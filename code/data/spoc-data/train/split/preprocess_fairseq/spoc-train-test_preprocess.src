TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integers cur, cnt with cur = 1, cnt = 0 ;  $  TAB1 create integer vector ans ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 if x is cur ;  $  TAB3 increment cnt ;  $  TAB3 increment cur ;  $  TAB2 else ;  $  TAB3 add element cnt to end of ans ;  $  TAB3 set cnt to 1 ;  $  TAB3 set cur to 2 ;  $  TAB2 if i is n - 1, add element cnt to end of ans ;  $  TAB1 print integer casted size of ans print newline ;  $  TAB1 for i = 0 to integer casted size of ans exclusive ;  $  TAB2 if i is greater than 0, print " " ;  $  TAB2 print ans[i] ;  $  TAB1 print newline ;
TAB1 let n be an integer ;  $  TAB1 while reading n ;  $  TAB2 let a be an integer array of length n ;  $  TAB2 let b be an integer array of length n ;  $  TAB2 let max be an int ;  $  TAB2 let count = 0 be an int ;  $  TAB2 read a n times ;  $  TAB2 set max = a at 0 ;  $  TAB2 for q = 1 to n exclusive ;  $  TAB3 if a at q is 1 then increment count, set b[count] to a[q-1] ;  $  TAB2 print count + 1 ;  $  TAB2 for j = 1 to count inclusive print b ;  $  TAB2 print a[n-1] ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 declare int array arr with n elements and int variable ct = 0 ;  $  TAB1 change i from 0 to n exclusive in a loop ;  $  TAB2 read input to arr[i] ;  $  TAB2 if arr[i] is equal to 1, increment ct ;  $  TAB1 print ct ;  $  TAB1 for i from 1 to n exclusive ;  $  TAB2 if arr[i] is equal to 1, print arr[i - 1] and " " ;  $  TAB1 print arr[n - 1] ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 i, j, k= int with k = 0 and a = int array of size n + 1 ;  $  TAB1 for i = 0 to n ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is 1 then increment k ;  $  TAB1 print k ;  $  TAB1 for i = 1 to n ;  $  TAB2 if a[i] is 1 print a[i - 1] and " " ;  $  TAB1 print a[n - 1] ;
TAB1 declare int variable n ;  $  TAB1 read n ;  $  TAB1 declare an array of integers a with size 1005 ;  $  TAB1 declare an array of integers ans with size 1005 ;  $  TAB1 for i from 1 to n inclusive, read a[i] ;  $  TAB1 create integer j = 0 ;  $  TAB1 loop i from 1 to n exclusive ;  $  TAB2 if a[i + 1] <= a[i], set ans[j] to a[i] and increment j ;  $  TAB1 set ans[j] to a[n] and increment j ;  $  TAB1 print j ;  $  TAB1 for i = 0 to j - 1 exclusive, print ans[i] and " " ;  $  TAB1 print ans[j - 1] ;
TAB0 maxn = const integer with maxn = 1e3 + 5 ;  $  TAB0 arr = integer array of size maxn ;  $  TAB0 stc = integer array of size maxn ;  $  TAB1 n, top = integers ;  $  TAB1 while read n ;  $  TAB2 top = 0 ;  $  TAB2 for i = 0 to n exclusive, readarr[i] ;  $  TAB2 i = integer ;  $  TAB2 for i = 0 to n - 1 exclusive ;  $  TAB3 if arr[i + 1] is 1, stc[increment top] = arr[i] ;  $  TAB2 stc[increment top] = arr[i] ;  $  TAB2 print top,stc[0] ;  $  TAB2 for i = 1 to top exclusive, print stc[i] ;  $  TAB2 print next line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 nxt = integer = 1 ;  $  TAB1 ans = integer vector ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 if x is not nxt, then push back the values of ans and insert a new element of nxt - 1 at the end of ans ;  $  TAB2 nxt = x + 1 ;  $  TAB1 push back the values of ans and insert a new element of nxt - 1 at the end of ans ;  $  TAB1 print size of ans in integer form ;  $  TAB1 for i = 0 to size of ans in integer form ;  $  TAB2 if i > 0, then print a space ;  $  TAB2 print ans[i] ;  $  TAB1 print endline ;
TAB1 a = int array of length 1001, n = int, s = int= 0 ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a at i is 1 increment sum ;  $  TAB1 print sum ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if a at i + 1 is 1 print a at i ;  $  TAB1 print a at n ;
TAB1 create integers n, c with c = 0, create integer array arr with size 1001 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] is 1 increment c ;  $  TAB1 print c print newline ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if arr[i] is 1, print arr[i-1] print " " ;  $  TAB1 print arr[n-1] print newline ;
TAB1 n =integer ;  $  TAB1 val = integer ;  $  TAB1 Read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i is greater than 0, print " " ;  $  TAB2 Read val ;  $  TAB2 print val - (val + 1) % 2 and a new line ;  $  TAB1 print a new line ;
TAB0 n = integer ;  $  TAB1 Read n ;  $  TAB1 a = array of n+10 integers ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read n values into array a ;  $  TAB2 if a[i] modulo 2 is 0, then set a[i] to a[i] - 1 ;  $  TAB1 print a[j] and a new line ;  $  TAB1 print a[n - 1] and a new line ;
TAB1 create integer n ;  $  TAB1 while read n is true ;  $  TAB2 create integer flag with flag = 1 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 create integer num ;  $  TAB3 read num ;  $  TAB3 if num is 0 ;  $  TAB4 if flag is true ;  $  TAB5 print num, set flag to 0 ;  $  TAB4 else ;  $  TAB5 print " " print num ;  $  TAB3 else if num % 2 is 0 ;  $  TAB4 if flag is true ;  $  TAB5 print num - 1, set flag to 0 ;  $  TAB4 else ;  $  TAB5 print " " print num - 1 ;  $  TAB3 else ;  $  TAB4 if flag is true ;  $  TAB5 print num, flag with flag = 0 ;  $  TAB4 else ;  $  TAB5 print " " print num ;  $  TAB2 print newline ;
TAB0 array of 1000 = a ;  $  TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 read in a until i = n inclusive ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 if a[i] modulo 2 is 0 then do the following a[i] -= 1 ;  $  TAB2 if i = n then do the following ;  $  TAB3 output a[i] ;  $  TAB2 else ;  $  TAB3 output a[i], ;
TAB0 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer array a with size n + 10 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] % 2 is 0, decrement a[i] by 1 ;  $  TAB1 for j = 0 to n - 1 exclusive, print a[j] print " " ;  $  TAB1 print a[n-1] print newline ;
TAB0 declare const int N = 1e5 + 50 ;  $  TAB0 declare ints T, n, m, L and R ;  $  TAB0 declare long long array a with size 2 * N ;  $  TAB1 read input to n ;  $  TAB1 for i from 0 to n * 2 exclusive, read a[i] ;  $  TAB1 if n <= 1 ;  $  TAB2 print "0" ;  $  TAB1 sort a from the start to the position 2 * n ;  $  TAB1 declare long long ans = (a[n - 1] - a[0]) * (a[2 * n - 1] - a[n]) ;  $  TAB1 declare long long C = a[2 * n - 1] - a[0] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare long long variable temp = C * (a[i + n - 1] - a[i]) ;  $  TAB2 set ans to min of ans and temp ;  $  TAB1 print ans ;
TAB1 n = long long ;  $  TAB1 while the loop reads n ;  $  TAB2 a = long long array of size 2 * n +10 ;  $  TAB2 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB2 sort a in ascending order ;  $  TAB2 ans = long long = (a[n - 1] - a[0]) * (a[2 * n - 1] - a[n]) ;  $  TAB2 for i = 1 to n exclusive, ans = the minimum value between ans and (a[2 * n - 1] - a[0]) * (a[i + n - 1] - a[i]) ;  $  TAB2 print ans ;
TAB0 create constant integer sz with sz = 200010 ;  $  TAB0 create long long integer array a with size sz ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 2 * n exclusive, read [i] ;  $  TAB1 sort elements from a to a + 2 * n ;  $  TAB1 create long long integer ans with ans = (a[n - 1] - a[0]) * (a[2 * n - 1] - a[n]) ;  $  TAB1 for i = n to 2 * 2 exclusive, set ans to minimum of ( ans and (a[2 * n - 1] - a[0]) * (a[i] - a[i - n + 1]) ) ;  $  TAB1 print ans print newline ;
TAB0 set N to 2e6 + 5 ;  $  TAB0 create long long a[N] ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i=0 to 2*n, read a[i] ;  $  TAB1 sort elements between a and a + 2*n ;  $  TAB1 set ans = (a[n - 1] - a[0]) * (a[2 * n - 1] - a[n]) ;  $  TAB1 for i=1 to n exclusive, set and to min(ans, (a[i + n - 1] - a[i]) * (a[2 * n - 1] - a[0])) ;  $  TAB1 print ans ;
TAB0 N = const integer with N = 2e5 + 50 ;  $  TAB0 M = const integer with M = 1e6 ;  $  TAB0 oo = const long long with oo = 1e18 ;  $  TAB0 mod = const integer mod = 1e9 + 7 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a(2 * n) = vector of long long ;  $  TAB1 for i = 0 to n * 2 exclusive, read a[i] ;  $  TAB1 sort a.begin() and a.end() ;  $  TAB1 ans = long long with ans = (a[n - 1] - a[0]) * (a.back() - a[n]) ;  $  TAB1 for i = 1 to n exclusive, ans = min(ans, (a[i + n - 1] - a[i]) * (a.back() - a[0])) ;  $  TAB1 print ans ;
TAB0 declare const int INF = 0x3f3f3f3f ;  $  TAB0 create const int maxa = 1e5 + 10 ;  $  TAB0 declare int array a with size maxa << 1 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n and loop further ;  $  TAB2 declare int variable i ;  $  TAB2 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB2 sort a ;  $  TAB2 declare long long x = a[n - 1] - a[0] ;  $  TAB2 create long long y = a[2 * n - 1] - a[n] ;  $  TAB2 declare long long minsq = x * y ;  $  TAB2 set x to a[2 * n - 1] - a[0] ;  $  TAB2 for i from 1 to n exclusive ;  $  TAB3 set y to a[i + n - 1] - a[i] ;  $  TAB3 change minsq to min of minsq and x * y ;  $  TAB2 print minsq ;
TAB0 create integer N ;  $  TAB0 create long long array A with size 200005 ;  $  TAB1 read N ;  $  TAB1 for i = 0 to 2 * N - 1 inclusive, read A[i] ;  $  TAB1 sort elements from A to A + 2 * N ;  $  TAB1 create long long Ans with Ans = (A[N - 1] - A[0]) * (A[2 * N - 1] - A[N]) ;  $  TAB1 for i = 1 to N - 1 inclusive, set Ans to minimum of Ans and (A[2 * N - 1] - A[0]) * (A[i + N - 1] - A[i]) ;  $  TAB1 print Ans print '\n' ;
TAB0 niz = array of integers of length 200005 ;  $  TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2 * n inclusive , read niz[i] ;  $  TAB1 sort the values niz + 1 and niz + 2 * n + 1 ;  $  TAB1 let dx be a integer with dx = niz[n] - niz[1] ;  $  TAB1 let dy be a integer with dy = niz[2 * n] - niz[n + 1] ;  $  TAB1 let p be a long integer with p = 0 ;  $  TAB1 the value (long long int)dx * dy is initialized to p ;  $  TAB1 set the long integer tren to 0 ;  $  TAB1 for i = n + 1 to 2 * n - 1 inclusive ;  $  TAB2 the long integer value of (niz[i] - niz[i - n + 1]) * (niz[2 * n] - niz[1]) is assigned to tren ;  $  TAB2 if tren is less than p , the value of p is equal to tren ;  $  TAB1 print p and newline ;
TAB0 declare long long n and long long array a with size 1000001 ;  $  TAB1 read n ;  $  TAB1 multiply n by 2 ;  $  TAB1 loop i from 1 to n inclusive, read a[i] ;  $  TAB1 sort a from element 1 to n + 1 ;  $  TAB1 create long long ans = (a[n / 2] - a[1]) * (a[n] - a[n / 2 + 1]) ;  $  TAB1 loop i from 2 to n / 2 + 1 inclusive, assign min of ans and (a[i + n / 2 - 1] - a[i]) * (a[n] - a[1]) to ans ;  $  TAB1 print ans ;
TAB0 declare long long array a with size 202000 ;  $  TAB1 declare integer n ;  $  TAB1 read input to n ;  $  TAB1 for i = 1 to n << 1 inclusive, read a[i] ;  $  TAB1 sort a fron index 1 to 1 + n + n ;  $  TAB1 long long s = 1ll << 62 ;  $  TAB1 set s to min of s and (a[n] - a[1]) * (a[n << 1] - a[n + 1]) ;  $  TAB1 for i from 2 to n inclusive, change s to min of s and (a[n << 1] - a[1]) * (a[n + i - 1] - a[i]) ;  $  TAB1 print s ;
TAB0 flag = int ;  $  TAB0 n, m, len = int ;  $  TAB0 a = long long array of size 200005 ;  $  TAB0 ans, temp = long long ;  $  TAB1 loop while reading n ;  $  TAB2 read 2 * n values into a ;  $  TAB2 sort a ;  $  TAB2 set ans to (a[2 * n - 1] - a[n]) * (a[n - 1] - a[0]) ;  $  TAB2 set temp to a[2 * n - 1] - a[0] ;  $  TAB2 for i = 1 to n set ans to min of ans and temp * (a[i + n - 1] - a[i]) ;  $  TAB2 print ans ;
TAB0 create integer flag ;  $  TAB0 create integers n, m, len ;  $  TAB0 create long long array a with size 200005 ;  $  TAB0 create long longs ans, temp ;  $  TAB1 while read n is true ;  $  TAB2 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB2 sort elements from a to a + n + n ;  $  TAB2 set ans to (a[2 * n - 1] - a[n]) * (a[n - 1] - a[0]) ;  $  TAB2 set temp to a[2 * n - 1] - a[0] ;  $  TAB2 for i = 1 to n exclusive, set ans to minimum of ans and temp * (a[i + n - 1] - a[i]) ;  $  TAB2 print ans print newline ;
TAB0 maxn = const integer with maxn = 2e5 + 10 ;  $  TAB0 a = array of size maxn long long ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 ans = long long with ans = 0 ;  $  TAB1 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB1 sort a and a + 2 * n ;  $  TAB1 ans = (a[n - 1] - a[0]) * (a[2 * n - 1] - a[n]) ;  $  TAB1 for i = 1 to n exclusive, ans = min((a[2 * n - 1] - a[0]) * (a[i + n - 1] - a[i]), ans) ;  $  TAB1 print ans ;
TAB0 n = integer ;  $  TAB0 a = long long array of size 200001, ans = long long ;  $  TAB1 read n ;  $  TAB1 for i = 1 to (left shift n 1 place), read a[i] ;  $  TAB1 sort a + 1 and a + (n << 1) + 1 ;  $  TAB1 ans = (a[n] - a[1]) * (a[shift n 1 place] - a[n + 1]) ;  $  TAB1 for i = 1 to n exclusive, ans = min((a[left shift n 1 place] - a[1]) * (a[n + i] - a[i + 1]), ans) ;  $  TAB1 print ans ;
TAB0 let in be long long array with size 200010 ;  $  TAB0 create ints n and n2 ;  $  TAB0 declare long long ans ;  $  TAB1 read n ;  $  TAB1 change n2 to n * 2 ;  $  TAB1 for integer i = 0 to n2 exclusive, read in[i] ;  $  TAB1 sort n2 elements of in ;  $  TAB1 assign (in[n - 1] - in[0]) * (in[n2 - 1] - in[n]) to ans ;  $  TAB1 for i from 1 to n exclusive, set ans to min of ans and in[n - 1 + i] - in[i]) * (in[n2 - 1] - in[0] ;  $  TAB1 print ans and '\n' ;
TAB0 create long long array of length 200020 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i=1 to 2*n inclusive, read a[i] ;  $  TAB1 sort elements between a+1 and a + 2 * n + 1 ;  $  TAB1 set min1 to (a[n] - a[1]) * (a[2 * n] - a[n + 1]) ;  $  TAB1 for i=2 to n+1 inclusive, assign min of min1 and (a[2 * n] - a[1]) * (a[i + n - 1] - a[i]) to min1 ;  $  TAB1 print min1 ;
TAB0 create long long array a with size 202000 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to i is less than or equal to ( n bitshift left 1 ), incrementing i, read a[i] ;  $  TAB1 sort elements from a + 1 to a + 1 + n + n ;  $  TAB1 create long long s with s = (s, (a[n] - a[1]) * (a[n bitshift left 1] - a[n + 1])) ;  $  TAB1 for i = 2 to n inclusive, set s to minimum of ( s and (a[n bitshift left 1] - a[1]) * (a[n + i - 1] - a[i]) ;  $  TAB1 print s print newline ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create long longs vector a with n * 2 elements ;  $  TAB1 for i = 0 to n*2 exclusive, read a[i] ;  $  TAB1 sort a ;  $  TAB1 create long long ans = LLONG_MAX ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 if i = 0 ;  $  TAB3 assign min of ans and (a[n - 1] - a[0]) * (a[n * 2 - 1] - a[n]) to ans ;  $  TAB2 else ;  $  TAB3 assign min of ans and (a[i + n - 1] - a[i]) * (a[n * 2 - 1] - a[0]) to ans ;  $  TAB1 print ans ;
TAB0 create const int maxn = 1e5 + 2 ;  $  TAB0 let a be long long array with size maxn * 2 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create long long m = n * 2 ;  $  TAB1 for i from 1 to m inclusive, read input to a[i] ;  $  TAB1 sort a from index 1 to m + 1 ;  $  TAB1 create long long ans = 1e18 ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 if i = 1 ;  $  TAB3 change ans to min of ans and (a[n] - a[1]) * (a[m] - a[n + 1]) ;  $  TAB2 else ;  $  TAB3 change ans to min of ans and (a[m] - a[1]) * (a[n + i - 1] - a[i]) ;  $  TAB1 print ans ;
TAB0 create constant integer MAXN with MAXN = integer casted ( 2 * 1e5 + 5 ) ;  $  TAB0 create integer n ;  $  TAB0 create long long array a with size MAXN ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n + n exclusive, read a[i] ;  $  TAB1 sort elements from a to a + n + n ;  $  TAB1 if n is less than or equal to 1 ;  $  TAB2 print "0" print newline ;  $  TAB1 else ;  $  TAB2 create long long ans with ans = a[n-1]-a[0] ;  $  TAB2 set ans to ans * ( a[n + n - 1] - a[n] ) ;  $  TAB2 create long long l with l = a[n + n - 1] - a[0] ;  $  TAB2 for i = 1 to n inclusive, set ans to minimum of ( ans and ( l * (a[i + n - 1] - a[i]) ) ) ;  $  TAB2 print ans print newline ;
TAB1 n, x = integers ;  $  TAB1 read n ;  $  TAB1 set cnt1, cnt2 = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 set cnt1 = cnt1 + x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 set cnt2 = cnt2 + x ;  $  TAB1 if cnt1 >= cnt2 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 declare long long integer variables n, i and j ;  $  TAB1 read n ;  $  TAB1 declare long long integers s1 and s2 = 0 and long long integer arrays a and b with size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increase s1 by a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 increase s2 by b[i] ;  $  TAB1 if s1 >= s2 ;  $  TAB2 print "YES" and '\n' ;  $  TAB1 else ;  $  TAB2 print "NO" and '\n' ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 sumx = integer, set to 0 ;  $  TAB1 sumy = integer, set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 x =integer ;  $  TAB2 Read x ;  $  TAB2 set sumx to sumx + x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 y =integer ;  $  TAB2 Read y ;  $  TAB2 set sumy to sumy + y ;  $  TAB1 if sumy is less than or equal to sumx ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 x, y, n = integers with x, y = 0 ;  $  TAB1 a = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 set x to x + a ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 set y to y + a ;  $  TAB1 if x >= y ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 create integer arrays x, y, with x size 51, y size 51 ;  $  TAB1 create integers n, sum_x, sum_y, with sum_x = 0, sum_y = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read x[i], increment sum_x by x[i] ;  $  TAB1 for i = 0 to n exclusive, read y[i], increment sum_y by y[i] ;  $  TAB1 if sum_x is greater than or equal than sum_y ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 create n, sum, s as int set sum and s to 0 ;  $  TAB1 read in to n ;  $  TAB1 create int array arr and ar both size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read in to arr[i] ;  $  TAB2 increase sum by arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read in to ar[i] ;  $  TAB2 increase s by ar[i] ;  $  TAB1 if s <= sum ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 let is be integer array with size 105 ;  $  TAB1 create integers n, m, a and b ;  $  TAB1 read n and m ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read a and b ;  $  TAB2 for j = a to b inclusive set is[j] to 1 ;  $  TAB1 declare integer vector ans ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 if is[i] is 0, push i into ans ;  $  TAB1 print length of ans and "\n" ;  $  TAB1 for i = 0 to length of ans exclusive ;  $  TAB2 if i != length of ans - 1 ;  $  TAB3 print ans[i] and " " ;  $  TAB2 else ;  $  TAB3 print ans[i] and "\n" ;
TAB1 a, tam, comeco, fim = int witha = 0 and tam = 0 and comeco = 0 and fim = 0 ;  $  TAB1 read a then tam ;  $  TAB1 isThere = bool array of size tam + 1 ;  $  TAB1 set all values of isThere to false ;  $  TAB1 for b = 0 to a ;  $  TAB2 read comeco then fim ;  $  TAB2 for c = comeco to fim inclusive set siThere[c] to true ;  $  TAB1 resp = int with resp = 0 ;  $  TAB1 presentes = int array of size tam + 1 ;  $  TAB1 ordem = string with ordem = "" ;  $  TAB1 for b = 1 to tam inclusive ;  $  TAB2 is isThere[b] is false ;  $  TAB3 set presentes[resp] to b ;  $  TAB3 increment resp ;  $  TAB1 print resp ;  $  TAB1 for b = 0 to resp ;  $  TAB2 print presentes[b] ;  $  TAB2 if b is resp - 1 ;  $  TAB3 print newline ;  $  TAB2 else ;  $  TAB3 print " " ;
TAB1 ax, ay, bx, by, cx, cy, n =integers ;  $  TAB1 Read ax, ay, bx, by, cx, cy, n ;  $  TAB1 if cx is greater than bx ;  $  TAB2 if cy is greater than by ;  $  TAB3 if (ax is less than cx and ax is greater than bx) OR (ay is less than cy and ay is greater than by) ;  $  TAB4 print NO and a new line ;  $  TAB3 else do the following ;  $  TAB4 print YES and a new line ;  $  TAB2 else do the following ;  $  TAB3 if (ax is less than cx and ax is greater than bx) OR (ay is greater than cy and ay is less than by) ;  $  TAB4 print NO and a new line ;  $  TAB3 else do the following ;  $  TAB4 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 if cy is greater than by ;  $  TAB3 if (ax is greater than cx and ax is less than bx) OR| (ay is less than cy and ay is greater than by ;  $  TAB4 print NO and a new line ;  $  TAB3 else do the following ;  $  TAB4 print YES and a new line ;  $  TAB2 else do the following ;  $  TAB3 if (ax is greater than cx and ax is less than bx) OR| (ay is greater than cy and ay is less than by) ;  $  TAB4 print NO and a new line ;  $  TAB3 else do the following ;  $  TAB4 print YES and a new line ;
TAB1 integers = n,ax,ay,bx,by,cx,cy ;  $  TAB1 read n,ax,ay,bx,by,cx,cy ;  $  TAB1 if (bx - ax) * (cx - ax)is less than 0 or (by - ay) * (cy - ay) < 0 then do the following ;  $  TAB2 output NO ;  $  TAB1 else ;  $  TAB2 print YES ;
TAB1 declare integer variable n ;  $  TAB1 read input to n ;  $  TAB1 create integers x1 and y1 ;  $  TAB1 read x1 and y1 ;  $  TAB1 declare ints x2 and y2 ;  $  TAB1 read x2 and y2 ;  $  TAB1 declare integers x3 and y3 ;  $  TAB1 read x3 and y3 ;  $  TAB1 if x2 < x1 and y2 < y1 and x3 < x1 and y3 < y1 ;  $  TAB2 print "YES" ;  $  TAB1 else if x2 > x1 && y2 > y1 && x3 > x1 && y3 > y1 ;  $  TAB2 print "YES" ;  $  TAB1 else if x2 > x1 && x3 > x1 && y3 < y1 && y2 < y1 ;  $  TAB2 print "YES" ;  $  TAB1 else if x2 < x1 && x3 < x1 && y2 > y1 && y3 > y1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 n, qx, qy, kx, ky, tx, ty = integers ;  $  TAB1 Read n ;  $  TAB1 Read qx ;  $  TAB1 Read qy ;  $  TAB1 Read kx ;  $  TAB1 Read ky ;  $  TAB1 Read tx ;  $  TAB1 Read ty ;  $  TAB1 if kx is less than qx ;  $  TAB2 if ky is less than qy ;  $  TAB3 if tx is less than qx and ty is less than qy ;  $  TAB4 print YES and a new line ;  $  TAB3 else do the following ;  $  TAB4 print NO and a new line ;  $  TAB2 else do the following ;  $  TAB3 if tx is less than qx and ty is greater than qy ;  $  TAB4 print YES and a new line ;  $  TAB3 else do the following ;  $  TAB4 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 if ky is less than qy ;  $  TAB3 if tx is greater than qx and ty is less than qy ;  $  TAB4 print YES and a new line ;  $  TAB3 else do the following ;  $  TAB4 print NO and a new line ;  $  TAB2 else do the following ;  $  TAB3 if tx is greater than qx and ty is greater than qy ;  $  TAB4 print YES and a new line ;  $  TAB3 else do the following ;  $  TAB4 print NO and a new line ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 integers = x,y,x1,y1,x2,y2 ;  $  TAB1 read input x,y,x1,y1,x2,y2 ;  $  TAB1 integers = flag = 1 ;  $  TAB1 if x1 is x or y1 then do the following ;  $  TAB1 if abs is abs(y - y1 then do the following or abs(x - x2 ;  $  TAB2 set flag to 0 ;  $  TAB1 else if x1 is less than x and x2 > x then do the following ;  $  TAB2 set flag to 0 ;  $  TAB1 else if x1 > x and x2 is less than x then do the following ;  $  TAB2 set flag to 0 ;  $  TAB1 else if y1 is less than y and y2 > y then do the following ;  $  TAB2 set flag to 0 ;  $  TAB1 else if y1 > y and y2 is less than y then do the following ;  $  TAB2 set flag to 0 ;  $  TAB1 if flag is true ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 boolean function search with int arguments ax, ay, bx, by, cx and cy ;  $  TAB1 if bx < ax and cx < ax and by < ay and cy < ay ;  $  TAB2 return true ;  $  TAB1 else if bx < ax and cx < ax and by > ay and cy > ay ;  $  TAB2 return true ;  $  TAB1 else if bx > ax and cx > ax and by < ay and cy < ay ;  $  TAB2 return true ;  $  TAB1 else if bx > ax and cx > ax and by > ay and cy > ay ;  $  TAB2 return true ;  $  TAB1 return false ;  $  TAB1 create ints n, ax, ay, bx, by, cx and cy ;  $  TAB1 read n, ax, ay, bx, by, cx and cy ;  $  TAB1 if search(ax, ay, bx, by, cx, cy) returns true ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n, a, b, c = long long int ;  $  TAB1 read n ;  $  TAB1 if n is a multiple of 3 or n mod 3 is 1 ;  $  TAB2 set a to n - 2 ;  $  TAB2 set b to 1 ;  $  TAB2 set c to 1 ;  $  TAB1 else if n mod 3 is 2 ;  $  TAB2 set a to n - 3 ;  $  TAB2 set b to 1 ;  $  TAB2 set c to 2 ;  $  TAB1 print a and b and c ;
TAB1 declare integer n ;  $  TAB1 declare integer variable c8 = 0 ;  $  TAB1 read n ;  $  TAB1 read from the input input and ignore it ;  $  TAB1 let s be char array with size 101 ;  $  TAB1 read s ;  $  TAB1 if n >= 11 ;  $  TAB2 declare integer r = n / 11 ;  $  TAB2 loop i from 0 while s[i] !=0, incrementing i ;  $  TAB3 if s[i] is equal to '8', increment c8 ;  $  TAB3 if c8 is equal to r, break the loop ;  $  TAB2 print c8 ;  $  TAB1 print c8 ;
TAB1 create integers n, num8, numn and num ;  $  TAB1 create character array str with 101 element ;  $  TAB1 read n and loop further ;  $  TAB2 set num8 to 0 ;  $  TAB2 read input to str ;  $  TAB2 for i from 0 to n exclusive ;  $  TAB3 if str[i] = '8', increment num8 by one ;  $  TAB2 assign n / 11 to numn ;  $  TAB2 if num8 is greater than numn ;  $  TAB3 change num to numn ;  $  TAB2 else ;  $  TAB3 change num to num8 ;  $  TAB2 print num ;
TAB1 st, s = string ;  $  TAB1 i, a, b, count = int with count = 0 ;  $  TAB1 read a then st ;  $  TAB1 set b to a / 11 ;  $  TAB1 for i = 0 to a ;  $  TAB2 if st[i] is '8' then increment count ;  $  TAB1 if count is less than b ;  $  TAB2 print count ;  $  TAB1 else ;  $  TAB2 print b ;
TAB1 s = character array of size 101 ;  $  TAB1 n, i = integers, sum8 = integer = 0, sum = integer = 0, total = integer = 0 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is 8, then increase sum8 by 1 ;  $  TAB2 increase sum by 1 ;  $  TAB1 if sum8 >= sum / 11 ;  $  TAB2 total = sum / 11 ;  $  TAB1 else ;  $  TAB2 total = sum8 ;  $  TAB1 print total ;
TAB1 create character array s with size 101 ;  $  TAB1 create integers n, i, sum8, sum, total, with sum8 = 0, sum = 0, total = 0 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is '8', increment sum8 ;  $  TAB2 increment sum ;  $  TAB1 if sum8 is greater than or equal to sum / 11 ;  $  TAB2 set total to sum / 11 ;  $  TAB1 else ;  $  TAB2 set total to sum8 ;  $  TAB1 print total print newline ;
TAB1 create string s ;  $  TAB1 create int n and sum, set to sum 0 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 for i=0 to length of s exclusive ;  $  TAB2 if s[i] equal to 8, increment sum ;  $  TAB1 if n/11 greater than 11 ;  $  TAB2 print n/11 ;  $  TAB1 else ;  $  TAB2 print sum and a newline ;
TAB0 set N to 1e6 + 10 ;  $  TAB0 mod = 998244353 ;  $  TAB0 create int n ;  $  TAB0 create string x ;  $  TAB0 create map m from int to int ;  $  TAB1 read n and x ;  $  TAB1 for i=0 to n exclusive, increment m[x[i] - 0] ;  $  TAB1 set s to size of x ;  $  TAB1 print min of m[8] and s/11 ;
TAB1 n, k = integers with k = 0 ;  $  TAB1 Read n ;  $  TAB1 s=string ;  $  TAB1 Read s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is 8, then increment k ;  $  TAB1 print minimum value of n / 11 and k and a new line ;
TAB0 MAX = const int with MAX = 100000 ;  $  TAB0 IN = const int with INF = 1000000001 ;  $  TAB0 a = int array of size MAX ;  $  TAB0 n, sum = int with sum = 0 ;  $  TAB0 s = string ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 len = int with len = length of s ;  $  TAB1 for i = 0 to len increment sum if s[i] is '8' ;  $  TAB1 res = int with res = n / 11 ;  $  TAB1 if sum is less or equal to res ;  $  TAB2 print sum ;  $  TAB1 else ;  $  TAB2 print res ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 number =string ;  $  TAB1 Read number ;  $  TAB1 has_eight =integer with 0 ;  $  TAB1 for i = 0 to length of string number exclusive ;  $  TAB2 if number[i] is 8, then increment has_eight ;  $  TAB1 if n is less than 11 OR has_eight is 0 ;  $  TAB2 print 0 and a new line ;  $  TAB1 if (n / 11) is greater than or equal to has_eight ;  $  TAB2 print has_eight and a new line ;  $  TAB1 else if (n / 11) is less than has_eight ;  $  TAB2 print n / 11 and a new line ;
TAB1 declare integer variables n and count with count = 0 ;  $  TAB1 read n ;  $  TAB1 create character c ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read c ;  $  TAB2 if c = '8', increment count ;  $  TAB1 if n < 11 or count = 0 ;  $  TAB2 print 0 ;  $  TAB1 print min of count and n / 11 ;
TAB0 k, i, n, ans, m = integers ;  $  TAB0 s = string ;  $  TAB1 read n, s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is 8, increment k ;  $  TAB1 ans = min of k and n / 11 ;  $  TAB1 print ans ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 eight, other = int with eight = 0 and other = 0 ;  $  TAB1 for i= 0 to n ;  $  TAB2 if s[i] is '8' ;  $  TAB3 increment eight ;  $  TAB2 else ;  $  TAB3 increment other ;  $  TAB1 if eight is 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 ans = int with ans = other / 10 ;  $  TAB2 if ans is greater than eight ;  $  TAB3 print eight ;  $  TAB2 if eight - ans is 0 ;  $  TAB3 print ans ;  $  TAB2 else ;  $  TAB3 print (((eight - ans) + (other mod 10)) / 11) + ans ;
TAB1 create integers n, i and cnt where i and cnt = 0 ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 while s[i] != '\0' ;  $  TAB2 if s[i] = '8', increment cnt by one ;  $  TAB2 increment i ;  $  TAB1 if n >= 11 and n / 11 <= cnt and cnt != 0 ;  $  TAB2 print n / 11 and "\n" ;  $  TAB1 else if n >= 11 && n / 11 >= cnt && cnt != 0 ;  $  TAB2 print cnt and "\n" ;  $  TAB1 else ;  $  TAB2 print "0\n" ;
TAB1 create string s ;  $  TAB1 declare integers n and sum with sum = 0 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 for i from 0 to length of s exclusive ;  $  TAB2 if s[i] = '8', increment sum ;  $  TAB1 if n / 11 is less than sum ;  $  TAB2 print n / 11 ;  $  TAB1 else ;  $  TAB2 print sum ;
TAB1 declare int variable n ;  $  TAB1 declare string variable num ;  $  TAB1 read n and num ;  $  TAB1 declare int count = 0 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 if num[i] is equal to '8', increment count by one ;  $  TAB1 print count if n / 11 > count and n / 11 otherwise ;
TAB1 n, i, no_of_8, groups =integers with no_of_8 = 0 ;  $  TAB1 c = character ;  $  TAB1 Read n ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 Read c ;  $  TAB2 f c is 8, then increment no_of_8 ;  $  TAB1 set groups to n / 11 ;  $  TAB1 if no_of_8 is greater than or equal to groups ;  $  TAB2 print groups and a new line ;  $  TAB1 else do the following ;  $  TAB2 print no_of_8 and a new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 create char array s with 101 element ;  $  TAB1 read s ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 if s[i] = '8', increment ans by 1 ;  $  TAB1 if ans is equal to 0 or n / 11 is equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else if ans > n / 11 ;  $  TAB2 print n / 11 ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB1 create int ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 n and k = int ;  $  TAB2 read n, k ;  $  TAB2 set flag =0 ;  $  TAB2 for i=0 to n/k exclusive ;  $  TAB3 for j=0 to k exclusive ;  $  TAB4 print char(97+j) ;  $  TAB4 assign j to flag ;  $  TAB2 for i=0 to n - (n/k) * k exclusive, print char(97 + flag) ;  $  TAB2 print a newline ;
TAB1 create integer n ;  $  TAB1 create string s ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 create string t with t = "" ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer k with k = (i * (i + 1)) / 2 ;  $  TAB2 if k is greater than or equal to n, break loop ;  $  TAB2 set t to t + s[k] ;  $  TAB1 print t print newline ;
TAB0 create long longs x, y and z, with z = 1 ;  $  TAB0 declare string variables s and ss ;  $  TAB1 read x and s ;  $  TAB1 for integer i = 0 to x exclusive ;  $  TAB2 increase ss by s[i] ;  $  TAB2 increase i by z ;  $  TAB2 increment z ;  $  TAB1 print ss and a new line ;
TAB1 v = vector of characters ;  $  TAB1 s = vector of characters ;  $  TAB1 count and size are integers, with count = 1 ;  $  TAB1 declare character variable called c ;  $  TAB1 read size ;  $  TAB1 for integer i = 0 to size exclusive ;  $  TAB2 read c ;  $  TAB2 push c into v ;  $  TAB1 let in and i be integers, with i = 0 ;  $  TAB1 while i is less than size ;  $  TAB2 if i = 0 ;  $  TAB3 push v[i] into s ;  $  TAB3 increase i by one ;  $  TAB2 else ;  $  TAB3 set value of in to count ;  $  TAB3 for integer j = 0 to in exclusive ;  $  TAB3 if i is less than size push v[i] into s ;  $  TAB3 increase count ;  $  TAB1 for integer i = 0 to length of s exclusive, print s[i] ;  $  TAB1 print new line ;
TAB1 declare integer variable called n ;  $  TAB1 read n ;  $  TAB1 let a be string ;  $  TAB1 read a ;  $  TAB1 for integer i = 1 while i * (i + 1) / 2 < n + 1, print a[(i * (i + 1) / 2) - 1] ;  $  TAB1 print new line ;
TAB1 create integers n, sum, index ;  $  TAB1 create character arrays s, a, with s size 55, a size 55 ;  $  TAB1 read n read s ;  $  TAB1 set sum to index to 0 ;  $  TAB1 for i = 0 ;  $  TAB2 increment index by i ;  $  TAB2 if index is greater than or equal to n, break loop ;  $  TAB2 set a[increment sum] to s[index] ;  $  TAB1 set a[sum] to '\0' ;  $  TAB1 print a print newline ;
TAB0 define function compare with arguments p1 and p2 of type pair of string and int ;  $  TAB1 return true if p1.second > p2.second or false if it is not ;  $  TAB1 n is integer ;  $  TAB1 read n ;  $  TAB1 declare string called s ;  $  TAB1 read s ;  $  TAB1 declare string variable called ans = " " ;  $  TAB1 declare integer called h = 1 ;  $  TAB1 declare integer variable called c = 1 ;  $  TAB1 for integer i = 0 to length of s exclusive ;  $  TAB2 if c = h ;  $  TAB3 increase ans by s[i] ;  $  TAB3 increment h ;  $  TAB3 c = 1 ;  $  TAB2 else ;  $  TAB3 increase c by one ;  $  TAB1 print ans and a new line ;  $  TAB1 read n ;
TAB0 s, d = strings ;  $  TAB0 n, i, l = long long ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 while n is not 0 ;  $  TAB2 increment l ;  $  TAB2 n=n-l ;  $  TAB1 for i=1 to less or equal l ;  $  TAB2 sd = sd + s[0] ;  $  TAB2 Erases the portion of the string ;  $  TAB1 print sd and new line ;
TAB1 create string a ;  $  TAB1 create integers n, num, l with num = 0, l = 2 ;  $  TAB1 read n read a ;  $  TAB1 while true ;  $  TAB2 if num is less than n - 1 ;  $  TAB3 print a[num] ;  $  TAB3 increment num by l ;  $  TAB3 increment l ;  $  TAB2 else ;  $  TAB3 print a[num] print newline ;  $  TAB3 break loop ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create string palabra ;  $  TAB1 read palabra ;  $  TAB1 create string answer with answer = "" ;  $  TAB1 create long long aumento with aumento = 1 ;  $  TAB1 for i = 0 to n exclusive, setting i to i + aumento ;  $  TAB2 add element substring of palabra from i to 1 to end of answer ;  $  TAB2 increment aumento ;  $  TAB1 print answer print newline ;
TAB1 create integers n, sum, index ;  $  TAB1 create character arrays s, a, with s size 56, a size 56 ;  $  TAB1 read n read s ;  $  TAB1 set sum to index to 0 ;  $  TAB1 for i = 0 ;  $  TAB2 increment index by i ;  $  TAB2 if index is greater than or equal to n, break loop ;  $  TAB2 set a[increment sum] to s[index] ;  $  TAB1 set a[sum] to '\0' ;  $  TAB1 print a print newline ;
TAB1 declare integer called n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 let i be integer = 2 ;  $  TAB1 ans is an empty string ;  $  TAB1 ans = ans + s[0] ;  $  TAB1 j is integer = 3 ;  $  TAB1 while i <= n - 1 ;  $  TAB2 ans = ans + s[i] ;  $  TAB2 i = i + j ;  $  TAB2 increment j ;  $  TAB1 print ans and a new line ;
TAB1 declare string variable a ;  $  TAB1 declare integer variables n and s with s = 0 ;  $  TAB1 read n and a ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 increase s by i ;  $  TAB2 if s <= n print a[s - i] ;  $  TAB1 print new line ;
TAB1 n is integer ;  $  TAB1 read n ;  $  TAB1 let a be an array of characters of length n ;  $  TAB1 for i = 0 to n exclusive put input to a[i] ;  $  TAB1 let incr be integer = 1 ;  $  TAB1 for integer i = 0 to n exclusive incrementing by incr ;  $  TAB2 print a[i] ;  $  TAB2 increase incr ;  $  TAB1 print new line ;
TAB1 create integer n ;  $  TAB1 let s be an array of characters of length 100 ;  $  TAB1 read n and s ;  $  TAB1 t is integer = 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 print s[i] ;  $  TAB2 increase t by one ;  $  TAB1 print new line ;
TAB1 create integers n and it; it = 1 ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 for i = 0 to n exclusive with step of it ;  $  TAB2 increase it by one ;  $  TAB2 print s[i] ;  $  TAB1 print new line ;
TAB0 a and b are char arrays with size 60 ;  $  TAB1 let n be integer ;  $  TAB1 read n in a loop ;  $  TAB2 call memset(b, 0 and sizeof(b)) ;  $  TAB2 read n elements into a starting from index 1 ;  $  TAB2 k and d are integers = 0 ;  $  TAB2 for i = 1 to n inclusive, incrementing by k ;  $  TAB3 set b[d] to a[i] ;  $  TAB3 increment d ;  $  TAB3 increase k ;  $  TAB2 print b and a new line ;
TAB1 declare integer variable called n ;  $  TAB1 read n ;  $  TAB1 let a be an array of characters of size 60 ;  $  TAB1 read a ;  $  TAB1 j is integer = 1 ;  $  TAB1 for i = 0 to n exclusive, incrementing i by j ;  $  TAB2 print a[i] ;  $  TAB2 increase j by one ;  $  TAB1 print new line ;
TAB1 set s to character array of length 60 ;  $  TAB1 n, ans = integers with ans set to 0 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 for i to n inclusive incremented by ans ;  $  TAB2 increment ans by 1 ;  $  TAB2 print s[i] ;  $  TAB1 print new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create string ans ;  $  TAB1 create integers cnt, sum with cnt = 0, sum = 0 ;  $  TAB1 for i = 0 to n exclusive, incrementing i by cnt ;  $  TAB2 add element s[i] to end of ans ;  $  TAB2 increment cnt ;  $  TAB1 print ans print newline ;
TAB1 create integers n, cnt, i with cnt = 1, i = 0 ;  $  TAB1 create string s ;  $  TAB1 read n read s ;  $  TAB1 while true ;  $  TAB2 print s[i] ;  $  TAB2 increment i by cnt ;  $  TAB2 increment cnt ;  $  TAB2 if i + cnt is greater than n, break loop ;  $  TAB1 print newline ;
TAB1 declare integer variables l, r, n and k ;  $  TAB1 read k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read l and r ;  $  TAB2 print l, ' ' and r - (r modulo l) ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 l, r, R = long long arrays of size 1000 each ;  $  TAB1 for i = 0 to n ;  $  TAB2 read l[i] then r[i] ;  $  TAB2 set R[i] to r[i] / l[i] ;  $  TAB1 for i = 0 to n print l[i] then " " then l[i] * R[i] ;
TAB1 create integers t, n, l ;  $  TAB1 read t ;  $  TAB1 while decrement t is true ;  $  TAB2 read n read l ;  $  TAB2 print n print " " print ( l / n ) * n print newline ;
TAB1 create integers T, l, r ;  $  TAB1 read T ;  $  TAB1 for i = 1 to T inclusive ;  $  TAB2 read l read r ;  $  TAB2 print l print " " print l * ( r / l ) print newline ;
TAB1 create integer numberOfInputs ;  $  TAB1 read numberOfInputs ;  $  TAB1 create long longs input1 and input2 ;  $  TAB1 while numberOfInputs > 0, decrement it and keep looping ;  $  TAB2 read input1 and input2 ;  $  TAB2 create long long div = input2 / input1 ;  $  TAB2 create long long answer = input1 * div ;  $  TAB2 print input1, " " and answer ;
TAB0 create integers T, l ,r ;  $  TAB1 create integers i, j ;  $  TAB1 read T ;  $  TAB1 for i = 1 to T inclusive ;  $  TAB2 read l read r ;  $  TAB2 print l print ' ' print ( r / l ) * l print '\n' ;
TAB1 t = int ;  $  TAB1 read t ;  $  TAB1 loop t times ;  $  TAB2 l, r = long int ;  $  TAB2 read l then r ;  $  TAB2 if l equals 1 ;  $  TAB3 print l and r ;  $  TAB2 else ;  $  TAB3 print l and " " ;  $  TAB3 mod = long int with mod = r modulo l ;  $  TAB3 print r - mod ;
TAB1 t=int ;  $  TAB1 read t ;  $  TAB1 l,r,d=int ;  $  TAB1 while decremented t not equal 0 ;  $  TAB2 read l,r ;  $  TAB2 if r modulo l is zero ;  $  TAB3 print l, space, r ;  $  TAB2 else ;  $  TAB3 d=r modulo l ;  $  TAB3 d=r-d ;  $  TAB3 print l, space, d ;
TAB1 create long long n and m ;  $  TAB1 read n ;  $  TAB1 create long long l and r ;  $  TAB1 while decrement n ;  $  TAB2 read l and r ;  $  TAB2 if r mod l = 0 ;  $  TAB3 print l, " ", r ;  $  TAB2 else ;  $  TAB3 print l, " ", r - (r mod l) ;
TAB0 x, y = long long ;  $  TAB1 T = int ;  $  TAB1 read T ;  $  TAB1 loop T times ;  $  TAB2 read x then y ;  $  TAB2 r = long long with r = y mod x ;  $  TAB2 print x then " " then y - r ;
TAB1 create int n, i and arrays p and s of length 100100 ;  $  TAB1 read n ;  $  TAB1 for i=2 to n inclusive, read p[i] ;  $  TAB1 for i=1 to n inclusive, read s[i] ;  $  TAB1 for i=2 to n inclusive ;  $  TAB2 if s[i] = -1, continue the loop ;  $  TAB2 s[p[i]] = -1 ;  $  TAB3 set s[p[i]] = s[i] ;  $  TAB2 else ;  $  TAB3 s[p[i]] = min of s[p[i]] and s[i] ;  $  TAB1 for i=2 to n inclusive ;  $  TAB2 if s[i] equal to -1, continue the loop ;  $  TAB2 if s[p[i]] greater than s[i] ;  $  TAB3 print -1 ;  $  TAB1 set ans to s[1] ;  $  TAB1 for i=2 to n inclusive ;  $  TAB2 if s[i] equal to -1, continue the loop ;  $  TAB2 assign ans + s[i] - s[p[i]] to ans ;  $  TAB1 print ans ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create long long integer arrays s, ms, p, v with s size n, ms size n, p size n, v size n ;  $  TAB1 set p[0] to 0 ;  $  TAB1 for i = 1 to n exclusive, decrementing p[increment i], read p[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s[i] ;  $  TAB2 set ms[i] to s[i] ;  $  TAB1 for i = n - 1 to 0 exclusive, decrementing i ;  $  TAB2 if ms[i] is less than 0, break current loop iteration ;  $  TAB2 if s[p[i]] is less than 0 and ( ms[p[i]] is less than 0 or ms[p[i]] is greater than ms[i]), set ms[p[i]] to ms[i] ;  $  TAB1 if ms[0] is less than 0, set ms[0] to 0 ;  $  TAB1 create long long integer sum with sum = ms[0] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if ms[i] is less than 0 ;  $  TAB3 set ms[i] to mms[p[i]] ;  $  TAB2 else if ms[i] is less than ms[p[i]] ;  $  TAB3 print -1 print newline ;  $  TAB2 else ;  $  TAB3 increment sum by ms[i] - ms[p[i]] ;  $  TAB1 print sum print newline ;
TAB0 create long long p with size 200000 ;  $  TAB0 create long long s with size 200000 ;  $  TAB1 create long long num with num = 0 ;  $  TAB1 create long longs n, i, j ;  $  TAB1 read n ;  $  TAB1 for i = 2 to n inclusive, read p[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read s[i] ;  $  TAB2 if s[i] is -1, set s[i] to 1e10 ;  $  TAB1 for i = 1 to n inclusive, set s[p[i]] to minimum of s[p[i]] and s[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if s[p[i]] is greater than s[i] ;  $  TAB3 print -1 print newline ;  $  TAB2 if s[i] is 1e10, set s[i] to s[p[i]] ;  $  TAB2 increment num by s[i] - s[p[i]] ;  $  TAB1 print num print newline ;
TAB1 create string x ;  $  TAB1 read x ;  $  TAB1 create integers v and h = 0 ;  $  TAB1 for i = 0 to length of x exclusive ;  $  TAB2 if x[i] is '0' ;  $  TAB3 if v is 0 ;  $  TAB4 print 1, ' ', 1 and a new line, then increment v ;  $  TAB3 else ;  $  TAB4 print 3, ' ', 1 and a new line, then set v to 0 ;  $  TAB2 else ;  $  TAB3 if h is 0 ;  $  TAB4 print 4, ' ', 3 and a new line, then increment h ;  $  TAB3 else ;  $  TAB4 print 4, ' ', 1 and a new line, then set h to 0 ;
TAB0 declare boolean variables l and r ;  $  TAB0 let s be string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] = '0' && l is true ;  $  TAB3 print "3 1" and a new line ;  $  TAB3 set value of l to false ;  $  TAB2 else if s[i] = '0' ;  $  TAB3 print "1 1" and a new line ;  $  TAB3 l = true ;  $  TAB2 else if s[i] = '1' && r is true ;  $  TAB3 print "4 1" and a new line ;  $  TAB3 assign value of false to r ;  $  TAB2 else ;  $  TAB3 print "4 3" and a new line ;  $  TAB3 r = true ;
TAB0 create constant integer MAXN with value 100000 + 5 ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 let cnt1 and cnt2 be integers = 0 ;  $  TAB1 for integer i = 0 to length of s exclusive ;  $  TAB2 if s[i] = '0' ;  $  TAB3 if cnt1 is even ;  $  TAB4 print 1, " " and 1 ;  $  TAB3 else ;  $  TAB4 print 3, " " and 1 ;  $  TAB3 increment cnt1 ;  $  TAB2 else ;  $  TAB3 if cnt2 is even ;  $  TAB4 print 4, " " and 3 ;  $  TAB3 else ;  $  TAB4 print 4, " " and 1 ;  $  TAB3 increase cnt2 ;  $  TAB2 print "\n" ;
TAB1 s is string ;  $  TAB1 read s ;  $  TAB1 l1 is integer = length of s ;  $  TAB1 create booleans vertikal and horizontal = 0 ;  $  TAB1 for integer i = 0 to l1 exclusive ;  $  TAB2 if s[i] = '0' ;  $  TAB3 if vertikal is not 0 ;  $  TAB4 assign value of 0 to vertikal ;  $  TAB4 print "3 1\n" ;  $  TAB3 else ;  $  TAB4 assign value of 1 to vertikal ;  $  TAB4 print "1 1\n" ;  $  TAB2 else ;  $  TAB3 if horizontal is not 0 ;  $  TAB4 assign value of 0 to horizontal ;  $  TAB4 print "4 1\n" ;  $  TAB3 else ;  $  TAB4 set value of horizontal to 1 ;  $  TAB4 print "4 3\n" ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create integers o, z, with o = 0, z = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] is '0' ;  $  TAB3 increment o ;  $  TAB3 if o % 2 ;  $  TAB4 print 1 print " " print 1 print newline ;  $  TAB3 else ;  $  TAB4 print 3 print " " print 1 print newline ;  $  TAB2 else if s[i] is '1' ;  $  TAB3 increment z ;  $  TAB3 if z % 2 ;  $  TAB4 print 4 print " " print 3 print newline ;  $  TAB3 else ;  $  TAB4 print 4 print " " print 1 print newline ;
TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 create integer len with len = length of str ;  $  TAB1 create integers a, c, with a = 0, c = 0 ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if str[i] is '0' ;  $  TAB3 if a is 0 ;  $  TAB4 set a to 1 ;  $  TAB4 print "1 1" ;  $  TAB3 else ;  $  TAB4 set a to 0 ;  $  TAB4 print "3 1" ;  $  TAB2 if str[i] is '1' ;  $  TAB3 if c is 0 ;  $  TAB4 set c to 1 ;  $  TAB4 print "4 3" ;  $  TAB3 else ;  $  TAB4 set c to 0 ;  $  TAB4 print "4 1" ;
TAB0 assign value 200005 to constant integer N ;  $  TAB0 assign value 998244353 to constant integer MOD ;  $  TAB0 define function solve ;  $  TAB1 create string s ;  $  TAB1 create boolean v = false ;  $  TAB1 create boolean g = false ;  $  TAB1 read s ;  $  TAB1 declare integer n = length of s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] = '0' ;  $  TAB3 if v is true ;  $  TAB4 print 3, " ", 1 and a new line ;  $  TAB4 set v to false ;  $  TAB3 else ;  $  TAB4 print "1 1" and a new line ;  $  TAB4 set v to true ;  $  TAB2 else ;  $  TAB3 if g is true ;  $  TAB4 print 4, " ", 1 and a new line ;  $  TAB4 set g to false ;  $  TAB3 else ;  $  TAB4 print 4, " ", 3 and a new line ;  $  TAB4 set g to true ;  $  TAB1 declare integer variable t = 1 ;  $  TAB1 while t is not 0, decrement it and call solve ;
TAB0 create string s ;  $  TAB0 create integer array r with size 1001 ;  $  TAB0 create integer array c with size 1001 ;  $  TAB1 read s ;  $  TAB1 create integer n with n = length of s ;  $  TAB1 create boolean slot_0 with slot_0 = false ;  $  TAB1 create boolean slot_1 with slot_1 = false ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is '0' ;  $  TAB3 if not slot_0 ;  $  TAB4 print "1 1\n" ;  $  TAB4 set slot_0 to true ;  $  TAB3 else ;  $  TAB4 print "3 1\n" ;  $  TAB4 set slot_0 to false ;  $  TAB2 else ;  $  TAB3 if not slot_1 ;  $  TAB4 print "4 3\n" ;  $  TAB4 set slot_1 to true ;  $  TAB3 else ;  $  TAB4 print "4 1\n" ;  $  TAB4 set slot_1 to false ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer a, b, i, cnt, max, set cnt = 0, max = 0 ;  $  TAB1 for i = 0 to n execute ;  $  TAB2 print a, b ;  $  TAB2 set cnt = cnt + b - a ;  $  TAB2 if cnt>max set max = cnt ;  $  TAB1 print max ;
TAB1 create integers x, y, c, m with c = 0, m = 0 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 while decrement n is true ;  $  TAB2 read x read y ;  $  TAB2 decrement c by x ;  $  TAB2 increment c by y ;  $  TAB2 if c is greater than m, set m to c ;  $  TAB1 print m print newline ;
TAB0 create string str ;  $  TAB0 let n, a, b, capacity, total be integers, set capacity = 0, total=0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a and b ;  $  TAB2 total = total - a ;  $  TAB2 set total to total + b ;  $  TAB2 assign max of capacity and total to capacity ;  $  TAB1 print capacity ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integers on, off, count, c with count = 0, c = 0 ;  $  TAB1 while decrement n is true ;  $  TAB2 read off read on ;  $  TAB2 increment c by on - off ;  $  TAB2 if c is greater than count, set count to c ;  $  TAB1 print count print newline ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 integers = max,a,b,c ;  $  TAB1 read a,b ;  $  TAB1 set c to a + b ;  $  TAB1 set max to c ;  $  TAB1 for i = 1 to less than n do the following ;  $  TAB2 read a,b ;  $  TAB2 subtract a from c ;  $  TAB2 c equals c plus b ;  $  TAB2 if c is greater than max then do the following max = c ;  $  TAB1 output max ;
TAB1 n, i, j, k, max, cap = int ;  $  TAB1 set max to -1 ;  $  TAB1 set cap to 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n ;  $  TAB2 rad j then k ;  $  TAB2 set cap to cap - j + k ;  $  TAB2 if cap is greater than max set max to cap ;  $  TAB1 print max ;
TAB1 let n be an integer ;  $  TAB1 read n ;  $  TAB1 max = int = 0 ;  $  TAB1 cp = 0 = int ;  $  TAB1 for i = 0 to n ;  $  TAB2 let a, b be ints ;  $  TAB2 read a and b ;  $  TAB2 increment cp by (b- a) ;  $  TAB2 if cp >= max then set max to cp ;  $  TAB1 print max ;
TAB1 create integers n, a, b, c, m with c = 0, m = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a read b ;  $  TAB2 set c to c + b - a ;  $  TAB2 if m is less than c, set m to c ;  $  TAB1 print m print newline ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 ans =0 ;  $  TAB1 temp =0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create int a and b ;  $  TAB2 read a and b ;  $  TAB2 set temp to temp - a ;  $  TAB2 assign temp + b to temp ;  $  TAB2 set ans = max of temp and ans ;  $  TAB1 print ans ;
TAB1 create long longs n, max, d, with max = 0, d = 0 ;  $  TAB1 read n ;  $  TAB1 create long long arrays a, b, with a size 100000, with b size 100000 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] read b[i] ;  $  TAB2 set d to d - a[i] ;  $  TAB2 set d to d + b[i] ;  $  TAB2 if d is greater than max, set max to d ;  $  TAB1 print max print newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer arrays a, b with a size n, b size n ;  $  TAB1 for i = 0 to n exclusive, read a[i] read b[i] ;  $  TAB1 create integer curr with curr = 0 ;  $  TAB1 create integer req with req = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 decrement curr by a[i] ;  $  TAB2 increment cur by b[i] ;  $  TAB2 if curr is greater than req, set req to curr ;  $  TAB1 print req print newline ;
TAB1 create integer n ;  $  TAB1 create integer maxValue set maxValue = INT_MIN ;  $  TAB1 read n ;  $  TAB1 create Integer a, b ;  $  TAB1 create integer d set d = 0 ;  $  TAB1 create integer c set c = 0 ;  $  TAB1 for i =0 to n execute ;  $  TAB2 print a, b ;  $  TAB2 set c = c + a ;  $  TAB2 set d = d + b ;  $  TAB2 if maxValue is less than the absolute value of c - d set maxValue = abs(c - d) ;  $  TAB1 print maxValue ;
TAB1 create integer n ;  $  TAB1 while read n is true ;  $  TAB2 create integers ans, temp with ans = 0, temp = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 create integers p, q ;  $  TAB3 read p read q ;  $  TAB3 increment temp by q ;  $  TAB3 decrement temp by p ;  $  TAB3 set ans to maximum of ans and temp ;  $  TAB2 print ans print newline ;
TAB1 n=int, Max and Count=0 ;  $  TAB1 read n ;  $  TAB1 a and b=array of n int ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i],b[i] ;  $  TAB2 subtract a[i] from Count ;  $  TAB2 add b[i] to Count ;  $  TAB2 if Count>Max Max=Count ;  $  TAB1 print Max ;
TAB1 a, b, i, j, c, n, p, q = int with j = 0 and c = 0 and p = 0 and q = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a then b ;  $  TAB2 set p to p + a ;  $  TAB2 set q to q + b ;  $  TAB2 set c to q - p ;  $  TAB2 if c > j set j to c ;  $  TAB1 print j ;
TAB1 create character array s with size 10001 ;  $  TAB1 create integer t ;  $  TAB1 while read t is true ;  $  TAB2 create integers ns, sm with ns = -1, sm = 0 ;  $  TAB2 while decrement t is true ;  $  TAB3 create integers doll, puppet ;  $  TAB3 read doll read puppet ;  $  TAB3 set sm to sm - doll + puppet ;  $  TAB3 set ns to maximum of ns and sm ;  $  TAB2 print ns print newline ;
TAB1 n = integer ;  $  TAB1 while n can be read as a valid integer ;  $  TAB2 a, b, total, max = integers, k = integer = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a, b ;  $  TAB3 if k is 0 ;  $  TAB4 total = b ;  $  TAB4 k = 1 ;  $  TAB4 max = b ;  $  TAB3 else if k is 1 ;  $  TAB4 total = total - a + b ;  $  TAB4 if total > max, then max = total ;  $  TAB2 print max ;
TAB1 create integers a, b ;  $  TAB1 create integer counter with counter = 0 ;  $  TAB1 create integer tranSize with tranSize = 0 ;  $  TAB1 create integer rep ;  $  TAB1 read rep ;  $  TAB1 while decrement rep is true ;  $  TAB2 read a read b ;  $  TAB2 decrement counter by a ;  $  TAB2 increment counter by b ;  $  TAB2 if counter is greater than tranSize, set tranSize to counter ;  $  TAB1 print tranSize print newline ;
TAB1 v = long long int vector ;  $  TAB1 n, out, in, sum = long long int with sum = 0 ;  $  TAB1 read n ;  $  TAB1 loop n times ;  $  TAB2 read out then in ;  $  TAB2 set sum to sum - out + in ;  $  TAB2 append sum to v ;  $  TAB1 sort v ;  $  TAB1 reverse v ;  $  TAB1 print v[0] ;
TAB1 n, x, y, i, max, a = long long integer with max, a = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x, y ;  $  TAB2 a = a - x + y ;  $  TAB2 if max < a, max = a ;  $  TAB1 print max ;
TAB1 create integers minx, n, a, b and test with minx and test = 0 ;  $  TAB1 read variable n from the input ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read standard input to a and b ;  $  TAB2 change test to test - a ;  $  TAB2 change test to sum of test and b ;  $  TAB2 change minx to max of minx and test ;  $  TAB1 print minx to the standard output ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a, b = int array of size n each ;  $  TAB1 cntr, ans = int with cntr = 0 and ans = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 read a[i] then b[i] ;  $  TAB2 decrement cntr by a[i] ;  $  TAB2 increment cntr by b[i] ;  $  TAB2 set ans to max of ans and cntr ;  $  TAB1 print ans ;
TAB1 create integers n, a, b, s, t ;  $  TAB1 while read n is true ;  $  TAB2 set t to 0 ;  $  TAB2 create integers r, z, with r = 0, z = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a read b ;  $  TAB3 increment r by a ;  $  TAB3 increment z by b ;  $  TAB3 set s to z - r ;  $  TAB3 set t to maximum of t ans s ;  $  TAB2 print t print newline ;
TAB0 s = integer ;  $  TAB1 create integers x, a[10001], b[10001], maxs, set maxs to 0 ;  $  TAB1 read x ;  $  TAB1 for i=1 to x inclusive, read a[i] and b[i] ;  $  TAB1 for i=1 to x inclusive ;  $  TAB2 set s to s - a[i] ;  $  TAB2 assign s + b[i] to s ;  $  TAB2 if s greater than maxs, set maxs to s ;  $  TAB1 print maxs ;
TAB1 create integers n, r, t, with r = 0, t = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integers a, b ;  $  TAB2 read a read b ;  $  TAB2 set t to t = a + b ;  $  TAB2 if t is greater than r, set r to t ;  $  TAB1 print r print newline ;
TAB0 bool function lucky with integer argument n ;  $  TAB1 while n != 0 ;  $  TAB2 if n % 10 != 4 && n % 10 != 7 return false ;  $  TAB2 divide n by 10 ;  $  TAB1 return true ;  $  TAB0 almost_lucky is a boolean function with integer argument n ;  $  TAB1 if lucky(n) is true, return true ;  $  TAB1 for i = 2 while i * i <= n ;  $  TAB2 if n % i = 0 && (lucky(i) or lucky(n / i) is true) ;  $  TAB1 return false ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if almost_lucky(n) is true ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 function str (get int n, return string) ;  $  TAB1 ss = stringstream ;  $  TAB1 push n into ss ;  $  TAB1 s=string ;  $  TAB1 s = ss ;  $  TAB1 return s ;  $  TAB0 sorte=array of 1001 int ;  $  TAB0 tam=0 ;  $  TAB0 function lucky ;  $  TAB1 for i=0 to 1001 exclusive ;  $  TAB2 s string = str(i) ;  $  TAB2 sorte2=true ;  $  TAB2 for c=0 to length of s exclusive ;  $  TAB3 if s[c] != '4' and != '7' ;  $  TAB4 sorte2 = false ;  $  TAB4 break ;  $  TAB2 if sorte2 ;  $  TAB3 sorte[tam] = i ;  $  TAB3 increment tam ;  $  TAB1 call lucky() ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 pos=0 ;  $  TAB1 divide=false ;  $  TAB1 while sorte[pos] <= n and pos < tam ;  $  TAB2 if n modulo sorte[pos] is zero ;  $  TAB3 divide=true ;  $  TAB3 break ;  $  TAB2 increment pos ;  $  TAB1 if divide ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 assign elements 4, 7, 44, 77, 47, 74, 444, 447, 474, 477, 777, 744, 747, 774 to int array arr ;  $  TAB0 set bool s to false ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i=0 to 14 exclusive ;  $  TAB2 if n mod arr[i] = 0 ;  $  TAB3 print YES ;  $  TAB3 s = true ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 continue the loop ;  $  TAB1 if s is false, print NO and a newline ;
TAB1 create integers n, i, , a, j, h ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 set k to i ;  $  TAB2 if n % k is 0 ;  $  TAB3 set j to h to 0 ;  $  TAB3 while k is not 0 ;  $  TAB4 set a to k % 10 ;  $  TAB4 if a is 4 or a is 7, increment h ;  $  TAB4 set k to k / 10 ;  $  TAB4 increment j ;  $  TAB3 if h is j ;  $  TAB4 print "YES" print newline ;  $  TAB1 print "NO" print newline ;
TAB1 num = integer ;  $  TAB1 arr = integer array of 14 strings with arr = {4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777} ;  $  TAB1 read num ;  $  TAB1 for i = 0 to 13 ;  $  TAB2 if num modulo arr[i] is 0 ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB1 set int i, j, l, x, m, m1, k to 0, res=0 ;  $  TAB1 read x ;  $  TAB1 set int a as array of 1000 all to 0 ;  $  TAB1 for = 4 to less than or equal to 1000 do the following ;  $  TAB2 set i to j ;  $  TAB2 set m to 0, m1 ;  $  TAB2 if i is greater than 0 then do ;  $  TAB3 set l to i modulo 10 ;  $  TAB3 if l is 4 or 7 then add one to m ;  $  TAB3 set i to i / 10 ;  $  TAB3 add one to m1 ;  $  TAB2 if m is m1 then do the following ;  $  TAB3 set a[k] to j ;  $  TAB3 add one to k ;  $  TAB1 for = 0 to less than k do the following ;  $  TAB2 if x modulo a[i] is 0 then do ;  $  TAB3 set res to 5 ;  $  TAB3 break ;  $  TAB1 if res is 5 then do the following commands ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 create integer n ;  $  TAB0 create integer array arr with arr = {4, 7, 44, 47, 74, 77, 444, 447, 474, 477} ;  $  TAB1 read n ;  $  TAB1 for i = 0 to size of arr / 4 exclusie ;  $  TAB2 if not ( n % arr[i] ) ;  $  TAB3 print "YES\n" ;  $  TAB3 exit from program with code 0 ;  $  TAB1 print "NO\n" ;
TAB0 int function getdigits with int argument n ;  $  TAB1 declare int variable c = 0 ;  $  TAB1 while n is not 0 ;  $  TAB2 divide n by 10 ;  $  TAB2 increment c ;  $  TAB1 return c ;  $  TAB1 declare int variables n, d, i and flag where flag = 0 ;  $  TAB1 read input to n ;  $  TAB1 assign result of etdigits(n) to d ;  $  TAB1 if n % 4 = 0 ;  $  TAB2 set flag to 1 ;  $  TAB1 else if n % 7 = 0 ;  $  TAB2 assign 1 to flag ;  $  TAB1 else if n % 47 = 0 ;  $  TAB2 assign 1 to flag ;  $  TAB1 else if n % 477 = 0 ;  $  TAB2 change flag to 1 ;  $  TAB1 else if n % 447 = 0 ;  $  TAB2 assign 1 to flag ;  $  TAB1 else if n % 474 = 0 ;  $  TAB2 set flag to 1 ;  $  TAB1 else if n % 744 = 0 ;  $  TAB2 assign 1 to flag ;  $  TAB1 else if n % 747 = 0 ;  $  TAB2 set flag to 1 ;  $  TAB1 else if n % 774 = 0 ;  $  TAB2 set flag to 1 ;  $  TAB1 if flag is true ;  $  TAB2 print "YES" ;  $  TAB3 print "\n" ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB3 print "\n" ;
TAB0 set int n, arr[] to 4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to less than 10 do the following ;  $  TAB2 if n / arr[i] has no remainder then do the following ;  $  TAB3 output YES ;  $  TAB1 output NO ;
TAB1 n, k = integer ;  $  TAB1 read n, k ;  $  TAB1 x, y, x0, y0, total = double with total(0.0) ;  $  TAB1 read x0, y0 ;  $  TAB1 while decrement n ;  $  TAB2 read x, y ;  $  TAB2 total = total + sqrt((x - x0) * (x - x0) + (y - y0) * (y - y0)) ;  $  TAB2 x0 = x ;  $  TAB2 y0 = y ;  $  TAB1 print fixed, setprecision(6), total * k / 50 ;
TAB1 n, k = int ;  $  TAB1 read n then k ;  $  TAB1 x, y, x0, y0, total = double with total = 0.0 ;  $  TAB1 read x0 then y0 ;  $  TAB1 loop n times ;  $  TAB2 read x then y ;  $  TAB2 add sqrt((x - x0) * (x - x0) + (y - y0) * (y - y0)) to total ;  $  TAB2 set x0 = x ;  $  TAB2 set y0 = y ;  $  TAB1 print total * k / 50 with 6 decimal digits ;
TAB1 create integers n, k ;  $  TAB1 read n read k ;  $  TAB1 create doubles x, y, x0, y0, total with total initialized with 0.0 ;  $  TAB1 read x0 read y0 ;  $  TAB1 while decrement n is true ;  $  TAB2 read x read y ;  $  TAB2 increment total by square root of ( (x - x0) * (x - x0) + (y - y0) * (y - y0) ) ;  $  TAB2 set x0 to x ;  $  TAB2 set y0 to y ;  $  TAB1 print fixed, set cout decimal precision to 6, print total*k/50 print newline ;
TAB0 double function dist with integer arguments x1, y1, x2 and y2 ;  $  TAB1 return square root of (pow((x1 - x2), 2) + pow((y1 - y2), 2)) ;  $  TAB1 create integers n and k ;  $  TAB1 read n and k ;  $  TAB1 declare boolean f = true ;  $  TAB1 create integers x1, y1, x2 and y2 ;  $  TAB1 create double totDist ;  $  TAB1 decrement n in a loop while n > 0 ;  $  TAB2 if f is true ;  $  TAB3 read x1 and y1 ;  $  TAB3 set f to false ;  $  TAB2 else ;  $  TAB3 read x2 and y2 ;  $  TAB3 increase totDist by dist of (x1, y1, x2, y2) ;  $  TAB3 set x1 to x2 ;  $  TAB3 assign value of y2 to y1 ;  $  TAB1 create double r = totDist * k / 50.0 ;  $  TAB1 print fixed and r ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to s.length() exclusive ;  $  TAB2 while (s[i - 1] is character ' ' and s[i] is character ' '), erase(s.begin() + i - 1) from s ;  $  TAB2 if ((s[i] is . or s[i] is ! or s[i] is , or s[i] is ?)) ;  $  TAB3 if (s[i - 1] is character ' ' and s[i + 1] is character ' ') ;  $  TAB4 erase(s.begin() + i - 1) from s ;  $  TAB3 else if (s[i + 1] is not character ' ' ;  $  TAB4 insert(s.begin() + i + 1, character ' ') in s ;  $  TAB3 while (s[i - 1] is character ' ') erase(s.begin() + i - 1) from s ;  $  TAB1 print s ;
TAB0 create const ints N = 1e5 + 5 and OO = 0x3f3f3f3f ;  $  TAB1 declare string variable str ;  $  TAB1 read input into str ;  $  TAB1 loop i from 0 to length of str exclusive ;  $  TAB2 if str[i] is equal to ' ' and str[i + 1] is equal to ' ' ;  $  TAB3 remove element at position i from str ;  $  TAB3 decrement i by one ;  $  TAB2 if str[i] = ',' or str[i] = '!' or str[i] = '?' or str[i] = '.' ;  $  TAB3 if str[i + 1] != ' ' and i < length of str-1 ;  $  TAB4 declare string a = " " ;  $  TAB4 insert a to position i + 1 of str ;  $  TAB3 if str[i - 1] is equal to ' ' ;  $  TAB4 remove element at position i - 1 from str ;  $  TAB4 decrement i by one ;  $  TAB1 print str ;
TAB1 s = string array ;  $  TAB1 set int sp to 0, p = 0 ;  $  TAB1 get the line as variable s ;  $  TAB1 set string s2 to ;  $  TAB1 set int l to s.size() ;  $  TAB1 for i = 0 to less than l do the following ;  $  TAB2 if s[i] is then do ;  $  TAB3 add one to sp ;  $  TAB2 else if (s[i] equals , . ? or ! then do the following ;  $  TAB3 add one to p ;  $  TAB3 s2 equals s2 plus s[i] ;  $  TAB2 else ;  $  TAB3 if sp is 0 and p = 0 then do the following instructions ;  $  TAB4 s2 equals s2 plus s[i] ;  $  TAB3 else if sp and p = 0 the do the following ;  $  TAB4 s2 equals s2 plus space ;  $  TAB4 s2 equals s2 plus s[i] ;  $  TAB4 set sp to 0 ;  $  TAB3 else ;  $  TAB4 s2 equals s2 plus space ;  $  TAB4 s2 equals s2 plus s[i] ;  $  TAB4 set p to 0 ;  $  TAB4 set sp to 0 ;  $  TAB1 output s2 ;
TAB0 create character variable c with size of 10005 ;  $  TAB0 s = string ;  $  TAB1 input line into array c of 10005 size ;  $  TAB1 set int i to 0 ;  $  TAB1 set int lg to strlen(c) ;  $  TAB1 set bool ok to 0 ;  $  TAB1 if i is less than lg then do ;  $  TAB2 if isalpha is true ;  $  TAB3 if ok = 0 and i is not equal to 0 and not isalpha(c[i - 1] then add a space character to s ;  $  TAB3 s equals s plus c[i] ;  $  TAB3 set ok to 0 ;  $  TAB2 else ;  $  TAB3 set if (c[i] = ? or c[i] = ! or c[i] = , or c[i] = .) s += c[i] then add a c[i] to s and add a space to s, and make ok = 1 ;  $  TAB2 add one to i ;  $  TAB1 output s ;
TAB0 s = string ;  $  TAB0 ans = string array of size 111111 ;  $  TAB1 call getline of cin and s ;  $  TAB1 n, p = int with n = size of s and p = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 if s[i] equals ',' or '.' or '!' or '?' ;  $  TAB3 set ans[p] to " " then increment p ;  $  TAB3 set ans[p - 1][0] to s[i] ;  $  TAB2 else if s[i] is a lowercase character ;  $  TAB3 j = int with j = i ;  $  TAB3 loop while s[j] is a lowercase character and j is less than n increment j ;  $  TAB3 set ans[p] to result of s.substr of i and j - i then increment p ;  $  TAB3 set i to j - 1 ;  $  TAB1 l = int with l = 0 ;  $  TAB1 for i = 0 to p ;  $  TAB2 if ans[i][0] is greater or equal to 'a' ;  $  TAB3 if l equals 1 print ' ' ;  $  TAB3 print ans[i] ;  $  TAB3 set l to 1 ;  $  TAB2 else ;  $  TAB3 print ans[i] and ' ' ;  $  TAB3 set l to 0 ;  $  TAB1 print newline ;
TAB0 create string in ;  $  TAB0 declare string n = "" ;  $  TAB1 read line and store it into in ;  $  TAB1 declare int m = length of in ;  $  TAB1 declare boolean se = false ;  $  TAB1 for i from 0 to m exclusive ;  $  TAB2 if in[i] >= 'a' and in[i] <= 'z' ;  $  TAB3 append n to in[i] ;  $  TAB2 else if in[i] = ' ' ;  $  TAB3 if n is equal to " " continue the loop from the start ;  $  TAB3 print n ;  $  TAB3 assign ' ' to n ;  $  TAB3 change se to true ;  $  TAB3 continue the loop from the start ;  $  TAB2 else ;  $  TAB3 if se is true and n = " " ;  $  TAB4 print in[i] ;  $  TAB4 set n to ' ' ;  $  TAB4 set se to false ;  $  TAB4 go to the start of the loop ;  $  TAB3 print n and in[i] ;  $  TAB3 change n to ' ' ;  $  TAB1 print n if if n != " " ;  $  TAB1 print a new line ;
TAB1 declare string variable s ;  $  TAB1 loop when read data from input into s ;  $  TAB2 declare string n = "" ;  $  TAB2 declare integer d = length of s ;  $  TAB2 for i = 0 to d exclusive incrementing i ;  $  TAB3 if s[i] is equal to ' ' ;  $  TAB4 if n[n.length() - 1] is not ' ', incremen n by s[i] ;  $  TAB3 else if s[i] = '.' || s[i] = ',' || s[i] = '!' || s[i] = '?' ;  $  TAB4 if n[n.length() - 1] is not ' ' ;  $  TAB5 append s[i] + ' ' to n ;  $  TAB4 else ;  $  TAB5 remove n.length() - 1 elements from n ;  $  TAB5 append s[i] + ' ' to n ;  $  TAB3 else ;  $  TAB4 append s[i] to n ;  $  TAB2 print all elements of n sequentially ;  $  TAB2 print a new line ;
TAB0 declare isp with character c as argument, returning boolean ;  $  TAB1 if c is '.' or c is ',' or c is '!' or c is '?', return true from function ;  $  TAB1 return false from function ;  $  TAB1 create string s ;  $  TAB1 read line from cin to s ;  $  TAB1 create integer len with len = size of s ;  $  TAB1 create string s2 ;  $  TAB1 create integer lenn with lenn = len - 1 ;  $  TAB1 for i = 0 to lenn exclusive ;  $  TAB2 if s[i] is ' ' and ( s[i+1] is ' ' or result of run isp with s[i+1] as argument is true ), break current loop iteration ;  $  TAB2 increment s2 by s[i] ;  $  TAB2 if result of run isp with s[i] as argument is true and s[i+1] is not ' ', increment s2 by ' ' ;  $  TAB1 increment s2 by s[len - 1] ;  $  TAB1 print s2 print newline ;
TAB0 s = string ;  $  TAB0 p = integer ;  $  TAB0 ans = character array of size 111111 ;  $  TAB1 read s ;  $  TAB1 n = integer with n = s.size() ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] >= a and s[i] <= z ;  $  TAB3 ans[increment p] = s[i] ;  $  TAB2 else if s[i] is , or s[i] is . or s[i] is ? or s[i] is ! ;  $  TAB3 for p and ans[p - 1] is character' ', decrement p ;  $  TAB3 ans[increment p] = s[i] ;  $  TAB3 ans[increment p] = character ' ' ;  $  TAB2 else if (s[i] is character ' ' ;  $  TAB3 if ans[p - 1] is not character ' ', ans[increment p] = s[i] ;  $  TAB1 print ans ;
TAB1 create integers n, dx ;  $  TAB1 read n read dx ;  $  TAB1 create string arrays a, b, c, d, with a size 1001, b size 1001, c size 1001, d size 1001 ;  $  TAB1 create integer array t with size 1001 ;  $  TAB1 create integer sum with sum = 0 ;  $  TAB1 for i = 0 to n exclusive, read a[i] read b[i] read t[i] ;  $  TAB1 or i = 0 to n - 1 exclusive ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 if t[j] - t[i] is greater than 0 and t[j] - t[i] is less than or equal to dx ;  $  TAB4 if a[i] is b[j] and b[i] is a[j] ;  $  TAB5 create integer flat with flat = 0 ;  $  TAB5 for k = 0 to sum exclusive ;  $  TAB6 if a[i] is c[k] and b[i] is d[k] or a[i] is d[k] and b[i] is c[k] ;  $  TAB7 set flat to 1 ;  $  TAB7 break loop ;  $  TAB5 if not flag ;  $  TAB6 set c[sum] to a[i] ;  $  TAB6 set d[sum] to b[i] ;  $  TAB6 increment sum ;  $  TAB1 print sum print newline ;  $  TAB1 for i = 0 to sum exclusive, print c[i] print " " print d[i] print newline ;
TAB0 let x and y be arrays of double of size 100000 ;  $  TAB0 n and t = integers ;  $  TAB0 define function sorty ;  $  TAB1 let i and k be integers ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer min with value x[i] ;  $  TAB2 set integer pos to i ;  $  TAB2 for k = i + 1 to n exclusive ;  $  TAB3 if x[k] is less than min ;  $  TAB4 set value of min to x[k] ;  $  TAB4 set value of pos to k ;  $  TAB2 invoke function swap with arguments x[i] and x[pos] ;  $  TAB2 invoke function swap with arguments y[i] and y[pos] ;  $  TAB1 read n and t ;  $  TAB1 let i be integer ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a and b = doubles ;  $  TAB2 read a and b ;  $  TAB2 x[i] = (a - (b / 2.0)) ;  $  TAB2 y[i] = (a + (b / 2.0)) ;  $  TAB1 call sorty ;  $  TAB1 create integer ct with value 2 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 create double h with value y[i] + t ;  $  TAB2 if x[i + 1] >= h increment ct ;  $  TAB2 h = x[i + 1] - t ;  $  TAB2 if y[i] is less than h increment ct ;  $  TAB1 print ct and a new line ;
TAB0 let a be an array of integers of length 10005 ;  $  TAB1 create integers n and t ;  $  TAB1 read n and t ;  $  TAB1 multiply t by 2 ;  $  TAB1 mi and mx are integers with mi = 5000 and mx = 0 ;  $  TAB1 invoke function memset with arguments a, 0 and size of a ;  $  TAB1 while n-- ;  $  TAB2 let x and aa be integers ;  $  TAB2 read x and aa ;  $  TAB2 set integer ll to x * 2 + 4000 - aa; ;  $  TAB2 set integer rr to x * 2 + 4000 + aa ;  $  TAB2 for i = ll to rr inclusive ;  $  TAB3 increase a[i] ;  $  TAB3 set mx to max of mx, i ;  $  TAB3 set value of mi to min of mi, i ;  $  TAB1 len and ans are integers with len = 0 and ans = 2 ;  $  TAB1 for integer i = mi to mx inclusive ;  $  TAB2 increase len ;  $  TAB2 if a[i] is true ;  $  TAB3 if len is greater than t ;  $  TAB4 increase ans by 2 ;  $  TAB3 else if len is equal to t ;  $  TAB4 increase ans by one ;  $  TAB3 len = 0 ;  $  TAB1 if len is greater than t ;  $  TAB2 increase ans by 2 ;  $  TAB1 else if len is equal to t ;  $  TAB2 increment ans ;  $  TAB1 print ans and a new line ;
TAB0 double constant PI is acos(-1.0) ;  $  TAB1 let n and s be integers ;  $  TAB1 read n and s ;  $  TAB1 create integers x and size ;  $  TAB1 create arrays of doubles start and end with size 1005 ;  $  TAB1 call memset with arguments start, 0 and sizeof(start) ;  $  TAB1 call memset with arguments end, 0 and sizeof(end) ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read x and size ;  $  TAB2 start[i] = x - size / 2.0 ;  $  TAB2 end[i] = x + size / 2.0 ;  $  TAB1 sort n elements of array start ;  $  TAB1 sort n elements of array end ;  $  TAB1 res is integer = 2 ;  $  TAB1 for integer i = 0 to n - 1 exclusive ;  $  TAB2 set double gap to start[i + 1] - end[i] ;  $  TAB2 if s is less than gap increase res by 2 ;  $  TAB2 if s = gap increase res by 1 ;  $  TAB1 print res and "\n" ;
TAB1 let n, i and sum be integers with sum = 2 ;  $  TAB1 let x, y and t be doubles ;  $  TAB1 a = array of doubles of length 2005 ;  $  TAB1 read n and t ;  $  TAB1 for i = 0 to n + n exclusive looping by steps of 2 ;  $  TAB2 read x and y ;  $  TAB2 a[i] = x - y * 0.5 ;  $  TAB2 a[i + 1] = x + y * 0.5 ;  $  TAB1 sort a from the start to n + n ;  $  TAB1 b = array of doubles of length 2005 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 b[i] = a[i * 2] - a[i * 2 - 1] ;  $  TAB2 if b[i] is equal to t ;  $  TAB3 sum = sum + 1 ;  $  TAB2 else if b[i] is greater than t ;  $  TAB3 sum = sum + 2 ;  $  TAB1 print sum and a new line ;
TAB1 let x, d and c be doubles ;  $  TAB1 assign value 0, n, t to the integer cnt ;  $  TAB1 arr is an array of double double pairs ;  $  TAB1 read n and t ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x and d ;  $  TAB2 divide d by 2 ;  $  TAB2 arr[i] = make_pair(x - d, x + d) ;  $  TAB1 sort arr ;  $  TAB1 for integer i = 0 to n - 1 exclusive ;  $  TAB2 c = first element of arr[i + 1] - second element ;  $  TAB2 decrease c by t ;  $  TAB2 if c = 0 ;  $  TAB3 increase cnt ;  $  TAB2 else if c is greater than 0 ;  $  TAB3 increase cnt by 2 ;  $  TAB1 print cnt + 2 and a new line ;
TAB0 create map mp from long long to long long ;  $  TAB1 create integers n, t, c with c = 2 ;  $  TAB1 read n read t ;  $  TAB1 create doubles x, y ;  $  TAB1 create pair array p with double, double, size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x read y ;  $  TAB2 if x is greater than or equal to 0 ;  $  TAB3 set first element of p[i] to x - (y/2) ;  $  TAB3 set second element of p[i] to x + (y/2) ;  $  TAB2 else ;  $  TAB3 set first element of p[i] to x - (y/2) ;  $  TAB3 set second element of p[i] to x + (y/2) ;  $  TAB1 sort elements from p to p + n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set x to first element of p[i] - second element of p[i-1] ;  $  TAB2 if x is t ;  $  TAB3 increment c ;  $  TAB2 else if x is greater than t ;  $  TAB3 increment c by 2 ;  $  TAB1 print c print newline ;
TAB0 let mp be a map from long long to long long ;  $  TAB1 integers n, t and c with c = 2 ;  $  TAB1 read n and t ;  $  TAB1 declare doubles called x and y ;  $  TAB1 p is array of pairs of double, double with size n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read x and y ;  $  TAB2 if x >= 0 ;  $  TAB3 p[i].first = x - (y / 2) ;  $  TAB3 p[i].second = x + (y / 2) ;  $  TAB2 else ;  $  TAB3 p[i].first = x - (y / 2) ;  $  TAB3 p[i].second = x + (y / 2) ;  $  TAB1 sort array p ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 x = p[i].first - p[i - 1].second ;  $  TAB2 if x is equal to t ;  $  TAB3 increase c ;  $  TAB2 else if x is greater than t ;  $  TAB3 increase c by 2 ;  $  TAB1 print c and a new line ;
TAB0 create integers n, t ;  $  TAB0 create double vector coord ;  $  TAB1 read n read t ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integers x, a ;  $  TAB2 read x read ;  $  TAB2 add element 1.0 * x - 1.0 * a / 2 to end of coord ;  $  TAB2 add element 1.0 * x + 1.0 * a / 2 to end of coord ;  $  TAB1 sort elements from beginning of coord to end of coord ;  $  TAB1 create integer ans with ans = 2 ;  $  TAB1 for i = 1 to size of coord -1 exclusive, incrementing i by 2 ;  $  TAB2 create double x1, x2 with x1 = coord[i], x2 = coord[i+1] ;  $  TAB2 if x2 - x1 is less than t ;  $  TAB3 break current loop iteration ;  $  TAB2 else if x2 - x1 is t ;  $  TAB3 increment ans by 1 ;  $  TAB2 else ;  $  TAB3 increment ans by 2 ;  $  TAB1 print ans print "\n" ;
TAB0 create integers n and t ;  $  TAB0 coord = vector of doubles ;  $  TAB1 read n and t ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 declare integers called x and a ;  $  TAB2 read x and a ;  $  TAB2 push 1.0 * x - 1.0 * a / 2 into coord ;  $  TAB2 push 1.0 * x + 1.0 * a / 2 into coord ;  $  TAB1 sort coord ;  $  TAB1 create integer ans with value 2 ;  $  TAB1 for i = 1 to the length of coord - 1 exclusive with increments of 2 ;  $  TAB2 let double x1 = coord[i] and double x2 = coord[i + 1] ;  $  TAB2 if x2 - x1 is less than t ;  $  TAB3 go to the start of the loop ;  $  TAB2 else if x2 - x1 is equal to t ;  $  TAB3 increase ans by 1 ;  $  TAB2 else ;  $  TAB3 increase ans by 2 ;  $  TAB1 print ans and "\n" ;
TAB0 mod = int with mod = 1e9 + 7 ;  $  TAB0 n = int ;  $  TAB0 N = const int with N = 50 ;  $  TAB0 p, t = int array of size N each ;  $  TAB0 in function compare taking int a, int b and returning bool ;  $  TAB1 if p[a] > p[b] return 1 ;  $  TAB1 if p[a] is p[b] and t[a] <= t[b] return 1 ;  $  TAB0 in function eq taking int a, int b and returning bool ;  $  TAB1 if p[a] is p[b] and t[a] is t[b] return 1 ;  $  TAB1 k = int ;  $  TAB1 read n then k ;  $  TAB1 a = int array of size n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read p[i] then t[i] ;  $  TAB2 set a[i] to i ;  $  TAB1 call stable_sort on a, a + n, compare ;  $  TAB1 c = int with c = 1 ;  $  TAB1 i = int with i = k - 2 ;  $  TAB1 loop while i >= 0 and eq of a[k - 1], a[i] ;  $  TAB2 increment c ;  $  TAB2 decrement i ;  $  TAB1 set to k ;  $  TAB1 loop while i < n and eq of a[k - 1], a[i] ;  $  TAB2 increment c ;  $  TAB2 increment i ;  $  TAB1 print c ;
TAB0 create ints n, i, p, t, and k and int array a of size 111111 ;  $  TAB1 read n and k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read p and t ;  $  TAB2 increment a[p * 50 - t] ;  $  TAB1 set t to 10000 ;  $  TAB1 while a[t] is less than k, set k to k - a[t--] ;  $  TAB1 print a[t] ;
TAB1 create new integers n and k ;  $  TAB1 read n and k ;  $  TAB1 create an array of int int pairs A witn n + 1 element ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 read input to A[i].first and A[i].second ;  $  TAB2 invert the sign of A[i].first ;  $  TAB1 sort A from position 1 to n + 1 ;  $  TAB1 create integer ans = 0 ;  $  TAB1 for i = 1 to n inclusive incrementing i ;  $  TAB2 if A[i] = A[k], increment ans by one ;  $  TAB1 print ans and '\n' ;
TAB1 create ints i, j, n, k, ans1, ans2, and c and int arrays a of size 10000 and b of size 10000 ;  $  TAB1 read n and k ;  $  TAB1 Enter integers for every index of arrays a and b ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = n - 1 to i exclusive ;  $  TAB3 if a[j] is greater than a[j - 1] ;  $  TAB4 swap the values of a[j] and a[j - 1] ;  $  TAB4 swap the values of b[j] and b[j - 1] ;  $  TAB3 if a[j] is equal to a[j - 1] and b[j] is less than a[j - 1], swap the values of b[j] and b[j -1] ;  $  TAB1 set ans1 to a[k - 1] ;  $  TAB1 set ans2 to b[k - 1] ;  $  TAB1 for i = 0 and c = 0 to n exclusive ;  $  TAB2 if ans1 is equal to a[i] and ans2 is equal to b[i], increment c++ ;  $  TAB1 print c ;
TAB0 declare const int N = 50 + 5 ;  $  TAB0 create integers n, k and res ;  $  TAB0 create an array of int-int pairs a with size N ;  $  TAB0 declare boolean function cmp that takes pairs of int-int a and b as an arguments ;  $  TAB1 if a.first is greater than b.first ;  $  TAB2 return true ;  $  TAB1 else if a.first is equal to b.first ;  $  TAB2 if a.second is less than b.second, return true ;  $  TAB2 return false ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB0 define function Input ;  $  TAB1 read n and k ;  $  TAB1 for i from 1 to n inclusive, read input to a[i].first and a[i].second ;  $  TAB1 sort a from position 1 to n + 1 using cmp as a comparator method ;  $  TAB0 function Solve ;  $  TAB1 declare int problems = a[k].first and penalty=a[k].second ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 if a[i].first = problems and a[i].second is equal to penalty, increment res ;  $  TAB1 print res and '\n' ;  $  TAB1 call Input() ;  $  TAB1 call Solve() ;
TAB1 declare integers n, k ;  $  TAB1 read n read k ;  $  TAB1 declare pair of integer, integer array a size 50 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read first element for a[i], second element of a[i] ;  $  TAB2 let first element of a[i] be first element of a[i] * -1 ;  $  TAB1 sort elements from a to a + n ;  $  TAB1 print result of run count with a, a + n, a[k - 1] as arguments, newline ;  $  TAB1 return 0 from function ;
TAB0 n, i, p, t, k = int and a = int array of size 111111 ;  $  TAB1 read n then k ;  $  TAB1 for i = 0 to n ;  $  TAB2 read p then t ;  $  TAB2 increment a[p * 50 - t] ;  $  TAB1 set t to 2500 ;  $  TAB1 loop while a[t] is less than k decrement k by a[t] then decrement t ;  $  TAB1 print a[t] ;
TAB1 create integers n, m, i, j, k, a, b, create integer array x with size 51 ;  $  TAB1 while read n read m ;  $  TAB2 set j to 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a read b ;  $  TAB3 set x[i] to a * 50 - b ;  $  TAB2 sort elements from x to x + n ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if x[i] is x[n-m], increment j ;  $  TAB2 print j print newline ;
TAB1 declare int variables n and d ;  $  TAB1 declare double variable a ;  $  TAB1 read n, a and d ;  $  TAB1 create an arrays of long longs t and v with n elements ;  $  TAB1 loop i from 0 to n exclusive, read t[i] and v[i] ;  $  TAB1 declare long double T = 0 ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 if v[i] * v[i] >= 2 * a * d ;  $  TAB3 T = max of t[i] + sqrt((2.0 * d) / a and T ;  $  TAB2 else ;  $  TAB3 create long double t1 = v[i] / a ;  $  TAB3 create long double s = (v[i] * v[i]) / (2 * a) ;  $  TAB3 T = max of T and t[i] + t1 + ((d - s) / v[i]) ;  $  TAB2 set output decimal precision to 12 and print T ;
TAB0 maxn = const int with maxn = 2e5 + 10 ;  $  TAB0 n, a, b = int and arr = int array of size maxn ;  $  TAB1 read n then a then b ;  $  TAB1 read n values into arr ;  $  TAB1 sort arr ;  $  TAB1 print arr[b] - arr[b - 1] ;
TAB1 n =integer with 0 ;  $  TAB1 a =integer with 0 ;  $  TAB1 b =integer with 0 ;  $  TAB1 Read n ;  $  TAB1 Read a ;  $  TAB1 Read b ;  $  TAB1 h = array of 2000 integers ;  $  TAB1 Read n values into array h ;  $  TAB1 sort array elements of h in ascending order ;  $  TAB1 print h[b] - h[b - 1] and a new line ;
TAB0 create integer array arr of length 2005 ;  $  TAB1 create integers a, b, and c ;  $  TAB1 read a, b, and c ;  $  TAB1 for i = 0 to a exclusive, read arr[i] ;  $  TAB1 sort array arr ;  $  TAB1 create integer mn = arr[c - 1] ;  $  TAB1 create integer mx = arr[c] - 1 ;  $  TAB1 print the max of 0 and mx - mn + 1 ;
TAB1 n, a, b, i = long long int ;  $  TAB1 read n then a then b ;  $  TAB1 p = long long int array of size n ;  $  TAB1 read n values into p ;  $  TAB1 sort p ;  $  TAB1 x = long long int with x = p[n - a] - p[b - 1] ;  $  TAB1 print x ;
TAB0 create ints n, a and b ;  $  TAB0 declare integer array x with 2005 elements ;  $  TAB1 read n, a and b ;  $  TAB1 for i from 0 to n exclusive, read input to x[i] ;  $  TAB1 sort x ;  $  TAB1 print x[b] - x[b - 1] and '\n' ;
TAB1 create integers n, a, b ;  $  TAB1 read n read a read b ;  $  TAB1 create integer array p with size n ;  $  TAB1 for i = 0 to n exclusive, read p[i] ;  $  TAB1 sort elements from p to p + n ;  $  TAB1 create long long count with count = 0 ;  $  TAB1 if p[b-1] is not p[b] ;  $  TAB2 increment count by p[b] - p[b-1] ;  $  TAB2 print count print newline ;  $  TAB1 else ;  $  TAB2 print "0" print newline ;
TAB0 create string T ;  $  TAB0 create long long N, K, M, A, B, C[2005], D, sum ;  $  TAB1 read N, A and B ;  $  TAB1 for i=1 to N inclusive, read C[i] ;  $  TAB1 sort elements between C+1 and C + N + 1 ;  $  TAB1 print C[B + 1] - C[B] and a newline ;
TAB1 create ints n, a, b and way ;  $  TAB1 read n, a and b ;  $  TAB1 create int pointer *chore to the new array of int with n elements ;  $  TAB1 loop i from 0 to n exclusive, read chore[i] ;  $  TAB1 sort chore ;  $  TAB1 declare int j = n - 1 ;  $  TAB1 decrement j while j > n - a ;  $  TAB1 if chore[j] = chore[j - 1] ;  $  TAB2 print 0 and "\n" ;  $  TAB1 else ;  $  TAB2 print chore[j] - chore[j - 1] and "\n" ;
TAB0 define int constant maxn, set to 5e3 + 5 ;  $  TAB0 define unsigned integer constant base, set to 311 ;  $  TAB0 define unsigned integer array A to be of maxn elements ;  $  TAB1 define integer N ;  $  TAB1 read N ;  $  TAB1 define integers a and b ;  $  TAB1 read a, b ;  $  TAB1 for int i from 1 to N by 1, read A[i] ;  $  TAB1 sort(A + 1, A + N + 1) ;  $  TAB1 print A[b + 1] - A[b] and a newline ;
TAB1 create int a, b, n, i, au, nx ;  $  TAB1 read n ;  $  TAB1 read a and b ;  $  TAB1 create vector int c ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read au ;  $  TAB2 put au at the end of c ;  $  TAB1 sort c ;  $  TAB1 set nx to c[b] - c[b - 1] ;  $  TAB1 print nx and a newline ;
TAB1 n, a, b, i, ans = int ;  $  TAB1 read n then a then b ;  $  TAB1 f = int vector of size n ;  $  TAB1 read n values into f ;  $  TAB1 sort f from rbegin to rend ;  $  TAB1 set ans to n, a, b, i, ans ;  $  TAB1 print ans ;
TAB1 n, a, b = int ;  $  TAB1 read n then a then b ;  $  TAB1 V = int vector of size n ;  $  TAB1 read n values into V ;  $  TAB1 sort V ;  $  TAB1 print V[b] - V[b - 1] ;
TAB0 N=1000055 ;  $  TAB0 M=1000000007 ;  $  TAB0 n,a,b=int ;  $  TAB0 v=vector of int ;  $  TAB1 read n,a,b ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 q=int ;  $  TAB2 read q ;  $  TAB2 add q to end of v ;  $  TAB1 sort v ;  $  TAB1 q=v[n-1]-v[n-a-1] ;  $  TAB1 if q <= 0 ;  $  TAB2 print 0 ;  $  TAB2 exit ;  $  TAB1 print q ;
TAB1 n = int ;  $  TAB1 a = int ;  $  TAB1 b = int ;  $  TAB1 complexity = int vector ;  $  TAB1 read n then a then b ;  $  TAB1 i = int with i = 0 ;  $  TAB1 loop while i is less than n incrementing i each time ;  $  TAB2 tmp = int ;  $  TAB2 read tmp ;  $  TAB2 append tmp to complexity ;  $  TAB1 sort complexity ;  $  TAB1 cnt = int with cnt = 0 ;  $  TAB1 for i = complexity[b - 1] to complexity[b] increment cnt ;  $  TAB1 print cnt ;
TAB1 let n, a, b, i be long integers ;  $  TAB1 read n , a, b ;  $  TAB1 let c[n] be long integer ;  $  TAB1 for i = 0 to n exclusive , read ith element of c ;  $  TAB1 sort the values of c and c + n ;  $  TAB1 print c[b] - c[b - 1] and newline ;
TAB1 create integers n, a, b ;  $  TAB1 create integer vector h ;  $  TAB1 read n read a read b ;  $  TAB1 resize vector to size n ;  $  TAB1 for i = 0 to n exclusive, read h[i] ;  $  TAB1 sort elements from beginning of h to end of h using integer greater function to compare ;  $  TAB1 create integer min_petya with min_petya = h[a-1] ;  $  TAB1 create max_vasya with max_vasya = h[a] ;  $  TAB1 if min_petya is max_vasya ;  $  TAB2 print 0 print newline ;  $  TAB1 else ;  $  TAB2 print min_petya - max_vasya print newline ;
TAB0 N = const long long with N = 1e9 + 3 ;  $  TAB0 MN = const long long with MN = 1e9 + 7 ;  $  TAB0 MX = const long long with MX = -1e9 - 7 ;  $  TAB0 n, a, b, x, c1, c2, cnt = long long ;  $  TAB0 s, s1 = string ;  $  TAB0 bl = bool with bl = false ;  $  TAB0 c = long long ;  $  TAB0 pr = pair of long long and long long ;  $  TAB0 v = vector of long long ;  $  TAB0 mp = map from long long to long long ;  $  TAB0 st = set of long long ;  $  TAB0 iterator it = set of long long ;  $  TAB1 read n, a, b ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 append x in v ;  $  TAB1 sort v.begin() and v.end() ;  $  TAB1 if v[b - 1] is v[b] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print v[b] - v[b - 1] ;  $  TAB1 print new line ;
TAB1 create integer vector h ;  $  TAB1 create integers a, b, n, num ;  $  TAB1 read n read a read b ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read num ;  $  TAB2 add element num to end of h ;  $  TAB1 sort elements from beginning of h to end of h ;  $  TAB1 if h[b-1] is h[b] ;  $  TAB2 print 0 print newline ;  $  TAB1 else ;  $  TAB2 print h[b] - h[b-1] print newline ;
TAB1 create long long int n, a, b, kount, x, set kount = 0 ;  $  TAB1 create vector long long int h ;  $  TAB1 read n, a and b ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 add x to end of h ;  $  TAB1 sort h ;  $  TAB1 if h[b - 1] different from h[b], set kount to h[b] - h[b - 1] ;  $  TAB1 print kount ;
TAB1 create int n, a and b ;  $  TAB1 read n, a and b ;  $  TAB1 create vector int h(n) ;  $  TAB1 for i=0 to n exclusive, read h[i] ;  $  TAB1 sort vector h ;  $  TAB1 print h[b] - h[b - 1] and a newline ;
TAB0 integer function selsort with an array of long long argument arr and int argument n ;  $  TAB1 loop i from 0 to n - 1 exclusive ;  $  TAB2 declare integer min = i ;  $  TAB2 for j = to n exclusive ;  $  TAB3 if arr[j] is less than arr[min], set min to j ;  $  TAB2 create long long t with value arr[i] ;  $  TAB2 set arr[i] to arr[min] ;  $  TAB2 assign t to arr[min] ;  $  TAB1 declare integers n, a and b ;  $  TAB1 read n, a and b ;  $  TAB1 let arr be long long array with size n ;  $  TAB1 loop i from 0 to n exclusive, read input to arr[i] ;  $  TAB1 call selsort(arr, n) ;  $  TAB1 print arr[n - a] - arr[n - a - 1] and "\n" ;
TAB0 create integer array h with size 2000 ;  $  TAB1 create integers n, a, b ;  $  TAB1 read n read a read b ;  $  TAB1 for i = 0 to n exclusive, read h[i] ;  $  TAB1 sort elements from h to h + n ;  $  TAB1 create integer ans with ans = h[b] - h[b-1] ;  $  TAB1 print ans print newline ;
TAB1 a, b, n, i =integers ;  $  TAB1 Read a, b, n ;  $  TAB1 C = array of n integers ;  $  TAB1 Read n values into array C ;  $  TAB1 sort array elements of C in ascending order ;  $  TAB1 print C[b] - C[b - 1] and a new line ;
TAB0 create integers n, a, and b ;  $  TAB0 let chores be an array of integers of length 2000 ;  $  TAB1 read n, a, and b ;  $  TAB1 for i to n exclusive, read chores[i] ;  $  TAB1 sort arrary chores ;  $  TAB1 output chores[b] - chores[b - 1] and new line ;
TAB1 n, a, b, m =integers and c = array of 2555 integers ;  $  TAB1 Read n, a, b ;  $  TAB1 Read n values into array c ;  $  TAB1 sort array elements of c in ascending order ;  $  TAB1 set m to c[b] - c[b - 1] ;  $  TAB1 print m and a new line ;
TAB1 n and b = integers ;  $  TAB1 read n and b ;  $  TAB1 create vector of integers V with n elements ;  $  TAB1 read n elements into V ;  $  TAB1 assign value b to the integer total ;  $  TAB1 for integer i = 0 to n exclusive, add V[i] to the total ;  $  TAB1 double t = total / n ;  $  TAB1 create vector of doubles ans with n elements ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 if V[i] is greater than t ;  $  TAB3 print "-1\n" ;  $  TAB2 assign value of t - V[i] to the ans[i] ;  $  TAB1 print fixed and set decimal precision to 10 ;  $  TAB1 for integer i = 0 to n exclusive print ans[i] ;
TAB0 declare const int MOD = 1e9 + 7 ;  $  TAB0 create integers n, m and k ;  $  TAB0 create 2d arrays of integers a, b and c with size 10 by 100 ;  $  TAB0 integer function solve with int arguments u and v ;  $  TAB1 create vector of integers profits ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 loop j from 0 to c[u][i] exclusive, push max of 0 and b[v][i]-a[u][i] into profits ;  $  TAB1 sort profits ;  $  TAB1 declare integer variable ans = 0 ;  $  TAB1 for i = 0 to min of k and length of profits exclusive, increase ans by profits[i] ;  $  TAB1 return ans ;  $  TAB1 read n, m and k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare string variable name ;  $  TAB2 read name ;  $  TAB2 loop j from 0 to m exclusive, read a[i][j], b[i][j] and c[i][j] ;  $  TAB1 create integer ans = 0 ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 for j from 0 to n exclusive, assign max of ans and solve(i, j) to ans ;  $  TAB1 print ans and '\n' ;
TAB1 declare n as long long, a as long long array with size 100100 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 declare s as long long = 0 ;  $  TAB1 for k = 0 to n - 1 exclusive ;  $  TAB2 declare integer t = 0 ;  $  TAB2 while k + ( 1 bitshift left t + 1 ) is less than n, increment i ;  $  TAB2 increment s by a[k], a[k + (1 << t)] by a[k] ;  $  TAB2 print s, newline ;
TAB0 MaxN = const int with MaxN = 1E5 + 10 ;  $  TAB0 a = int array of size MaxN ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 lg = int with lg = log2 of n - i - 1 ;  $  TAB2 increment ans by a[i] ;  $  TAB2 increment a[i + (1 bitshift left by lg)] by a[i] ;  $  TAB2 print ans ;
TAB0 n, i, a, ans, d = integers with ans = 0, a, d = integer array of size 1111111 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 d[1] = 1 ;  $  TAB1 for i = 2 to n exclusive, d[i] = d[i / 2] * 2 ;  $  TAB1 for i = 0 to i + 1 < n ;  $  TAB2 a[i + d[n - i - 1]] = a[i + d[n - i - 1]] + a[i] ;  $  TAB2 ans = ans + a[i] ;  $  TAB2 print ans ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create long long int array arr[n] ;  $  TAB1 read every index of arr ;  $  TAB1 create long long N = 0 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 let integer t = floor(log2(n - i - 1)) ;  $  TAB2 set N to N + arr[i] ;  $  TAB2 create int j = i + pow(2, t) ;  $  TAB2 set arr[j] to arr[j] + arr[i] ;  $  TAB2 set arr[i] to 0 ;  $  TAB2 print N ;
TAB0 a = integer array of size 100001 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n + 1 exclusive, read a[i] ;  $  TAB1 res = long long with res = 0 ;  $  TAB1 t = integer ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 for t = 1, i + t <= n, t = t * 2 ;  $  TAB3 ; ;  $  TAB2 t = right shift t 1 place ;  $  TAB2 res = res + a[i] ;  $  TAB2 a[i + t] = a[i + t] + a[i] ;  $  TAB2 print res ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 create long long int a[n + 5] ;  $  TAB1 for i=0 to n inclusive, read a[i] ;  $  TAB1 set c to 0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set c to c + a[i] ;  $  TAB2 print c and a newline ;  $  TAB2 j=1 ;  $  TAB2 while ( - 1 + j * 2 < n, set j to j*2 ;  $  TAB2 set a[i + j] to a[i + j] + a[i] ;
TAB0 power2 is a long long function with long long arguments pow and mod ;  $  TAB1 declare long longs res = 1ll and x = 2ll ;  $  TAB1 while pow > 0 ;  $  TAB2 if pow & 1 is true, set res to (res * x) modulo mod ;  $  TAB2 pow >>= 1 ;  $  TAB2 assign (x * x) modulo mod to x ;  $  TAB1 return res ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n is true ;  $  TAB2 declare long long M = 1 * 1000 * 1000 * 1000 + 7 ;  $  TAB2 declare long long variable sol ;  $  TAB2 assign power2(2 * n - 1, M) to sol ;  $  TAB2 increase sol by power2(n - 1, M) ;  $  TAB2 sol = sol modulo M ;  $  TAB2 print sol ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 declare int variables a, n and p where p = 1000000007 ;  $  TAB0 long long function fastmod with long long arguments a and n ;  $  TAB1 if n is equal to 1, return a ;  $  TAB1 declare long long variable ans = fastmod(a, n / 2) modulo p ;  $  TAB1 if n is even ;  $  TAB2 return ans % p * ans % p ;  $  TAB1 else{ ;  $  TAB2 return ans % p * ans % p * a % p ;  $  TAB1 declare long long variable k ;  $  TAB1 read k ;  $  TAB1 if k >= 2 ;  $  TAB2 declare long long variable t = fastmod(2, k - 1) ;  $  TAB2 print (t + 2 * t * t % p) % p ;  $  TAB1 else if k = 1 ;  $  TAB2 print 3 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 mod = constant long long with value of 1e9 + 7 ;  $  TAB0 in function qpow2 that returns a long long and takes argument p = long long ;  $  TAB1 a = long long with value of 2 ;  $  TAB1 res = long long with value of 1 ;  $  TAB1 while p ;  $  TAB2 if p bitwise and 1 ;  $  TAB3 set res to res * a ;  $  TAB3 set res to res modulo mod ;  $  TAB2 set a to a * a ;  $  TAB2 set a to a modulo mod ;  $  TAB2 set p to right shift p by 1 ;  $  TAB1 return res ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 if n equals 0 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print (call qpow2 with argument n-1 plus call qpow2 with argument 2*n-1) modulo mod ;
TAB0 oo=1000000000, MD=1000000007 ;  $  TAB0 function fastExp (get long long b and e, return long long) ;  $  TAB1 ans=1 ;  $  TAB1 while e > 0 ;  $  TAB2 if e and 1 ans = (ans*b) modulo MD ;  $  TAB2 b = (b*b) modulo MD ;  $  TAB2 right shift e ;  $  TAB1 return ans ;  $  TAB1 n=long long ;  $  TAB1 read n ;  $  TAB1 ans=(fastExp(4,n) + fastExp(2,n)) modulo MD ;  $  TAB1 ans = (ans*fastExp(2,MD-2)) modulo MD ;  $  TAB1 print ans ;
TAB0 mul is a long long function with long long arguments x and p ;  $  TAB1 declare long long ans = 1 ;  $  TAB1 while p is not 0 ;  $  TAB2 if p & 1 != 0, assign ans * x % 1000000007 to ans ;  $  TAB2 set x to x * x % 1000000007 ;  $  TAB2 assign p >> 1 to p ;  $  TAB1 return ans ;  $  TAB1 declare long long variable n ;  $  TAB1 read n ;  $  TAB1 if n is equal to 0 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 declare long long variable w = mul(2, n - 1) % 1000000007 ;  $  TAB2 print (w + w * w % 1000000007 * 2 % 1000000007) % 1000000007 ;
TAB0 MOD = 1000000007 ;  $  TAB0 mod = 1000000007 ;  $  TAB0 N = 100005 ;  $  TAB0 inv = array of 100005 long long ;  $  TAB0 function powmod (get long long a and b, return long long) ;  $  TAB1 res = 1 ;  $  TAB1 a = a modulo mod ;  $  TAB1 while b = b >> 1 ;  $  TAB2 if b and 1 multiply res by a modulo mod ;  $  TAB2 multiply a by a modulo mod ;  $  TAB1 return res ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 inv[1] = 1 ;  $  TAB1 for i=2 to N exclusive inv[i] = (MOD-MOD/i)*inv[MOD modulo i] modulo MOD ;  $  TAB1 d=powmod(2, n) ;  $  TAB1 ans = d*(d+1) modulo mod * inv[2] modulo mod ;  $  TAB1 print ans ;
TAB0 create constant long long INF with INF = (1ll bitshift left 62) - 1 ;  $  TAB0 create constant long long M with M = 1e9 + 7 ;  $  TAB0 declare modularExponentiation with long longs x, y as arguments, returning long long ;  $  TAB1 create integer res with res = 1 ;  $  TAB1 while y is greater than 0 ;  $  TAB2 if y bitwise and 1, set res to ( res * x ) % M ;  $  TAB2 set y to y bitshift right 1 ;  $  TAB2 set x to ( x * x ) % M ;  $  TAB1 return res from function ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create long long ans with ans = result of run modularExponentiation with 2, n as arguments ;  $  TAB1 set ans to ( ans + ( ans * ans )) / 2 ;  $  TAB1 print ans % M print newline ;
TAB1 n, a, b, c = int ;  $  TAB1 read n then a then b then c ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 for i = 0 to 4000 inclusive ;  $  TAB2 for k = 0 to 4000 inclusive ;  $  TAB3 sum = int with sum = a * i + b * k ;  $  TAB3 if sum is greater than n then continue inner loop ;  $  TAB3 if (n - sum) mod c equals 0 then set ans to max of ans and (i + k + (n - sum) / c) ;  $  TAB1 print ans ;
TAB0 a = int array of size 3 with all values set to 0 ;  $  TAB0 dp = int array of size 10000 ;  $  TAB1 n = int ;  $  TAB1 read n then a[0] then a[1] then a[2] ;  $  TAB1 set all values of dp to -100 ;  $  TAB1 set dp[0] to 0 ;  $  TAB1 for i = 0 to 3 ;  $  TAB2 for j = a[i] to n inclusive set dp[j] to max of dp[j] and dp[j - a[i]] + 1 ;  $  TAB1 print dp[n] ;
TAB0 create ints n, a, b and c ;  $  TAB1 read n ;  $  TAB1 declare integer array w with size 5 ;  $  TAB1 loop i from 1 to 3 inclusive, read input to w[i] ;  $  TAB1 let e be int array with size 5000 ;  $  TAB1 set sizeof(e) bytes at the pointer e to -40 ;  $  TAB1 assign 0 to e[0] ;  $  TAB1 loop i from 1 to 3 inclusive ;  $  TAB2 for j = w[i] to n inclusive, assign max of e[j - w[i]] + 1 and e[j] to e[j] ;  $  TAB1 print e[n] ;
TAB0 integers = a array that is size 4 ;  $  TAB0 integers = dp array size 4001 ;  $  TAB1 integers = n ;  $  TAB1 read n,a[1],a[2],a[3] ;  $  TAB1 create memset dp with a size of dp ;  $  TAB1 set dp[0] to 0 ;  $  TAB1 for i = 1 to less than or equal to 3 do the following ;  $  TAB2 for j = a[i] to less than or equal to n then dp[j] = the maximum out of dp[j] and dp[j-a[i]+1 ;  $  TAB1 output dp[n] ;
TAB0 let a be int array with size 3 fileld with 0 ;  $  TAB0 declare integer array dp with size 10000 ;  $  TAB1 declare integer variable n ;  $  TAB1 read input to n, a[0], a[1] and a[2] ;  $  TAB1 set sizeof(dp) bytes at the pointer dp to -9999 ;  $  TAB1 set dp[0] to 0 ;  $  TAB1 loop i from 0 to 3 exclusive ;  $  TAB2 loop j from a[i] to n inclusive incrementing j, change dp[j] to max of dp[j] and dp[j - a[i]] + 1 ;  $  TAB1 print dp[n] ;
TAB1 n, a, b, c = integers ;  $  TAB1 read n, a, b, c ;  $  TAB1 mx = integer with mx = -1 ;  $  TAB1 for i = n / a down to 0 ;  $  TAB2 for j = n / b down to 0 ;  $  TAB3 x = integer with x = n - (i * a + j * b) ;  $  TAB3 if x modulo c is 0 and x >= 0, mx = max of mx and i + j + x / c ;  $  TAB1 print mx ;
TAB1 n, a, b, c =integers ;  $  TAB1 Read n, a, b, c ;  $  TAB1 res = integer with 0 ;  $  TAB1 for i = 0 to n / a exclusive ;  $  TAB2 for i = 0 to n / b exclusive ;  $  TAB3 set k to n - i * a - j * b ;  $  TAB3 if k is greater than 0 and k modulo c is 0, then set res to maximum value of res and i + j + k / c ;  $  TAB1 print res and a new line ;
TAB1 create integers n, a ,b, c, max with max = 0 ;  $  TAB1 read n read a read b read c ;  $  TAB1 for x = 0 to a * x is less than or equal to n, incrementing x ;  $  TAB2 for y = 0 to ( y * b ) + ( a * x ) is less than or equal to n, incrementing y ;  $  TAB3 create integer z with z = (n - a * x - b * y) / c ;  $  TAB3 if a * x + b * y + z * c is n ;  $  TAB4 if x + y + z is greater than max, set max to x + y + z ;  $  TAB1 print max print newline ;
TAB1 let n, a, b, c be integers ;  $  TAB1 read n, a, b, c ;  $  TAB1 let x, y, z, p , i be integers with p = 0 ;  $  TAB1 i is equal to minimum of a , minimum of b and c ;  $  TAB1 i is equal to n / i ;  $  TAB1 for x is equal to i , x >= 0 , decrease x by 1 ;  $  TAB2 for y = 0 to i inclusive ;  $  TAB3 z is equal to absolute value of (n - (a * x + b * y)) / c ;  $  TAB3 if a * x + b * y + c * z is equal to n , p = maximum of p and x + y + z ;  $  TAB1 print p and newline ;
TAB0 arr = integer array of size 5, n = integer ;  $  TAB0 dp = integer array of size 4004, mn = integer ;  $  TAB0 in the function fun that takes integer rem and returns integer ;  $  TAB1 if rem is 0, return 0 ;  $  TAB1 if rem < mn, return -11111111 ;  $  TAB1 if dp[rem] is not -1, return dp[rem] ;  $  TAB1 ret = integer with ret = -11111111 ;  $  TAB1 for i = 0 to 3, ret = max(ret, 1 + fun(rem - arr[i])) ;  $  TAB1 return dp[rem] = ret ;  $  TAB1 set all contents of dp to -1 ;  $  TAB1 read n ;  $  TAB1 mn = 100000000 ;  $  TAB1 for i = 0 to 2 ;  $  TAB2 read arr[i] ;  $  TAB2 mn = min of arr[i] and mn ;  $  TAB1 print fun(n) ;
TAB0 create long longs n, a, b and c ;  $  TAB0 let dp be 2d long long array with size 5006 by 5005 ;  $  TAB0 long long function result with long long arguments total and cnt ;  $  TAB1 if total = 0 return cnt ;  $  TAB1 declare long long variables d, e and f = 0 ;  $  TAB1 if dp[total][cnt] is not -1m return dp[total][cnt] ;  $  TAB1 if a <= total, assign result(total - a, cnt + 1) to d ;  $  TAB1 if b <= total, assign result(total - b, cnt + 1) to e ;  $  TAB1 if c <= total, assign result(total - c, cnt + 1) to f ;  $  TAB1 return dp[total][cnt] = max of d and max(e, f) ;  $  TAB1 set value of sizeofdp bytes at the pointer dp to -1 ;  $  TAB1 read input to n, a, b and c ;  $  TAB1 declare long long variable ans = result(n, 0) ;  $  TAB1 print ans ;
TAB1 create integer n, create integer array a with size 3 ;  $  TAB1 read n read a[0] read a[1] read a[2] ;  $  TAB1 sort elements from a to a + 3 ;  $  TAB1 create integers i, j, k, ans with i = 0, j = 0, k = 0, ans = -1 ;  $  TAB1 for i = 0 to a * a[2] is less than n + 1, incrementing i ;  $  TAB2 for j = 0 to i * a[2] + j * a[1] is less than n + 1, incrementing j ;  $  TAB3 if (n - i * a[2] - j * a[1]) % a[0] is 0, set ans to maximum of ans and i + j + (n - i * a[2] - j * a[1]) / a[0]) ;  $  TAB1 print ans print newline ;
TAB0 declare const int N = 4005 ;  $  TAB0 declare const int inf = 1e9 ;  $  TAB0 create const long long INF = 1e18 ;  $  TAB0 declare const double PI = acos(-1.0) ;  $  TAB0 declare const double EPS = 1e-8 ;  $  TAB0 create const int MOD = 1000000007 ;  $  TAB0 declare integer variables n, a, b and c ;  $  TAB0 declare int array dp with size N ;  $  TAB1 read n, a, b and c ;  $  TAB1 loop i from 0 to n inclusive, assign -inf to dp[i] ;  $  TAB1 assign 0 to dp[0] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a <= i, set dp[i] to max of dp[i] and dp[i - a] + 1 ;  $  TAB2 if b <= i, assign max of dp[i] and dp[i - b] + 1 to dp[i] ;  $  TAB2 if c <= i, change dp[i] to max of dp[i] and dp[i - c] + 1 ;  $  TAB1 print dp[n] and "\n" ;
TAB0 N = constant integer with N = 1e5 + 7 ;  $  TAB0 arr = array of size N ;  $  TAB1 n, a, b, c = integers ;  $  TAB1 read n, a, b, c ;  $  TAB1 set all contents of arr to 0 after casting to integer ;  $  TAB1 arr[a] = arr[b] = arr[c] = 1 ;  $  TAB1 for i = (cast to integer)(1) to (cast to integer)(n) ;  $  TAB2 if i >= a and arr[i - a], arr[i] = max(arr[i], arr[i - a] + 1) ;  $  TAB2 if i >= b and arr[i - b], arr[i] = max(arr[i], arr[i - b] + 1) ;  $  TAB2 if i >= c and arr[i - c], arr[i] = max(arr[i], arr[i - c] + 1) ;  $  TAB1 print arr[n] ;
TAB0 p = array of 3 integers ;  $  TAB0 dp = 2d array of size [4010][4010] ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 2, read p[i] ;  $  TAB1 minp, maxp = integers with minp = min(min(p[0], p[1]), p[2]), maxp = max(max(p[0], p[1]), p[2]) ;  $  TAB1 dp[0][0] = true ;  $  TAB1 for i = minp to n ;  $  TAB2 for k = 1 to i / minp ;  $  TAB3 for j = 0 to 2 ;  $  TAB4 if i >= p[j], dp[i][k] = dp[i][k] binary or dp[i - p[j]][k - 1] ;  $  TAB1 for i = n / minp down to 1 ;  $  TAB2 if dp[n][i] ;  $  TAB3 print i ;  $  TAB3 break loop ;
TAB0 create integers a, b and c ;  $  TAB0 declare int array memo with size 4001 ;  $  TAB0 function solve with int argument i that returns integer ;  $  TAB1 if i = 0, return 0 ;  $  TAB1 if memo[i] != - 1, return memo[i] ;  $  TAB1 create integers opt1, opt2 and opt3 = -1e9 ;  $  TAB1 if i >= a, change opt1 to solve(i - a) + 1 ;  $  TAB1 if i >= b, change opt2 to solve(i - b) + 1 ;  $  TAB1 if i >= c, change opt3 to solve(i - c) + 1 ;  $  TAB1 return memo[i] = max of opt1 and (max of opt2 and opt3) ;  $  TAB1 set first sizeof memo bytes at the pointer memo to -1 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n, a, b and c ;  $  TAB1 print result of solve(n) ;
TAB0 declare cut_ribbon with integers n, a, b, c as arguments ;  $  TAB1 create integer array arr with size n + 1 ;  $  TAB1 set bytes from arr to size of arr to value 0 ;  $  TAB1 if a is less than or equal to n, set arr[a] to 1 ;  $  TAB1 if b is less than or equal to n, set arr[b] to 1 ;  $  TAB1 if c is less than or equal to n, set arr[c] to 1 ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 if i is greater than a and arr[i-a] is not 0, set arr[i] to maximum of arr[i] and arr[i-a]+1 ;  $  TAB2 if i is greater than b and arr[i-b] is not 0, set arr[i] to maximum of arr[i] and arr[i-b]+1 ;  $  TAB2 if i is greater than c and arr[i-c] is not 0, set arr[i] to maximum of arr[i] and arr[i-c] + 1 ;  $  TAB1 return arr[n] from function ;  $  TAB1 create integers n, a, b, c ;  $  TAB1 read n read a read b read c ;  $  TAB1 print result of run cut_ribbon with n, a, b, c as arguments, print newline ;
TAB1 x, y, r, ans = integers ;  $  TAB1 read x, y, r ;  $  TAB1 if 2 * r > min(x, y) ;  $  TAB2 print Second ;  $  TAB1 else ;  $  TAB2 print First ;
TAB1 l, b, r = integers ;  $  TAB1 read l, b, r ;  $  TAB1 d, plates = integers with d = 2 * r, plates = 0 ;  $  TAB1 if min(l, b) < d ;  $  TAB2 print Second ;  $  TAB1 else ;  $  TAB2 print First ;
TAB1 a, b, c = int ;  $  TAB1 read a then b then c ;  $  TAB1 if a and b are both greater or equal to 2 * c ;  $  TAB2 print "First" ;  $  TAB1 else ;  $  TAB2 print "Second" ;  $  TAB1 print newline ;
TAB0 create constant integer MAXN with MAXN = 100000 + 7 ;  $  TAB0 create constant integer mod with mod = 23333333 ;  $  TAB0 create integers a, b, r ;  $  TAB1 read a read b read r ;  $  TAB1 if a is less than 2 * r or b is less than 2 * r ;  $  TAB2 print "Second" print newline ;  $  TAB1 else ;  $  TAB2 print "First" print newline ;
TAB0 str=array of 30100 strings ;  $  TAB0 a,b,r=int ;  $  TAB1 read a,b,r ;  $  TAB1 multiply r by 2 ;  $  TAB1 if r <= a and r <= b ;  $  TAB2 print "First" ;  $  TAB1 else ;  $  TAB2 print "Second" ;
TAB0 integers = t integer pi = 3.14 ;  $  TAB1 integers = a,b,r ;  $  TAB1 read a,b,r ;  $  TAB1 if 2 * r is greater than min(a, b then do the following ;  $  TAB2 output Second ;  $  TAB1 else ;  $  TAB2 integers = cnt = 0 ;  $  TAB2 integers = ans = max(a,b) ;  $  TAB2 integers = res = min(a,b) ;  $  TAB2 if 1 is true do the following ;  $  TAB3 set ans to maximum of ans and res ;  $  TAB3 set res to minimum and ans and res ;  $  TAB3 cnt equals cnt plus res / (2 * r) ;  $  TAB3 subtract (res / (2 * r)) * 2 * r from ans ;  $  TAB3 integers = minn = minimum of ans or res ;  $  TAB3 if minn is less than 2 * r then do the following break ;  $  TAB2 if cnt is greater than or equal to 1 then do the following ;  $  TAB3 output First ;  $  TAB2 else ;  $  TAB3 output Second ;
TAB1 n,k,l = long long integers ;  $  TAB1 input n,k,l ;  $  TAB1 if 2 * l is less than or equal to minimum of n and k then do the following ;  $  TAB2 output First ;  $  TAB1 else ;  $  TAB2 output Second ;
TAB0 a, b, r = integers ;  $  TAB1 Read a, b, r ;  $  TAB1 if a is less than 2 * r OR b is less than 2 * r ;  $  TAB2 print Second and a new line ;  $  TAB1 else do the following ;  $  TAB2 print First and a new line ;
TAB1 create integers n1, n2, r ;  $  TAB1 read n1 read n2 read r ;  $  TAB1 create integer r2 with r2 = r + r ;  $  TAB1 if n1 is greater than or equal to r2 and n2 is greater than or equal to r2 ;  $  TAB2 print "First\n" ;  $  TAB1 else ;  $  TAB2 print "Second\n" ;
TAB1 a, b, r = int ;  $  TAB1 read a then b then r ;  $  TAB1 set r to r * 2 ;  $  TAB1 if a or b is less than r ;  $  TAB2 print "Second" ;  $  TAB1 else ;  $  TAB2 print "First" ;
TAB1 create integers a, b, r, m ;  $  TAB1 read a read b read r ;  $  TAB1 if a is greater than b ;  $  TAB2 set m to b ;  $  TAB1 else ;  $  TAB2 set m to a ;  $  TAB1 if m is greater than or equal to 2 * r ;  $  TAB2 print "First" print newline ;  $  TAB1 else ;  $  TAB2 print "Second" print newline ;
TAB1 a, b, r =integers ;  $  TAB1 Read a, b, r ;  $  TAB1 if minimum value of a and b is greater than or equal to 2 * r ;  $  TAB2 print First and a new line ;  $  TAB1 else do the following ;  $  TAB2 print Second and a new line ;
TAB1 create int min, height, width, radius ;  $  TAB1 while read height, width, radius ;  $  TAB2 if heigth less than width ;  $  TAB3 set min to height ;  $  TAB2 else ;  $  TAB3 min = width ;  $  TAB2 assign radius * 2 to radius ;  $  TAB2 if min >= radius ;  $  TAB3 print First ;  $  TAB2 else ;  $  TAB3 print Second ;
TAB1 define ints a, b, and r ;  $  TAB1 read a, b, r ;  $  TAB1 if 2 r <= a and 2 r <= b ;  $  TAB2 print First and newline ;  $  TAB1 else... ;  $  TAB2 print Second followed by newline ;
TAB1 integers = a,b,r ;  $  TAB1 read a,b,r ;  $  TAB1 multiply r by 2 ;  $  TAB1 if r is greater than minimum of a or b then proceed with the following ;  $  TAB2 output Second ;  $  TAB1 else ;  $  TAB2 output First ;
TAB1 define ints n, a, b, c ;  $  TAB1 read a, b, c ;  $  TAB1 if a < c * 2 or b < c * 2 ;  $  TAB2 print "Second" and newline ;  $  TAB1 otherwise ;  $  TAB2 print "First" and a newline ;
TAB1 n, m, r = integers ;  $  TAB1 while read n, m, r ;  $  TAB2 if r * 2 <= n and r * 2 <= m ;  $  TAB3 print First ;  $  TAB2 else ;  $  TAB3 print Second ;
TAB0 a, b, r = integers ;  $  TAB1 Read a, b, r ;  $  TAB1 if a is less than r * 2 OR b is less than r * 2 ;  $  TAB2 print Second and a new line ;  $  TAB1 else do the following ;  $  TAB2 print First and a new line ;
TAB1 create integers a, b, r ;  $  TAB1 read a read b read r ;  $  TAB1 if a is greater than or equal to b ;  $  TAB2 if ( 2 * r is less than or equal to b ) ;  $  TAB3 print "First\n" ;  $  TAB2 else ;  $  TAB3 print "Second\n" ;  $  TAB1 else ;  $  TAB2 if ( 2 * r is less than or equal to a ) ;  $  TAB3 print "First\n" ;  $  TAB2 else ;  $  TAB3 print "Second\n" ;
TAB1 x, y, r = integers ;  $  TAB1 read x, y, r ;  $  TAB1 if x < r * 2 or y < r * 2 ;  $  TAB2 print Second ;  $  TAB1 else ;  $  TAB2 print First ;
TAB0 create long long int mod = 1000000007 ;  $  TAB1 let a, b and r be integers ;  $  TAB1 read a, b and r ;  $  TAB1 if 2 * r is greater than min(a, b) ;  $  TAB2 print Second ;  $  TAB1 else ;  $  TAB2 print First ;
TAB1 a, b, r = integers ;  $  TAB1 read a, b, r ;  $  TAB1 if 2 * r <= min(a, b) ;  $  TAB2 print First ;  $  TAB1 else ;  $  TAB2 print Second ;
TAB1 let k, b, n, t be long integers ;  $  TAB1 read k, b, n, t ;  $  TAB1 let the value of long integer z is equal to k + b ;  $  TAB1 let g be a integer with value g is equal to n ;  $  TAB1 while (z is less than t and g is greater than 0) ;  $  TAB2 decrease g by 1 ;  $  TAB2 let the value of z is equal to z * k + b ;  $  TAB1 if (z is equal to t) , decrease g by 1 ;  $  TAB1 print g and newline ;
TAB1 create long long u = 1 ;  $  TAB1 create long long k, b, n and t ;  $  TAB1 read k, b, n and t ;  $  TAB1 if k = 1 ;  $  TAB2 create long long x = 1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB2 create long long variable r = t ;  $  TAB2 create long long variable ans = 0 ;  $  TAB2 while r is less than x ;  $  TAB3 increase ans by one ;  $  TAB3 increase r by b ;  $  TAB2 print ans ;  $  TAB1 create long long r = 0 ;  $  TAB1 while u * (k - 1 + b) <= (k * t - t + b) ;  $  TAB2 multiply u by k ;  $  TAB2 increase r by one ;  $  TAB1 print max of n - r + 1 and 0LL ;
TAB1 l, b, n, t = long long ;  $  TAB1 read k, b, n, t ;  $  TAB1 set x = 1 and cnt = -1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 set x = k * x + b ;  $  TAB2 if x is greater than t ;  $  TAB3 set cnt = i - 1 ;  $  TAB3 stop the loop ;  $  TAB1 if cnt is equal to -1 ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print n - cnt ;
TAB1 create long long k, b, n, z ;  $  TAB1 read k, b, n and z ;  $  TAB1 set x = 1 ;  $  TAB1 while n and k*x+b equal to or greater than z ;  $  TAB2 assign k*x+b to x ;  $  TAB2 decrement n ;  $  TAB1 print n and a new line ;
TAB0 k, b, n, t, ans = integers ;  $  TAB0 assign 1 to m ;  $  TAB1 read k, b, n, t ;  $  TAB1 while m equal to or greater than t, assign m*k+b to m, increment ans ;  $  TAB1 if n >= ans ;  $  TAB2 print n - ans + 1 ;  $  TAB1 otherwise ;  $  TAB2 print 0 and a new line ;
TAB1 declare double variables k, b, n and t ;  $  TAB1 read k, b, n and t ;  $  TAB1 declare integer x = 0 ;  $  TAB1 declare double variable dub = (t *(k - 1) + b) / (b + k - 1) ;  $  TAB1 if k = 1 ;  $  TAB2 dub = (t - 1) / b ;  $  TAB2 set value of x to dub casted to integer ;  $  TAB2 if x is greater than n ;  $  TAB1 else ;  $  TAB2 for i = 1 to n + 1 inclusive ;  $  TAB3 if pow(k, i) >= dub + 1 ;  $  TAB4 set value of x to i - 1 ;  $  TAB4 stop the loop ;  $  TAB3 if i = n + 1, assign value of n to x ;  $  TAB1 create integer ans = n - x ;  $  TAB1 print ans ;
TAB1 let c1, c2, x, k, i, b, n, t, cnt be long long with cnt = 0 ;  $  TAB1 read k, b, n, t ;  $  TAB1 set c1 = b + t * (k - 1) ;  $  TAB1 set c2 = b + k - 1 ;  $  TAB1 set cnt = 1 ;  $  TAB1 set x = n ;  $  TAB1 if k not equal to 1 do the following ;  $  TAB2 for i = n iterate while i is less than or equal to 0 having i decrease by 1 after each iteration ;  $  TAB3 if c1 is greater or equal to cnt * c2 do the following ;  $  TAB4 set x = i ;  $  TAB3 else do the following ;  $  TAB4 break out of the iteration loop ;  $  TAB3 set cnt = cnt * k ;  $  TAB2 print x and one newline ;  $  TAB1 else do the following ;  $  TAB2 for i = 0 to n inclusive ;  $  TAB3 if i * b is greater or equal to 1 + n * b - t break out of the iteration loop ;  $  TAB2 print i and one newline ;
TAB0 in the function solve that takes long long k, b, n, t and returns long long ;  $  TAB1 if k is 1 ;  $  TAB2 low, high = long long with low = -1, high = n ;  $  TAB2 while high - low > 1 ;  $  TAB3 mid = long long with mid = (low + high) / 2 ;  $  TAB3 if 1 - t + b * (n - mid) <= 0 ;  $  TAB4 high = mid ;  $  TAB3 else ;  $  TAB4 low = mid ;  $  TAB2 return high ;  $  TAB1 answ = long long with answ = n ;  $  TAB1 pow = __float128 with pow = 1 ;  $  TAB1 while answ > 0 and (k - 1) * (pow * k - t) + b * (pow * k - 1) <= 0 ;  $  TAB2 pow = pow * k ;  $  TAB2 decrement answ ;  $  TAB1 return answ ;  $  TAB1 k, b, n, t = long long ;  $  TAB1 while read k, b, n, t, print solve(k, b, n, t) ;
TAB1 k, b, n, t, i, j, m, ans, r, x, xx = long long int with m = 0, x = 1, xx = 0 ;  $  TAB1 read k, b, n, t ;  $  TAB1 for i = 1 increment i ;  $  TAB2 r = (x * k) + b ;  $  TAB2 if r <= t ;  $  TAB3 increment m ;  $  TAB2 else ;  $  TAB3 break loop ;  $  TAB2 x = r ;  $  TAB1 ans = n - m ;  $  TAB1 ans = max of xx and ans ;  $  TAB1 print ans ;
TAB1 create long long integers k, b, n and t ;  $  TAB1 read k, b, n and t ;  $  TAB1 declare long long integer variable num = 1 ;  $  TAB1 declare long long integer variable index = 0 ;  $  TAB1 while num <= t ;  $  TAB2 num = k * num + b ;  $  TAB2 increment index ;  $  TAB1 decrease index ;  $  TAB1 print max of 0ll and n - index and '\n' ;
TAB0 set constant integer M = 100 + 10 ;  $  TAB1 create long long integer k, b, n, t ;  $  TAB1 read k, b, n, t ;  $  TAB1 if k = 1 ;  $  TAB2 set z = 1 + n*b ;  $  TAB2 if z is equal to or less than t ;  $  TAB3 print 0 ;  $  TAB2 otherwise ;  $  TAB3 set res = z - t ;  $  TAB3 ans = res / b + (res modulo b different from 0) ;  $  TAB3 print and and a new line ;  $  TAB1 otherwise ;  $  TAB2 set long long integer num1 = t * (k - 1) + b ;  $  TAB2 num2= k - 1 + b ;  $  TAB2 set num3 = num1/num2 ;  $  TAB2 set num1 equal to 1 ;  $  TAB2 set integer tm = 0 ;  $  TAB2 while num*k is equal to or less than num3 ;  $  TAB3 set num = num * k ;  $  TAB3 increment tm ;  $  TAB2 set m = n - tm ;  $  TAB2 m = max between m and 0 ;  $  TAB2 print m ;
TAB0 create long long ans, set k, b, n, t, x to 1 ;  $  TAB1 read k, b, n and t ;  $  TAB1 while x <=t, set x=x * k + b, increment ans ;  $  TAB1 print max between 011 and n - ans + 1 ;
TAB1 k, b, n, t = long longs ;  $  TAB1 read k, b, n and t ;  $  TAB1 declare cnt as long long set to 1 ;  $  TAB1 while c less than or equal to t ;  $  TAB2 set cnt to cnt * k + b ;  $  TAB2 decrement n ;  $  TAB1 print max(0LL, n + 1) ;
TAB0 long long function bigmod with long long arguments a, b and m ;  $  TAB1 if b = 0 ;  $  TAB1 x = bigmod of a, b / 2 and m ;  $  TAB1 x = (x % m * x % m) % m ;  $  TAB1 if b % 2) x = (x % m * a % m ;  $  TAB1 return x % m ;  $  TAB0 long long function po with long long arguments a and b ;  $  TAB1 return 1 if a = 1 ;  $  TAB1 declare long long r = 1 ;  $  TAB1 decrement b and loop, while b > 0; multiply r by a in that loop ;  $  TAB1 return r ;  $  TAB1 declare long long variables k, b, n, t and s where s = 0 ;  $  TAB1 read k, b, n and t ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 assign value of s + po(k, i) to new long long v ;  $  TAB2 if v >= t ;  $  TAB3 if v is greater than t ;  $  TAB4 print n - i + 1 ;  $  TAB3 else ;  $  TAB4 print n - i ;  $  TAB2 increase s by b * po(k, i) ;  $  TAB1 print "0" ;
TAB1 k, b, n, t =integers ;  $  TAB1 Read k, b, n, t ;  $  TAB1 sum=integer with 1 ;  $  TAB1 cnt=integer with 0 ;  $  TAB1 while sum is less than or equal to t ;  $  TAB2 set sum to sum * k + b ;  $  TAB2 increment cnt ;  $  TAB1 if cnt is greater than n ;  $  TAB2 print 0 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print n - cnt + 1 and a new line ;
TAB0 long long function solve with long long arguments k, b, n and t ;  $  TAB1 if k = 1 ;  $  TAB2 declare long longs low = -1 and high = n ;  $  TAB2 while high - low is greater than 1 ;  $  TAB3 declare long long variable mid = (low + high) / 2 ;  $  TAB3 if 1 - t + b * (n - mid) <= 0 ;  $  TAB4 assign value of mid to high ;  $  TAB3 else ;  $  TAB4 assign value of mid to low ;  $  TAB2 return high ;  $  TAB1 declare long long variable answ = n ;  $  TAB1 declare __float128 variable pow = 1 ;  $  TAB1 while answ > 0 && (k - 1) * (pow * k - t) + b * (pow * k - 1) <= 0 ;  $  TAB2 multiply pow by k ;  $  TAB2 decrease answ ;  $  TAB1 return answ ;  $  TAB1 declare long long variables k, b, n and t ;  $  TAB1 while car read k, b, n and t, print solve(k, b, n, t) ;
TAB0 declare integers n, m, a, b and 2d array of integers v of size 2100 by 2100 ;  $  TAB0 declare integers k, x, y and 2d array of integers d of size 2100 by 2100 ;  $  TAB0 boolean function solve with integer arguments x, y and k ;  $  TAB1 create ingteger variables t, l = max of 1 and x - k; r = min of x + k and n ;  $  TAB1 for integer i = l to r inclusive ;  $  TAB2 set t to k - abs(i - x) ;  $  TAB2 if y - t is greater than 0 && !v[i][y - t] ;  $  TAB3 set a to i ;  $  TAB3 set value of b to y - t ;  $  TAB3 return 1 ;  $  TAB2 if y + t <= m && !v[i][y + t] ;  $  TAB3 a = i ;  $  TAB3 b = y + t ;  $  TAB3 return 1 ;  $  TAB1 read n, m and k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read x and y ;  $  TAB2 for integer j = -2 to 2 inclusive ;  $  TAB3 for integer k = -2 to 2 inclusive ;  $  TAB4 if x + j < 1 || x + j > n || y + k < 1 || y + k is greater than m, continue the loop ;  $  TAB4 d[x][y] = max(d[x][y], d[x + j][y + k] - abs(j) - abs(k)) ;  $  TAB2 while solve(x, y, d[x][y]) is false, increment d[x][y] ;  $  TAB2 v[a][b] = 1 ;  $  TAB2 print a, " ", b and a new line ;
TAB0 create integers n, m, a, b, create 2d integer array v with size 2100 by 2100 ;  $  TAB0 create integers k, x, y, create 2d integer array d with size 2100 by 2100 ;  $  TAB0 declare solve with integers x, y, k as arguments, returning boolean ;  $  TAB1 create integers l, r, t with l = maximum of ( 1 and x - k ), r = minimum of ( x + k and n ) ;  $  TAB1 for i = l to r inclusive ;  $  TAB2 set t to k - absolute value of ( i - x ) ;  $  TAB2 if y - t is greater than 0 and v[i][y-t] is false ;  $  TAB3 set a to i ;  $  TAB3 set b to y - t ;  $  TAB3 return 1 from function ;  $  TAB2 if y + t is less than or equal to m and v[i][y+t] is false ;  $  TAB3 set a to i ;  $  TAB3 set b to y + t ;  $  TAB3 return 1 ;  $  TAB1 read n read m read k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read x read y ;  $  TAB2 for j = -2 to 2 inclusive ;  $  TAB3 for k = -2 to 2 inclusive ;  $  TAB4 if x + j is less than 1 or x + j is greater than n or y + k is less than 1 or y + k is greater than m, break current loop iteration ;  $  TAB4 set d[x][y] to maximum of ( d[x][y] and d[x+j][y+k] - absolute value of j - absolute value of k ) ;  $  TAB2 while result of run solve with x, y, d[x][y] as arguments is false, increment d[x][y] ;  $  TAB2 set v[a][b] to 1 ;  $  TAB2 print a print " " print b print newline ;
TAB0 create integers n, m, a and b, and 2d array of integers v 2100 by 2100 ;  $  TAB0 create integers k, x and y, and 2d array of integers d 2100 by 2100 ;  $  TAB0 boolean method solve with integer arguments x, y and k ;  $  TAB1 declare integers t, l = max of 1 and x - k and r = min of x + k and n ;  $  TAB1 for integer i = l to r inclusive ;  $  TAB2 set value of t to k - abs(i - x) ;  $  TAB2 if y - t is greater than 0 and !v[i][y - t] ;  $  TAB3 set a to i ;  $  TAB3 set value of b to y - t ;  $  TAB3 return 1 ;  $  TAB2 if y + t <= m and !v[i][y + t] ;  $  TAB3 assign value of i to the a ;  $  TAB3 set b to y + t ;  $  TAB3 return 1 ;  $  TAB1 read n, m and k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read x and y ;  $  TAB2 for integer j = -2 to 2 inclusive ;  $  TAB3 for integer k = -2 to 2 inclusive ;  $  TAB4 if x + j < 1 or x + j > n or y + k < 1 or y + k > m, continue the loop ;  $  TAB4 set d[x][y] = max of d[x][y] and d[x + j][y + k] - abs(j) - abs(k)) ;  $  TAB2 while solve(x, y, d[x][y]) is 0, increment d[x][y] ;  $  TAB2 set value of v[a][b] to 1 ;  $  TAB2 print a, " ", b and a new line ;
TAB0 a = array of pair of size 200020 of int and int ;  $  TAB0 n, k, c, x, y, m, z, ac, t, b, i = long long ;  $  TAB1 for (read n, increment i, decrement n ;  $  TAB2 for read k, c, x, y, m and t = 0, decrement k, z = max(z, t) ;  $  TAB3 if ac <= 200000, a[increment ac] = make_pair(pair of int to int (t, c), i) ;  $  TAB3 b = (c * x + y) modulo m ;  $  TAB3 if b < c and k, increment t ;  $  TAB3 c = b ;  $  TAB1 print z ;  $  TAB1 if ac < 200001 ;  $  TAB2 sort a and a + ac ;  $  TAB2 for i = 0 to ac, print first.second of a[i]," ", second of a[i] + 1 ;
TAB0 a1, a2, n, k, second, ans, ans1 = long long with second = 0 and ans = 0 ;  $  TAB0 h = pair of long long and pair of long long and long long vector ;  $  TAB0 in function read ;  $  TAB1 read n ;  $  TAB1 x, y, m = int then for i = 0 to n ;  $  TAB2 read k ;  $  TAB2 add k to second ;  $  TAB2 read a1 ;  $  TAB2 t = long long with t = a1 ;  $  TAB2 read x then y then m ;  $  TAB2 append make_pair of 0 and make_pair of a1 and i + 1 to h ;  $  TAB2 set ans1 to 0 ;  $  TAB2 for j = 1 to k ;  $  TAB3 set a2 to (a1 * x + y) mod m ;  $  TAB3 if a2 is less than a1 then increment ans1 ;  $  TAB3 set a1 to a2 ;  $  TAB3 set t to max of t and a1 ;  $  TAB3 if size of h is less or equal to 200000 then append make_pair of ans1 and make_pair of a1 and i + 1 to h ;  $  TAB2 set ans to max of ans and ans1 ;  $  TAB1 sort vector h ;  $  TAB1 print ans ;  $  TAB1 if second is less or equal to 200000 ;  $  TAB2 for i = 0 to second print h[i].second.first and h[i].second.second ;  $  TAB1 call read ;
TAB0 a = pair of pair of int and int and int of size 200020 ;  $  TAB0 n, k, c, x, y, m, z, ac, t, b, i = long long ;  $  TAB1 read n then loop n times decrementing n and incrementing i each time ;  $  TAB2 read k then c then x then y then m and set t to 0 then loop k times decrementing k and setting z to max of z and t each time ;  $  TAB3 if ac is less or equal to 200000 then set a[ac] to value of make_pair of pair of int and int of t and c and i then increment ac ;  $  TAB3 set b to (c * x + y) mod m ;  $  TAB3 if b is less than c and k is not 0 then increment t ;  $  TAB3 set c to b ;  $  TAB1 print z ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 call sort on a and a + ac ;  $  TAB2 for i = 0 to ac print a[i].first.second and a[i].second + 1 ;
TAB0 let a = array of integers of length 200020, pair of integets ;  $  TAB0 let n, k, c, x, y, m, z, ac, t, b, i be long integers ;  $  TAB1 for read n, n is decreased by 1, i is increased by 1 ;  $  TAB2 for read the values k, c, x, y, m, t , t = 0 , k value is decreased by 1, z = maximum of z and t ;  $  TAB3 if ac <= 200000, a[ac++] = make_pair(pair<int, int>(t, c), i ;  $  TAB3 let the value of b is equal to c * x + y modulo m ;  $  TAB3 if b is less than c and k, increase t by 1 ;  $  TAB3 the value of b is assigned to c ;  $  TAB1 print z and newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort the values a and a + ac ;  $  TAB2 for i = 0 to ac exclusive, print a[i].first.second and a[i].second + 1 and newline ;
TAB0 create pair array a with size 200020 with pair of ( pair of ( integer and integer) and integer ) ;  $  TAB0 create long longs n, k, c, x, y, m, z, ac, t, b, i ;  $  TAB1 for read n, decrement n, incrementing i ;  $  TAB2 for read k read c read x read y read m, t = 0, deecrement k, setting z to maximum of z and t ;  $  TAB3 if ac is less than or equal to 200000, set a[increment ac] to make pair from ( pair of ( integer and integer ) initialized with ( t, c ), and integer ) ;  $  TAB3 set b to (c * x + y) % m ;  $  TAB3 if b is less than c and k, increment t ;  $  TAB3 set c to b ;  $  TAB1 print z print newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort elements from a to a + ac ;  $  TAB2 for i = 0 to ac exclusive, print second element of first element of a[i] print " " print second element of a[i] + 1 print newline ;
TAB1 create long longs n, count with count = 0 ;  $  TAB1 read n ;  $  TAB1 create constant integer max_i with max_i = 2e5 ;  $  TAB1 create integer counter with counter = 0 ;  $  TAB1 create tuple array data with integer, integer, integer, with size max_i + 9 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create long longs k, a0, x, y, m, t, a, with t = 0, a = 0 ;  $  TAB2 read k read a0 read x read y read m ;  $  TAB2 for j = 0 to k exclusive ;  $  TAB3 if counter is less than or equal to max_i, set data[increment counter] to make tuple from t, a0, i ;  $  TAB3 set a to (a0 * x + y) % m ;  $  TAB3 if a is less than a0 and j is not k - 1, increment t ;  $  TAB3 set a0 to a ;  $  TAB2 set count to maximum of count and t ;  $  TAB1 print count print newline ;  $  TAB1 if counter is less than or equal to max_i ;  $  TAB2 sort elements from data to data + counter ;  $  TAB2 for i = 0 to counter exclusive, print get element 1 from data[i] print " " print get element 2 from data[i] + 1 print newline ;
TAB0 MAX = const int with MAX = 2e5 ;  $  TAB0 a = pair of pair of long long and long long and long long array of size MAX + 9 ;  $  TAB0 n, k, a0, x, y, m, ans, cnt, t, tmp = long long ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read k then a0 then x then y then m then set t to 0 ;  $  TAB2 for j = 0 to k ;  $  TAB3 if cnt is less or equal to MAX then set a[cnt] to {{t, a0}, i} then increment cnt ;  $  TAB3 set tmp to (a0 * x + y) mod m ;  $  TAB3 if tmp is less than a0 and j is not k - 1 increment t ;  $  TAB3 set a0 to tmp ;  $  TAB2 set ans to max of ans and t ;  $  TAB1 print ans ;  $  TAB1 if cnt is less than MAX ;  $  TAB2 call sort on a and a + cnt ;  $  TAB2 for i = 0 to cnt print a[i].first.second and a[i].second + 1 ;
TAB0 create pair a with pair of ( integer, integer), integer, with size 200020 ;  $  TAB0 create long longs n, k, c, x, y, m, z, ac, t, b, i ;  $  TAB1 for read n to decrement n, incrementing i ;  $  TAB2 for read k read c read x read y read m, t = 0 to decrement k, setting z to maximum of z and t ;  $  TAB3 if ac is less than or equal to 200000, set a[increment ac] to create pair from ( pair of integer and integer initialized with ( t, c ) and i ;  $  TAB3 set b to (c * x + y) % m ;  $  TAB3 if b is less than c and k, increment t ;  $  TAB3 set c to b ;  $  TAB1 print z print newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort elements from a to a + ac ;  $  TAB2 for i = 0 to ac exclusive, print second element of first element of a[i] print " " print second element of a[i] + 1 print newline ;
TAB0 create pair of ( pair of ( integer and integer ) and integer ) array a with size 200020 ;  $  TAB0 create long longs n, k, c, x, y, m, z, ac, t, b, i ;  $  TAB1 for read n to decrement n, incrementing i ;  $  TAB2 for read k read c read x read y read m, t = 0 to decrement k, setting z to maximum of z and t ;  $  TAB3 if ac is less than or equal to 200000, set a[increment ac] to make pair of ( pair of ( integer and integer) initialized with (t, c ) and i ) ;  $  TAB3 set b to (c * x + y) % m ;  $  TAB3 if b is less than c and k, increment t ;  $  TAB3 set c to b ;  $  TAB1 print z print newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort elements from a to a + ac ;  $  TAB2 for i = 0 to ac exclusive, print second element of first element of a[i] print " " print second element of a[i] + 1 print newline ;
TAB0 create pair of ( pair of ( integer, integer ), integer ) array a with size 200020 ;  $  TAB0 create long longs n, k, c, x, y, m, z, ac, t, b, i ;  $  TAB1 for read n to derement n, incrementing i ;  $  TAB2 for read k read c read x read y read m, t = 0 to decrement k, setting z to maximum of z and t ;  $  TAB3 if ac is less than or equal to 200000 set a[increment ac] to make pair from ( pair of (integer, integer ) initialized with (t, c ), i ) ;  $  TAB3 set b to (c * x + y) % m ;  $  TAB3 if b is less than c and k, increment t ;  $  TAB3 set c to b ;  $  TAB1 print z print newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort elements from a to a + ac ;  $  TAB2 for i = 0 to ac exclusive, print second element of first element of a[i] print " " print second element of a[i] + 1 print newline ;
TAB0 create pair array of pair of ( pair of ( integer, integer ), integer ) a with size 200020 ;  $  TAB0 create long longs n, k, c, x, y, m, z, ac, t, b, i ;  $  TAB1 for read n, decrement n, incrementing i ;  $  TAB2 for read k read c read x read y read m, t = 0, to decrement k, setting z to maximum of z and t ;  $  TAB3 if ac is less than or equal to 200000, set a[increment ac] to make pair with ( (pair of integer, integer initialized with ( t, c ) ), i ;  $  TAB3 set b to (c * x + y) % m ;  $  TAB3 if b is less than c and k, increment t ;  $  TAB3 set c to b ;  $  TAB1 print z print newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort elements from a to a + ac ;  $  TAB2 for i = 0 to ac exclusive, print second element of first element of a[i] print " " print second element of a[i] + 1 print newline ;
TAB0 create pair array a with size 200020 with pair of ( pair of (integer and integer) and integer ) ;  $  TAB0 create long longs n, k, c, x, y, m, z, ac, t, b, i ;  $  TAB1 for read n, decrement n, incrementing i ;  $  TAB2 for read k read c read x read y read m, t = 0, decrement k, setting z to maximum of z and t ;  $  TAB3 if ac is less than or equal to 200000, set a[increment ac] to new pair from ( pair of ( integer and integer ) initialized with (t, c) and i ) ;  $  TAB3 set b to (c * x + y) % m ;  $  TAB3 if b is less than c and k, increment t ;  $  TAB3 set c to b ;  $  TAB1 print z print newline ;  $  TAB1 if ac is less than 200001 ;  $  TAB2 sort elements from a to a + ac ;  $  TAB2 for i = 0 to ac exclusive, print second element of first element of a[i] print " " print second element of a[i] + 1 print newline ;
TAB1 create integers a, b and c ;  $  TAB1 read input to a, b and c ;  $  TAB1 if b is greater than c, swap b and c ;  $  TAB1 print (2 * a + b - 1) * b + (c - b - 1) * (a + b - 1) ;
TAB0 oo = constant integer = 1e9 ;  $  TAB1 a, b, c = integer ;  $  TAB1 read a, b, c ;  $  TAB1 ans = integer = b * c + (a - 1) * (b + c - 1) ;  $  TAB1 print ans ;
TAB1 a, b, c =integers ;  $  TAB1 Read a, b, c ;  $  TAB1 print a * b + b * c + c * a - (a + b + c) + 1 and a new line ;
TAB0 declare long longs x, y and z ;  $  TAB1 read x, y and z ;  $  TAB1 print x * y + y * z + x * z - x - z - y + 1 ;
TAB0 let gcd be a function which accepts integers a and b ;  $  TAB1 return gcd(b, a modulo b) if b else a ;  $  TAB1 let n, m, c be integers ;  $  TAB1 read n, m, c ;  $  TAB1 print n * m * c - (n - 1) * (m - 1) * (c - 1) and newline ;
TAB1 create integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print a * b + b * c + a * c - a - b - c + 1 print newline ;
TAB1 create integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print a * b + b * c + c * a - a - b - c + 1 print newline ;
TAB1 let a, b, c be int ;  $  TAB1 read a and b and c ;  $  TAB1 print a * b + b * c + c * a - a - b - c + 1 ;
TAB0 create integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print a * b + b * c + c * a - a - b - c + 1 print newline ;
TAB1 create long longs a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 create long long ans with ans = (c + a - 1) * (b + a - 1) - a * (a - 1) ;  $  TAB1 print ans print newline ;
TAB0 create constant long long OO with OO = 1e5 + 555 ;  $  TAB0 declare rakm with character x as argument, returning long long ;  $  TAB1 return x - 48 from function ;  $  TAB0 declare _7rf with long long x as argument, returning character ;  $  TAB1 return x + 48 from function ;  $  TAB0 declare odd with long long x as argument, returning boolean ;  $  TAB1 return x % 2 ;  $  TAB0 declare even with long long x as argument, returning boolean ;  $  TAB1 return 1 - x % 2 ;  $  TAB0 declare factorial with long long x as argument, returning long long ;  $  TAB1 if x is 0 or x is 1 ;  $  TAB2 return 1 from function ;  $  TAB1 else ;  $  TAB2 return x * result of run factorial with x - 1 as argument ;  $  TAB0 declare ss with long long x as argument, returning long long ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 while x is greater than 0 ;  $  TAB2 increment sum by x % 10 ;  $  TAB2 set x to x / 10 ;  $  TAB1 return sum from function ;  $  TAB0 declare a3ks with long long x as argument, returning long long ;  $  TAB1 create long longs b, u, with b = 0, u = x ;  $  TAB1 while u is greater than 0 ;  $  TAB2 set b to ( b * 10 ) + u % 10 ;  $  TAB2 set u to u / 10 ;  $  TAB1 return b from function ;  $  TAB0 declare prime with long long x as argument, returning boolean ;  $  TAB1 for i = 2 to x exclusive ;  $  TAB2 if x % i is 0, return 0 from function ;  $  TAB1 return 1 from function ;  $  TAB1 create integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print (a * b * c) - ((a - 1) * (b - 1) * (c - 1)) print newline ;
TAB1 declare integer variables a, b and c ;  $  TAB1 read a, b and c ;  $  TAB1 print (a * b) + (b * c) + (c * a) - a - b - c + 1 ;
TAB0 declare constant int N = 1e5 + 100 ;  $  TAB0 create ints a, b and c ;  $  TAB0 declare vector of integers called v ;  $  TAB1 read input to a, b and c ;  $  TAB1 print (a * b * c) - (a - 1) * (b - 1) * (c - 1) ;
TAB0 create constant integer MAX with MAX = 5e4 + 5 ;  $  TAB0 create constant long long MAX2 with MAX2 = 11 ;  $  TAB0 create constant integer MOD with MOD = 1000000000 + 7 ;  $  TAB0 create constant long long INF with INF = 20000 ;  $  TAB0 create constant integer array dr with dr = {1, 0, -1, 0, 1, 1, -1, -1} ;  $  TAB0 create constant integer array dc with dc = {0, 1, 0, -1, 1, -1, 1, -1} ;  $  TAB0 create constant double pi with pi = acosign of -1 ;  $  TAB0 create integer a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print a * b + (a + b - 1) * (c - 1) print "\n" ;
TAB0 N=100100 ;  $  TAB0 a,b,c=int ;  $  TAB0 v=vector of int ;  $  TAB1 read a,b,c ;  $  TAB1 print (b*c)+(a-1)*(b+c-1) ;
TAB1 a, b, c =integers ;  $  TAB1 Read a, b, c ;  $  TAB1 ans = integer, set to (c + a - 1) * (b + a - 1) - a * (a - 1) ;  $  TAB1 print ans and a new line ;
TAB1 create long long a, b, c ;  $  TAB1 read a, b, c ;  $  TAB1 print (a * b * c) - ((a - 1) * (b - 1) * (c - 1)) ;
TAB1 a, b, c = integer ;  $  TAB1 read a, b, c ;  $  TAB1 print the result of b * c + (a - 1) * (b + c - 1) ;
TAB0 create constant integer INF with INF = 0x3f3f3f3f ;  $  TAB0 create constant long long INFLL with INFLL = 0x3f3f3f3f3f3f3f3fLL ;  $  TAB1 create long longs a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 create long long ans with ans = (c + a - 1) * (b + a - 1) - a * (a - 1) ;  $  TAB1 print ans print newline ;
TAB1 declare string variables str, str2 and s ;  $  TAB1 declare integer variables num and i ;  $  TAB1 read num and str and loop further ;  $  TAB2 sort str ;  $  TAB2 for i from 0 to length of str exclusive adding num to i, append str[i] to str2 ;  $  TAB2 for i = 0 to num exclusive, append str2 to s ;  $  TAB2 assign s to str2 ;  $  TAB2 sort str2 ;  $  TAB2 if str2 != str ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print s ;
TAB0 create constant double PI with PI = acosign of -1 ;  $  TAB0 create constant integer MAX with MAX = 2e9 + 7 ;  $  TAB0 create constant long long MOD with MOD = 1e9 + 7 ;  $  TAB0 create map m from character to integer ;  $  TAB0 declare solve with no arguments, returning void ;  $  TAB1 create integer k ;  $  TAB1 read k ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create integer n with n = size of s ;  $  TAB1 if n % k is not 0 ;  $  TAB2 print -1 print newline ;  $  TAB2 return false from function ;  $  TAB1 create integer need with need = n / k ;  $  TAB1 for i = 0 to n exclusive, increment m[s[i]] ;  $  TAB1 create string t with t = "" ;  $  TAB1 for i = 97 to 123 exclusive ;  $  TAB2 if m[character casted i] % k is 0 ;  $  TAB3 for j = 0 to m[character casted i] / k exclusive, increment by character casted i ;  $  TAB2 else ;  $  TAB3 print -1 print newline ;  $  TAB3 return false from function ;  $  TAB1 for i = 0 to k exclusive, print t ;  $  TAB1 print newline ;  $  TAB1 run solve ;
TAB1 k = int ;  $  TAB1 s = string ;  $  TAB1 c = int array of size 26 with all values set to 0 ;  $  TAB1 read k then s ;  $  TAB1 if size of s is not a multiple of k ;  $  TAB2 print -1 ;  $  TAB1 for i = 0 to size of s increment c[s[i] - 'a'] ;  $  TAB1 for i = 0 to 26 ;  $  TAB2 if c[i] is not a multiple of k ;  $  TAB3 print -1 ;  $  TAB1 res = string ;  $  TAB1 for i = 0 to 26 ;  $  TAB2 for j = 0 to c[i] / k increment res by ('a' + i) as char ;  $  TAB1 for i = 0 to k print res ;  $  TAB1 print newline ;
TAB1 k=int ;  $  TAB1 s=string ;  $  TAB1 read k,s ;  $  TAB1 count=array of 26 int filled with 0 ;  $  TAB1 for i=0 to length of s exclusive increment count[s[i]-'a'] ;  $  TAB1 s1=string ;  $  TAB1 c=0 ;  $  TAB1 increment c while c<26 ;  $  TAB2 if count[c] modulo k not equal 0 ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 append count[c]/k copies of 'a'+c to s1 ;  $  TAB1 if c is 26 ;  $  TAB2 while decremented value of k not equal 0 print s1 ;  $  TAB2 print newline ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 declare count as integer ;  $  TAB1 read count ;  $  TAB1 declare s as string ;  $  TAB1 read s ;  $  TAB1 declare n as integer = length of s ;  $  TAB1 declare integer array a size 26 = {0} ;  $  TAB1 for i = 0 to n exclusive, increment a[s[i] - 'a'] ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if a[i] % count is not 0 ;  $  TAB3 print "-1" print newline ;  $  TAB1 declare string ans = "" ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if a[i] is true ;  $  TAB3 for j = 0 to a[i] / count exclusive ;  $  TAB4 declare temp with temp = i + 'a' ;  $  TAB4 let ans be ans + temp ;  $  TAB1 for i = 0 to count exclusive, print ans ;  $  TAB1 print newline ;
TAB1 create integers k ;  $  TAB1 read k ;  $  TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 create integer n with n = length of str ;  $  TAB1 create map characters from character to integer ;  $  TAB1 create map iterator itr from character to integer ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if first index of str[i] in characters is not end of characters ;  $  TAB3 increment characters[str[i]] by 1 ;  $  TAB2 else ;  $  TAB3 set characters[str[i]] to 1 ;  $  TAB1 for itr = beginning of characters to itr is not end of characters, incrementing itr ;  $  TAB2 if second element of itr is less than k ;  $  TAB3 print -1 print newline ;  $  TAB3 exit program with code 0 ;  $  TAB1 create string new_str with new_str = "" ;  $  TAB1 for itr = beginning of characters to itr is not end of characters, incrementing itr ;  $  TAB2 create integer repeat with repeat = second element of itr / k ;  $  TAB2 for i = 0 to repeat exclusive, set new_str to new_str + first element of itr ;  $  TAB1 if length of new_str * k is less than n ;  $  TAB2 print -1 print newline ;  $  TAB2 exit program with code 0 ;  $  TAB1 for i = 0 to k exclusive, print new_str ;  $  TAB1 print newline ;
TAB0 declare an array of chars inPutStr with size 1001 ;  $  TAB0 declare int k and an array of ints strArr with 26 elements ;  $  TAB0 create char array subStr with 1001 elements ;  $  TAB0 makeAString is a void function ;  $  TAB1 create integer idx = 0 ;  $  TAB1 for j from 0 to 26 exclusive ;  $  TAB2 while strArr[j] != 0 ;  $  TAB3 change subStr[idx] to j + 'a' ;  $  TAB3 increment idx by one ;  $  TAB3 assign strArr[j] - k to strArr[j] ;  $  TAB1 for i from 0 to k exclusive ;  $  TAB2 for j = 0 to idx exclusive, print subStr[j] ;  $  TAB1 print new line ;  $  TAB1 for i = 0 to 26 exclusive, set strArr[i] to 0 ;  $  TAB1 read k ;  $  TAB1 read inPutStr ;  $  TAB1 for i = 0 while inPutStr[i] != 0 ;  $  TAB2 create integer id = inPutStr[i] - 'a' ;  $  TAB2 set strArr[id] to strArr[id] + 1 ;  $  TAB1 declare bool Result = true ;  $  TAB1 for i from 0 to 26 exclusive ;  $  TAB2 if strArr[i] % k != 0 ;  $  TAB3 assign false to Result ;  $  TAB3 break the loop ;  $  TAB1 if Result is true ;  $  TAB2 call makeAString() ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB1 let T, i, j, count, d and m be integers with count = 1 and m = 0 ;  $  TAB1 create an arrays of characters s and k with size 1000 ;  $  TAB1 read T and s ;  $  TAB1 set j to length of s ;  $  TAB1 sort s ;  $  TAB1 for i = 0 to j exclusive ;  $  TAB2 if s[i] = s[i + 1] ;  $  TAB3 add 1 to count ;  $  TAB2 else ;  $  TAB3 if count % T = 0 ;  $  TAB4 assign count / T to d ;  $  TAB4 loop, decrementing d, while it is not 0 ;  $  TAB5 set k[m] to s[i] ;  $  TAB5 increment m ;  $  TAB4 set count to 1 ;  $  TAB3 else ;  $  TAB4 print "-1" ;  $  TAB1 set k[m] to '\0' ;  $  TAB1 decrement T and loop further, while T is not 0 ;  $  TAB2 for i from 0 while k[i] != '\0' incrementing i, print k[i] in a loop ;  $  TAB1 print new line ;
TAB0 let solve be a void function which accepts string str , integer k ;  $  TAB1 cnt = array of integers of length 26 ;  $  TAB1 memset of cnt, 0, length of cnt ;  $  TAB1 for i = 0 to length of str exclusive , increment cnt[str[i] - a] by 1 ;  $  TAB1 let s1 be a string ;  $  TAB1 initialize integer i to 0 ;  $  TAB1 for i is less than 26 , increment i by 1 ;  $  TAB2 if cnt[i] modulo k is not equal to 0 ;  $  TAB3 stop ;  $  TAB2 else do the following ;  $  TAB3 It extends the string s1 by appending cnt[i] / k, 'a' + i ;  $  TAB1 if i is equal to 26 ;  $  TAB2 while k is decremented by 1, print s1 ;  $  TAB2 print newline ;  $  TAB1 else do the following ;  $  TAB2 print -1 and newline ;  $  TAB1 let k be a integer ;  $  TAB1 read k ;  $  TAB1 let str be a string ;  $  TAB1 read str ;  $  TAB1 solve the values str, k ;
TAB0 declare long longs i, j, k, n, m, ans, sz, c1, c2, x, f, z, declare long long arrays a with size 100009, ch with size 26 ;  $  TAB1 declare string s ;  $  TAB1 read k, s ;  $  TAB1 let sz be size of s ;  $  TAB1 declare character set st ;  $  TAB1 declare it as character set iterator ;  $  TAB1 for i = 0 to sz exclusive ;  $  TAB2 insert s[i] into st ;  $  TAB2 increment ch[s[i] - 'a'] ;  $  TAB1 declare long long vector v ;  $  TAB1 for it = beginning of st to it is not end of st, incrementing it ;  $  TAB2 create character c ;  $  TAB2 set c to value of it ;  $  TAB2 add ch[c-'a'] to end of v ;  $  TAB1 let sz be size of v ;  $  TAB1 for i = 0 to sz exclusive ;  $  TAB2 if v[i] % k is not 0 ;  $  TAB3 let f be 1 ;  $  TAB3 break loop ;  $  TAB1 if f is true ;  $  TAB2 print "-1" print newline ;  $  TAB1 else ;  $  TAB2 declare ss as string ;  $  TAB2 for it = beginning of st to it is not end of st, incrementing it ;  $  TAB3 declare character c ;  $  TAB3 let c be value of it ;  $  TAB3 let z be ch[c - 'a'] / k ;  $  TAB3 for i = 0 to z exclusive, increment ss by c ;  $  TAB2 for i = 0 to k exclusive, print ss ;  $  TAB2 print newline ;
TAB1 create integers i, Len, k, create integer array Arr with size 26 with Arr = {0} ;  $  TAB1 create strings s, kString ;  $  TAB1 read k read s ;  $  TAB1 for i = 0 to length of s exclusive, increment Arr[s[i] - 'a'] ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if Arr[i] % k is not 0 ;  $  TAB3 break loop ;  $  TAB2 else ;  $  TAB3 append 'a' + i to kString (Arr[i] / k) times ;  $  TAB1 if i is 26 ;  $  TAB2 while decrement k is true, print kString ;  $  TAB2 print newline ;  $  TAB1 else ;  $  TAB2 print -1 print newline ;
TAB0 create constant double PI = acos(-1) ;  $  TAB0 let const integer MAX = 2e9 + 7 ;  $  TAB0 let const long long MOD = 1e9 + 7 ;  $  TAB0 create map m of chars to ints ;  $  TAB0 declare solve ;  $  TAB1 let int k ;  $  TAB1 read k ;  $  TAB1 let string s ;  $  TAB1 read s ;  $  TAB1 create int n = s.size() ;  $  TAB1 if n modulo k is not equal to 0 ;  $  TAB2 print - 1 ;  $  TAB2 terminate function ;  $  TAB1 create int need = n / k ;  $  TAB1 increment all contents of m[s] ;  $  TAB1 let string t = "" ;  $  TAB1 for i = 97 to 123 exclusive ;  $  TAB2 if m[char(i)] modulo k is 0 ;  $  TAB3 for j = 0 to m[char(i)] / k exclusive, set t to t + char(i) ;  $  TAB2 otherwise do ;  $  TAB3 print -1 ;  $  TAB3 end function ;  $  TAB1 for i = 0 to k exclusive, print t ;  $  TAB1 print new line ;  $  TAB1 call solve ;
TAB0 ctn = int array of length 30 ;  $  TAB1 let n, k be int ;  $  TAB1 let s be a string ;  $  TAB1 read k and s ;  $  TAB1 set n to the lenght of s ;  $  TAB1 for i = 0 to n exclusive increment cnt at s[i] - 'a' ;  $  TAB1 let can = true be a boolean ;  $  TAB1 let ss be a blank string ;  $  TAB1 for x = 'a' to 'z' inclusive ;  $  TAB2 if cnt[x - 'a'] mod k is not 0 ;  $  TAB3 can is false ;  $  TAB2 else ;  $  TAB3 for j = 0 to cnt[x-'a']/k increment ss by x ;  $  TAB1 if can ;  $  TAB2 print ss for k times ;  $  TAB2 print new line ;  $  TAB1 else ;  $  TAB2 print -1 and new line ;
TAB1 create integers k, i and j ;  $  TAB1 declare string s ;  $  TAB1 create integer array c with size 26 ;  $  TAB1 read input to k and s ;  $  TAB1 if length of s % k != 0 ;  $  TAB2 print -1 to the standart output ;  $  TAB1 for i = 0 to length of s exclusive, ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if c[i] % k != 0 ;  $  TAB3 print -1 to the standart output ;  $  TAB1 create string result ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 for j from 0 to c[i] / k exclusive, append char('a' + i) to result ;  $  TAB1 for i from 0 to k exclusive, print result to the standart output ;  $  TAB1 print new line ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for i = 1 to n exclusive, print ' ' and i ;  $  TAB1 print '\n' ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for i = 1 to n exclusive, print " " print i ;  $  TAB1 print newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for i = 1 to n exclusive, print " " print i ;  $  TAB1 print newline ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for integer i = 1 to n exclusive print " " and i ;  $  TAB1 print new line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if i is not n print " " ;  $  TAB2 print i ;  $  TAB1 print new line ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for ( i= 1 to n-1 inclusive ), print space and i ;  $  TAB1 print newline ;
TAB1 declare integer a ;  $  TAB1 loop while reading a ;  $  TAB2 print a ;  $  TAB2 for integer i = 1 to a exclusive, print ' ' and i ;  $  TAB2 print new line ;
TAB0 in the function desperate_optimization that takes integer precision ;  $  TAB1 print floats with a fixed number of decimals ;  $  TAB1 print floats with showpoint format ;  $  TAB1 print precision with precision ;  $  TAB1 call desperate_optimization on 10 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print n ;  $  TAB1 for i = 1 to n exclusive, print i ;  $  TAB1 print new line ;
TAB1 a =integer ;  $  TAB1 Read a ;  $  TAB1 print a ;  $  TAB1 if a is greater than 1, then print " " ;  $  TAB1 for i = 0 to a - 1 exclusive ;  $  TAB2 print i + 1 ;  $  TAB2 if i + 2 is not equal to a, then print " " ;  $  TAB1 print a new line ;
TAB0 MOD = integer ;  $  TAB0 in function mod_pow with arguments of long long a and long long b and returns a long long ;  $  TAB1 if b is 0, then return 1 ;  $  TAB1 if b is 1, then return a modulo MOD ;  $  TAB1 if the last bit in binary of b is 1, then return a modulo MOD * the result of calling mod_pow with arguments a, b - 1 and then modulo the result of that function by MOD ;  $  TAB1 x = long long = the result of calling mod_pow with arguments a, and the b with its elements shifted to the right by one bit ;  $  TAB1 return (x * x) modulo MOD ;  $  TAB1 n, m = integer ;  $  TAB1 read n, m ;  $  TAB1 MOD = m ;  $  TAB1 r = integer = the result of calling mod_pow with arguments 3, n ;  $  TAB1 if r is 0 ;  $  TAB2 print the result of m - 1 ;  $  TAB1 else ;  $  TAB2 print the result of r - 1 ;
TAB0 declare power with long longs x, integers y, m as arguments, returning long long ;  $  TAB1 create long long res with res = 1 ;  $  TAB1 while y is greater than 0 ;  $  TAB2 if y bitwise and 1 ;  $  TAB3 set res to res * x ;  $  TAB3 set res to res % m ;  $  TAB2 set y to y bitwise right 1 ;  $  TAB2 set x to x * x ;  $  TAB2 set x to x % m ;  $  TAB1 return res from function ;  $  TAB1 create integers n, m ;  $  TAB1 read n read m ;  $  TAB1 create integer ans with ans = result of run power with long long casted (3), n, m as arguments ;  $  TAB1 if ans is 0 ;  $  TAB2 print m - 1 print newline ;  $  TAB1 else ;  $  TAB2 print ans - 1 print newline ;
TAB0 in function modl taking three long longs n, k and p and returning a long long ;  $  TAB1 if n is 0 return 0 ;  $  TAB1 if k is 0 ;  $  TAB2 return 1 ;  $  TAB1 else if k is even ;  $  TAB2 return (modl of n, k / 2 and p * (modl of n, k / 2 and p)) mod p ;  $  TAB1 else ;  $  TAB2 return (n * modl of n, k - 1 and p) mod p ;  $  TAB1 n, m = long long ;  $  TAB1 read n then m ;  $  TAB1 z = long long with z = modl of 3, n and m ;  $  TAB1 if z is 0 ;  $  TAB2 print m - 1 ;  $  TAB1 else ;  $  TAB2 print z - 1 ;
TAB1 declare integers n and m ;  $  TAB1 read n and m ;  $  TAB1 create long long a = 3 ;  $  TAB1 create integer i = 1 ;  $  TAB1 create integer two = 0 ;  $  TAB1 while n > 0 ;  $  TAB2 if n is odd, assign i * a % m to i ;  $  TAB2 set n to n / 2 ;  $  TAB2 change a to a squared modulo m ;  $  TAB1 print (i - 1 + m) % m ;
TAB0 in function pow taking three long longs a, b and m and returning a long long ;  $  TAB1 res = long long with res = 1 ;  $  TAB1 loop while b is not 0 ;  $  TAB2 if b bitwise-and 1 is true then set res to (res * a) mod m ;  $  TAB2 set a to (a * a) mod m ;  $  TAB2 set b to b bithsift right by 1 ;  $  TAB1 return res ;  $  TAB1 n, m = long long ;  $  TAB1 read n then m ;  $  TAB1 print ((pow of 3, n and m) - 1 + m) mod m ;
TAB0 MAX = const integer with MAX = 3e4 + 5 ;  $  TAB0 MAX2 = const long long with MAX2 = 11 ;  $  TAB0 MOD = const integer with MOD = 1000000000 + 7 ;  $  TAB0 INF = const long long with INF = 20000 ;  $  TAB0 dr = const integer array with dr = {1, 0, -1, 0, 1, 1, -1, -1} ;  $  TAB0 dc = const integer array with dc = {0, 1, 0, -1, 1, -1, 1, -1} ;  $  TAB0 pi = const double with pi = acos(-1) ;  $  TAB0 eps = const double with eps = 1e-9 ;  $  TAB0 n, m = long long ;  $  TAB0 in the function pw that returns long long ;  $  TAB1 ret = long long with ret = 1, x = 3 ;  $  TAB1 while n ;  $  TAB2 if n bitwise and 1, ret = (ret * x) modulo m ;  $  TAB2 x = (x * x) modulo m ;  $  TAB2 n = right shift n 1 place ;  $  TAB1 return ret ;  $  TAB1 read n, m ;  $  TAB1 print (pw() + m - 1) modulo m ;
TAB0 m = long long ;  $  TAB0 in function pw taking two long longs x and p and returning a long long ;  $  TAB1 if p is 0 return 1 mod m ;  $  TAB1 z = long long with z = pw of x and p / 2 ;  $  TAB1 set z to z * z ;  $  TAB1 set z to z mod m ;  $  TAB1 if p is even return z ;  $  TAB1 set z to z * x ;  $  TAB1 set z to z mod m ;  $  TAB1 return z ;  $  TAB1 n = long long ;  $  TAB1 raed n then m ;  $  TAB1 res = long long with res = 2 * ((pw of 3 and n) - 1) / 2 ;  $  TAB1 set res to res mod m ;  $  TAB1 increment res by m ;  $  TAB1 set res to res mod m ;  $  TAB1 print res ;
TAB0 declare power taking in long long ints x, y, and MOD and returning long long int ;  $  TAB1 create unsigned long long int res = 1 ;  $  TAB1 set x to x modulo MOD ;  $  TAB1 while y is more than 0 ;  $  TAB2 if y & 1 is truthy, set res to (res * x) % MOD ;  $  TAB2 set y to y >> 1 ;  $  TAB2 set x to (x * x) % MOD ;  $  TAB1 convert res to long long int and return it ;  $  TAB0 create long long ints n, m, and res ;  $  TAB1 read n and m ;  $  TAB1 set res to power(3, n, m) - 1 ;  $  TAB1 print (res + m) % m ;
TAB0 declare long longs m and n ;  $  TAB0 pw is a long long function with long long arguments a and b ;  $  TAB1 declare long long res with value 1 ;  $  TAB1 while b is not 0 ;  $  TAB2 if b & 1 is true, change res to (res * a) modulo m ;  $  TAB2 set a to a squared modulo m ;  $  TAB2 change the value of b to b divided by 2 ;  $  TAB1 return res ;  $  TAB1 read input to n and m ;  $  TAB1 declare long long variable with name ans and value = pw of 3 and n ;  $  TAB1 decrement ans ;  $  TAB1 if ans is less than 0, add m to ans ;  $  TAB1 print ans to the standard output ;
TAB0 declare f taking in long long integers n and m and returning long long int ;  $  TAB1 if n is equal to 0 ;  $  TAB2 return the result of 1 % m ;  $  TAB1 else if n is equal to 1 ;  $  TAB2 return 3 % m ;  $  TAB1 create long long tmp = f(n / 2, m) ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 return the result of tmp * tmp % m ;  $  TAB1 otherwise ;  $  TAB2 return (tmp * tmp % m) * 3 % m ;  $  TAB1 create ints n and m ;  $  TAB1 read n and m ;  $  TAB1 create long long int fx = f(n, m) ;  $  TAB1 if fx is 0 ;  $  TAB2 print m - 1 ;  $  TAB1 else ;  $  TAB2 print fx - 1 ;
TAB0 m = long long ;  $  TAB0 in function power taking a long long a and an int n and returning an int ;  $  TAB1 res = long long with res = 1 ;  $  TAB1 loop while n is greater than 0 ;  $  TAB2 if n is uneven ;  $  TAB3 set res to res * a ;  $  TAB3 set res to res mod m ;  $  TAB2 set a to a * a ;  $  TAB2 set a to a mod m ;  $  TAB2 set n to n / 2 ;  $  TAB1 return res ;  $  TAB1 n = int ;  $  TAB1 read n then m ;  $  TAB1 print (((power of 3 and n) - 1) mod m + m) mod m ;
TAB0 declare power with long longs a, b, m as arguments, returning long long ;  $  TAB1 create long longs temp, ans with temp = a, ans = 1 ;  $  TAB1 while b is true ;  $  TAB2 if b bitwise and 1 is true, set ans to (ans % m * temp % m) % m ;  $  TAB2 set temp to (temp % m * temp % m) % m ;  $  TAB2 set b to b / 2 ;  $  TAB1 return ans from function ;  $  TAB1 create long longs n, m ;  $  TAB1 read n read m ;  $  TAB1 print ( result of run power with 3, n, m as arguments - 1 + m ) % m print newline ;
TAB1 create long longs ax, ay, bx, by, cx, cy ;  $  TAB1 read ax read ay read bx read by read cx read cy ;  $  TAB1 create long long ds with ds = (bx * cy - by * cx) - (ax * cy - ay * cx) + (ax * by - ay * bx) ;  $  TAB1 if ds is 0 ;  $  TAB2 print "TOWARDS" ;  $  TAB1 else if ds is less than 0 ;  $  TAB2 print "RIGHT" ;  $  TAB1 else ;  $  TAB2 print "LEFT" ;  $  TAB1 print '\n' ;
TAB0 function solve (no args, no return value) ;  $  TAB1 a1,a2,b1,b2,c1,c2=long long ;  $  TAB1 read a1,a2,b1,b2,c1,c2 ;  $  TAB1 d=(b1-a1)*(c2-a2)-(b2-a2)*(c1-a1) ;  $  TAB1 if d is 0 ;  $  TAB2 print "TOWARDS" ;  $  TAB1 else if d > 0 ;  $  TAB2 print "LEFT" ;  $  TAB1 else ;  $  TAB2 print "RIGHT" ;  $  TAB1 set output precision to 12 digits ;  $  TAB1 solve() ;
TAB1 x1, x2, x3, y1, y2, y3 =integers ;  $  TAB1 Read x1, x2, x3, y1, y2, y3 ;  $  TAB1 if (y2 - y1) * (x3 - x2) is equal to (y3 - y2) * (x2 - x1) ;  $  TAB2 print TOWARDS and a new line ;  $  TAB1 else if (x3 - x2) * (y2 - y1) - (x2 - x1) * (y3 - y2) is greater than 0 ;  $  TAB2 print RIGHT and a new line ;  $  TAB1 else do the following ;  $  TAB2 print LEFT and a new line ;
TAB1 create long long integers xa, ya, xb, yb, xc, and yc ;  $  TAB1 read xa, ya, xb, yb, xc, and yc ;  $  TAB1 create long long integer cp = (xb - xa) * (yc - ya) - (yb - ya) * (xc - xa) ;  $  TAB1 if cp is greater than 0 ;  $  TAB2 print "LEFT\n" ;  $  TAB1 else if cp is less than 0 ;  $  TAB2 print "RIGHT\n" ;  $  TAB1 else ;  $  TAB2 print "TOWARDS\n" ;
TAB1 create long long integers x1, x2, x3, y1, y2, y3 ;  $  TAB1 read x1 read y1 read x2 read y2 read x3 read y3 ;  $  TAB1 if (y2 - y1) * (x3 - x2) is (y3 - y2) * (x2 - x1) ;  $  TAB2 print "TOWARDS" print newline ;  $  TAB1 else if (x3 - x2) * (y2 - y1) - (x2 - x1) * (y3 - y2) is greater than 0 ;  $  TAB2 print "RIGHT" print newline ;  $  TAB1 else ;  $  TAB2 print "LEFT" print newline ;
TAB1 x1, y1, x2, y2, x3, y3 = long longs ;  $  TAB1 read x1, y1, x2, y2, x3, y3 ;  $  TAB1 vx1 = long long = x2 - x1, vy1 = long long = y2 - y1, vx2 = long long = x3 - x2, vy2 = long long = y3 - y2 ;  $  TAB1 cha = long long = vx1 * vy2 - vx2 * vy1 ;  $  TAB1 if cha > 0, then print LEFT ;  $  TAB1 if cha < 0, then print RIGHT ;  $  TAB1 if cha is 0, then print TOWARDS ;
TAB1 f = integer = 0 ;  $  TAB1 x1, x2, x3, y1, y, 2, y3 = long longs ;  $  TAB1 read x1, y1, x2, y2, x3, y3 ;  $  TAB1 temp = long long = (x2 - x1) * (y3 - y2) - (y2 - y1) * (x3 - x2) ;  $  TAB1 if temp is 0 ;  $  TAB2 f = 0 ;  $  TAB1 else if temp > 0 ;  $  TAB2 f = 1 ;  $  TAB1 else ;  $  TAB2 f = 2 ;  $  TAB1 if f is 0 ;  $  TAB2 print TOWARDS ;  $  TAB1 else if f is 2 ;  $  TAB2 print RIGHT ;  $  TAB1 else ;  $  TAB2 print LEFT ;
TAB1 let x = array of long integers of length 4, y = array of long integers of length 4 ;  $  TAB1 for i = 1 to 3 inclusive , read x[i] and y[i] ;  $  TAB1 let a1 be a long integer with a1 = y[1] - y[2] ;  $  TAB1 let b1 be a long integer with b1 = x[2] - x[1] ;  $  TAB1 let c1 be a long integer with c1 = x[1] * y[2] - x[2] * y[1] ;  $  TAB1 let a2 be a long integer with a2 = y[2] - y[3] ;  $  TAB1 let b2 be a long integer with b2 = x[3] - x[2] ;  $  TAB1 let c2 be a long integer with c2 = x[2] * y[3] - x[3] * y[2] ;  $  TAB1 if a1 * b2 is equal to a2 * b1 and b1 * c2 is equal to b2 * c1 ;  $  TAB2 print TOWARDS and newline ;  $  TAB1 else do the following ;  $  TAB2 if a1 * b2 is greater than a2 * b1 ;  $  TAB3 print LEFT and newline ;  $  TAB2 else do the following ;  $  TAB3 print RIGHT and newline ;
TAB0 declare cross with long longs x0, y0, x1, y1 as arguments, returning long long ;  $  TAB1 return y1 * x0 - y0 * x1 from function ;  $  TAB1 create long long vectors X, Y with X initialized with 3, Y initialized with 3 ;  $  TAB1 for i = 0 to 3 exclusive, read X[i] read Y[i] ;  $  TAB1 create long long c with c = result of run cross with X[1] - X[0], Y[1] - Y[0], X[2] - X[1], Y[2] - Y[1] as arguments ;  $  TAB1 if c is 0 ;  $  TAB2 print "TOWARDS\n" ;  $  TAB1 else if c is less than 0 ;  $  TAB2 print "RIGHT\n" ;  $  TAB1 else ;  $  TAB2 print "LEFT\n" ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is odd ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print "2 1" ;  $  TAB2 for integer i = 3 to n exclusive with increment step 2, print " ", i + 1, " " and i ;  $  TAB2 print new line ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 if n mod 2 = 1 ;  $  TAB2 print -1 ;  $  TAB1 otherwise ;  $  TAB2 print 2 1 ;  $  TAB2 for i=3 to n exclusive, print " ", i+1," ", i ;  $  TAB2 print a new line ;
TAB1 create int t and i ;  $  TAB1 read t ;  $  TAB1 if t mod 2 = 1 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print 2 1 ;  $  TAB2 for i=3 to t exclusive, print " ", i + 1, " ", i ;  $  TAB2 print a new line ;
TAB0 let num be integer array with size 101 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 for integer i = 0 to n exclusive, set num[i] to i + 1 ;  $  TAB1 if n is even ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 for i = 1 to n exclusive swap num[i - 1] and num[i] ;  $  TAB2 for integer i = 0 to n - 1 exclusive print num[i] and " " ;  $  TAB2 print num[n - 1] ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 if n is uneven ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 i = 1 to n inclusive ;  $  TAB3 if i is uneven ;  $  TAB4 print i + 1 ;  $  TAB3 else ;  $  TAB4 print i - 1 ;  $  TAB3 if i equals n ;  $  TAB4 print newline ;  $  TAB3 else ;  $  TAB4 print " " ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is 1 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 temp = integer with temp = 2 ;  $  TAB2 count = integer with count = 0 ;  $  TAB2 while not temp is n - 1 ;  $  TAB3 print temp," " ;  $  TAB3 increment count ;  $  TAB3 if count modulo 2 is 1 ;  $  TAB4 temp = temp - 1 ;  $  TAB3 else ;  $  TAB4 temp = temp + 3 ;  $  TAB2 print temp ;
TAB1 a, b = integer ;  $  TAB1 read a ;  $  TAB1 if a modulo not 2 is 0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 for b = 2 to a - 2 inclusive with b = b + 2 then print b,' ', b - 1 ;  $  TAB2 print a,' ',a - 1 ;
TAB1 p = integer ;  $  TAB1 read p ;  $  TAB1 if p modulo 2 is 1 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print 2 1 ;  $  TAB2 for i = 4 to p inclusive with i = i + 2 then print i, i - 1 ;  $  TAB2 print new line ;
TAB0 declare fastIo with no arguments, returning void ;  $  TAB1 run fastIo ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create pair of ( pair of ( integer and integer ) and integer ) m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integers x, y ;  $  TAB2 read x read y ;  $  TAB2 increment m[ new pair with x and y ] ;  $  TAB1 create map iterator it from pair of integer and integer to integer with it = beginning of m ;  $  TAB1 create integer cnt with cnt = 1 ;  $  TAB1 while it is not end of m ;  $  TAB2 if second element of it is greater than cnt, set cnt to second element of it ;  $  TAB2 increment it ;  $  TAB1 print cnt print newline ;
TAB0 create constant int N = 1e5 + 5 ;  $  TAB0 create integers n, res and Max with res and Max = 1 ;  $  TAB0 a is an array of int/int pairs with N elements ;  $  TAB0 void function Input ;  $  TAB1 read n ;  $  TAB1 for i from 1 to n inclusive incrementing i, read a[i].first and a[i].second ;  $  TAB1 sort a from index 1 to n + 1 ;  $  TAB0 Solve is a void function ;  $  TAB1 declare integer curr = 1 ;  $  TAB1 loop i from 2 to n inclusive ;  $  TAB2 if a[i].first = a[i - 1].first and a[i].second = a[i - 1].second ;  $  TAB3 increment curr and set res to max of res and curr ;  $  TAB2 else ;  $  TAB3 change curr to 1 ;  $  TAB1 print res and '\n' ;  $  TAB1 call function Input ;  $  TAB1 call function Solve ;
TAB1 n, temp = integer 2d array of size [24][60], maxi, h, m = integers with temp = {0}, maxi = 0 ;  $  TAB1 read n ;  $  TAB1 while n ;  $  TAB2 read h, m ;  $  TAB2 increment temp[h][m] ;  $  TAB2 if temp[h][m] > maxi, maxi = temp[h][m] ;  $  TAB1 print maxi ;
TAB1 n, h, m, t , c, rest = integer with t = -1, c = 0, res = 1 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read h and m ;  $  TAB2 t0 = integer with t0 = h * 60 + m ;  $  TAB2 c = if t0 is t, c + 1 else 1 ;  $  TAB2 if c > res, res = c ;  $  TAB2 t = t0 ;  $  TAB1 print res ;
TAB1 create integers n, i, j ;  $  TAB1 create integer arrays h, m, count with h size 100000, m size 100000, count size 100000 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read h[i] read m[i] ;  $  TAB1 for i = 0 to n exclusive, set count[i] to 1 ;  $  TAB1 for i = 0, j = 0 to i is less than n - 1, incrementing i ;  $  TAB2 if h[i] is h[i+1] and m[i] is m[i+1] ;  $  TAB3 increment count[j] ;  $  TAB2 else if count[j] is not 1 ;  $  TAB3 increment j ;  $  TAB1 create integer ans with ans = count[0] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if count[i] is greater than ans, set ans to count[i] ;  $  TAB1 print ans print newline ;
TAB1 n, i, c = int with c = 0 and x, y = int array of size 100010 each ;  $  TAB1 v = int vector ;  $  TAB1 read n ;  $  TAB1 mp = map of pair of int and int and int ;  $  TAB1 for i = 0 to n ;  $  TAB2 read x[i] then y[i] ;  $  TAB2 increment mp[make_pair of x[i] and y[i]] ;  $  TAB1 for i = 0 to n append mp[make_pair of x[i] and y[i]] to v ;  $  TAB1 sort v ;  $  TAB1 if last element of v is 0 ;  $  TAB2 print "1" ;  $  TAB1 else ;  $  TAB2 print last element of v ;
TAB1 n, a, b, c , d , co, m = integers with c = -1, d = -1, co = 0, m = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a and b ;  $  TAB2 if a is c and b is d ;  $  TAB3 increment co ;  $  TAB3 m = max of m and co ;  $  TAB2 else ;  $  TAB3 co = 1 ;  $  TAB2 c = a ;  $  TAB2 d = b ;  $  TAB1 if m is 0 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print m ;
TAB1 let n, h, m, a = two dimensional array of int with lengths 100, 100 ;  $  TAB1 while reading new values for n ;  $  TAB2 let maxa = int = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read h, m ;  $  TAB3 increment a[h][m] ;  $  TAB3 if a[h][m] > maxa, maxa = a[h][m] ;  $  TAB2 print maxa ;
TAB1 create integers n, i ;  $  TAB1 read n ;  $  TAB1 create integer arrays a, b, with a size n + 2, b size n + 2 ;  $  TAB1 create integer m with m = 0 ;  $  TAB1 create 2d integer array c with size 24 by 60, with c = {0} ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] read b[i] ;  $  TAB2 increment c[a[i]][b[i]] ;  $  TAB1 for i = 0 to n exclusive, set m to maximum of m and c[a[i]][b[i]] ;  $  TAB1 print m print "\n" ;
TAB1 n, hh, mm, h, m, res, k = integers with hh and mm value of -1, res value of 0 and k value of 1 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read h and m ;  $  TAB2 if h equals hh and m equals mm ;  $  TAB3 add 1 to k ;  $  TAB2 else ;  $  TAB3 set hh to h ;  $  TAB3 set mm to m ;  $  TAB3 if res is greater than k then set res to res otherwise set res to k ;  $  TAB3 set k to 1 ;  $  TAB1 if res is greater than k then print res otherwise print k ;
TAB0 declare const int N = 1e5 + 5 ;  $  TAB0 let n, res and Max be ints with res and Max = 1 ;  $  TAB0 create an array of int/int pairs called a with N elements ;  $  TAB0 function Input ;  $  TAB1 read n ;  $  TAB1 loop i from 1 to n inclusive, read a[i].first and a[i].second ;  $  TAB1 sort a from index 1 to n + 1 ;  $  TAB0 void function Solve ;  $  TAB1 declare int variable curr = 1 ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if a[i].first = a[i - 1].first and a[i].second = a[i - 1].second ;  $  TAB3 increment curr by one and set res to max of res and curr ;  $  TAB2 else ;  $  TAB3 assign 1 to curr ;  $  TAB1 print res and '\n' ;  $  TAB1 call function Input ;  $  TAB1 call function Solve ;
TAB1 n, ele1, ele2 = integers ;  $  TAB1 read n ;  $  TAB1 arr = integer array of size[24 * 60] with arr[24 * 60] = {} ;  $  TAB1 while decrement n ;  $  TAB2 read ele1 and ele2 ;  $  TAB2 increment arr[ele1 * 60 + ele2] ;  $  TAB1 max = integer with max = 0 ;  $  TAB1 for i = 0 to 24 * 60 exclusive ;  $  TAB2 if arr[i] > max, max = arr[i] ;  $  TAB1 print max ;
TAB1 integers = t ;  $  TAB1 read t ;  $  TAB1 integers array = arr[t][2] ;  $  TAB1 read arr[i][0],arr[i][1] ;  $  TAB1 set int count to 0, temp to 1 ;  $  TAB1 for i = 1 to less than t do the following ;  $  TAB2 set if (temp > count) count equals temp ;  $  TAB2 if arr[i - 1][0] is arr[i][0] && arr[i - 1][1] equals arr[i][1] then do next ;  $  TAB3 add one to temp ;  $  TAB2 else ;  $  TAB3 set temp to 1 ;  $  TAB1 set if (temp > count) count equals temp ;  $  TAB1 output count ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integers ans, cnt, ph, pm, with ans = 1, cnt = 1, ph = 99, pm = 99 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integers h, m ;  $  TAB2 read h read m ;  $  TAB2 if h is ph and m is pm ;  $  TAB3 increment cnt ;  $  TAB3 if ans is less than cnt, set ans to cnt ;  $  TAB2 else ;  $  TAB3 set cnt to 1 ;  $  TAB2 set ph to h ;  $  TAB2 set pm to m ;  $  TAB1 print ans print newline ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 let Arr , Sum be long integers with Sum = 0, Arr = array of long integers of length n + 2 ;  $  TAB1 for i = 1 to n inclusive , read Arr[i] , increment Sum by Arr[i] ;  $  TAB1 let s, t be long integers ;  $  TAB1 read s, t ;  $  TAB1 let Cnt be a long integer with Cnt = 0 ;  $  TAB1 if s is greater than t , swap s, t ;  $  TAB1 for i = s to t exclusive , increment Cnt by Arr[i] ;  $  TAB1 print minimum of Cnt, Sum - Cnt and newline ;
TAB1 a,i,s,t,n=int, b,c,l1,l2=0, arr=array of 105 int ;  $  TAB1 read n ;  $  TAB1 for a=1 to n inclusive read arr[a] ;  $  TAB1 read s ;  $  TAB1 read t ;  $  TAB1 if s>t ;  $  TAB2 b=t ;  $  TAB2 c=s ;  $  TAB1 else ;  $  TAB2 b=s ;  $  TAB2 c=t ;  $  TAB1 for a=b to c exclusive add arr[a] to l1 ;  $  TAB1 increment a from c while a is not b ;  $  TAB2 add arr[a] to l2 ;  $  TAB2 if a is n a=0 ;  $  TAB1 if l1 <= l2 ;  $  TAB2 print l1 ;  $  TAB1 else ;  $  TAB2 print l2 ;
TAB0 let d, n, x be integers with d = 2d array of integers with 107 rows and 107 columns respectively ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive , d[i][j] is equal to INT_MAX / 10 ;  $  TAB1 for i = 1 to n inclusive , d[i][i] is equal to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 let j be a integer with j = i + 1 ;  $  TAB2 if j is greater than n ,decrement j by n ;  $  TAB2 d[i][j] is equal to x ;  $  TAB2 d[j][i] is equal to x ;  $  TAB1 for k = 1 to n inclusive ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to n inclusive ;  $  TAB4 if d[i][k] + d[k][j] is less than d[i][j] , d[i][j] is equal to d[i][k] + d[k][j] ;  $  TAB1 let s, t be integers ;  $  TAB1 read s, t ;  $  TAB1 print d[s][t] and newline ;
TAB0 create ints K, X, Y, M, and N and int array A of size 105 ;  $  TAB1 read K ;  $  TAB1 for i = 1 to K ;  $  TAB2 read A[i] ;  $  TAB2 set N to N + A[i] ;  $  TAB1 read X and Y ;  $  TAB1 for i = min(X, Y) to max(X, Y), set M to M + A[i] ;  $  TAB1 print the min of M and N - M ;
TAB0 let int array arr of size 1000 ;  $  TAB1 let int n ;  $  TAB1 while cin >> n is truthy ;  $  TAB2 let int total = 0 ;  $  TAB2 set every index of arr to 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read arr[i] ;  $  TAB3 set total to total + arr[i] ;  $  TAB2 let ints s and t ;  $  TAB2 read s and t ;  $  TAB2 create int tmp ;  $  TAB2 if s is greater than t ;  $  TAB3 set tmp to s ;  $  TAB3 set s to t ;  $  TAB3 set t to tmp ;  $  TAB2 decrease s by 1 ;  $  TAB2 reduce t by 1 ;  $  TAB2 let ints a1 = 0 and a2 = 0 ;  $  TAB2 for i = s to t exclusive, set a1 to a1 + arr[i] ;  $  TAB2 set a2 to total - a1 ;  $  TAB2 print the min of a2 and a1 ;
TAB1 n, sum, sum1, a, b = int with sum = 0 and sum1 = 0 ;  $  TAB1 read n ;  $  TAB1 x = int array of size n ;  $  TAB1 read n values into x ;  $  TAB1 read a then b ;  $  TAB1 for i = min of a - 1, b - 1 to max of b - 1, a- 1 increment sum by x[i] ;  $  TAB1 for i = min of a - 1, b - 1 to 0 inclusive decrementing i increment sum1 by x[i] ;  $  TAB1 for i = n - 1 to max of b - 1, a - 1 decrementing i increment sum1 by x[i] ;  $  TAB1 print min of sum, sum1 ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer array d with size n + 10 ;  $  TAB1 set d[0] to 0 ;  $  TAB1 for i = 1 to n inclusive, read d[i] ;  $  TAB1 create integer array s with size n + 15 ;  $  TAB1 set s[0] to 0 ;  $  TAB1 for i = 1 to n + 1 inclusive, set s[i] to s[i-1] + d[i-1] ;  $  TAB1 create integers sr, t ;  $  TAB1 read sr read t ;  $  TAB1 if sr is greater than t, swap values between sr and t ;  $  TAB1 create integer ans with ans = s[t] - s[sr] ;  $  TAB1 set ans to minimum of ( ans and s[sr] + s[n + 1] - s[t] ) ;  $  TAB1 print ans print newline ;
TAB0 create integers n, m, x, y, ans, ans1, create integer arrays dist, prefs with dist size 100015, prefs size 100015 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read dist[i] ;  $  TAB1 set prefs[0] to dist[0] ;  $  TAB1 for i = 1 to n exclusive, set prefs[i] to dist[i] + prefs[i - 1] ;  $  TAB1 read x read y ;  $  TAB1 decrement x ;  $  TAB1 decrement y ;  $  TAB1 if x is greater than y, swap values between x and y ;  $  TAB1 set ans to prefs[y-1] ;  $  TAB1 decrement ans by prefs[x-1] ;  $  TAB1 set ans1 to prefs[n-1] - ans ;  $  TAB1 print minimum of ans and ans1 print newline ;
TAB0 declare n, s, t, ans = 0, tmp = 0 as integers, declare line as integer array with size 101 = {} ;  $  TAB1 declare integer i ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read line[i] ;  $  TAB1 read s read t ;  $  TAB1 let i be s ;  $  TAB1 while i is not t ;  $  TAB2 increment tmp by line[i] ;  $  TAB2 increment i ;  $  TAB2 if i is greater than n, let i be 1 ;  $  TAB1 while i is not s ;  $  TAB2 increment ans by line[i] ;  $  TAB2 increment i ;  $  TAB2 if i is greater than n, let i be 1 ;  $  TAB1 if tmp is less than ans, let ans be tmp ;  $  TAB1 print ans and newline ;
TAB0 n, i, s1, s2, s, t, a = integers with a = array of size 105 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 read s, t ;  $  TAB1 if s > t, swap s and t ;  $  TAB1 for i = s to t exclusive, s1 = s1 + a[i] ;  $  TAB1 for i = 1 to s exclusive, s2 = s2 + a[i] ;  $  TAB1 for i = n to t, s2 = s2 + a[i] ;  $  TAB1 print min of s1 and s2 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 arr = int array of size n ;  $  TAB1 read n values into arr ;  $  TAB1 a, b = int ;  $  TAB1 read a then b ;  $  TAB1 x = int with x = max of a and b ;  $  TAB1 y = int with y = min of a and b ;  $  TAB1 d1 = int with d1 = 0 ;  $  TAB1 for i = x - 1 to n + y - 1 increment d1 by arr[i mod n] ;  $  TAB1 d2 = int with d2 = 0 ;  $  TAB1 for i = x - 2 to y - 1 inclusive decrementing i increment d2 by arr[i mod n] ;  $  TAB1 print min of d1 and d2 ;
TAB1 declare NumberOfStations as integer ;  $  TAB1 declare integers From, To ;  $  TAB1 declare integer SumOfDistance = 0 ;  $  TAB1 read NumberOfStations ;  $  TAB1 declare integer vector StationsDistance initialized with NumberOfStations ;  $  TAB1 for Index = 0 to NumberOfStations exclusive ;  $  TAB2 read StationsDistance[Index] ;  $  TAB2 increment SumOfDistance by StationsDistance[Index] ;  $  TAB1 read From and To ;  $  TAB1 declare integers Start, End ;  $  TAB1 if From is less than To ;  $  TAB2 let Start be From ;  $  TAB2 let End be To ;  $  TAB1 else ;  $  TAB2 let Start be To ;  $  TAB2 let End be From ;  $  TAB1 declare TheOtherDestance as integer = 0 ;  $  TAB1 for Start is less than End, incrementing Start, increment TheOtherDestance by StaionsDistance[Start - 1] ;  $  TAB1 print minimum of TheOtherDestance and ( SumOfDistance - TheOtherDestance), newline ;
TAB1 n = long long int ;  $  TAB1 read n ;  $  TAB1 d = long long int array of size n ;  $  TAB1 read n values into d ;  $  TAB1 s, t = long long int ;  $  TAB1 read s then t ;  $  TAB1 if s is greater than t ;  $  TAB2 temp = long long int with temp = s ;  $  TAB2 set s to t ;  $  TAB2 set t to temp ;  $  TAB1 dist1, dist2 = long long int with dist1 = 0 and dist2 = 0 ;  $  TAB1 for i = s - 1 to t - 1 increment dist1 by d[i] ;  $  TAB1 flag = bool with flag = true ;  $  TAB1 for i = t - 1 to s - 1 ;  $  TAB2 if i is a multiple of n and flag is true ;  $  TAB3 set i to -1 ;  $  TAB3 set flag to false ;  $  TAB3 continue ;  $  TAB2 increment dist2 by d[i] ;  $  TAB1 if dist2 > dist1 ;  $  TAB2 print dist1 ;  $  TAB1 else ;  $  TAB2 print dist2 ;
TAB1 let n, d with 255 elements, s, and t be integers ;  $  TAB1 let res1 and res2 be integers with value 0 ;  $  TAB1 read n ;  $  TAB1 read n values into array i ;  $  TAB1 iterate and set 2 * n values into array d with element i - n ;  $  TAB1 read s and t ;  $  TAB1 if s is more than t, swap s and t ;  $  TAB1 for i from s to t exclusive, add d at element i to res1 ;  $  TAB1 for i from t to n + s exclusive, add d at element i to res2 ;  $  TAB1 print min of res1 and res2 ;
TAB1 n, s, t, sum, m1 = int with sum = 0 and m1 = 0 ;  $  TAB1 read n ;  $  TAB1 arr = int array of size n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read arr[i] ;  $  TAB2 increment sum by arr[i] ;  $  TAB1 read s then t ;  $  TAB1 decrement s ;  $  TAB1 decrement t ;  $  TAB1 l = int with l = min of s and t ;  $  TAB1 h = int with h = max of s and t ;  $  TAB1 for i = l to j increment m1 by arr[i] ;  $  TAB1 print min of m1 and sum - m1 ;
TAB1 declare integer variables n, m, u, v, x and y ;  $  TAB1 read user input to n ;  $  TAB1 a is a new array of integers with size 105 ;  $  TAB1 start for loop from i = 1 to n inclusive, reading user input to a[i] on each loop ;  $  TAB1 read u and v from the user input ;  $  TAB1 if u is greater than v, swap u and v ;  $  TAB1 declare int variables m1 and m2 = 0 ;  $  TAB1 for integer i = u to v exclusive, change m1 to m1 + a[i] ;  $  TAB1 start for loop from i = 1 to n inclusive ;  $  TAB2 if i < u or i >= v, add a[i] to m2 ;  $  TAB1 if u = v ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print min of m1 and m2 to the standard output ;
TAB1 n, s, t, len1, len2 = int with len1 = 0 and len2 = 0 and arr = int array of size 103 ;  $  TAB1 read n ;  $  TAB1 read n values into arr ;  $  TAB1 read s then t ;  $  TAB1 if s is greater then t then swap s and t ;  $  TAB1 for i = s - 1 to t - 1 increment len1 by arr[i] ;  $  TAB1 f = int with f = n - t + s ;  $  TAB1 tt = int with tt = t - 1 ;  $  TAB1 loop f times ;  $  TAB2 if tt is even set tt to 0 ;  $  TAB2 increment len2 by arr[tt] ;  $  TAB2 increment tt ;  $  TAB1 print min of len1 and len2 ;
TAB1 declare long longs i, x, j, y, tn = 1, ans = 0, long long array ar size 100000 ;  $  TAB1 declare n, m as integers ;  $  TAB1 declare tc as long long ;  $  TAB1 read n ;  $  TAB1 declare v, v1 as long long vectors ;  $  TAB1 add 0 to end of v ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 add x to end of v ;  $  TAB1 let v1 be v ;  $  TAB1 for i = 1 to size of v exclusive, increment v[i] by v[i-1] ;  $  TAB1 read x read y ;  $  TAB1 if x is greater than y, swap values between x and y ;  $  TAB1 if x is y ;  $  TAB2 print 0, newline ;  $  TAB1 declare integer t1 = v[y - 1] - v[x - 1] ;  $  TAB1 declare integer t2 = v[size of v - 1] - v[y] + v1[y] + v[x - 1] ;  $  TAB1 print minimum of t1 and t2, newline ;
TAB0 let N be int ;  $  TAB0 let x, s and t = int ;  $  TAB0 let d be vector of int ;  $  TAB1 read N ;  $  TAB1 read x and d.push_back of x N times exclusive ;  $  TAB1 read s and t ;  $  TAB1 if decremented s is greater than decremented t then swap s and t ;  $  TAB1 let d1 be integer set to 0 ;  $  TAB1 add d of i to d1 i times from s to t exclusive ;  $  TAB1 let d2 be integer set to 0 ;  $  TAB1 add d of i to d2 i times from t to N exclusive ;  $  TAB1 add d of i to d2 i times from 0 to s exclusive ;  $  TAB1 print min of d1 and d2 ;
TAB0 create string s ;  $  TAB0 create integers i and j, and an array of integers arr with 10000 elements ;  $  TAB1 create integers a, b, c, d, t, cnt and cn where cnt and cn = 0 ;  $  TAB1 read from the input to t ;  $  TAB1 in a for loop, change k from 1 to t inclusive, reading variable arr[k] from the input ;  $  TAB1 read variables a and b from the input ;  $  TAB1 if a is greater than b, swap a and b ;  $  TAB1 in the for loop, change i from a to b exclusive, increasing cnt by arr[i] ;  $  TAB1 start for loop with i = b, incrementing i by 1 ;  $  TAB2 if i = a, stop the loop ;  $  TAB2 change cn to cn + arr[i] ;  $  TAB2 if i = t, set i to 0 ;  $  TAB1 if cnt is greater than cn ;  $  TAB2 print cn to the standard output ;  $  TAB1 else ;  $  TAB2 print cnt ;
TAB1 n, s, t = integers, arr = integer array of size 100 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB1 read s, t ;  $  TAB1 m1 = integer = lower value between s, t ;  $  TAB1 m2 = integer = bigger value between s, t ;  $  TAB1 decrease m1 by 1 ;  $  TAB1 decrease m2 by 1 ;  $  TAB1 R1 = integer = 0, R2 = integer = 0 ;  $  TAB1 for i = m1 to m2, then R1 = R1 + arr[i] ;  $  TAB1 for i = m2 to mn, then R2 = R1 + arr[i] ;  $  TAB1 for i = 0 to m1, then R2 = R2 + arr[i] ;  $  TAB1 R = integer = lower value between R2 and R1 ;  $  TAB1 print R ;
TAB0 declare array of integers arr with size 10005 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to i = n - 1 read arr[i + 1] ;  $  TAB1 let s and t be integers ;  $  TAB1 read s and t ;  $  TAB1 if s is greater than t then swap s and t ;  $  TAB1 create integer aa and set it to 0 ;  $  TAB1 for i = s to i = t exclusive set aa to aa + arr[i] ;  $  TAB1 create integer bb = 0 ;  $  TAB1 for i = 1 to i = t exclusive assign bb + arr[i] to bb ;  $  TAB1 for i = t to i = n do bb = bb + arr[i] ;  $  TAB1 print min of aa and bb ;
TAB0 create constant integer maxn with maxn = 105 ;  $  TAB0 create integers n, s, t, create integer array d with size maxn ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read d[i] ;  $  TAB1 read s read t ;  $  TAB1 create integers clock, revert, i with clock = 0, revert = 0 ;  $  TAB1 create integers front, tail, with front = minimum of s and t, tail = maximum of s and t ;  $  TAB1 for i = front to tail exclusive, increment clock by d[i] ;  $  TAB1 for i = tail to i is not front, incrementing i ;  $  TAB2 if i is greater than n, set i to i % n ;  $  TAB2 if i is front, break loop ;  $  TAB2 increment revert by d[i] ;  $  TAB1 print minimum of clock and revert print newline ;
TAB1 declare int variables n, s, t, sum, res and mini with sum, res and mini = 0, and an array of integers d with 100 elements ;  $  TAB1 read n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read d[i] ;  $  TAB2 increase sum by d[i] ;  $  TAB1 read input to s and t ;  $  TAB1 for i from min of s - 1 and t - 1 to max of t - 1 and s - 1 exclusive, add d[i] to res ;  $  TAB1 change mini to min of res and sum - res ;  $  TAB1 print mini ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int vector x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let int m ;  $  TAB2 read m ;  $  TAB2 add m to the end of x ;  $  TAB1 let ints s and t ;  $  TAB1 read s and t ;  $  TAB1 create ints count1 = 0 and count2 = 0 ;  $  TAB1 set s to s + n ;  $  TAB1 for i = s - 1 to infinity ;  $  TAB2 if i modulo n is equal to t - 1 ;  $  TAB3 break loop ;  $  TAB2 otherwise ;  $  TAB3 set count1 to count1 + x[i % n] ;  $  TAB1 decrease s by 1 ;  $  TAB1 for i = s - 1 to infinity decreasing by 1 each time ;  $  TAB2 if i modulo n is equal to t - 1 ;  $  TAB3 set count2 to count2 + x[i % n] ;  $  TAB3 break loop ;  $  TAB2 otherwise do ;  $  TAB3 set count2 to count2 + x[i % n] ;  $  TAB1 if count1 is less than or equal to count2 ;  $  TAB2 print count1 ;  $  TAB1 otherwise do ;  $  TAB2 print count2 ;
TAB1 create ints n, ans1 = 0, ans2 = 0, f, t, and tot = 0 and int array d of size 105 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n ;  $  TAB2 read d[i] ;  $  TAB2 set tot to tot + d[i] ;  $  TAB1 read f and t ;  $  TAB1 if f is greater than t, swap the values of f and t ;  $  TAB1 for i = f to t exclusive, set ans1 to ans1 + d[i] ;  $  TAB1 set ans2 to tot - ans1 ;  $  TAB1 print the min of ans1 and ans2 ;
TAB0 mod = long long = 1000000007 ;  $  TAB0 N, M, K, H, W, L, R = long long integer ;  $  TAB1 read N ;  $  TAB1 v = integer vector of size N + 1 ;  $  TAB1 for i = 1 to N inclusive, then read v[i] ;  $  TAB1 M = sum of all values of v ;  $  TAB1 for i = 1 to N inclusive, v[i] = v[i] + v[i - 1] ;  $  TAB1 read L, R ;  $  TAB1 if L > R swap the values of L, R ;  $  TAB1 print the result of the lower value between v[R - 1] - v[L - 1] and M in integer form - v[R - 1] + v[L - 1] ;
TAB1 create character array c with size 4 by 4 ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = 0 to 4 exclusive read c[i][j] ;  $  TAB1 declare integers x, y, z and v = 0 ;  $  TAB1 in the infinite loop ;  $  TAB2 for j = z to z + 2 exclusive ;  $  TAB3 if c[v][j] = '#' increment x ;  $  TAB3 if c[v][j] = '.' increment y ;  $  TAB3 if c[v + 1][j] = '#' increment x ;  $  TAB3 if c[v + 1][j] = '.' increment y ;  $  TAB2 if x > y or y is greater than x ;  $  TAB3 print "YES" ;  $  TAB2 set x to 0 ;  $  TAB2 set y to 0 ;  $  TAB2 increase z by one ;  $  TAB2 if z = 3 ;  $  TAB3 increase v by one ;  $  TAB3 set z to 0 ;  $  TAB2 if v = 3, break the loop ;  $  TAB1 print "NO" ;
TAB0 create 2d boolean array a with size 4 by 4 ;  $  TAB0 declare f with no arguments, returning boolean ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 create boolean bol with bol = a[i][j] ;  $  TAB3 if a[i+1][j] is bol and a[i+1][j+1] is bol and a[i][j+1] is bol, return true from function ;  $  TAB1 return false from function ;  $  TAB1 create character h ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = 0 to 4 exclusive ;  $  TAB3 set h to read character ;  $  TAB3 if h is '#' ;  $  TAB4 set a[i][j] to true ;  $  TAB3 else ;  $  TAB4 set a[i][j] to false ;  $  TAB2 set h to read character ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = 0 to 4 exclusive ;  $  TAB3 set a[i][j] to false if a[i][j] is true, else true ;  $  TAB3 if result of run f is true ;  $  TAB4 print "YES" print newline ;  $  TAB3 set a[i][j] to false if a[i][j] is true, else true ;  $  TAB1 print "NO" print newline ;
TAB1 create string vector vs initialized with 4 ;  $  TAB1 for i = 0 to 4 exclusive, read vs[i] ;  $  TAB1 create boolean pass with pass = false ;  $  TAB1 for top = 0 to top is less than or equal to 2 and not pass, incrementing top ;  $  TAB2 for left = 0 to 2 inclusive ;  $  TAB3 create integer dot with dot = 0 ;  $  TAB3 for r = 0 to 2 exclusive ;  $  TAB4 for c = 0 to 2 exclusive ;  $  TAB5 if vs[top+r][left+c] is '.', increment dot by 1 ;  $  TAB3 if dot is not 2 ;  $  TAB4 set pass to true ;  $  TAB4 break loop ;  $  TAB1 print "YES" if pass is true, else "NO", print newline ;
TAB0 declare compute ;  $  TAB1 create 2d character array a with size 4 by 4 ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = 0 to 4 exclusive, read a[i][j] ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = 0 to 4 exclusive ;  $  TAB3 if j is less than or equal to 2 and i is less than or equal to 2 ;  $  TAB4 create integers hutch, dots with hutch = 0, dots = 0 ;  $  TAB4 for k = 0 to 2 exclusive ;  $  TAB5 for l = 0 to 2 exclusive ;  $  TAB6 if a[i + k][j + l] is '#' ;  $  TAB7 increment hutch ;  $  TAB6 else ;  $  TAB7 increment dots ;  $  TAB4 if hutch is greater than or equal to 3 or dots is greater than or equal to 3 ;  $  TAB5 print "YES\n" ;  $  TAB5 return from function ;  $  TAB1 print "NO\n" ;  $  TAB1 run compute ;
TAB1 let s = array of strings of length 5 ;  $  TAB1 for (i = 0 to 4 exclusive), read ith element of array s ;  $  TAB1 for ( x = 1 to 4 exclusive ) ;  $  TAB2 for ( y = 1 to 4 exclusive ) ;  $  TAB3 let cnt be a integer with value assigned as 0 ;  $  TAB3 for i=0 to 2 (exclusive) ;  $  TAB4 for j=0 to 2 (exclusive) ;  $  TAB5 if (s[x - i][y - j] is not equal to s[x][y]), increase cnt value by 1 ;  $  TAB3 check if (cnt power 2), then return print YES and newline ;  $  TAB1 print NO and newline ;
TAB1 let grid = array of strings of length 4 ;  $  TAB1 read the 0th element of grid, 1st element of grid,2nd element of grid and 3rd element of grid ;  $  TAB1 boolean found is equal to false ;  $  TAB1 for i= 0 to 3 exclusive ;  $  TAB2 for j= 0 to 3 exclusive ;  $  TAB3 let the integers c1, c2 are assigned as c1 is equal to 0 and c2 is equal to 0 respectively ;  $  TAB3 for (int i1 = i to i+1 inclusive) ;  $  TAB4 for (int j1 = j to j+1 inclusive) ;  $  TAB5 if ( the 2d array grid[i1][j1] is equal to .) ;  $  TAB6 increase c1 by 1 ;  $  TAB5 else do the following ;  $  TAB6 increase c2 by 1 ;  $  TAB3 if (c1 is not equal to 2), found is equal to true ;  $  TAB1 print YES if found else print NO ;
TAB0 declare character array a with size 6 by 6 ;  $  TAB0 int function nCount with integer arguments x and y and character argument c ;  $  TAB1 create integer res = 0 ;  $  TAB1 increment res if a[x + 1][y] = c ;  $  TAB1 increment res if a[x][y + 1] = c ;  $  TAB1 increment res if a[x + 1][y + 1] = c ;  $  TAB1 return res ;  $  TAB1 declare character z ;  $  TAB1 for integer i = 1 to 4 inclusive ;  $  TAB2 for integer j = 1 to 4 inclusive ;  $  TAB3 read z ;  $  TAB3 a[i][j] = z ;  $  TAB1 for i = 1 to 4 inclusive ;  $  TAB2 for j = 1 to 4 inclusive ;  $  TAB3 if a[i][j] = '#' ;  $  TAB4 if nCount(i, j, '#') >= 2 || nCount(i, j, '.') >= 3 ;  $  TAB5 print "YES" ;  $  TAB3 else ;  $  TAB4 if nCount(i, j, '.') >= 2 || nCount(i, j, '#') >= 3 ;  $  TAB5 print "YES" ;  $  TAB1 print "NO" ;
TAB0 create character array m with 4 by 4 elements ;  $  TAB0 function check with integer arguments i and j that returns boolean ;  $  TAB1 declare integers cnt and cnt2 = 0 ;  $  TAB1 for k = i to i + 2 exclusive ;  $  TAB2 for d = j to j + 2 exclusive ;  $  TAB3 if m[k][d] is '#' ;  $  TAB4 increment cnt ;  $  TAB3 else ;  $  TAB4 increment cnt2 ;  $  TAB1 return true if cnt = 3 || cnt = 4 || cnt2 = 3 || cnt2 = 4 ;  $  TAB1 return false ;  $  TAB1 for integer i = 0 to 4 exclusive ;  $  TAB2 declare string variable s ;  $  TAB2 read s ;  $  TAB2 for integer j = 0 to 4 exclusive, set m[i][j] to s[j] ;  $  TAB1 declare boolean variable sol = false ;  $  TAB1 for integer i = 0 to 3 exclusive ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 if check(i, j) is true, set sol to true ;  $  TAB1 if sol is true ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 num = array of 225 integers ;  $  TAB1 n, m, i, j, k = integers ;  $  TAB1 read n and k ;  $  TAB1 set a index of num to k ;  $  TAB1 for i = 1 to k exclusive increment num['a' + i] ;  $  TAB1 if k > n ;  $  TAB2 print -1 ;  $  TAB1 else if n is 1 ;  $  TAB2 print a ;  $  TAB1 else if k is 1 and n > 1 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 set f to 1 ;  $  TAB2 for i = 1 to n - (k - 2) inclusive ;  $  TAB3 if i modulo 2 ;  $  TAB4 print a ;  $  TAB3 else ;  $  TAB4 print b ;  $  TAB2 for i = 1 to k - 2 inclusive print (char)('b' + i) ;  $  TAB2 print a new line ;
TAB1 create integers n, k, sig with sig = 0 ;  $  TAB1 create string s ;  $  TAB1 read n read k ;  $  TAB1 if k is 1 and n is greater than 1 ;  $  TAB2 print "-1\n" ;  $  TAB1 else if k is greater than n ;  $  TAB2 print "-1\n" ;  $  TAB1 else if n is 1 and k is 1 ;  $  TAB2 print "a\n" ;  $  TAB1 else ;  $  TAB2 create integers i, j with j = n - k + 1 ;  $  TAB2 if ( j bitwise and 1 ) is 0, decrement j, set sig to 1 ;  $  TAB2 for i = 0 to j inclusive, increment i by 2, increment s by "ab" ;  $  TAB2 if sig is true, increment s by "a", set a to j + 2 ;  $  TAB2 create character c with c = 'b' ;  $  TAB2 for i is less than n, incrementing i, increment s by character casted ( c + 1 ), set c to s[i] ;  $  TAB2 print s print newline ;
TAB1 create integers n and k ;  $  TAB1 read n and k ;  $  TAB1 if n < k or (k = 1 and n != 1) ;  $  TAB2 print -1 ;  $  TAB1 else if k = 1 and n = 1 ;  $  TAB2 print 'a' ;  $  TAB1 else ;  $  TAB2 for i = 1 to n - (k - 2) inclusive ;  $  TAB3 if i & 1 ;  $  TAB4 print 'a' ;  $  TAB3 else ;  $  TAB4 print 'b' ;  $  TAB2 declare integer variable x = n - (k - 2) ;  $  TAB2 declare character ch = 'c' ;  $  TAB2 for i = 1 to k - 2 inclusive print ch and increment it ;  $  TAB2 print new line ;
TAB1 create n, k and zzz ;  $  TAB1 read n, k ;  $  TAB1 if n<k or k=1 and n is different from 1 ;  $  TAB2 print -1 ;  $  TAB1 else if k=1 and n=1 ;  $  TAB2 print a and a new line ;  $  TAB1 else ;  $  TAB2 for i=1 to n - k -2 inclusive ;  $  TAB3 if i is odd ;  $  TAB4 print a ;  $  TAB3 els ;  $  TAB4 print b and a new line ;  $  TAB2 set x to n - k - 2 ;  $  TAB2 assign c to ch ;  $  TAB2 for i=1 to k inclusive, print increment ch ;  $  TAB2 print a new line ;
TAB1 declare long long variables n and k ;  $  TAB1 read n and k ;  $  TAB1 if k > n || (k = 1 && n > 1) ;  $  TAB2 print -1 ;  $  TAB1 else if k = 1 ;  $  TAB2 print 'a' ;  $  TAB1 else ;  $  TAB2 declare long long x = n - (k - 2) ;  $  TAB2 declare string str = " " ;  $  TAB2 declare long long variable i = 0 ;  $  TAB2 while i is less than x ;  $  TAB3 if i is even ;  $  TAB4 append "a" to str ;  $  TAB3 else ;  $  TAB4 append "b" to str ;  $  TAB3 increase i ;  $  TAB2 for long long i = 2 to k exclusive ;  $  TAB3 declare character ch = (i + 'a') ;  $  TAB3 append ch to str ;  $  TAB2 print str ;
TAB0 let n, k be ints ;  $  TAB1 read n, k ;  $  TAB1 if k is less than n do the following ;  $  TAB2 print -1 and one newline ;  $  TAB1 if ke equals 1 do the following ;  $  TAB2 if n equals 1 do the following ;  $  TAB3 print a and one newline ;  $  TAB2 else ;  $  TAB3 print -1 and one newline ;  $  TAB1 if k equals 2 do the following ;  $  TAB2 for int = 0 to n exclusive print char('a' + (i & 1)) ;  $  TAB2 print one newline ;  $  TAB1 for i = 0 to n - k + 2 exclusive print char('a' + (i & 1)) ;  $  TAB1 for i = 0 to k - 2 exclusive print char('c' + i) ;  $  TAB1 print one newline ;
TAB1 declare integer variables i, j, k, l, n and m ;  $  TAB1 read n and m ;  $  TAB1 k = m ;  $  TAB1 if n < m or (m = 1 and n is greater than 1) ;  $  TAB2 print -1 ;  $  TAB1 create a map from integers to characters called mm ;  $  TAB1 create character h = 'a' ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 set value of mm[i] to h ;  $  TAB2 increase h by one ;  $  TAB1 declare string variable st = " " ;  $  TAB1 if n = m ;  $  TAB2 for i = 0 to n exclusive, apped mm[i] to st ;  $  TAB2 print st ;  $  TAB1 for i = 0 to n - (m - 2) exclusive ;  $  TAB2 if i is even ;  $  TAB3 append mm[0] to st ;  $  TAB2 else ;  $  TAB3 append mm[1] to st ;  $  TAB1 for i = 0 to m - 2 exclusive, append mm[i + 2] to st ;  $  TAB1 print st ;
TAB1 declare integers a and b ;  $  TAB1 while read a and b ;  $  TAB2 declare integer i ;  $  TAB2 if a = 1 ;  $  TAB3 if b is greater than 1 ;  $  TAB4 print "-1" ;  $  TAB3 else ;  $  TAB4 print "a" ;  $  TAB2 else ;  $  TAB3 declare character variable q = 'c' ;  $  TAB3 declare integer pl = 0 ;  $  TAB3 if b > a or (b = 1 and a > 1) ;  $  TAB4 print "-1" ;  $  TAB3 else ;  $  TAB4 for i = 0 to a - (b - 2) exclusive ;  $  TAB5 if pl is even ;  $  TAB6 increase pl by one ;  $  TAB6 print 'a' ;  $  TAB5 else ;  $  TAB6 increment pl ;  $  TAB6 print 'b' ;  $  TAB4 for i = 0 to b - 2 exclusive ;  $  TAB4 print new line ;
TAB1 let s, s1 be strings ;  $  TAB1 let n,k be integers ;  $  TAB1 read n,k ;  $  TAB1 if (k is greater than n or (k is equal to 1 and n is greater than 1)) , and print -1 and endline , return 0 ;  $  TAB1 if (k is equal to 1) print a and endline, return 0 ;  $  TAB1 for( i=1 to k - 2 inclusive), s is equal to s + b + i ;  $  TAB1 for( i=1 to n- k +2 inclusive), s1 = s1 + (if i modulus 2 ) ? a else b ;  $  TAB1 print s1 and s and newline ;
TAB0 let xx be a char array of length 1000002 ;  $  TAB1 n, k = integers ;  $  TAB1 while n and k are read ;  $  TAB2 if n is equal to or greater than 2 and k is less than 2, or n is less than k ;  $  TAB3 print -1 and a new line ;  $  TAB2 otherwise ;  $  TAB3 set integer a equal to k - 2 ;  $  TAB3 set t = 0 ;  $  TAB3 set all contents of xx to 0 ;  $  TAB3 for i = 0 to n exclusive ;  $  TAB4 if i is less than n - (k - 2) ;  $  TAB5 if i modulo 2 equal to 0 ;  $  TAB6 set xx[i] = a ;  $  TAB5 otherwise ;  $  TAB6 set xx[i] equal to b ;  $  TAB4 otherwise ;  $  TAB5 if i is less than n ;  $  TAB6 set xx[i] = 99 + t ;  $  TAB6 increment t ;  $  TAB3 print xx and a new line ;
TAB1 create integers n and k ;  $  TAB1 read n, k ;  $  TAB1 if n<k or k equal to 1 and n different from 1 ;  $  TAB2 print -1 ;  $  TAB1 otherwise ;  $  TAB2 if n equal to or greater than 2 ;  $  TAB3 for i=1 to n inclusive ;  $  TAB4 if 1 modulo 2 equal to 0 ;  $  TAB5 print b ;  $  TAB4 other ;  $  TAB5 print a ;  $  TAB3 if n-k mod 2 = 0 ;  $  TAB4 print ab ;  $  TAB4 for i=3 to k inclusive, print i + a - 1 ;  $  TAB3 else ;  $  TAB4 print ba ;  $  TAB4 for i = 3 to k inclusive, print i + a - 1 ;  $  TAB3 print a new line ;  $  TAB2 otherwise ;  $  TAB3 print a and a new line ;
TAB0 let b, d, sum, i, n , resh, ans1, ans2, ans3, ans4, j and k be long longs and a be long long array with length 10001 ;  $  TAB0 create strings s and s1 ;  $  TAB0 create char array c with length 10001 ;  $  TAB1 read n and k ;  $  TAB1 if (n is smaller than k) or (k is equal to 1 and n is greater than 1) return 0 and print -1 ;  $  TAB1 if n is equal to 1 return 0 and print a and newline ;  $  TAB1 for i=0 to (n - (k - 2)) / 2 exclusive print "ab" ;  $  TAB1 if (n - (k - 2) mod 2) print "a" ;  $  TAB1 for i=0 to k-2 exclusive print char(i + 'c') ;  $  TAB1 print newline ;
TAB0 create character array ab with size 2, with ab = {'a', 'b'} ;  $  TAB1 create integers n, k ;  $  TAB1 read n read k ;  $  TAB1 if ( k is 1 and n is not 1 ) or ( k is greater than n ) ;  $  TAB2 print -1 print newline ;  $  TAB1 create integer frst with frst = n - k + 2 ;  $  TAB1 create boolean flag with flag = 0 ;  $  TAB1 create integer i with i = 0 ;  $  TAB1 for i is less than frst and i is less than n, incrementing i ;  $  TAB2 print ab[flag] ;  $  TAB2 set flag to ( not flag bitwise and 1 ) ;  $  TAB1 create character c with c = 'c' ;  $  TAB1 for i is less than n, incrementing i ;  $  TAB2 print c ;  $  TAB2 increment c ;  $  TAB1 print newline ;
TAB0 create integers n and k ;  $  TAB1 read n and k ;  $  TAB1 if n * (n - 1) / 2 <= k ;  $  TAB2 print "no solution\n" ;  $  TAB1 else ;  $  TAB2 print "0 ", n and "\n ;
TAB1 declare integers n and k ;  $  TAB1 while reading n and k ;  $  TAB2 create long long temp = 0 ;  $  TAB2 declare long long variable a ;  $  TAB2 declare integer j = 1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read a ;  $  TAB3 if temp - (i - 1) * (n - i) * a is less than k ;  $  TAB4 print j ;  $  TAB4 decrease i and n ;  $  TAB3 else ;  $  TAB4 increase temp by (i - 1) * a ;  $  TAB3 increase j ;
TAB1 create long long integers n, i, k, x, b, with x = 1 to b = 0 ;  $  TAB1 read n read k ;  $  TAB1 create long long integer array a with size n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if b - x * a[i] * ( n - i - 1 ) is less than k ;  $  TAB3 print i + 1 print newline ;  $  TAB2 else ;  $  TAB3 increment by by x * a[i] ;  $  TAB3 increment x ;
TAB1 create long longs n, k ;  $  TAB1 read n readk ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 create long long pos with pos = 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create long long x ;  $  TAB2 read x ;  $  TAB2 create long long d with d = sum - ( pos - 1 ) * ( n - i ) * x ;  $  TAB2 if d is less than k ;  $  TAB3 print i print '\n' ;  $  TAB2 else ;  $  TAB3 increment sum by x * (pos-1) ;  $  TAB3 increment pos ;
TAB1 create long longs n, k, sum, cur with sum = 0, cur = 0 ;  $  TAB1 read n read k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create integer a ;  $  TAB2 read a ;  $  TAB2 if i is greater than 1 and sum - (i-cur-1)*(n-1)*a is less than k ;  $  TAB3 print i print newline ;  $  TAB3 increment cur ;  $  TAB2 else ;  $  TAB3 increment sum by a * (i - cur - 1) ;
TAB1 let n,k be integers ;  $  TAB1 while ( read the values of n and k ) ;  $  TAB2 let temp be a long integer with value as 0 ;  $  TAB2 let a be a long integer ;  $  TAB2 let j be a integer with value as 1 ;  $  TAB2 for integer i = 1 to n inclusive ;  $  TAB3 read a ;  $  TAB3 if (temp - (i - 1) * (n - i) * a is less than k) ;  $  TAB4 print j and newline ;  $  TAB4 decrease the value of i by 1, decrease the value of n by 1 ;  $  TAB3 else do the following ;  $  TAB4 temp is equal to temp + (i - 1) * a ;  $  TAB3 increase j value by 1 ;
TAB1 create integer T with T = 1 ;  $  TAB1 while decrement T is true ;  $  TAB2 create integers n, k ;  $  TAB2 read n read k ;  $  TAB2 create long long integer vector arr initialized with n + 1 ;  $  TAB2 set arr[0] to 0 ;  $  TAB2 for i = 0 to n exclusive, read arr[i+1] ;  $  TAB2 create long long integer c with c = 1 ;  $  TAB2 create integer p_1 with p_1 = 1 ;  $  TAB2 create long long integers cur_d, prev_d, di, with cur_d = 0, prev_d = 0, di = 0 ;  $  TAB2 for i = 2 to n inclusive ;  $  TAB3 set cur_d to prev_d + 1LL * arr[p_i] * (c - 1) ;  $  TAB3 set di to cur_d - 1LL * (n - i) * (c)*arr[i] ;  $  TAB3 if di is less than k ;  $  TAB4 print i print '\n' ;  $  TAB3 else ;  $  TAB4 increment c ;  $  TAB4 set p_i to i ;  $  TAB4 set prev_d to cur_d ;
TAB0 create long long vector v ;  $  TAB1 create long longs n, k, a, s, j, p, i with s = 0, j = 2 ;  $  TAB1 read n read k ;  $  TAB1 create long long m with m = n ;  $  TAB1 read a ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 read a ;  $  TAB2 set p to s - (j - 1) * (m - j) * a ;  $  TAB2 if p is less than k ;  $  TAB3 add element i to end of v ;  $  TAB3 set m to m - 1 ;  $  TAB2 else ;  $  TAB3 set s to s + ( j - 1 ) * a ;  $  TAB3 set j to j + 1 ;  $  TAB1 for i = 0 to size of v exclusive, print v[i] print newline ;
TAB0 create long longs n, k, a, sum and l ;  $  TAB1 read n and k ;  $  TAB1 for long long i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 if i != 1 ;  $  TAB3 if sum - (n - i) * (i - 1) * a is less than k ;  $  TAB4 print i + l ;  $  TAB4 decrease i ;  $  TAB4 decrease n by one ;  $  TAB4 increment l ;  $  TAB3 else ;  $  TAB4 increase sum by a * (i - 1) ;
TAB0 declare prn with integer pos as argument, returning void ;  $  TAB1 print pos print "\n" ;  $  TAB1 create long longs n, k ;  $  TAB1 read n read k ;  $  TAB1 create long long sz with sz = n ;  $  TAB1 create integer pos with pos = 1 ;  $  TAB1 create long long ai ;  $  TAB1 read ai ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 for i = 2 to sz inclusive ;  $  TAB2 increment pos ;  $  TAB2 read ai ;  $  TAB2 create long long d with d = sum - (n - pos) * (pos - 1) * ai ;  $  TAB2 if d is less than k ;  $  TAB3 run prn with i as argument ;  $  TAB3 decrement pos ;  $  TAB3 decrement n ;  $  TAB2 else ;  $  TAB3 increment sum by ai * ( pos - 1 ) ;
TAB0 create long longs n, k, a, sum, l ;  $  TAB1 read n read k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 if i is not 1 ;  $  TAB3 if sum - ( n - 1 ) * ( i - 1 ) * a is less than k ;  $  TAB4 print i + l print newline ;  $  TAB4 decrement i ;  $  TAB4 decrement n ;  $  TAB4 increment l ;  $  TAB3 else ;  $  TAB4 increment sum by a * ( i - 1 ) ;
TAB1 integers = n,a,b,c,d,w,h,x1 = 2e9,y1 = 2e9,x2 = 0,y2 = 0,area = 0 ;  $  TAB1 read n ;  $  TAB1 if n is true do the following ;  $  TAB2 read a,b,c,d ;  $  TAB2 set w to c - a ;  $  TAB2 set h to d - b ;  $  TAB2 area equals area plus w * h ;  $  TAB2 set x1 to min(x1, a) ;  $  TAB2 set y1 to min(y1, b) ;  $  TAB2 set x2 to max(x2, c) ;  $  TAB2 set y2 to max(y2, d) ;  $  TAB1 set w to x2 - x1 ;  $  TAB1 set h to y2 - y1 ;  $  TAB1 if w= h and area = w*h print YES else NO) ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 declare integers x0, y0, x1, y1 and a with a = 0 ;  $  TAB1 change x0 and y0 to 1e9 + 87 ;  $  TAB1 change x1 and y1 to -9e8 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 declare ints l, b, r and u ;  $  TAB2 read l, b, r and u ;  $  TAB2 add (r - l) * (u - b) to a ;  $  TAB2 change x0 to min of x0 and l ;  $  TAB2 change x1 to max of x1 and r ;  $  TAB2 change y0 to min of y0 and b ;  $  TAB2 change y1 to max of y1 and u ;  $  TAB1 subtract x0 from x1 ;  $  TAB1 decrease y1 by y0 ;  $  TAB1 print "YES\n" if x1 = y1 and x1 * y1 = a, or "NO\n" otherwise ;
TAB0 declare integer n ;  $  TAB1 read n ;  $  TAB1 create integers xmin and ymin = 1000000000 and xmax and ymax = - 1 ;  $  TAB1 create integer act = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create ints a, b, c and d ;  $  TAB2 read a, b, c and d ;  $  TAB2 set xmin to min of xmin and a ;  $  TAB2 set xmin to min of xmin and c ;  $  TAB2 set xmax to min of xmax and a ;  $  TAB2 set xmax to max of xmax and a ;  $  TAB2 set ymin to min of ymin and b ;  $  TAB2 set ymin to min of ymin and d ;  $  TAB2 set ymax to max of ymax and b ;  $  TAB2 set ymax to max of ymax and d ;  $  TAB2 add abs(a - c) * abs(b - d) to act ;  $  TAB1 if ymax - ymin = xmax - xmin and act = ((ymax - ymin) * (xmax - xmin)) ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 x1, y1, x2, y2 and sum are long long ints where sum = 0 ;  $  TAB1 declare long long int minmum = INT_MIN, maxmum = INT_MIN, p = INT_MAX and q = INT_MAX ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read input to x1, y1, x2 and y2 ;  $  TAB2 change maxmum to max of maxmum and max(x2 and x1) ;  $  TAB2 change minmum to max of minmum and max(y2 and y1) ;  $  TAB2 assign min of p and min(y2 and y1) to p ;  $  TAB2 set q to min of q and min(x2 and x1) ;  $  TAB2 add fabs(x2 - x1) * fabs(y2 - y1) to sum ;  $  TAB1 if sum = ((minmum - p) * (maxmum - q)) and (maxmum - q) == (minmum - p) ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 integers = i,n,x1,x2,y1,y2,mx = 99999,my = 99999,Mx = -1,My = -1,R = 0 ;  $  TAB1 read n ;  $  TAB1 for = 0 to less than n do the following ;  $  TAB2 read x1,y1,x2,y2 ;  $  TAB2 R equals R plus (x2 - x1) * (y2 - y1) ;  $  TAB2 if Mx is less than x2 then do the following Mx = x2 ;  $  TAB2 if My is less than y2 then do the following My = y2 ;  $  TAB2 if mx is greater than x1 then do the following mx = x1 ;  $  TAB2 if my is greater than y1 then do the following my = y1 ;  $  TAB1 if is R and Mx - mx equals My -my then do the following ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB1 n = integer ;  $  TAB1 S = integer array of size 10 ;  $  TAB1 while read n ;  $  TAB2 set all contents of S to 0 ;  $  TAB2 maxx, maxy = integers with maxx = 0, maxy = 0 ;  $  TAB2 minx, miny = integers with minx = 10000000, miny = 10000000 ;  $  TAB2 C = integer with C = 0 ;  $  TAB2 x1, x2, y1, y2 = integers ;  $  TAB2 for i = 1 to n ;  $  TAB3 read x1, x2, y1, y2 ;  $  TAB3 S[i] = (x2 - x1) * (y2 - y1) ;  $  TAB3 C = C + S[i] ;  $  TAB3 if x1 < minx, minx = x1 ;  $  TAB3 if x2 > maxx, maxx = x2 ;  $  TAB3 if y1 < miny, miny = y1 ;  $  TAB3 if y2 > maxy, maxy = y2 ;  $  TAB2 if C is (maxx - minx) * (maxy - miny) and (maxx - minx) is (maxy - miny) ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 change output format flag to ios::fixed ;  $  TAB1 change output precision to 20 ;  $  TAB1 declare ints n, x1, y1, x2 and y2 ;  $  TAB1 declare int variables xl and yl = 2139062143 and xr and yr = -2139062143 ;  $  TAB1 read input to n ;  $  TAB1 declare long long area = 0 ;  $  TAB1 loop, decrementing n, while it is not 0 ;  $  TAB2 read x1, y1, x2 and y2 ;  $  TAB2 set xl to min of xl and x1 ;  $  TAB2 change xr to xr if xr > x2, else to x2 ;  $  TAB2 set yl to min of yl and y1 ;  $  TAB2 change yr to yr if yr > y2, else to y2 ;  $  TAB2 add 1LL * (x2 - x1) * (y2 - y1) to area ;  $  TAB1 if xr - xl = yr - yl and area = 1LL * (xr - xl) * (yr - yl) ;  $  TAB2 print "YES" to stdout ;  $  TAB1 else ;  $  TAB2 print "NO" to stdout ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 create ints x0, y0, x1, y1, a with a = 0 ;  $  TAB1 set x0 and y0 to 1e9 + 87 ;  $  TAB1 assign -9e8 to y1 and x1 ;  $  TAB1 for n iterations ;  $  TAB2 create integers l, b, r, u ;  $  TAB2 read l, b, r and u ;  $  TAB2 add a to (r - l) * (u - b) and assign the result to a ;  $  TAB2 set x0 to min(x0, l) ;  $  TAB2 assign the greater of x1 and r to x1 ;  $  TAB2 set y0 to min(y0, b) ;  $  TAB2 set y1 to max of y1 and u ;  $  TAB1 x1 = x1 - x0 ;  $  TAB1 set y1 to y1 - y0 ;  $  TAB1 print (x1 == y1 && x1 * y1 == a ? "YES\n" : "NO\n") ;
TAB1 mn, mn2 = integers with mn = 50000, mn2 = mn ;  $  TAB1 N, mx, mx2, Ar = integers with mx = -1, mx2 = mx, Ar = 0 ;  $  TAB1 read N ;  $  TAB1 for i = 1 to N ;  $  TAB2 a, b, x, y = integers ;  $  TAB2 read a, b, x, y ;  $  TAB2 Ar = Ar + (x - a) * (y - b) ;  $  TAB2 mn = min of mn and min(a, x) ;  $  TAB2 mn2 = min of mn2 and min(b, y) ;  $  TAB2 mx = max of mx and max(a, x) ;  $  TAB2 mx2 = max of mx2 and max(b, y) ;  $  TAB1 if (mx - mn is mx2 - mn2 and Ar is (mx - mn) * (mx2 - mn2)) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 while n % 3 is 0, set n to n / 3 ;  $  TAB1 print n / 3 + 1 print newline ;
TAB1 create unsigned long long n, t, coi with coi = 1 ;  $  TAB1 read n ;  $  TAB1 while n % 3 is 0, set n to n / 3 ;  $  TAB1 print ( n - 1 ) / 3 + 1 print '\n' ;
TAB0 n, ans = long long with ans = 0 ;  $  TAB1 read n ;  $  TAB1 while n modulo 3 is 0, n = n / 3 ;  $  TAB1 ans = n / 3 + 1 ;  $  TAB1 print ans ;
TAB0 in function cil taking two long longs x and y and returning a long long ;  $  TAB1 if x is a multiple if y ;  $  TAB2 return x / y ;  $  TAB1 else ;  $  TAB2 return x / y + 1 ;  $  TAB1 n, i, j = long long with j = 0 ;  $  TAB1 read n ;  $  TAB1 set i to n ;  $  TAB1 loop while n is a multiple of 3 and greater than 0 ;  $  TAB2 increment j ;  $  TAB2 set n to n / 3 ;  $  TAB1 l = long long with l = pow of 3 and j + 1 ;  $  TAB1 print cil of i and l ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 let sum , x be long integers with x = 3 ;  $  TAB1 while n modulo x is equal to 0 , x is equal to x * 3 ;  $  TAB1 n / x + 1 is assigned to sum ;  $  TAB1 print sum and newline ;
TAB1 define integers i, j, k, and n ;  $  TAB1 read n ;  $  TAB1 define j and set to 3; for i from 1 to 35, set j to itself * 3 ;  $  TAB2 if n modulo j isn't 0, then break out ;  $  TAB1 print n / j + 1 and a newline ;
TAB0 create FILE pointer stream ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create long long x with x = 1 ;  $  TAB1 while n % x is 0, set x to x * 3 ;  $  TAB1 print ( n / x ) + 1 print newline ;
TAB1 n =integer ;  $  TAB1 while reading values n ;  $  TAB2 while n modulo 3 is 0, then set n to n / 3 ;  $  TAB2 print n / 3 + 1 and a new line ;
TAB0 set first 4 elements of dx to 0, 0, -1, 1 ;  $  TAB0 assign 1, -1, 0, 0 to first 4 elements of dy ;  $  TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 set x and ans to 1 ;  $  TAB1 while x less than n ;  $  TAB2 if n mod x different from 0, set ans = max of ans and n/x +1 ;  $  TAB2 set x = x*3 ;  $  TAB1 print ans and a newline ;
TAB1 create long long n ;  $  TAB1 read n and loop further ;  $  TAB2 declare long long a ;  $  TAB2 declare long long t = 3 ;  $  TAB2 while n % t = 0, multiply t by 3 ;  $  TAB2 print n / t + 1 ;
TAB1 create long longs n and a ;  $  TAB1 read n and keep looping ;  $  TAB2 set a to 3 ;  $  TAB2 while n modulo a is 0 ;  $  TAB2 print n / a + 1 ;
TAB0 cil is a long long function with long long arguments x and y ;  $  TAB1 if x % y is equal to 0 ;  $  TAB2 return x / y ;  $  TAB1 else ;  $  TAB2 return x / y + 1 ;  $  TAB1 declare long long variables n, i and j with j = 0 ;  $  TAB1 read input to n ;  $  TAB1 change i to n ;  $  TAB1 while n % 3 is 0 and n > 0 ;  $  TAB2 increment j ;  $  TAB2 divide n by 3 ;  $  TAB1 create long long l = 3 raised to power j + 1 ;  $  TAB1 print cil(i, l) ;
TAB1 create long longs n, m, i, j, k ;  $  TAB1 read n ;  $  TAB1 set k to 3 ;  $  TAB1 while 1 is true ;  $  TAB2 if n % k is not 0 ;  $  TAB3 set m to ( n / k ) + 1 ;  $  TAB3 break loop ;  $  TAB2 set value of k to 3 ;  $  TAB1 print m print newline ;
TAB0 declare const int maxn = 100001 ;  $  TAB0 declare long long n ;  $  TAB1 read n ;  $  TAB1 while n modulo 3 = 0, divide n by 3 ;  $  TAB1 print n / 3 + 1 ;
TAB0 in function power_of_two taking int n and returning bool ;  $  TAB1 m = int ;  $  TAB1 set m to n - 1 ;  $  TAB1 if not n bitwise-and m ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB1 n, m, a, mn = int with mn = 10000 ;  $  TAB1 read n then m ;  $  TAB1 v = int vector ;  $  TAB1 for i = 0 to m ;  $  TAB2 read a ;  $  TAB2 append a to v ;  $  TAB1 sort v ;  $  TAB1 for i = n - 1 to m set mn to min of mn and v[i] - v[i - n + 1] ;  $  TAB1 print mn ;
TAB1 let integers n, m, i, and ans = INT_MAX and int array a of size 1000 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to m exclusive, read a[i] ;  $  TAB1 sort array a ;  $  TAB1 for i = 0 to m - n, set ans to the min of ans and a[i + n - 1] - a[i] ;  $  TAB1 print ans ;
TAB1 let n, m, and f with 1000 indices be int ;  $  TAB1 read n and m ;  $  TAB1 read f of i i times from 0 to m exclusive ;  $  TAB1 sort f and f plus m ;  $  TAB1 let least be f[n - 1] - f[0] ;  $  TAB1 for i from to 1 m - n inclusive ;  $  TAB2 if f[i + n - 1] - f[i] < least set least to least = f[i + n - 1] - f[i] ;  $  TAB1 print least ;
TAB0 create integers array dx initialized with 1, 0, -1, 0, 1, 1, -1, -1 ;  $  TAB0 create integers array dy initialized with 0, 1, 0, -1, 1, -1, 1, -1 ;  $  TAB0 in the function fast ;  $  TAB0 declare const long long md = 1e9 + 7 ;  $  TAB1 call fast() ;  $  TAB1 create long longs n and m ;  $  TAB1 read n and m ;  $  TAB1 declare an array of long longs a with m + 5 elements ;  $  TAB1 read a from the input m times ;  $  TAB1 sort first m elements of a ;  $  TAB1 declare long long variable ans = LLONG_MAX ;  $  TAB1 for i from 0 to m - n inclusive, change ans to min of ans and a[i + (n - 1)] - a[i] ;  $  TAB1 print ans ;
TAB1 n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 arr = integer array of size 100000 ;  $  TAB1 for i = 0 to m exclusive, read arr[i] ;  $  TAB1 sort arr and arr + m ;  $  TAB1 mindiff = integer with mindiff = INT_MAX ;  $  TAB1 for i = 0 to m - (n - 1) exclusive ;  $  TAB2 diff = integer with diff = arr[i + n - 1] - arr[i] ;  $  TAB2 if diff < mindiff, mindiff = diff ;  $  TAB1 print mindiff ;
TAB1 create new variables n, m, i, j, total, val, diff and mini be ints with total = 0 and mini = 10000 ;  $  TAB1 declare new vector of integers called v ;  $  TAB1 read variables n and m from the input ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read val ;  $  TAB2 push val to the end of v ;  $  TAB1 sort v ;  $  TAB1 start for loop from i = 0 to m - n inclusive incrementing i ;  $  TAB2 change val to abs(v[i] - v[i + n - 1]) ;  $  TAB2 change mini to min of mini and val ;  $  TAB1 print mini ;
TAB1 create integers n and m, and an array of integers f with size 1000 ;  $  TAB1 read input to n and m ;  $  TAB1 for integer i = 0 to m exclusive, read input to f[i] ;  $  TAB1 sort m elements of f ;  $  TAB1 create integer least = f[n - 1] - f[0] ;  $  TAB1 for i from 1 to m - n inclusive ;  $  TAB2 if f[i + n - 1] - f[i] is less than least, assign f[i + n - 1] - f[i] to least ;  $  TAB1 print least ;
TAB1 let n,m,mn be integers wtih mn = 1005 and a be an integer array of size 60 ;  $  TAB1 input n ;  $  TAB1 input m ;  $  TAB1 input m number of items into a ;  $  TAB1 call sort with parameters a, a+m ;  $  TAB1 for i = 0 to m-n ;  $  TAB2 set integer d to a[i + n - 1] - a[i] ;  $  TAB2 if d < mn set mn = d ;  $  TAB1 print mn ;
TAB1 declare x, y as integers ;  $  TAB1 read x, y ;  $  TAB1 declare integer array m size y ;  $  TAB1 declare integer array arr size y ;  $  TAB1 for i = 0 to y exclusive, read arr[i] ;  $  TAB1 sort elements from arr to arr + y ;  $  TAB1 declare integer k with k = 0 ;  $  TAB1 for i = 0 to y - x + 1 exclusive ;  $  TAB2 let m[k] be arr[x-1+i] - arr[i] ;  $  TAB2 increment k ;  $  TAB1 let integer min be 99999 ;  $  TAB1 for j = 0 to k exclusive ;  $  TAB2 if min is greater than m[j], let min be m[j] ;  $  TAB1 print min, newline ;
TAB1 let i, a, b, j, s, c, d be integers with c = array of integers of length 1000, d = array of integers of length 1000 ;  $  TAB1 read a, b ;  $  TAB1 for i = 0 to b exclusive , read c[i] ;  $  TAB1 sort the values c and c + b ;  $  TAB1 for i = 0, j = 0, i is less than b - a + 1, increment i , j by 1, d[j] is equal to c[i + a - 1] - c[i] ;  $  TAB1 sort the values d, d + b - a + 1 ;  $  TAB1 print d[0] and newline ;
TAB0 create int array A of size 1000100 ;  $  TAB1 let ints n and m ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to m exclusive, read A[i] ;  $  TAB1 sort A ;  $  TAB1 create ints high = n - 1 and low = 0 ;  $  TAB1 let int mini = A[high] - A[low] ;  $  TAB1 while high is less than m ;  $  TAB2 increment low ;  $  TAB2 increment high ;  $  TAB2 if high is less than m, set mini to the min of mini and A[high] - A[low] ;  $  TAB1 print mini ;
TAB1 create ints num and buy ;  $  TAB1 create int vector v ;  $  TAB1 read num and buy ;  $  TAB1 for i = 0 to buy exclusive ;  $  TAB2 let int x ;  $  TAB2 read x ;  $  TAB2 append x to vector v ;  $  TAB1 sort vector v ;  $  TAB1 let ints max = 0, min = 0, and differ = 1000000 ;  $  TAB1 for i = 0 to size of v exclusive ;  $  TAB2 if i + num is greater than the size of v ;  $  TAB3 break loop ;  $  TAB2 otherwise do ;  $  TAB3 set min to the min value in v ;  $  TAB3 set max to the max value in v ;  $  TAB3 if v.at(max) - v.at(min) is less than differ, set differ to v.at(max) - v.at(min) ;  $  TAB1 for i = 0 to size of v exclusive ;  $  TAB2 let int total = count(v.begin(), v.end(), v.at(i)); ;  $  TAB2 if total is greater than or equal to num ;  $  TAB3 set differ to 0 ;  $  TAB3 break loop ;  $  TAB1 print differ ;
TAB1 let n,m be integers ;  $  TAB1 read n and m ;  $  TAB1 a = array of integers of length m ;  $  TAB1 for i = 0 to m exclusive , read a[i] ;  $  TAB1 sort the values a and a + m ;  $  TAB1 let min be a integer with min = 1000000 ;  $  TAB1 for i = 0 to m - n + 1 exclusive ;  $  TAB2 if a[i + n - 1] - a[i] is less than min , the value of min is equal to a[i + n - 1] - a[i] ;  $  TAB1 if min is equal to 1000000 ;  $  TAB2 print 0 and newline ;  $  TAB1 else do the following ;  $  TAB2 print min and newline ;
TAB1 set precision to 10 ;  $  TAB1 print fixed ;  $  TAB1 n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 v = vector of integer with v = m ;  $  TAB1 for i = 0 to m exclusive, print v[i] ;  $  TAB1 sort v.begin() and v.end() ;  $  TAB1 diff = vector of integer ;  $  TAB1 for i = 0 to m - n + 1 exclusive, append (abs(v[i] - v[n + i - 1])) in diff ;  $  TAB1 print pointer min_element(diff.begin(), diff.end()) ;
TAB1 declare int variables n and m ;  $  TAB1 read n and m from the input ;  $  TAB1 arr is a new array ofintegers with m elements ;  $  TAB1 in the for loop, change i from 0 to m exclusive, reading variable arr[i] from the input ;  $  TAB1 sort arr from index 0 to m exclusive ;  $  TAB1 declare integer mn = 1e9 ;  $  TAB1 for i = 0 to m - n inclusive, change mn to min of mn and arr[i + n - 1] - arr[i] ;  $  TAB1 print mn to the standard output ;
TAB1 numbuy=int ;  $  TAB1 v=vector of int ;  $  TAB1 read num,buy ;  $  TAB1 for i=0 to buy exclusive ;  $  TAB2 x=int ;  $  TAB2 read x ;  $  TAB2 add x at end of v ;  $  TAB1 sort v ;  $  TAB1 max,min=0, differ=1000000 ;  $  TAB1 for i=0 to size of v exclusive ;  $  TAB2 if i+num > size of v ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 min=min_element(first item of v+i, first item of v+i+num) - first item of v ;  $  TAB3 max=max_element(first item of v+i, first item of v+i+num) - first item of v ;  $  TAB3 if pos of max in v - pos of min in v < differ differ = pos of max in v - pos of min in v ;  $  TAB1 for i=0 to size of v exclusive ;  $  TAB2 total=count(occurrences of i in v) ;  $  TAB2 if total >= num ;  $  TAB3 differ=0 ;  $  TAB3 break ;  $  TAB1 print differ ;
TAB1 declare integers n, m ;  $  TAB1 read n, m ;  $  TAB1 declare integer array a size m ;  $  TAB1 for i = 0 to m exclusive, read a[i] ;  $  TAB1 sort from a to a + m ;  $  TAB1 declare integers i = 0, j = n - 1 ;  $  TAB1 declare psum = a[j]-a[i] as integer ;  $  TAB1 while j is less than m ;  $  TAB2 declare sum = a[j]-a[i] as integer ;  $  TAB2 if sum is less than or equal to psum, let psum = sum ;  $  TAB2 increment i ;  $  TAB2 increment j ;  $  TAB1 print psum, "\n" ;
TAB1 noOfStudents, noOfprizes, minimum = int with minimum = 100000 ;  $  TAB1 read noOfStudents then noOfprizes ;  $  TAB1 a = int array of size noOfprizes ;  $  TAB1 read noOfprizes values into a ;  $  TAB1 sort a ;  $  TAB1 for i = 0 to noOfprizes - noOfStudents + 1 set minimum to min of a[i + noOfStudents - 1] - a[i], minimum ;  $  TAB1 print minimum ;
TAB0 create long long ans = 1000000 ;  $  TAB1 declare long long int variables n and m ;  $  TAB1 read input to n and m ;  $  TAB1 declare long long int array a with m + 2 elements ;  $  TAB1 for integer i = 0 to m exclusive, read a[i] ;  $  TAB1 sort m elements of a ;  $  TAB1 declare long long int k = m - n ;  $  TAB1 for i from 0 to k inclusive, assign min of ans and a[i + (n - 1)] - a[i] to ans ;  $  TAB1 print ans ;
TAB1 n,m=int ;  $  TAB1 while read n, m ;  $  TAB2 a=array of 55 int ;  $  TAB2 for i=0 to m exclusive read a[i] ;  $  TAB2 sort first m items of a ;  $  TAB2 min2=999999999, t=int ;  $  TAB2 for i=n-1 to m exclusive ;  $  TAB3 t=a[i]-a[i-n+1] ;  $  TAB3 if min2>t min2=t ;  $  TAB2 print min2 ;
TAB1 create long longs n, m ;  $  TAB1 read n read m ;  $  TAB1 create long long vector a initialized with ( m, 0 ) ;  $  TAB1 for i = 0 to m exclusive, read a[i] ;  $  TAB1 sort elements from beginning of a to end of a ;  $  TAB1 create long longs l, r ;  $  TAB1 set l to r to 0 ;  $  TAB1 set r to n - 1 ;  $  TAB1 create long long mn with mn = a[m - 1] - a[0] ;  $  TAB1 while r is not m ;  $  TAB2 set mn to minimum of ( mn and a[r] - a[l] ) ;  $  TAB2 increment l ;  $  TAB2 increment r ;  $  TAB1 print mn print newline ;
TAB1 let n, m be integers ;  $  TAB1 read n and m ;  $  TAB1 arr = vector ;  $  TAB1 while m is greater than 0 ;  $  TAB2 let i be int ;  $  TAB2 read i ;  $  TAB2 push_back i onto r ;  $  TAB2 decrement m ;  $  TAB1 sort with functions arr.begin and arr.end ;  $  TAB1 let distance be integer with value 1e9 ;  $  TAB1 for i from 0 to arr size minus n + 1 exclusive ;  $  TAB2 if arr[i + n - 1] - arr[i] < distance then set distance to arr[i + n - 1] - arr[i] ;  $  TAB1 print distance ;
TAB1 declare integers k, d and i ;  $  TAB1 read k and d ;  $  TAB1 if d = 0 ;  $  TAB2 if k = 1 ;  $  TAB3 print 0 and a new line ;  $  TAB2 else ;  $  TAB3 print "No solution\n" ;  $  TAB1 else ;  $  TAB2 print d ;  $  TAB2 for i = 1 to k exclusive, print 0 ;  $  TAB2 print new line ;
TAB1 create integers k, d ;  $  TAB1 read k read d ;  $  TAB1 if d is 0 and k is greater than 1 ;  $  TAB2 print "No solution\n" ;  $  TAB1 print d ;  $  TAB1 decrement k ;  $  TAB1 while decrement k is true, print 0 ;  $  TAB1 print newline ;
TAB1 k and d = integers ;  $  TAB1 read k and d ;  $  TAB1 if d = 0 ;  $  TAB2 if k = 1 ;  $  TAB3 print "0" and a new line ;  $  TAB2 else ;  $  TAB3 print "No solution" and a new line ;  $  TAB1 else ;  $  TAB2 print d ;  $  TAB2 print "0" k - 1 times ;  $  TAB2 print new line ;
TAB1 let k be a integer ;  $  TAB1 let d be a character ;  $  TAB1 read the values k and d ;  $  TAB1 if (d is equal to 0 and k is greater than 1) ;  $  TAB2 print No solution and newline ;  $  TAB1 let temp be a string ;  $  TAB1 push temp vector to back when element d is given( temp.push_back(d)) ;  $  TAB1 for (int i is equal to 1, i is less than k; increment i value by 1) ,temp.push_back('0') ;  $  TAB1 print temp and newline ;
TAB1 create integers k, d ;  $  TAB1 read k read d ;  $  TAB1 if k is 1 and d is 0 ;  $  TAB2 print "0" print newline ;  $  TAB1 else if k is greater than 1 and d is 0 ;  $  TAB2 print "No solution" print newline ;  $  TAB1 else ;  $  TAB2 print d ;  $  TAB2 for i = 0 to k - 1 exclusive, print "0" ;  $  TAB2 print newline ;
TAB1 k, d=integers ;  $  TAB1 Read k and d ;  $  TAB1 if d is equal to 0 and k is greater than 1 ;  $  TAB2 print No solution and a new line ;  $  TAB1 else do the following ;  $  TAB2 print d ;  $  TAB2 for i = 1 to k, exclusive, print 0 ;  $  TAB2 print a new line ;
TAB1 k, d =integers ;  $  TAB1 Read k, d ;  $  TAB1 if d is equal to 0 and k is greater than 1 ;  $  TAB2 print No solution and a new line ;  $  TAB1 print d ;  $  TAB1 for j = 1 to k exclusive, print 0 ;  $  TAB1 print a new line ;
TAB1 k, d, i, j =integers ;  $  TAB1 Read k and d ;  $  TAB1 if d is equal to 0 ;  $  TAB2 if k is greater than 1 ;  $  TAB3 print No solution and a new line ;  $  TAB2 else do the following ;  $  TAB3 print 0 and a new line ;  $  TAB1 print d ;  $  TAB1 for i = 0 to k exclusive, print 0 ;  $  TAB1 print a new line ;
TAB1 k, d = integers ;  $  TAB1 read k and d ;  $  TAB1 if k is greater than 1 and d is 0 ;  $  TAB2 print No solution ;  $  TAB1 print d ;  $  TAB1 for i=1 to k exclusive print 0 ;  $  TAB1 print new line ;
TAB1 d = large long ;  $  TAB1 read k and d ;  $  TAB1 if d = 0 and k > 1 ;  $  TAB2 print No Solution ;  $  TAB1 else ;  $  TAB2 print d ;  $  TAB2 increment k ;  $  TAB2 while k > - ;  $  TAB3 print 0 ;  $  TAB3 decrement k ;  $  TAB2 print newline ;
TAB0 declare desperate_optimization with integer precision as argument, returning void ;  $  TAB1 set cout stream flag ios::fixed ;  $  TAB1 set cout stream flag ios::showpoint ;  $  TAB1 set cout floating point precision to precision ;  $  TAB1 run desperate_optimization with 10 as argument ;  $  TAB1 create integers n, k ;  $  TAB1 read n read k ;  $  TAB1 if k is 0 and n is not 1 ;  $  TAB2 print "No solution" print '\n' ;  $  TAB1 if k is 0 ;  $  TAB2 print 0 print '\n ;  $  TAB1 else ;  $  TAB2 print k ;  $  TAB2 for i = 1 to n exclusive, print 0 ;  $  TAB2 print '\n' ;
TAB0 create integers k, d ;  $  TAB1 read k read d ;  $  TAB1 if d is 0 and k is greater than 1 ;  $  TAB2 print "No solution" print newline ;  $  TAB1 print d ;  $  TAB1 decrement k ;  $  TAB1 while decrement k is true, print 0 ;  $  TAB1 print newline ;
TAB1 create integers k, q, with q = 1 ;  $  TAB1 create character d ;  $  TAB1 create string s with s = "" ;  $  TAB1 read k read d ;  $  TAB1 if d - '0' is 0 ;  $  TAB2 if k is 1 ;  $  TAB3 print 0 print newline ;  $  TAB2 else ;  $  TAB3 print "No solution" print newline ;  $  TAB1 else ;  $  TAB2 increment s by d ;  $  TAB2 for i = 1 to k exclusive, increment s by "0" ;  $  TAB2 print s print newline ;
TAB1 declare integers k and d ;  $  TAB1 read k and d ;  $  TAB1 if k is greater than 1 and d is 0 ;  $  TAB2 print "No solution" and a new line ;  $  TAB1 print d ;  $  TAB1 decrease k by one ;  $  TAB1 print 0 in the loop while decrementing k ;  $  TAB1 print new line ;
TAB0 Mod = const int with Mod = 1e9 + 7 ;  $  TAB0 n, p = integers ;  $  TAB0 choose, ans = long long with choose = 2d array of 30025 rows and 600 columns, ans = 1 ;  $  TAB0 Pedy = map from int to int ;  $  TAB1 read n ;  $  TAB1 index 0, 0 of choose = 1 ;  $  TAB1 for i = 1 to 30024 ;  $  TAB2 index i and 0 of choose = 1 ;  $  TAB2 for j = 1 to n index i and j of choose = (choose[i - 1][j - 1] + choose[i - 1][j]) modulo Mod ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read p ;  $  TAB2 for j = 2 to j * j <= p ;  $  TAB3 if p modulo j is 0 ;  $  TAB4 while not(p modulo j) ;  $  TAB5 p = p / j ;  $  TAB5 increment Pedy[j] ;  $  TAB2 if p > 1, increment Pedy[p] ;  $  TAB1 for it = Pedy.begin() to it is not Pedy.end() ;  $  TAB2 p = second in it ;  $  TAB2 ans = (ans * choose[p + n - 1][n - 1]) modulo Mod ;  $  TAB1 print ans ;
TAB1 n, l, r, a, b, sum = int with sum = 0 and my = int array of size 105 with all values set to 0 ;  $  TAB1 read n ;  $  TAB1 read l then r ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 read a then b ;  $  TAB2 for j = a + 1 to b inclusive set m[j] to 1 ;  $  TAB1 for i = l + 1 to r inclusive ;  $  TAB2 if m[i] is 0 increment sum ;  $  TAB1 print sum ;
TAB0 create integer array arrx with size 101 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integers l, r ;  $  TAB1 read l read r ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 create integers a, b ;  $  TAB2 read a read b ;  $  TAB2 for j = a to b exclusive, set arrx[j] to 1 ;  $  TAB1 create integer total with total = 0 ;  $  TAB1 for i = l to r exclusive, increment total by 0 if arrx[i] is true, else 1 ;  $  TAB1 print total print newline ;
TAB0 declare constant integer N = 100 + 5 ;  $  TAB0 declare boolean array mark with N elements ;  $  TAB1 declare int variables n, st and en ;  $  TAB1 read input to n, st and en ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 create integers l and r ;  $  TAB2 read l and r ;  $  TAB2 for j from l to r exclusive, set mark[j] to true ;  $  TAB1 create int ans = 0 ;  $  TAB1 for i = st to en exclusive, increase ans by !mark[i] ;  $  TAB1 print ans ;
TAB0 N=105 ;  $  TAB0 mm = array of N bool ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 k1,k2=int ;  $  TAB1 read k1,k2 ;  $  TAB1 fill mm with false ;  $  TAB1 for i=k1 to k2 exclusive mm[i]=true ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 read k1,k2 ;  $  TAB2 for j=k1 to k2 exclusive mm[j]=false ;  $  TAB1 ans=0 ;  $  TAB1 for i=0 to 101 exclusive ;  $  TAB2 if mm[i] increment ans ;  $  TAB1 print ans ;
TAB0 create int arr[1000] ;  $  TAB1 let n be int ;  $  TAB1 read n ;  $  TAB1 create int l and r ;  $  TAB1 read l, r ;  $  TAB1 decrement n ;  $  TAB1 while decrement n ;  $  TAB2 create integers x and y ;  $  TAB2 read x, y ;  $  TAB2 for i=x to y exclusive, increment arr[i] ;  $  TAB1 assign 0 to ans ;  $  TAB1 for i=l to r exclusive ;  $  TAB2 if arr[i] =0, add 1 to ans ;  $  TAB1 print ans ;
TAB0 create int n, l, r, a[200], x, y, ans, z, w, set ans to 0 ;  $  TAB1 read n ;  $  TAB1 read x and y ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 read l and r ;  $  TAB2 for j= l to r exclusive, set a[j] to 1 ;  $  TAB1 for i=x to y exclusive ;  $  TAB2 if a[i] is 0, increment ans ;  $  TAB1 print ans ;
TAB1 n=int ;  $  TAB1 l,r=int ;  $  TAB1 vis=array of 101 int ;  $  TAB1 while read n ;  $  TAB2 fill vis with 0 ;  $  TAB2 read l,r ;  $  TAB2 for i=l+1 to r inclusive vis[i]=1 ;  $  TAB2 x,y=int ;  $  TAB2 for i=1 to n-1 inclusive ;  $  TAB3 read x,y ;  $  TAB3 for j=x+1 to y inclusive vis[j]=0 ;  $  TAB2 cnt=0 ;  $  TAB2 for i=l+1 to r inclusive add vis[i] to cnt ;  $  TAB2 print cnt ;
TAB0 in int function miniel which takes an int vecotr v and an int x ;  $  TAB1 let l = int = 11111111 ;  $  TAB1 for i = 0 to x inclusive ;  $  TAB2 if v at i < l then set l = v at 1 ;  $  TAB1 return l ;  $  TAB1 let n, s, e, p be integers ;  $  TAB1 read n, s, e ;  $  TAB1 let arr be an integer array of length 100, with arr[0] = 0 ;  $  TAB1 sum = int = 0 ;  $  TAB1 l = int = -111 ;  $  TAB1 for i = 1 to n ;  $  TAB2 let x, y be int ;  $  TAB2 read x and y ;  $  TAB2 if e <= y ;  $  TAB3 set p to e ;  $  TAB2 else ;  $  TAB3 set p to y ;  $  TAB2 for i = x to p, set arr[i] to arr[i] + 1 ;  $  TAB1 for i = s to e ;  $  TAB2 if arr at i is 0 then increment sum ;  $  TAB1 print sum and new line ;
TAB0 create int n, a, b, c, d, ans ;  $  TAB0 create int array dryer of length 101 ;  $  TAB1 read n, a and b ;  $  TAB1 while pre decrement n ;  $  TAB2 read c and d ;  $  TAB2 for i=c to d exclusive, set dryer[i] to 1 ;  $  TAB1 for i=a to b exclusive ;  $  TAB2 if dryer[i] equal to 0, increment ans ;  $  TAB1 print ans ;
TAB0 create const int maxn = 100 + 10 ;  $  TAB0 let bool array mark size of maxn ;  $  TAB1 let int n ;  $  TAB1 read n ;  $  TAB1 make ints L and R ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let ints l and r ;  $  TAB2 read l and r ;  $  TAB2 if i is greater than 0 ;  $  TAB3 for j = l to r exclusive, set mark[j] to true ;  $  TAB2 else ;  $  TAB3 set L to l and R to r ;  $  TAB1 make integer ans = 0 ;  $  TAB1 for i = 0 to maxn exclusive ;  $  TAB2 if !mark[i] is truthy and L is less than or equal to i and i is less than R, increment ans ;  $  TAB1 print ans ;
TAB1 b, a, n, i, c, d, m, j = integers ;  $  TAB1 v = integer array of size 110 ;  $  TAB1 while read n, c, d ;  $  TAB2 m = 0 ;  $  TAB2 for i = 0 to 100, v[i] = 0 ;  $  TAB2 for i = 0 to n - 1 exclusive ;  $  TAB3 read a, b ;  $  TAB3 for j = a + 1 to b, v[j] = -1 ;  $  TAB2 for i = c + 1 to d ;  $  TAB3 if v[i] is 0, increment m ;  $  TAB2 print m ;
TAB0 N=100011 ;  $  TAB0 use=array of N bool ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 l,r=int ;  $  TAB1 read l,r ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 l,r=int ;  $  TAB2 read l,r ;  $  TAB2 for j=l to r exclusive use[j]=1 ;  $  TAB1 ans=0 ;  $  TAB1 for i=l to r exclusive ;  $  TAB2 if use[i] is 0 increment ans ;  $  TAB1 print ans ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 i = int ;  $  TAB1 x = int vector of size n ;  $  TAB1 y = int vector of size n ;  $  TAB1 z = int vector of size 101 with all values set to 1 ;  $  TAB1 read n values into x then y ;  $  TAB1 k = int ;  $  TAB1 for i = 1 to n ;  $  TAB2 for j = x[i] to y[i] set z[k] to 0 ;  $  TAB1 ct = int with ct = 0 ;  $  TAB1 for i = x[0] to y[0] ;  $  TAB2 if z[i] is 1 increment ct ;  $  TAB1 print ct ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let x, y be integers ;  $  TAB1 read x, y ;  $  TAB1 let d be a integer with d = y - x ;  $  TAB1 a = array of integers of length d ;  $  TAB1 for i = 0 to d exclusive , the value of a[i] is equal to 1 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 let m, n be integers ;  $  TAB2 read m, n ;  $  TAB2 decrement n by 1 ;  $  TAB2 for p = m to n inclusive ;  $  TAB3 if p >= y or p is less than x, proceed to next ;  $  TAB3 the value of a[p - x] is equal to 0 ;  $  TAB1 let sum be a integer with sum = 0 ;  $  TAB1 for j = 0 to d exclusive, increment sum by a[j] ;  $  TAB1 print sum and newline ;
TAB0 create int array v[105] ;  $  TAB1 create long long n and sum, set sum to 0 ;  $  TAB1 read n ;  $  TAB1 let x and y be int ;  $  TAB1 read x, y ;  $  TAB1 for i=2 to n inclusive ;  $  TAB2 create int a and b ;  $  TAB2 read a and b ;  $  TAB2 for j= a+1 to b inclusive, set v[j] to 1 ;  $  TAB1 for i=x+1 to y inclusive, assign sum + 1 - v[i] to sum ;  $  TAB1 print sum and a newline ;
TAB0 create int array a of length 105 ;  $  TAB0 create integers n, x, y, i, l, r ;  $  TAB0 let sum and j be integers ;  $  TAB1 read n ;  $  TAB1 read x and y ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 read l and r ;  $  TAB2 for j=l to r exclusive, set a[j] to 1 ;  $  TAB1 assign 0 to sum ;  $  TAB1 for i=x to y exclusive ;  $  TAB2 if a[i] equal to 0, sum = sum +1 ;  $  TAB1 print sum ;
TAB1 n, i, j, sum, alexeyI and alexeyJ are integers with sum = 0 ;  $  TAB1 create int array dryer with size 101 ;  $  TAB1 call fill_n(dryer, 101, 1) ;  $  TAB1 read n ;  $  TAB1 read input to alexeyI and alexeyJ ;  $  TAB1 for integer l = 0 to n - 1 exclusive ;  $  TAB2 read i and j ;  $  TAB2 for k from i to j exclusive, set dryer[k] to 0 ;  $  TAB1 for k from alexeyI to alexeyJ exclusive, add dryer[k] to sum ;  $  TAB1 print sum ;
TAB0 create int array arr with size 1000 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create integers l and r ;  $  TAB1 read l and r ;  $  TAB1 decrement n by one ;  $  TAB1 while n != 0, decrement it and continue the loop ;  $  TAB2 create ints x and y ;  $  TAB2 read input to x and y ;  $  TAB2 for i = y to x exclusive counting down, increment arr[i] by one ;  $  TAB1 declare int variable ans = 0 ;  $  TAB1 for i = r to l exclusive counting down ;  $  TAB2 if arr[i] is equal to 0, increment ans by one ;  $  TAB1 print ans ;
TAB0 in function File ;  $  TAB1 call freopen of "output.txt", "w" and stdout ;  $  TAB1 call freopen of "input.txt", "r" and stdin ;  $  TAB0 define empty function fast ;  $  TAB0 pi = const double with pi = 2 * acos of 0.0 ;  $  TAB0 nn = const int with nn = 2e5 + 5 ;  $  TAB0 oo = const int with oo = 0x3f3f3f3f ;  $  TAB1 call fast ;  $  TAB1 n, b, e, ans = int with ans = 0 ;  $  TAB1 arr = int array of size nn ;  $  TAB1 read n ;  $  TAB1 read b then e ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 x, y = int ;  $  TAB2 read x then y ;  $  TAB2 for j = x to y increment arr[j] ;  $  TAB1 for i = b to e ;  $  TAB2 if arr8i] is 0 increment ans ;  $  TAB1 print ans ;
TAB0 create integer vector v ;  $  TAB1 create integers n, p, k ;  $  TAB1 read n read p read k ;  $  TAB1 for x = p - k to p + k inclusive ;  $  TAB2 if x is less than 1, break current loop iteration ;  $  TAB2 if x is greater than n, break current loop iteration ;  $  TAB2 add element x to end of v ;  $  TAB1 if v[0] is not 1, print "<< " ;  $  TAB1 for i = 0 to integer casted size of v exclusive ;  $  TAB2 if v[i] is p, print "(" ;  $  TAB2 print v[i] ;  $  TAB2 if v[i] is p, print ")" ;  $  TAB2 if i is integer casted size of v - 1 ;  $  TAB3 if v[i] is less than n ;  $  TAB4 print " >>" print newline ;  $  TAB3 else ;  $  TAB4 print newline ;  $  TAB2 else ;  $  TAB3 print " " ;
TAB0 create integer queue q ;  $  TAB0 create boolean array p with size 10000 with p = {} ;  $  TAB0 create integer pe ;  $  TAB0 declare print with integers c, a, b as arguments, returning void ;  $  TAB1 if a is less than c or a is greater than b or p[a] or a is greater than pe or a is less than 1, return from function ;  $  TAB1 set p[a] to true ;  $  TAB1 run print with c, a - 1, b as arguments ;  $  TAB1 add element a to end of q ;  $  TAB1 run print with c, a + 1, b as arguments ;  $  TAB1 create integers n, k ;  $  TAB1 read pe read n read k ;  $  TAB1 if n - k is greater than 1, print "<< " ;  $  TAB1 run print with n - k, n, n + k as arguments ;  $  TAB1 while q is not empty ;  $  TAB2 if size of q is not 1 and front of q is not n ;  $  TAB3 print front of q print " " ;  $  TAB2 else if front of q is n ;  $  TAB3 print "(" print front of q ;  $  TAB3 if size of q is not 1 ;  $  TAB4 print ") " ;  $  TAB3 else ;  $  TAB4 print ")" ;  $  TAB2 else ;  $  TAB3 print front of q ;  $  TAB2 remove element from end of q ;  $  TAB1 if n + k is less than pe, print " >>" ;  $  TAB1 print newline ;
TAB0 in the function desperate_optimization ;  $  TAB1 set format flag ios::fixed of the output ;  $  TAB1 set format flag ios::showpoint of the output ;  $  TAB1 set output precision to precision ;  $  TAB1 call desperate_optimization(10) ;  $  TAB1 let n, p and k be integers ;  $  TAB1 read n, p and k ;  $  TAB1 if p - k is greater than 1 ;  $  TAB1 for i = max of 1 and p - k to p exclusive, print i and " " ;  $  TAB1 print "(", p and ")" ;  $  TAB1 for i = p + 1 to min of n and p + k inclusive, print " " and i ;  $  TAB1 if p + k is less than n, print " >>" ;  $  TAB1 print '\n' ;
TAB1 create integers n, p, k ;  $  TAB1 create booleans start, end with start = 1, end = 0 ;  $  TAB1 read n read p read k ;  $  TAB1 for i = p - k to p + k inclusive ;  $  TAB2 if start is true ;  $  TAB3 if i is less than or equal to 1 ;  $  TAB4 if p is 1 ;  $  TAB5 print "(" print 1 print ")" ;  $  TAB4 else ;  $  TAB5 print 1 ;  $  TAB4 set i to 1 ;  $  TAB3 else ;  $  TAB4 print "<< " print i ;  $  TAB3 set start to 0 ;  $  TAB3 break current loop iteration ;  $  TAB2 if i is greater than or equal to n ;  $  TAB3 set end to 1 ;  $  TAB3 if p is n ;  $  TAB4 print " (" print n print ")" ;  $  TAB3 else ;  $  TAB4 print " " print n ;  $  TAB3 break loop ;  $  TAB2 if i is p ;  $  TAB3 print " (" print i print ")" ;  $  TAB2 else ;  $  TAB3 print " " print i ;  $  TAB1 if not end print " >>" ;  $  TAB1 print '\n' ;
TAB1 create integers n and v ;  $  TAB1 read n and v ;  $  TAB1 a is an array of doubles with size n ;  $  TAB1 read n elements into array a ;  $  TAB1 declare double called minvalue = INT_MAX ;  $  TAB1 b is an array of doubles with size n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 assign value of min of minvalue and b[i] to the minvalue ;  $  TAB1 l is double = 0 ;  $  TAB1 let r be double = 1e18 ;  $  TAB1 answer is double = 0 ;  $  TAB1 for integer i = 1 to 100 inclusive ;  $  TAB2 double mid = (l + (r - l) / 2) ;  $  TAB2 sum is double = 0 ;  $  TAB2 flag is integer = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 set double value to a[i] * mid ;  $  TAB3 if value is greater than b[i] ;  $  TAB4 set flag to 1 ;  $  TAB4 break the loop ;  $  TAB3 else ;  $  TAB4 increase sum by (a[i] * mid) ;  $  TAB2 if flag = 1 ;  $  TAB3 set value of r to mid - 1 ;  $  TAB3 skip the rest of the loop ;  $  TAB2 if sum <= v ;  $  TAB3 set answer to sum ;  $  TAB3 l = mid + 1 ;  $  TAB2 else ;  $  TAB3 r = mid - 1 ;  $  TAB1 print setprecision(6), fixed, answer and "\n" ;
TAB0 create const long long inf = 1e9 + 7 ;  $  TAB1 declare integer n ;  $  TAB1 read from the input to n ;  $  TAB1 create long long ans = 0 and long long arrays a, left and right with size n + 2 ;  $  TAB1 change a[0] to - 1 ;  $  TAB1 assign inf to a[n + 1] ;  $  TAB1 loop i from 1 to n inclusive incrementing i ;  $  TAB1 set right[0] to 0 ;  $  TAB1 loop i from 1 to n inclusive, change right[i] to right[i - 1] + 1 if a[i] > a[i - 1], or else 1 ;  $  TAB1 set left[n + 1] to 0 ;  $  TAB1 loop i from n to 0 inclusive decrementing i, change left[i] to left[i + 1] + 1 if a[i] < a[i + 1], or else 1 ;  $  TAB1 loop i from 1 to n inclusive ;  $  TAB2 if a[i - 1] + 1 is less than a[i+1] ;  $  TAB3 set ans to max of ans and 1 + left[i + 1] + right[i - 1] ;  $  TAB2 else ;  $  TAB3 set ans to max of ans and (max of left[i] and right[i] + 1) ;  $  TAB1 print ans ;
TAB0 maxn = const integer with maxn = 100005 ;  $  TAB0 INF = const integer with INF = 0x3fffffff ;  $  TAB0 eps = double with eps = 1e-8 ;  $  TAB0 pi = double with pi = acos of -1 ;  $  TAB0 f = integer array of size maxn ;  $  TAB0 g = integer array of size maxn ;  $  TAB0 a = integer array of size maxn ;  $  TAB0 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 for i = 1 to n ;  $  TAB2 if a[i] > a[i - 1] ;  $  TAB3 f[i] = f[i - 1] + 1 ;  $  TAB2 else ;  $  TAB3 f[i] = 1 ;  $  TAB1 for i = n down to 1 ;  $  TAB2 if a[i] < a[i + 1] ;  $  TAB3 g[i] = g[i + 1] + 1 ;  $  TAB2 else ;  $  TAB3 g[i] = 1 ;  $  TAB1 ans = integer with ans = 0 ;  $  TAB1 for i = 1 to n ;  $  TAB2 if a[i + 1] - a[i - 1] > 1 ;  $  TAB3 ans = max of ans and f[i - 1] + g[i + 1] + 1 ;  $  TAB2 else ;  $  TAB3 ans = max of ans and max(f[i - 1] + 1, g[i + 1] + 1) ;  $  TAB1 print ans ;
TAB0 a, dp1, dp2 = int array of size 100005 each ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 set a[0] to 0x3f3f3f3f ;  $  TAB1 set a[n + 1] to 0x3f3f3f3f ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 for i = 1 to n inclusive set dp1[i] and dp2[i] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] is greater than a[i - 1] then set dp1[i] to dp1[i - 1] + 1 ;  $  TAB2 set ans to max of ans and dp1[i] ;  $  TAB1 for i = n to 0 decrementing i ;  $  TAB2 if a[i] is less than a[i + 1] then set dp2[i] to dp2[i + 1] + 1 ;  $  TAB2 set ans to max of ans and dp2[i] ;  $  TAB1 for i = 2 to n inclusive set ans to max of ans and dp2[i] + 1 ;  $  TAB1 for i = 1 to n set ans to max of ans and dp1[i] + 1 ;  $  TAB1 for i = 2 to n ;  $  TAB2 if a[i + 1] - a[i - 1] is greater than 1 then set ans to max of ans and dp2[i + 1] + dp1[i - 1] + 1 ;  $  TAB1 print ans ;
TAB1 str = string array of size 12 ;  $  TAB1 n, i, j, ck = int ;  $  TAB1 read n then str[0] ;  $  TAB1 set str[1] to "vaporeon" ;  $  TAB1 set str[2] to "jolteon" ;  $  TAB1 set str[3] to "flareon" ;  $  TAB1 set str[4] to "espeon" ;  $  TAB1 set str[5] to "umbreon" ;  $  TAB1 set str[6] to "leafeon" ;  $  TAB1 set str[7] to "glaceon" ;  $  TAB1 set str[8] to "sylveon" ;  $  TAB1 for i = 1 to 8 inclusive ;  $  TAB2 if size of str[i] is n ;  $  TAB3 set ck to 1 ;  $  TAB3 for j = 0 to n ;  $  TAB4 if str[0][j] >= 'a' and str[0][j] <= 'z' ;  $  TAB5 if str[0][j] is not str[i][j] ;  $  TAB6 set ck to 0 ;  $  TAB6 break ;  $  TAB3 if ck is 1 ;  $  TAB4 print str[i] ;  $  TAB1 print newline ;
TAB1 let n be an integer ;  $  TAB1 read n ;  $  TAB1 define n number of pair pr with two integer elements ;  $  TAB1 for i= 0 to n exclusive , read ;  $  TAB1 sort pr, pr+n ;  $  TAB1 for j=0 to n-1 (exclusive) ;  $  TAB2 if first element of jth pair is less than j+1 th pair , and second element of jth pair is greater than j+1th pair, do the following ;  $  TAB3 print Happy Alex and a new line ;  $  TAB1 print Poor Alex and a new line ;
TAB1 t, a, b, h, p = int with h = 0 and p = 0 ;  $  TAB1 read t ;  $  TAB1 loop t times ;  $  TAB2 read a then b ;  $  TAB2 if a is not equal to b increment p ;  $  TAB1 if p is not equal 0 ;  $  TAB2 print "Happy Alex" ;  $  TAB1 else ;  $  TAB2 print "Poor Alex" ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create doubles x and y ;  $  TAB1 create double z ;  $  TAB1 double pointer *arr points to new array of doubles with size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x and y ;  $  TAB2 declare double variable q = x + (y / 100000) ;  $  TAB2 set value of arr[i] to q ;  $  TAB1 sort arr ;  $  TAB1 for integer i = 0 to n - 1 exclusive ;  $  TAB2 if arr[i] != arr[i + 1] ;  $  TAB3 if arr[i + 1] - arr[i] is less than 1 ;  $  TAB4 print "Happy Alex" ;  $  TAB1 print "Poor Alex" ;
TAB1 count, i, j, n = int with count = 0 and a, b = int array of size 100001 each ;  $  TAB1 read n ;  $  TAB1 read n values into a then b ;  $  TAB1 for j = 0 to n ;  $  TAB2 if a[j] is not b[j] ;  $  TAB3 print "Happy Alex" ;  $  TAB3 set count to 1 ;  $  TAB3 break loop ;  $  TAB1 if count is 0 then print "Poor Alex" ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create pair array of integer, integer pr with size n ;  $  TAB1 for i = 0 to n exclusive, read first element of pr[i] read second element of pr[i] ;  $  TAB1 sort elements from pr to pr + n ;  $  TAB1 for j = 0 to n - 1 exclusive ;  $  TAB2 if first element of pr[j] is less than first element of pr[j+1] and second element of pr[j] is greater than second element of pr[j+1] ;  $  TAB3 print "Happy Alex" print newline ;  $  TAB1 print "Poor Alex" print newline ;
TAB1 declare integer variables n, a and b ;  $  TAB1 read input to n ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 read a and b ;  $  TAB2 if a != b ;  $  TAB3 print "Happy Alex" ;  $  TAB1 print "Poor Alex" ;
TAB0 create constant double PI with PI = 3.14159265358979323846264338327 ;  $  TAB1 create strings a, b ;  $  TAB1 read a read b ;  $  TAB1 create integer vectors a1, b1 with a1 initialized with 100020, b1 initialized with 100020 ;  $  TAB1 for i = size of a - 1 to 0 inclusive, decrementing i, set a1[size of a - 1 - i ] to a[i] - '0' ;  $  TAB1 for i = size of b - 1 to 0 inclusive, decrementing i, set b1[size of b - 1 - i ] to b[i] - '0' ;  $  TAB1 for i = 100010 to 0 inclusive, decrementing i ;  $  TAB2 for j = i to a1[j] and a1[j+1], incrementing j by 2, set a1[j] to a1[j+1] to 0, set a1[j+2] to 1 ;  $  TAB2 for j = i to b1[j] and b1[j+1], incrementing j by 2, set b1[j] to b1[j+1] to 0, set b1[j+2] to 1 ;  $  TAB1 for i = 100010 to 0 inclusive, decrementing i ;  $  TAB2 if a1[i] is less than b1[i], return print '<' print newline, 0 from function ;  $  TAB2 if a1[i] is greater than b1[i], return print '>' print newline, 0 ;  $  TAB1 print '=' print newline ;
TAB0 create a map from integers to strings with name m ;  $  TAB0 create iterator it for map of int to strings ;  $  TAB1 s = array of characters of size 20 ;  $  TAB1 declare integer variable n ;  $  TAB1 m[0] = "January" ;  $  TAB1 m[1] = "February" ;  $  TAB1 m[2] = "March" ;  $  TAB1 m[3] = "April" ;  $  TAB1 m[4] = "May" ;  $  TAB1 m[5] = "June" ;  $  TAB1 m[6] = "July" ;  $  TAB1 m[7] = "August" ;  $  TAB1 m[8] = "September" ;  $  TAB1 m[9] = "October" ;  $  TAB1 m[10] = "November" ;  $  TAB1 m[11] = "December" ;  $  TAB1 while cin >> s >> n ;  $  TAB2 create integer j with value 0 ;  $  TAB2 move it through m from the beginning ;  $  TAB3 increment j ;  $  TAB3 if it->second = s. break ;  $  TAB2 print m[(j + n - 1) % 12] and a new line ;
TAB0 create map m from integer to string ;  $  TAB0 create map iterator it from integer to string ;  $  TAB1 create character array s with size 20 ;  $  TAB1 create integer n ;  $  TAB1 set m[0] to "January" ;  $  TAB1 set m[1] to "February" ;  $  TAB1 set m[2] to "March" ;  $  TAB1 set m[3] to "April" ;  $  TAB1 set m[4] to "May" ;  $  TAB1 set m[5] to "June" ;  $  TAB1 set m[6] to "July" ;  $  TAB1 set m[7] to "August" ;  $  TAB1 set m[8] to "September" ;  $  TAB1 set m[9] to "October" ;  $  TAB1 set m[10] to "November" ;  $  TAB1 set m[11] to "December" ;  $  TAB1 while read s read n ;  $  TAB2 create integer j with j = 0 ;  $  TAB2 for it = beginning of m to it is not end of m, incrementing it ;  $  TAB3 increment j ;  $  TAB3 if second element of it is s, break loop ;  $  TAB2 print m[(j + n - 1) % 12] print newline ;
TAB1 v is a vector of strings with 120 elements ;  $  TAB1 for integer i = 0 to 120 exclusive ;  $  TAB2 v[i] = "January" ;  $  TAB2 v[i + 1] = "February" ;  $  TAB2 v[i + 2] = "March" ;  $  TAB2 v[i + 3] = "April" ;  $  TAB2 v[i + 4] = "May" ;  $  TAB2 v[i + 5] = "June" ;  $  TAB2 v[i + 6] = "July" ;  $  TAB2 v[i + 7] = "August" ;  $  TAB2 v[i + 8] = "September" ;  $  TAB2 v[i + 9] = "October" ;  $  TAB2 v[i + 10] = "November" ;  $  TAB2 v[i + 11] = "December" ;  $  TAB1 x = string ;  $  TAB1 read x ;  $  TAB1 declare integers n and z ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 120 exclusive ;  $  TAB2 if v[i] = x ;  $  TAB3 assign value of i to the z ;  $  TAB3 break the loop ;  $  TAB1 print v[z + n] and a new line ;
TAB0 declare map from integer to string m ;  $  TAB0 declare map iterator from integer to string it ;  $  TAB1 declare character array s size 20 ;  $  TAB1 declare integer n ;  $  TAB1 let m[0] be "January" ;  $  TAB1 let m[1] be "February" ;  $  TAB1 let m[2] be "March" ;  $  TAB1 let m[3] be "April" ;  $  TAB1 let m[4] be "May" ;  $  TAB1 let m[5] be "June" ;  $  TAB1 let m[6] be "July" ;  $  TAB1 let m[7] be "August" ;  $  TAB1 let m[8] be "September" ;  $  TAB1 let m[9] be "October" ;  $  TAB1 let m[10] be "November" ;  $  TAB1 let m[11] be "December" ;  $  TAB1 while read s, n ;  $  TAB2 declare integer j = 0 ;  $  TAB2 for it = beginning of m to it is not end of m, incrementing it ;  $  TAB3 increment j ;  $  TAB3 if second element of it is s, end loop ;  $  TAB2 print m[(j + n - 1) % 12], newline ;
TAB1 declare integers n, m, a, b, rub, with rub = 0 ;  $  TAB1 read n, m, a and b ;  $  TAB1 while n is greater than 0 ;  $  TAB2 if n is less than m ;  $  TAB3 set integer flag to n * a ;  $  TAB3 if flag is less than b ;  $  TAB4 increase rub by flag ;  $  TAB4 n = 0 ;  $  TAB3 else ;  $  TAB4 increase rub by b ;  $  TAB4 decrease n by m ;  $  TAB2 else if (a * m) is greater than b ;  $  TAB3 decrease n by m ;  $  TAB3 increase rub by b ;  $  TAB2 else ;  $  TAB3 increase rub by n * a ;  $  TAB3 assign value of 0 to the n ;  $  TAB1 print rub and "\n" ;
TAB1 create integers n, m, a, b, r, d, cost with cost = 0 ;  $  TAB1 read n read m read a read b ;  $  TAB1 set r to n % m ;  $  TAB1 set d to n / m ;  $  TAB1 if m is greater than n ;  $  TAB2 if b is less than a * b ;  $  TAB3 print b print newline ;  $  TAB2 else ;  $  TAB3 print a * n print newline ;  $  TAB1 if d * b is less than a * ( n - r ) ;  $  TAB2 increment cost by d * b ;  $  TAB2 if r * a is less than b ;  $  TAB3 increment cost by r * a ;  $  TAB2 else ;  $  TAB3 increment cost by b ;  $  TAB1 else ;  $  TAB2 increment cost by a * n ;  $  TAB1 print cost print newline ;
TAB1 n, m, a, b =integers ;  $  TAB1 Read n, m, a, b ;  $  TAB1 x = integer, set to (n / m) * b + (n % m) * a ;  $  TAB1 y = integer, set to (n / m + 1) * b ;  $  TAB1 z = integer, set to n * a ;  $  TAB1 print minimum value of x and minimum value of y and z and a new line ;
TAB1 create integer TESTS with TESTS = 1 ;  $  TAB1 while decrementing TESTS is true ;  $  TAB2 create long longs n, m, a, b ;  $  TAB2 read n read m read a read b ;  $  TAB2 create long long integer vector v ;  $  TAB2 if b is greater than or equal to m * a ;  $  TAB3 read n * a read '\n' ;  $  TAB2 else ;  $  TAB3 create long long c with c = n / m ;  $  TAB3 create long long ans with ans = c * b ;  $  TAB3 decrement n by c * m ;  $  TAB3 increment ans by minimum of b and a * n ;  $  TAB3 print ans print '\n' ;
TAB1 n, m, a, b are long long ;  $  TAB1 read n,m,a,b ;  $  TAB1 if m*a < b ;  $  TAB2 print n*a ;  $  TAB1 else ;  $  TAB2 price = n/m*b + min(n modulo m * a, b) ;  $  TAB2 print price ;
TAB1 create integers n, m, a, b ;  $  TAB1 read n read m read a read b ;  $  TAB1 if m * a is greater than b ;  $  TAB2 print minimum of ( (n / m) * b + (n % m) * a and ((n / m) + 1) * b ) print newline ;  $  TAB1 print minimum of n * a and ((n / m) + 1) * b print newline ;
TAB1 create integers n, m ;  $  TAB1 create floats a, b ;  $  TAB1 read n read m read a read b ;  $  TAB1 create integer sum with sum = 0 ;  $  TAB1 if ( n % m ) * a is less than or equal to b ;  $  TAB2 increment sum by n / m * b + ( n % m ) * a ;  $  TAB1 else ;  $  TAB2 set sum to ( n / m + 1 ) * b ;  $  TAB1 if sum is greater than n * a, set sum to n * a ;  $  TAB1 print sum print newline ;
TAB1 create long long integers n, m, a , b ;  $  TAB1 read n read m read a read b ;  $  TAB1 if m * a is less than b ;  $  TAB2 print n * a print newline ;  $  TAB1 else ;  $  TAB2 create long long integer price with price = (n/m)*b+minimum of (n % m ) * b and b ;  $  TAB2 print price print newline ;
TAB1 declare long longs n, m, a and b ;  $  TAB1 read n, m, a and b ;  $  TAB1 if m * a is less than b ;  $  TAB2 print n * a and a new line ;  $  TAB1 else ;  $  TAB2 create variable price of type long long = (n / m) * b + min of (n % m) * a and b ;  $  TAB2 print price and a new line ;
TAB1 create integers m, n, a, b and cost ;  $  TAB1 read n, m, a and b ;  $  TAB1 if a is greater than b / m ;  $  TAB2 cost = (n / m) * b ;  $  TAB2 if a * (n % m) is less than b ;  $  TAB3 add a * (n % m) to cost ;  $  TAB2 else ;  $  TAB3 increase cost by b ;  $  TAB1 else ;  $  TAB2 cost = n * a ;  $  TAB1 print cost and a new line ;
TAB1 create integers n, m, a, b ;  $  TAB1 read n, m, a, b ;  $  TAB1 create integer sum with sum = a * n ;  $  TAB1 create integer msum with msum = b ;  $  TAB1 create integer rides with rides = m ;  $  TAB1 do the following while rides less than or equal to n ;  $  TAB2 add b to msum ;  $  TAB2 add m to rides ;  $  TAB1 subtract b from msum ;  $  TAB1 subtract m from rides ;  $  TAB1 if sum less than or equal to msum then do the following ;  $  TAB2 print sum and a new line ;  $  TAB1 else do the following ;  $  TAB2 if rides less than n ;  $  TAB3 create integer newsum with newsum = msum + (n - rides) * a ;  $  TAB3 add b to msum ;  $  TAB3 add m to rides ;  $  TAB3 create numsum1 with newsum1 = msum ;  $  TAB3 if newsum1 less than or equal to newsum then do the following ;  $  TAB4 print newsum1 and a new line ;  $  TAB3 else do the following ;  $  TAB4 print newsum and a new line ;  $  TAB2 else if rides greater than n then do the following ;  $  TAB3 create integer newsum with newsum = msum + (n - rides) * a ;  $  TAB3 add b to msum ;  $  TAB3 add m to rides ;  $  TAB3 create newsum1 with newsum1 = msum ;  $  TAB3 if newsum1 less than or equal to newsum then do the following ;  $  TAB4 print newsum1 and a new line ;  $  TAB3 else do the following ;  $  TAB4 print newsum and a new line ;  $  TAB2 else do the following ;  $  TAB3 print msum and a new line ;
TAB1 n and m = integers with m = 2 ;  $  TAB1 read n ;  $  TAB1 print m ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 increase m by i + 1 ;  $  TAB2 if m % n is equal to 0 ;  $  TAB3 print " " and n ;  $  TAB2 else ;  $  TAB3 print " " and m % n ;  $  TAB1 print new line ;
TAB1 create integers n, m with m = 2 ;  $  TAB1 read n ;  $  TAB1 print m ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 increment m by i + 1 ;  $  TAB2 if m % n is 0 ;  $  TAB3 print " " print n ;  $  TAB2 else ;  $  TAB3 print " " print m % n ;  $  TAB1 print newline ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 set integer cur to 0 ;  $  TAB1 for integer i = 1 to n exclusive ;  $  TAB2 if i is greater than 1 print whitespace ;  $  TAB2 increase cur by i ;  $  TAB2 set cur to remainder of division of cur by n ;  $  TAB2 print cur + 1 ;  $  TAB1 print new line ;
TAB1 create integers n, i, create integer array a with size 200 ;  $  TAB1 read n ;  $  TAB1 set a[0] to 1 ;  $  TAB1 for i = 1 to n - 1 inclusive ;  $  TAB2 set a[i] to (a[i - 1] + i) % n ;  $  TAB2 if a[i] is 0, set a[i] to n ;  $  TAB1 for i = 1 to n - 1 exclusive, print a[i] print " " ;  $  TAB1 print a[n-1] print newline ;
TAB1 integers n and i, integer array a of size 200 ;  $  TAB1 read n ;  $  TAB1 set value of a[0] to 1 ;  $  TAB1 for i = 1 to n - 1 inclusive ;  $  TAB2 a[i] = (a[i - 1] + i) % n ;  $  TAB2 set a[i] to n if a[i] is 0 ;  $  TAB1 for i = 1 to n - 1 exclusive print a[i] and " " ;  $  TAB1 print a[n - 1] and a new line ;
TAB0 mp = map from long long to long long ;  $  TAB0 declare vector of strings called s ;  $  TAB0 declare vector of integers called v ;  $  TAB1 declare integer variable m ;  $  TAB1 read m ;  $  TAB1 let k, i and j be integers with k = m, i = 1 and j = 1 ;  $  TAB1 decrease m by one ;  $  TAB1 while m-- ;  $  TAB2 increase j by i ;  $  TAB2 integer ans = j % k ;  $  TAB2 if ans is equal to 0 set ans to j ;  $  TAB2 print ans ;  $  TAB2 if m is equal to 0 ;  $  TAB3 print new line ;  $  TAB2 else ;  $  TAB3 print " " ;  $  TAB2 increase i by one ;  $  TAB2 j %= k ;  $  TAB2 if j is equal to 0, set j to ans ;
TAB1 declare integer vector v initialized with 6 ;  $  TAB1 read v[0], v[1], v[2], v[3], [4], v[5] ;  $  TAB1 sort from beginning of v to end of v ;  $  TAB1 declare integers h, b ;  $  TAB1 if v[0] is v[3] ;  $  TAB2 let h be 4 ;  $  TAB2 let b be 5 ;  $  TAB1 else if v[1] is v[4] ;  $  TAB2 let h be 0 ;  $  TAB2 let b be 5 ;  $  TAB1 else if v[2] is v[5] ;  $  TAB2 let h be 0 ;  $  TAB2 let b be 1 ;  $  TAB1 else ;  $  TAB2 print "Alien\n" ;  $  TAB1 print "Bear\n" if v[h] is less than v[b], else "Elephant\n" ;
TAB0 declare const int INF = 0x3f3f3f3f ;  $  TAB0 create int array a with size 11 ;  $  TAB1 declare integer variables n, m and t ;  $  TAB1 declare integer variables i, j and k ;  $  TAB1 for i = 0 to 6 exclusive, read t and increment a[t] ;  $  TAB1 for i = 1 to 9 inclusive ;  $  TAB2 if a[i] >= 4, break ;  $  TAB1 if i is greater than 9 ;  $  TAB2 print "Alien" ;  $  TAB1 for i from 1 to 9 inclusive ;  $  TAB2 if a[i] = 2 or a[i] = 6, stop the loop ;  $  TAB1 if i is greater than 9 ;  $  TAB2 print "Bear" ;  $  TAB1 print "Elephant" ;
TAB0 declare new array of integers a with size 10 ;  $  TAB1 create new integer variable x ;  $  TAB1 for i from 1 to 6 inclusive incrementing i ;  $  TAB2 read variable x from the input ;  $  TAB2 increment a[x] ;  $  TAB1 declare new ints y and z = -1 ;  $  TAB1 start for loop from i = 1 to 9 inclusive ;  $  TAB2 if a[i] >= 4, assign i to z ;  $  TAB1 if z is not -1 ;  $  TAB2 assign a[z] - 4 to a[z] ;  $  TAB2 for i = 1 to 9 inclusive ;  $  TAB3 if a[i] is equal to 1 and y = -1, change y to i ;  $  TAB3 if a[i] = 1 and y is not -1, set z to i ;  $  TAB3 if a[i] is equal to 2, change y to set z to a[i] ;  $  TAB2 if y is equal to z ;  $  TAB3 print "Elephant" ;  $  TAB2 else ;  $  TAB3 print "Bear" to the standard output ;  $  TAB1 else ;  $  TAB2 print "Alien" ;
TAB1 create integers i, j, n, p, q, flag with p = 0, flag = 0, create integer array a with size 10 with a = {0} ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 read n ;  $  TAB2 increment a[n] ;  $  TAB1 for i = 0 to 9 inclusive ;  $  TAB2 if a[i] is greater than or equal to 4 ;  $  TAB3 decrement a[i] by 4 ;  $  TAB3 set flag to 1 ;  $  TAB1 if flag is 0 ;  $  TAB2 print "Alien" print newline ;  $  TAB1 for i = 0 to 9 inclusive ;  $  TAB2 if a[i] is 2 ;  $  TAB3 print "Elephant" print newline ;  $  TAB1 print "Bear" print newline ;
TAB0 ar = int array of size 12 ;  $  TAB1 a, b, c, d, e, f = int ;  $  TAB1 read a then b then c then d then e then f ;  $  TAB1 increment ar[a] ;  $  TAB1 increment ar[b] ;  $  TAB1 increment ar[c] ;  $  TAB1 increment ar[d] ;  $  TAB1 increment ar[e] ;  $  TAB1 increment ar[f] ;  $  TAB1 paichi = bool with paichi = false ;  $  TAB1 for i = 1 to 9 inclusive ;  $  TAB2 if ar[i] >= 4 set paichi to true ;  $  TAB1 if not paichi print "Alien" and return 0 ;  $  TAB1 cnt = int with cnt = 0 ;  $  TAB1 for i = 1 to 9 inclusive ;  $  TAB2 if ar[i] is 2 or 6 print "Elephant" and return 0 ;  $  TAB1 print "Bear" ;
TAB1 create integer A with size 6 ;  $  TAB1 for i = 0 to 6 exclusive, read A[i] ;  $  TAB1 sort elements from A to A + 6 ;  $  TAB1 create integers B, C ;  $  TAB1 if A[0] is A[3] ;  $  TAB2 set B to A[4], set C to A[5] ;  $  TAB1 else if A[1] is A[4] ;  $  TAB2 set B to A[0], set C to A[5] ;  $  TAB1 else if A[2] is A[5] ;  $  TAB2 set B to A[0], set C to A[1] ;  $  TAB1 else ;  $  TAB2 print "Alien" print newline ;  $  TAB1 if B is C ;  $  TAB2 print "Elephant" print newline ;  $  TAB1 if B is less than C ;  $  TAB2 print "Bear" print newline ;
TAB0 dp = two dimensional char array of sizes 10 and 10 ;  $  TAB0 mp = long long and long long map ;  $  TAB1 n, x = long long ;  $  TAB1 a = long long array of size 10 ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 read a[i] ;  $  TAB2 increment mp[a[i]] ;  $  TAB1 ok = bool with ok = false ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 if mp[a[i]] is 6 set ok to true ;  $  TAB1 if ok is true ;  $  TAB2 print "Elephant" ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 if mp[a[i]] is 5 set ok to true ;  $  TAB1 if ok is true ;  $  TAB2 print "Bear" ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 if mp[a[i]] is 4 set ok to true ;  $  TAB1 if ok is false ;  $  TAB2 print "Alien" ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 if mp[a[i]] is 2 set ok to false ;  $  TAB1 if ok is true ;  $  TAB2 print "Bear" ;  $  TAB1 else ;  $  TAB2 print "Elephant" ;
TAB0 declare int arrays b with size 10 and c with size 6 ;  $  TAB1 declare an array of integers a with size 6 and integer variables i, x and j with j = 0 ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 read a[i] ;  $  TAB2 assign a[i] to x ;  $  TAB2 increment b[x] by one ;  $  TAB1 for i = 1 to 9 inclusive ;  $  TAB2 if b[i] != 0 ;  $  TAB3 set c[j] to b[i] ;  $  TAB3 increment j by one ;  $  TAB1 sort first 3 elements of c ;  $  TAB1 if c[0] = 1 and c[1] = 1 and c[2] = 4 ;  $  TAB2 print "Bear" ;  $  TAB1 else if c[0] = 0 and c[1] = 1 and c[2] = 5 ;  $  TAB2 print "Bear" ;  $  TAB1 else if c[0] = 0 and c[1] = 2 and c[2] = 4 ;  $  TAB2 print "Elephant" ;  $  TAB1 else if c[2] is equal to 6 ;  $  TAB2 print "Elephant" ;  $  TAB1 else ;  $  TAB2 print "Alien" ;
TAB1 create integers i, j, n, p, q, flag, with p = 0, flag = 0, create integer array a with size 10 with a = {0} ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 read n ;  $  TAB2 increment a[n] ;  $  TAB1 for i = 0 to 9 inclusive ;  $  TAB2 if a[i] is greater than or equal to 4 ;  $  TAB3 decrement a[i] by 4 ;  $  TAB3 set flag to 1 ;  $  TAB1 if flag is 0 ;  $  TAB2 print "Alien" print newline ;  $  TAB1 for i = 0 to 9 inclusive ;  $  TAB2 if a[i] is 2 ;  $  TAB3 print "Elephant" print newline ;  $  TAB1 print "Bear" print newline ;
TAB1 declare integer array list size 10 ;  $  TAB1 set bytes from list to size of list to value 0 ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 declare temp as integer ;  $  TAB2 read temp ;  $  TAB2 increment list[temp] ;  $  TAB1 for i = 0 to 10 exclusive ;  $  TAB2 if list[i] is 4 ;  $  TAB3 for j = 0 to 10 exclusive ;  $  TAB4 if list[j] is 2 ;  $  TAB5 print "Elephant", newline ;  $  TAB3 print "Bear", newline ;  $  TAB2 else if list[i] is 5 ;  $  TAB3 print "Bear", newline ;  $  TAB2 else if list[i] is 6 ;  $  TAB3 print "Elephant", newline ;  $  TAB1 print "Alien", newline ;
TAB0 create integer array mp with size 20 ;  $  TAB1 create integer n ;  $  TAB1 create integer vector Q ;  $  TAB1 set bytes from mp to size of mp to value 0 ;  $  TAB1 for i = 1 to 6 inclusive ;  $  TAB2 create integer p ;  $  TAB2 read p ;  $  TAB2 increment mp[p] ;  $  TAB2 add character p to end of Q ;  $  TAB1 create integers flag1, flag2 with flag1 = 0, flag2 = 0 ;  $  TAB1 for i = 0 to size of Q exclusive ;  $  TAB2 if mp[Q[i]] is greater than or equal to 4, set flag1 to 1 ;  $  TAB2 if mp[Q[i]] is 2, set flag2 to 1 ;  $  TAB2 if mp[Q[i]] is 6 ;  $  TAB3 set flag1 to 1 ;  $  TAB3 set flag2 to 1 ;  $  TAB1 if flag1 is 1 and flag2 is 0 ;  $  TAB2 print "Bear\n" ;  $  TAB1 else if flag1 is 1 and flag2 is 1 ;  $  TAB2 print "Elephant\n" ;  $  TAB1 else ;  $  TAB2 print "Alien\n" ;
TAB0 a, b, n = int and s = int array of size 10 ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 read n ;  $  TAB2 increment s[n] ;  $  TAB1 for i = 0 to 10 ;  $  TAB2 if s[i] is greater or equal to 4 set b to 1 ;  $  TAB2 if s[i] is 2 or 6 set a to 1 ;  $  TAB1 if b is 0 ;  $  TAB2 print "Alien" ;  $  TAB1 else if a is 1 ;  $  TAB2 print "Elephant" ;  $  TAB1 else ;  $  TAB2 print "Bear" ;
TAB1 l, r = long long ;  $  TAB1 read l then r ;  $  TAB1 if r - l is greater than 1 ;  $  TAB2 if l is even ;  $  TAB3 print l then ' ' then l + 1 then ' ' then l + 2 ;  $  TAB2 else ;  $  TAB3 if r - l is greater than 2 ;  $  TAB4 print l + 1 then ' ' then l + 2 then ' ' then l + 3 ;  $  TAB3 else ;  $  TAB4 print -1 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 create long long l and r ;  $  TAB1 read l and r ;  $  TAB1 if r - l + 1 less than 3 ;  $  TAB2 print -1 ;  $  TAB1 if l is odd ;  $  TAB2 print l, ' ', l+1, ' ', l+2 ;  $  TAB1 if r - l + 1 greater than 3 ;  $  TAB2 print l+1, ' ', l+2, ' ', l+3 ;  $  TAB1 print -1 and a newline ;
TAB0 create long long l and r ;  $  TAB1 read l, r ;  $  TAB1 if r - l + 1 < 3 ;  $  TAB2 print -1 ;  $  TAB1 if l is even ;  $  TAB2 print l, " ", l+1, " ", l+2 ;  $  TAB1 if r - l + 1 greater than 3 ;  $  TAB2 print l + 1, " ", l + 2, " ", l + 3 ;  $  TAB1 print -1 and a newline ;
TAB1 create integer long longs l, r ;  $  TAB1 read l read r ;  $  TAB1 if l % 2 is not 0, increment l ;  $  TAB1 if l + 2 is greater than r ;  $  TAB2 print -1 print newline ;  $  TAB1 else ;  $  TAB2 print l print " " print l + 1 print " " print l + 2 print newline ;
TAB1 declare long long variables k and l ;  $  TAB1 read k and l and keep looping ;  $  TAB2 if l - k is less than 2 ;  $  TAB3 print - 1 ;  $  TAB2 else if k is even ;  $  TAB3 print k, " ", k + 1, " " and k + 2 ;  $  TAB2 else if k is odd && l - k >= 3 ;  $  TAB3 print k + 1, " ", k + 2, " " and k + 3 ;  $  TAB2 else ;  $  TAB3 print -1 ;
TAB1 create long longs n, m ;  $  TAB1 read n read m ;  $  TAB1 if m - n is less than 2 ;  $  TAB2 print -1 print newline ;  $  TAB1 else ;  $  TAB2 if n % 2 is 0 ;  $  TAB3 print n print " " print n + 1 print " " print n + 2 print newline ;  $  TAB2 else if n % 2 is not 0 and n + 3 is less than or equal to m ;  $  TAB3 print n + 1 print " " print n + 2 print " " print n + 3 print newline ;  $  TAB2 else ;  $  TAB3 print -1 print newline ;
TAB1 a, b = long long integer ;  $  TAB1 read a, b ;  $  TAB1 if a modulo 2 is 0 and a + 2 <= b ;  $  TAB2 print a," ",a + 1," ",a + 2 ;  $  TAB1 else if a modulo 2 is not 0 and a + 3 <= b ;  $  TAB2 print a + 1," ",a + 2," ",a + 3 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 create long long l and r ;  $  TAB1 read l and r ;  $  TAB1 if r - l + 1 < 3 ;  $  TAB2 read -1 ;  $  TAB1 if r - l + 1 = 3 and r mod 2 different from 0 or l mod 2 different from 0 ;  $  TAB2 print -1 ;  $  TAB1 if l is even and l + 2 is even ;  $  TAB2 print l, " ", l + 1, " ", l + 2 ;  $  TAB1 else ;  $  TAB2 print l + 1, " ", l + 2, " ", l + 3 ;
TAB1 l, r = long long ;  $  TAB1 read l, r ;  $  TAB1 if r - l + 1 < 3 ;  $  TAB2 print -1 ;  $  TAB1 if l modulo 2 is 0 ;  $  TAB2 print l,' ',l + 1,' ',l + 2 ;  $  TAB1 if r - l + 1 > 3 ;  $  TAB2 print l + 1,' ',l + 2,' ',l + 3 ;  $  TAB1 print -1 ;
TAB1 create long long n1 and n2 ;  $  TAB1 read n1, n2 ;  $  TAB1 if n1 is odd, increase n1 ;  $  TAB1 if n2 - n1 less than 2 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print n1, " ", n1+1, " ", n1+2 ;
TAB1 let l, r be long integers ;  $  TAB1 read l and r ;  $  TAB1 if r - l is less than 2 ;  $  TAB2 print -1 and newline ;  $  TAB1 else if r - l is equal to 2 ;  $  TAB2 if r modulo 2 ;  $  TAB3 print -1 and newline ;  $  TAB2 else do the following ;  $  TAB3 print l and space and l + 1 and space and r and newline ;  $  TAB1 else do the following ;  $  TAB2 if l modulo 2 ;  $  TAB3 print l + 1 and space and l + 2 and space and l + 3 and newline ;  $  TAB2 else do the following ;  $  TAB3 print l and space and l + 1 and space and l + 2 and newline ;
TAB1 create long long l and r ;  $  TAB1 read l and r ;  $  TAB1 is l is even and l + 2 <= r ;  $  TAB2 print l, " ", l + 1, " ", l + 2 ;  $  TAB1 else ;  $  TAB2 l + 3 <= r ;  $  TAB3 print l+1, " ", l + 2, " ", l + 3 ;  $  TAB2 else ;  $  TAB3 print -1 and a newline ;
TAB1 n, res = integer with res = 0 ;  $  TAB1 read n ;  $  TAB1 total = integer with total = 0 ;  $  TAB1 while total < n ;  $  TAB2 increment res ;  $  TAB2 total = total + res * (res + 1) / 2 ;  $  TAB1 if total > n, decrement res ;  $  TAB1 print res ;
TAB1 create ints n, i, j, x, and mohi ;  $  TAB1 create long long int sum = 0 ;  $  TAB1 create integer vector v ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n ;  $  TAB2 for j = 1 to i ;  $  TAB3 set mohi to (j * (j + 1)) / 2 ;  $  TAB3 set sum to sum + mohi ;  $  TAB2 if sum is less than n ;  $  TAB3 set x to i ;  $  TAB3 break loop ;  $  TAB2 set sum to 0 ;  $  TAB1 if n is equal to 1 ;  $  TAB2 print 1 ;  $  TAB1 otherwise ;  $  TAB2 print x - 1 ;
TAB1 n,ans,sum,sum2=int ;  $  TAB1 while read n ;  $  TAB2 ans, sum, sum2=0 ;  $  TAB2 while true ;  $  TAB3 if sum2>n break ;  $  TAB3 increment ans ;  $  TAB3 add ans to sum ;  $  TAB3 add sum to sum2 ;  $  TAB2 print ans-1 ;
TAB0 int function Addition with int argument n ;  $  TAB1 declare new integer s ;  $  TAB1 set s to (n * (1 + n)) / 2 ;  $  TAB1 return s ;  $  TAB1 a and i are integers with i = 0 ;  $  TAB1 read input to a ;  $  TAB1 if a is greater than 0 ;  $  TAB2 change a to a - the result of Addition(i) ;  $  TAB2 while a > 0 ;  $  TAB3 increment i ;  $  TAB3 assign a - the result of Addition(i + 1) to a ;  $  TAB2 print i to the standard output ;  $  TAB1 else ;  $  TAB2 print "0" to the standard output ;
TAB1 n, a, b = integers with a = 0, b = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 a = a + i ;  $  TAB2 n = n - a ;  $  TAB2 if n >= 0, increment b ;  $  TAB1 print b ;
TAB1 declare integer array a with size 151; create integers sum and sum1 where sum1 = 0 ;  $  TAB1 read variable sum from the input ;  $  TAB1 in the for loop, change i from 1 to 150 inclusive ;  $  TAB2 set a[i] to (1 + i) * i / 2 ;  $  TAB2 increase sum1 by a[i] ;  $  TAB2 set a[i + 1] to (2 + i) * (i + 1) / 2 ;  $  TAB2 if sum >= sum1 and sum < sum1 + a[i + 1] ;  $  TAB3 print i to the standard output ;  $  TAB3 break the loop ;
TAB1 n = integer, s = integer = 0 ;  $  TAB1 read n ;  $  TAB1 loop indefinitely for i = 1 and increase i at the end of the loop ;  $  TAB2 if s > n ;  $  TAB3 print the result of i - 2 ;  $  TAB3 exit the for loop ;  $  TAB2 else ;  $  TAB3 s = s + (i * (i + 1)) / 2 ;
TAB1 var, n, aux, x = int with var = 1 and aux = 0 and x = 0 ;  $  TAB1 read n ;  $  TAB1 level = int with level = 0 ;  $  TAB1 loop infinitely ;  $  TAB2 increment x by var ;  $  TAB2 increment aux by x ;  $  TAB2 if aux > n break ;  $  TAB2 increment level ;  $  TAB2 increment var ;  $  TAB1 print level ;
TAB0 create constant int INF = 1e9 ;  $  TAB0 let const integer N = 1e5 ;  $  TAB0 let int array arr of size 10001 ;  $  TAB0 declare prework ;  $  TAB1 set arr[0] to 0 ;  $  TAB1 for i = 1 to 10000, set arr[i] to arr[i - 1] + i ;  $  TAB1 call prework ;  $  TAB1 let ints n and cnt = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1, loop indefinitely ;  $  TAB2 if n is less than arr[i], break loop ;  $  TAB2 set n to n - arr[i] ;  $  TAB2 increment cnt ;  $  TAB1 print cnt ;
TAB1 create ints n, c = 0, d, and count = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n ;  $  TAB2 set c to c + 1 ;  $  TAB2 if n is greater than or equal to c, increment count ;  $  TAB2 set n to n - c ;  $  TAB1 print count ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 h = int with h = 1 ;  $  TAB1 temp = int with temp = ((h) * (h + 1) * (h + 2)) / 6 ;  $  TAB1 loop while temp <= n ;  $  TAB2 increment h ;  $  TAB2 set temp to ((h) * (h + 1) * (h + 2)) / 6 ;  $  TAB1 print h - 1 ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 val, ans = long long with val = 0 and ans = 0 ;  $  TAB1 for i = 0 to 10001 ;  $  TAB2 increment val by i ;  $  TAB2 increment ans by val ;  $  TAB2 if ans > n ;  $  TAB3 print i - 1 ;
TAB0 in function sum taking an int n and returning an int ;  $  TAB1 s = int with s = (n * (n + 1)) / 2 ;  $  TAB1 return s ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 i = int with i = 0 ;  $  TAB1 s = int with s = 0 ;  $  TAB1 loop infinitely ;  $  TAB2 increment s by sum of i ;  $  TAB2 if s > n ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 increment i ;  $  TAB1 print i - 1 ;
TAB1 n, count = int with count = 0 ;  $  TAB1 read n ;  $  TAB1 flag, i, x = int with flag = 0 and i = 2 and x = 1 ;  $  TAB1 loop while flag <= n ;  $  TAB2 increment flag by x ;  $  TAB2 increment x by i ;  $  TAB2 increment i ;  $  TAB2 if flag <= n increment count ;  $  TAB1 print count ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 tot, ans = int with tot = 0 and ans = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 increment tot by i * (i + 1) / 2 ;  $  TAB2 if tot > n break ;  $  TAB2 set ans to i ;  $  TAB1 print ans ;
TAB1 n=long long, x, count and boxes=0 ;  $  TAB1 read n ;  $  TAB1 i=1 ;  $  TAB1 j=1 ;  $  TAB1 while boxes+i+x <= n ;  $  TAB2 add i to x ;  $  TAB2 add j to i ;  $  TAB2 increment count ;  $  TAB2 add x to boxes ;  $  TAB1 print count ;
TAB1 let i, n, k be integers ;  $  TAB1 while read n ;  $  TAB2 k is equal to 0 ;  $  TAB2 for i is equal to 1, n >= 0 , increment i by 1 ;  $  TAB3 increment k by i ;  $  TAB3 decrement n by k ;  $  TAB2 print i - 2 and newline ;
TAB0 a = array of integers of length 10010 ;  $  TAB1 1st element in a is equal to 1 ;  $  TAB1 let sum, m be long integers ;  $  TAB1 for i = 2 to 10000 inclusive , the value of a[i] is equal to a[i - 1] + i ;  $  TAB1 while reading m ;  $  TAB2 for i = 1 to 10000 inclusive ;  $  TAB3 decrement m by a[i] ;  $  TAB3 if m is less than a[i + 1] ;  $  TAB4 print i and newline ;  $  TAB4 stop ;
TAB0 declare integer vector sol ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integer sum = 0 ;  $  TAB1 for i = 1 to 150 inclusive ;  $  TAB2 if sum is greater than n ;  $  TAB3 print i - 2, newline ;  $  TAB2 increment sum by ((i * (i + 1)) / 2) ;
TAB0 create int array a of length 10010 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 for i=1 to 10000 inclusive set a[i] = a[i - 1] + i ;  $  TAB1 create int n ;  $  TAB1 while read n ;  $  TAB2 ans =0 ;  $  TAB2 loop over i starting from i=1 ;  $  TAB3 if n >= a[i] ;  $  TAB4 set n to n - a[i], increment ans ;  $  TAB3 else ;  $  TAB4 break ;  $  TAB2 print ans ;
TAB1 n, i, l, s = long long integer with s = 0 ;  $  TAB1 read n ;  $  TAB1 for l = 0 ;  $  TAB2 s = s + l * (l + 1) / 2 ;  $  TAB2 if s > n, break loop ;  $  TAB1 print l - 1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int ans, t and q, set ans to 0 and t, q to 1 ;  $  TAB1 ans = ans + t ;  $  TAB1 while n >= ans ;  $  TAB2 increment q ;  $  TAB2 set t to t + q ;  $  TAB2 assign ans + t to ans ;  $  TAB1 print q - 1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int a, c, b and i, set a, c and b to 0 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 set b to (i * (i + 1)) / 2 ;  $  TAB2 set a to a + b ;  $  TAB2 if a > n, break ;  $  TAB2 increment c ;  $  TAB1 print c ;
TAB0 create ints n and c ;  $  TAB1 read n ;  $  TAB1 for c = 1, loop as long as c * (c + 1) * (c + 2) / 6 <= n ;  $  TAB2 end statement ;  $  TAB1 print c - 1 ;
TAB1 let n be an integer ;  $  TAB1 get input in n ;  $  TAB1 let i = 2 = int ;  $  TAB1 while n - i * (i + 1) / 2 is positive ;  $  TAB2 decrement n by i * (i + 1) / 2 ;  $  TAB2 increment i ;  $  TAB1 print i-1 ;
TAB0 a is a new array of integers with size 10010 ;  $  TAB1 set a[1] to 1 ;  $  TAB1 declare new long long int variables sum and m ;  $  TAB1 for i from 2 to 10000 inclusive, change a[i] to a[i - 1] + i ;  $  TAB1 read m and loop further ;  $  TAB2 start for loop from i = 1 to 10000 inclusive incrementing i ;  $  TAB3 decrease m by a[i] ;  $  TAB3 if m is less than a[i + 1] ;  $  TAB4 print i ;  $  TAB4 break the loop ;
TAB1 n = int ;  $  TAB1 a = int with a = 0 ;  $  TAB1 b = int with b = 1 ;  $  TAB1 c = int with c = 0 ;  $  TAB1 read n ;  $  TAB1 loop infinitely ;  $  TAB2 for i = 1 to b inclusive increment a by i ;  $  TAB2 increment b ;  $  TAB2 if a > n break ;  $  TAB2 increment c ;  $  TAB1 print c ;
TAB1 n, r, t = int with r = 0 and t = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 ;  $  TAB2 increment r by i ;  $  TAB2 increment t by r ;  $  TAB2 if t > n ;  $  TAB3 print i - 1 ;  $  TAB3 break ;
TAB1 let int n ;  $  TAB1 read n and while n is truthy ;  $  TAB2 let long long int sum = 0 ;  $  TAB2 let int i ;  $  TAB2 for i = 1 loop indefinitely ;  $  TAB3 make long long current = 1LL * i * (i + 1) / 2 ;  $  TAB3 if sum + current is less than or equal to n ;  $  TAB4 set n to n - sum + current ;  $  TAB3 else do ;  $  TAB4 break loop ;  $  TAB2 print i - 1 ;
TAB0 cube = long long ;  $  TAB1 res = long long ;  $  TAB1 read cube ;  $  TAB1 for i = 0 loop while i * (i + 1) * ( i + 2) <= 6 * cube set res to i ;  $  TAB1 print res ;
TAB0 declare need with integer a as argument, returning integer ;  $  TAB1 declare b as integer = 0 ;  $  TAB1 for i = 1 to a inclusive, increment b by i ;  $  TAB1 return b from function ;  $  TAB1 declare integer a ;  $  TAB1 read a ;  $  TAB1 declare integer i with i = 0 ;  $  TAB1 while a is greater than or equal to result of run need with i as argument ;  $  TAB2 decrement a by need(1) ;  $  TAB2 increment i ;  $  TAB1 print i - 1 print newline ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 sum, i, b = int ;  $  TAB1 set sum, b, i to 1 ;  $  TAB1 loop infinitely ;  $  TAB2 if sum is n ;  $  TAB3 print i ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 if sum > n ;  $  TAB4 print i - 1 ;  $  TAB4 break ;  $  TAB3 else ;  $  TAB4 increment i ;  $  TAB4 increment b by i ;  $  TAB4 increment sum by b ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 sum and height=0 ;  $  TAB1 while sum <= n ;  $  TAB2 increment height ;  $  TAB2 add height*(height+1)/2 to sum ;  $  TAB1 print height-1 ;
TAB1 let n, sum, level be integers ;  $  TAB1 while read n ;  $  TAB2 if n is equal to 1 ;  $  TAB3 print 1 and newline ;  $  TAB3 proceed to next ;  $  TAB2 sum is equal to 1, level is equal to 1 ;  $  TAB2 for integer i is equal to 2 , the condition is always true, increment i by 1 ;  $  TAB3 increment level by i ;  $  TAB3 increment sum by level ;  $  TAB3 if sum is equal to n ;  $  TAB4 print i and newline ;  $  TAB4 stop ;  $  TAB3 else if sum is greater than n ;  $  TAB4 print i - 1 and newline ;  $  TAB4 stop ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 if n<4 ;  $  TAB2 print 1 ;  $  TAB1 cnt=0, m=1, i=1, sum=0 ;  $  TAB1 while sum+i <= n ;  $  TAB2 addi to sum ;  $  TAB2 increment cnt ;  $  TAB2 increment m ;  $  TAB2 add m to i ;  $  TAB1 print cnt ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB2 the 1000th element of sum1 is equal to 0 ;  $  TAB2 the 1000th element of sum2 is equal to 1 ;  $  TAB2 let sum be a integer with sum = 0 ;  $  TAB2 for i = 1 to 50 exclusive ;  $  TAB3 increment sum by i ;  $  TAB3 sum1[i - 1] is equal to sum ;  $  TAB3 sum1[i] is equal to sum1[i - 1] + i + 1 ;  $  TAB3 sum2[i] is equal to sum2[i - 1] + sum1[i] ;  $  TAB3 if sum2[i - 1] <= n and sum2[i] is greater than n, print i and newline ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integer cont = 0 ;  $  TAB1 declare integer sumador = 1 ;  $  TAB1 declare i = 1 as integer ;  $  TAB1 while n is greater than 0 and n is greater than or equal to sumador ;  $  TAB2 let n be n - sumador ;  $  TAB2 increment cont ;  $  TAB2 increment i ;  $  TAB2 let sumador = sumador + 1 ;  $  TAB1 print cont, "\n" ;
TAB0 declare int variables n and i ;  $  TAB1 read user input to n ;  $  TAB1 for i from 1 to 40 inclusive incrementing i ;  $  TAB2 if i * (i + 1) * (i + 2) / 6 is greater than n, stop the loop ;  $  TAB1 print i - 1 to the standard output ;
TAB1 declare integers n, tmp = 0, hitung = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 increment hitung by ((i * (i + 1)) / 2) ;  $  TAB2 if hitung is n ;  $  TAB3 set tmp to i ;  $  TAB3 break loop ;  $  TAB2 else if hitung is greater than n ;  $  TAB3 set tmp to i - 1 ;  $  TAB3 break loop ;  $  TAB1 print tmp, newline ;
TAB0 create integer length = 1e5 ;  $  TAB1 let ints n, i, and sum = 0 ;  $  TAB1 read n ;  $  TAB1 create int vector a of size n + 1 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 for i = 1 to n, set a[i] to a[i - 1] + i ;  $  TAB1 for i = 1 until sum <= n and i <= n are false, set sum to sum + a[i] ;  $  TAB1 if n is equal to 1, increase 1 by 1 ;  $  TAB1 print the result of i - 2 ;
TAB1 declare new integer variable n ;  $  TAB1 read n and keep looping ;  $  TAB2 declare new long long variable sum with value 0 ;  $  TAB2 declare new integer called i ;  $  TAB2 set i to 1 and increment it in a for loop ;  $  TAB3 declare new long long variable current with value 1LL * i * (i + 1) / 2 ;  $  TAB3 if sum + current <= n ;  $  TAB4 subtract sum + current from n ;  $  TAB3 else ;  $  TAB4 break the loop ;  $  TAB2 print i - 1 to the standard output ;
TAB1 create integer n ;  $  TAB1 while get n do the following till valid input ;  $  TAB2 create long long sum, prev, x and set them to 0 ;  $  TAB2 for integer i=1 to n with increment i ;  $  TAB3 add sum to prev ;  $  TAB3 add i to sum ;  $  TAB3 if sum+prev less than or equal to n ;  $  TAB4 increment x ;  $  TAB3 else do the following ;  $  TAB4 break the loop ;  $  TAB2 print x ;
TAB0 in function inum taking pointer to an int a, int k, int i returning int ;  $  TAB1 for l = 1 to k ;  $  TAB2 if a[l - 1] is not 1 ;  $  TAB3 set a[l] to a[l - 1] + (l + 1) ;  $  TAB2 else ;  $  TAB3 set a[l] to (inum of a, l, i) + l + 1 ;  $  TAB1 return value of (a + (k - 1)) ;  $  TAB0 in function isum taking int i returning int ;  $  TAB1 arr, a = int array of size i each ;  $  TAB1 set arr[i] to -1 ;  $  TAB1 set a[i] to -1 ;  $  TAB1 set a[0] to 1 ;  $  TAB1 set arr[0] to 1 ;  $  TAB1 if i is 1 ;  $  TAB2 return i ;  $  TAB1 else ;  $  TAB2 j = int with j = 1 ;  $  TAB2 for j to i ;  $  TAB3 if arr[j - 1] is not -1 ;  $  TAB4 set arr[j] to arr[j - 1] + inum of a, j + 1, i ;  $  TAB3 else ;  $  TAB4 set arr[j] to isnum of j + j + 1 ;  $  TAB1 return value of arr + (i - 1) ;  $  TAB1 n, i = int with i = 1 ;  $  TAB1 read n ;  $  TAB1 loop while isnum of i <= n increment i ;  $  TAB1 print i - 1 ;
TAB1 declare n, cnt, sum, ans, i as long long integers ;  $  TAB1 read n ;  $  TAB1 let cnt be 0, ans be 0, sum be 0 ;  $  TAB1 for i = 1 to 10000 inclusive ;  $  TAB2 increment ans by i ;  $  TAB2 increment sum by ans ;  $  TAB2 if sum is greater than n, break loop ;  $  TAB2 increment cnt ;  $  TAB1 print cnt print newline ;
TAB1 create integer n ;  $  TAB1 create integer array a with dimension 100 ;  $  TAB1 while get n do till valid input ;  $  TAB2 create integer i, sum with i=2, sum=0 ;  $  TAB2 create integer cs with cs=0 ;  $  TAB2 set a[1] to 1 ;  $  TAB2 for integer i=2 with increment i till sum less than n ;  $  TAB3 set a[i] to i + a[i-1] ;  $  TAB3 add a[i] to sum ;  $  TAB3 set cs to i-1 ;  $  TAB2 print cs ;
TAB1 create integer variables n, i and l with i and l = 0 ;  $  TAB1 read standard input to n ;  $  TAB1 while l <= n ;  $  TAB2 increment i by one ;  $  TAB2 change l to sum of l and (i * (i + 1)) / 2 ;  $  TAB1 print i - 1 ;
TAB0 cum = long long array of size 102 ;  $  TAB1 for i = 1 to 100 inclusive set cum[i] to i ;  $  TAB1 for i = 2 to 100 inclusive increment cum[i] by cum[i - 1] ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 sum = long long with sum = 0 ;  $  TAB1 Count = int with Count = 0 ;  $  TAB1 i = int ;  $  TAB1 iterate i starting at 1 while sum <= n ;  $  TAB2 increment sum by cum[i] ;  $  TAB2 if sum > n ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 increment Count ;  $  TAB1 print Count ;
TAB1 create int sum = 1 ;  $  TAB1 make int levels = 1 ;  $  TAB1 make integer counter = 0 ;  $  TAB1 let int n ;  $  TAB1 read n ;  $  TAB1 for i = 2 to n ;  $  TAB2 increment counter ;  $  TAB2 set levels to levels + i ;  $  TAB2 set sum to sum + levels ;  $  TAB1 print counter ;
TAB1 declare long long n ;  $  TAB1 while read n is true ;  $  TAB2 declare i as integer ;  $  TAB2 declare long long t = 0 ;  $  TAB2 declare long long k = 0 ;  $  TAB2 declare last as integer ;  $  TAB2 for i = 1, incrementing i ;  $  TAB3 increment t by i ;  $  TAB3 increment k by t ;  $  TAB3 if n is greater than or equal to k ;  $  TAB4 let last be i ;  $  TAB3 else ;  $  TAB4 break loop ;  $  TAB2 if n is 0, let last be 0 ;  $  TAB2 print last, newline ;
TAB0 let s1 be character array with size 15 ;  $  TAB0 set s2 be character array with size 15 ;  $  TAB0 set s be character array with size 15 ;  $  TAB1 declare integer variable f = 0 ;  $  TAB1 read s1 ;  $  TAB1 declare integer variable n = length of s1 ;  $  TAB1 create boolean flag = 0 ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 for j = 0 to n inclusive ;  $  TAB3 set f to 0 ;  $  TAB3 for k = 0 to j exclusive, set s[k] to s1[k] ;  $  TAB3 s[j] = char('a' + i) ;  $  TAB3 for k = j + 1 to n inclusive, set s[k] to s1[k - 1] ;  $  TAB3 for i = 0, j = n while i < j increase i and decrease j ;  $  TAB4 if s[i] != s[j] ;  $  TAB5 increment f ;  $  TAB5 if f >= 1, break ;  $  TAB3 if f = 0 ;  $  TAB4 print n elements of s ;  $  TAB4 print new line ;  $  TAB1 print "NA" ;
TAB0 declare string variable s ;  $  TAB1 read s ;  $  TAB1 for char = 'a' to 'z' inclusive going alphabetically ;  $  TAB2 for integer i = 0 to length of s inclusive ;  $  TAB3 declare string t = s ;  $  TAB3 insert character c to the t at position i ;  $  TAB3 create string k = t ;  $  TAB3 reverse k ;  $  TAB3 if k = t ;  $  TAB4 print t ;  $  TAB1 print "NA" ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create integer flag with flag = -1 ;  $  TAB1 create integer sz with sz = size of s ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 create string a ;  $  TAB2 add element ( 'a' + i ) to end of a ;  $  TAB2 increment a by s ;  $  TAB2 for j = 0 to sz exclusive ;  $  TAB3 create string b with b = 0 ;  $  TAB3 reverse element order from beginning of b to end of b ;  $  TAB3 if a is b ;  $  TAB4 print a print newline ;  $  TAB3 swap element values from a[j] to a[j+1] ;  $  TAB2 create string b with b = a ;  $  TAB2 reverse element order from beginning of b to end of b ;  $  TAB2 if a is b ;  $  TAB3 print a print newline ;  $  TAB1 print "NA" print newline ;
TAB0 create 2d integer array mp with size 1010 by 1010 ;  $  TAB1 create integers m, n, k ;  $  TAB1 read m read n read k ;  $  TAB1 set bytes from m to size of m to value 0 ;  $  TAB1 create integer flog with flag = 0 ;  $  TAB1 create integer ans with ans = 0 ;  $  TAB1 for i = 1 to k inclusive ;  $  TAB2 create integers x, y ;  $  TAB2 read x read y ;  $  TAB2 set mp[x][y] to 1 ;  $  TAB2 if flag is 0 ;  $  TAB3 if (mp[x - 1][y] and mp[x - 1][y - 1] and mp[x][y - 1]), set flog to 1 ;  $  TAB3 if (mp[x + 1][y] and mp[x + 1][y + 1] and mp[x][y + 1]), set flog to 1 ;  $  TAB3 if (mp[x - 1][y] and mp[x - 1][y + 1] and mp[x][y + 1]), set flog to 1 ;  $  TAB3 if (mp[x + 1][y] and mp[x + 1][y - 1] and mp[x][y - 1]), set flog to 1 ;  $  TAB3 if flog is true ;  $  TAB4 print i print newline ;  $  TAB1 print "0" print newline ;
TAB0 mp = two dimensional int array of sizes 1010 and 1010 ;  $  TAB1 m, n, k = int ;  $  TAB1 read m then n then k ;  $  TAB1 set all values of mp to 0 ;  $  TAB1 flog = int with flog = 0 ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 for i = 1 to k inclusive ;  $  TAB2 x, y = int ;  $  TAB2 read x then y ;  $  TAB2 set mp[x][y] to 1 ;  $  TAB2 if flog is 0 ;  $  TAB3 if mp[x - 1][y] is not 0 and mp[x - 1][y - 1] is not 0 and mp[x][y - 1] is not 0 then set flog to 1 ;  $  TAB3 if mp[x + 1][y] is not 0 and mp[x + 1][y + 1] is not 0 and mp[x][y + 1] is not 0 then set flog to 1 ;  $  TAB3 if mp[x - 1][y] is not 0 and mp[x - 1][y + 1] is not 0 and mp[x][y + 1] is not 0 then set flog to 1 ;  $  TAB3 if mp[x + 1][y] is not 0 and mp[x + 1][y - 1] is not 0 and mp[x][y - 1] is not 0 then set flog to 1 ;  $  TAB3 if flog is not 0 ;  $  TAB4 print i ;  $  TAB1 print "0" ;
TAB0 let OO, NegOO, N, mod be constant integers with OO = 0x3f3f3f3f, NegOO = -1 * OO, N = 1e3 + 5, mod = 1e9 + 7 ;  $  TAB0 black = 2d boolean array of N rows and N columns ;  $  TAB0 boolean check of int x, int z ;  $  TAB1 if black[x + 1][z] and black[x + 1][z + 1] and black[x][z + 1], return the value 1 ;  $  TAB1 if black[x][z - 1] and black[x + 1][z - 1] and black[x + 1][z], return the value 1 ;  $  TAB1 if black[x][z - 1] and black[x - 1][z] and black[x - 1][z - 1], return the value 1 ;  $  TAB1 if black[x][z + 1] and black[x - 1][z] and black[x - 1][z + 1], return the value 1 ;  $  TAB1 let n, m, k be integers ;  $  TAB1 read n, m, k ;  $  TAB1 let ans be a integer with ans = 0 ;  $  TAB1 let x, z be integers ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read x, z ;  $  TAB2 set black[x][z] to 1 ;  $  TAB2 if not ans ;  $  TAB3 if check ( x, z ) , ans is equal to i + 1 ;  $  TAB1 print ans and newline ;
TAB0 declare long longs n, m, i, k, v1, v2 and f where f = 0, and 2d long long array a with size 1007 by 1007 ;  $  TAB1 read n, m and k ;  $  TAB1 for i from 1 to k inclusive ;  $  TAB2 read v1 and v2 ;  $  TAB2 change a[v1][v2] to 1 ;  $  TAB2 if (a[v1][v2] + a[v1 + 1][v2] + a[v1 + 1][v2 + 1] + a[v1][v2 + 1]) = 4 ;  $  TAB3 print i ;  $  TAB3 assign 1 to f ;  $  TAB3 break the loop ;  $  TAB2 if a[v1][v2] + a[v1 - 1][v2] + a[v1][v2 + 1] + a[v1 - 1][v2 + 1] = 4 ;  $  TAB3 print i ;  $  TAB3 set f to 1 ;  $  TAB3 stop the loop ;  $  TAB2 if a[v1][v2] + a[v1][v2 - 1] + a[v1 + 1][v2] + a[v1 + 1][v2 - 1] = 4 ;  $  TAB3 print i ;  $  TAB3 set f to 1 ;  $  TAB3 stop the loop ;  $  TAB2 if a[v1][v2] + a[v1 - 1][v2] + a[v1][v2 - 1] + a[v1 - 1][v2 - 1] = 4 ;  $  TAB3 print i ;  $  TAB3 change f to 1 ;  $  TAB3 break the loop ;  $  TAB1 if f is equal to 0, print 0 ;
TAB0 create constant integer N with N = 1e5 + 5 ;  $  TAB0 create integers x, y, create integer array arr with size 1005 by 1005 ;  $  TAB0 declare solve with integers st1, st2 as arguments, returning boolean ;  $  TAB1 for z = st1 to st1 + 1 inclusive ;  $  TAB2 for v = st2 to st2 + 2 inclusive ;  $  TAB3 if not arr[x+z][y+v], return false from function ;  $  TAB1 return true from function ;  $  TAB1 create integers n, m, k ;  $  TAB1 read n read m read k ;  $  TAB1 for i = 1 to k inclusive ;  $  TAB2 read x read y ;  $  TAB2 set arr[x][y] to 1 ;  $  TAB2 for t = -1 to 0 inclusive ;  $  TAB3 for u = -1 to 0 inclusive ;  $  TAB4 if result of run solve with t, u as arguments is true, return print i print "\n", 0 from function ;  $  TAB1 return print 0 print "\n", 0 from function ;
TAB0 create bool a[1005][1005] ;  $  TAB1 create int n and m ;  $  TAB1 read n, m ;  $  TAB1 create int k ;  $  TAB1 read k ;  $  TAB1 for c=1 to k inclusive ;  $  TAB2 create int x and y ;  $  TAB2 read x, y ;  $  TAB2 set a[x][y] = true ;  $  TAB2 if a[x][y], a[x + 1][y], a[x][y + 1], a[x + 1][y + 1] are true ;  $  TAB3 print c ;  $  TAB2 else if a[x][y] and a[x - 1][y] and a[x][y + 1] and a[x - 1][y + 1] are not false ;  $  TAB3 print c and a newline ;  $  TAB2 else if a[x][y], a[x - 1][y], a[x][y - 1], a[x - 1][y - 1] = true ;  $  TAB3 print c ;  $  TAB2 else if a[x][y] and a[x + 1][y] and a[x][y - 1] and a[x + 1][y - 1] different from false ;  $  TAB3 print c ;  $  TAB1 print 0 and a newline ;
TAB0 create constant integer N with N = 1e3 + 5 ;  $  TAB0 create 2d boolean array mark with size N by N ;  $  TAB1 create integers n, m, k ;  $  TAB1 read n read m read k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 create integers x, y ;  $  TAB2 read x read y ;  $  TAB2 set mark[decrement x][decrement y] to true ;  $  TAB2 for a = x - 1 to x inclusive ;  $  TAB3 for b = y - 1 to y inclusive ;  $  TAB4 if bitwise not minimum of (a and b) and a + 1 is less than n and b + 1 is less than m ;  $  TAB5 create boolean bad with bad = true ;  $  TAB5 for c = 0 to 4 exclusive, set bad to bad bitwise and mark[ a + ( c bitwise and 1 ) ][ b + ( c bitshift right 1 bitwise and 1) ] ;  $  TAB5 if bad, return print i + 1 print newline, 0 ;  $  TAB1 print "0\n" ;
TAB1 create integer n ;  $  TAB1 create strings str, s, ans, min with min = "z" ;  $  TAB1 read str read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s ;  $  TAB2 if s is str ;  $  TAB3 set min to str ;  $  TAB3 break loop ;  $  TAB2 if first index of str in s is 0 and s is less than min, set min to s ;  $  TAB1 if min is "z" ;  $  TAB2 print str print newline ;  $  TAB1 else ;  $  TAB2 print min print newline ;
TAB1 create string str, str2, ans, set ans to a ;  $  TAB1 create int n and flag, assign 0 to flag ;  $  TAB1 read str ;  $  TAB1 set len to length of str ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read str2 ;  $  TAB2 set flag to 0 ;  $  TAB2 for j=0 to len ;  $  TAB3 if str[j] different from str2[j] ;  $  TAB4 flag =1 ;  $  TAB4 break ;  $  TAB2 if flag=1, continue ;  $  TAB2 if ans equal to a ;  $  TAB3 set ans to str2 ;  $  TAB2 else if str2<ans ;  $  TAB3 set ans = str2 ;  $  TAB1 if ans different from a ;  $  TAB2 print ans ;  $  TAB1 else ;  $  TAB2 print str and a newline ;
TAB0 let str, s be strings with s = array of strings of length 105 ;  $  TAB0 create a vector of strings s1 ;  $  TAB0 let n be a integer ;  $  TAB1 read str ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read s[i] ;  $  TAB1 sort the values s and s + n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i].find(str) is equal to 0 , push_back s[i] in s1 ;  $  TAB1 if length of s1 ;  $  TAB2 print s1[0] and newline ;  $  TAB1 else do the following ;  $  TAB2 print str and newline ;
TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 len = int with len = length of str ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 vec = string vector ;  $  TAB1 for i = 0 to n ;  $  TAB2 temp = string ;  $  TAB2 read temp ;  $  TAB2 pos = int with pos = index of str in temp ;  $  TAB2 if pos is 0 ;  $  TAB3 suffix = string with suffix = substr of len on temp ;  $  TAB3 append suffix to vec ;  $  TAB1 if size of vec is 0 ;  $  TAB2 pritn str ;  $  TAB1 else ;  $  TAB2 sort vec ;  $  TAB2 print str + vec[0] ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 vs = vector string ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 ss = string ;  $  TAB2 read ss ;  $  TAB2 append ss in vs ;  $  TAB1 sort vs.begin() and vs.end() ;  $  TAB1 len = integer with len = s.size() ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if vs[i].substr(0, len) is s ;  $  TAB3 print vs[i] ;  $  TAB1 print s ;
TAB1 let str be a string , s = array of strings of length 101 ;  $  TAB1 let n be a integer ;  $  TAB1 read str ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read s[i] ;  $  TAB1 sort the values s + 1 and s + n + 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if s[i].substr(0, length of str ) is equal to str ;  $  TAB3 print s[i] and newline ;  $  TAB1 print str and newline ;
TAB0 function subset (get strings n1 and n2 and int len, return bool) ;  $  TAB1 for i=0 to len exclusive ;  $  TAB2 if n1[i] != n2[i] return false ;  $  TAB1 return true ;  $  TAB0 function small_min(get strings n1 and n2, return string) ;  $  TAB1 if length of n1 < length of n2 return n1 ;  $  TAB1 return n2 ;  $  TAB1 s,ans=string ;  $  TAB1 read s ;  $  TAB1 ara=array of 110 string ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 f=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read ara[i] ;  $  TAB2 j=int ;  $  TAB2 for j=0 to size of s exclusive ;  $  TAB3 if ara[i][j] != s[j] break ;  $  TAB2 if j is size of s ;  $  TAB3 if f is 0 ans=ara[i] ;  $  TAB3 f=1 ;  $  TAB3 ans=min(ans, ara[i]) ;  $  TAB1 if f is 0 ;  $  TAB2 print s ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB0 arr = int array of size 1000000 and a = int array of size 1000 and ar = int array of size 100000 ;  $  TAB0 m = char, int map ;  $  TAB0 mm = char, int map ;  $  TAB1 s, m, k, n = string with k = "" and n = "" ;  $  TAB1 x = int ;  $  TAB1 read s then x ;  $  TAB1 for i = 0 to x ;  $  TAB2 read m ;  $  TAB2 if size of m >= size of s ;  $  TAB3 set n to first size of s chars of m ;  $  TAB3 if n is s and (m <= k || k is "") set k to m ;  $  TAB1 if k is not "" ;  $  TAB2 print k ;  $  TAB1 else ;  $  TAB2 print s ;
TAB1 create string pointer ch, create string var ;  $  TAB1 create integer n ;  $  TAB1 read var read n ;  $  TAB1 set ch to new string array with size n ;  $  TAB1 for i = 0 to n exclusive, read ch[i] ;  $  TAB1 sort elements from ch to ch + n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if first index of var in ch[i] is 0 ;  $  TAB3 print ch[i] print newline ;  $  TAB1 print var print newline ;
TAB0 create string s and string array s1 with dimension 101 ;  $  TAB0 create integer n, ok ;  $  TAB1 get s,n ;  $  TAB1 for integer i=1 to n with increment i do get s1[i] ;  $  TAB1 for integer i=n to 1 with decrement i ;  $  TAB2 for integer j=1 with increment j till j less than i ;  $  TAB3 if s1[j] greater than s1[j+1] then swap s1[j] and s1[j+1] ;  $  TAB1 for integer k=1 to n with increment k ;  $  TAB2 set ok to 1 ;  $  TAB2 for integer i=0 to length of s -1 with increment i ;  $  TAB3 if s[i] not equal to s1[k][i] then ;  $  TAB4 set ok to 0 ;  $  TAB4 break the loop ;  $  TAB2 if ok not equal to 0 then ;  $  TAB3 print s1[k] ;  $  TAB1 print s ;
TAB1 declare string variable with name ss ;  $  TAB1 read standard input to ss ;  $  TAB1 create new integer n ;  $  TAB1 read variable n from the input ;  $  TAB1 read and discard the input data ;  $  TAB1 create string res = ss ;  $  TAB1 declare new boolean noe with value 0 ;  $  TAB1 for integer i = 0 to n exclusive incrementing i ;  $  TAB2 s is a new string ;  $  TAB2 read variable s from the input ;  $  TAB2 declare string tmp with value "" ;  $  TAB2 for j = 0 and ii = 0 while j < length of s, increment j ;  $  TAB3 if ss[ii] = s[j] ;  $  TAB4 increment ii ;  $  TAB3 else ;  $  TAB4 assign 0 to ii ;  $  TAB3 if ii is equal to length of ss ;  $  TAB4 if noe is false ;  $  TAB5 set res to the substring of s from index j - ii + 1 to the end; set noe to 1 ;  $  TAB4 else ;  $  TAB5 change tmp to the substring of s from index j - ii + 1 to the end ;  $  TAB5 set res to min of res and tmp ;  $  TAB5 assign 0 to ii ;  $  TAB1 print res and '\n' ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 let int len = s.length() ;  $  TAB1 let int n ;  $  TAB1 read n ;  $  TAB1 let string array array of size n ;  $  TAB1 let string array output of size n ;  $  TAB1 create integer count = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read array[i] ;  $  TAB2 let int flag = 0 ;  $  TAB2 if array[i].length() is less than len, continue to next loop iteration ;  $  TAB2 for j = 0 to len exclusive ;  $  TAB3 if array[i][j] is not equal to s[j] ;  $  TAB4 set flag to 1 ;  $  TAB4 break loop ;  $  TAB2 if flag is equal to 0, set output[count++] to array[i] ;  $  TAB1 if count is 0 ;  $  TAB2 print s ;  $  TAB1 sort output using argument output + count ;  $  TAB1 print output[0] ;
TAB0 v = string vector ;  $  TAB1 x = string ;  $  TAB1 read x ;  $  TAB1 n, i = long long ;  $  TAB1 y = string ;  $  TAB1 read n ;  $  TAB1 while n is not 0 subtract 1 from n and do ;  $  TAB2 read y ;  $  TAB2 append y to the end of v ;  $  TAB1 sort v ;  $  TAB1 for i = 0 to size of v exclusive ;  $  TAB2 f = long long with value of the position of x within v[i] ;  $  TAB2 if f equals 0 ;  $  TAB3 print v[i] ;  $  TAB1 print x ;
TAB1 create integer n ;  $  TAB1 create string array s with size 110, create string st ;  $  TAB1 read st read n ;  $  TAB1 for i = 0 to n exclusive, read s[i] ;  $  TAB1 sort elements from s to s + n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if substring of s[i] from 0 to size of st is st ;  $  TAB3 print s[i] print newline ;  $  TAB1 print st print newline ;
TAB0 create constant integer INF = 1e9 ;  $  TAB1 let string s ;  $  TAB1 create int N ;  $  TAB1 create string array A of size 128 ;  $  TAB1 read S and N ;  $  TAB1 for i = 0 to N exclusive, read A[i] ;  $  TAB1 sort A ;  $  TAB1 let string ans = S ;  $  TAB1 for i = 0 to N exclusive ;  $  TAB2 let bool check = true ;  $  TAB2 for j = 0 to size of S exclusive ;  $  TAB3 if S[j] is not equal to A[i][j] ;  $  TAB4 set check to false ;  $  TAB4 break loop ;  $  TAB2 if check is equal to false ;  $  TAB3 continue loop ;  $  TAB2 else ;  $  TAB3 set ans to A[i] ;  $  TAB3 break loop ;  $  TAB1 print ans ;
TAB0 p, s, ans = string ;  $  TAB0 n = int ;  $  TAB1 read p then n ;  $  TAB1 set ans to "" ;  $  TAB1 loop n times ;  $  TAB2 read s ;  $  TAB2 if size of s as int is greater or equal to size of p as int ;  $  TAB3 aux = string with aux = substr of 0 and size of p as int on s ;  $  TAB3 if aux is p and (s is less than ans or ans is "") set ans to s ;  $  TAB1 print p if ans is "" else print ans ;
TAB1 s, t = string ;  $  TAB1 n, j = int with j = 0 ;  $  TAB1 read s then n ;  $  TAB1 ar = string array of size n ;  $  TAB1 slength = int with slength = length of s ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read t ;  $  TAB2 if t starts with s ;  $  TAB3 set ar[j] to t ;  $  TAB3 increment j ;  $  TAB1 if j is 0 ;  $  TAB2 print s ;  $  TAB1 else ;  $  TAB2 sort ar from position 0 to j ;  $  TAB2 print ar[0] ;
TAB0 create integer constants OO = 0x3f3f3f3f, NegOO = -1 * OO, N = 2e5 + 5 and mod = 1e9 + 7 ;  $  TAB1 create new string variable x ;  $  TAB1 read variable x from the input ;  $  TAB1 create integer n ;  $  TAB1 read input to n ;  $  TAB1 arr is a new array of strings with size n ;  $  TAB1 for c from 0 to n exclusive, read standard input to arr[c] ;  $  TAB1 sort arr from 0 to n ;  $  TAB1 start for loop from c = 0 to n exclusive incrementing c ;  $  TAB2 declare boolean flag = 1 ;  $  TAB2 for integer i = 0 to the size of x exclusive ;  $  TAB3 change flag to 0 if i is less than size of arr[c] and x[i] != arr[c][i] ;  $  TAB2 if flag is not 0, return cout << arr[c] << "\n", 0 ;  $  TAB1 print x and "\n" to the standard output ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make string vector a of size n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 let int opt = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if (int)(a[i]).size() is less than (int)(s).size(), continue to next loop iteration ;  $  TAB2 if a[i]. substr(0, (int)(s).size()) is not equal to s, continue to next loop iteration ;  $  TAB2 if opt is equal to -1 or a[i] is less than a[opt], set opt to i ;  $  TAB1 if opt is not equal to -1 ;  $  TAB2 print a[opt] ;  $  TAB1 else ;  $  TAB2 print s ;  $  TAB1 print new line ;
TAB0 create new constant integer variable N with value 110 ;  $  TAB0 declare new string input and string array hist with size N ;  $  TAB0 declare vector of strings called prefixed ;  $  TAB0 declare new integer n ;  $  TAB0 boolean function comp with string arguments s1 and s2 ;  $  TAB1 return true if s1 is less than s2 in lexicographic order, or false otherwise ;  $  TAB0 isPref is a boolean function with string arguments s1 and s2 ;  $  TAB1 if length of s1 is less than length of s2, return false ;  $  TAB1 for integer i = 0 to length of s2 exclusive ;  $  TAB2 if s1[i] != s2[i], return false ;  $  TAB1 return true ;  $  TAB1 read input and n from the input ;  $  TAB1 for integer i = 0 to n exclusive incrementing i ;  $  TAB2 read hist[i] from the user input ;  $  TAB2 if isPref(hist[i], input) returned true, push hist[i] into prefixed ;  $  TAB1 if prefixed is not emptu ;  $  TAB2 sort prefixed ;  $  TAB2 print first element of prefixed to the standard output ;  $  TAB1 else ;  $  TAB2 print input ;
TAB1 s is a new array of strings with size 101 ;  $  TAB1 declare integer variable n ;  $  TAB1 declare new string t ;  $  TAB1 read t from the user input ;  $  TAB1 read standard input to n ;  $  TAB1 in a for loop, change i from 0 to n exclusive, reading s[i] on each loop ;  $  TAB1 sort s ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 if length of s[i] is less than length of t, skip the rest of the loop ;  $  TAB2 declare integer j with value 0 ;  $  TAB2 while j < length of t ;  $  TAB3 if s[i][j] != t[j], break ;  $  TAB3 increment j by one ;  $  TAB2 if j = length of t ;  $  TAB3 print s[i] to the standard output ;  $  TAB1 print t ;
TAB0 s = string ;  $  TAB0 n = integer ;  $  TAB0 in function Run that returns nothing ;  $  TAB1 while s can be read as a valid string ;  $  TAB2 ans, tmp = string ;  $  TAB2 for i = 1 to 110 inclusive and increase i at the start of the loop, then ans = ans + z, tmp = tmp + z ;  $  TAB2 read n ;  $  TAB2 t = string t ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read t ;  $  TAB3 if size of t < size of s, continue ;  $  TAB3 if contents of t from the beginning of t to size of s elements away is s, then ans = lower value between ans and t ;  $  TAB2 if ans is tmp, then ans = s ;  $  TAB2 print ans ;  $  TAB1 call Run ;
TAB0 in the function lexi_comp that takes const string reference a,b and returns bool ;  $  TAB1 n = integer with n = min of a.size() and b.size() ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is not b[i], return a[i] < b[i] ;  $  TAB1 return a.size() < b.size() ;  $  TAB0 in the function isPrefix that takes const string reference a, b and returns bool ;  $  TAB1 if b.size() < a.size(), return false ;  $  TAB1 for i = 0 to a.size() exclusive ;  $  TAB2 if a[i] is not b[i], return false ;  $  TAB1 return true ;  $  TAB1 a, b, ans = string ;  $  TAB1 n = integer ;  $  TAB1 read a, n ;  $  TAB1 ans = a + string on 100 an z ;  $  TAB1 ok = bool with ok = false ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read b ;  $  TAB2 if isPrefix on a and b ;  $  TAB3 ok = true ;  $  TAB3 if lexi_comp(b, ans), swap b and ans ;  $  TAB1 if ok ;  $  TAB2 print ans ;  $  TAB1 else ;  $  TAB2 print a ;
TAB0 create string st and string array st1 of size 102 ;  $  TAB0 let long long int n ;  $  TAB1 read st and n ;  $  TAB1 for i = 1 to n, read st1[i] ;  $  TAB1 sort st1 + 1 using argument st1 + n + 1 ;  $  TAB1 for i = 1 to n ;  $  TAB2 if st[i].find(st) is equal to 0 ;  $  TAB3 print st1[i] ;  $  TAB1 print st ;
TAB1 a=pointer to string, s=string ;  $  TAB1 n=int ;  $  TAB1 read s ;  $  TAB1 a=array of n string ;  $  TAB1 for i=0 to n exclusive read a[i] ;  $  TAB1 sort first n items of a ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if a[i] begins with s ;  $  TAB3 print a[i] ;  $  TAB1 print s ;
TAB1 s = string ;  $  TAB1 n = integer ;  $  TAB1 read s, n ;  $  TAB1 v = vector of string with v = n + 1 ;  $  TAB1 for i = 0 to n exclusive, read v[i] ;  $  TAB1 v[n] = s ;  $  TAB1 sort v.begin() and v.end() ;  $  TAB1 for i = 0 to n ;  $  TAB2 if v[i] is s ;  $  TAB3 if i < n and v[i] is v[i + 1].substring(0, (int)v[i].size()) ;  $  TAB4 print v[i + 1] ;  $  TAB4 break loop ;  $  TAB3 else ;  $  TAB4 print v[i] ;  $  TAB4 break loop ;
TAB0 declare check taking in strings s and t and returning bool ;  $  TAB1 if length of s is less than length of t, return false ;  $  TAB1 if i = 0 to length of t exclusive ;  $  TAB2 if s[i] is not equal to t[i], return false ;  $  TAB1 return true ;  $  TAB1 let string t ;  $  TAB1 read t ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 let string array s of size 1000 ;  $  TAB1 for i = 1 to n, read s[i] ;  $  TAB1 create string min = "" ;  $  TAB1 for i = 1 to n ;  $  TAB2 if check(s[i], t) is true ;  $  TAB3 if min is equal to "" or s[i] is less than min, set min to s[i] ;  $  TAB1 if min is equal to "" ;  $  TAB2 print t ;  $  TAB1 else ;  $  TAB2 print min ;
TAB1 var = string and str = pointer to a string ;  $  TAB1 n = int ;  $  TAB1 read var then n ;  $  TAB1 set str to new string array of size n ;  $  TAB1 read n values into str ;  $  TAB1 sort str ;  $  TAB1 for i = 0 to n ;  $  TAB2 if str[i] starts with var ;  $  TAB3 print str[i] ;  $  TAB1 print var ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create vector of booleans called good with n elements filled with 1 ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 for j from 0 to n exclusive ;  $  TAB3 declare integer x ;  $  TAB3 read input to x ;  $  TAB3 if x <= 0 ;  $  TAB4 go to the start of the loop ;  $  TAB3 else if x = 1 ;  $  TAB4 set good[i] to 0 ;  $  TAB3 else if x = 2 ;  $  TAB4 set good[j] to 0 ;  $  TAB3 else ;  $  TAB4 set good[i] and good[j] to 0 ;  $  TAB1 declare vector of integers called sol ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 if good[i] is true, push i + 1 to sol ;  $  TAB1 print length of sol ;  $  TAB1 if length of sol > 0 ;  $  TAB2 for integer i = 0 to length of sol exclusive ;  $  TAB3 if i != 0, print ' ' ;  $  TAB3 print sol[i] ;  $  TAB2 print new line ;
TAB1 n,i,j,k,flag=int, a=array of 100 by 100 int, b=array of 100 int filled with 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive read a[i][j] ;  $  TAB1 k=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 flag=1 ;  $  TAB2 for j=0 to n exclusive ;  $  TAB3 if i != j ;  $  TAB4 if a[i][j] is 1 or 3 flag=0 ;  $  TAB2 if flag b[k] = i+1, increment k ;  $  TAB1 if b[0] is 0 ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print k ;  $  TAB2 for i=0 to k-1 excluisve print b[i], space ;  $  TAB2 print b[k-1] ;
TAB0 vis=array of 105 int, f=array of 105 by 105 int ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 for j=1 to n inclusive ;  $  TAB3 read f[i][j] ;  $  TAB3 if f[i][j] is 1 ;  $  TAB4 vis[i]=1 ;  $  TAB3 else if f[i][j] is 2 ;  $  TAB4 vis[j]=1 ;  $  TAB3 else if f[i][j] is 3 ;  $  TAB4 vis[i] = vis[j] = 1 ;  $  TAB1 a=array of 105 int, top=0 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if not vis[i] a[top]=i, increment top ;  $  TAB1 print top ;  $  TAB1 for i=0 to top exclusive ;  $  TAB2 if i is top-1 ;  $  TAB3 print a[i] ;  $  TAB2 else ;  $  TAB3 print a[i] and space ;
TAB0 declare vector of integers vec ;  $  TAB1 declare int variable n ;  $  TAB1 read input to n ;  $  TAB1 create 2d array of ints arr with size n by n ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 for j from 0 to n exclusive, read input to arr[i][j] ;  $  TAB1 declare int cnt = 0 ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 create bool t = true ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if arr[i][j] = 1 or arr[i][j] = 3 ;  $  TAB4 set t to false ;  $  TAB4 stop the loop ;  $  TAB2 if t is true ;  $  TAB3 increment cnt by one ;  $  TAB3 push i + 1 into vec ;  $  TAB1 print cnt ;  $  TAB1 declare integer len = length of vec ;  $  TAB1 print all elements of vec except last with " " after each one ;  $  TAB1 if cnt is greater than 0, print last element of vec ;
TAB1 define ints n, i, j ;  $  TAB1 define 2-dimensional int array a to be of 105 x 105 elements, int array f to be of 105 elements, int t, and int array b to be of 105 elements ;  $  TAB1 read n ;  $  TAB1 assign zero to t ;  $  TAB1 for i by 1 from 0 to n (exclusive), set f[i] to 1 ;  $  TAB1 for i from 0 to n (exclusive) by 1 ;  $  TAB2 for j from 0 to n (exclusive) by 1 ;  $  TAB3 read a[i][j] ;  $  TAB3 if a[i][j] is 1 ;  $  TAB4 set f[i] to 0 ;  $  TAB3 else if a[i][j] is two ;  $  TAB4 zero f[j] ;  $  TAB3 otherwise if a[i]j] = three ;  $  TAB4 zero f[i] and f[j] ;  $  TAB1 for i from 0 to n (exclusive) by 1 ;  $  TAB2 if f[i], then set b[t] to i + 1 and then increment t ;  $  TAB1 print t and newline ;  $  TAB1 for i from 0 to t (exclusive) by 1 ;  $  TAB2 if i isn't t - 1 ;  $  TAB3 print b[i] and " " ;  $  TAB2 else ;  $  TAB3 print b[i] and newline ;
TAB1 n,d,s=int, dist=array of 105 int ;  $  TAB1 read n ;  $  TAB1 s=n ;  $  TAB1 fill dist with 0 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 for j=1 to n inclusive ;  $  TAB3 read d ;  $  TAB3 if d is 1 increment dist[i] ;  $  TAB3 if d is 2 increment dist[j] ;  $  TAB3 if d is 3 ;  $  TAB4 increment dist[i] ;  $  TAB4 increment dist[j] ;  $  TAB1 for i=0 to n inclusive ;  $  TAB2 if dist[i] != 0 decrement s ;  $  TAB1 print s ;  $  TAB1 flot=1 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if dist[i] is 0 and flot ;  $  TAB3 print i ;  $  TAB3 flot=0 ;  $  TAB2 else if dist[i] is 0 and not flot ;  $  TAB3 print space, i ;  $  TAB1 if s print newline ;
TAB1 define 2D int array r to be 200 x 200, and define ints a, b, c, d, and e ;  $  TAB1 while read into a ;  $  TAB2 define int dynamic array v2 ;  $  TAB2 define 200-elt. array v ;  $  TAB2 for b from 1 to a by 1 ;  $  TAB3 set v[b] to 1 ;  $  TAB3 for c by 1 from 1 to a, read into r[b][c] ;  $  TAB2 for b by 1 from 1 to a ;  $  TAB3 for c from 1 to a by 1 ;  $  TAB4 if b is c, then continue ;  $  TAB4 if r[b][c] is one, then zero v[b] ;  $  TAB4 if r[b][c] is two, then set v[c] to zero ;  $  TAB4 if r[b][c] is three,then set v[b] and v[c] to zero ;  $  TAB2 assign zero to c ;  $  TAB2 for b from 1 to a by 1 ;  $  TAB3 if v[b] is one ;  $  TAB4 increment c ;  $  TAB4 append b onto v2 ;  $  TAB2 if c ;  $  TAB3 print c and newline ;  $  TAB3 for d from 1 to c by 1 ;  $  TAB4 if d is one ;  $  TAB5 print v2[d - 1] ;  $  TAB4 otherwise ;  $  TAB5 print " " and v2[d - 1] ;  $  TAB3 print newline ;  $  TAB2 else ;  $  TAB3 print c followed by newline ;  $  TAB2 clear out v2 ;
TAB1 create int n and a and int array ans of size 105 ;  $  TAB1 while cin >> n is truthy ;  $  TAB2 set all contents of ans to 0 ;  $  TAB2 for i = 1 to n ;  $  TAB3 for j = 1 to n ;  $  TAB4 read a ;  $  TAB4 if a is equal to 1 or a is equal to 3, set ans[i] to 1 ;  $  TAB2 let int cnt = 0 and int array b of size 105 ;  $  TAB2 for i = 1 to n ;  $  TAB3 if ans[i] is equal to 0, set b[cnt++] to i ;  $  TAB2 if cnt is truthy ;  $  TAB3 print cnt ;  $  TAB3 for i = 0 to cnt - 1 exclusive, print b[i] and ' ' ;  $  TAB3 print b[cnt - 1] ;  $  TAB2 else ;  $  TAB3 print 0 ;
TAB0 declare 2d boolean array good with size 200 ;  $  TAB1 declare integer variable n ;  $  TAB1 declare 2d integer array a with size 300 by 300 ;  $  TAB1 read input to n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive, read a[i][j] ;  $  TAB1 set sizeof(good) bytes at the pointer good to true ;  $  TAB1 declare integer variable sum = 0 ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 for j from 1 to n inclusive ;  $  TAB3 if a[i][j] = 1 or a[i][j] = 3 ;  $  TAB4 assign false to good[i] ;  $  TAB4 stop the loop ;  $  TAB2 if good[i] is false, go to the start of the loop ;  $  TAB2 for j from 1 to n inclusive ;  $  TAB3 if a[j][i] is equal to 2 or a[j][i] is equal to 3 ;  $  TAB4 change good[i] to false ;  $  TAB4 break the loop ;  $  TAB2 if good[i] is true, increment sum ;  $  TAB1 print sum ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 if good[i] is true ;  $  TAB3 if sum is equal to 1 ;  $  TAB4 print i ;  $  TAB3 else ;  $  TAB4 print i and ' ' ;  $  TAB3 decrement sum ;
TAB1 v is a vector of 6 integers ;  $  TAB1 for integer i = 0 to 6 exclusive read v[i] ;  $  TAB1 declare integer suma = 0 ;  $  TAB1 create integer minA with value min of v[1] and v[5] ;  $  TAB1 create integer maxA with value max of v[1] and v[5] ;  $  TAB1 declare integer inicial = v[0] * 2 + 1 ;  $  TAB1 for i = 0 to minA exclusive ;  $  TAB2 increase suma by inicial ;  $  TAB2 increase inicial by 2 ;  $  TAB1 decrement inicial if maxA != minA ;  $  TAB1 for i = minA to maxA exclusive, increase suma by inicial ;  $  TAB1 assign value of min of v[2] and v[4] to minA ;  $  TAB1 assign value of max of v[2] and v[4] to maxA ;  $  TAB1 inicial = v[3] * 2 + 1 ;  $  TAB1 for i = 0 to minA exclusive ;  $  TAB2 increase suma by inicial ;  $  TAB2 increase inicial by 2 ;  $  TAB1 decrement inicial if maxA != minA ;  $  TAB1 if v[1] = v[5] ;  $  TAB2 for integer i = minA to maxA exclusive, increase suma by inicial ;  $  TAB1 print suma ;
TAB0 sq is a function that returns an integer and receive integer x ;  $  TAB1 return square of x ;  $  TAB1 a = array of integers of length 11 ;  $  TAB1 for ( integer i=0 to 6 exclusive),read i th element of array a ;  $  TAB1 ans is an integer and equals square of (a[0] + a[1] + a[2]) ;  $  TAB1 decrement ans by square of a[0]) + sq(a[2]) + sq(a[4] ;  $  TAB1 print ans and a new line ;
TAB0 declare long long array a with size 6 ;  $  TAB1 read 6 elements into array a ;  $  TAB1 create long longs ans = 0 and c = 2 * a[0] - 1 ;  $  TAB1 for i = 0 to a[1] + a[2] exclusive ;  $  TAB2 if i <= a[1] && i <= a[5] ;  $  TAB3 increase c by 2 ;  $  TAB2 else if i > a[1] && i is greater than a[5] ;  $  TAB3 decrease c by 2 ;  $  TAB2 if a[1] = a[5] && i = a[1] decrease c by 2 ;  $  TAB2 if i != a[1] && i = a[5] decrease c by 1 ;  $  TAB2 if i = a[1] && i != a[5] decrease c by 1 ;  $  TAB2 increase ans by c ;  $  TAB1 print ans ;
TAB1 a1, a2, a3, a4, a5, a6 =integers ;  $  TAB1 Read a1, a2, a3, a4, a5, a6 ;  $  TAB1 print (a1 + a2 + a3) * (a1 + a2 + a3) - a1 * a1 - a3 * a3 - a5 * a5 and a new line ;
TAB1 a, b, c, d, e, f, maxlevel = long ;  $  TAB1 read a, b, c, d, e, f ;  $  TAB1 maxlevel = b + c ;  $  TAB1 curr = long with curr = a * 2 - 1 ;  $  TAB1 sum = long with sum = 0 ;  $  TAB1 for i = 0 to maxlevel exclusive ;  $  TAB2 if b > 0 ;  $  TAB3 increment curr ;  $  TAB2 else if b < 0 ;  $  TAB3 decrement curr ;  $  TAB2 decrement b ;  $  TAB2 if f > 0 ;  $  TAB3 increment curr ;  $  TAB2 else if f < 0 ;  $  TAB3 decrement curr ;  $  TAB2 decrement f ;  $  TAB2 sum = sum + curr ;  $  TAB1 print sum ;
TAB1 create integer array a with 6 elements ;  $  TAB1 read 6 elements into a ;  $  TAB1 create integer n = a[0] + a[1] ;  $  TAB1 declare integer arrays l and r with size n ;  $  TAB1 for i = 0 to a[1] exclusive, set l[i] to 1 ;  $  TAB1 for integer i = a[1] + 1 to n exclusive, set l[i] to -1 ;  $  TAB1 for i = 0 to a[3] exclusive, set r[i] to 1 ;  $  TAB1 for i = a[3] + 1 to n exclusive, set r[i] to -1 ;  $  TAB1 declare integers ans = 0 and step = 2 * a[2] - 1 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 increase step by l[i] + r[i] ;  $  TAB2 increase ans by step ;  $  TAB1 print ans ;
TAB0 create integer arrays a, b, with a size 10, b size 5005 ;  $  TAB1 set b[0] to 0 ;  $  TAB1 set b[1] to 1 ;  $  TAB1 for i = 2 to 5005 exclusive, set b[i] to i * i ;  $  TAB1 create integer len with len = 0 ;  $  TAB1 for i = 1 to 6 inclusive, read a[i] ;  $  TAB1 create integer m with m = a[1] + a[2] + a[3] ;  $  TAB1 set len to b[m] - (b[a[1]] + b[a[3]] + b[a[5]]) ;  $  TAB1 print len print newline ;
TAB1 declare long long variables a, b, c, d, e and f ;  $  TAB1 read a, b, c, d, e and f ;  $  TAB1 print (c + d + e) * (c + d + e) - (a * a) - (c * c) - (e * e) and "\n" ;
TAB1 create integers a, b, c, d, e, and f ;  $  TAB1 print a b c d e and f ;  $  TAB1 set integer x equal to a + b + c ;  $  TAB1 let res be an integer equal to (x * x) - (a * a) - (c * c) - (e * e) ;  $  TAB1 print res and a new line ;
TAB0 let a, b, c, d, e, f be ints ;  $  TAB1 read a, b, c, d, e, f ;  $  TAB1 print (a + b + c) * (a + b + c) - a * a - c * c - e * e and one newline ;
TAB0 maxn = const int with maxn = 1e6 ;  $  TAB0 inf = const double with inf = 0x3f3f3f3f3f3f3f3f ;  $  TAB0 a, b, c, d, e, f = int ;  $  TAB1 while reading a then b then c then d then e then f print (a + b + c) * (a + b + c) - a * a - c * c - e * e ;
TAB1 a, b, c, d, e, f, ans, x, y and z are integers where ans, x, y and z = 0 ;  $  TAB1 read a, b, c, d, e and f ;  $  TAB1 if b is greater than f ;  $  TAB2 increase ans by 2 * a * f + f * (f + 1) - f ;  $  TAB2 set value of x to a + f ;  $  TAB1 else ;  $  TAB2 increase ans by 2 * a * b + b * (b + 1) - b ;  $  TAB2 set value of x to a + b ;  $  TAB1 if c is greater than e ;  $  TAB2 increase ans by 2 * d * e + e * (e + 1) - e ;  $  TAB2 assign value of c - e to y ;  $  TAB1 else ;  $  TAB2 increase ans by 2 * d * c + c * (c + 1) - c ;  $  TAB2 y = e - c ;  $  TAB1 increase ans by 2 * x * y ;  $  TAB1 print ans and '\n' ;
TAB0 declare integers n and res where n = 6 and array of integers a with 10 elements ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 declare integers root = a[1] * 2 + 1 and curr = root ;  $  TAB1 create integers first_layer, second_layer and third_layer = 0 ;  $  TAB1 if a[2] >= a[n] ;  $  TAB2 set first_layer = a[n] and second_layer = a[2] - a[n] ;  $  TAB1 else ;  $  TAB2 set first_layer = a[2] and second_layer = a[n] - a[2] ;  $  TAB1 for i = 1 to first_layer inclusive ;  $  TAB2 set value of res to res + curr ;  $  TAB2 curr = curr + 2 ;  $  TAB1 if first_layer = a[2] ;  $  TAB2 second_layer = min of second_layer and a[3] ;  $  TAB1 else ;  $  TAB2 second_layer = min of second_layer and a[5] ;  $  TAB1 for i = 1 to second_layer inclusive, increase res by curr - 1 ;  $  TAB1 set root = a[4] * 2 + 1 and curr = root ;  $  TAB1 for integer i = 1 to min of a[3] and a[5] inclusive ;  $  TAB2 res = res + curr ;  $  TAB2 set curr to curr + 2 ;  $  TAB1 print res and '\n' ;
TAB1 set ee and acc = 0 ;  $  TAB1 for i=0 to 6 exclusive ;  $  TAB2 create int e ;  $  TAB2 read e ;  $  TAB2 if i is even, assign acc + e * e to acc ;  $  TAB2 if i is less than 3, ee= ee +e ;  $  TAB1 set ans equal to ee * ee - acc ;  $  TAB1 print ans ;
TAB1 a1, a2, a3, a4, a5, a6, result =integers with result = 0 ;  $  TAB1 Read a1, a2, a3, a4, a5, a6 ;  $  TAB1 set result to ((a1 + a2 + a3) * (a1 + a2 + a3)) - (a1 * a1) - (a3 * a3) - (a5 * a5) ;  $  TAB1 print result and a new line ;
TAB1 create integers a, b, c, d, e and f ;  $  TAB1 read a, b, c, d, e and f ;  $  TAB1 if e > c then swap e and c and swap f and b ;  $  TAB1 print 2 * c * (d + e) - e * e + 2 * a * b + b * b ;
TAB1 create int a, b, c, d, e, f ;  $  TAB1 read a, b, c, d, e and f ;  $  TAB1 print (a + b + c) * (a + b + c) - a * a - c * c - e * e ;
TAB0 maxn = constant integer with value of 105 ;  $  TAB1 a, b, c, d, e, f = integers ;  $  TAB1 read a, b, c, d, e, and f ;  $  TAB1 print (a + b + c) * (a + b + c) - a * a - c * c - e * e ;
TAB0 declare int array side with size 7 ;  $  TAB1 for integer i = 1 to 6 inclusive read side[i] ;  $  TAB1 create integer h1 = min of side[2] and side[6] ;  $  TAB1 create integer h2 = min of side[3] and side[5] ;  $  TAB1 declare int h3 = side[2] + side[3] - h1 - h2 ;  $  TAB1 create int ans = 0 ;  $  TAB1 for integer i = side[1] + 1 to side[1] + h1 inclusive, increase ans by 2 * i - 1 ;  $  TAB1 for integer i = side[4] + 1 to side[4] + h2 inclusive, increase ans by 2 * i - 1 ;  $  TAB1 for i = 1 to h3 inclusive, increase ans by (side[1] + h1) * 2 ;  $  TAB1 print ans ;
TAB1 create long longs a, b, c, d, e, f ;  $  TAB1 read a read b read c read d read e read f ;  $  TAB1 create long long ans with ans = (a + b + c) * (a + b + c) - a * a - c * c - e * e ;  $  TAB1 print ans print newline ;
TAB0 in function sq taking an int a and returning an int ;  $  TAB1 return a * a ;  $  TAB1 i, j, k, a, b, c = int and A = int array of size 6 ;  $  TAB1 read 6 values into A ;  $  TAB1 set a to A[0] + A[1] + A[2] ;  $  TAB1 set b to sq of a ;  $  TAB1 set c to sq of A[0] + sq of A[2] + sq of A[4] ;  $  TAB1 set j to b - c ;  $  TAB1 print j ;
TAB0 a = integer array of size 7 ;  $  TAB0 in the function p that takes integer x and returns integer ;  $  TAB1 return x * x ;  $  TAB1 for i = 1 to 6, read a[i] ;  $  TAB1 ans = integer with ans = p(a[1] + a[2] + a[3]) - p(a[1]) - p(a[3]) - p(a[5]) ;  $  TAB1 print ans ;
TAB1 mp = map of string and int ;  $  TAB1 set mp["ABSINTH"] and mp["BEER"] and mp["BRANDY"] and mp["CHAMPAGNE"] to 1 ;  $  TAB1 set mp["GIN"] and mp["RUM"] and mp["SAKE"] and mp["TEQUILA"] and mp["VODKA"] to 1 ;  $  TAB1 set mp["WHISKEY"] and mp["WINE"] to 1 ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 cnt = int with cnt = 0 ;  $  TAB1 loop n times ;  $  TAB2 s = string ;  $  TAB2 read s ;  $  TAB2 if mp[s] is not 0 ;  $  TAB3 increment cnt ;  $  TAB2 else if s[0] is numeric char ;  $  TAB3 geek = stringstream initialized with s ;  $  TAB3 x = int with x = 0 ;  $  TAB3 read into x from geek ;  $  TAB3 if x is less than 18 then increment cnt ;  $  TAB1 print cnt ;
TAB0 s = string ;  $  TAB0 ans = integer with ans = 0 ;  $  TAB0 in the function make ;  $  TAB1 len = integer with len = s.length() ;  $  TAB1 if s[0] <= 9 and s[0] >= 0 ;  $  TAB2 year = integer with year = 0 ;  $  TAB2 for i = 0 to len exclusive, year = year * 10 + s[i] - 0 ;  $  TAB2 if year < 18, increment ans ;  $  TAB1 else ;  $  TAB2 if s is BRANDY ;  $  TAB3 increment ans ;  $  TAB2 else if s is BEER ;  $  TAB3 increment ans ;  $  TAB2 else if s is ABSINTH ;  $  TAB3 increment ans ;  $  TAB2 else if s is CHAMPAGNE ;  $  TAB3 increment ans ;  $  TAB2 else if s is GIN ;  $  TAB3 increment ans ;  $  TAB2 else if s is RUM ;  $  TAB3 increment ans ;  $  TAB2 else if s is SAKE ;  $  TAB3 increment ans ;  $  TAB2 else if s is TEQUILA ;  $  TAB3 increment ans ;  $  TAB2 else if s is VODKA ;  $  TAB3 increment ans ;  $  TAB2 else if s is WHISKEY ;  $  TAB3 increment ans ;  $  TAB2 else if s is WINE ;  $  TAB3 increment ans ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n ;  $  TAB2 read s ;  $  TAB2 call make ;  $  TAB1 print ans ;
TAB0 declare const int maxn = 1e6 ;  $  TAB0 create an array of integers prime with maxn + 1 elements ;  $  TAB0 function getPrime ;  $  TAB1 set first sizeof(prime) bytes at the pointer prime to 0 ;  $  TAB1 for i from 2 to maxn inclusive ;  $  TAB2 if prime[i] is 0, increment prime[0] and set prime[prime[0]] to i ;  $  TAB2 for j from 1 to prime[0] inclusive while prime[j] <= maxn / i, incrementing j ;  $  TAB3 prime[prime[j] * i] = 1 ;  $  TAB3 if i % prime[j] is equal to 0, break the loop ;  $  TAB1 call getPrime() ;  $  TAB1 declare int variable n ;  $  TAB1 loop, reading n from the input ;  $  TAB2 declare vector of integers v ;  $  TAB2 clear v ;  $  TAB2 declare integer variables key = prime[1] and id=1 ;  $  TAB2 loop i from 1 to n inclusive ;  $  TAB3 create int key = prime[i] ;  $  TAB3 while key <= n ;  $  TAB4 push key into v ;  $  TAB4 multiply key by prime[i] ;  $  TAB2 print length of v ;  $  TAB2 for integer i = 0 to length of v exclusive, print v[i] and "\n" if i = length of v - 1 or " " if it is not ;
TAB0 maxn = const integer with maxn = 1010 ;  $  TAB0 v = vector of integer ;  $  TAB0 is_prime = bool array of size maxn ;  $  TAB0 prime = integer array of size maxn ;  $  TAB0 k = integer ;  $  TAB0 in the function Euler that takes integer n ;  $  TAB1 i, j = integers ;  $  TAB1 k = 0 ;  $  TAB1 for i = 2 to n exclusive ;  $  TAB2 if is_prime[i] is false, prime[increment k] = i ;  $  TAB2 for j < k and i * prime[j] < n ;  $  TAB3 is_prime[i * prime[j]] = true ;  $  TAB3 if i modulo prime[j] is 0, break loop ;  $  TAB1 n, x = integer ;  $  TAB1 Euler of maxn ;  $  TAB1 ans = integer with ans = (0) ;  $  TAB1 read n ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 if prime[i] <= n ;  $  TAB3 p = integer with p = prime[i] ;  $  TAB3 while p <= n ;  $  TAB4 append p in v ;  $  TAB4 p = p * prime[i] ;  $  TAB1 print v.size() ;  $  TAB1 if v.size() > 0 ;  $  TAB2 for i = 0 to v.size() - 1 exclusive, print v[i] ;  $  TAB2 print v[v.size() - 1] ;
TAB0 create integer array a with size 1005 ;  $  TAB0 declare zhi with integer n as argument, returning boolean ;  $  TAB1 for i = 2 to n exclusive ;  $  TAB2 if n % i is 0, return false from function ;  $  TAB1 return true from function ;  $  TAB1 create integer n ;  $  TAB1 while read n ;  $  TAB2 if n is 1 ;  $  TAB3 print 0 print newline ;  $  TAB3 break current loop iteration ;  $  TAB2 set bytes from a to size of a to value 0 ;  $  TAB2 create integer j with j = 0 ;  $  TAB2 for i = 2 to n inclusive ;  $  TAB3 if result of run zhi with i as argument is true ;  $  TAB4 set a[j] to i ;  $  TAB4 increment j ;  $  TAB4 create integer t with t = i ;  $  TAB4 set t to t * i ;  $  TAB4 while t is less than or equal to n ;  $  TAB5 set a[j] to t ;  $  TAB5 increment j ;  $  TAB5 set t to t * i ;  $  TAB2 print j print newline ;  $  TAB2 for i = 0 to j - 1 exclusive, print a[i] print " " ;  $  TAB2 print a[j-1] print newline ;
TAB1 declare double variables a, b and c ;  $  TAB1 read a, b and c ;  $  TAB1 print b / (b + c) * a ;
TAB0 a, b, r = integers ;  $  TAB1 Read l, p, q ;  $  TAB1 print l / (q + p) * p and a new line ;
TAB1 double integers = l,p,q ;  $  TAB1 read l,p,q ;  $  TAB1 output l / (p + q) * p ;
TAB0 create constant integer maxn with maxn = integer casted 1e5 + 5 ;  $  TAB0 create constant long long mod with mod = 1e9 + 7 ;  $  TAB1 create doubles l, p, q ;  $  TAB1 read l read p read q ;  $  TAB1 create double t1 with t1 = ((2 * l) / (p + q)) ;  $  TAB1 create double t2 with t2 = l / (p + q) ;  $  TAB1 create double ans with ans = p * (t1 - t2) ;  $  TAB1 print ans print newline ;
TAB1 define floating point numbers m, a, s ;  $  TAB1 define doubles i, j ;  $  TAB1 while read m, i, j ;  $  TAB2 set a to i + j ;  $  TAB2 assign m / a to s ;  $  TAB2 print s * i and a newline ;
TAB1 create int l, p and q ;  $  TAB1 read l, p and q ;  $  TAB1 print l * p / (p + q) ;
TAB1 double integers = d,n,m ;  $  TAB1 read d,n,m ;  $  TAB1 output (d * n) / (n + m) ;
TAB0 inf = const integer with inf = 0x3f3f3f3f ;  $  TAB0 mod1 = const integer with mod1 = 1e9 + 7 ;  $  TAB0 mod = const long long with mod = 1e16 ;  $  TAB0 maxn = const integer with maxn = 1000 ;  $  TAB0 dx, dy = integer array of size 5 with dx = {0, 1, 0, -1, 0}, dy = {1, 0, -1, 0, 0} ;  $  TAB0 dir = integer array of size [4][2] with dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}} ;  $  TAB1 n, x, y = double ;  $  TAB1 read n, x, y ;  $  TAB1 d = double with d = n / (x + y) ;  $  TAB1 e = double with e = d * x ;  $  TAB1 print e ;
TAB0 create integer array h with size 3 ;  $  TAB1 create long long doubles a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 create long long double f with f = b + c ;  $  TAB1 create long long double t with t = a / f ;  $  TAB1 print b * t print '\n' ;
TAB1 create doubles l, p and q ;  $  TAB1 read input to l, p and q ;  $  TAB1 declare double variable t_total = 3 * l / (p + q) ;  $  TAB1 declare double t1 = l / (p + q) ;  $  TAB1 print (t_total - 2 * t1) * p ;
TAB1 l, x, y = double ;  $  TAB1 read l ;  $  TAB1 read x, y ;  $  TAB1 if y > x ;  $  TAB2 print l - ((l / (x + y)) * the greatest value between x and y) ;  $  TAB1 else ;  $  TAB2 print ((l / (x + y)) * the greatest value between x and y) ;
TAB0 N = const long long with N = 1e5 ;  $  TAB0 l, p, q = flaot ;  $  TAB1 read l then p then q ;  $  TAB1 print l / (p + q) * p ;  $  TAB1 print newline ;
TAB1 set a, b and c to 0 ;  $  TAB1 print a, b and c ;  $  TAB1 if b equal to c ;  $  TAB2 print 0.5*a ;  $  TAB1 print b / (c+b)*a and a newline ;
TAB0 create constant integer N with N = 5000 + 100 ;  $  TAB1 create doubles l, q, p, t, ans ;  $  TAB1 while read l is true ;  $  TAB2 read p read q ;  $  TAB2 set t to l / ( p + q ) ;  $  TAB2 set ans to p * t ;  $  TAB2 print ans print newline ;
TAB1 l, p, q = double ;  $  TAB1 read l, p, q ;  $  TAB1 print result of p * l / (p + q) ;
TAB1 let l, p, q be double values ;  $  TAB1 read l, p, q ;  $  TAB1 print (l * p) / (p + q) and newline ;
TAB1 set float a,s,c,d,e all to 0 and set float for i,j,k,l,f ;  $  TAB1 read k,l,f ;  $  TAB1 set s to (l + f) / 2 ;  $  TAB1 set s to k / s ;  $  TAB1 set s to s / 2 ;  $  TAB1 set a to l * s ;  $  TAB1 output a ;
TAB1 create doubles l, p and q ;  $  TAB1 read l, p and q ;  $  TAB1 print (l / (p + q)) * p and "\n" ;
TAB0 a,b,c,tt = long long integers ;  $  TAB1 read a,b,c ;  $  TAB1 output (float)a / (b + c) * b ;
TAB0 MOD = const long long integer with MOD = 1000000007 ;  $  TAB0 N, M, K, H, W, L, R = long long integer ;  $  TAB1 a, b, c = long double ;  $  TAB1 read a, b, c ;  $  TAB1 a = a / (b + c) ;  $  TAB1 a = a * b ;  $  TAB1 print a ;
TAB1 declare int variables l, p and q ;  $  TAB1 create doubles sum and su ;  $  TAB1 read l, p and q and keep looping ;  $  TAB2 change sum to l / (2 * (p + q)) ;  $  TAB2 assign l - sum * q * 2 to su ;  $  TAB2 print su ;
TAB1 create doubles l, a, b ;  $  TAB1 read l read a read b ;  $  TAB1 print l / ( a + b ) * a print newline ;
TAB1 declare doubles d, a and b ;  $  TAB1 read d, a and b ;  $  TAB1 create double t = d / (a + b) ;  $  TAB1 print t * a ;
TAB1 let a double ;  $  TAB1 let l, p, q doubles ;  $  TAB1 read l, p, and q ;  $  TAB1 set a to l * p / (p + q) ;  $  TAB1 print a ;
TAB1 declare floats l, p and q ;  $  TAB1 read input to l, p and q ;  $  TAB1 print l / (p + q) * p ;
TAB0 declare constant double PI with PI = acosign of -1.0 ;  $  TAB0 declare fast_in_out with no arguments, returning void ;  $  TAB0 declare pause with no arguments, returning void ;  $  TAB1 run fast_in_out ;  $  TAB1 declare ar as integer array = {2, 4, 8, 16, 32, 64, 128, 256, 512} ;  $  TAB1 declare integers n, b, q ;  $  TAB1 read n and b and q ;  $  TAB1 declare integers x = 0, y = n * q ;  $  TAB1 for i = 8 to 0 inclusive, decrementing i ;  $  TAB2 if n is less than ar[i], break current loop iteration ;  $  TAB2 declare integer k with k = ar[i] ;  $  TAB2 let n be n - k ;  $  TAB2 increment n by k / 2 ;  $  TAB2 increment i ;  $  TAB2 let k = k * b + (k / 2) ;  $  TAB2 increment x by k ;  $  TAB1 print x, " ", y, '\n' ;  $  TAB1 run pause ;
TAB0 create ints n, b, p, x = 0, and y ;  $  TAB1 read n, b, and p ;  $  TAB1 set b to 2 * b + 1 ;  $  TAB1 set y to n * p ;  $  TAB1 while n is greater than 1 ;  $  TAB2 create integer k = 1 ;  $  TAB2 while 2 * k is less than or equal to n, set k to k * 2 ;  $  TAB2 set x to x + b * k / 2 ;  $  TAB2 set n to n - k / 2 ;  $  TAB1 print x, " ", and y ;
TAB0 INF = const long long int with INF = (1LL bitshift left by 60) - 1 ;  $  TAB0 MAX = const long long int with MAX = 2000001 ;  $  TAB0 in function fast_exp taking three long long ints base, exp and m and returning a long long int ;  $  TAB1 res = long long int with res = 1 ;  $  TAB1 loop while exp is greater than 0 ;  $  TAB2 if exp is uneven set res to (res * base) mod m ;  $  TAB2 set base to (base * base) mod m ;  $  TAB2 set exp to exp / 2 ;  $  TAB1 return res mod m ;  $  TAB1 n, b, p = int ;  $  TAB1 read n then b then p ;  $  TAB1 bottle, towel = int with bottle = 0 and towel = 0 ;  $  TAB1 set towel to p * n ;  $  TAB1 loop while n is greater than 1 ;  $  TAB2 k = int with k = 1 ;  $  TAB2 loop while k is less or equal to n set k to k * 2 ;  $  TAB2 set k to k / 2 ;  $  TAB2 set n to (n - k) + k / 2 ;  $  TAB2 increment bottle by (k / 2) * (2 * b + 1) ;  $  TAB1 print bottle and towel ;
TAB1 n,m,p=int ;  $  TAB1 read n,m,p ;  $  TAB1 ans=0 ;  $  TAB1 c=n ;  $  TAB1 while n is not 1 ;  $  TAB2 add n/2 to ans ;  $  TAB2 subtract n/2 from n ;  $  TAB1 print ans*(m*2+1), space, c*p ;
TAB0 create const ints N = 1e6 + 5, MAX = 3e7 and MOD = 1e9 + 7 ;  $  TAB0 declare ints n, p, b, x and y ;  $  TAB1 read n, p and b ;  $  TAB1 set y to b * n ;  $  TAB1 while n is not 0 ;  $  TAB2 if n / 2 is true ;  $  TAB3 increase x by (n - n % 2) * p + n / 2 ;  $  TAB2 else ;  $  TAB3 break the loop ;  $  TAB2 assign n / 2 + n % 2 to n ;  $  TAB1 print x, " ", y and "\n" ;
TAB1 create integers m, b, p, total and total_p where total = 0 ;  $  TAB1 read variables m, b and p from the input ;  $  TAB1 assign m * p to total_p ;  $  TAB1 start infinite loop ;  $  TAB2 declare integer variable k = [](int n)->int ;  $  TAB3 declare ints i = 1 and res = pow(2, 0) ;  $  TAB3 looping infinitely ;  $  TAB4 declare new integer variable temp = 2 in the power of i ;  $  TAB4 if temp is greater than n, break ;  $  TAB4 set res to temp ;  $  TAB4 increment i by one ;  $  TAB3 return res ;  $  TAB2 (m) ;  $  TAB2 create integer variable with name matches and value = k / 2 ;  $  TAB2 change total to sum of total and matches * (2 * b) ;  $  TAB2 increase total by matches ;  $  TAB2 assign (k / 2) + (m - k) to m ;  $  TAB2 if matches = 0, break the loop ;  $  TAB1 print total, " " and total_p ;
TAB1 n, agua, toalha = int with toalha = 0 ;  $  TAB1 read n then agua then toalha ;  $  TAB1 nrod, tagua, ttoalha = int with ttoalha = 0 ;  $  TAB1 set nrod to n - 1 ;  $  TAB1 set tagua to nrod + nrod * agua * 2 ;  $  TAB1 set ttoalha to toalha * n ;  $  TAB1 print tagua and ttoalha ;
TAB1 let n, b, p be integers ;  $  TAB1 read n, b, p ;  $  TAB1 let bottles, towels be integers with bottles = 0, towels = n * p ;  $  TAB1 while n is greater than 1 ;  $  TAB2 let matches be a integer with matches = (1 << (int)log2(n)) / 2 ;  $  TAB2 increment bottles by matches * (2 * b + 1) ;  $  TAB2 decrement n by matches ;  $  TAB1 print bottles and space and towels and newline ;
TAB0 create ints n, b, and p ;  $  TAB1 read n, b, and p ;  $  TAB1 set b to b * 2 + 1 ;  $  TAB1 create integer now = 1 ;  $  TAB1 while now is less than or equal to n, shift the bits of now one place to the left ;  $  TAB1 shift the bits of now one place to the right ;  $  TAB1 create int t = n ;  $  TAB1 let long long integer ans = 0 ;  $  TAB1 while t is greater than 1 ;  $  TAB2 set ans to ans + 1LL * now / 2 * b ;  $  TAB2 set t to t - now / 2 ;  $  TAB2 while now is truthy and now > t is true, shift the bits of now one place to the right ;  $  TAB1 print ans, " ", and n * p ;
TAB0 declare g taking in int n and returning integer ;  $  TAB1 while _builtin_popcount(n) is greater than 1, set n to n & (n - 1) ;  $  TAB1 return n ;  $  TAB1 let ints n, b, p, r = 0, and m ;  $  TAB1 read n, b, and p ;  $  TAB1 set m to n ;  $  TAB1 while n is greater than 1 ;  $  TAB2 create int x = g(n) ;  $  TAB2 set r to r + x * (b) ;  $  TAB2 set r to r + x / 2 ;  $  TAB2 set n to n - x / 2 ;  $  TAB1 print r, " ", and p * m ;
TAB1 create ints participants, bottles, and towels ;  $  TAB1 let ints total_b = 0, total_t = 0, and matches ;  $  TAB1 read participants, bottles, and towels ;  $  TAB1 set total_t to the result of participants * towels ;  $  TAB1 while participants is not 1 ;  $  TAB2 set matches to participants / 2 ;  $  TAB2 if participants modulo 2 is equal to 1 ;  $  TAB3 set total_ b to total_b + (participants - 1) * bottles + matches ;  $  TAB3 set participants to participants / 2 + 1 ;  $  TAB2 otherwise do ;  $  TAB3 set total_b to total_b + participants * bottles + matches ;  $  TAB3 set participants to the result of participants / 2 ;  $  TAB1 print total_b, " ", and total_t ;
TAB0 create map m1 from long long ints to long long ints ;  $  TAB0 create map iterator itr from long long ints to long long ints ;  $  TAB1 create long long int n, b, and p ;  $  TAB1 read n, b, and p ;  $  TAB1 make long long int ans2 = n * p ;  $  TAB1 make long long int ans1 = 0 ;  $  TAB1 while n is greater than 1 ;  $  TAB2 let long long int i ;  $  TAB2 for i = 0, loop indefinitely ;  $  TAB3 if pow(2, i) is greater than n, break loop ;  $  TAB2 decrease i ;  $  TAB2 create long long integer z = pow(2, i) ;  $  TAB2 set ans1 to ans1 + (z / 2) * (2 * b + 1) ;  $  TAB2 set n to n - z / 2 ;  $  TAB1 print ans1, " ", and ans2 ;
TAB1 n, b, p = int ;  $  TAB1 read n then b then p ;  $  TAB1 fp = int with fp = n * p ;  $  TAB1 m = int with m = 0 ;  $  TAB1 loop while n > 1 ;  $  TAB2 po = int with po = floor of log2 of n ;  $  TAB2 compete = int with compete = pow of 2, po ;  $  TAB2 diff = int with diff = n - pow of 2, po ;  $  TAB2 increment m by compete / 2 ;  $  TAB2 set n to compete / 2 + diff ;  $  TAB1 fb = int with fb = m * 2 * b + m ;  $  TAB1 print fb and fp ;
TAB1 let n, b, p be integers ;  $  TAB1 read n, b, p ;  $  TAB1 let ats1 , ats2 be integers with ats1 = 0, ats2 = p * n ;  $  TAB1 while n is not equal to 1 ;  $  TAB2 let k be a integer with k = 1 ;  $  TAB2 while 2 * k <= n , k is equal to k * 2 ;  $  TAB2 increment ats1 by k * b + k / 2 ;  $  TAB2 decrement n by k / 2 ;  $  TAB1 print ats1 and space and ats2 and newline ;
TAB1 create integer variables p, b, t and x ;  $  TAB1 read input to p, b and t ;  $  TAB1 create new integer match with value 0 ;  $  TAB1 change x to p ;  $  TAB1 while p != 1 ;  $  TAB2 change match to match + (p / 2) ;  $  TAB2 set p to (p / 2) + (p % 2) ;  $  TAB1 print match + (2 * match * b), " " and x * t to the standard output ;
TAB1 n, p, b = integers ;  $  TAB1 read n, p, b ;  $  TAB1 print (n - 1) * p * 2 + (n - 1) ;  $  TAB1 print b * n ;
TAB0 in the function solve ;  $  TAB1 n, b, p = integers ;  $  TAB1 read n, b, p ;  $  TAB1 br = integer with br = 0 ;  $  TAB1 tr = integer with tr = n * p; ;  $  TAB1 while n > 1 ;  $  TAB2 x = integer with x = 1 ;  $  TAB2 while 2 * x < n, x = x * 2 ;  $  TAB2 br = br + x * (2 * b + 1 ;  $  TAB2 n = n - x ;  $  TAB1 print br," ",tr ;  $  TAB1 call solve ;
TAB1 n, b, p, k, ptot, btot = int ;  $  TAB1 read n then b then p ;  $  TAB1 set ptot to p * n ;  $  TAB1 set btot to 0 ;  $  TAB1 loop while n is greater than 1 ;  $  TAB2 set k to 1 bitshift left by (floor of log2 of n) as int ;  $  TAB2 decrement n by k / 2 ;  $  TAB2 increment btot by (k * b) + (k / 2) ;  $  TAB1 print btot and ptot ;
TAB0 declare gcd with long longs a, b as arguments, returning long long ;  $  TAB1 if b is 0, return a from function ;  $  TAB1 return result of gcd(b,a%b) ;  $  TAB0 declare long long lcm with long longs a, b as arguments ;  $  TAB1 return a * b / gcd(a,b) from function ;  $  TAB0 declare long long f with long longs n, b as arguments ;  $  TAB1 if n is less than or equal to 1, return 0 ;  $  TAB1 declare i as long long = 1 ;  $  TAB1 while i * 2 is less than or equal to n, let i be i * 2 ;  $  TAB1 return result of run f with (n - i + i / 2, b) as arguments + i / 2 * (2 * b + 1) ;  $  TAB1 declare long longs n, b, p ;  $  TAB1 read n read b read p ;  $  TAB1 print result of run f(n,b), print " ", n * p, newline ;
TAB1 n, b, p, m = int ;  $  TAB1 read n then b then p ;  $  TAB1 set p to p * n ;  $  TAB1 for m = 0 to n is greater or equal to 2 setting m to m + n / 2 and n to n / 2 + n mod 2 ;  $  TAB2 noop ;  $  TAB1 print (b * 2 + 1) * m and p ;
TAB0 declare integer array p2 = {1, 2, 4, 8, 16, 32, 64, 128, 256} ;  $  TAB1 declare integers n, b, p, k, m ;  $  TAB1 declare integer bn = 0 ;  $  TAB1 read n, b, p ;  $  TAB1 let m be n ;  $  TAB1 while m is greater than 1 ;  $  TAB2 for k = 8 to 0 inclusive, decrementing k ;  $  TAB3 if p2[k] is less than or equal to m ;  $  TAB4 increment bn by p2[k] / 2 + p2[k] * b ;  $  TAB4 end loop ;  $  TAB2 let m be p2[k] / 2 + (m - p2[k]) ;  $  TAB1 print bn and " " and n * p and newline ;
TAB0 declare new integer water ;  $  TAB0 create integers s, n, b and p ;  $  TAB1 read from the input to n, b and p ;  $  TAB1 declare new integer called k = n ;  $  TAB1 set water to 0 ;  $  TAB1 while n is not 1 ;  $  TAB2 change s to n / 2 ;  $  TAB2 if n is even ;  $  TAB3 set n to n divided by 2 ;  $  TAB2 else ;  $  TAB3 change n to n / 2 + 1 ;  $  TAB2 change water to sum of water and s * (2 * b + 1) ;  $  TAB1 print water, " " and k * p to the standard output ;
TAB0 function read (no args, return long long) ;  $  TAB1 c=getchar() ;  $  TAB1 while c is not '-' and (c < '0' or c > '9') c=getchar() ;  $  TAB1 k=0, kk=1 ;  $  TAB1 if c is '-' c=getchar(), kk=-1 ;  $  TAB1 while c >= '0' and c <= '9' k=k*10+c-'0', c=getchar() ;  $  TAB1 return kk*k ;  $  TAB0 function write (get long long x, return nothing) ;  $  TAB1 if x<0 x=-x, putchar('-') ;  $  TAB1 if x/10 write(w/10) ;  $  TAB1 putchar(x modulo 10+'0') ;  $  TAB0 function writlne (get long long x, return nothing) ;  $  TAB1 write(x) ;  $  TAB1 puts("") ;  $  TAB0 n,b,p=long long ;  $  TAB1 n=read() ;  $  TAB1 b=read() ;  $  TAB1 p=read() ;  $  TAB1 write((b+b+1)*(n-1)) ;  $  TAB1 putchar(' ') ;  $  TAB1 writeln(p*n) ;
TAB0 in function solve that returns nothing ;  $  TAB0 in function speed_up that returns nothing ;  $  TAB1 call speed_up ;  $  TAB1 call solve ;  $  TAB0 in function solve that returns nothing ;  $  TAB1 n, b, p = long long ;  $  TAB1 read n, b, p ;  $  TAB1 y = long long = n * p ;  $  TAB1 sor = long long = 0 ;  $  TAB1 while n > 1 ;  $  TAB2 st = long long = 2 ;  $  TAB2 while st * 2 <= n, then st = st * 2 ;  $  TAB2 sor = sor + (st / 2) * (b * 2 + 1) ;  $  TAB2 n = n - st / 2 ;  $  TAB1 print sor y ;
TAB1 declare ints n, b and p ;  $  TAB1 read variables n, b and p from the input ;  $  TAB1 create ints bowl = 0 and towl = n * p ;  $  TAB1 while n > 1 ;  $  TAB2 new integer k = pow(2, (log(n) / log(2))) ;  $  TAB2 increase bowl by k / 2 * (2 * b + 1) ;  $  TAB2 change n to n - k / 2 ;  $  TAB1 print bowl, ' ' and towl to the standard output ;
TAB1 declare new integers n, agua and toalha with toalha = 0 ;  $  TAB1 read user input to n, agua and toalha ;  $  TAB1 declare integers nrod, tagua and ttoalha with ttoalha = 0 ;  $  TAB1 assign n - 1 to nrod ;  $  TAB1 change tagua to nrod + nrod * agua * 2 ;  $  TAB1 assign toalha * n to ttoalha ;  $  TAB1 print tagua, " " and ttoalha ;
TAB1 n, b, p = int ;  $  TAB1 read n then b then p ;  $  TAB1 bottles = int with bottles = 0 ;  $  TAB1 towels = int with towels = n * p ;  $  TAB1 loop while n is greater than 1 ;  $  TAB2 k = int with k = 0 ;  $  TAB2 for i = 32 - 1 to 0 inclusive decrementing i ;  $  TAB3 if n bitwise-and (1 bitshift left by i) is 1 ;  $  TAB4 set k to 1 bitshift left by i ;  $  TAB4 break ;  $  TAB2 set n to (n - k) + k / 2 ;  $  TAB2 increment bottles by b * k + k / 2 ;  $  TAB1 print bottles and towels ;
TAB1 let m, b, p, total , total_p be integers with total = 0 ;  $  TAB1 read m, b, p ;  $  TAB1 the value of total_p = m * p ;  $  TAB1 while 1 is an infinite loop since condition is always true ;  $  TAB2 le k be a integer with k = [](int n) -> int ;  $  TAB3 let i , res be integers with i = 1, res = 2 ^ 0 ;  $  TAB3 while 1 is an infinite loop since condition is always true ;  $  TAB4 let temp be a integer with temp = 2 ^ i ;  $  TAB4 if temp is greater than n, stop ;  $  TAB4 the value of res = temp ;  $  TAB4 increment i by 1 ;  $  TAB3 return the value of res ;  $  TAB2 m ;  $  TAB2 let matches be a integer with matches = k / 2 ;  $  TAB2 increment total by matches * (2 * b) ;  $  TAB2 increment total by matches ;  $  TAB2 the value of m = (k / 2) + (m - k) ;  $  TAB2 if matches is equal to 0 , stop ;  $  TAB1 print total and space and total_p and newline ;
TAB1 i, b, p, j, n, m, k = int ;  $  TAB1 read n, b, p ;  $  TAB1 print (2 * b + 1) * (n - 1) and space and n * p ;
TAB1 declare new long longs n, b and p ;  $  TAB1 read variables n, b and p from the input ;  $  TAB1 B is a new long long = 0 ;  $  TAB1 declare new long long called T = n * p ;  $  TAB1 while n > 1 ;  $  TAB2 create long long variable with name now = 1 ;  $  TAB2 while now * 2 <= n ;  $  TAB2 change B to B + (now / 2) * (2 * b + 1) ;  $  TAB2 set n to now / 2 + (n - now) ;  $  TAB1 print B, " " and T ;
TAB1 declare new integers N, B and P ;  $  TAB1 read from the input to N, B and P ;  $  TAB1 Ile is a new integer variable with value 0 ;  $  TAB1 create new integer variable Reczniki with value N * P ;  $  TAB1 while N > 1 ;  $  TAB2 declare integer variable Potega with value 1 ;  $  TAB2 while Potega * 2 <= N ;  $  TAB2 declare new integer IleMeczy = Potega / 2 ;  $  TAB2 add IleMeczy * 2 * B + IleMeczy to Ile ;  $  TAB2 change N to (N - Potega) + IleMeczy ;  $  TAB1 print Ile, " ", Reczniki and "\n" ;
TAB1 create int n, b, p ;  $  TAB1 read n, b, p ;  $  TAB1 print (n - 1) * (2 * b + 1), " ", n*p and a newline ;
TAB1 P=array of 9 int filled with 1,2,4,8,16,32,64,128,256 ;  $  TAB1 n,b,p=int ;  $  TAB1 read n,b,p ;  $  TAB1 B=0 ;  $  TAB1 N=n ;  $  TAB1 while n>1 ;  $  TAB2 k=int ;  $  TAB2 for i=8 down to -1 exclusive ;  $  TAB3 if P[i] <= n ;  $  TAB4 k=P[i] ;  $  TAB4 break ;  $  TAB2 add k*(2*b+1)/2 to B ;  $  TAB2 subtract k/2 from n ;  $  TAB1 print B, space, N*p ;
TAB0 n, b, p = long long int ;  $  TAB1 read n, b, p ;  $  TAB1 bByGame = long long integer with bByGame = b * 2 + 1 ;  $  TAB1 towels = long long integer with towels = p * n ;  $  TAB1 bottles = long long integer with bottles = 0 ;  $  TAB1 while n > 1 ;  $  TAB2 num = long long integer with num = log2(n) ;  $  TAB2 bottles = bottles + num * bByGame ;  $  TAB2 n = n - num ;  $  TAB1 print bottles," ",towels ;
TAB0 function min with int arguments a and b that returns integer ;  $  TAB1 return a if a < b, or b otherwise ;  $  TAB0 max is an integer function with int arguments a and b ;  $  TAB1 return a if a > b, or b otherwise ;  $  TAB1 declare integer variables n, b, p and matches with the value of matches = 0 ;  $  TAB1 create integer variable with name x = 256 ;  $  TAB1 read n, b and p ;  $  TAB1 declare integer N with value n ;  $  TAB1 while n != 1 ;  $  TAB2 if x is greater than n ;  $  TAB3 change the value of x to x divided by 2 ;  $  TAB3 skip the rest of the loop ;  $  TAB2 subtract x / 2 from n ;  $  TAB2 add x / 2 to matches ;  $  TAB1 print matches * (1 + 2 * b), " " and N * p to the standard output ;
TAB1 n, b, p = long long ;  $  TAB1 read n then b then p ;  $  TAB1 s1, s2 = long long with s1 = 0LL and s2 = p * n ;  $  TAB1 loop while n > 1 ;  $  TAB2 k = long long with k = 1 ;  $  TAB2 loop while k < n set k to k * 2 ;  $  TAB2 if k > n set k to k / 2 ;  $  TAB2 increment s1 by (k / 2) * (2 * b + 1) ;  $  TAB2 m = long long with m = n - k ;  $  TAB2 l = long long with l = k / 2 ;  $  TAB2 set n to l + m ;  $  TAB1 print s1 and s2 ;
TAB0 create new constant integer maxn with value 1e6+5 ;  $  TAB0 create constant integer variable mod = 1e9+7 ;  $  TAB0 create long long arrays fac and y with size maxn ;  $  TAB0 declare long long variables n and k ;  $  TAB0 long long function qpow with long long arguments a, b and c ;  $  TAB1 declare long long variable with name ans with value 1 ;  $  TAB1 change a to the remainder of a divided by c ;  $  TAB1 change b to b modulo c ;  $  TAB1 while b > 0 ;  $  TAB2 if b is even, set ans to (ans * a) modulo c ;  $  TAB2 change b to b / 2 ;  $  TAB2 change a to a squared modulo c ;  $  TAB1 return ans ;  $  TAB0 integer function pow_2 with integer argument m ;  $  TAB1 create new integer called res with value 1 ;  $  TAB1 declare new integer variable left = 1 ;  $  TAB1 looping infinitely ;  $  TAB2 if res << left <= m and res << (left + 1) > m, return res ;  $  TAB2 increment left ;  $  TAB1 create ints n, b and p ;  $  TAB1 declare new integer called ans with value 0 ;  $  TAB1 read standard input to n, b and p ;  $  TAB1 declare integer tow with value n * p ;  $  TAB1 declare new integer called left with value 0 ;  $  TAB1 while n > 1 ;  $  TAB2 create integer k with value pow_2 of n ;  $  TAB2 set left to n - k ;  $  TAB2 add b * k + k / 2 to ans ;  $  TAB2 change n to k / 2 + left ;  $  TAB1 print ans, ' ', tow and '\n' to standard output ;
TAB1 let participants, bottles, towels be integers ;  $  TAB1 let total_b , total_t , matches be integers with total_b = 0, total_t = 0 ;  $  TAB1 read participants, bottles, towels ;  $  TAB1 the value of total_t = participants * towels ;  $  TAB1 while participants is not equal to 1 ;  $  TAB2 the value of matches = participants / 2 ;  $  TAB2 if participants modulo 2 is equal to 1 ;  $  TAB3 total_b is equal to total_b + (participants - 1) * bottles + matches ;  $  TAB3 the value of participants = participants / 2 + 1 ;  $  TAB2 else do the following ;  $  TAB3 total_b is equal to total_b + participants * bottles + matches ;  $  TAB3 the value of participants = participants / 2 ;  $  TAB1 print total_b and space and total_t and newline ;
TAB1 n, b, p = int ;  $  TAB1 read n then b then p ;  $  TAB1 print (n - 1) * (b * 2 + 1) and p * n ;
TAB0 N, B, P = int ;  $  TAB0 qplays = int ;  $  TAB0 qplayers = int ;  $  TAB0 qoutplayers = int ;  $  TAB0 tplays = int ;  $  TAB0 tplayers = int ;  $  TAB0 in function calc taking int n ;  $  TAB1 k = int with k = 1 ;  $  TAB1 loop while k < n set k to k bithsift left by 1 ;  $  TAB1 if k > n set k to k bitshift right by 1 ;  $  TAB1 set qplays to k - 1 ;  $  TAB1 set qoutplayers to n - k ;  $  TAB1 set qplayers to 0 ;  $  TAB1 loop while k >= 1 ;  $  TAB2 increment qplayers by k ;  $  TAB2 set k to k bitshift right by 1 ;  $  TAB1 decrement qplayers ;  $  TAB1 read N then B then P ;  $  TAB1 set tplays to 0 ;  $  TAB1 set tplayers to 0 ;  $  TAB1 set qoutplayers to 0 ;  $  TAB1 n = int with n = N ;  $  TAB1 do ;  $  TAB2 call calc of n ;  $  TAB2 increment tplayers by qplayers ;  $  TAB2 increment tplays by qplays ;  $  TAB2 set n to 1 + qoutplayers ;  $  TAB1 while qoutplayers > 0 ;  $  TAB1 print ((tplayers * B) + tplays) and N * P ;
TAB0 n, b, p, x, ans = long long ;  $  TAB0 l = bool with l = true ;  $  TAB1 read n, b, p ;  $  TAB1 x = n ;  $  TAB1 while n > 1 ;  $  TAB2 ans = ans + (n / 2) * (b * 2 + 1) ;  $  TAB2 n = ceil(n / 2.0) ;  $  TAB1 print ans," ",x * p ;
TAB1 create integers n, m, p ;  $  TAB1 get n, m, p ;  $  TAB1 create integer ans with ans=0 ;  $  TAB1 create integer c with c=n ;  $  TAB1 while n not equal to 1 do the following ;  $  TAB2 add n/2 to ans ;  $  TAB2 subtract n/2 from n ;  $  TAB1 compute and print two expressions ans*(m*2+1) and c*p with a blank space between ;
TAB0 p2 = int array with the values 1, 2, 4, 8, 16, 32, 64, 128, 256 ;  $  TAB1 n, b, p, k, m = int ;  $  TAB1 bn = int with bn = 0 ;  $  TAB1 read n then b then p ;  $  TAB1 set m to n ;  $  TAB1 loop while m is greater than 1 ;  $  TAB2 for k = 8 to 0 inclusive decrementing k ;  $  TAB3 if p2[k] is less or equal to m ;  $  TAB4 increment bn by p2[k] / 2 + p2[k] * b ;  $  TAB4 break ;  $  TAB2 set m to p2[k] / 2 + (m - p2[k]) ;  $  TAB1 print bn and n * p ;
TAB1 n, p = int ;  $  TAB1 str = string array of size 45 ;  $  TAB1 sum, now = long long ;  $  TAB1 read n then p ;  $  TAB1 set sum and now to 0 ;  $  TAB1 for i = n - 1 to 0 inclusive decrementing i read str[i] ;  $  TAB1 for i = 0 to n - 1 inclusive ;  $  TAB2 if str[i] is "half" ;  $  TAB3 increment sum by now * p ;  $  TAB3 set now to now * 2 ;  $  TAB2 else ;  $  TAB3 increment sum by now * p + p / 2 ;  $  TAB3 set now to now * 2 + 1 ;  $  TAB1 print sum ;
TAB1 create long longs n, p ;  $  TAB1 read n read p ;  $  TAB1 create string array str with size n ;  $  TAB1 create long long i ;  $  TAB1 create long longs ans, fans with fans = 0 ;  $  TAB1 for i = 0 to n exclusive, read str[i] ;  $  TAB1 reverse sort elements from str to str + n ;  $  TAB1 if str[0] is "half" ;  $  TAB2 set ans to 2 ;  $  TAB1 else ;  $  TAB2 set ans to 1 ;  $  TAB1 increment fans by ans * p / 2 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if str[i] is "half" ;  $  TAB3 set ans to ans * 2 ;  $  TAB2 else ;  $  TAB3 set ans to ans * 2 + 1 ;  $  TAB2 increment fans by ans * p / 2 ;  $  TAB1 print fans print newline ;
TAB0 declare solve ;  $  TAB1 create ints n and p ;  $  TAB1 read n and p ;  $  TAB1 let long double ans = 0 ;  $  TAB1 let int cnt = 0 ;  $  TAB1 create string vector v ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let string s ;  $  TAB2 read s ;  $  TAB2 append s to vector v ;  $  TAB1 reverse order of contents of vector v ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if v[i] is equal to "halfplus" ;  $  TAB3 set ans to ans + 0.5 ;  $  TAB3 set ans to ans * 2 ;  $  TAB3 increment cnt ;  $  TAB2 otherwise do: ;  $  TAB3 set ans to ans * 2 ;  $  TAB1 print the result of (long long)(ans)*p - cnt * (p / 2) ;  $  TAB1 call solve() ;
TAB1 str = string array of size 41 ;  $  TAB1 n, p, i, flag = int with flag = 0 ;  $  TAB1 a = long long with a = 0 ;  $  TAB1 read n then p ;  $  TAB1 for i = 1 to n inclusive read str[i] ;  $  TAB1 if str[i - 1] is "halfplus" ;  $  TAB2 increment a by p / 2 ;  $  TAB2 increment flag ;  $  TAB1 for j = i - 2 to 0 decrementing j ;  $  TAB2 if str[j] is "halfplus" ;  $  TAB3 set a to a + (a + flag * p / 2 + p / 2) ;  $  TAB3 increment flag ;  $  TAB2 if str[j] is "half" increment a by a + flag * p / 2 ;  $  TAB1 print a ;
TAB0 op = array of strings 444 ;  $  TAB1 let n, p be long integers ;  $  TAB1 read n and p ;  $  TAB1 the value of p = p / 2 ;  $  TAB1 for i = 1 to n inclusive, read op[i] ;  $  TAB1 let ans, send be long integers with ans = 0, send = 0 ;  $  TAB1 for i is equal to n , i >= 1, decrement i by 1 ;  $  TAB2 send = send * 2 ;  $  TAB2 if op[i] is equal to halfplus , increment send by 1 ;  $  TAB2 increment ans by send ;  $  TAB1 print ans * p and newline ;
TAB0 in the function GCD that takes integer a, b ;  $  TAB1 if a < b, swap a and b ;  $  TAB1 a = a modulo b ;  $  TAB1 if a is 0 ;  $  TAB2 return b ;  $  TAB1 else ;  $  TAB2 return GCD of a and b ;  $  TAB0 INF = const integer with INF = 1000000000 ;  $  TAB0 INF64 = const long long with INF64 = 1e18; ;  $  TAB0 N = const integer with N = 2020 ;  $  TAB0 M = const integer with M = 2000 ;  $  TAB0 MOD = const integer with MOD = 1000000007 ;  $  TAB1 n, p = long long ;  $  TAB1 read n, p ;  $  TAB1 a = vector of integer with a = n ;  $  TAB1 for i = 0 to cast to int(n) ;  $  TAB2 s = string ;  $  TAB2 read s ;  $  TAB2 if s is half ;  $  TAB3 a[i] = 0 ;  $  TAB2 else ;  $  TAB3 a[i] = 1 ;  $  TAB1 k = long long with k = 0 ;  $  TAB1 half = long long with half = 0 ;  $  TAB1 for i = n - 1 down to 0 ;  $  TAB2 k = k * 2 + a[i] ;  $  TAB2 half = half + a[i] ;  $  TAB1 res = long long with res = k * p - half * (p / 2) ;  $  TAB1 print res ;
TAB0 set maxn to 5005 ;  $  TAB0 assign 0x3f3f3f3f to inf ;  $  TAB1 create int a and b ;  $  TAB1 read a, b ;  $  TAB1 create string s of size 50 ;  $  TAB1 for i=1 to a inclusive, read s[i] ;  $  TAB1 set ans to b/2 and num to 1 ;  $  TAB1 for i=a-1 to 1 inclusive ;  $  TAB2 if s[i] = halfplus ;  $  TAB3 set ans to ans + (num + 0.5) * b ;  $  TAB3 assign num*2 + 1 to num ;  $  TAB2 else ;  $  TAB3 set ans to ans + bum*b ;  $  TAB3 num= num*2 ;  $  TAB1 print ans ;
TAB0 create string array s with size 2525 ;  $  TAB1 create long longs n, p, m, l, with m = 0, l = 0 ;  $  TAB1 read n read p ;  $  TAB1 for i = 1 to n inclusive, read s[i] ;  $  TAB1 for i = n to 1 inclusive, decrementing i ;  $  TAB2 set m to m * 2 ;  $  TAB2 if s[i] is "halfplus" increment m ;  $  TAB2 increment l by m ;  $  TAB1 print l * p / 2 print newline ;
TAB1 declare integers n, p and halfs where halfs = 0 ;  $  TAB1 create long long current = 0 ;  $  TAB1 read n and p from the user input ;  $  TAB1 create new stack of strings s ;  $  TAB1 create string variable temp ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 read standard input to temp ;  $  TAB2 push temp to the stack s ;  $  TAB2 if temp is equal to "halfplus", increment halfs ;  $  TAB1 if top element of s is equal to "halfplus" ;  $  TAB2 assign 1 to current ;  $  TAB2 remove top element from s ;  $  TAB1 loop while s is not empty ;  $  TAB2 change the value of current to current multiplied by 2 ;  $  TAB2 if value of the top element of s is "halfplus", increment current by one ;  $  TAB2 remove top element from s ;  $  TAB1 change current to current * p - (0.5 * p * halfs) ;  $  TAB1 print current ;
TAB0 let ret an array of long longs of length 50 ;  $  TAB1 let n, p ints ;  $  TAB1 read n and p ;  $  TAB1 let ans, temp be long longs with ans = 1, tmp = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let s a string ;  $  TAB2 read s ;  $  TAB2 if s is half ;  $  TAB3 set ret[i] to 1 ;  $  TAB2 otherwise ;  $  TAB3 set ret[i] to 2 and increment tmp ;  $  TAB1 for i = n-2 down to 0 inclusive ;  $  TAB2 if ret[i] is 1 ;  $  TAB3 multiply ans by 2 ;  $  TAB2 otherwise ;  $  TAB3 set ans to ans * 2 + 1 ;  $  TAB1 set ans to ans * p - tmp * (p / 2) ;  $  TAB1 print ans ;
TAB1 create long long ints n, p, count = 0, and y = 0 ;  $  TAB1 let string x ;  $  TAB1 read n and p ;  $  TAB1 make string vector a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 append x to vector a ;  $  TAB1 for i = n - 1 to 0 ;  $  TAB2 if a[i] is equal to "halfplus" ;  $  TAB3 set count to count * 2 + 1 ;  $  TAB3 increment y ;  $  TAB2 if a[i] is equal to "half", set count to 2 * count ;  $  TAB1 let long long int ans = p * count - (p * y) / 2 ;  $  TAB1 print ans ;
TAB0 declare long longs p, he and shu ;  $  TAB0 declare integer n ;  $  TAB0 declare an array of strings s with 50 elements ;  $  TAB1 read input to n and p ;  $  TAB1 divide p by 2 ;  $  TAB1 for i = 1 to n inclusive, read s[i] ;  $  TAB1 for integer i = n to 1 inclusive counting down ;  $  TAB2 set shu to shu * 2 ;  $  TAB2 if s[i] != "half", increase shu by 1 ;  $  TAB2 add shu to he ;  $  TAB1 print he * p ;
TAB0 set N to 1e6 + 5, MAX to 3e7 and MOD = 1e9 + 7 ;  $  TAB0 create int n and p ;  $  TAB0 create string a[N] ;  $  TAB0 let ans be ans ans ;  $  TAB1 read n and p ;  $  TAB1 for i=0 to n exclusive, read a[i] ;  $  TAB1 curr = 0 ;  $  TAB1 for i= n-1 to 0 inclusive ;  $  TAB2 if a[i] = half ;  $  TAB3 set ans to ans + curr*p ;  $  TAB3 assign curr*2 to curr ;  $  TAB2 else ;  $  TAB3 assign ans + curr * p to ans ;  $  TAB3 set ans to ans + p/2 ;  $  TAB3 set curr= curr*2 ;  $  TAB3 increment curr ;  $  TAB1 print ans and a newline ;
TAB1 let n and p be long long integers ;  $  TAB1 read n and p ;  $  TAB1 let cost be a long long in with value 0 ;  $  TAB1 arr with n elements = string ;  $  TAB1 read i long long elements into arr from 0 to n exclusive ;  $  TAB1 let num = long long int with value 0 ;  $  TAB1 for i from n - 1 to 0 inclusive decreasing ;  $  TAB2 if arr at element i equals halfplus ;  $  TAB3 num equals num times 2 plus 1 ;  $  TAB2 else ;  $  TAB3 num equals itself times 2 ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 if arr at i equals halfplus ;  $  TAB3 cost equals cost plus (num / 2) * p + (p / 2) ;  $  TAB3 num equals num minus half of num minus 1 ;  $  TAB2 else ;  $  TAB3 cost equals cost plus (num / 2) * p ;  $  TAB3 num equals num minus half of num ;  $  TAB1 print cost ;
TAB0 create constant long long mod with mod = 1e9 + 7 ;  $  TAB0 create constant double esp with esp = 1e-5 ;  $  TAB1 create long longs n, p ;  $  TAB1 create string array a with size 50 ;  $  TAB1 while read n read p is true ;  $  TAB2 for i = 1 to n inclusive, read a[i] ;  $  TAB2 create long longs num, t, with num = 1, t = 1 ;  $  TAB2 for i = n - 1 to 1 inclusive, decrementing i ;  $  TAB3 if a[i] is "halfplus" ;  $  TAB4 set num to ( num + 0.5 ) * 2 ;  $  TAB4 increment t ;  $  TAB3 else ;  $  TAB4 set num to num * 2 ;  $  TAB2 create long long ans with ans = 0 ;  $  TAB2 set ans to num * p - t * (p / 2) ;  $  TAB2 print ans print newline ;
TAB0 create string array s with size 41 ;  $  TAB0 create long longs n, p, sum ;  $  TAB0 create double curr ;  $  TAB1 read n read p ;  $  TAB1 for i = 0 to n exclusive, read s[i] ;  $  TAB1 for i = n - 1 to 0 inclusive, decrementing i ;  $  TAB2 if s[i] is "halfplus", increment curr by 0.5 ;  $  TAB2 increment sum by curr * p ;  $  TAB2 set curr to curr * 2 ;  $  TAB1 print sum print newline ;
TAB0 declare constant int N = 1e6 ;  $  TAB0 create integer array aa with size N + 2 ;  $  TAB1 declare integers n and p ;  $  TAB1 read n and p ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 declare string s ;  $  TAB2 read input to s ;  $  TAB2 if s is equal to "half" ;  $  TAB3 set aa[i] to 0 ;  $  TAB2 else ;  $  TAB3 set aa[i] to 1 ;  $  TAB1 declare long longs app and ans where ans = 0 ;  $  TAB1 for integer i = n to 1 inclusive decrementing i ;  $  TAB2 if i = n ;  $  TAB3 set app to 1 ;  $  TAB2 else ;  $  TAB3 set app to app * 2 + aa[i] ;  $  TAB2 add ((app / 2) * 1LL) * p to ans ;  $  TAB2 if app is odd, increase ans by p / 2 ;  $  TAB1 print ans ;
TAB1 create ints n and p ;  $  TAB1 read n ;  $  TAB1 read p ;  $  TAB1 create long double apples = 0 ;  $  TAB1 let long long answer = 0 ;  $  TAB1 create string vector data ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create string temp ;  $  TAB2 read temp ;  $  TAB2 append temp to data ;  $  TAB1 for i = n - 1 to 0 ;  $  TAB2 if data[i] is equal to "halfplus" ;  $  TAB3 set apples to apples + 0.5 ;  $  TAB3 set apples to apples * 2 ;  $  TAB3 set answer to answer + (apples / 2.0) * p ;  $  TAB2 else ;  $  TAB3 set apples to apples * 2 ;  $  TAB3 set answer to answer + (apples / 2.0) * p ;  $  TAB1 print answer ;  $  TAB1 read n ;
TAB0 declare string array op size 444 ;  $  TAB1 declare long longs n, p ;  $  TAB1 read n, p ;  $  TAB1 let p be p / 2 ;  $  TAB1 for i = 1 to n inclusive, read op[i] ;  $  TAB1 declare long longs ans = 0, send = 0 ;  $  TAB1 for i = n to 1 inclusive, decrementing i ;  $  TAB2 let send be send * 2 ;  $  TAB2 if op[i] is "halfplus", increment send ;  $  TAB2 increment ans by send ;  $  TAB1 print ans * p, newline ;
TAB0 create long longs n, p, k with k = 0 ;  $  TAB1 read n read p ;  $  TAB1 create boolean vector a initialized with n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create string t ;  $  TAB2 read t ;  $  TAB2 set a[i] to length of t is greater than 4 ;  $  TAB2 increment k by a[i] ;  $  TAB1 create double ans with ans = 0 ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 reverse sort elements from beginning of a to end of a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is true ;  $  TAB3 set ans to ans * 2 + 0.5 ;  $  TAB3 increment sum by ans * p ;  $  TAB2 else ;  $  TAB3 set ans to ans * 2 ;  $  TAB3 increment sum by ans * p ;  $  TAB1 print sum print newline ;
TAB0 N=int ;  $  TAB0 P=long long ;  $  TAB0 S=array of 2000010 string ;  $  TAB1 read N,P ;  $  TAB1 for i=1 to N inclusive read S[i] ;  $  TAB1 fans=0 ;  $  TAB1 for i=N down to 1 inclusive ;  $  TAB2 if S[i] is "halfplus" ;  $  TAB3 add 0.5 to fans ;  $  TAB3 multiply fans by 2 ;  $  TAB2 else ;  $  TAB3 multiply fans by 2 ;  $  TAB1 cost=0 ;  $  TAB1 for i=1 to N inclusive ;  $  TAB2 add (fans/2)*P to cost ;  $  TAB2 if S[i] is "half" ;  $  TAB3 divide fans by 2 ;  $  TAB2 else ;  $  TAB3 divide fans by 2 ;  $  TAB3 subtract 0.5 from fans ;  $  TAB1 print cost with 0 decimal digits ;
TAB0 c array of size 500005],s,bit array size of 100, origin array size of 100 = long long integers ;  $  TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 ong a,b = long long integers ;  $  TAB2 read a,b ;  $  TAB2 set s ^= a, c[i] to a ^ b ;  $  TAB1 set integer cnt to 0 ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 for j = 0 to less than cnt do the following ;  $  TAB3 if c[i] & bit[j] is true ;  $  TAB2 set if (c[i]) is true then origin[cnt] equals c[i], bit[cnt] equals c[i] and -c[i], and add 1 to cnt ;  $  TAB1 for j = 0 to less than cnt do the following ;  $  TAB2 if s & bit[j] is true ;  $  TAB1 if s is true ;  $  TAB2 output 1/1 ;  $  TAB1 else ;  $  TAB2 output (1ll,cnt) - 1,/,(1ll << cnt) ;
TAB1 create integer n ;  $  TAB1 create vector of integers T with 1001 element filled with 1 ;  $  TAB1 create vector of chararcters rla ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 create character c ;  $  TAB2 read c ;  $  TAB2 push c to rla ;  $  TAB1 for integer i = 0 to n - 1 exclusive ;  $  TAB2 if rla[i] is 'R' ;  $  TAB3 T[i + 1] = max(T[i + 1], T[i] + 1) ;  $  TAB2 else if rla[i] is '=' ;  $  TAB3 T[i + 1] = T[i] ;  $  TAB1 for i = n - 2 to 0 ;  $  TAB2 if rla[i] is 'L' ;  $  TAB3 assign value of max of T[i] and T[i + 1] + 1 to T[i] ;  $  TAB2 else if rla[i] is '=' ;  $  TAB3 set T[i] to T[i + 1] ;  $  TAB1 for i = 0 to n exclusive print T[i], " \n" and [i == n - 1] ;  $  TAB1 print flush ;
TAB0 n = long long integers ;  $  TAB0 integers = answer array with size of 2000 ;  $  TAB1 read n ;  $  TAB1 set integer small to 1 ;  $  TAB1 create character variable s ;  $  TAB1 read n values into array s ;  $  TAB1 make n values of array answer = 1 ;  $  TAB1 for i = n - 2 to greater than or equal to 0 then do ;  $  TAB2 if s[i] is L then do the following ;  $  TAB3 set answer[i] to answer[i + 1] + 1 ;  $  TAB2 else if s[i] is = then do the following ;  $  TAB3 set answer[i] to answer[i + 1] ;  $  TAB1 for i = 0 to less than n - 1 do the following ;  $  TAB2 if s[i] = R and answer[i] is greater than or equal to answer[i + 1] then do the following ;  $  TAB3 set answer[i + 1] to answer[i] + 1 ;  $  TAB2 else if s[i] is = then do the following ;  $  TAB3 set answer[i + 1] to answer[i] ;  $  TAB1 output n values from array answer ;
TAB0 mod = const long long with mod = 1000000007 ;  $  TAB0 in function powmod taking two long longs a and b and returning a long long ;  $  TAB1 res = long long with res = 1 ;  $  TAB1 set a to a mod mod ;  $  TAB1 call assert on b is greater or equal to 0 ;  $  TAB1 loop while b is not 0 setting b to b bitwise rightshift 1 each time ;  $  TAB2 if b bitwise and 1 is 1 then set re to res * a modulo mod ;  $  TAB2 set a to a * a modulo mod ;  $  TAB1 return res ;  $  TAB0 in = ifstream of "txt.in" ;  $  TAB0 out = ofstream of "txt.out" ;  $  TAB1 call fixed and setprecision of 12 on cout ;  $  TAB1 a, b = long long ;  $  TAB1 read a then b ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 mx = double with mx = 2e9 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 x, y, k = long long ;  $  TAB2 read x then y then k ;  $  TAB2 dis = double with dis = result of sqrt of (x - a) * (x - a) + (y - b) * (y - b) / k ;  $  TAB2 mx = min of mx and dis ;  $  TAB1 print mx ;
TAB1 create integers n and i and an arrays of integers a and b with size 100000 ;  $  TAB1 read n ;  $  TAB1 read n elements into a ;  $  TAB1 for i = 0 to n - 1 exclusive, set value of b[i] to a[i] + a[i + 1] ;  $  TAB1 set value of b[n - 1] to a[n - 1] ;  $  TAB1 for i = 0 to n - 1 exclusive print b[i] and " " ;  $  TAB1 print b[n - 1] ;
TAB0 declare integers n, z and a ;  $  TAB1 read n ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 if i != 1, print a + z and " " ;  $  TAB2 set z to a ;  $  TAB1 print a ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create long long array a with 100050 elements ;  $  TAB1 for integer i = 0 to n exclusive, read a[i] ;  $  TAB1 for integer i = 1 to n exclusive, print a[i] + a[i - 1] and " " ;  $  TAB1 print a[n - 1] ;
TAB1 create long long integers n, i ;  $  TAB1 read n ;  $  TAB1 create long long integer array arr of size n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i is n - 1 ;  $  TAB3 print arr[n-1] print newline ;  $  TAB2 else ;  $  TAB3 print arr[i] + arr[i+1] print " " ;
TAB0 a = int array of size 100005 ;  $  TAB1 n = int ;  $  TAB1 while reading n ;  $  TAB2 for i = i to n inclusive rad a[i] ;  $  TAB2 for i = 1 to n print a[i] + a[i + 1] ;  $  TAB2 print a[n] ;
TAB1 n =integer ;  $  TAB1 x, k = integers with k = 0 ;  $  TAB1 Read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read x ;  $  TAB2 if i is not equal to 1, then print NO and a new line ;  $  TAB2 set k to x ;  $  TAB1 print x and a new line ;
TAB0 x, y = long long arrays of size 100005 each ;  $  TAB1 a, b = long long ;  $  TAB1 read a ;  $  TAB1 set x to all 0 ;  $  TAB1 set y to all 0 ;  $  TAB1 for b = 0 to a read x[b] ;  $  TAB1 for b = 0 to a set y[b] to x[b] + x[b + 1] ;  $  TAB1 for b = 0 to a - 1 print y[b] and ' ' ;  $  TAB1 print y[a - 1] ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 arr = integer array of size n ;  $  TAB1 for i = 0 to n exclusive read arr[i] ;  $  TAB1 for i = 0 to n-1 exclusive ;  $  TAB2 increase arr[i] by arr[i+1] ;  $  TAB2 print arr[i] followed by a space ;  $  TAB1 print arr[n-1] ;
TAB1 create integer n, create integer array arr with size 100010 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i1] ;  $  TAB1 for i = 1 to n exclusive, print arr[i]+arr[i-1] print " " ;  $  TAB1 print arr[n-1] print newline ;
TAB1 create integer n create integer array ara with size 100000 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read ara[i] ;  $  TAB1 for i = 0 to n - 1 exclusive, print ara[i]+ara[i+1] print ' ' ;  $  TAB1 print ara[n-1] print newline ;
TAB1 create integers n, k1, k2, i ;  $  TAB1 read n ;  $  TAB1 read k1 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 read k2 ;  $  TAB2 print k2 + k1 print " " ;  $  TAB2 set k1 to k2 ;  $  TAB1 print k1 print newline ;
TAB1 create int n, r, s i, j and arrays a and b of length 100001 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive, read a[i] ;  $  TAB1 increment j ;  $  TAB1 b[j] = a[n] ;  $  TAB1 for i=n to 1 exclusive ;  $  TAB2 set r = a[i] + a[i - 1] ;  $  TAB2 add 1 to j ;  $  TAB2 assign r to b[j] ;  $  TAB1 for i=j to 0 exclusive ;  $  TAB2 print b[i] ;  $  TAB2 if i different fro 1, print " " ;  $  TAB1 print a newline ;
TAB1 n =integer ;  $  TAB1 x, k = integers with k = 0 ;  $  TAB1 Read n ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 Read x ;  $  TAB2 if i is not 1, then print x + k and a new line ;  $  TAB2 set k to x ;  $  TAB1 print x and a new line ;
TAB1 create int number, i, temp, flag, index and result, set index, result to 0 ;  $  TAB1 create string str ;  $  TAB1 read number ;  $  TAB1 read str ;  $  TAB1 set arr[number] to 0 ;  $  TAB1 for i=0 to number exclusive ;  $  TAB2 assign 0 to flag ;  $  TAB2 set temp to 0 ;  $  TAB2 while str[i] = B ;  $  TAB3 increment i ;  $  TAB3 assign 1 to flag ;  $  TAB3 increment temp ;  $  TAB2 if flag = 1 ;  $  TAB3 decrement i ;  $  TAB3 add 1 to result ;  $  TAB3 assign temp to arr[index] ;  $  TAB3 increment index ;  $  TAB1 print result ;  $  TAB1 for i=0 to result exclusive ;  $  TAB2 if i = result - 1 ;  $  TAB3 print arr[i] ;  $  TAB3 break ;  $  TAB2 print arr[i], " " ;
TAB1 create int n ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 declare integer variable cnt = -1 and an array of integers ans with 100 elements filled with 0 ;  $  TAB1 create character p = 'W' ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 declare character variable c = s[i] ;  $  TAB2 if c = 'B' ;  $  TAB3 if p = 'W' ;  $  TAB3 increase ans[cnt] ;  $  TAB2 set p to c ;  $  TAB1 print cnt + 1 ;  $  TAB1 if cnt + 1 is greater than 0 ;  $  TAB2 declare boolean first = true ;  $  TAB2 loop i from 0 to cnt inclusive ;  $  TAB3 if first is true ;  $  TAB4 set first to false ;  $  TAB3 else ;  $  TAB4 print " " ;  $  TAB3 print ans[i] ;  $  TAB2 print new line ;
TAB1 n = int ;  $  TAB1 a = char array of size 100005 ;  $  TAB1 b = int array of size 100005 ;  $  TAB1 loop while reading n ;  $  TAB2 set all values of a to 0 ;  $  TAB2 set all values of b to 0 ;  $  TAB2 read a ;  $  TAB2 j, count = int with j = 1 and count = 0 ;  $  TAB2 for i = 0 to n ;  $  TAB3 if a[i] is 'B' ;  $  TAB4 increment b[j] ;  $  TAB3 else if a[i] is 'W' and a[i + 1] is 'B' ;  $  TAB4 increment j ;  $  TAB2 for i = 1 to j inclusive ;  $  TAB3 if b[i] is not 0 then increment count ;  $  TAB2 print count ;  $  TAB2 if count is not 0 ;  $  TAB3 for i = 1 to j ;  $  TAB4 if b[i] is not 0 print b[i] and " " ;  $  TAB3 print b[j] ;
TAB0 let a, b be long integers ;  $  TAB0 ans = array of long integers of length 100 ;  $  TAB0 let flag be a integer with flag = 0 ;  $  TAB0 let k be a integer ;  $  TAB0 let void dfs(long long a, int i) be a dfs function ;  $  TAB1 if flag or a greater than b , return the value ;  $  TAB1 the value of ans[i] = a ;  $  TAB1 if a is equal to b ;  $  TAB2 flag is equal to 1 ;  $  TAB2 k value is assigned to i ;  $  TAB2 return ;  $  TAB1 depth first search of a * 2, i + 1 ;  $  TAB1 depth first search of a * 10 + 1, i + 1 ;  $  TAB1 read a, b ;  $  TAB1 depth first search of a, 0 ;  $  TAB1 if flag is equal to 0 ;  $  TAB2 print NO and newline ;  $  TAB1 else do the following ;  $  TAB2 print YES and newline ;  $  TAB2 print k + 1 and newline ;  $  TAB2 print ans[0] ;  $  TAB2 for i = 1 to k inclusive , print space and ans[i] ;  $  TAB2 print newline ;
TAB0 let a, b integers ;  $  TAB1 read a and b ;  $  TAB1 let v be a vector of ints ;  $  TAB1 let ok be an int with value 1 ;  $  TAB1 while b > a ;  $  TAB2 append b to v ;  $  TAB2 if b & 1 is 0 ;  $  TAB3 set b to b / 2 ;  $  TAB2 else if b mod 10 is 1 ;  $  TAB3 set b to b / 10 ;  $  TAB2 else ;  $  TAB3 set ok to 0 ;  $  TAB3 break ;  $  TAB1 if b is different from a ;  $  TAB2 set ok to 0 ;  $  TAB1 else ;  $  TAB2 append a to v ;  $  TAB1 if not ok ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;  $  TAB2 print the size of v ;  $  TAB2 for i = size of v -1 to 0 exclusive, print v[i] ;  $  TAB2 print v[0] ;
TAB0 declare long long variables a, b and n ;  $  TAB0 declare long long array ans with size 1010 ;  $  TAB0 declare boolean flag ;  $  TAB0 function dfs with long long arguments x, y and step ;  $  TAB1 change ans[step] to x ;  $  TAB1 if flag is true or x > y, return ;  $  TAB1 if x = y ;  $  TAB2 assign step to n ;  $  TAB2 set flag to true ;  $  TAB2 return ;  $  TAB1 call dfs(x * 2, y, step + 1) ;  $  TAB1 if flag is false, call dfs(x * 10 + 1, y, step + 1) ;  $  TAB1 loop, reading a and b from the input ;  $  TAB2 change flag to false ;  $  TAB2 call dfs(a, b, 1) ;  $  TAB2 if flag is true ;  $  TAB3 print "YES" ;  $  TAB3 print n ;  $  TAB3 loop i from 1 to n inclusive, print ans[i] and '\n' if i = n, or ' ' ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB0 create integer stack S ;  $  TAB0 declare funcion with long longs a, b as arguments, returning integer ;  $  TAB1 create integer ;  $  TAB1 if a is b, return 1 from function ;  $  TAB1 if a is less than b ;  $  TAB2 set r to result of run funcion with 2 * a, b as arguments ;  $  TAB2 if r is 1 ;  $  TAB3 add element 1 to end of S ;  $  TAB3 return 1 from function ;  $  TAB2 set r to result of run funcion with (10 * a) + 1, b as arguments ;  $  TAB2 if r is 1 ;  $  TAB3 add element 2 to end of S ;  $  TAB3 return 1 from function ;  $  TAB1 else ;  $  TAB1 create long longs a, b ;  $  TAB1 create integers op, ans ;  $  TAB1 read a read b ;  $  TAB1 set ans to result of run funcion with a, b as arguments ;  $  TAB1 if ans is 0 ;  $  TAB2 print "NO" print '\n' ;  $  TAB1 else ;  $  TAB2 print "YES" print '\n' ;  $  TAB2 print size of S + 1 print '\n' ;  $  TAB2 print a ;  $  TAB2 while S is not empty ;  $  TAB3 set op to top of S ;  $  TAB3 remove element from top of S ;  $  TAB3 if op is 1 ;  $  TAB4 set a to a * 2 ;  $  TAB3 else ;  $  TAB4 set a to a * 10 ;  $  TAB4 increment a ;  $  TAB3 print " " print a ;  $  TAB2 print '\n' ;
TAB0 ASS = array of integers of length 50 ;  $  TAB0 let sum be a integer ;  $  TAB0 let flag be a boolean value ;  $  TAB0 let int digui(int a, int b) accepts integer values ;  $  TAB1 if a is less than b ;  $  TAB2 set the value of flag to 1 ;  $  TAB1 if a is equal to b , return 0 ;  $  TAB1 if a modulo 2 is equal to 0 ;  $  TAB2 increase sum by 1 ;  $  TAB2 let ASS[sum - 1] is equal to a / 2 ;  $  TAB2 return digui of a / 2, b ;  $  TAB1 else if a modulo 10 is equal to 1 ;  $  TAB2 increase sum by 1 ;  $  TAB2 let ASS[sum - 1] is equal to (a - 1) / 10 ;  $  TAB2 return digui of (a - 1) / 10, b ;  $  TAB1 else do the following ;  $  TAB2 set the value of flag to 1 ;  $  TAB1 let m , n be integers ;  $  TAB1 read m and n ;  $  TAB1 digui of n , m ;  $  TAB1 if flag is equal to 0 ;  $  TAB2 print YES and newline and sum + 1 and newline ;  $  TAB2 for integer i = sum - 1 , i >= 0, decrease i by 1 , print ASS[i] and space ;  $  TAB2 print n and new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 let k and flag be long ints with flag = 0 ;  $  TAB0 declare vector of long long integers ans ;  $  TAB0 function dfs with long long int arguments n and level ;  $  TAB1 if n is equal to k, assign 1 to flag ;  $  TAB1 if 2 * n <= k and flag = 0, call dfs(2 * n, level + 1) ;  $  TAB1 if 10 * n + 1 <= k and flag = 0, call dfs(10 * n + 1, level + 1) ;  $  TAB1 if flag = 1, push n to ans ;  $  TAB1 return ;  $  TAB1 create long long int n ;  $  TAB1 read n and k ;  $  TAB1 call dfs(n, 1) ;  $  TAB1 if flag is 1 ;  $  TAB2 print "YES" ;  $  TAB2 declare int sz = length of ans ;  $  TAB2 print sz ;  $  TAB2 for i = sz - 1 to 1 inclusive decrementing i, print ans[i] and " " ;  $  TAB2 if sz >= 1, print ans[0] ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 N = const integer with N = 1e5 + 50 ;  $  TAB0 a, b, cnt = long long ;  $  TAB0 ans = long long array of size N ;  $  TAB0 i, j, k, t, m, n = integers ;  $  TAB0 in the function dfs that takes long long st, step ;  $  TAB1 if st > b, return ;  $  TAB1 ans[step] = st ;  $  TAB1 if st is b ;  $  TAB2 cnt = step ;  $  TAB2 print YES ;  $  TAB2 print cnt + 1 ;  $  TAB2 print ans[0] ;  $  TAB2 for i = 1 to cnt exclusive, print " ",ans[i] ;  $  TAB2 print new line ;  $  TAB2 return ;  $  TAB1 if st * 2 <= b, dfs on st * 2 and step + 1 ;  $  TAB1 if st * 10 + 1 <= b, dfs on st * 10 + 1 and step + 1 ;  $  TAB1 read a and b ;  $  TAB1 cnt = 0 ;  $  TAB1 dfs on a and 0 ;  $  TAB1 if not cnt, print NO ;
TAB0 a, b, jum = long long ;  $  TAB0 v = long long vector ;  $  TAB1 read a then b ;  $  TAB1 loop while b is greater than 0 ;  $  TAB2 increment jum ;  $  TAB2 append b to v ;  $  TAB2 if a is b then break loop ;  $  TAB2 if a b is less than a ;  $  TAB3 print "NO" ;  $  TAB2 else if b is even ;  $  TAB3 set b to b / 2 ;  $  TAB2 else if b is uneven ;  $  TAB3 decrement b ;  $  TAB3 if b is a multiple of 10 ;  $  TAB4 set b to b / 10 ;  $  TAB3 else ;  $  TAB4 print "NO" ;  $  TAB1 sort v ;  $  TAB1 print "YES" and jum ;  $  TAB1 for i = 0 to jum ;  $  TAB2 print v[i] ;  $  TAB2 if i is less than jum - 1 ;  $  TAB3 print " " ;  $  TAB2 else ;  $  TAB3 print newline ;
TAB0 declare long integer array perm with size 2 * 100000 + 5 ;  $  TAB1 declare long integer variables n, x, cycle, v, k and xo where cycle = 0 and xo = 1 ;  $  TAB1 read n ;  $  TAB1 for integer i = 1 to n inclusive, read perm[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 xo ^= x ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 continue loop from the start if if perm[i] is false ;  $  TAB2 increase cycle ;  $  TAB2 assign value of i to v ;  $  TAB2 while perm[v] is true ;  $  TAB3 assign value of perm[v] to k ;  $  TAB3 set perm[v] to 0 ;  $  TAB3 set v to k ;  $  TAB1 if cycle = 1, change cycle to 0 ;  $  TAB1 print cycle + xo ;
TAB0 let n be a integer ;  $  TAB0 p = array of integers of length 200100 ;  $  TAB0 b = array of integers of length 200100 ;  $  TAB0 vis = array of integers of length 200200 ;  $  TAB0 let dfs be a function which accepts integer x value ;  $  TAB1 the xth element of array vis is equal to 1 ;  $  TAB1 if (not vis[ xth element of array p], dfs( xth element of array p) ;  $  TAB1 read n ;  $  TAB1 for (i = 1 to n inclusive), read ith element of array p ;  $  TAB1 let cnt be a integer with cnt value as 0 ;  $  TAB1 for (i = 1 to n inclusive) ;  $  TAB2 read ith element of array b ;  $  TAB2 if (ith element of array b is equal to 1), increase cnt by 1 ;  $  TAB1 let ans be a integer with ans value is equal to 0 ;  $  TAB1 if (cnt modulus 2 is equal to 0), increase ans by 1 ;  $  TAB1 let the value of cnt is equal to 0 ;  $  TAB1 for (i = 1 to n inclusive) ;  $  TAB2 if (not ith element of array vis ) ;  $  TAB3 increase cnt value by 1 ;  $  TAB3 dfs of i ;  $  TAB1 if (cnt is equal to 1), cnt is equal to 0 ;  $  TAB1 print ans + cnt and newline ;
TAB0 create constant integer N with N = 6e5 + 10 ;  $  TAB0 create integer arrays v, A, B with v size N, A size N, B size N ;  $  TAB0 create integer n ;  $  TAB0 declare dfs with integer x as argument ;  $  TAB1 if v[x] is true, return from function ;  $  TAB1 set v[x] to 1 ;  $  TAB1 run dfs with A[x] as argument ;  $  TAB1 read n ;  $  TAB1 create integer ans with ans = 0 ;  $  TAB1 for i = 1 to n inclusive, read A[i] ;  $  TAB1 for i = 1 to n inclusive, read B[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if v[i] is 0, run dfs with i as argument, increment ans ;  $  TAB1 create integer t with t = 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if B[i] is true, set t to t ^ 1 ;  $  TAB1 if ans is 1, decrement ans ;  $  TAB1 print ans + t print newline ;
TAB0 declare constant integer N = 2e5 + 5 ;  $  TAB0 create integer arrays Prv and vis with N elements ;  $  TAB0 dfs is a void function with integer argument u ;  $  TAB1 if vis[u] is not 0, return ;  $  TAB1 set value of vis[u] to true ;  $  TAB1 call function dfs with arguments Prv[u] ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 for integer i = 1 to n inclusive read Prv[i] ;  $  TAB1 create integer now = 1 ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 increase now by x ;  $  TAB1 declare integer Res = 0 ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 if vis[i] is 0 ;  $  TAB3 call function dfs with argument i ;  $  TAB3 increment Res ;  $  TAB1 decrement Res if Res = 1 ;  $  TAB1 print Res + (now % 2) and "\n" ;
TAB1 create int i, j and n ;  $  TAB1 set int arrays p, b and status of length 200000 to all 0 ;  $  TAB1 set count and result to 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read p[i] ;  $  TAB2 decrement p[i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 if b[i] = 1, increment count ;  $  TAB1 if count is even, increment result ;  $  TAB1 count = 0 ;  $  TAB1 if i=0 to n exclusive ;  $  TAB2 if status[i] equal to 0 ;  $  TAB3 assign 1 to status[i] ;  $  TAB3 set t to p[i] ;  $  TAB3 while t different from 1 ;  $  TAB4 status[t] = 1 ;  $  TAB4 t = p[t] ;  $  TAB3 add 1 to count ;  $  TAB1 if count greater than 1, set result to result + count ;  $  TAB1 print result ;
TAB0 n,m,k=static long long ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 p=vector of n int ;  $  TAB1 for i=0 to n exclusive read p[i] ;  $  TAB1 res=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 x=int ;  $  TAB2 read x ;  $  TAB2 add x to res ;  $  TAB1 res = (res+1) modulo 2 ;  $  TAB1 visited = vector of n bool ;  $  TAB1 count=-1 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if visited[i] continue ;  $  TAB2 increment count ;  $  TAB2 j=i ;  $  TAB2 while not visited[j] ;  $  TAB3 visited[j] = true ;  $  TAB3 j=p[j]-1 ;  $  TAB1 if count > 0 increment res ;  $  TAB1 add count to res ;  $  TAB1 print res ;
TAB0 create integer n ;  $  TAB0 create constant integer MAXN with MAXN = 200005 ;  $  TAB0 create integer array p with size MAXN ;  $  TAB0 create boolean array vis with size MAXN ;  $  TAB0 declare dfs with integer idx as argument, returning void ;  $  TAB1 set vis[idx] to true ;  $  TAB1 if not vis[p[idx]], run dfs with p[idx] as argument ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read p[i] ;  $  TAB1 create integer counter with counter = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create integer b ;  $  TAB2 read b ;  $  TAB2 if b is 1, increment counter ;  $  TAB1 create integer cycle with cycle = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if not vis[i] ;  $  TAB3 run dfs with i as argument ;  $  TAB3 increment cycle ;  $  TAB1 if cycle is 1 ;  $  TAB2 print 1 - counter % 2 print "\n" ;  $  TAB1 else ;  $  TAB2 print cycle + 1 - counter % 2 print "\n" ;
TAB1 create strings s1 and s2 ;  $  TAB1 read s1 and s2 ;  $  TAB1 if s1 is equal to s2 ;  $  TAB2 print "-1\n" ;  $  TAB1 else ;  $  TAB2 print the max of s1.size() and s2.size() ;
TAB0 dx = int array with the values 0, 1, 0, -1, 1, 1, -1, -1 ;  $  TAB0 dy = int array with the values 1, 0, -1, 0, 1, -1, 1, -1 ;  $  TAB0 define empty function fast ;  $  TAB1 call fast ;  $  TAB1 s, t = string ;  $  TAB1 read s then t ;  $  TAB1 print -1 if s is t else print max of size of s and size of t ;
TAB1 create strings a and b ;  $  TAB1 read standard input to a and b ;  $  TAB1 if a = b, print -1 to the standard output and exit the program ;  $  TAB1 print max of length of a and length of b ;
TAB0 declare constant long long N = 1e8 + 3 ;  $  TAB0 declare constant long long MN = 1e9 + 7 ;  $  TAB0 declare constant long long MX = -1e9-7 ;  $  TAB0 declare long longs n, m, cnt, mx = MX ;  $  TAB0 declare a, b as strings ;  $  TAB0 declare pair of long long, long long pr ;  $  TAB0 declare string vector v ;  $  TAB0 declare map from string to long long mp ;  $  TAB0 declare long long set st ;  $  TAB0 declare long long set iterator it ;  $  TAB1 read a, b ;  $  TAB1 if maximum of ( size of a and size of b ) is greater than minimum of ( size of a and size of b ) ;  $  TAB2 print maximum of ( size of a and size of b ) ;  $  TAB1 else ;  $  TAB2 while true ;  $  TAB3 if a is not b ;  $  TAB4 print size of a ;  $  TAB4 end loop ;  $  TAB3 let a be substring of a from 0 to size of a - 1 ;  $  TAB3 let b be substring of b from 0 to size of b - 1 ;  $  TAB3 if size of a is 0 ;  $  TAB4 print -1 ;  $  TAB4 end loop ;  $  TAB1 print "\n" ;
TAB1 declare character array s1 with size 100006 s2 with size 100003 ;  $  TAB1 while read s1, s2 ;  $  TAB2 declare p as integer = string comparison between s1 and s2 ;  $  TAB2 declare len1 as integer = string length of s1 ;  $  TAB2 declare len2 as integer = string length of s2 ;  $  TAB2 if p is 0 ;  $  TAB3 print "-1" print newline ;  $  TAB2 if len1 is greater than len2 ;  $  TAB3 print len1, newline ;  $  TAB2 else ;  $  TAB3 print len2, newline ;
TAB1 s, ss = string ;  $  TAB1 read s then ss ;  $  TAB1 if s is ss ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print max of length of ss and length of s ;
TAB1 i,res=0 ;  $  TAB1 s1,s2=string ;  $  TAB1 read s1,s2 ;  $  TAB1 if s1 == s2 ;  $  TAB2 res=-1 ;  $  TAB1 else ;  $  TAB2 res=max(size of s1, size of s2) ;  $  TAB1 print res ;
TAB1 declare strings a and b ;  $  TAB1 read standard input to a and b ;  $  TAB1 declare integer variables l = length of a, and ll =length of b ;  $  TAB1 if l != ll ;  $  TAB2 print max of l and ll to the standard output ;  $  TAB1 else if a = b ;  $  TAB2 print -1 to the standard output ;  $  TAB1 else ;  $  TAB2 print length of a to the standard output ;
TAB0 a, b = string ;  $  TAB1 read a then b ;  $  TAB1 if a is not b ;  $  TAB2 print max of size of a, size of b ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB1 create string A ;  $  TAB1 read A ;  $  TAB1 let string B ;  $  TAB1 read B ;  $  TAB1 if A is equal to B ;  $  TAB2 print -1 ;  $  TAB1 print max of A.size() and B.size() ;
TAB0 create new constant long long integer INF with value 8e18 ;  $  TAB0 create new constant long long integer called MOD = 998244353 ;  $  TAB1 declare string variables a and b ;  $  TAB1 read input to a and b ;  $  TAB1 if length of a != length of b ;  $  TAB2 print max of length of a and length of b and '\n' ;  $  TAB1 else if a != b ;  $  TAB2 print length of a and '\n' ;  $  TAB1 else ;  $  TAB2 print -1 and '\n' ;
TAB1 let a, b be strings ;  $  TAB1 let c be a integer with c = 0 ;  $  TAB1 read a, b ;  $  TAB1 let len1 be a integer with len1 is equal to length of a ;  $  TAB1 let len2 be a integer with len2 is equal to length of b ;  $  TAB1 if a is equal to b ;  $  TAB2 print -1 and newline ;  $  TAB1 else do the following ;  $  TAB2 print maximum of len1, len2 and newline ;
TAB0 INF is a new constant integer = 0x3f3f3f3f ;  $  TAB0 create new constant integer mod with value 998244353 ;  $  TAB0 declare character arrays a and b with 100005 elements ;  $  TAB1 read input to a and b ;  $  TAB1 if content of a and b matches ;  $  TAB2 return puts("-1") ;  $  TAB1 else ;  $  TAB2 print max of length of a and length of b to the standard output ;
TAB1 s, s1 = string ;  $  TAB1 read s then s1 ;  $  TAB1 if s is s1 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print max of size of s, size of s1 ;
TAB0 declare strings n, n2 ;  $  TAB0 declare compare with strings s1, s2, integer length as arguments, returning boolean ;  $  TAB1 for i = 0 to length exclusive ;  $  TAB2 if s1[i] is not s2[i], return false from function ;  $  TAB1 return true from function ;  $  TAB1 read n, n2 ;  $  TAB1 declare l1, l2, greater as integers ;  $  TAB1 let l1 be greater = length of n ;  $  TAB1 let l2 be length of n2 ;  $  TAB1 if l2 is greater than l1, let greater be l2 ;  $  TAB1 if l1 is l2 ;  $  TAB2 declare x as boolean = result of run compare with n, n2, l1 as arguments ;  $  TAB2 if x is true ;  $  TAB3 print -1 and newline ;  $  TAB2 else ;  $  TAB3 print l1 print newline ;  $  TAB1 print greater print newline ;
TAB1 a, b = string ;  $  TAB1 read a then b ;  $  TAB1 sz1, sz2 = int with sz1 = size of a and sz2 = size of b ;  $  TAB1 if a is b ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print max of sz1, sz2 ;
TAB1 declare string variables s1 and s2 ;  $  TAB1 read from the input to s1 and s2 ;  $  TAB1 if s1 is equal to s2 ;  $  TAB2 print -1 and a new line ;  $  TAB1 else ;  $  TAB2 print max of length of s1 and length of s2 to the standard output ;
TAB1 let a, b strings ;  $  TAB1 read in a and b ;  $  TAB1 if a same as b ;  $  TAB2 print -1 to stdout ;  $  TAB1 otherwise ;  $  TAB2 print max(length of a, length of b) ;
TAB0 N, INF = const int with N = 1e5 + 10 and INF = 1e9 + 7 ;  $  TAB0 a, b = string ;  $  TAB1 read a then b ;  $  TAB1 if a is b ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print max of size of a and size of b ;
TAB1 a, b = string ;  $  TAB1 read a then b ;  $  TAB1 if a is not b ;  $  TAB2 print max of length of a and length of b ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB0 E=exp(1) ;  $  TAB0 maxn=1000010 ;  $  TAB0 ch=array of maxn char ;  $  TAB0 ch1=array of maxn char ;  $  TAB1 read ch ;  $  TAB1 read ch1 ;  $  TAB1 l1=length of ch ;  $  TAB1 l2=length of ch1 ;  $  TAB1 if ch and ch1 are equal ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print max(l1,l2) ;
TAB1 create strings s and second ;  $  TAB1 read user input to s and second ;  $  TAB1 declare long long variables p and q = 0 ;  $  TAB1 create new long long called xx with value 0 ;  $  TAB1 create new long long variable cnt = 0 ;  $  TAB1 if s = second ;  $  TAB2 print "-1" to the standard output ;  $  TAB1 if length of s is greater than length of second ;  $  TAB2 print length of s to the standard output ;  $  TAB1 else ;  $  TAB2 print length of second ;
TAB1 s1, s2 = string ;  $  TAB1 Read s1 and s2 ;  $  TAB1 if s1 = s2 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print max of s1 and s2 ;
TAB1 create strings a and b ;  $  TAB1 read a and b ;  $  TAB1 let ints l = a.size() and ll = b.size() ;  $  TAB1 if l is not equal to ll ;  $  TAB2 print max(l, ll) ;  $  TAB1 else if a is equal to b ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print a.size() ;
TAB1 a, b = string ;  $  TAB1 read a then b ;  $  TAB1 if size of a is not size of b ;  $  TAB2 print max of size of a and size of b ;  $  TAB1 else if compare of b on a is 0 ;  $  TAB2 print "-1" ;  $  TAB1 else ;  $  TAB2 s = int with s = size of a ;  $  TAB2 mp = string and int map ;  $  TAB2 x = int with x = s ;  $  TAB2 loop while x is greater than 0 ;  $  TAB3 for i = 0 to s and i + x is less or equal to s ;  $  TAB4 st = string with st = substring of a starting at i and a length of x ;  $  TAB4 set mp[st] to 1 ;  $  TAB3 for i = 0 to s and i + x is less or equal to s ;  $  TAB4 st = string with st = substring of b starting at i and a length of x ;  $  TAB4 if mp[st] is 0 ;  $  TAB5 print size of st ;  $  TAB3 decrement x ;
TAB1 create strings a and b ;  $  TAB1 read a and b ;  $  TAB1 if the length of a is not equal to the length of b ;  $  TAB2 print the max of length of a and length of b ;  $  TAB1 else ;  $  TAB2 if a is equal to b ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print the length of a ;
TAB0 dx = int array with the values 0, 1, 0, -1, 1, 1, -1, -1 ;  $  TAB0 dy = int array with the values 1, 0, -1, 0, 1, -1, 1, -1 ;  $  TAB0 define empty function fast ;  $  TAB1 call fast ;  $  TAB1 s, t = string ;  $  TAB1 read s then t ;  $  TAB1 print -1 if s is t else print max of size of s, size of t ;
TAB0 let n, c1, c2 be long integers ;  $  TAB0 let solve accepts long integer g ;  $  TAB1 t1, t2, left, res be long integers with t1 = ceiling of(double)n / g , t2 = n / g, left = n, res = 0 ;  $  TAB1 for t2 * g is not equal to left and left is greater than 0, decrement left by t1, decrement g by 1, res = res + (c1 + c2 * (t1 - 1) * (t1 - 1)) ;  $  TAB1 for g is greater than 0, decrement left by t2, decrement g by 1, the value of res = res + (c1 + c2 * (t2 - 1) * (t2 - 1)) ;  $  TAB1 return the value of res ;  $  TAB1 let t be a character ;  $  TAB1 read n, c1, c2 ;  $  TAB1 let p , r , i be long integers with p = 0, r = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t ;  $  TAB2 if t is equal to 1 increment p by 1 else increment r by 1 ;  $  TAB1 let lo, hi be long integers with lo = 1, hi = p ;  $  TAB1 while lo is less than hi ;  $  TAB2 let diff be a long integer with diff = hi - lo ;  $  TAB2 let p1, p2 be long integers with p1 = lo + diff / 3, p2 = lo + (2 * diff + 2) / 3 ;  $  TAB2 let s1, s2 be a long integers with s1 = solve(p1), s2 = solve(p2) ;  $  TAB2 if s1 is equal to s2 ;  $  TAB3 lo is equal to p1 + 1, hi is equal to p2 - 1 ;  $  TAB2 else if s1 is greater than s2 ;  $  TAB3 the value of lo = p1 + 1 ;  $  TAB2 else do the following ;  $  TAB3 the value of hi = p2 - 1 ;  $  TAB1 print solve(lo) and newline ;
TAB0 declare long longs n, c1, c2 ;  $  TAB0 declare solve with long long g as argument, returning long long ;  $  TAB1 declare long longs t1 = round up( double casted(n) / g), t2 = n / g, left = n, res = 0 ;  $  TAB1 for t2 * g is not left and left is greater than 0, decrementing left by t1, decrementing g, increment res by (c1 + c2 * (t1 - 1) * (t1 - 1)) ;  $  TAB1 for g is greater than 0, decrementing left by t2, decrementing g, increment res by (c1 + c2 * (t2 - 1) * (t2 - 1)) ;  $  TAB1 return res from function ;  $  TAB1 declare t as character ;  $  TAB1 read n, c1, c2 ;  $  TAB1 declare long longs p = 0, r = 0, i ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t ;  $  TAB2 increment p if t is '1', else increment r ;  $  TAB1 declare long long lo = 1, hi = p ;  $  TAB1 while lo is less than hi ;  $  TAB2 declare long long diff = hi - lo ;  $  TAB2 declare long longs p1 = lo + diff / 3, p2 = lo + (2 * diff + 2) / 3 ;  $  TAB2 declare long longs s1 = result of run solve with p1 as argument, s2 = result of run solve(p2) ;  $  TAB2 if s1 is s2 ;  $  TAB3 let lo be p1 + 1, hi be p2 - 1 ;  $  TAB2 else if s1 is greater than s2 ;  $  TAB3 let lo be p1 + 1 ;  $  TAB2 else ;  $  TAB3 let hi be p2 - 1 ;  $  TAB1 print result of run solve with lo as argument, newline ;
TAB1 create integer n ;  $  TAB1 create long longs c1, c2 ;  $  TAB1 read n read c1 read c2 ;  $  TAB1 create integer cnt with cnt = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create character c ;  $  TAB2 read c ;  $  TAB2 if c is '1' increment cnt ;  $  TAB1 create long long ans with ans = 1e18 ;  $  TAB1 for i = 1 to cnt inclusive ;  $  TAB2 create long longs p, mod with p = n / i, mod = n % i ;  $  TAB2 create long long now with now = (p - 1) * (p - 1) * c2 * (i - mod) + c1 * i + p * p * mod * c2 ;  $  TAB2 set ans to minimum of ans and now ;  $  TAB1 print ans print newline ;
TAB1 create long longs n, m, i, j, p, q, cnt, c1, c2, x, y, mn ;  $  TAB1 create string s ;  $  TAB1 while read n read c1 read c2 is true ;  $  TAB2 read charaacter ;  $  TAB2 read s ;  $  TAB2 set cnt to 0 ;  $  TAB2 set mn to LONG_LONG_MAX ;  $  TAB2 for i = 0 to size of s exclusive ;  $  TAB3 if s[i] is '1', increment cnt ;  $  TAB2 for i = 1 to cnt inclusive ;  $  TAB3 set x to n / i ;  $  TAB3 set y to n % i ;  $  TAB3 set p to (c1 + c2 * (x - 1) * (x - 1)) * (i - y) ;  $  TAB3 set q to (c1 + (c2 * x * x)) * y ;  $  TAB3 set m to p + q ;  $  TAB3 set mn to minimum of mn and m ;  $  TAB2 print mn print newline ;
TAB0 declare constant int MAX_N = 2e5 + 10 ;  $  TAB0 declare constant int MAX_LOG = 62 ;  $  TAB0 declare constant long long INF = 1e18 + 1 ;  $  TAB0 declare constant long long MOD = 1e9 + 7 ;  $  TAB0 declare long long variables n, c1, c2 and ans with ans = INF ;  $  TAB0 create string s ;  $  TAB0 declare integer variable m ;  $  TAB1 read input to n, c1 and c2 ;  $  TAB1 read s ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 if s[i] = '1', increment m ;  $  TAB1 for i from 1 to m inclusive ;  $  TAB2 create long long k = n / i ;  $  TAB2 create long long r = n % i ;  $  TAB2 declare long long variable tmp = r * (c1 + c2 * k * k) ;  $  TAB2 add (i - r) * (c1 + c2 * (k - 1) * (k - 1)) to tmp ;  $  TAB2 set ans to min of ans and tmp ;  $  TAB1 print ans ;
TAB0 in the function es_primo that takes integer n and returns bool ;  $  TAB1 if n < 4, return true ;  $  TAB1 for i = 2 to i * i <= n ;  $  TAB2 if n modulo i is 0, return false ;  $  TAB1 return true ;  $  TAB0 in the function sum_digitos that takes integer n and returns int ;  $  TAB1 sum = integer with sum = 0 ;  $  TAB1 while n > 0 ;  $  TAB2 sum = sum + n modulo 10 ;  $  TAB2 n = n / 10 ;  $  TAB1 return sum ;  $  TAB0 in the function sum_factores that takes integer n and returns integer ;  $  TAB1 sum = integer with sum = 0 ;  $  TAB1 for i = 2 to i * i <= n ;  $  TAB2 while n modulo i is 0 ;  $  TAB3 sum = sum + sum_digitos(i) ;  $  TAB3 n = n / i ;  $  TAB1 if n > 1, sum = sum + sum_digitos(n) ;  $  TAB1 return sum ;  $  TAB0 in the function busca_sig that takes integer n and returns integer ;  $  TAB1 do increment n, while es_primo(n) or sum_digitos(n) is not sum_factores(n) ;  $  TAB1 return n ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 act = integer with act = 0 ;  $  TAB1 for i = 1 to n, act = busca_sig(act) ;  $  TAB1 print act ;
TAB1 create long long n, k, p ;  $  TAB1 read n read k read p ;  $  TAB1 create long long arrays pe, ke, with pe size 1001, ke size 2002 ;  $  TAB1 for a = 0 to n exclusive, read pe[a] ;  $  TAB1 for a = 0 to k exclusive, read ke[a] ;  $  TAB1 sort elements from pe to pe+n ;  $  TAB1 sort elements from ke to pe+k ;  $  TAB1 create long long mins with mins = 99999999999999 ;  $  TAB1 for a = 0 to k - n + 1 exclusive ;  $  TAB2 create long long tmp with tmp = 0 ;  $  TAB2 for b = 0 to n exclusive, set tmp to maximum of tmp and absolute value of ( pe[b] - ke[a + b] ) + absolute value of ( ke[a + b] - p ) ;  $  TAB2 set mins to minimum of tmp and mins ;  $  TAB1 print mins print newline ;
TAB0 mod = const int with mod = 1000000007 ;  $  TAB0 inf = const long long with inf = 1000000000000 ;  $  TAB1 n, k, p = int ;  $  TAB1 read n then k then p ;  $  TAB1 A, B = vector of long longs ;  $  TAB1 for i = 0 to n ;  $  TAB2 x = long long ;  $  TAB2 read x ;  $  TAB2 append x to A ;  $  TAB1 for i = 0 to k ;  $  TAB2 x = long long ;  $  TAB2 read x ;  $  TAB2 append x to B ;  $  TAB1 sort vector A ;  $  TAB1 sort vector B ;  $  TAB1 ans = long long with ans = inf ;  $  TAB1 for i = 0 to k - n inclusive ;  $  TAB2 temp = long long with temp = 0 ;  $  TAB2 index = int with index = i ;  $  TAB2 for j = 0 to n ;  $  TAB3 temp2 = long long with temp2 = 0 ;  $  TAB3 set temp2 to the sum the absolute value of A[j] - B[index] and the absolute value of B[index] - p ;  $  TAB3 set temp to max between temp and temp2 ;  $  TAB3 increment index ;  $  TAB2 set ans to min between ans and temp ;  $  TAB1 print ans ;
TAB0 N = constant integer with value of 2e5 + 50 ;  $  TAB0 M = constant integer with value of 1e6 ;  $  TAB0 oo = constant long long with value of 1e18 ;  $  TAB0 mod = constant integer with value of 1e9 + 7 ;  $  TAB0 a, b = long long arrays with a length of 1010 and b length of 2010 ;  $  TAB0 n, k, p = long long ;  $  TAB0 in function can that takes long long variable md and returns a boolean ;  $  TAB1 id = long long with value of 0 ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 if the absolute value of (a[id] - b[i]) plus the absolute value of (b[i] - p) is greater than md then continue ;  $  TAB2 add 1 to id ;  $  TAB2 if id equals n return 1 ;  $  TAB1 read n, k, and p ;  $  TAB1 for i = 0 to n exclusive read a[i] ;  $  TAB1 for i = 0 to k exclusive read b[i] ;  $  TAB1 sort the first n elements of a ;  $  TAB1 sort the first k elements of b ;  $  TAB1 md, lo, hi, and ans = long long with lo value of 0 and hi value of 2e9 and ans value of 0 ;  $  TAB1 while lo is less than or equal to hi ;  $  TAB2 set md to half of lo plus hi ;  $  TAB2 if call can with argument of md is true ;  $  TAB3 set hi to md minus 1 ;  $  TAB3 set ans to md ;  $  TAB2 else ;  $  TAB3 set lo to md plus 1 ;  $  TAB1 print ans ;
TAB0 N = const long long with N = 1000 + 5 ;  $  TAB0 N = const long long with K = 2000 + 5 ;  $  TAB0 n, m, fi = long long ;  $  TAB0 p = array of N long long ;  $  TAB0 k = array of K long long ;  $  TAB0 in the function di that takes long long a and b and returns long long ;  $  TAB1 return abs of a - b ;  $  TAB0 in the function ok that takes long long t and returns bool ;  $  TAB1 set poz to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if poz > m return 0 ;  $  TAB2 while 1 ;  $  TAB3 tot = long long with tot = di of p[i] and k[poz] + di of k[poz] and fi ;  $  TAB3 if tot <= t break loop ;  $  TAB3 increment poz ;  $  TAB3 if poz > m return 0 ;  $  TAB2 increment poz ;  $  TAB1 return 1 ;  $  TAB1 read n, m, fi ;  $  TAB1 for i = 1 to n inclusive read p[i] ;  $  TAB1 for i = 1 to m inclusive read k[i] ;  $  TAB1 sort p + 1 and p + n + 1 ;  $  TAB1 sort k + 1 and k + m + 1 ;  $  TAB1 r, pas = long long with r = -1, pas = 1LL << 60 ;  $  TAB1 while pas ;  $  TAB2 if ok(r + pas) is 0 r = r + pas ;  $  TAB2 pas = pas >> 1 ;  $  TAB1 increment r ;  $  TAB1 print r ;
TAB0 create long longs n, k, p ;  $  TAB0 create long long arrays a, b, with a size 1005, b size 2005 ;  $  TAB0 declare moze with long long x as argument, returning boolean ;  $  TAB1 create long long h with h = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if h is k, return false from function ;  $  TAB2 create boolean sat with sat = false ;  $  TAB2 while h is less than k ;  $  TAB3 create long long d with d = absolute value of ( a[i] - b[h] ) + absolute value of (b[h]-p) ;  $  TAB3 increment h ;  $  TAB3 if d is less than or equal to x ;  $  TAB4 set sat to true ;  $  TAB4 break loop ;  $  TAB2 if not sat, return false from function ;  $  TAB1 return true from function ;  $  TAB1 read n read k read p ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to k exclusive, read b[i] ;  $  TAB1 sort elements from a to a + n ;  $  TAB1 sort elements from b to b + n ;  $  TAB1 create long longs l, r, o, with l = 0, r = 4e9, o = -1 ;  $  TAB1 while l is less than or equal to r ;  $  TAB2 create long long m with m = ( l + r ) bitshift right 1 ;  $  TAB2 if result of run moze with m as argument is true ;  $  TAB3 set o to m ;  $  TAB3 set r to m - 1 ;  $  TAB2 else ;  $  TAB3 set l to m + 1 ;  $  TAB1 print o print '\n' ;
TAB0 MOD = const int with MOD = 1e9 + 7 ;  $  TAB0 INF = const long long int with INF = 1e18 ;  $  TAB0 keya, per = vectors of long long int ;  $  TAB0 ans = long long int with ans = INF ;  $  TAB1 i, j, k, n, p, x = integers ;  $  TAB1 read n, k, p ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 append x in per ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read x ;  $  TAB2 append x in key ;  $  TAB1 sort begin of per and end of per ;  $  TAB1 sort begin of key and end of key ;  $  TAB1 for j = 0 to j + n - 1 < k ;  $  TAB2 now = long long int with now = 0 ;  $  TAB2 for i = 0 to n exclusive now = max of now and abs(per[i] - key[j + i]) + abs(key[j + i] - p) ;  $  TAB2 ans = min of ans and now ;  $  TAB1 print ans ;
TAB1 create long longs n, k, p ;  $  TAB1 read n read k read p ;  $  TAB1 create long long arrays pe, ke, with pe size 1001, ke size 2002 ;  $  TAB1 for a = 0 to n exclusive, read pe[a] ;  $  TAB1 for a = 0 to k exclusive, read ke[a] ;  $  TAB1 sort elements from pe to pe + n ;  $  TAB1 sort elements from ke to ke + n ;  $  TAB1 create long long mins with mins = 99999999999999 ;  $  TAB1 for a = 0 to k - n + 1 exclusive ;  $  TAB2 create long long tmp with tmp = 0 ;  $  TAB2 for b = 0 to n exclusive, set tmp to maximum of ( tmp and absolute value of ( pe[b] - ke[a + b] ) + absolute value of ( ke[a + b] - p ) ) ;  $  TAB2 set mins to minimum of tmp and mins ;  $  TAB1 print mins print newline ;
TAB0 n, k, p = integer ;  $  TAB0 person = long long array of size 1005, key = long long array of size 2005 ;  $  TAB0 ans, tmp = long long ;  $  TAB1 while read n, k, p ;  $  TAB2 ans = 99999999999999LL ;  $  TAB2 for i = 0 to n exclusive, read person[i] ;  $  TAB2 for i = 0 to k exclusive, read key[i] ;  $  TAB2 sort person and person + n ;  $  TAB2 sort key and key + k ;  $  TAB2 for i = 0 to i + n <= k ;  $  TAB3 tmp = 0 ;  $  TAB3 for j = 0 to n exclusive, tmp = max of tmp and abs of key[i + j] - person[j] + abs of p - key[i + j] ;  $  TAB3 ans = min of tmp and ans ;  $  TAB2 print ans ;
TAB0 create 64 bit integer infint64_t with infint64_t = 9223372036854775807LL ;  $  TAB0 declare solve with no arguments, returning void ;  $  TAB1 create 64 bit integers n, k, p ;  $  TAB1 read n read k read p ;  $  TAB1 create 64 bit integer vector a initialized with n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort elements from beginning of a to end of a ;  $  TAB1 create 64 bit integer vector b initialized with k ;  $  TAB1 for i = 0 to k exclusive, read b[i] ;  $  TAB1 sort elements from beginning of b to end of b ;  $  TAB1 create 64 bit integer best with best = infint64_t ;  $  TAB1 for i = 0 to k - n inclusive ;  $  TAB2 create 64 bit integer curWorst with curWorst = 0 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 create 64 bit integer cur with cur = absolute value of ( b[i+j] - p ) + absolute value of (b[i+j]-a[j] ) ;  $  TAB3 set curWorst to maximum of curWorst and cur ;  $  TAB2 set best to minimum of best and curWorst ;  $  TAB1 print best print newline ;  $  TAB1 run solve ;
TAB1 create long long t ;  $  TAB1 read t ;  $  TAB1 decrement t and loop further, while t > 0 ;  $  TAB2 declare long longs a and b ;  $  TAB2 read a and b ;  $  TAB2 long long c = pow(a * b, 1.0 / 3.0) ;  $  TAB2 increment c while c * c * c < a * b ;  $  TAB2 decrement c while c * c * c > a * b ;  $  TAB2 if c * c * c = a * b && a % c = 0 && b % c = 0 ;  $  TAB3 print "Yes\n" ;  $  TAB2 else ;  $  TAB3 print "No\n" ;
TAB1 let q be a long integer ;  $  TAB1 read q ;  $  TAB1 while q value is decreased by 1 ;  $  TAB2 let a, b be long integers ;  $  TAB2 read a and b ;  $  TAB2 let prod be long integer with prod = a * b ;  $  TAB2 let round1 be long integer with round1 = round(cbrt(prod)) ;  $  TAB2 if a modulus round1 is equal to 0 and b modulus round1 is equal to 0 ;  $  TAB3 if round1 is equal to 1 ;  $  TAB4 if a is equal to 1 and b is equal to 1 ;  $  TAB5 print Yes ;  $  TAB6 print newline ;  $  TAB4 else do the following ;  $  TAB5 print No ;  $  TAB6 print newline ;  $  TAB3 else do the following ;  $  TAB4 print Yes ;  $  TAB5 print newline ;  $  TAB2 else do the following ;  $  TAB3 print No ;  $  TAB4 print newline ;
TAB1 q = long long ;  $  TAB1 read q ;  $  TAB1 while q is not 0 subtract 1 from q do ;  $  TAB2 a, b = long long ;  $  TAB2 read a and b ;  $  TAB2 prod = long long with value of a*b ;  $  TAB2 round1 = long long with value of the cubic root of prod rounded to the nearest whole number ;  $  TAB2 if a mod round1 equals 0 and b mod round1 equals 0 ;  $  TAB3 if round1 equals 1 ;  $  TAB4 if a and b equal 1 ;  $  TAB5 print Yes ;  $  TAB6 print a new line ;  $  TAB4 else ;  $  TAB5 print No ;  $  TAB6 print a new line ;  $  TAB3 else ;  $  TAB4 print Yes ;  $  TAB5 print a new line ;  $  TAB2 else ;  $  TAB3 print No ;  $  TAB4 print a new line ;
TAB0 create const integer MAX = 2e5 + 7 ;  $  TAB0 create const integer INF = 0x3f3f3f3f ;  $  TAB0 declare integer variables N, M and K ;  $  TAB0 declare an arrays of integers prea and preb with size MAX ;  $  TAB0 integer function cal with integer arguments a and b and char argument c ;  $  TAB1 if c = '&', return a & b ;  $  TAB1 if c = '|', return a | b ;  $  TAB1 return a ^ b ;  $  TAB1 read N and loop further ;  $  TAB2 create integers x = 0 and y = 1023 ;  $  TAB2 for i from 0 to N exclusive ;  $  TAB3 declare character c ;  $  TAB3 declare integer a ;  $  TAB3 read c and a ;  $  TAB3 set x to cal(x, c, a) ;  $  TAB3 set y to cal(y, c, a) ;  $  TAB2 declare integers a and b = 0 and c = 1023 ;  $  TAB2 for integer i = 0 to 10 exclusive ;  $  TAB3 integer p = 1 << i ;  $  TAB3 if x & p != 0 ;  $  TAB4 if y & p != 0 ;  $  TAB5 a |= p ;  $  TAB4 else ;  $  TAB5 b |= p ;  $  TAB3 else ;  $  TAB4 if y & p = 0, set c to c ^ p ;  $  TAB2 print 3 ;  $  TAB2 print "| " and a ;  $  TAB2 print "^ " and b ;  $  TAB2 print "& " and c ;
TAB1 create long longs n, M, M2, s, with s = 0 ;  $  TAB1 create long long array t with size 100005 ;  $  TAB1 create long long array t2 with size 100005 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t[i] ;  $  TAB2 increment s by t[i] ;  $  TAB1 for i = 0 to n exclusive, read t2[i] ;  $  TAB1 sort elements from t2 to t2 + n ;  $  TAB1 if s is less than or equal to t2[n-1] + t2[n-2] ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 create long longs n, sum with sum = 0 ;  $  TAB1 read n ;  $  TAB1 create long long array a with size n ;  $  TAB1 create long long array b with size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment sum by a[i] ;  $  TAB1 for i = 0 to n exclusive, read b[i] ;  $  TAB1 sort elements from b to b + n ;  $  TAB1 print "YES" if b[n - 2] + b[n - 1] is greater than or equal to sum, else "NO", print '\n' ;
TAB0 create long long array num with 100010 elements ;  $  TAB0 function cmp with integer arguments a and b that returns boolean ;  $  TAB1 return a > b ;  $  TAB1 declare long long variable sum = 0 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 declare integer a ;  $  TAB2 read a ;  $  TAB2 increase sum by a ;  $  TAB1 read n elements into num ;  $  TAB1 sort num using cmp as comparator function ;  $  TAB1 if num[0] + num[1] >= sum ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 declare long long variables cans, sum and aux, with sum = 0 ;  $  TAB1 read cans ;  $  TAB1 val is an array of long longs with size cans + 2 ;  $  TAB1 for i = 0 to cans exclusive ;  $  TAB2 read aux ;  $  TAB2 increase sum by aux ;  $  TAB1 read val cans times ;  $  TAB1 sort val ;  $  TAB1 if sum <= val[cans - 1] + val[cans - 2] ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 let n, sum be long integers with sum is equal to 0 ;  $  TAB1 read n ;  $  TAB1 b= array of long inters of length n ;  $  TAB1 for long integer i = 0 to n exclusive ;  $  TAB2 let x be a long integer ;  $  TAB2 read x ;  $  TAB2 sum is equal to sum+x ;  $  TAB1 for long integer i = 0 to n exclusive, read ith element of b array ;  $  TAB1 sorting the data of b, b+n ;  $  TAB1 print YES if (b[n - 2] + b[n - 1] >= sum ) else print NO ;
TAB0 create constant integer N with N = 1e5 + 10 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer arrays a, b, with a size N, b size N ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment sum by a[i] ;  $  TAB1 for i = 0 to n exclusive, read b[i] ;  $  TAB1 sort elements from b to b + n using integer greater to compare ;  $  TAB1 if sum is less than or equal to (b[0] + b[1]) ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 declare constant integer N = 1e5 + 10 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create long long arrays a and b with N elements ;  $  TAB1 declare long long sum = 0 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increase sum by a[i] ;  $  TAB1 for i = 0 to n exclusive read b[i] ;  $  TAB1 sort b using greater function as comparer ;  $  TAB1 if sum <= (b[0] + b[1]) ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 let a,b, i, n be integers where a and b are arrays of length 100001 ;  $  TAB0 let s be a long integer ;  $  TAB1 read n ;  $  TAB1 for i= 1 to n inclusive ;  $  TAB2 read ith element of array a ;  $  TAB2 s is equal to s + ith element of array a ;  $  TAB1 for i = 1 to n inclusive, read ith element of array b ;  $  TAB1 sort the values b+1, b+n+1 ;  $  TAB1 if (nth term of array b + [n - 1]th term of array b is greater than or equal to s) ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 function gcd with long long arguments a and b that returns long long ;  $  TAB1 if b = 0, return a ;  $  TAB1 return gcd(b, a % b) ;  $  TAB0 function lcm with long long arguments a and b that returns long long ;  $  TAB1 return a * b / gcd(a, b) ;  $  TAB1 create long longs i and j ;  $  TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 create vectors of long long a and b with n elements each ;  $  TAB1 read n elements into a ;  $  TAB1 read n elements into b ;  $  TAB1 declare long long variable sum = 0 ;  $  TAB1 add all elements of a to the sum one by one ;  $  TAB1 sort array b ;  $  TAB1 if sum is greater than b[n - 1] + b[n - 2] ;  $  TAB2 print "NO" and a new line ;  $  TAB1 else ;  $  TAB2 print "YES" and a new line ;
TAB1 create long long integers n and k, array c with 2 elements filled with 0, and arrays a and b with size 100000 ;  $  TAB1 declare long long integer variables i, j and sum where sum = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 set sum to sum + a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 if b[i] is greater than c[0] ;  $  TAB3 c[0] = b[i] ;  $  TAB3 k = i ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if c[1] < b[i] and b[i] <= c[0] and i != k, set c[1] to b[i] ;  $  TAB1 if c[1] + c[0] >= sum ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 create long long arrays a, b, with a size 100010, b size 100010 ;  $  TAB0 declare cmp with integers a, b as arguments, returning boolean ;  $  TAB1 return a is greater than b ;  $  TAB1 create integers n, i, j ;  $  TAB1 while read n is true ;  $  TAB2 set bytes from a to size of a to value 0 ;  $  TAB2 set bytes from b to size of b to value 0 ;  $  TAB2 create double sum with sum = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a[i] ;  $  TAB3 increment sum by a[i] ;  $  TAB2 for i = 0 to n exclusive, read b[i] ;  $  TAB2 sort elements from b to b + i using cmp to compare ;  $  TAB2 if b[0] + b[1] is greater than or equal to sum ;  $  TAB3 print "YES" print newline ;  $  TAB2 else ;  $  TAB3 print "NO" print newline ;
TAB1 n, M, M2, s = long long and set s to 0 ;  $  TAB1 t = long long array of size 100005 ;  $  TAB1 t2 = long long array of size 100005 ;  $  TAB1 read n ;  $  TAB1 for long long i = 0 to n exclusive ;  $  TAB2 read t[i] ;  $  TAB2 increase s by t[i] ;  $  TAB1 for long long i = 0 to n exclusive read t2[i] ;  $  TAB1 sort the first n elements of t2 ;  $  TAB1 if s <= t2[n-1] + t2[n-2] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 create constant long long Mod with value 1e9 + 7 ;  $  TAB0 create constant double pi with value 2 * acos(0.0) ;  $  TAB0 create constant double N with value 2e5 + 5 ;  $  TAB0 arr is an integer array with size N ;  $  TAB1 create long longs n, x and s, with s = 0 ;  $  TAB1 read n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 increase s by x ;  $  TAB1 for integer i = 0 to n exclusive read arr[i] ;  $  TAB1 sort arr ;  $  TAB1 if arr[n - 1] + arr[n - 2] >= s ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 let sum and cur be long longs where sum = 0 ;  $  TAB1 for size_t = 0 to n exclusive ;  $  TAB2 read cur ;  $  TAB2 increase sum by cur ;  $  TAB1 create long longs Max1 and Max2 = -1 ;  $  TAB1 for size_t = 0 to n exclusive ;  $  TAB2 read cur ;  $  TAB2 if cur is greater than Max1 ;  $  TAB3 set Max2 to Max1 ;  $  TAB3 set value of Max1 to cur ;  $  TAB2 else if cur is greater than Max2 ;  $  TAB3 Max2 = cur ;  $  TAB1 print "YES\n" if Max2 + Max1 >= sum, else pring "NO\n" ;
TAB1 create integer x ;  $  TAB1 create long long integer k with k = 0 ;  $  TAB1 read x ;  $  TAB1 create long long integer vector v ;  $  TAB1 create integer arrays a, b, with a size x, b size x ;  $  TAB1 for i = 0 to x exclusive ;  $  TAB2 create integer s ;  $  TAB2 read s ;  $  TAB2 increment k by s ;  $  TAB1 for i = 0 to x exclusive ;  $  TAB2 create long long integer d ;  $  TAB2 read d ;  $  TAB2 add element d to end of v ;  $  TAB1 sort elements from beginning of v to end of v ;  $  TAB1 create long long integer s with s = v[x-1]+v[x-2] ;  $  TAB1 if s is greater than or equal to k ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 declare gcd with long longs a, b as arguments, returning long long ;  $  TAB1 while b is true, swap values of ( set a to a % b, and b ) ;  $  TAB1 return a ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create long long vector nums initialized with n ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create long long a ;  $  TAB2 read a ;  $  TAB2 increment sum by a ;  $  TAB1 create long longs mx1, mx2 with mx1= 0, mx2 = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read nums[i] ;  $  TAB2 if nums[i] is greater than mx1 ;  $  TAB3 set mx2 to mx1, set mx1 to nums[i] ;  $  TAB2 else if nums[i] is less than or equal to mx1 and nums[i] is greater than mx2 ;  $  TAB3 set mx2 to nums[i] ;  $  TAB1 if sum is less than or equal to mx1 + mx2 ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 n, j, minnum and ans are integers with minnum = 1000000002 and ans = 100002 ;  $  TAB0 create an arrays of ints a and flag with size 100005 ;  $  TAB1 read n ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 if minnum is greater than a[i], change minnum to a[i] ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 if a[i] = minnum ;  $  TAB3 increment j ;  $  TAB3 change flag[j] to i ;  $  TAB1 for integer i = 1 to j exclusive ;  $  TAB2 if flag[i + 1] - flag[i] is less than ans, set ans to flag[i + 1] - flag[i] ;  $  TAB1 print ans ;
TAB0 n, a, mink, pr, mind = integers with a = integer array of size 100001, mink = 2e9, pr = -1, mind = 2e9 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 mink = min of mink and a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if pr is not -1 and a[i] is mink, mind = min(mind, i - pr) ;  $  TAB2 if a[i] is mink, pr = i ;  $  TAB1 print mind ;
TAB0 create constant int maxn = 1e7 + 10 ;  $  TAB0 let int array a of size maxn ;  $  TAB0 let int n ;  $  TAB0 let integer mini = 1e9 + 10 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is less than mini, set mini to a[i] ;  $  TAB1 create int vector vec ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if mini is equal to a[i], append i to vec ;  $  TAB1 set mini to n ;  $  TAB1 for i = 0 to the size of vec exclusive, set mini to the min of mini and vec[i + 1] - vec[i] ;  $  TAB1 print mini ;
TAB1 v = long long vector ;  $  TAB1 v1 = long long vector ;  $  TAB1 i, j, n, ans, min, t, flag = long long with min = 1000000002 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n ;  $  TAB2 x = long long ;  $  TAB2 read x ;  $  TAB2 append x to v ;  $  TAB2 if x is less than min set min to x ;  $  TAB1 for i = 0 to n ;  $  TAB2 if min is v[i] append i to v1 ;  $  TAB1 set min to 1000000002 ;  $  TAB1 for i = 1 to size of v1 ;  $  TAB2 if (v1[i] - v1[i - 1]) < min set min to v1[i] - v1[i - 1] ;  $  TAB1 print min ;
TAB0 a = array of integers of length 100010 ;  $  TAB1 let n, m, j, k, l, i, o, p be integers with j = INT_MAX, l = INT_MAX ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 l is equal to minimum of l, a[i] ;  $  TAB1 k is equal to distance(a, find(a + 1, a + n + 1, l)) ;  $  TAB1 for i = k + 1 to n inclusive ;  $  TAB2 if a[i] is equal to l ;  $  TAB3 j is equal to minimum of j, i - k ;  $  TAB3 k is equal to i ;  $  TAB1 print j and newline ;
TAB0 n, a, Min, pre, ans = integers with a = array of size 100005, ans = 100005 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 Min = a[1] ;  $  TAB1 for i = 2 to n, Min = min of Min and a[i] ;  $  TAB1 for i = 1 to n ;  $  TAB2 if a[i] is Min ;  $  TAB3 if not pre ;  $  TAB4 pre = i ;  $  TAB3 else ;  $  TAB4 ans = min(ans, i - pre), pre = i ;  $  TAB1 print ans ;
TAB1 let int s = 9999999999 ;  $  TAB1 let int n ;  $  TAB1 read n ;  $  TAB1 create pair array a of int and int of size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i].first ;  $  TAB2 set a[i].second to i + 1 ;  $  TAB1 sort array a ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if a[i].first equals a[i + 1].first and a[0].first equals a[i].first, set s to min of s and a[i +1].second - a[i].second ;  $  TAB1 print s ;
TAB1 size = int and in = int array of size 100005 ;  $  TAB1 d1 = int vector ;  $  TAB1 read size ;  $  TAB1 read size values into in ;  $  TAB1 mn = int with mn = 1e9 ;  $  TAB1 for i = 0 to size ;  $  TAB2 if in[i] < mn set mn to in[i] ;  $  TAB1 for i = 0 to size ;  $  TAB2 if mn is in[i] append i to d1 ;  $  TAB1 mns = int with mns = 1e9 ;  $  TAB1 for i = 0 to size of d1 - 1 ;  $  TAB2 if absolute of d1[i] - d1[i + 1] < mns set mns to ansolute of d1[i] - d1[i + 1] ;  $  TAB1 print mns ;
TAB1 n = integer ;  $  TAB1 while read n ;  $  TAB2 v = vector of integer with v = n ;  $  TAB2 s = vector of integer with s = n ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read v[i] ;  $  TAB3 s[i] = v[i] ;  $  TAB2 sort s.begin() and s.end() ;  $  TAB2 a, b = integers ;  $  TAB2 a = s[0] ;  $  TAB2 b = s[1] ;  $  TAB2 x, y, d = integers ;  $  TAB2 d = x = y = 1000000100 ;  $  TAB2 sw = bool with sw = true ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a is v[i] ;  $  TAB4 x = i ;  $  TAB4 break loop ;  $  TAB2 for i = x + 1 to n exclusive ;  $  TAB3 if b is v[i] ;  $  TAB4 y = i ;  $  TAB4 d = min of d and abs(x - y) ;  $  TAB4 x = i ;  $  TAB2 print d ;
TAB1 n, menor, pos, ans, i = int ;  $  TAB1 read n ;  $  TAB1 V = int vector of size n ;  $  TAB1 read n values into V ;  $  TAB1 set menor to 2000000000 ;  $  TAB1 for i = 0 to n set menor to min of menor and V[i] ;  $  TAB1 for i = 0 to n ;  $  TAB2 if V[i] = menor ;  $  TAB3 set pos to i ;  $  TAB3 break ;  $  TAB1 set ans to 1000000 ;  $  TAB1 for i = pos + 1 to n ;  $  TAB2 if V[i] = menor ;  $  TAB3 if i - pos < ans set ans to i - pos ;  $  TAB3 set pos to i ;  $  TAB1 print ans ;
TAB0 create long long array a of length 100005 ;  $  TAB1 create long long a and mi, set mi to 1000000007 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n+1 exclusive ;  $  TAB2 read a[i] ;  $  TAB2 set mi to min of mi and a[i] ;  $  TAB1 set j to -1000000007 and ans to 1000000007 ;  $  TAB1 for i=1 to n+1 exclusive ;  $  TAB2 if a[i] = mi ;  $  TAB3 set ans to min of ans and i - j ;  $  TAB3 assign i to j ;  $  TAB1 print ans ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integer pointer a = new integer array size n ;  $  TAB1 declare long long integer min = 99999999999999999 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is less than min, let min = a[i] ;  $  TAB1 declare integer array p size 100000 ;  $  TAB1 declare integer c = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is min ;  $  TAB3 let p[c] be i ;  $  TAB3 increment c ;  $  TAB1 let min be 99999999999999999 ;  $  TAB1 for i = 1 to c exclusive ;  $  TAB2 declare integer r = p[i] - p[i - 1] ;  $  TAB2 if r is less than min, let min be r ;  $  TAB1 print min, newline ;
TAB0 let maxn be a constant integer with maxn = 1e6 + 7 ;  $  TAB0 let mod be a constant integer with mod = 998244353 ;  $  TAB0 read the integer data ;  $  TAB1 let c, Nig, x be integers with Nig = 1, x = 0 ;  $  TAB1 while not isdigit of c , c = getchar() ;  $  TAB1 if c is equal to - , Nig = -1, c = getchar() ;  $  TAB1 while isdigit of c, x is equal to ((x << 1) + (x << 3)) + (c ^ '0'), c is equal to getchar() ;  $  TAB1 return the value of Nig * x ;  $  TAB0 a = array of integers of length maxn ;  $  TAB1 read from n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 let minl be a integer with minl = *min_element(a + 1, a + 1 + n) ;  $  TAB1 let pos, ans be integers with pos = -1, ans = 0x3f3f3f3f ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] is equal to minl ;  $  TAB3 if ~pos ;  $  TAB4 ans is equal to minimum of ans and i - pos , pos is equal to i ;  $  TAB3 else do the following ;  $  TAB4 pos is equal to i ;  $  TAB1 print ans and new line ;
TAB0 create new array of long longs a with 200050 elements ;  $  TAB0 create new array of long longs b with size 200050 ;  $  TAB0 declare integer variable len with value 0 ;  $  TAB1 declare new integer called n ;  $  TAB1 read n ;  $  TAB1 for i from 0 to n exclusive, read standard input to a[i] ;  $  TAB1 create long long minn with value 1000000009 ;  $  TAB1 for integer i = 0 to n exclusive, set minn to min of minn and a[i] ;  $  TAB1 for integer i = 0 to n exclusive incrementing i ;  $  TAB2 if a[i] = minn ;  $  TAB3 assign i to b[len] ;  $  TAB3 increment len by one ;  $  TAB1 declare new long long called minnn = 200000050 ;  $  TAB1 in a for loop, change i from 1 to len exclusive, assigning min of minnn and b[i] - b[i - 1] to minnn on each loop ;  $  TAB1 print minnn to the standard output ;
TAB1 a, b, n, mini, ans = long long int with ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read a ;  $  TAB2 increment ans ;  $  TAB2 if i is 0 or a is less than mini ;  $  TAB3 set mini to a ;  $  TAB3 set ans to 0 ;  $  TAB3 set b to 0 ;  $  TAB2 else if a is mini ;  $  TAB3 if ans is less than b or b is 0 set b to ans ;  $  TAB3 set ans to 0 ;  $  TAB1 print b ;
TAB1 let ints n, min = INT_MAX, cnt = 0, first, last, and selisih and int array num of size 100005 ;  $  TAB1 create int has = INT_MAX and int array arrpos of size 100005 ;  $  TAB1 read n ;  $  TAB1 for x = 1 to n ;  $  TAB2 read num[x] ;  $  TAB2 if num[x] is less than min, set min to num[x] ;  $  TAB1 for x = 1 to n ;  $  TAB2 if num[x] equals min ;  $  TAB3 if cnt is equal to 0 ;  $  TAB4 set arrpos[x] to x ;  $  TAB4 set first to x ;  $  TAB3 if cnt equals 1 ;  $  TAB4 set arrpos[x] to x ;  $  TAB4 set last to x ;  $  TAB3 if cnt is greater than or equal to 2 ;  $  TAB4 set first to last ;  $  TAB4 set last to x ;  $  TAB4 set arrpos[x] to x ;  $  TAB3 increment cnt ;  $  TAB2 if cnt is greater than or equal to 2 ;  $  TAB3 set selisih to the result of arrpos[last] - arrpos[first] ;  $  TAB3 if selisih is less than has, set has to selisih ;  $  TAB1 print has ;
TAB0 a is a new array of integers with size 1e5 + 5 ;  $  TAB0 function min with long long arguments a and b that returns long long ;  $  TAB1 if a is greater than b ;  $  TAB2 return b ;  $  TAB1 else ;  $  TAB2 return a ;  $  TAB1 declare integer variable n ;  $  TAB1 read n from the user input ;  $  TAB1 declare long long m with value 1e9 + 1 ;  $  TAB1 for integer i = 1 to n inclusive incrementing i ;  $  TAB2 read input to a[i] ;  $  TAB2 change m to min of m and a[i] ;  $  TAB1 declare vector of integers called ans ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] is equal to m, push i into ans ;  $  TAB1 create new integer called mins = 1e9 ;  $  TAB1 declare integer size with value length of ans - 1 ;  $  TAB1 for i from 1 to size inclusive, assign min of mins and ans[i] - ans[i - 1] to mins ;  $  TAB1 print mins to the standard output ;
TAB1 t, n, i, x, pp, count, flag, dis, min, sum = integers with flag = 0, dis = 0, min = 0 ;  $  TAB1 v = vector of integer ;  $  TAB1 it = iterator vector of integer ;  $  TAB1 read n ;  $  TAB1 while decrement n ;  $  TAB2 read x ;  $  TAB2 append x in v ;  $  TAB1 t = pointer min_element on v.begin() and v.end() ;  $  TAB1 for i = 0 to v.size() exclusive ;  $  TAB2 if v[i] is t ;  $  TAB3 if flag is not 0 ;  $  TAB4 dis = i - pp ;  $  TAB4 if min is 0 and dis is not 0 ;  $  TAB5 min = dis ;  $  TAB4 else if min is not 0 and min > dis ;  $  TAB5 min = dis ;  $  TAB3 increment flag ;  $  TAB3 pp = i ;  $  TAB1 print min ;
TAB1 create integer x ;  $  TAB1 read x from the input ;  $  TAB1 create new array of integers ara with x elements ;  $  TAB1 create new integer maxn ;  $  TAB1 create new set of integers s ;  $  TAB1 set maxn to 1000000009 ;  $  TAB1 declare new integer variable d with value 1000000009 ;  $  TAB1 create boolean variable with name b with value 0 ;  $  TAB1 in the for loop, change integer w from 0 to x exclusive ;  $  TAB2 read variable ara[w] from the input ;  $  TAB2 if ara[w] is less than maxn, change maxn to ara[w] ;  $  TAB1 for w from 0 to x exclusive ;  $  TAB2 if ara[w] = maxn, insert w into set s ;  $  TAB1 i is a new iterator for the set of integers ;  $  TAB1 j is a new iterator for the set of integers pointed to the end of s ;  $  TAB1 decrement j ;  $  TAB1 declare ints l and m ;  $  TAB1 move i through s in a for loop ;  $  TAB2 if i is equal to j, skip the rest of the loop ;  $  TAB2 change m to the value pointed by i ;  $  TAB2 increment i ;  $  TAB2 change l to the value pointed by i ;  $  TAB2 decrement i ;  $  TAB2 if l - m is less than d, set d to (l - m) ;  $  TAB1 print d to the standard output ;
TAB0 a is a new array of integers with 300000 elements ;  $  TAB1 create ints n, m1, m2, minn and minn2 with m1 and m2 = 0, minn2 = 9999999 and minn = 9999999999 ;  $  TAB1 read standard input to n ;  $  TAB1 for i from 1 to n inclusive incrementing i ;  $  TAB2 read input to a[i] ;  $  TAB2 if minn is greater than a[i], assign a[i] to minn ;  $  TAB1 start for loop from i = 1 to n inclusive on each loop ;  $  TAB2 if a[i] is equal to minn ;  $  TAB3 if m1 is equal to 0 ;  $  TAB4 change m1 to i ;  $  TAB3 else if m2 = 0 ;  $  TAB4 assign i to m2 ;  $  TAB4 if minn2 is greater than m2 - m1, change minn2 to m2 - m1 ;  $  TAB3 else ;  $  TAB4 change m1 to m2 ;  $  TAB4 assign i to m2 ;  $  TAB4 if minn2 is greater than m2 - m1, change minn2 to m2 - m1 ;  $  TAB1 print minn2 to the standard output ;
TAB0 nums is a new vector of integers ;  $  TAB1 declare int variables n, a, last and dist ;  $  TAB1 create integer variable min with value INT_MAX ;  $  TAB1 mindist is a new integer with value INT_MAX ;  $  TAB1 read n from the user input ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 read input to a ;  $  TAB2 push a to the end of nums ;  $  TAB2 if a is less than min, set min to a ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 if nums[i] = min ;  $  TAB3 change last to i ;  $  TAB3 break ;  $  TAB1 for i from last + 1 to n exclusive incrementing i ;  $  TAB2 if nums[i] = min ;  $  TAB3 change dist to i - last ;  $  TAB3 if dist is less than mindist, change mindist to dist ;  $  TAB3 assign i to last ;  $  TAB1 print mindist to the standard output ;
TAB1 declare integer variable n and an array of integers ar with size 100010 ;  $  TAB1 read n ;  $  TAB1 read input into ar n times ;  $  TAB1 declare integer variable mn = ar[0] ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 if mn is greater than ar[i], assign ar[i] to mn ;  $  TAB1 declare integers p1, p2 and d with p1 and p2 = -1 ;  $  TAB1 create int mnd = n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 if ar[i] = mn ;  $  TAB3 assign i to p1 ;  $  TAB3 if p2 != -1 ;  $  TAB4 if mnd is greater than (p1 - p2), change mnd to p1 - p2 ;  $  TAB3 assign p1 to p2 ;  $  TAB1 print mnd ;
TAB0 n, mn, skr, mnd = integers with mn = 1e9 + 7, skr = 1e9 + 7, mnd = 1e6 ;  $  TAB0 in the function masuk that takes integer idx ;  $  TAB1 if idx < n ;  $  TAB2 ai = integer ;  $  TAB2 read ai ;  $  TAB2 mn = min of mn and ai ;  $  TAB2 masuk of idx + 1 ;  $  TAB2 if ai is mn ;  $  TAB3 mnd = min of mnd and skr - idx ;  $  TAB3 skr = idx ;  $  TAB1 read n ;  $  TAB1 masuk of 0 ;  $  TAB1 print mnd ;
TAB1 t,n,i,x,pp,count,sum=int, flag,dis,min=0 ;  $  TAB1 v=vector of int ;  $  TAB1 it=iterator on vector of int ;  $  TAB1 read n ;  $  TAB1 while decremented value of n is not zero ;  $  TAB2 read x ;  $  TAB2 put x at end of v ;  $  TAB1 t=item of v with min value ;  $  TAB1 for i=0 to size of v exclusive ;  $  TAB2 if v[i] is t ;  $  TAB3 if flag != 0 ;  $  TAB4 dis=i-pp ;  $  TAB4 if min is 0 and dis is not 0 ;  $  TAB5 min=dis ;  $  TAB4 else if min is not 0 and min>dis ;  $  TAB5 min=dis ;  $  TAB3 increment flag ;  $  TAB3 pp=i ;  $  TAB1 print min ;
TAB1 create int n, minix, p, q ;  $  TAB1 read n ;  $  TAB1 create vector int v(n) ;  $  TAB1 minix = INT_MAX ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read v[i] ;  $  TAB2 set minix to min of minix and v[i] ;  $  TAB1 assign -999999 to p ;  $  TAB1 set q to INT_MAX ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if v[i] = minix ;  $  TAB3 set q = min of q and i - p ;  $  TAB3 p=i ;  $  TAB1 print q ;
TAB0 create const int oo = 1e9 ;  $  TAB1 declare int variable n ;  $  TAB1 read n ;  $  TAB1 declare vector of integers called a with n elements ;  $  TAB1 read n elements from the input into a ;  $  TAB1 create int mn = pointer to the min element of a ;  $  TAB1 create integer ans = oo ;  $  TAB1 for i = 0 and prev = -oo while i < n, incrementing i ;  $  TAB2 if a[i] is equal to mn ;  $  TAB3 set ans to min of ans and i - prev ;  $  TAB3 set prev to i ;  $  TAB1 print ans and '\n' ;
TAB1 declare vector of long longs v ;  $  TAB1 create new vector of long longs v1 ;  $  TAB1 declare long longs i, j, n, ans, min, t and flag with min = 1000000002 ;  $  TAB1 read input to n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare long long variable x ;  $  TAB2 read from the input to x ;  $  TAB2 push x to the back of v ;  $  TAB2 if x is less than min, set min to x ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 if min = v[i], push i into v1 ;  $  TAB1 assign 1000000002 to min ;  $  TAB1 start for loop from i = 1 to length of v1 exclusive ;  $  TAB2 if (v1[i] - v1[i - 1]) is less than min, assign v1[i] - v1[i - 1] to min ;  $  TAB1 print min to the standard output ;
TAB0 arr = array of integers of length 1000000 ;  $  TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let minimum, answer be integers wih answer = (int)1e9 ;  $  TAB1 create a vector of integers with name occurrences ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if not i , minimum is equal to arr[0] ;  $  TAB2 minimum is equal to minimum of minimum, arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] is equal to minimum , push i into occurrences from back ;  $  TAB1 for i = 1 to length of occurrences exclusive , answer = minimum of answer, occurrences[i] - occurrences[i - 1] ;  $  TAB1 print answer and newline ;
TAB1 n, i = int ;  $  TAB1 a = int array of size 100005 ;  $  TAB1 loop while reading n ;  $  TAB2 Min = int with Min = 0x7fffffff ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read a[i] ;  $  TAB3 set Min to min of a[i] and Min ;  $  TAB2 ans = int with ans = 0x7fffffff ;  $  TAB2 t = int with t = -1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if a[i] is Min ;  $  TAB4 set t to i ;  $  TAB4 break ;  $  TAB2 for i = t + 1 to n inclusive ;  $  TAB3 if a[i] is Min ;  $  TAB4 set ans to min of i - t and ans ;  $  TAB4 set t to i ;  $  TAB2 print ans ;
TAB0 declare new constant integer called maxn = 1e7 + 10 ;  $  TAB0 a is a new array of integers with maxn elements ;  $  TAB0 n is a new integer variable ;  $  TAB0 create new integer variable mini = 1e9 + 10 ;  $  TAB1 read from the input to n ;  $  TAB1 start for loop from i = 0 to n exclusive ;  $  TAB2 read from the input to a[i] ;  $  TAB2 if a[i] is less than mini, assign a[i] to mini ;  $  TAB1 create new vector of integers vec ;  $  TAB1 start for loop from i = 0 to n exclusive ;  $  TAB2 if mini = a[i], add i to the end of vec ;  $  TAB1 assign n to mini ;  $  TAB1 for i from 0 to length of vec - 1 exclusive, assign min of mini and vec[i + 1] - vec[i] to mini ;  $  TAB1 print mini ;
TAB1 r, c = integers ;  $  TAB1 flag = integer with flag = -1 ;  $  TAB1 read r, c ;  $  TAB1 v = 2d character array of size [r][c] ;  $  TAB1 empt, wolf, sheep = integers with empt = 0, wolf = 0, sheep = 0 ;  $  TAB1 p = character ;  $  TAB1 for i = 0 to r exclusive ;  $  TAB2 for j = 0 to c exclusive ;  $  TAB3 read p ;  $  TAB3 if p is . ;  $  TAB4 v[i][j] = D ;  $  TAB3 else ;  $  TAB4 v[i][j] = p ;  $  TAB1 for i = 0 to r exclusive ;  $  TAB2 for j = 0 to c exclusive ;  $  TAB3 if v[i][j] is S ;  $  TAB4 if v[i - 1][j] is W and i - 1 >= 0, flag = 0 ;  $  TAB4 if v[i + 1][j] is W and i + 1 < r, flag = 0 ;  $  TAB4 if v[i][j + 1] is W and j + 1 < c, flag = 0 ;  $  TAB4 if v[i][j - 1] is W and j - 1 >= 0, flag = 0 ;  $  TAB1 if flag is 0 ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;  $  TAB2 for i = 0 to r exclusive ;  $  TAB3 for j = 0 to c exclusive, print v[i][j] ;  $  TAB3 print new line ;
TAB0 create long long a and b ;  $  TAB0 create char s[1000][1000] ;  $  TAB1 read a and b ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 for j=0 to b exclusive, read cin >> s[i][j] ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 for j=0 to b exclusive ;  $  TAB3 if s[i][j] = S ;  $  TAB4 if s[i][j + 1] = W ;  $  TAB5 print NO ;  $  TAB4 if s[i][j - 1] equal to W ;  $  TAB5 print NO ;  $  TAB4 s[i + 1][j] = W ;  $  TAB5 print NO ;  $  TAB4 if s[i - 1][j] = W ;  $  TAB5 print NO and a newline ;  $  TAB1 print YES ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 for j=0 to b exclusive ;  $  TAB3 if s[i][j] = ., set s[i][j] to D ;  $  TAB3 print s[i][j] ;  $  TAB2 print a newline ;
TAB0 declare int array freq with size 1005 ;  $  TAB1 declare int variables hh and mm ;  $  TAB1 declare double variables h, d, c and n ;  $  TAB1 declare doubles cost1 and cost2 ;  $  TAB1 read hh and mm ;  $  TAB1 read input to h, d, c and n ;  $  TAB1 declare int time = (hh * 60) + mm ;  $  TAB1 declare int buns = 0 ;  $  TAB1 declare int hunger = h ;  $  TAB1 while hunger > 0 ;  $  TAB2 subtract n from hunger ;  $  TAB2 increment buns ;  $  TAB1 assign buns * c to cost1 ;  $  TAB1 if time is less than 1200 ;  $  TAB2 set hunger to h + ((1200 - time) * d) ;  $  TAB1 else ;  $  TAB2 change hunger to h ;  $  TAB1 change buns to 0 ;  $  TAB1 while hunger > 0 ;  $  TAB2 decrease hunger by n ;  $  TAB2 increment buns ;  $  TAB1 decrease c by c * (20.0 / 100) ;  $  TAB1 change cost2 to c * buns ;  $  TAB1 change decimal precision of the output to 5, set showpoint and fixed flags and print the min of cost2 and cost1 ;
TAB0 create vector integer v ;  $  TAB0 create integer arrays num, value, with num size 51, value size 51 ;  $  TAB1 create integers n, index with index = 1 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read num[i] ;  $  TAB1 add element num[n-1] to end of v ;  $  TAB1 for i = n - 2 to 0 inclusive, decrementing i ;  $  TAB2 create integers j, flag with j = 0, flag = 0 ;  $  TAB2 while j is less than size of v ;  $  TAB3 if num[i] is v[j] ;  $  TAB4 set flag to 1 ;  $  TAB4 break loop ;  $  TAB3 increment j ;  $  TAB2 if not flag, add element num[i] to end of v ;  $  TAB1 print size of v print newline ;  $  TAB1 print v[size of v - 1] ;  $  TAB1 for i = size of v - 2 to 0 inclusive, decrementing i, print " " print v[i] ;  $  TAB1 print newline ;
TAB0 create integer array a with size 555 ;  $  TAB0 create boolean array vis with size 1005 ;  $  TAB0 create integer vector s ;  $  TAB1 create integer n, tot with tot = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = n - 1 to 0 inclusive, decrementing i ;  $  TAB2 if vis[a[i]] is false ;  $  TAB3 add element a[i] to end of s ;  $  TAB3 set vis[a[i]] to true ;  $  TAB1 create integer len with len = size of s ;  $  TAB1 print len print newline ;  $  TAB1 for i = len - 1 to 0 exclusive, decrementing i, print s[i] print " " ;  $  TAB1 print s[0] print newline ;
TAB0 create integer array num of size 100 ;  $  TAB0 create integer array nn of size 100 ;  $  TAB0 create integer cnt with cnt = 0 ;  $  TAB0 create integer cc1 with cc1 = 0 ;  $  TAB0 declare num_find with integer in as argument, returning boolean ;  $  TAB1 for i = 0 to cnt exclusive ;  $  TAB2 if num[i] is in, return true from function ;  $  TAB1 return false from function ;  $  TAB1 create integer N ;  $  TAB1 read N ;  $  TAB1 for i = 0 to N exclusive ;  $  TAB2 read nn[cc1] ;  $  TAB2 increment cc1 ;  $  TAB1 for i = N - 1 to 0 inclusive, decrement i ;  $  TAB2 create integer tmp ;  $  TAB2 set tmp to nn[i] ;  $  TAB2 if result of num_find with tmp as argument is false ;  $  TAB3 set num[cnt] is tmp ;  $  TAB3 increment cnt ;  $  TAB1 print cnt print newlien ;  $  TAB1 for i = cnt - 1 to 0 exclusive, decrementing i, print num[i] print " " ;  $  TAB1 print num[0] print newline ;
TAB0 declare integers n and t, integer arrays a and b with 100 elements and an array of integers visit with 1010 elements ;  $  TAB1 while reading n ;  $  TAB2 call memset with arguments a, 0 and sizeof(a) ;  $  TAB2 call memset with arguments b, 0 and sizeof(b) ;  $  TAB2 call memset with arguments visit, 0 and sizeof(visit) ;  $  TAB2 t = 0 ;  $  TAB2 for i = 0 to n exclusive read a[i] ;  $  TAB2 declare integer variable p = n ;  $  TAB2 for i = n - 1 to 0 inclusive counting down ;  $  TAB3 if visit[a[i]] is greater than 0 ;  $  TAB4 decrement p ;  $  TAB4 continue the loop ;  $  TAB3 set b[t] to a[i] and increment t ;  $  TAB3 increase visit[a[i]] ;  $  TAB2 print p ;  $  TAB2 for i = t - 1 to 0 inclusive counting down ;  $  TAB3 print b[i] ;  $  TAB3 if i != 0, print " " ;  $  TAB2 print new line ;
TAB1 create integer arrays a, b with a size 5000, b size 5000 ;  $  TAB1 create integer array flag of size 5000 ;  $  TAB1 set bytes from flag to size of flag to value true ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 create integer len with len = 0 ;  $  TAB1 for i = n - 1 to 0 inclusive, decrementing i ;  $  TAB2 if flag[a[i]] is true ;  $  TAB3 increment len ;  $  TAB3 set b[len] to a[i] ;  $  TAB3 set flag[a[i]] to false ;  $  TAB1 print len print newline ;  $  TAB1 for i = len to 1 inclusive, decrementing i ;  $  TAB2 if i is not 1 ;  $  TAB3 print b[i] print ' ' ;  $  TAB2 else ;  $  TAB3 print b[i] print newline ;
TAB0 let n be integer ;  $  TAB0 A = array of integers of size 60 ;  $  TAB0 let sum be integer ;  $  TAB0 let B be an array of integers of size 60 ;  $  TAB1 read n ;  $  TAB1 sum = n ;  $  TAB1 create integer t with value 0 ;  $  TAB1 read n elements from the input to A ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 for integer x = i + 1 to n exclusive ;  $  TAB3 if A[i] = A[x] ;  $  TAB4 assign value of 0 to the A[i] ;  $  TAB4 assign value of i to the B[t] ;  $  TAB4 increase t ;  $  TAB4 stop the loop ;  $  TAB1 for i = t - 1 to 0 ;  $  TAB2 decrease sum by one ;  $  TAB2 for integer x = B[i] to n exclusive ;  $  TAB3 A[x] = A[x + 1] ;  $  TAB3 A[x + 1] = 0 ;  $  TAB1 print sum and a new line ;  $  TAB1 for i = 0 to sum exclusive ;  $  TAB2 print A[i] ;  $  TAB2 if i != sum - 1, print " " ;  $  TAB1 print new line ;
TAB1 let n and sum be integers, with sum = 0; a and b are arrays of integers with size 50 and v is an array of integers with size 1001 filled with 0 ;  $  TAB1 read n ;  $  TAB1 read n elements into a ;  $  TAB1 for integer i = n - 1 to 0 inclusive counting down ;  $  TAB2 if v[a[i]] is 0 ;  $  TAB3 set value of v[a[i]] to 1 ;  $  TAB3 set value of b[sum] to a[i] ;  $  TAB3 increment sum ;  $  TAB1 print sum and a new line ;  $  TAB1 for i = sum - 1 to 0 exclusive counting down, print b[i] and ' ' ;  $  TAB1 print b[0] and a new line ;
TAB0 create constant integer Max with Max = 1e3 + 10 ;  $  TAB0 create integer arrays a, ans, flag, with a size Max, ans size Max, flag size Max ;  $  TAB1 create integers n, tot with tot = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = n to 1 inclusive, decrementing i ;  $  TAB2 if not flag[a[i]] ;  $  TAB3 set flag[a[i]] to 1 ;  $  TAB3 set ans[increment tot] to a[i] ;  $  TAB1 print tot print newline ;  $  TAB1 for i = tot - 1 to 0 inclusive, decrementing i ;  $  TAB2 print ans[i] ;  $  TAB2 if i is not 0 print " " ;  $  TAB1 print newline ;
TAB1 create long long integer n ;  $  TAB1 while read n ;  $  TAB2 if n is 0 ;  $  TAB3 print 0 print newline ;  $  TAB2 else if ( n + 1 ) % 2 is 0 ;  $  TAB3 print ( n + 1 ) / 2 print newline ;  $  TAB2 else ;  $  TAB3 print n + 1 print newline ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n = 0 ;  $  TAB2 print n and a newline ;  $  TAB1 else ;  $  TAB2 if n is even ;  $  TAB3 print n + 1 and a newline ;  $  TAB2 otherwise ;  $  TAB3 print (n + 1) / 2 and a newline ;
TAB1 declare int64_t N ;  $  TAB1 read N ;  $  TAB1 declare int64_t ans = 0 if N = 0, (N + 1) / 2 if N is even, or N + 1 if N is odd ;  $  TAB1 print ans ;
TAB0 create long long n ;  $  TAB1 read n ;  $  TAB1 if n = 0 ;  $  TAB2 print 0 ;  $  TAB1 else if n is even ;  $  TAB2 print n+1 ;  $  TAB1 otherwise ;  $  TAB2 print (n+1)/2 and a newline ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 if (n + 1) modulo 2 is equal to 0 ;  $  TAB2 print (n + 1) / 2 and a new line ;  $  TAB1 else do the following ;  $  TAB2 if n is equal to 0 ;  $  TAB3 print 0 and a new line ;  $  TAB2 else do the following ;  $  TAB3 print n + 1 and a new line ;
TAB1 let n be a unsigned long integer ;  $  TAB1 read n ;  $  TAB1 increase n value by 1 ;  $  TAB1 if (n modulus 2 is equal to 0) ;  $  TAB2 print n / 2 and newline ;  $  TAB1 else if (n is equal to 1) ;  $  TAB2 print 0 and newline ;  $  TAB1 else do the following ;  $  TAB2 print n and newline ;
TAB0 integer function gcd with integer arguments a and b ;  $  TAB1 if b = 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 call gcd with arguments b and a % b ;  $  TAB1 declare long long integer variable n ;  $  TAB1 read n and keep looping ;  $  TAB2 increase n by one ;  $  TAB2 if n = 1 ;  $  TAB3 print "0" ;  $  TAB2 else if n is even ;  $  TAB3 print n / 2 ;  $  TAB2 else ;  $  TAB3 print n ;  $  TAB2 print new line ;
TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 if n = 0 ;  $  TAB2 print 0 and "\n" ;  $  TAB1 if n = 1 ;  $  TAB2 print 1 and "\n" ;  $  TAB1 if odd is greater than even ;  $  TAB2 print (n + 1) / 2 and "\n" ;  $  TAB1 else ;  $  TAB2 print n + 1 and "\n" ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n is equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 if n is even ;  $  TAB2 print n+1 and a newline ;  $  TAB1 else ;  $  TAB2 print (n+1)/2 ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 print if not n then 0 else if n & 1 then (n + 1) >> 1 else n + 1 ;
TAB1 create long long int s, n, i, j, p, h, set h to 0 ;  $  TAB1 read n ;  $  TAB1 if n equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else if n is even ;  $  TAB2 print n +1 ;  $  TAB1 else ;  $  TAB2 print (n+1)/2 and a newline ;
TAB0 create long longs n, p, b and q ;  $  TAB0 long long function gcd with long long arguments a and b ;  $  TAB1 return a if b = 0 ;  $  TAB1 return gcd(b, a % b) ;  $  TAB1 read n ;  $  TAB1 decrement n and loop further, while n > 0 ;  $  TAB2 read from the input to p, q and b ;  $  TAB2 declare long long variable tmp = gcd(p,q) ;  $  TAB2 divide p by tmp ;  $  TAB2 divide q by tmp ;  $  TAB2 create long long div = gcd of b and q ;  $  TAB2 while div = (gcd(b, q) != 1) ;  $  TAB3 while q % div is 0, divide q by div ;  $  TAB2 if q is 1 ;  $  TAB3 print "Finite" ;  $  TAB2 else ;  $  TAB3 print "Infinite" ;
TAB0 n = integer ;  $  TAB0 p, q, b = long long ;  $  TAB1 read n ;  $  TAB1 while decrement n ;  $  TAB2 read p, q, b ;  $  TAB2 if p modulo q is 0 ;  $  TAB3 print Finite ;  $  TAB3 continue iteration ;  $  TAB2 q = q / gcd of p and q ;  $  TAB2 g = long long ;  $  TAB2 while 1 ;  $  TAB3 g = gcd of q and b ;  $  TAB3 if g is 1, break loop ;  $  TAB3 while q modulo g is 0, q = q / g ;  $  TAB2 if q is not 1 ;  $  TAB3 print Infinite ;  $  TAB2 else ;  $  TAB3 print Finite ;
TAB0 N = integer ;  $  TAB0 P, Q, B = long long ;  $  TAB0 in the function gcd that takes long long x, y and returns long long ;  $  TAB1 if y is 0, return x ;  $  TAB1 return gcd of y and x modulo y ;  $  TAB1 read N ;  $  TAB1 while decrement N ;  $  TAB2 read P, Q, B ;  $  TAB2 P = P modulo Q ;  $  TAB2 G = long long with G = gcd of P and Q ;  $  TAB2 Q = Q / G ;  $  TAB2 C = long long with C = gcd of B and Q ;  $  TAB2 while C is not 1 ;  $  TAB3 Q = Q / C ;  $  TAB3 C = gcd of C and Q ;  $  TAB2 if Q is not 1 ;  $  TAB3 print Infinite ;  $  TAB2 else ;  $  TAB3 print Finite ;
TAB1 declare long longs n, p, q and b ;  $  TAB1 read input to n ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 read p, q and b from the input ;  $  TAB2 declare long long variable t = __gcd of p and q ;  $  TAB2 divide q by t ;  $  TAB2 assign b to t ;  $  TAB2 while q != 1 ;  $  TAB3 assign result of __gcd(q,t) to t ;  $  TAB3 divide q by t ;  $  TAB3 break if t = 1 ;  $  TAB2 if q = 1 ;  $  TAB3 print "Finite\n" ;  $  TAB2 else ;  $  TAB3 print "Infinite\n" ;
TAB0 in the function freac ;  $  TAB0 DX = array of const integers with DX = +1, 0, -1, 0, +1, +1, -1, -1 ;  $  TAB0 DX = array of const integers with DY = 0, +1, 0, -1, +1, -1, +1, -1 ;  $  TAB0 INF = const integer with INF = cast 1e9 + 123 from integer ;  $  TAB0 INFL = const long long with INFL = cast 1e18 + 123 from long long ;  $  TAB0 EPS = const double with EPS = 1e-9 ;  $  TAB0 in the function lifestyle ;  $  TAB1 call lifestyle ;  $  TAB1 call freac ;  $  TAB1 n = integer ;  $  TAB1 p, q, b = long long ;  $  TAB1 read n ;  $  TAB1 while decrement n ;  $  TAB2 read p, q, b ;  $  TAB2 g = long long with g = gcd of p and q ;  $  TAB2 q = q / g ;  $  TAB2 while b is not 1 ;  $  TAB3 while q modulo b is 0, q = q / b ;  $  TAB3 b = gcd of q and b ;  $  TAB2 if q is 1 print Finite else print Infinite ;  $  TAB1 return false ;
TAB0 declare int n ;  $  TAB0 declare long longs p, q, and b ;  $  TAB0 declare long long NWD with long long x and long long y ;  $  TAB1 if y is 0 ;  $  TAB2 return x ;  $  TAB1 else ;  $  TAB2 return the NWD of y, and x mod y ;  $  TAB1 input n ;  $  TAB1 loop i between 1 and n inclusive ;  $  TAB2 input p, q, and b ;  $  TAB2 declare long long blep to be NWD of p and q ;  $  TAB2 divide q by q over blep ;  $  TAB2 set blep to NWD of q and b ;  $  TAB2 while blep is more than 1 ;  $  TAB3 while q mod blep is zero, then set q to q over blep ;  $  TAB3 set blep to NWD of q and b ;  $  TAB2 if q is greater than 1 ;  $  TAB3 output "Infinite" ;  $  TAB2 else ;  $  TAB3 output "Finite" ;
TAB0 in function gcd taking two long longs a and b and returning a long long ;  $  TAB1 return __gcd of a and b ;  $  TAB0 in function solve returning a bool ;  $  TAB1 p, q, b = long long ;  $  TAB1 read p then q then b ;  $  TAB1 if p is 0 then return true ;  $  TAB1 gc = long long with gc = gcd of p and q ;  $  TAB1 set p to p / gc ;  $  TAB1 set q to q / gc ;  $  TAB1 x = long long ;  $  TAB1 loop while setting x to gcd of q and b and x is greater than 1 ;  $  TAB2 loop while q mod x is 0 set q to q / x ;  $  TAB2 set x to gcd of q and b ;  $  TAB1 return true if q is 1 else return false ;  $  TAB1 t = int ;  $  TAB1 read t ;  $  TAB1 loop t times ;  $  TAB2 is = bool with is = solve ;  $  TAB2 print "Finite" if is is true else print "Infinte" ;
TAB0 create long longs p, q, k ;  $  TAB0 declare gcd with long longs a, b as arguments, returning long long ;  $  TAB1 return a if b is 0, else result of run gcd with b, a % b as arguments ;  $  TAB0 declare inline rd with no arguments, returning long long ;  $  TAB1 create long longs x, f, with x = 0, f = 1 ;  $  TAB1 create character ch with ch = getchar ;  $  TAB1 while ch is greater than '9' or ch is less than '0' ;  $  TAB2 if ch is '-', set f to -1 ;  $  TAB2 set ch to read character ;  $  TAB1 while ch is greater than or equal to '0' and ch is less than or equal to '9' ;  $  TAB2 set x to ( x bitshift left 1 ) + ( x bitshift left 3 ) + ch - '0' ;  $  TAB2 set ch to read character ;  $  TAB1 return x * f from function ;  $  TAB0 declare inline solve with no arguments, returning void ;  $  TAB1 set p to result of run rd, set q to result of run rd, set k to result of run rd ;  $  TAB1 create long long t with t = result of run gcd with p, q as arguments ;  $  TAB1 set q to q / t ;  $  TAB1 while ( set t to result of run gcd with k, q as arguments ) is not 1 ;  $  TAB2 while ( q % t is 0 ) set q to q / t ;  $  TAB1 print "Finite" if q is 1, else "Infinite" ;  $  TAB1 for T = result of run rd to T, decrementing T, run solve ;
TAB0 in function compare taking two pointers to const void x1 and x2 and returning an int ;  $  TAB1 return value of x1 as pointer to in - value of x2 as pointer to int ;  $  TAB1 N = int ;  $  TAB1 final = int ;  $  TAB1 read N ;  $  TAB1 massiv = int array of size N ;  $  TAB1 d = int ;  $  TAB1 R = int ;  $  TAB1 for R = 0 to N ;  $  TAB2 read d ;  $  TAB2 set massiv[R] to d ;  $  TAB1 call qsort on massiv, N, sizeof of int and compare ;  $  TAB1 if N is even ;  $  TAB2 set final to massiv[R / 2 - 1] ;  $  TAB1 else ;  $  TAB2 set final to massiv[R / 2] ;  $  TAB1 print final ;
TAB1 declare long long n and an array of long longs arr with 1001 element ;  $  TAB1 read n ;  $  TAB1 for i from 0 to n exclusive, read arr[i] ;  $  TAB1 sort arr ;  $  TAB1 if n is even ;  $  TAB2 print arr[(n / 2) - 1] ;  $  TAB1 else ;  $  TAB2 print arr[n / 2] ;
TAB1 create integer array a with size 1005 ;  $  TAB1 create integer n ;  $  TAB1 create integer sum with sum = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort elements from a to a + n ;  $  TAB1 if n % 2 ;  $  TAB2 print a[n / 2] print newline ;  $  TAB1 else ;  $  TAB2 print a[n/2 - 1] print newline ;
TAB0 create constant integer N with N = 100010 ;  $  TAB0 create integer array a with size N ;  $  TAB1 create integer N ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 sort elements from a + 1 to a + n + 1 ;  $  TAB1 print a[(n + 1) / 2] print "\n" ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 v=vector of int ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 x=int ;  $  TAB2 read x ;  $  TAB2 add x at end of v ;  $  TAB1 sort first n items of v in numeric ascending order ;  $  TAB1 turn=0 ;  $  TAB1 while size of v is not 1 ;  $  TAB2 if turn is even ;  $  TAB3 erase first item of v ;  $  TAB2 else ;  $  TAB3 pop last item of v ;  $  TAB2 turn=(incremented value of turn) modulo 2 ;  $  TAB1 print first item of v ;
TAB1 create int n, a[1001] ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive, read a[i] ;  $  TAB1 sort elements bewteen a+1 and a+n+1 ;  $  TAB1 if n is even ;  $  TAB2 print a[n / 2] ;  $  TAB1 otherwise ;  $  TAB2 print a[n / 2 + 1] and a newline ;
TAB0 create long int array arr with size 1001 ;  $  TAB1 create integers n, i and mid ;  $  TAB1 read input to n ;  $  TAB1 for i from 0 to n exclusive, read arr[i] ;  $  TAB1 sort arr ;  $  TAB1 mid = n / 2 rounded up ;  $  TAB1 print arr[mid - 1] ;
TAB0 maxn = const integer with maxn = 1e3 + 10 ;  $  TAB1 n = integer ;  $  TAB1 a = integer array of size maxn ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 sort a + 1 and a + n + 1 ;  $  TAB1 print a[(n + 1) / 2] ;
TAB1 declare integer variable n ;  $  TAB1 read input to n ;  $  TAB1 declare vector of integers a with size n ;  $  TAB1 for i from 0 to n exclusive, read a[i] ;  $  TAB1 sort a ;  $  TAB1 create integer idx = (length of a - 1) / 2 ;  $  TAB1 print a[idx] ;
TAB1 let int n ;  $  TAB1 read n ;  $  TAB1 create int array a of size n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 for j = 0 to n - i - 1 exclusive ;  $  TAB3 if a[j] is greater than a[j + 1], swap values between a[j] and a[j + 1] ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 print a[n / 2 - 1] ;  $  TAB1 else ;  $  TAB2 print a[n / 2] ;
TAB1 let int n and int array a of size 1110 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort array a ;  $  TAB1 print a[(n - 1) / 2] ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create vector of integers v with size n ;  $  TAB1 read n elements into v ;  $  TAB1 sort v ;  $  TAB1 for i from 0 to n - 1 exclusive ;  $  TAB2 if i is odd ;  $  TAB3 remove first element from v ;  $  TAB2 else ;  $  TAB3 remove the last element from v ;  $  TAB1 print the first element of v ;
