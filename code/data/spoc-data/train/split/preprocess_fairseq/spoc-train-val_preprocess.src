TAB1 let a, b, c, d, e be integers ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read c ;  $  TAB1 read d ;  $  TAB1 read e ;  $  TAB1 if (a + b + c + d + e) modulo 5 is not 0 or (a + b + c + d + e) / 5 is 0 ;  $  TAB2 print -1 ;  $  TAB1 else do the following ;  $  TAB2 print (a + b + c + d + e)/5 ;
TAB1 declare integer variable sum = 0 and an array of integers arr with size 5 ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 increase sum by arr[i] ;  $  TAB1 float ans = sum / 5 ;  $  TAB1 if sum = 0 ;  $  TAB2 print -1 ;  $  TAB1 else if ans = int(ans) ;  $  TAB2 print int(ans) ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB0 cmp is a boolean function with integer arguments a and b ;  $  TAB1 return a < b ;  $  TAB1 declare integer variable sum = 0 ;  $  TAB1 create integer n ;  $  TAB1 for integer i = 0 to 5 exclusive ;  $  TAB2 read n ;  $  TAB2 increase sum by n ;  $  TAB1 if sum = 0 ;  $  TAB2 print -1 ;  $  TAB1 if sum % 5 = 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 x, i = int ;  $  TAB1 sum = int with sum = 0 ;  $  TAB1 for i = 0 to 5 ;  $  TAB2 read x ;  $  TAB2 add x to sum ;  $  TAB1 if sum is not a multiple of or if sum equals 0 ;  $  TAB2 print "-1" ;  $  TAB1 else ;  $  TAB2 print sum / 5 ;
TAB1 create int sum and a, set sum to 0 ;  $  TAB1 for i=0 to 5 exclusive ;  $  TAB2 read a ;  $  TAB2 set sum to sum + a ;  $  TAB1 if sum equal to 0 ;  $  TAB2 print -1 ;  $  TAB1 else if sum mod 5 =0 ;  $  TAB2 print sum/5 and a newline ;  $  TAB1 otherwise ;  $  TAB2 print -1 ;
TAB1 create int a and i ;  $  TAB1 set sum to 0 ;  $  TAB1 for i=0 to 5 exclusive ;  $  TAB2 read a ;  $  TAB2 sum= sum+a ;  $  TAB1 if sum mod 5 is different from 0 or sum=0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print sum/5 and a newline ;
TAB0 create int array a of length 1005 ;  $  TAB1 ans = 0 ;  $  TAB1 for i=0 to 5 exclusive ;  $  TAB2 read a[i] ;  $  TAB2 ans=ans + a[i] ;  $  TAB1 if ans equal to 0 ;  $  TAB2 print -1 ;  $  TAB1 else if ans mod 5 =0 ;  $  TAB2 print ans/5 and a newline ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 declare integers sum, c1, c2, c3, c4 and c5 ;  $  TAB1 read c1, c2, c3, c4 and c5 ;  $  TAB1 sum = c1 + c2 + c3 + c4 + c5 ;  $  TAB1 if sum != 0 && sum % 5 = 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB1 a, b, c, d, e = int ;  $  TAB1 loop while reading a then b then c then d then e ;  $  TAB2 ans = int with ans = 0 ;  $  TAB2 set ans to a + b + c + d + e ;  $  TAB2 if ans is a multiple of 5 and not 0 ;  $  TAB3 print ans / 5 ;  $  TAB2 else ;  $  TAB3 print -1 ;
TAB1 create integers a, b, c, d, e and sum ;  $  TAB1 read a, b, c, d and e ;  $  TAB1 set sum to a + b + c + d + e ;  $  TAB1 if sum > 0 && sum % 5 = 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB1 create int x and sum, sum=0 ;  $  TAB1 for i=0 to 5 exclusive ;  $  TAB2 read x ;  $  TAB2 sum= sum + x ;  $  TAB1 if sum mod 5 is different from 0 or sum = 0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print sum/5 and a newline ;
TAB1 declare integer sum = 0 and an array of integers a with size 5 ;  $  TAB1 for integer i = 0 to 5 exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increase sum by a[i] ;  $  TAB1 if sum modulo 5 = 0 && sum is not 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 create int a, n and total with n=5 and total=0 ;  $  TAB1 while decrement n ;  $  TAB2 read a ;  $  TAB2 set total to total + a ;  $  TAB1 if total =0 ;  $  TAB2 print -1 ;  $  TAB1 else if total mod 5 =0 ;  $  TAB2 print total/5 ;  $  TAB1 otherwise ;  $  TAB2 print -1 ;  $  TAB1 print a newline ;
TAB1 declare integer variables c1, c2, c3, c4 and c5 ;  $  TAB1 read c1, c2, c3, c4 and c5 ;  $  TAB1 create integer m = c1 + c2 + c3 + c4 + c5 ;  $  TAB1 if m modulo 5 is 0 and m is not 0 ;  $  TAB2 print m / 5 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB0 create long long array arr with 1000000 elements ;  $  TAB0 create set of long longs s ;  $  TAB0 mm = map from string to string ;  $  TAB0 declare string array ss with size 100000 ;  $  TAB0 declare chara array ch with size 100000 ;  $  TAB1 create integers a and res where res = 0 ;  $  TAB1 for integer i = 0 to 5 exclusive ;  $  TAB2 read a ;  $  TAB2 increase res by a ;  $  TAB1 if res = 0 || res % 5 != 0 ;  $  TAB2 print -1 ;  $  TAB1 print res / 5 ;
TAB0 declare integer variables a and sum ;  $  TAB1 for integer i = 0 to 5 exclusive ;  $  TAB2 read a ;  $  TAB2 increase sum by a ;  $  TAB1 if sum = 0 ;  $  TAB2 print -1 ;  $  TAB1 if sum % 5 = 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 print -1 ;
TAB1 create integers a, b, c, d and e ;  $  TAB1 read a, b, c, d and e ;  $  TAB1 declare integer s = sum of a, b, c, d and e ;  $  TAB1 if s modulo 5 is not 0 or s is 0 ;  $  TAB2 print "-1" ;  $  TAB1 else ;  $  TAB2 print s / 5 ;
TAB1 let s, c be integers with s equal to 0 ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 read c ;  $  TAB2 increase s by c ;  $  TAB1 if s is not a multiple of 5 or not s do the following ;  $  TAB2 print -1 ;  $  TAB1 else do the following ;  $  TAB2 print s/5 ;
TAB1 set int s to 0, c ;  $  TAB1 for i = 0 to less than 5 do the following ;  $  TAB2 read c ;  $  TAB2 s equals s plus c ;  $  TAB1 if s modulo 5 or not s is true ;  $  TAB2 output -1 ;  $  TAB1 else ;  $  TAB2 output s / 5 ;
TAB0 MOD = constant integer with value of 1e9 + 7 ;  $  TAB0 in function pow that returns a long long and takes arguments a, b = long long ;  $  TAB1 ans = long long with value of 1 ;  $  TAB1 while b is not 0 ;  $  TAB2 if b bitwise and 1 is true then set ans to (ans * a) mod MOD ;  $  TAB2 set b to b/2 ;  $  TAB2 set a to (a*a) mod MOD ;  $  TAB1 return ans ;  $  TAB1 c1, c2, c3, c4, c5 = integers ;  $  TAB1 read c1, c2, c3, c4 and c5 ;  $  TAB1 s = integer with value of c1+c2+c3+c4+c5 ;  $  TAB1 if s equals 0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 if s mod 5 equals 0 ;  $  TAB3 print s/5 ;  $  TAB2 else ;  $  TAB3 print -1 ;
TAB1 x, r = integer with r = 0 ;  $  TAB1 for i = 0 to 4 ;  $  TAB2 read x ;  $  TAB2 r = r + x ;  $  TAB1 if (r modulo 5 is 0 and r > 0), print r / 5 else print -1 ;
TAB1 integers = a,b,c,d,e ;  $  TAB1 read a,b,c,d,e ;  $  TAB1 set int sum to a + b + c + d + e ;  $  TAB1 if sum is 0 then do the following ;  $  TAB2 output -1 ;  $  TAB1 else if sum modulo 5 is 0 then ;  $  TAB2 output sum / 5 ;  $  TAB1 else ;  $  TAB2 output -1 ;
TAB1 a, b, c, d, e =integers ;  $  TAB1 Read a ;  $  TAB1 Read b ;  $  TAB1 Read c ;  $  TAB1 Read d ;  $  TAB1 Read e ;  $  TAB1 if (a + b + c + d + e) modulo 5 is not 0 OR (a + b + c + d + e) / 5 is 0 ;  $  TAB2 print -1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print (a + b + c + d + e) / 5 and a new line ;
TAB0 set const int N to 1e6 + 5 ;  $  TAB1 set int s to 0 ;  $  TAB1 for i = 0 to i is less than 5 do the following ;  $  TAB2 integers = x ;  $  TAB2 read x ;  $  TAB2 s equals s plus x ;  $  TAB1 if s is 0 or (s modulo 5) is not 0, then do the following ;  $  TAB2 output -1 ;  $  TAB1 else ;  $  TAB2 output s / 5 ;
TAB1 c1, c2, c3, c4, c5 = int ;  $  TAB1 loop while reading c1 then c2 then c3 then c4 then c5 ;  $  TAB2 s = int with s = 0 ;  $  TAB2 set s to c1 + c2 + c3 + c4 + c5 ;  $  TAB2 if s equals 0 ;  $  TAB3 print "-1" ;  $  TAB2 else ;  $  TAB3 if s is a multiple of 5 ;  $  TAB4 print s / 5 ;  $  TAB3 else ;  $  TAB4 print "-1" ;
TAB1 set int a[6], i, j, sum to 0 ;  $  TAB1 for = 0 to less than 5 do the following ;  $  TAB2 read a[i] ;  $  TAB2 set sum to sum + a[i] ;  $  TAB1 set int res to sum / 5 ;  $  TAB1 if sum = 0 or sum modulo 5 is not equal to 0 then do ;  $  TAB2 output -1 ;  $  TAB1 else if sum modulo 5 equals 0 ;  $  TAB2 output res ;
TAB0 create integer array c with size 10 ;  $  TAB1 create integers b, sum, i with b = 0, sum = 0, i = 0 ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 read c[i] ;  $  TAB2 set sum to sum + c[i] ;  $  TAB1 if sum is 0 ;  $  TAB2 print "-1" print newline ;  $  TAB1 else if sum % 5 is 0 ;  $  TAB2 print sum / 5 print newline ;  $  TAB1 else ;  $  TAB2 print "-1" print newline ;
TAB1 num = integer array of size 5, sum = integer with sum = 0 ;  $  TAB1 for i = 0 to 4 ;  $  TAB2 read num[i] ;  $  TAB2 sum = sum + num[i] ;  $  TAB1 if sum modulo 5 is 0 and sum is not 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 create integers a, b, c, d, e ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read c ;  $  TAB1 read d ;  $  TAB1 read e ;  $  TAB1 if (a + b + c + d + e) % 5 is not 0 or (a + b + c + d + e) / 5 is 0 ;  $  TAB2 print -1 print newline ;  $  TAB1 else ;  $  TAB2 print (a + b + c + d + e) / 5 print newline ;
TAB0 declare function fastIo with return type void ;  $  TAB1 call function fastIo ;  $  TAB1 create integer sum = 0 ;  $  TAB1 for i=0 to 5 exclusive ;  $  TAB2 let temp be int ;  $  TAB2 read temp ;  $  TAB2 add temp to sum ;  $  TAB1 if (sum mod 5 equals 0) and sum is greater or equal to 5 ;  $  TAB2 print sum divided by 5 ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB1 declare integers n, m ;  $  TAB1 declare integer count = 0 ;  $  TAB1 read n and m ;  $  TAB1 for a = 0, increment a ;  $  TAB2 if a * a is greater than n, end loop ;  $  TAB2 for b = 0, incrementing b ;  $  TAB3 if a + b * b is greater than m, end loop ;  $  TAB3 if a * a + b is n and a + b * b is m, increment count ;  $  TAB1 print count and '\n' ;
TAB0 declare long long int variables n and m ;  $  TAB1 read standard input to n and m ;  $  TAB1 create long long integer c = 0 ;  $  TAB1 for i = 0 to 1000 inclusive ;  $  TAB2 in a for loop, change j from 0 to 1000 inclusive ;  $  TAB3 if i * i + j = n and i + j * j is equal to m, add 1 to the variable c ;  $  TAB1 print c and "\n" to the standard output ;
TAB1 n, m = integers ;  $  TAB1 pair1, pair2 = integers with both having value of 0 ;  $  TAB1 min, max = integers ;  $  TAB1 count = integer with value of 0 ;  $  TAB1 read n and m ;  $  TAB1 if n is greater than m ;  $  TAB2 set max to n ;  $  TAB2 set min to m ;  $  TAB1 else ;  $  TAB2 set max to m ;  $  TAB2 set min to n ;  $  TAB1 for i = 0 to max inclusive ;  $  TAB2 for j = max to 0 inclusive decreasing ;  $  TAB3 if (i*i) + j equals n and i + (j * j) equals m then add 1 to count ;  $  TAB1 print count ;
TAB1 declare new int variables n and m ;  $  TAB1 read n and m from the user input ;  $  TAB1 create new integer called cnt with value 0 ;  $  TAB1 for i from 0 to n inclusive incrementing i ;  $  TAB2 new integer variable k = n - i * i ;  $  TAB2 increment cnt by one if k squared + i = m ;  $  TAB1 print cnt and '\n' ;
TAB1 let l, n, i, j, m, and cnt be ints with cnt=0 ;  $  TAB1 read n and m ;  $  TAB1 for i=0 to 1000 inclusive ;  $  TAB2 for j=0 to 1000 inclusive ;  $  TAB3 if i*i+j is n and i+j*j is m then increment cnt ;  $  TAB1 print cnt ;
TAB1 create ints n and m ;  $  TAB1 read n and m ;  $  TAB1 let p = 0 be an integer ;  $  TAB1 for a = 0 to a = 1000 exclusive ;  $  TAB2 for b = 0 to b = 1000 exclusive ;  $  TAB3 if a * a + b equals n and a + b * b equals m then increment p ;  $  TAB1 print p ;
TAB1 declare integers n, m, i, x, a, b, c = 0 ;  $  TAB1 read n, m ;  $  TAB1 let x be square root of n ;  $  TAB1 for i = 0 to x inclusive ;  $  TAB2 let b be n - i * i ;  $  TAB2 let a be m - b * b ;  $  TAB2 if a is i, increment c ;  $  TAB1 print c and newline ;
TAB0 new integer constant M = 100000 + 5 ;  $  TAB1 declare new integers n and m ;  $  TAB1 read from the input to n and m ;  $  TAB1 create variable ans = 0 with type int ;  $  TAB1 for integer a = 0 to 1000 inclusive ;  $  TAB2 for integer b = 0 to 1000 inclusive incrementing b ;  $  TAB3 if a * a + b = n and a + b * b is equal to m, increment ans ;  $  TAB1 print ans ;
TAB1 a, b, count, i, c and y are integers with count = 0 ;  $  TAB1 read user input to a and b ;  $  TAB1 assign the square root of a to c ;  $  TAB1 start for loop from i = 0 to c inclusive ;  $  TAB2 change the value of y to a - (i * i) ;  $  TAB2 if i + y squared is equal to b, increment count ;  $  TAB1 print count ;
TAB0 a = two dimensional int array of sizes 1001 and 1001 ;  $  TAB1 n, m, i, j, cnt = int with cnt = 0 ;  $  TAB1 read n then m ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 for j = 0 to m inclusive ;  $  TAB3 if i * i + j is n and i + j * j is m set a[i][j] to 1 ;  $  TAB1 for i = 0 to 1001 ;  $  TAB2 for j = 0 to 1001 ;  $  TAB3 if a[i][j] increment cnt ;  $  TAB1 print cnt ;
TAB1 n, m = integers ;  $  TAB1 ans = integer with ans = 0 ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to 1000 ;  $  TAB2 for j = 0 to 1000 ;  $  TAB3 if (((i * i) + j) is n and (i + (j * j)) is m), increment ans ;  $  TAB1 print ans ;
TAB1 TESTS=1 ;  $  TAB1 while decremented TESTS is not 0 ;  $  TAB2 count=0, n,m,i,j=int ;  $  TAB2 read n,m ;  $  TAB2 for i=0 to sqrt(n) inclusive ;  $  TAB3 for j=0 to sqrt(m) inclusive ;  $  TAB4 if i*i+j is n and i+j*j is m increment count ;  $  TAB2 print count ;
TAB1 N, M = integers ;  $  TAB1 read N, M ;  $  TAB1 ans = integer with ans = 0 ;  $  TAB1 for i = 0 to 1000 ;  $  TAB2 for j = 0 to 1000 ;  $  TAB3 if ((i * i + j is N) and (j * j + i is M)), increment ans ;  $  TAB1 print ans ;
TAB1 n,m,i,b=int, sum=0 ;  $  TAB1 read n,m ;  $  TAB1 for i=0 to sqrt(n) inclusive while i<=m ;  $  TAB2 b=n-i*i ;  $  TAB2 if i+b*b is m increment sum ;  $  TAB1 print sum ;
TAB1 n,m=long long int ;  $  TAB1 read n,m ;  $  TAB1 cp=n ;  $  TAB1 sq=long long int ;  $  TAB1 count=0 ;  $  TAB1 while n is not -1 ;  $  TAB2 sq=int(sqrt(n)) ;  $  TAB2 if sq*sq is n ;  $  TAB3 a=sq ;  $  TAB3 b=cp-n ;  $  TAB3 if a+b*b is m increment count ;  $  TAB2 decrement n ;  $  TAB1 print count ;
TAB1 n,m,i,a,b=int, cnt=0 ;  $  TAB1 read n,m ;  $  TAB1 i=0 ;  $  TAB1 while i<=sqrt(n) ;  $  TAB2 a=i ;  $  TAB2 b=n-(a*a) ;  $  TAB2 if b>=0 ;  $  TAB3 if a+b*b is m increment cnt ;  $  TAB2 increment i ;  $  TAB1 print cnt ;
TAB0 maxn = const integer with maxn = 105 ;  $  TAB0 n, m = integers ;  $  TAB0 a, b = integers ;  $  TAB0 ans = integer with ans = 0 ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to 1000 ;  $  TAB2 for j = 0 to 1000 ;  $  TAB3 if (i * i + j is n and i + j * j is m), increment ans ;  $  TAB1 print ans ;
TAB1 n, m = int ;  $  TAB1 read n and m ;  $  TAB1 c = 0 = int ;  $  TAB1 for a = 0 to 1000 inclusive ;  $  TAB2 for b = 0 to 1000 inclusive ;  $  TAB3 if a^2 _ b = n and b^2 + a = m then increment c ;  $  TAB1 print c ;
TAB0 declare min taking in ints a and b and returning integer ;  $  TAB1 return a if a is less than b or b if not ;  $  TAB1 create ints m and n ;  $  TAB1 read m and n ;  $  TAB1 create integer c = min(m, n) ;  $  TAB1 make int counter = 0 ;  $  TAB1 for i = 0 to c ;  $  TAB2 for j = 0 to c ;  $  TAB3 if i * i + j is equal to m and i + j * j is equal to n, increment counter ;  $  TAB1 print counter ;
TAB0 a is a new 2d array of integers with size 1001 by 1001 ;  $  TAB1 n, m, i, j and cnt are ints with cnt = 0 ;  $  TAB1 read input to n and m ;  $  TAB1 in a for loop, change i from 0 to n inclusive incrementing i ;  $  TAB2 for j = 0 to m inclusive ;  $  TAB3 set a[i][j] to 1 if i * i + j is equal to n and i + j * j is equal to m ;  $  TAB1 for i = 0 to 1001 exclusive ;  $  TAB2 start for loop from j = 0 to 1001 exclusive ;  $  TAB3 if a[i][j] != 0, increment cnt ;  $  TAB1 print cnt ;
TAB1 create integers n and m ;  $  TAB1 read n and m ;  $  TAB1 let cnt = 0 be an integer ;  $  TAB1 for i = 0 while i is less than or equal to n and less than or equal to m ;  $  TAB2 let b = n - i * i ;  $  TAB2 if b is positive or 0 and i + b * b is equal to m then increment cnt ;  $  TAB1 print cnt ;
TAB1 create integers n and m ;  $  TAB1 read variables n and m from the input ;  $  TAB1 declare new integer variable c = 0 ;  $  TAB1 in a for loop, change i from 0 to 1000 inclusive ;  $  TAB2 start for loop from j = 0 to 1000 inclusive incrementing j ;  $  TAB3 p is a new integer variable with value i squared + j ;  $  TAB3 new integer q with value i + j squared ;  $  TAB3 if p is equal to n and q is equal to m, increment c ;  $  TAB1 print c ;
TAB1 declare integers n, m ;  $  TAB1 read n and m ;  $  TAB1 declare integer res = 0 ;  $  TAB1 for i = 0 to 100 exclusive ;  $  TAB2 for j = 0 to 100 exclusive ;  $  TAB3 if ( i * i + j is n and i + j * j is m, increment res ;  $  TAB1 print res and newline ;
TAB1 i, s, j, k, l, n, m =integers with s = 0, j = 0, k = 0 ;  $  TAB1 Read m, n ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 set k to i * i + j ;  $  TAB3 set l to i + j * j ;  $  TAB3 if k is n and l is m, then increment s ;  $  TAB1 print s and a new line ;
TAB1 n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 solu = integer with solu = 0 ;  $  TAB1 for i = 0 to 1000 ;  $  TAB2 for j = 0 to 1000 ;  $  TAB3 if (pow(i, 2) + j is n and i + pow(j, 2) is m), increment solu ;  $  TAB1 print solu ;
TAB1 create int n and m ;  $  TAB1 read n and m ;  $  TAB1 counter =0 ;  $  TAB1 for a=0 to m inclusive ;  $  TAB2 for b=0 to n inclusive ;  $  TAB3 if a * a + b = n and a + b * b = m, increment counter ;  $  TAB1 print counter ;
TAB1 create int n and m ;  $  TAB1 read n and m ;  $  TAB1 inte_pair = 0 ;  $  TAB1 for i=0 to n inclusive and m inclusive ;  $  TAB2 for j=0 to n and m inclusive ;  $  TAB3 if (i * i) + j = n and i + (j * j) = m, increment inte_pair ;  $  TAB1 print inte_pair ;
TAB0 n, k, i, m, j = int with k = 0 ;  $  TAB1 read n then m ;  $  TAB1 iterate i while i * i <= n ;  $  TAB2 iterate j while j * j <= m ;  $  TAB3 if i * i + j is n and j * j + i is m increment k ;  $  TAB1 print k ;
TAB0 double integers = EPS = 1e-9 ;  $  TAB0 INFF set to 1000000000000000005LL = long long integer ;  $  TAB1 integers = n,m ;  $  TAB1 read n,m ;  $  TAB1 integer c = 0 ;  $  TAB1 for a = 0 to less than or equal to sqrt(n) do the following ;  $  TAB2 for b = 0 to less than or equal to sqrt(m) do the following ;  $  TAB3 if a squared+ b is n and a + b squared is m then add one to c ;  $  TAB1 output c ;
TAB1 let n, m be integers ;  $  TAB1 while read n, m ;  $  TAB2 let ans be a integer with ans = 0 ;  $  TAB2 for a = 0 to 1000 inclusive ;  $  TAB3 for b = 0 to 1000 inclusive ;  $  TAB4 if a * a + b is equal to n and b * b + a is equal to m , increment ans by 1 ;  $  TAB2 print ans and newline ;
TAB0 let m, n, a, b be integers ;  $  TAB0 let fit be a integer function ;  $  TAB1 let f1 , f2 be integers with f1 = a * a + b, f2 = a + b * b ;  $  TAB1 if f1 is equal to n and f2 is equal to m ;  $  TAB1 else if f1 is greater than n ;  $  TAB2 return 1 ;  $  TAB1 else if f2 is greater than m ;  $  TAB2 return 1 ;  $  TAB1 return -1 ;  $  TAB1 read n, m ;  $  TAB1 let cnt be a integer with cnt = 0 ;  $  TAB1 for a = 0 to 31 inclusive ;  $  TAB2 for b = 0 to 31 inclusive ;  $  TAB3 if fit() is equal to 0 ;  $  TAB4 increment cnt by 1 ;  $  TAB3 else if fit() is equal to 1 ;  $  TAB4 stop ;  $  TAB1 print cnt and newline ;
TAB1 define new integer n ;  $  TAB1 read n from the user input ;  $  TAB1 change n to n - 10 ;  $  TAB1 if n is equal to 10, return cout << 15 << endl, 0 ;  $  TAB1 if 1 <= n <= 11, return cout << 4 << endl, 0 ;  $  TAB1 print 0 ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 if n is less than or equal to 10 then do the following ;  $  TAB2 output 0 ;  $  TAB1 else ;  $  TAB2 if n >= 11 and n is less than or equal to 19 then do the following ;  $  TAB3 output 4 ;  $  TAB2 else if n is 20 then do the following ;  $  TAB3 output 15 ;  $  TAB2 else if n is 21 then do the following ;  $  TAB3 output 4 ;  $  TAB2 else if n is greater than 21 then do the following ;  $  TAB3 output 0 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 if n <= 10 or n is greater than 21 ;  $  TAB2 print 0 and newline ;  $  TAB1 else if n equals 20 ;  $  TAB2 print 15 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 4 and newline ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is less than or equal to 10 or n is greater than or equal to 22 ;  $  TAB2 print '0', newline ;  $  TAB1 else if n is 20 ;  $  TAB2 print "15", newline ;  $  TAB1 else ;  $  TAB2 print '4', newline ;
TAB1 declare integer a ;  $  TAB1 read a ;  $  TAB1 let a be a - 10 ;  $  TAB1 if a is 10 ;  $  TAB2 print ( 4 * 3 ) + 3, newline ;  $  TAB1 else if a is greater than 0 and a is less than 12 ;  $  TAB2 print 4, newline ;  $  TAB1 else ;  $  TAB2 print 0, newline ;
TAB1 n is an integer ;  $  TAB1 read n ;  $  TAB1 if n is less than 11 ;  $  TAB2 print 0 and endline ;  $  TAB1 else if n equals 11 or 21 ;  $  TAB2 print 4 and endline ;  $  TAB1 else if n is between 12 and 19 inclusive ;  $  TAB2 print 4 and endline ;  $  TAB1 else if n equals 20 ;  $  TAB2 print 15 and endline ;  $  TAB1 else ;  $  TAB2 print 0 and endline ;
TAB0 create integer N ;  $  TAB1 read N ;  $  TAB1 if N is greater than 21 ;  $  TAB2 print '0' ;  $  TAB1 if n is equal to 21 ;  $  TAB2 print '4' ;  $  TAB1 if n - 10 is equal to 10 ;  $  TAB2 print "15" ;  $  TAB1 if N is less than 20 and N is greater than 10 ;  $  TAB2 print "4" ;  $  TAB1 else do ;  $  TAB2 show "0" ;
TAB1 n, cards =integers with cards = 0 ;  $  TAB1 Read n ;  $  TAB1 set n to n - 10 ;  $  TAB1 if n is greater than or equal to 1 and n is less than 10 ;  $  TAB2 set cards to 4 ;  $  TAB1 else if n is equal to 10 ;  $  TAB2 set cards to 15 ;  $  TAB1 else if n is equal to 11 ;  $  TAB2 set cards to 4 ;  $  TAB1 else do the following ;  $  TAB2 set cards to 0 ;  $  TAB1 print cards and a new line ;
TAB1 create int n, i, n1 ;  $  TAB1 read n ;  $  TAB1 i=10 ;  $  TAB1 if n <=10 ;  $  TAB2 set n1 to 0 ;  $  TAB1 else ;  $  TAB2 if n<= 19 ;  $  TAB3 assign 4 to n1 ;  $  TAB2 else if n=20 ;  $  TAB3 set n1 to 15 ;  $  TAB2 else if n=21 ;  $  TAB3 assign 4 to n1 ;  $  TAB2 else ;  $  TAB3 set n1=0 ;  $  TAB1 print n1 ;
TAB1 let n be a integer ;  $  TAB1 while read n ;  $  TAB2 if n is less than or equal to 10 or greater than or equal to 22, ;  $  TAB3 print 0 and newline ;  $  TAB2 else if n equals 20 ;  $  TAB3 print 15 and newline ;  $  TAB2 else ;  $  TAB3 print 4 and newline ;
TAB1 create new integer n ;  $  TAB1 read variable n from the input ;  $  TAB1 if n <= 10 or n > 21 ;  $  TAB2 print 0 ;  $  TAB1 else if n is equal to 20 ;  $  TAB2 print 15 to the standard output ;  $  TAB1 else ;  $  TAB2 print 4 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 if n <= 10 or n >= 22 , print 0 and newline ;  $  TAB1 if n >= 11 and n <= 19 , print 4 and newline ;  $  TAB1 if n equals 20 , print 15 and newline ;  $  TAB1 if n equals 21 , print 4 and newline ;
TAB1 create integer variable with name n ;  $  TAB1 read user input to n ;  $  TAB1 if n <= 10 or n > 21 ;  $  TAB2 print 0 ;  $  TAB1 else if n - 10 is less than 10 ;  $  TAB2 print 4 ;  $  TAB1 else if n - 10 is equal to 10 ;  $  TAB2 print 15 ;  $  TAB1 else ;  $  TAB2 print 4 to the standard output ;
TAB1 integer as a ;  $  TAB1 read a ;  $  TAB1 if a - 10 is less than or equal to 0 or a - 10 > 11 then do the following ;  $  TAB2 output 0 ;  $  TAB1 else if a-10 is greater than 1 or a-10 is less than or equal to 9 then do the following ;  $  TAB2 output 4 ;  $  TAB1 else ;  $  TAB2 output 15 ;
TAB1 declare new integer variables n and m ;  $  TAB1 loop, reading n from the input ;  $  TAB2 change m to n - 10 ;  $  TAB2 if m > 0 and m < 10 ;  $  TAB3 print '4' ;  $  TAB2 else if m = 0 ;  $  TAB3 print '0' ;  $  TAB2 else if m is equal to 10 ;  $  TAB3 print "15" ;  $  TAB2 else if m = 11 ;  $  TAB3 print '4' ;  $  TAB2 else ;  $  TAB3 print '0' ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n <= 10 ;  $  TAB2 print 0 ;  $  TAB1 else if n < 20 ;  $  TAB2 print 4 ;  $  TAB1 else if n is 20 ;  $  TAB2 print 15 ;  $  TAB1 else if n is 21 ;  $  TAB2 print 4 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB0 create new vector of long longs v ;  $  TAB1 define new integer called n ;  $  TAB1 read standard input to n ;  $  TAB1 if n <= 10 or n > 21 ;  $  TAB2 print 0 ;  $  TAB1 decrease n by 10 ;  $  TAB1 if n = 10 ;  $  TAB2 print 15 to the output ;  $  TAB1 else ;  $  TAB2 print 4 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n <= 10 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 if n is between 11 and 19 both inclusive ;  $  TAB3 print 4 ;  $  TAB2 else ;  $  TAB3 if n = 20 ;  $  TAB4 print 15 ;  $  TAB3 else if n = 21 ;  $  TAB4 print 4 ;  $  TAB3 else ;  $  TAB4 print 0 ;
TAB1 integer as n ;  $  TAB1 while reading input n ;  $  TAB2 if n is less than 10 or n > 21 then do the following ;  $  TAB3 output 0 ;  $  TAB2 else if n is 20 then do the following ;  $  TAB3 output 15 ;  $  TAB2 else if n is 10 then do the following ;  $  TAB3 output 0 ;  $  TAB2 else ;  $  TAB3 output 4 ;
TAB0 let n be a integer ;  $  TAB1 read n ;  $  TAB1 decrement n by 10 ;  $  TAB1 if n <= 0 ;  $  TAB2 print 0 and newline ;  $  TAB1 else if n <= 9 ;  $  TAB2 print 4 and newline ;  $  TAB1 else if n equals 10 ;  $  TAB2 print 15 and newline ;  $  TAB1 else if n equals 11 ;  $  TAB2 print 4 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 0 and newline ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 if n is less than or equal to 10 or n > 21 then do the following ;  $  TAB2 output 0 ;  $  TAB1 else if n is 20 then do the following ;  $  TAB2 output 15 ;  $  TAB1 else ;  $  TAB2 output 4 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n <= 10 ;  $  TAB2 print 0 ;  $  TAB1 else if n = 11 ;  $  TAB2 print 4 ;  $  TAB1 else if n >= 12 AND n <= 19 ;  $  TAB2 print 4 ;  $  TAB1 else if n = 20 ;  $  TAB2 print 15 ;  $  TAB1 else if n = 21 ;  $  TAB2 print 4 ;  $  TAB1 else if n >= 22 ;  $  TAB2 print 0 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n <= 10 or n > 21 ;  $  TAB2 print 0 ;  $  TAB1 else if n is 20 ;  $  TAB2 print 15 ;  $  TAB1 else ;  $  TAB2 print 4 ;
TAB1 n =integer ;  $  TAB1 while reading values n ;  $  TAB2 if n is less than 20 and n is greater than 10 OR n is equal to 21 ;  $  TAB3 print 4 and a new line ;  $  TAB2 else if n is less than or equal to 10 OR n is greater than 21 ;  $  TAB3 print 0 and a new line ;  $  TAB2 else do the following ;  $  TAB3 print 15 and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 if n is less than 11 ;  $  TAB2 print 0 and a new line ;  $  TAB1 else if n is less than 20 ;  $  TAB2 print 15 and a new line ;  $  TAB1 else if n is less than 21 ;  $  TAB2 print 0 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print 4 and a new line ;
TAB1 n is a new integer variable ;  $  TAB1 read n from the user input ;  $  TAB1 declare new integer required with value n-10 ;  $  TAB1 if required <= 0 ;  $  TAB2 print "0" to the standard output ;  $  TAB1 else if required >= 1 and required <= 9 ;  $  TAB2 print "4" to the output ;  $  TAB1 else if required = 10 ;  $  TAB2 print "15" to the stdou ;  $  TAB1 else if required = 11 ;  $  TAB2 print "4" ;  $  TAB1 else if required >= 12 ;  $  TAB2 print "0" ;
TAB0 create integer n ;  $  TAB1 read n and while it's truthy, print (n > 10 && n < 22) * 4 + (n == 20) * 11 ;
TAB1 n is an integer ;  $  TAB1 read n ;  $  TAB1 if n is less than or equals 10 ;  $  TAB2 print 0 and endline ;  $  TAB1 else if n is between 11 and 19 exclusive ;  $  TAB2 print 4 and endline ;  $  TAB1 else if n equals 20 ;  $  TAB2 print 15 and endline ;  $  TAB1 else if n equals 21 ;  $  TAB2 print 4 and endline ;  $  TAB1 else ;  $  TAB2 print 0 and endline ;
TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 if n is less than or equal to 10 or n - 10 is greater than or equal to 12 ;  $  TAB2 display "0" ;  $  TAB1 if n - 10 is equal to 1 or n - 10 is equal to 11 ;  $  TAB2 show 4 ;  $  TAB1 else if n - 10 is 10 ;  $  TAB2 display 15 ;  $  TAB1 else ;  $  TAB2 show 4 ;
TAB1 n, i, j, temp, result and imin are integers with imin = 10000000 ;  $  TAB1 create new vector of integers a ;  $  TAB1 read n from the input ;  $  TAB1 add 1 as a new element to a ;  $  TAB1 in a for loop, change i from 1 to n inclusive ;  $  TAB2 read variable temp from the input ;  $  TAB2 push temp into a ;  $  TAB1 in a for loop, change i from 1 to n inclusive ;  $  TAB2 assign 0 to result ;  $  TAB2 for j from 1 to n inclusive, increase result by 2 * a[j] * (abs(i - j) + abs(j - 1) + abs(i - 1)) ;  $  TAB2 change the value of imin to min of imin and result ;  $  TAB1 print imin ;
TAB1 create new integer variable n ;  $  TAB1 read n and keep looping ;  $  TAB2 create new array of integers a with 105 elements ;  $  TAB2 start for loop from i = 1 to n inclusive, read standard input to a[i] on each loop ;  $  TAB2 Min is a new integer variable = 0x3f3f3f3f ;  $  TAB2 loop through i from i to n inclusive ;  $  TAB3 ans is a new integer = 0 ;  $  TAB3 change j in a loop from 1 to n inclusive ;  $  TAB4 if j is greater than i ;  $  TAB5 increase ans by (j - 1) * 4 * a[j] ;  $  TAB4 else ;  $  TAB5 change ans to ans + (i - 1) * 4 * a[j] ;  $  TAB3 change Min to min of Min and ans ;  $  TAB2 print Min ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 read n values into a ;  $  TAB1 mini = int with mini = 100000000 ;  $  TAB1 for i = 0 to n ;  $  TAB2 temp = int with temp = 0 ;  $  TAB2 for j = 0 to n increment temp by (absolute of (i - j) + j + i) * a[j] * 2 ;  $  TAB2 set mini to min of mini, temp ;  $  TAB1 print mini ;
TAB1 n = integer ;  $  TAB1 arr = integer array of size 10010 ;  $  TAB1 ans = integer with ans = 1000000000 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read arr[i] ;  $  TAB1 for i = 1 to n ;  $  TAB2 x = intege with x = i ;  $  TAB2 cost = integer with cost = 0 ;  $  TAB2 for j = 1 to n ;  $  TAB3 cost = cost + abs(x - j) * arr[j] ;  $  TAB3 cost = cost + ((j - 1) * arr[j]) ;  $  TAB3 cost = cost + (x - 1) * arr[j] ;  $  TAB3 cost = cost + (x - 1) * arr[j] ;  $  TAB3 cost = cost + ((j - 1) * arr[j]) ;  $  TAB3 cost = cost + abs(x - j) * arr[j] ;  $  TAB2 if (cost < ans), ans = cost ;  $  TAB1 print ans ;
TAB1 s, n and m are ints with s = 0 ;  $  TAB1 read input to n ;  $  TAB1 in a for loop, change i from 0 to n exclusive incrementing i ;  $  TAB2 read variable m from the input ;  $  TAB2 assign the new value = s + i * 4 * m to s ;  $  TAB1 print s ;
TAB0 function init ;  $  TAB0 a = integer array of size 1000 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 sum = long long with sum = 0 ;  $  TAB1 for i = 1 to n, sum = sum + 4 * (i - 1) * a[i] ;  $  TAB1 print sum ;
TAB0 create long long ints i, j and t ;  $  TAB1 n is a new long long ;  $  TAB1 read input to n ;  $  TAB1 a is a new array of long long integers with size n ;  $  TAB1 in a for loop, change i from 0 to n exclusive, read user input to a[i] on each loop ;  $  TAB1 x is a new array of long long integers with size n filled with 0 ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 start for loop from j = 0 to n exclusive, changing x[i] to x[i] + a[j] * ((abs(i - j) + abs(j) + abs(i) + abs(i) + abs(j) + abs(j - i))) on each loop ;  $  TAB1 sort x from index 0 to n ;  $  TAB1 print x[0] ;
TAB0 declare integer variables n and ans ;  $  TAB0 a is a new array of integers with 10010 elements ;  $  TAB1 read variable n from the input ;  $  TAB1 in a for loop, change i from 1 to n inclusive ;  $  TAB2 read a[i] from the user input ;  $  TAB2 increase ans by a[i] * (i - 1) * 4 ;  $  TAB1 print ans ;
TAB0 pi is a new constant integer = acos of -1 ;  $  TAB1 declare integer variable n ;  $  TAB1 read from the input to n ;  $  TAB1 declare new integers ele, flag = 0 and k = 1; create an integer array a with 200 elements ;  $  TAB1 for i from 1 to n inclusive, read a[i] from the input ;  $  TAB1 for integer i = 1 to n inclusive, add (4 * i - 4) * a[i] to ele ;  $  TAB1 print ele to the standard output ;
TAB0 create const long long int M = 998244353 ;  $  TAB0 make constant long long oo = 1e13 ;  $  TAB0 create int array a of size 1010 ;  $  TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 make int ans = 1e9 ;  $  TAB1 for x = 1 to n ;  $  TAB2 let int sum = 0 ;  $  TAB2 for j = 1 to n, add ((abs(j - x) + j - 1 + x - 1) * 2) * a[j] to sum ;  $  TAB2 set ans to min of ans and sum ;  $  TAB1 print ans ;
TAB1 create ints n and max1 and int array a of size 1000 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 for i = 1 to n ;  $  TAB2 make integer sum = 0 ;  $  TAB2 for j = 1 to n, add (fabs(i * 1.0 - j * 1.0) + j - 1 + i - 1) * 2 * a[j] to sum ;  $  TAB2 if i is equal to 1 ;  $  TAB3 set max1 to sum ;  $  TAB2 else do ;  $  TAB3 set max1 to min of max1 and sum ;  $  TAB1 print max1 ;
TAB1 declare integer variable n ;  $  TAB1 read input to n ;  $  TAB1 declare integer variable with name value ;  $  TAB1 create integer ans = 0 ;  $  TAB1 repeat the loop n times, incrementing i by 1, starting from 0 ;  $  TAB2 read value ;  $  TAB2 add i * 4 * value to ans ;  $  TAB1 print ans ;
TAB1 n, i, j, m, t, x, y = integers ;  $  TAB1 a = integer array of size 110 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 m = -1 ;  $  TAB1 for i = 1 to n ;  $  TAB2 x = 0 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 y = i - (j + 1) ;  $  TAB3 if (y < 0), y = -y ;  $  TAB3 y = y + j + i - 1 ;  $  TAB3 x = x + y * a[j] * 2 ;  $  TAB2 if (x < m or m is -1), m = x ;  $  TAB1 print m ;
TAB0 let N, A, sum ints ;  $  TAB1 read N ;  $  TAB1 for i from 0 to N exclusive ;  $  TAB2 read A ;  $  TAB2 add 4 * A * i to sum ;  $  TAB1 print sum ;
TAB1 make ints n, sum = 0, i, m, and j ;  $  TAB1 read n ;  $  TAB1 create int pointer p = new int[n] ;  $  TAB1 for i = 0 to n exclusive, read p[i] ;  $  TAB1 create integer pointer h = new int[n] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i + 1 to n exclusive, set sum to sum + 4 * j * p[j] ;  $  TAB2 for m = i - 1 to 0 exclusive by decreasing by 1, set sum to sum + 4 * i * p[m] * 4 ;  $  TAB2 set sum to i * 4 * p[i] + sum ;  $  TAB2 set h[i] to sum ;  $  TAB2 set sum to 0 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if h[0] is greater than h[i] ;  $  TAB3 create integer t ;  $  TAB3 set t to h[0] ;  $  TAB3 set h[0] to h[i] ;  $  TAB3 set h[i] to t ;  $  TAB1 display h[0] ;
TAB0 declare constant integer M = 105 ;  $  TAB0 declare integer array a size M ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integer Min = 0x3f3f3f3f ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare integer sum = 0 ;  $  TAB2 for j = 1 to n inclusive, increment sum by ( absolute value of ( i - j ) - 2 + j + i ) * a[j] * 2 ;  $  TAB2 let min be minimum of sum and Min ;  $  TAB1 print Min and newline ;
TAB0 maxn = 1e4 + 5 = int const ;  $  TAB0 let num be an int array of size maxn with num[0] = 0 ;  $  TAB0 let n, ans be ints with ans = 10000000 ;  $  TAB1 read n ;  $  TAB1 read the first n+1 elements of num ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 cnt = 0 = int ;  $  TAB2 for j = 1 to n inclusve, increment cnt by 2 * num[j] * (abs of(i - j) + abs of (j - 1) + abs of (1 - i) ;  $  TAB2 set ans to the min of cnt and ans ;  $  TAB1 print ans ;
TAB1 n = int ;  $  TAB1 while reading n ;  $  TAB2 a = int array of length 105 ;  $  TAB2 read a from 1 to n inclusive ;  $  TAB2 Min = 0x3f3f3f3f = int ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 ans = 0 = int ;  $  TAB3 for j =1 to n inclusive ;  $  TAB4 if j > i ;  $  TAB5 increment ans by (j - 1) * 4 * a at j ;  $  TAB4 else ;  $  TAB5 increment ans by (i - 1) * 4 * a at j ;  $  TAB3 set Min to the minimum between Min and ans ;  $  TAB2 print Min ;
TAB0 declare init ;  $  TAB0 create integer a of size 1000 ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 create long long sum = 0 ;  $  TAB1 for i = 1 to n, add 4 * (i - 1) * a[i] to sum ;  $  TAB1 print sum ;
TAB0 declare new constant integer maxn with value 1e5 + 5 ;  $  TAB0 num is a new array of integers with size maxn ;  $  TAB0 let n and ans be ints with ans = 1000000000 ;  $  TAB1 read standard input to n ;  $  TAB1 read n elements from the input to array num ;  $  TAB1 for integer i = 1 to n inclusive incrementing i ;  $  TAB2 declare integer cnt with value 0 ;  $  TAB2 in a for loop, change j from 1 to n inclusive, increasing cnt by 2 * num[j] * (abs(i - j) + abs(j - 1) + abs(1 - i)) on each loop ;  $  TAB2 change the value of ans to min of cnt and ans ;  $  TAB1 print ans ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 read n values into a ;  $  TAB1 ans = int with ans = 2e6 ;  $  TAB1 for i = 0 to n ;  $  TAB2 cur = int with cur = 0 ;  $  TAB2 for j = 0 to n ;  $  TAB3 d1 = int with d1 = i - j ;  $  TAB3 if d1 < 0 set d1 to -d1 ;  $  TAB3 increment cur by 2 * (d1 + i + j) * a[j] ;  $  TAB2 if cur < ans set ans to cur ;  $  TAB1 print ans ;
TAB1 n, i, sum, minm, x = long long int ;  $  TAB1 minm = 100000000 ;  $  TAB1 read n ;  $  TAB1 a = int array of size n + 1 ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 for x = 1 to n inclusive ;  $  TAB2 set sum to 0 ;  $  TAB2 for i = 1 to n inclusive set sum to sum + (absolute of (i - x) + i - 1 + (x - 1)) * a[i] * 2 ;  $  TAB2 if sum < minm set minm to sum ;  $  TAB1 print minm ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let ans be a integer with ans = (int)10e9 ;  $  TAB1 arr = array of integers of length n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let a be a integer ;  $  TAB2 read a ;  $  TAB2 arr[i] is equal to a ;  $  TAB1 let x be a integer with x = 1 ;  $  TAB1 while x <= n ;  $  TAB2 let cost be a integer with cost = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 let l be a integer with l = i + 1 ;  $  TAB3 cost = cost + absolute value of (x - l) + absolute value of (l - 1) + absolute value of (x - 1)) * 2 * arr[i] ;  $  TAB2 ans = minimum of ans, cost ;  $  TAB2 increment x by 1 ;  $  TAB1 print ans and newline ;
TAB0 maxn = const integer with maxn = 200005 ;  $  TAB0 maxm = const integer with maxm = maxn * 2 ;  $  TAB0 inf = const integer with inf = 0x3f3f3f3f ;  $  TAB0 mod = const long long with mod = 998244353 ;  $  TAB0 function init ;  $  TAB0 n = integer ;  $  TAB0 a = long long array of size 105 ;  $  TAB1 call init ;  $  TAB1 read n ;  $  TAB1 ans = long long with ans = 1e18 ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 for i = 1 to n ;  $  TAB2 tmp = long long with tmp = 0 ;  $  TAB2 for j = 1 to n, tmp = tmp + a[j] * 4 * ((i - 1) * 2 + (j - 1)) ;  $  TAB2 ans = min of ans and tmp ;  $  TAB1 print ans ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 let s be '#' + s ;  $  TAB1 declare integer n = length of s - 1 ;  $  TAB1 declare integer cnt = 0 ;  $  TAB1 for i = 1 to i + i is less than or equal to n, incrementing i ;  $  TAB2 if s[i] is not s[n-i+1], increment cnt ;  $  TAB1 if ( cnt is less than or equal to 1 and ( n bitwise and 1 ) ) or cnt is 1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create string x ;  $  TAB1 read x ;  $  TAB1 c=0 ;  $  TAB1 for i=0 to length of x - exclusive and for j= length of x-1 exclusive ;  $  TAB2 if x[i] different from x[j], increment c ;  $  TAB1 if c=2 or c=0 and length of x is odd ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 s=string ;  $  TAB1 while read s ;  $  TAB2 c=0 ;  $  TAB2 n=s ;  $  TAB2 for i=0 to length of s/2 exclusive ;  $  TAB3 reverse s ;  $  TAB3 if s[i] is not s[length of s-i-1] increment c ;  $  TAB2 if length of s is even and c is 1 ;  $  TAB3 print YES ;  $  TAB2 else if length of s is odd and c <= 1 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB0 create constant int MOD = 998244353 ;  $  TAB0 make const int MAX = 200001 ;  $  TAB0 create int array An of size MAX ;  $  TAB0 make integer array book of size MAX ;  $  TAB1 let string str ;  $  TAB1 read str ;  $  TAB1 create int sum = 0 ;  $  TAB1 make integer n = str.length() ;  $  TAB1 for i = 0 to n / 2 exclusive ;  $  TAB2 if str[i] is not equal to str[n - 1 - i], increment sum ;  $  TAB1 if sum is 1 ;  $  TAB2 print "YES" ;  $  TAB1 otherwise ;  $  TAB2 if sum is 0 and n % 2 ;  $  TAB3 display "YES" ;  $  TAB2 otherwise do ;  $  TAB3 show "NO" ;
TAB1 declare new string variables s and t ;  $  TAB1 read s from the input ;  $  TAB1 assign s to t ;  $  TAB1 reverse s ;  $  TAB1 create integer d = 0 ;  $  TAB1 for integer i = 0 to length of s / 2 exclusive incrementing i ;  $  TAB2 increment d if s[i] != t[i] ;  $  TAB1 print "YES" if d = 0 or 2 and s is odd, otherwise print "NO" ;
TAB1 declare string str ;  $  TAB1 read str ;  $  TAB1 declare integer diff = 0 ;  $  TAB1 for i = 0 to size of str exclusive, increment diff by ( str[i] is not str[size of str - 1 - i] ) ;  $  TAB1 if diff is 2 or diff is 0 and size of str % 2 is 1 ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 set d to 0 ;  $  TAB1 for i=0 to size of s exclusive, d= d+s[i] different from s[s.size() - 1 - i] ;  $  TAB1 if d=2 or d=0 and size of s mod 2 =1 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 declare string s ;  $  TAB0 declare inline check with string s as argument, returning integer ;  $  TAB1 declare string ss = s ;  $  TAB1 reverse sort from beginning of s to end of s ;  $  TAB1 return s is ss ;  $  TAB1 read s ;  $  TAB1 if result of run check(s) is true ;  $  TAB2 if size of s % 2 is 0 ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" ;  $  TAB1 declare integer len = size of s ;  $  TAB1 if len % 2 is 0 ;  $  TAB2 let len be len / 2 - 1 ;  $  TAB1 else ;  $  TAB2 let len be len / 2 ;  $  TAB1 for i = 0 to len inclusive ;  $  TAB2 if s[i] is not s[size of s - 1 - i] ;  $  TAB3 let s[i] be s[size of s - 1 - i] ;  $  TAB3 if result of run check(s) is true ;  $  TAB4 print "YES" ;  $  TAB3 else ;  $  TAB4 print "NO" ;
TAB0 declare string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 declare character c = s[i] ;  $  TAB2 for j = 0 to 26 exclusive ;  $  TAB3 if 'a' + j is c, end current loop ;  $  TAB3 let s[i] be 'a' + j ;  $  TAB3 declare integer k ;  $  TAB3 for k = 0 to size of k exclusive ;  $  TAB4 if s[k] is not s[size of s - 1 - k ] end current loop ;  $  TAB3 if k is size of s ;  $  TAB4 print "YES" and newline ;  $  TAB2 let s[i] be c ;  $  TAB1 print "NO" and newline ;
TAB0 declare ispalindrome taking in string s and returning bool ;  $  TAB1 make string t = s ;  $  TAB1 reverse s ;  $  TAB1 return the result of s == t ;  $  TAB1 make string s ;  $  TAB1 read s ;  $  TAB1 if ispalindrome(s) returns true ;  $  TAB2 if s.size() % 2 is truthy ;  $  TAB3 display "YES" ;  $  TAB2 else do ;  $  TAB3 print "NO" ;  $  TAB1 for i = 0 to s.size() / 2 exclusive ;  $  TAB2 make string t = s ;  $  TAB2 set t[i] to t[t.size() - i - 1] ;  $  TAB2 if ispalindrome(t) is true ;  $  TAB3 show "YES" ;  $  TAB1 display "NO" ;
TAB1 A is a new array of long longs with size 26 filled with 0 ;  $  TAB1 declare new string s ;  $  TAB1 read s from the user input ;  $  TAB1 declare new long long called n ;  $  TAB1 new long long c = 0 ;  $  TAB1 in a for loop, change i from 0 to n / 2 exclusive with step = 1 ;  $  TAB2 if s[i] != s[n - 1 - i], increment c ;  $  TAB1 if c is equal to 1 ;  $  TAB2 print "YES" ;  $  TAB3 print "\n" ;  $  TAB1 else if c = 0 and n is odd ;  $  TAB2 print "YES" to the standard output ;  $  TAB3 print "\n" ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB3 print "\n" to the stdout ;
TAB0 function ispalindrome with string argument s that returns bool ;  $  TAB1 create string variable t = s ;  $  TAB1 reverse s ;  $  TAB1 return s = t ;  $  TAB1 create new string variable s ;  $  TAB1 read s from the input ;  $  TAB1 if length of s is odd and ispalindrome(s) is true ;  $  TAB2 print "YES" to standard output ;  $  TAB1 if length of s is even and ispalindrome(s) returns true ;  $  TAB2 print "NO" ;  $  TAB1 declare integer err with value 0 ;  $  TAB1 for integer i = 0 to length of s / 2 exclusive incrementing i ;  $  TAB2 if s[i] != s[length of s - i - 1], increment err by one ;  $  TAB1 if err is equal to 1 ;  $  TAB2 print "YES" to standard output ;  $  TAB1 print "NO" to stdout ;
TAB1 s is a new array of characters with 16 elements ;  $  TAB1 declare integer variables i, count and n where count = 0 ;  $  TAB1 read s ;  $  TAB1 change the value of n to length of s ;  $  TAB1 start for loop from i = 0 to n / 2 exclusive incrementing i ;  $  TAB2 increment count if s[i] != s[n - 1 - i] ;  $  TAB1 if n is odd ;  $  TAB2 if count <= 1 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;  $  TAB1 else ;  $  TAB2 if count is equal to 1 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 s is a new string ;  $  TAB1 read standard input to s ;  $  TAB1 create new integers count = 0 and l = length of s - 1 ;  $  TAB1 start for loop from i = 0 to length of s / 2 exclusive ;  $  TAB2 if s[i] != s[l - i], increment count ;  $  TAB1 if length of s is even and count is 1 ;  $  TAB2 print "YES" ;  $  TAB1 else if length of s is odd and (count is 1 or 0) ;  $  TAB2 print "YES" to the standard output ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 declare string s ;  $  TAB0 declare integer ans = 0 ;  $  TAB0 declare integer i = 0 ;  $  TAB1 read s ;  $  TAB1 if size of s is 1 ;  $  TAB2 print "YES" and newline ;  $  TAB1 for j = size of s - 1 to size of s / 2, decrementing j ;  $  TAB2 if s[i] is not s[j] ;  $  TAB3 for c = 'a' to 'z' inclusive ;  $  TAB4 if c is s[i] or c is s[j] ;  $  TAB5 increment ans ;  $  TAB5 end loop ;  $  TAB2 let i be i + 1 ;  $  TAB1 if size of s % 2 is 0 ;  $  TAB2 if ans is 0 or ans is greater than 1 ;  $  TAB3 print "NO" and newline ;  $  TAB1 if ans is greater than 1 ;  $  TAB2 print "NO" and newline ;  $  TAB1 print "YES" and newline ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 count = integer = 1, l = integer = size of s - 1 ;  $  TAB1 for i = 0 to size of s / 2 exclusive ;  $  TAB2 if s[i] is not s[i - 1], then increase count by 1 ;  $  TAB1 if count is 1 ;  $  TAB2 print YES ;  $  TAB1 else if size of s is odd and count is 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create int l, i, j and k, set l to size of s exclusive ;  $  TAB1 for i=0 to l exclusive ;  $  TAB2 set c to s[i] ;  $  TAB2 for j=0 to 26 exclusive ;  $  TAB3 if j=c - a, continue ;  $  TAB3 set s[i] to j + a ;  $  TAB3 for k=0 to l exclusive ;  $  TAB4 if s[k] different from s[l - k - 1] ;  $  TAB3 if k >= l ;  $  TAB4 print YES ;  $  TAB2 set s[i] = c ;  $  TAB1 print NO ;
TAB0 make constant long long integer INF = 2000000000000000000LL ;  $  TAB0 let const int MOD = 10000007 ;  $  TAB0 make int array a of size 1000006 ;  $  TAB0 let string r ;  $  TAB0 delcare ispal taking in string s and returning bool ;  $  TAB1 set r to s ;  $  TAB1 reverse contents of r ;  $  TAB1 if s is equal to r ;  $  TAB2 return true ;  $  TAB1 else do ;  $  TAB2 return false ;  $  TAB1 make string s ;  $  TAB1 read s ;  $  TAB1 make ints n = s.size() and cnt = 0 ;  $  TAB1 for i = 0 to n / 2 exclusive ;  $  TAB2 make char samne = s[i] ;  $  TAB2 let char pichone = s[n - (i + 1)] ;  $  TAB2 if samne is not pichone, increment cnt ;  $  TAB1 if cnt is equal to 0 and ispal(s) returns truthy and n modulo 2 is 0 ;  $  TAB2 print "NO" ;  $  TAB3 print "\n" ;  $  TAB2 end statement ;  $  TAB1 else if cnt is more than 1 ;  $  TAB2 print "NO" ;  $  TAB3 print "\n" ;  $  TAB2 end statement ;  $  TAB1 else do ;  $  TAB2 print "YES" ;  $  TAB3 print "\n" ;  $  TAB2 ; ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare integer y = size of s - 1 ;  $  TAB1 declare integer sum = 0 ;  $  TAB1 for i = 0 to size of s / 2 exclusive ;  $  TAB2 if s[i] is not s[y], increment sum ;  $  TAB2 if sum is 2 ;  $  TAB3 print "NO" and newline ;  $  TAB2 decrement y ;  $  TAB1 if sum is 1 ;  $  TAB2 print "YES" and newline ;  $  TAB1 else if sum is 0 and size of s % 2 is not 0 ;  $  TAB2 print "YES" and newline ;  $  TAB1 else ;  $  TAB2 print "NO" and newline ;
TAB1 make string str ;  $  TAB1 read str ;  $  TAB1 let integer d = 0 ;  $  TAB1 for i = 0 to str.size() exclusive, set d to d + str[i] != str[str.size() - 1 - i] ;  $  TAB1 if d is 2 or if d is 0 and size of str % 2 is truthy ;  $  TAB2 print "YES" ;  $  TAB1 else do ;  $  TAB2 print "NO" ;
TAB1 create integers y, b, r ;  $  TAB1 read y read b read r ;  $  TAB2 for i = r to 3 inclusive, decrementing i ;  $  TAB3 if b is greater than or equal to ( i - 1 ) and y is greater than or equal to ( i - 2 ) ;  $  TAB4 print i + i - 1 + i - 2 print newline ;  $  TAB4 break loop ;
TAB1 create integers b,y, r ;  $  TAB1 read r read y read b ;  $  TAB1 create integer array arr with size 3, with arr = {r, y - 1, b - 2} ;  $  TAB1 create integermin with min = 200 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 if min is greater than or equal to arr[i], set min to arr[i] ;  $  TAB1 print 3 * min + 3 print newline ;
TAB1 declare integer variables y, b, r and m ;  $  TAB1 read y, b and r ;  $  TAB1 if b <= r - 1 and y >= b - 1 ;  $  TAB2 m = 3 * b ;  $  TAB1 else if b <= r - 1 and y is less than b - 1 ;  $  TAB2 m = 3 * (y + 1) ;  $  TAB1 else if b > r - 1 and y >= r - 2 ;  $  TAB2 m = 3 * (r - 1) ;  $  TAB1 else if b > r - 1 and y is less than r - 2 ;  $  TAB2 m = 3 * (y + 1) ;  $  TAB1 print m ;
TAB1 create integers a, b, c, d, e, f, g ;  $  TAB1 read a read b read c ;  $  TAB1 set e to a, set f to b, set g to c ;  $  TAB1 set d to minimum of a and b ;  $  TAB1 set d to minimum of d and c ;  $  TAB1 set d to minimum of d and a ;  $  TAB1 if d is a ;  $  TAB2 set b to a + 1 ;  $  TAB2 set c to a + 2 ;  $  TAB1 else if d is b ;  $  TAB2 set a to b - 1 ;  $  TAB2 set c to b + 1 ;  $  TAB1 else if d is c ;  $  TAB2 set a to c - 2 ;  $  TAB2 set b to c - 1 ;  $  TAB1 while a is greater than e or b is greater than f or c is greater than g ;  $  TAB2 decrement a ;  $  TAB2 decrement b ;  $  TAB2 decrement c ;  $  TAB1 print a + b + c print newline ;
TAB1 create integers a,b and c ;  $  TAB1 read a,b and c ;  $  TAB1 create integer a with a=0 ;  $  TAB1 subtract 2 from c ;  $  TAB1 decrement b by 1 ;  $  TAB1 print (the minimum of a (and the minimum of b and c)) *3+3 ;
TAB1 create integers y, b, r ;  $  TAB1 read y read b read r ;  $  TAB1 create integers mx with minimum of ( y + 2 and minimum of ( b + 1 and r ) ) ;  $  TAB1 print mx * 3 - 3 print "\n" ;
TAB1 color = integer array of length 3 ;  $  TAB1 for i = 0 to 3 exclusive read color[i] ;  $  TAB1 min, no = integers ;  $  TAB1 if color[0] is less than color[1] - 1 ;  $  TAB2 set min to color[0] + 2 ;  $  TAB2 set no to 0 ;  $  TAB1 else ;  $  TAB2 set min to color[1] + 1 ;  $  TAB2 set no to 1 ;  $  TAB1 if color[2] is less than min then set no to 2 ;  $  TAB1 print color[no] * 3 - (no - 1) * 3 ;
TAB0 function min with integer arguments x, y and z that returns integer ;  $  TAB1 create integer t = 0 ;  $  TAB1 if x is less than y ;  $  TAB2 if x is less than z ;  $  TAB3 set t to 1 ;  $  TAB2 else ;  $  TAB3 t = -1 ;  $  TAB1 else ;  $  TAB2 if y is less than z ;  $  TAB3 set t to 0 ;  $  TAB2 else ;  $  TAB3 t = -1 ;  $  TAB1 return t ;  $  TAB1 declare integer variables y, b and r ;  $  TAB1 create integer sum = 0 ;  $  TAB1 read y, b and r ;  $  TAB1 if y = b && b = r && r = y, set sum = 3 * (y - 1) ;  $  TAB1 assign min of y, b and r to new integer x ;  $  TAB1 if x = 1 ;  $  TAB2 if (b - y) >= 1 && (r - y) >= 2 ;  $  TAB3 sum = (y + 1) * 3 ;  $  TAB2 else ;  $  TAB3 decrement y while !((b - y) >= 1 && (r - y) >= 2) ;  $  TAB3 sum = (y + 1) * 3 ;  $  TAB1 else if x = 0 ;  $  TAB2 if b = r ;  $  TAB3 sum = 3 * (b - 1) ;  $  TAB2 else ;  $  TAB3 sum = 3 * b ;  $  TAB1 else ;  $  TAB2 sum = (r - 1) * 3 ;  $  TAB1 print sum ;
TAB1 create integers a, b, c, s with s = 0 ;  $  TAB1 read a read b read c ;  $  TAB1 while 1 is true ;  $  TAB2 if b is greater than or equal to a + 1 ;  $  TAB3 if c is greater than or equal to a + 2 ;  $  TAB4 set s to a + a + 1 + a + 2 ;  $  TAB4 break loop ;  $  TAB2 decrement a ;  $  TAB1 print s print newline ;
TAB1 y,b ,r are integers ;  $  TAB1 read y,b,r ;  $  TAB1 If y < 1 or y > 100 or b < 2 or b > 100 or r < 3 or r > 100, return 0 ;  $  TAB1 y1,y2,b1,b2,r1,r2 are integers ;  $  TAB1 assign y1 to y+1 ;  $  TAB1 assign y2 to y+2 ;  $  TAB1 assign b1 to b-1 ;  $  TAB1 assign b2 to b+1 ;  $  TAB1 assign r1 to r-2 ;  $  TAB1 assign r2 to r-1 ;  $  TAB1 if y1 <= b and y2 <= r, do the following ;  $  TAB2 print y + y1 + y2 and a new line ;  $  TAB1 else if b1 <= y and b2 <= r,, do the following ;  $  TAB2 print b + b1 + b2 and a new line ;  $  TAB1 else if r1 <= y and r2 <= b,, do the following ;  $  TAB2 print r1 + r2 + r and a new line ;
TAB1 y, b, r, ans = integers ;  $  TAB1 read y and b and r ;  $  TAB1 if r - 2 != 0 and r -2 <= y and r-1 <= b ;  $  TAB2 set ans = 3 * r - 3 ;  $  TAB1 else if b + 1 <= r and b - 1 != 0 and b - 1 < increment y ;  $  TAB2 set ans = 3 * b ;  $  TAB1 else ;  $  TAB2 set ans = 3 * y + 3 ;  $  TAB1 print ans ;
TAB1 create integers y, b, r ;  $  TAB1 read y read b read r ;  $  TAB1 while y is greater than r - 2 or y is greater than b - 1, decrement y ;  $  TAB1 while b is greater than y + 1, decrement b ;  $  TAB1 while r is greater than b + 1, decrement r ;  $  TAB1 print y + r + b print '\n' ;
TAB1 create integers y, b, r ;  $  TAB1 read y read b read r ;  $  TAB1 print 3 * minimum of ( minimum of ( b + 1 and r ) and y + 2 ) - 3 print newline ;
TAB1 let y,b,r be integers ;  $  TAB1 read y,b and r ;  $  TAB1 for (int i is equal to r, i greater than or equal to 3, i--) ;  $  TAB2 if (i less than or equal to r and i - 1 less than or equal to b and i - 2 less than or equal to y) ;  $  TAB3 print 3 * i - 3 and newline ;  $  TAB3 stop ;
TAB1 y, b, r =integers ;  $  TAB1 Read y, b, r ;  $  TAB1 for i = y to 1 exclusive ;  $  TAB2 ty = integers and set to i ;  $  TAB2 tb = integers and set to i+1 ;  $  TAB2 tc = integers and set to i+2 ;  $  TAB2 if tb is less than or equal to b and tc is less than or equal to r ;  $  TAB3 print ty + tb + tc and a new line ;
TAB1 create integers y, b, r ;  $  TAB1 read y read b read r ;  $  TAB1 print minimum of ( y and minimum of b - 1 and r - 2 ) * 3 + 3 print newline ;
TAB1 a,b,c = int ;  $  TAB1 read a,b,c ;  $  TAB1 d = min(a+1, min(b, c-1)) ;  $  TAB1 print 3*d ;
TAB1 create 64 bit integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print 3 * minimum of ( a + 1 and minimum of ( b and c - 1 )) print newline ;
TAB1 create integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 if b is greater than or equal to c - 1 and a is greater than or equal to c - 2 ;  $  TAB2 print 3 * c - 3 print newline ;  $  TAB1 else if b is less than c - 1 and a is greater than or equal to c - 2 ;  $  TAB2 print 3 * b print newline ;  $  TAB1 else if b is greater than or equal to c - 1 and a is less than c - 2 ;  $  TAB2 print 3 * a + 3 print newline ;  $  TAB1 else ;  $  TAB2 if a is less than b - 1 ;  $  TAB3 print 3 * a + 3 print newline ;  $  TAB2 else ;  $  TAB3 print 3 * b print newline ;
TAB1 declare integer variables y, b and r ;  $  TAB1 read y, b and r ;  $  TAB1 for integer i = r to 3 inclusive counting down by 1 ;  $  TAB2 if i <= b + 1 and i <= y + 2 ;  $  TAB3 let ans be integer = i ;  $  TAB3 print 3 * ans - 3 and a new line ;
TAB1 y, b, r = integers ;  $  TAB1 read y and b and r ;  $  TAB1 for i = y to 0 inclusive ;  $  TAB2 if i + 1 <= b and i + 2 <= r ;  $  TAB3 print 3 * i + 3 ;
TAB0 in function min ;  $  TAB1 if a is less than b return a ;  $  TAB1 return b ;  $  TAB1 create integers a, b and c ;  $  TAB1 read a, b and c ;  $  TAB1 set x to min of a and min of b-1 and c-2 ;  $  TAB1 print x+x+1+x+2 and new line ;
TAB1 create integers y, r, b, ans ;  $  TAB1 while read y read b read r is true ;  $  TAB2 create integer ans with ans = minimum of ( y + 2 and minimum of ( b + 1 and r ) ) * 3 ;  $  TAB2 print ans - 3 print newline ;
TAB1 a, b, c = integers ;  $  TAB1 read a, b, c ;  $  TAB1 set ans = 0 ;  $  TAB1 set c = c - 2 ;  $  TAB1 set b = b - 1 ;  $  TAB1 print min between a and (min between b and c) * 3 + 3 ;
TAB0 Variable M is set to 1000000007 ;  $  TAB1 declare three integer variables named y, b, and r ;  $  TAB1 Let the user input values for y, b, and r ;  $  TAB1 decrease the value of b by 1 ;  $  TAB1 decrease the value of r by 2 ;  $  TAB1 take the minimum number between b and r, then take the minimum number between that and the value of y, then multiply that by 3 and then add 3 and display the output to the screen ;
TAB1 y, b, r = integers ;  $  TAB1 read y, b, r ;  $  TAB1 if y >= r set y = r - 2 ;  $  TAB1 if r - y = 1 decrement y ;  $  TAB1 if y >= b set y = b - 1 ;  $  TAB1 print y + (y + 1) + (y + 2 ) ;
TAB0 declare solve with no arguments, returning void ;  $  TAB1 create long long t ;  $  TAB1 set t to 1 ;  $  TAB1 while decrement t is true, run solve ;  $  TAB0 declare solve with no arguments, returning void ;  $  TAB1 create long longs y, b, r ;  $  TAB1 read y read b read r ;  $  TAB1 create long long tt with tt = minimum of ( y and minimum of ( b - 1 and r - 2 ) ) ;  $  TAB1 print tt * 3 + 3 print '\n' ;
TAB1 y, b, r = integers ;  $  TAB1 while read y, b, and r ;  $  TAB2 for i=r to greater or equal than 3 ;  $  TAB3 if b is greater or equal than i-1 and y is greater or equal than i-2 ;  $  TAB4 print i + i - 1 + i - 2 and new line ;  $  TAB4 stop loop ;
TAB1 let a, b and c be integers ;  $  TAB1 read a, b and c ;  $  TAB1 increment a ;  $  TAB1 decrement c ;  $  TAB1 print min of (min of a and c) and b * 3, and a new line ;
TAB1 create 64 bit integers a, b, c ;  $  TAB1 read a read b read c ;  $  TAB1 print 3 * minimum of a + 1 and minimum of b and c - 1, print newline ;
TAB1 create integers y, b, r ;  $  TAB1 read y read b read r ;  $  TAB1 if y is less than 1 or y is greater than 100 or b is less than 2 or b is greater than 100 or r is less than 3 or r is greater than 100, return 0 from function ;  $  TAB1 if y + 1 is less than or equal to b and y + 2 is less than or equal to r ;  $  TAB2 print 3 * y + 3 print newline ;  $  TAB1 else if b - 1 is less than or equal to y and b + 1 is less than or equal to r ;  $  TAB2 print 3 * b print newline ;  $  TAB1 else if r - 2 is less than or equal to y and r - 1 is less than or equal to b ;  $  TAB2 print 3 * r - 3 print newline ;
TAB1 create integers x, y, z ;  $  TAB1 get x, y, z ;  $  TAB1 if x+1 is equal to y and y+1 equal to z then ;  $  TAB2 print x+y+z ;  $  TAB1 else do the following ;  $  TAB2 do the following indefinitely till break statement ;  $  TAB3 create integer a with a=z ;  $  TAB3 create integer b with b=z-1 ;  $  TAB3 create integer c with c=z-2 ;  $  TAB3 if a, b, c less than or equal to z, y, x respectively and c+1 equal to b and b+1 equal to a then ;  $  TAB4 print a+b+c ;  $  TAB4 break out of loop ;  $  TAB3 decrement z ;
TAB1 declare integer variables a, b and c ;  $  TAB1 read from the input to a, b and c ;  $  TAB1 declare integer variable ans = 0 ;  $  TAB1 decrease c by 2 ;  $  TAB1 subtract 1 from b ;  $  TAB1 print (min of a and (min of b and c)) * 3 + 3 ;
TAB1 t = int ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t ;  $  TAB2 L, v, l ,r = int ;  $  TAB2 read L then v then l then r ;  $  TAB2 print L / v - r / v + (l - 1) / v ;
TAB1 t=long long int ;  $  TAB1 read t ;  $  TAB1 while decremented value of t is not zero ;  $  TAB2 n,l,v,r=long long int ;  $  TAB2 read n,v,l,r ;  $  TAB2 a=n/v ;  $  TAB2 b=(l-1)/v ;  $  TAB2 c=r/v ;  $  TAB2 print a+b-c ;
TAB0 N is a new constant integer = 2e6 + 123 ;  $  TAB0 INF is a new integer constant = 1e9 + 123 ;  $  TAB0 create constant integer variable called MOD = 1e9 + 7 ;  $  TAB0 declare constant double variable EPS with value 1e - 9 ;  $  TAB0 define function solve ;  $  TAB1 declare integer variables L, v, l, r and x ;  $  TAB1 read user input to L, v, l and r ;  $  TAB1 print (L / v) - ((r / v) - ((l - 1) / v)) and '\n' to the standard output ;  $  TAB1 create integer variable t ;  $  TAB1 read variable t from the input ;  $  TAB1 while t is not 0 ;  $  TAB2 call method solve() ;  $  TAB2 decrement t ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 x,y,z,w=int ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 ans=long long ;  $  TAB2 read x,y,z,w ;  $  TAB2 if z modulo y is 0 decrement z ;  $  TAB2 ans=x/y+z/y-w/y ;  $  TAB2 if y, z and w are the same increment ans ;  $  TAB2 print ans ;
TAB1 t = integer ;  $  TAB1 read t ;  $  TAB1 while t ;  $  TAB2 L, v, l, r = integers ;  $  TAB2 read L, v, l, r ;  $  TAB2 a = integer with a = r / v - l / v ;  $  TAB2 if l modulo v is 0, increment a ;  $  TAB2 print L / v - a ;
TAB1 create long long ints n, m, p, q, r, s, t, u, v, w, x, y, z, L, l, i and j with p = 0 ;  $  TAB1 read input to n ;  $  TAB1 start for loop from i = 1 to n inclusive ;  $  TAB2 read L, v, l and r from the input ;  $  TAB2 set x to L / v - r / v ;  $  TAB2 set y to (l - 1) / v ;  $  TAB2 print x + y and '\n' ;
TAB1 let t be a integer ;  $  TAB1 read t ;  $  TAB1 while t is decremented by 1 ;  $  TAB2 let d, v, l, r be long integers ;  $  TAB2 read d, v, l, r ;  $  TAB2 let count be a integer with count = d / v ;  $  TAB2 r is equal to v * (r / v) ;  $  TAB2 if l modulo v is not equal to 0 , l is equal to v * ((l / v) + 1) ;  $  TAB2 print count - ((r - l) / v) - 1 and newline ;
TAB1 t, L, v, l, r, r1, ans = integers ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 read L, v, l, r ;  $  TAB2 ans = (l - 1) / v ;  $  TAB2 r1 = ((r / v) + 1) * v ;  $  TAB2 if L >= r1, then ans = ans + (L - r1) / v + 1 ;  $  TAB2 print ans ;
TAB1 declare integer t ;  $  TAB1 read t ;  $  TAB1 while decrement t is ture ;  $  TAB2 declare long integers L, v, l, r ;  $  TAB2 read L and v and l and r ;  $  TAB2 declare long integers tot = L / v ;  $  TAB2 declare long integers unseen = r / v - (l - 1) / v ;  $  TAB2 print tot - unseen and newline ;
TAB1 declare integers t, L, v, l, r ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 read L, v, l, r ;  $  TAB2 print L / v - r / v + l / v - ( 1 if l % v is 0, else 0 ), "\n" ;
TAB1 n, k, v, l, r = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read k, v, l, r ;  $  TAB2 print the result of k / v + (l - 1) / v - r / v ;
TAB1 create long long T, L, v, l, r, ans1, ans2 ;  $  TAB1 read T ;  $  TAB1 while decrement T ;  $  TAB2 read L, v, l and r ;  $  TAB2 set ans1 to L/v ;  $  TAB2 assign r/v - l/v to ans2 ;  $  TAB2 if l mod v=0, assign ans2 + 1 to ans2 ;  $  TAB2 print ans1 - ans2 ;
TAB0 i, j, k, n, m = long long integers, sum = long long integer = 0, ans = long long integer = 0 ;  $  TAB0 in function fastio that returns nothing ;  $  TAB0 in function solve that returns nothing ;  $  TAB1 L, v, l, r = long long integer ;  $  TAB1 read L, v, l, r ;  $  TAB1 n = L / v ;  $  TAB1 m = r / v - (l - 1) / v ;  $  TAB1 print the result of n - m ;  $  TAB1 call fastio ;  $  TAB1 t = integer = 1 ;  $  TAB1 read t ;  $  TAB1 while looping decrease t by 1, while in the loop call solve ;
TAB1 create new integer variable tc ;  $  TAB1 read variable tc from the input ;  $  TAB1 loop, decrementing tc, while it is not 0 ;  $  TAB2 declare int variables n, v, l and r ;  $  TAB2 read n, v, l and r from the user input ;  $  TAB2 create new integer variable t = n / v ;  $  TAB2 declare integer variable with name t1 with value (r / v) - ((l - 1) / v) ;  $  TAB2 print t - t1 to the standard output ;
TAB1 declare long long variable called t ;  $  TAB1 read t from the input ;  $  TAB1 while t != 0, decrement it and continue the loop ;  $  TAB2 declare long long ints L, v, l and r ;  $  TAB2 read user input to L, v, l and r ;  $  TAB2 print L / v - (r / v - (l - 1) / v) to the standard output ;
TAB1 create int int t, L, v, l, r ;  $  TAB1 read t ;  $  TAB1 for i=0 to t exclusive ;  $  TAB2 read L, v, l, r ;  $  TAB2 print L / v - r / v + (l - 1) / v ;
TAB1 t = long ;  $  TAB1 read t ;  $  TAB1 loop t times ;  $  TAB2 x, v, l, r = long ;  $  TAB2 read x then v then l then r ;  $  TAB2 ans = long with ans = x / v ;  $  TAB2 temp = long with temp = r / v - (l - 1) / v ;  $  TAB2 decrement ans by temp ;  $  TAB2 print ans ;
TAB1 declare integers t, L, v, l, r ;  $  TAB1 read t ;  $  TAB1 while decrement t is true ;  $  TAB2 declare integers a = 0, b = 0, c = 0, d = 0 ;  $  TAB2 read L and v and l and r ;  $  TAB2 let a be ( l - 1 ) / v ;  $  TAB2 let b be r / v ;  $  TAB2 let d be d - a ;  $  TAB2 let c be L / v ;  $  TAB2 print c - d, newline ;
TAB0 t = int ;  $  TAB0 L, v, l, r = long long ;  $  TAB1 read t ;  $  TAB1 loop t times ;  $  TAB2 ans = long long with ans = 0 ;  $  TAB2 read L then v then l then r ;  $  TAB2 set ans to (l - 1) / v + L / v - r / v ;  $  TAB2 print ans ;
TAB0 declare constant integer variable INF with value 0x3f3f3f3f ;  $  TAB1 let t, v, l, r, L and cnt be ints with the value of cnt = 0 ;  $  TAB1 read variable t from the input ;  $  TAB1 loop, decrementing t, while it is not 0 ;  $  TAB2 read variables L, v, l and r from the input ;  $  TAB2 declare new integer ans = L / v - (r / v - (l - 1) / v) ;  $  TAB2 print ans to the standard output ;
TAB1 let int t ;  $  TAB1 read t ;  $  TAB1 while t-- is truthy ;  $  TAB2 create long long ints l, v, a, and b ;  $  TAB2 read l, v, a, and b ;  $  TAB2 create long long int numOfLight = (l / v) - ((b / v) - (a - 1) / v) ;  $  TAB2 print numOfLight ;
TAB1 make integer t ;  $  TAB1 read t ;  $  TAB1 while t-- is truthy ;  $  TAB2 create long long ints l, v, li, ri, val1, val2, val3 ;  $  TAB2 read l, v, li, and ri ;  $  TAB2 set val1 to l / v ;  $  TAB2 set val2 to li / v ;  $  TAB2 set val3 to ri / v ;  $  TAB2 if li modulo v is 0, increment val3 ;  $  TAB2 set val3 to val3 - val2 ;  $  TAB2 set val1 to val1 - val3 ;  $  TAB2 print val1 ;
TAB0 declare long long array mz size 100005 = {} ;  $  TAB0 declare long long array ts size 100005 = {} ;  $  TAB1 declare long long T ;  $  TAB1 read T ;  $  TAB1 while decrement T is true ;  $  TAB2 declare long longs L, v, l, r, ans = 0 ;  $  TAB2 read L, v, l, r ;  $  TAB2 increment ans by L / v ;  $  TAB2 if r % v is not 0, let r be r - r % v ;  $  TAB2 if l % v is not 0, let l be l + ( v - l % v ) ;  $  TAB2 decrement ans by ((r-l)/v+1) ;  $  TAB2 print ans, newline ;
TAB1 t=int ;  $  TAB1 read t ;  $  TAB1 L,u,l,r=int ;  $  TAB1 res=vector of int ;  $  TAB1 for i=0 to t exclusive ;  $  TAB2 read L,u,l,r ;  $  TAB2 curr=L/u ;  $  TAB2 subtract (r/u-l/u+(1 if l modulo u is 0)) from curr ;  $  TAB2 put curr at end of res ;  $  TAB1 for i=0 to t exclusive print res[i] ;
TAB1 n, l1, v1, l2, r, count = integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read l1, v1, l2, r ;  $  TAB2 print the result of (l1 / v1 - (r / v1 - (l2 - 1) / v1)) ;
TAB0 in function gcd with arguments long long x and long long y that returns a long long ;  $  TAB1 if y is 0 ;  $  TAB2 return x ;  $  TAB1 else ;  $  TAB2 return the result of calling gcd with arguments y and x modulo y ;  $  TAB0 in function long long expo with arguments of long long n, long long m, and long long p that returns a long long ;  $  TAB1 r = long long = 1 ;  $  TAB1 n = n modulo p ;  $  TAB1 while m > 0 ;  $  TAB2 if m modulo 2 is possible then r = (r * n) modulo p ;  $  TAB2 n = n squared modulo p ;  $  TAB2 m - m / 2 ;  $  TAB1 return r modulo p ;  $  TAB0 in function isPrime with an argument of a long long n that returns a boolean ;  $  TAB1 if n <= 1 then return false ;  $  TAB1 if n <= 3 then return true ;  $  TAB1 if n is even or n modulo 3 is 0 then return false ;  $  TAB1 for i = 5, where i is square to n inclusive and i = i + 6 ;  $  TAB2 if n modulo i is 0 or n modulo (i + 2) is 0, then return false ;  $  TAB1 return true ;  $  TAB1 t = long long ;  $  TAB1 read t ;  $  TAB1 while looping decrease t by 1 ;  $  TAB2 a, b, c, d = long long ;  $  TAB2 read a, b, c, d ;  $  TAB2 print the result of (a / b) - ((d / b) - (c - 1) / b) ;
TAB1 t = integer ;  $  TAB1 read t ;  $  TAB1 l, v, x, y = long long integer ;  $  TAB1 while decrement t ;  $  TAB2 read l, v, x, y ;  $  TAB2 count = long long integer with count = 0 ;  $  TAB2 total = long long integer with total = l / v; ;  $  TAB2 sub1 = long long integer with sub1 = y / v ;  $  TAB2 sub2 = long long integer with sub2 = x / v ;  $  TAB2 count = total - sub1 + sub2 ;  $  TAB2 if x modulo v is 0, decrement count ;  $  TAB2 print count ;
TAB1 create integer t ;  $  TAB1 read t ;  $  TAB1 iterate t times ;  $  TAB2 create integers l, r, v, p ;  $  TAB2 read p, v, l and r ;  $  TAB2 declare integer ans and set it to p/v ;  $  TAB2 assign ans - (r / v - (l - 1) / v) to ans ;  $  TAB2 print ans ;
TAB1 declare new int variables n and d ;  $  TAB1 read n ;  $  TAB1 declare new 2d array of long longs a with size n by 4 ;  $  TAB1 start for loop from i = 0 to n exclusive ;  $  TAB2 in a for loop, change j from 0 to 4 exclusive, reading a[i][j] from the user input on each loop ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 change the value of d to (a[i][0] / a[i][1]) + ((a[i][2] - 1) / a[i][1]) - (a[i][3] / a[i][1]) ;  $  TAB2 print d and "\n" ;
TAB1 declare integer T ;  $  TAB1 read T ;  $  TAB1 declare L, v, l, r as long integers ;  $  TAB1 while decrement T is true ;  $  TAB2 read L, v, l, r ;  $  TAB2 declare nbr_lat = L / v as long integer ;  $  TAB2 declare long integer hidden = r/v-l/v ;  $  TAB2 if l % v is 0, increment hidden ;  $  TAB2 print nbr_lat - hidden and newline ;
TAB1 create long long int t ;  $  TAB1 read t ;  $  TAB1 create long long int dest, v, l and r ;  $  TAB1 while decrement t ;  $  TAB2 read dest, v, l and r ;  $  TAB2 set fin to dest/v ;  $  TAB2 fin1 = r / v ;  $  TAB2 fin2 = (l - 1) / v ;  $  TAB2 print fin - fin1 + fin2 ;
TAB0 n, i = integers ;  $  TAB1 Read n ;  $  TAB1 a = array of n integers ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 if n is equal to 1 ;  $  TAB2 print a[0] and a new line ;  $  TAB1 else if n is 3 ;  $  TAB2 print a[1] and a new line ;  $  TAB1 else do the following ;  $  TAB2 print a[2] and a new line ;
TAB0 b, c, d, i, n = integers and a = array of 10001 integers ;  $  TAB1 Read n ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 print a[n / 2] and a new line ;
TAB0 do nothing ;  $  TAB0 eps = 1e-8 = const double ;  $  TAB0 maxn = 1e6+7 = const int ;  $  TAB0 pi = const double = acos(-1) ;  $  TAB0 inf = 0x3f3f3f3f = const int ;  $  TAB0 n = int ;  $  TAB0 a = int array length 10 ;  $  TAB1 read n ;  $  TAB1 read a from 1 to n inclusive ;  $  TAB1 sort a from 1 to n inclusive ;  $  TAB1 x = int = half of a[n] - a[1]) ;  $  TAB1 print a at 1 + x ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 sum = integer with 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a = integer ;  $  TAB2 Read a ;  $  TAB2 set sum to sum + a ;  $  TAB1 print sum / n and a new line ;
TAB1 declare new unsigned variable n ;  $  TAB1 read input to n ;  $  TAB1 vect is a new vector of integers with n elements ;  $  TAB1 define new long sum = 0 ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 read vect[i] ;  $  TAB2 change sum to the sum of sum and vect[i] ;  $  TAB1 sort elements of vect from the index 0 to n ;  $  TAB1 new long avg = sum / n ;  $  TAB1 print avg ;
TAB1 n = integer, a = integer array of size 5 ;  $  TAB1 read n ;  $  TAB1 for 0 to n exclusive read a[i] ;  $  TAB1 sort(a, a + n) ;  $  TAB1 print a[n / 2] ;
TAB0 nu = array of 100100 long long ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 sum = integer with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 b = integer ;  $  TAB2 read b ;  $  TAB2 sum = sum + b ;  $  TAB1 print sum / n ;
TAB0 a is an array of integers with size 100 ;  $  TAB1 create integer variable with name n ;  $  TAB1 read n from the user input ;  $  TAB1 read n elements from the input to a in a for loop ;  $  TAB1 sort a from index 0 to n ;  $  TAB1 print a[n / 2] ;
TAB0 in void function solve ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = int vector ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 buff = int ;  $  TAB2 read buff ;  $  TAB2 push back buff into a ;  $  TAB1 sort a ;  $  TAB1 m = half of size of a = int ;  $  TAB1 print a at m ;  $  TAB1 call solve ;
TAB0 n, m, i, q, ii = long long and a, b = long long array of size 100001 each ;  $  TAB1 read n ;  $  TAB1 read n values int a ;  $  TAB1 sort a from index 0 to n ;  $  TAB1 print a[n / 2] ;
TAB0 V = vector of integer ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 while decrement n ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 append x on V ;  $  TAB1 sort V.begin() and V.end() ;  $  TAB1 print V[(V.size() / 2)] ;
TAB0 n, i = integers and a = array of 10 integers ;  $  TAB1 Read n ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 print a[n / 2 + 1] and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 year = array of n integers ;  $  TAB1 Read n values into array year ;  $  TAB1 sort array elements of year in ascending order ;  $  TAB1 print year[n / 2] and a new line ;
TAB0 create constant double eps with value 1e-8 ;  $  TAB0 create constant integer cakked maxn = 1e6 + 7 ;  $  TAB0 create constant double with name pi and value = acos of -1 ;  $  TAB0 create new constant integer inf = 0x3f3f3f3f ;  $  TAB0 declare integer variable n ;  $  TAB0 a is a new array of integers with 10 elements ;  $  TAB1 read variable n from the input ;  $  TAB1 read input into sequential items of a n times, starting from the index 1 ;  $  TAB1 sort a from element 1 to n + 1 ;  $  TAB1 x is a new integer = (a[n] - a[1]) / 2 ;  $  TAB1 print a[1] + x ;
TAB0 MOD = const integer with MOD = 1000000007 ;  $  TAB0 INF = const long long with INF = 1e18 ;  $  TAB0 t, m, n = long long ;  $  TAB0 A = vector of integer ;  $  TAB0 in the function solve that returns long long ;  $  TAB1 sort A.begin() and A.end() ;  $  TAB1 n = integer with n = A.size() ;  $  TAB1 return A[n / 2] ;  $  TAB1 read n ;  $  TAB1 resize n of A ;  $  TAB1 for i = 0 to n exclusive, read A[i] ;  $  TAB1 print solve ;
TAB1 create float n ;  $  TAB1 read n ;  $  TAB1 create integers tmp and sum = 0 ;  $  TAB1 for i = 0 to i = n - 1 ;  $  TAB2 read tmp ;  $  TAB2 set sum to sum + tmp ;  $  TAB1 print the result of ceil of sum/n ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 sum = integer with 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a = integer ;  $  TAB2 Read a ;  $  TAB2 set sum to sum + a ;  $  TAB1 print sum / n and a new line ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 V=vector of n int ;  $  TAB1 for i=0 to n exclusive read V[i] ;  $  TAB1 sort V ;  $  TAB1 print (V[0]+V[n-1])/2 ;
TAB1 let n,a, sum=0 be integer ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 sum +=a ;  $  TAB1 print sum and a new line ;
TAB1 create integer n ;  $  TAB1 read input to n ;  $  TAB1 create new vector of integers a with n elements ;  $  TAB1 for i = 0 to n exclusive, read a[i] from the user input ;  $  TAB1 sort vector a ;  $  TAB1 print a[n / 2] ;
TAB1 create long long ints k, l, m, o, n, max = 0 and min = 0 ;  $  TAB1 read input to o ;  $  TAB1 for i from 0 to o exclusive incrementing i ;  $  TAB2 read user input to n ;  $  TAB2 if max is less than n, assign the new value = n to max ;  $  TAB2 if i = 0, change min to n ;  $  TAB2 if min is greater than n, assign change min to n ;  $  TAB1 change the value of k to (max - min) / 2 ;  $  TAB1 print max - k to the standard output ;
TAB0 let maxn be a constant integer with maxn = 6 ;  $  TAB0 A = array of integers of length maxn ;  $  TAB1 let N be a integer ;  $  TAB1 read N ;  $  TAB1 for i = 1 to N inclusive , read A[i] ;  $  TAB1 sort the values A + 1 and A + N + 1 ;  $  TAB1 let p be a integer with p = N / 2 ;  $  TAB1 if N modulo 2 is equal to 1 , increment p by 1 ;  $  TAB1 print A[p] and newline ;
TAB0 declare new integer variables n and i ;  $  TAB1 read n from the input stream ;  $  TAB1 a is an array of integers with n elements ;  $  TAB1 read n elements from the input into a ;  $  TAB1 sort a ;  $  TAB1 print a[n / 2] to the stdout ;
TAB1 n = integer ;  $  TAB1 a = vector integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 k = integer ;  $  TAB2 read k ;  $  TAB2 push back the element of a by 1 and insert a new element of k at the end of a ;  $  TAB1 min = max = integer = a[0] ;  $  TAB1 for i = 0 to size of a exclusive ;  $  TAB2 if a[i] > max, then max = a[i] ;  $  TAB2 if a[i] < min, then min = a[i] ;  $  TAB1 print min + (max - min) / 2 ;
TAB0 inf is a new constant integer with value 0x3f3f3f3f ;  $  TAB0 declare new constant integer MX = 1e5 + 5 ;  $  TAB0 create new int n and int array a with size 10 ;  $  TAB1 read n ;  $  TAB1 read n elements into a, starting from the index 1 ;  $  TAB1 sort a ;  $  TAB1 print a[n / 2 + 1] to the standard output ;
TAB0 MAX = constant integer of value 1e10 ;  $  TAB0 dict = set of integers ;  $  TAB1 n, j = integers ;  $  TAB1 read n ;  $  TAB1 arr = array of length 6 initialized to 0 ;  $  TAB1 for i = 0 to n exclusive read arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] is greater than 0 then insert arr[i] into dict ;  $  TAB1 set the first n elements of arr to 0 ;  $  TAB1 set j to 0 ;  $  TAB1 for it = the first element of dict until the last element of dict exclusive set arr[j] to be the value of it then add 1 to j ;  $  TAB1 print arr[n/2] ;
TAB0 a = array of 10 integers ;  $  TAB1 n=integer ;  $  TAB1 Read n ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 print a[n / 2] and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 a = array of n + 2 integers ;  $  TAB1 set a[0] to 0 ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 k = integer, set to n / 2 ;  $  TAB1 if n modulo 2, then increment k ;  $  TAB1 print a[k] and a new line ;
TAB0 y = array of integers of length 10 ;  $  TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive , read y[i] ;  $  TAB1 sort the values y + 1 and y + n + 1 ;  $  TAB1 print y[n / 2 + 1] and newline ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int ara[n] ;  $  TAB1 for i=0 to n exclusive, read ara[i] ;  $  TAB1 sort elements between ara and ara + n ;  $  TAB1 if n=1 ;  $  TAB2 print ara[0] ;  $  TAB1 else if n=3 ;  $  TAB2 print ara[1] ;  $  TAB1 else ;  $  TAB2 print ara[2] ;  $  TAB1 print a new line ;
TAB0 declare new constant integer M with value 2e5 + 5 ;  $  TAB0 create new constant integer inf with value 1e9 + 5 ;  $  TAB1 n is a new integer variable ;  $  TAB1 create new vector of integers v ;  $  TAB1 read variable n from the input ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 create new integer variable t ;  $  TAB2 read variable t from the input ;  $  TAB2 add new element = t after the last element of v ;  $  TAB1 sort v from start to end ;  $  TAB1 print v[n / 2] ;
TAB1 n =integer and y = array of 10 integers ;  $  TAB1 Read n ;  $  TAB1 Read n values into array y ;  $  TAB1 sort array elements of y in ascending order ;  $  TAB1 print y[n / 2] and a new line ;
TAB1 create variable n with type size_t ;  $  TAB1 read input to n ;  $  TAB1 create new vector year with n elements of type of size_t ;  $  TAB1 read n elements into year in a loop ;  $  TAB1 sort year ;  $  TAB1 print year[(n - 1) / 2] ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 arr=array of 10 int ;  $  TAB1 for i=1 to n exclusive read arr[i] ;  $  TAB1 sort arr from position 1 to n+1 ;  $  TAB1 if n is 1 ;  $  TAB2 print arr[1] ;  $  TAB1 else if n is 3 ;  $  TAB2 print arr[2] ;  $  TAB1 else ;  $  TAB2 print arr[3] ;
TAB1 declare long long unsigned variables n and k ;  $  TAB1 read n and k ;  $  TAB1 declare long long unsigned variable mid = n / 2 ;  $  TAB1 if n modulo 2 is 1, increment mid ;  $  TAB1 if k <= mid ;  $  TAB2 print (k * 2) - 1 ;  $  TAB1 else ;  $  TAB2 print ((k - (mid + 1)) * 2) + 2 ;
TAB1 n, k, p, o =integers ;  $  TAB1 Read n and k ;  $  TAB1 if n is even ;  $  TAB2 set p to n / 2 ;  $  TAB1 else do the following ;  $  TAB2 set p to n / 2 + 1 ;  $  TAB1 if k is less than or equal to p ;  $  TAB2 set o to (k * 2) - 1 ;  $  TAB1 else do the following ;  $  TAB2 set o to (k - p) * 2 ;  $  TAB1 print o and a new line ;
TAB1 n, k, half = long long int ;  $  TAB1 read n and k ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 half = n / 2 ;  $  TAB1 else if n modulo 2 is 1 ;  $  TAB2 half = (n + 1) / 2 ;  $  TAB1 if k <= half ;  $  TAB2 print 2 * k - 1 ;  $  TAB1 else if k > half ;  $  TAB2 print (k - half) * 2 ;
TAB1 declare long longs n, k, c, l and d ;  $  TAB1 read n and k ;  $  TAB1 if n is even ;  $  TAB2 l = n / 2 ;  $  TAB1 else ;  $  TAB2 l = n / 2 + 1 ;  $  TAB1 if k <= l ;  $  TAB2 print 2 * k - 1 ;  $  TAB1 else ;  $  TAB2 if n is odd ;  $  TAB3 print 2 * k - n - 1 ;  $  TAB2 else ;  $  TAB3 print 2 * k - n ;
TAB1 create long long n, k ;  $  TAB1 read n, k ;  $  TAB1 if n is even ;  $  TAB2 if k is greater than n/2 ;  $  TAB3 print (k - (n / 2)) * 2 ;  $  TAB2 else do the following ;  $  TAB3 print k * 2 - 1 ;  $  TAB1 else do the following ;  $  TAB2 if k is greater than (n) / 2 + 1 ;  $  TAB3 print (k - (n / 2 + 1)) * 2 ;  $  TAB2 else do the following ;  $  TAB3 print k * 2 - 1 ;
TAB1 create long long integers n and k ;  $  TAB1 read n and k ;  $  TAB1 if k <= (n + 1) / 2 ;  $  TAB2 print 2 * k - 1 ;  $  TAB1 else ;  $  TAB2 print 2 * (k - (n + 1) / 2) ;
TAB1 create long long integer number ;  $  TAB1 declare long long integer variable position ;  $  TAB1 read number ;  $  TAB1 read position ;  $  TAB1 declare long long integer x ;  $  TAB1 if number is even ;  $  TAB2 if position <= number / 2 ;  $  TAB3 x = (position * 2) - 1 ;  $  TAB2 else if position is greater than number / 2 ;  $  TAB3 x = (position - (number / 2)) * 2 ;  $  TAB1 else if number is odd ;  $  TAB2 if position <= (number + 1) / 2 ;  $  TAB3 x = (position * 2) - 1 ;  $  TAB2 else if position is greater than (number + 1) / 2 ;  $  TAB3 x = (position - ((number + 1) / 2)) * 2 ;  $  TAB1 print x ;
TAB1 declare long long integer variables n and k = 0 ;  $  TAB1 loop reading n and k from the input ;  $  TAB2 declare long long integer a = 0 ;  $  TAB2 if n is odd ;  $  TAB3 if k is greater than (n + 1) / 2 ;  $  TAB4 a = (k - (n + 1) / 2) * 2 ;  $  TAB3 else ;  $  TAB4 a = 2 * k - 1 ;  $  TAB2 else ;  $  TAB3 if k is greater than n / 2 ;  $  TAB4 a = (k - n / 2) * 2 ;  $  TAB3 else ;  $  TAB4 a = 2 * k - 1 ;  $  TAB2 print a ;
TAB1 n, k, p, o = long long int ;  $  TAB1 read n and k ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 p = n / 2 ;  $  TAB1 else ;  $  TAB2 p = (n / 2) + 1 ;  $  TAB1 if k <= p ;  $  TAB2 o = (2 * k) - 1 ;  $  TAB1 else ;  $  TAB2 o = (k - p) * 2 ;  $  TAB1 print o ;
TAB1 n, k = long long ;  $  TAB1 read n then k ;  $  TAB1 if n is uneven ;  $  TAB2 if k is less or equal to n / 2 + 1 ;  $  TAB3 print 2 * k - 1 ;  $  TAB2 else ;  $  TAB3 print (k - n / 2 - 1) * 2 ;  $  TAB1 else ;  $  TAB2 if k is less or equal to n / 2 ;  $  TAB3 print 2 * k - 1 ;  $  TAB2 else ;  $  TAB3 print (k - n / 2) * 2 ;
TAB1 n, k = long long ;  $  TAB1 read n, k ;  $  TAB1 if k <= (n + 1) / 2 ;  $  TAB2 print k * 2 - 1 ;  $  TAB1 else ;  $  TAB2 print (k - (n + 1) / 2) * 2 ;
TAB1 create long long int n, k and mid ;  $  TAB1 read n and k ;  $  TAB1 assign ceil of n/2.0 to mid ;  $  TAB1 if k is less than or equal to mid ;  $  TAB2 print (k * 2) - 1 ;  $  TAB1 else do the following ;  $  TAB2 print (k - mid) * 2 ;
TAB1 declare unsigned long longs a, b and c ;  $  TAB1 read a and b ;  $  TAB1 if a is even ;  $  TAB2 c = a / 2 ;  $  TAB1 else ;  $  TAB2 c = a / 2 + 1 ;  $  TAB1 if b is greater than c ;  $  TAB2 b = (b - c) * 2 ;  $  TAB1 else if b <= c ;  $  TAB2 b = 2 * b - 1 ;  $  TAB1 print b ;
TAB1 a,b=long long int, sum=0 ;  $  TAB1 read a,b ;  $  TAB1 sum=(a+1)/2 ;  $  TAB1 if sum >= b ;  $  TAB2 print b*2-1 ;  $  TAB1 else ;  $  TAB2 print (b-sum)*2 ;
TAB0 declare long long variables n and k ;  $  TAB1 read n and k ;  $  TAB1 if k <= (n + 1) / 2 ;  $  TAB2 print k * 2 - 1 ;  $  TAB1 else ;  $  TAB2 print (k - (n + 1) / 2) * 2 ;
TAB1 create long long n and k ;  $  TAB1 let j be long long ;  $  TAB1 read n and k ;  $  TAB1 if k<= (n+1)/2 ;  $  TAB2 print 2*k-1 ;  $  TAB1 else ;  $  TAB2 assign (k - (n + 1) / 2) * 2 to j ;  $  TAB2 print j ;
TAB1 create long long n, k, i, num ;  $  TAB1 read n and k ;  $  TAB1 set i = (n + 1) / 2 ;  $  TAB1 id k<= i ;  $  TAB2 assign 2*k-1 to num ;  $  TAB1 else ;  $  TAB2 k=k-i ;  $  TAB2 set num to 2*k ;  $  TAB1 print num ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 if k is less than or equal to (n + 1) / 2 ;  $  TAB2 print (k * 2) - 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print (k - (n + 1) / 2) * 2 and a new line ;
TAB1 declare long longs n and k ;  $  TAB1 read n and k ;  $  TAB1 if n is even ;  $  TAB2 if k <= n / 2 ;  $  TAB3 print 2 * k - 1 ;  $  TAB2 else ;  $  TAB3 print 2 * (k - n / 2) ;  $  TAB1 else ;  $  TAB2 if k <= (n + 1) / 2 ;  $  TAB3 print 2 * k - 1 ;  $  TAB2 else ;  $  TAB3 print 2 * (k - ((n + 1) / 2)) ;
TAB1 create variables n and k with type long long ;  $  TAB1 input n and k ;  $  TAB1 if k > (n/2 + n mod 2) ;  $  TAB2 print (k - n / 2 - n % 2) * 2 ;  $  TAB1 otherwise ;  $  TAB2 print k * 2 - 1 ;
TAB1 create long long n and k ;  $  TAB1 read n, k ;  $  TAB1 if k<= (n+1)/2 ;  $  TAB2 print k*2-1 ;  $  TAB1 else ;  $  TAB2 print (k - (n + 1) / 2) * 2 and a newline ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 if n is even ;  $  TAB2 if k is less than or equal to n / 2 ;  $  TAB3 print 2 * k - 1 and a new line ;  $  TAB2 else do the following ;  $  TAB3 print 2 * (k - n / 2) and a new line ;  $  TAB1 else do the following ;  $  TAB2 if k is less than or equal to (n + 1) / 2 ;  $  TAB3 print 2 * k - 1 and a new line ;  $  TAB2 else do the following ;  $  TAB3 print 2 * (k - (n + 1) / 2) and a new line ;
TAB1 declare long long n ;  $  TAB1 create long long k ;  $  TAB1 read n and k and keep looping ;  $  TAB2 if n is odd ;  $  TAB3 if k <= n / 2 + 1 ;  $  TAB4 print 2 * k - 1 ;  $  TAB3 else ;  $  TAB4 print 2 * k - n - 1 ;  $  TAB2 else ;  $  TAB3 if k <= n / 2 ;  $  TAB4 print 2 * k - 1 ;  $  TAB3 else ;  $  TAB4 print 2 * k - n ;
TAB1 declare long long variables n and k ;  $  TAB1 loop, reading n and k from the input ;  $  TAB2 if k <= (n + 1)>>1 ;  $  TAB3 assign k << 1 - 1 to k ;  $  TAB2 else{ ;  $  TAB3 decrease k by n + 1 >> 1 ;  $  TAB3 k = k << 1 ;  $  TAB2 print k ;
TAB1 create long long n and k ;  $  TAB1 read n, k ;  $  TAB1 if n is odd ;  $  TAB2 if k greater than ((n - 1) / 2) + 1) ;  $  TAB3 k = k - ((n - 1) / 2) - 1 ;  $  TAB3 assign 2*k to k ;  $  TAB2 esle ;  $  TAB3 set k to 2*k -1 ;  $  TAB1 else ;  $  TAB2 k greater than n/2 ;  $  TAB3 k = k - (n / 2) ;  $  TAB3 set k to 2*k ;  $  TAB2 else ;  $  TAB3 set k = 2 * k - 1 ;  $  TAB1 print k ;
TAB1 declare long long variables n and k ;  $  TAB1 read n and k ;  $  TAB1 set n to (n + 1) / 2 ;  $  TAB1 print 2 * (k - n) if k > n, else 2 * k - 1 ;
TAB1 create long longs n, k ;  $  TAB1 read n read k ;  $  TAB1 if k is less than or equal to ( n + 1 ) / 2 ;  $  TAB2 print k * 2 - 1 print newline ;  $  TAB1 else ;  $  TAB2 print ( k - ( n + 1 ) / 2 * 2 print newline ;
TAB1 n, k = long long ;  $  TAB1 read n and k ;  $  TAB1 part = long long with part = 0 ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 part = n / 2 ;  $  TAB1 else ;  $  TAB2 part = (n / 2) + 1 ;  $  TAB1 if k <= part ;  $  TAB2 print (k * 2) - 1 ;  $  TAB1 else ;  $  TAB2 print (k - part) * 2 ;
TAB1 let n, k, odd, ans be long long ints ;  $  TAB1 read n and k ;  $  TAB1 if n is even ;  $  TAB2 set odd to n / 2 ;  $  TAB1 else ;  $  TAB2 set odd to n / 2 + 1 ;  $  TAB1 if k <= odd ;  $  TAB2 set ans to k*2 - 1 ;  $  TAB1 else ;  $  TAB2 set ans to (k - odd) * 2 ;  $  TAB1 print empty string, then print ans ;
TAB1 create unsigned int n ;  $  TAB1 k=integer ;  $  TAB1 read n ;  $  TAB1 for i=1 to 4 inclusive ;  $  TAB2 if n mod i = 1 or n mod i = 2, set k to 1 ;  $  TAB2 if n mod 1 = 0 or n mod i = 3, k=0 ;  $  TAB1 print k ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 if n/2 is even ;  $  TAB3 print 0 ;  $  TAB2 otherwise ;  $  TAB3 print 1 ;  $  TAB1 else ;  $  TAB2 set n=n-1 ;  $  TAB2 if n/2 is even ;  $  TAB3 print 1 ;  $  TAB2 else ;  $  TAB3 print 0 and a newline ;
TAB0 set maxn to 2e5 + 5 ;  $  TAB0 create long long a[maxn] ;  $  TAB0 create long long b[maxn] ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 print ((n + 1) / 2) % 2 ;
TAB1 declare integer variable m ;  $  TAB1 read m ;  $  TAB1 print m + 1 >> 1 & 1 if m & 1, else print m >> 1 & 1; then print '\n' ;
TAB1 n = long long int ;  $  TAB1 read n ;  $  TAB1 if (n * (n + 1) / 2) modulo 2 is 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 create constant long long N = 1e8 + 3 ;  $  TAB0 create constant long long MN = 1e9 + 7 ;  $  TAB0 create constant long long MX = -1e9 - 7 ;  $  TAB0 create long longs n, l, a, t, l1, cnt, c and q ;  $  TAB0 create string variables s1 and s ;  $  TAB0 create array of pairs of long longs called pr, with 1001 element ;  $  TAB0 create vector of long longs called v ;  $  TAB0 create a map from characters to long longs with name mp ;  $  TAB0 create set of long longs st ;  $  TAB0 create set iterator it for a set of long longs ;  $  TAB1 read n ;  $  TAB1 n %= 4 ;  $  TAB1 if n = 0 or n = 3 ;  $  TAB2 print 0 ;  $  TAB1 else if n = 1 or n = 2 ;  $  TAB2 print 1 ;  $  TAB1 print "\n" ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 set (n * (n + 1)) / 2 to y ;  $  TAB1 if y mod 2 ;  $  TAB2 print 1 ;  $  TAB1 otherwise ;  $  TAB2 print 0 and a new line ;
TAB0 set constant integer N = 5005 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 4 equal to 0 or n modulo 4 = 3 ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print 1 ;
TAB1 create long long n, set sum = 0 ;  $  TAB1 read n ;  $  TAB1 assign n * (n + 1) / 2 to sum ;  $  TAB1 if sum is even ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print 1 and a newline ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n modulo 4 equal to 0 or n modulo 4 = 3 ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print 1 and a new line ;
TAB0 declare power with long longs x, y, m as arguments, returning long long ;  $  TAB1 if y is 1, return x % m from function ;  $  TAB1 if y is 0, return 1 from function ;  $  TAB1 if y bitwise and 1, return (x * result of run power with ( (x * x) % m, (y - 1) / 2, m ) as arguments ) % m from function ;  $  TAB1 return result of run power with ( (x*x) % m, y / 2, m ) as arguments % m from function ;  $  TAB0 declare modinv with long longs x, mod with mod = 1000000007 ;  $  TAB1 return result of run power with x, mod - 2, mod as arguments ;  $  TAB0 declare solve ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if (n * (n + 1) / 2) & 1 ;  $  TAB2 print 1 print newline ;  $  TAB1 else ;  $  TAB2 print 0 print newline ;  $  TAB1 run solve ;
TAB1 declare integer variables n, x and y ;  $  TAB1 read n ;  $  TAB1 n = (n * (n + 1)) / 2 ;  $  TAB1 x = n / 2 ;  $  TAB1 y = n - x ;  $  TAB1 print absolute value of x - y ;
TAB1 create long long n ;  $  TAB1 set ans = 0 ;  $  TAB1 read n ;  $  TAB1 set ans = n * (1 + n) / 2 ;  $  TAB1 if ans is even ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print 1 and a newline ;
TAB0 create long long int T and n ;  $  TAB0 create int array a of length 100010 + 5 ;  $  TAB0 set M = 1e9 + 7 ;  $  TAB1 read n ;  $  TAB1 n=n%4 ;  $  TAB1 if n is equal to 0 or n is equal to 3 ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print 1 and a newline ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 tmp = integer with n modulo 4 ;  $  TAB1 if tmp is equal to 1 OR tmp is equal to 2 ;  $  TAB2 print 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print 0 and a new line ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 if n mod 4 = 0 ;  $  TAB2 print 0 ;  $  TAB1 else if n mod 4 is equal to 1 ;  $  TAB2 print 1 and a new line ;  $  TAB1 otherwise if n modulo 4 = 2 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 and a new line ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 if (n is equal to 3 or n % 4 is equal to 0 or n % 4 is equal to 3) ;  $  TAB2 print 0 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 1 and newline ;
TAB1 n, s = long longs ;  $  TAB1 read n ;  $  TAB1 set s to ((n + 1) * n) / 2 ;  $  TAB1 if s % 2 is equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 if n modulo 4 = 3 || n modulo 4 = 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;  $  TAB1 print '\n' ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print ((n + 1) / 2) modulo 2 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print ((n + 1) / 2) modulo 2 ;
TAB0 create integer n ;  $  TAB0 create long longs a and b ;  $  TAB1 read n ;  $  TAB1 if n is even and n % 4 = 0 ;  $  TAB2 print 0 and '\n' ;  $  TAB1 else if n is even and n % 4 != 0 ;  $  TAB2 print 1 and '\n' ;  $  TAB1 else if n is odd and (n - 1) % 4 = 0 ;  $  TAB2 print 1 and '\n' ;  $  TAB1 else if n is odd and (n - 1) % 4 != 0 ;  $  TAB2 print 0 and '\n' ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create long long sum with sum = n * ( n + 1 ) ;  $  TAB1 set sum to sum / 2 ;  $  TAB1 create long long p with p = sum / n ;  $  TAB1 print p % 2 print newline ;
TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 print n * (n + 1) / 2 modulo 2 ;
TAB1 create long long integer n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 if n % 4 = 0 ;  $  TAB3 print 0 ;  $  TAB2 else ;  $  TAB3 print 1 ;  $  TAB1 else ;  $  TAB2 if (n - 1) % 4 = 0 ;  $  TAB3 print 1 ;  $  TAB2 else ;  $  TAB3 print 0 ;
TAB0 A = integer array of length 10000 ;  $  TAB0 B = integer array of length 10000 ;  $  TAB1 n, ans = integers with ans value of 0 ;  $  TAB1 read n ;  $  TAB1 if n mod 4 equals 1 or n mod 4 equals 2 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 4 equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 otherwise if n modulo 4 = 1 ;  $  TAB2 print 1 ;  $  TAB1 otherwise if n modulo 4 equal to 2 ;  $  TAB2 print 1 ;  $  TAB1 otherwise ;  $  TAB2 print 0 ;  $  TAB1 print a new line ;
TAB0 INF = const int with INF = 0x3f3f3f3f ;  $  TAB0 MAXN = const int with MAXN = 2e5 + 5 ;  $  TAB0 n = long long ;  $  TAB1 read n ;  $  TAB1 print n * (n + 1) / 2 modulo 2 ;
TAB0 create long long i, n and sum ;  $  TAB1 read n ;  $  TAB1 if n is even, set sum to n / 2 * (n + 1) ;  $  TAB1 if n mod 2 is different from 0, assign n / 2 * (n + 1) + (n / 2 + 1) to sum ;  $  TAB1 if sum modulo 2 is different from 0 ;  $  TAB2 print 1 ;  $  TAB1 otherwise ;  $  TAB2 print 0 and a new line ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is = 0 ;  $  TAB2 set m = n/2 ;  $  TAB2 if m modulo 2 equal to 0 ;  $  TAB3 print 0 ;  $  TAB2 otherwise ;  $  TAB3 print 1 ;  $  TAB1 otherwise ;  $  TAB2 set m= (n-1)/2 ;  $  TAB2 if m mod 2 = 0 ;  $  TAB3 print 1 ;  $  TAB2 other ;  $  TAB3 print 0 and a new line ;
TAB0 arr = long long array of size 200001 ;  $  TAB1 n, i, sum = long long with sum = 0 ;  $  TAB1 read n ;  $  TAB1 set sum to (n * (n + 1)) / 2 ;  $  TAB1 if sum is even ;  $  TAB2 print 0 ;  $  TAB1 else if sum is uneven ;  $  TAB2 print 1 ;
TAB0 x = long long int ;  $  TAB1 read x ;  $  TAB1 print ((x * (x + 1) / 2) modulo 2) ;
TAB0 mxaN = const int with maxN = 2012345678 ;  $  TAB0 n = int ;  $  TAB1 read n ;  $  TAB1 sum = long long int with sum = (n * (n + 1)) / 2 ;  $  TAB1 if sum is even ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create integer a ;  $  TAB1 read a ;  $  TAB1 print ((a + 1) / 2) % 2 print "\n" ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 n = n mod 4 ;  $  TAB1 if n=0 or n=3 ;  $  TAB2 print 0 ;  $  TAB1 otherwise ;  $  TAB2 print 1 and a newline ;
TAB1 n,m=int ;  $  TAB1 read n,m ;  $  TAB1 mn=n if n<m else m ;  $  TAB1 fact=1 ;  $  TAB1 for i=2 to mn inclusive multiply fact by i ;  $  TAB1 print fact ;
TAB1 declare new integer variables a and b ;  $  TAB1 read input to a and b ;  $  TAB1 new integer ans with value 1 ;  $  TAB1 for i from 1 to (min of a and b) inclusive, multiply ans by i ;  $  TAB1 print ans ;
TAB1 declare integer variables a, b and ans with ans = 1 ;  $  TAB1 read a and b ;  $  TAB1 if a is greater than b, change a to b ;  $  TAB1 in a for loop, change i from 1 to a inclusive, multiplying ans by i on every loop ;  $  TAB1 print ans to the standard output ;
TAB0 in function fact which accepts integer n and returns long long integer ;  $  TAB1 if n <= 0 ;  $  TAB2 return 1 ;  $  TAB1 else ;  $  TAB2 return n * fact(n - 1) ;  $  TAB1 a, b = long long integers ;  $  TAB1 read a and b ;  $  TAB1 x = long long integer set to min(a, b) ;  $  TAB1 print fact(x) ;
TAB1 let a, b, c be long integers ;  $  TAB1 read a, b ;  $  TAB1 if a is greater than b ;  $  TAB2 c is equal to a ;  $  TAB2 a is equal to b ;  $  TAB2 b is equal to c ;  $  TAB1 c is equal to 1 ;  $  TAB1 while a is true ;  $  TAB2 c is equal to c * a ;  $  TAB2 decrement a by 1 ;  $  TAB1 print c and newline ;
TAB1 a, b = integer ;  $  TAB1 sum = long long = 1 ;  $  TAB1 read a, b ;  $  TAB1 min = integer = a if a < b else min = b ;  $  TAB1 for i = 2 to min inclusive, then sum = sum * i ;  $  TAB1 print sum ;
TAB0 new array of integers dx with values 0, 0, -1, 1 ;  $  TAB0 new array of integers dy with values 1, -1, 0, 0 ;  $  TAB1 create new ints x and y ;  $  TAB1 read x and y from the input ;  $  TAB1 g is a new integer with value min of x and y ;  $  TAB1 create new integer called ans = 1 ;  $  TAB1 loop through i from 1 while i < g + 1, multiplying ans by i on each iteration ;  $  TAB1 print ans and '\n' ;
TAB0 function factorial with long argument A that returns long ;  $  TAB1 declare long variable with name ans = 1 ;  $  TAB1 for i from 1 to A inclusive, multiply ans by i ;  $  TAB1 return ans ;  $  TAB1 declare longs A and B ;  $  TAB1 read A and B from the user input ;  $  TAB1 print factorial(min of A and B) and "\n" to the standard output ;
TAB0 function fact (get long long n, return long long) ;  $  TAB1 if n is 0 or 1 ;  $  TAB2 return 1 ;  $  TAB1 else ;  $  TAB2 return n*fact(n-1) ;  $  TAB0 function gcd (get long long a and b, return long long) ;  $  TAB1 if b is 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return gcd(b, a modulo b) ;  $  TAB1 a,b=long long ;  $  TAB1 read a,b ;  $  TAB1 c=min(a,b) ;  $  TAB1 print fact(c) ;
TAB1 declare long longs t, i, j, n, m, k, ans, ck, cnt = 0, sum = 0, c = 0 ;  $  TAB1 declare strings s, s1, s2, tmp ;  $  TAB1 read n and m ;  $  TAB1 let ck be minimum of n and m ;  $  TAB1 declare long long face = 1 ;  $  TAB1 for i = 1 to ck inclusive, let fact be fact * i ;  $  TAB1 print face and newline ;
TAB0 declare function factorial which takes integer a ;  $  TAB1 if a is equal to 1 then return 1 ;  $  TAB1 return a * factorial(a - 1) ;  $  TAB1 create integers a and b ;  $  TAB1 read a and b ;  $  TAB1 if a is greater than b ;  $  TAB2 print factorial of b ;  $  TAB1 else ;  $  TAB2 print factorial of a ;
TAB1 a, b, x, i, k = long long int with k = 1 ;  $  TAB1 read a then b ;  $  TAB1 set x to min of a, b ;  $  TAB1 for i = 1 to x inclusive set k to k * i ;  $  TAB1 print k ;
TAB0 create new vector of integers called divisor with 1000000+1 elements filled with 0 ;  $  TAB0 integer function bigmod with long long arguments a, b and c ;  $  TAB1 create long long variable with name x ;  $  TAB1 if b is equal to 0, return 1 modulo c ;  $  TAB1 change x to bigmod(a, b / 2, c) ;  $  TAB1 set x to x squared % c ;  $  TAB1 if b & 1 is true, assign the new value = (x * a) % c to x ;  $  TAB1 return x ;  $  TAB0 ulong long function factorial with long long argument n ;  $  TAB1 new ulong long fact = 1 ;  $  TAB1 in a for loop, change i from 2 to n inclusive, multiplying fact by i ;  $  TAB1 return fact ;  $  TAB1 declare int variables x and y ;  $  TAB1 loop, reading x and y from the input ;  $  TAB2 new integer variable mn with value min of x and y ;  $  TAB2 new ulong long A = result of factorial(mn) ;  $  TAB2 print the result of __gcd(A, A) ;
TAB0 in the function fac that takes long long n and returns long long ;  $  TAB1 ans = long long with ans = 1 ;  $  TAB1 for i = 1 to n, ans = ans * i ;  $  TAB1 return ans ;  $  TAB1 a, b = long long ;  $  TAB1 read a, b ;  $  TAB1 print fac(min(a, b)) ;
TAB0 long long function gcd with long long arguments a and b ;  $  TAB1 if b != 0, return a ;  $  TAB1 return gcd(b, (a % b)) ;  $  TAB1 declare long long variables n, m, a and b with a and b = 1 ;  $  TAB1 read input to n and m ;  $  TAB1 if n is greater than m, swap n and m ;  $  TAB1 in a for loop, change i from 1 to n inclusive, multiplying a by i on each iteration ;  $  TAB1 start for loop from i = 1 to n + 1 inclusive, multiply b by i on each loop ;  $  TAB1 print gcd(a, b) and "\n" to the standard output ;
TAB1 a, b, i, ans, x = int with ans = 1 ;  $  TAB1 read a then b ;  $  TAB1 set x to min of a, b ;  $  TAB1 for i = 1 to x inclusive set ans to ans * i ;  $  TAB1 print ans ;
TAB1 declare ints a and b ;  $  TAB1 create long long variable sum = 1 ;  $  TAB1 read a and b and keep looping ;  $  TAB2 create new integer variable cnt with value min of a and b ;  $  TAB2 loop through i from 1 to cnt inclusive, multiplying sum byi on each iteration ;  $  TAB2 print sum ;
TAB1 a, b = integers ;  $  TAB1 read a and b ;  $  TAB1 mn, ans = integers with mn having value of the minimum of a and b, and ans having value of 1 ;  $  TAB1 for i = 2 to mn inclusive set ans to ans * i ;  $  TAB1 print ans ;
TAB0 declare long longs a, b, c, v and e ;  $  TAB1 read input to a and b ;  $  TAB1 if a <= b ;  $  TAB2 assign the new value = a to v ;  $  TAB1 else ;  $  TAB2 set v to b ;  $  TAB1 change the values of a and b to 1 ;  $  TAB1 while v > 0 ;  $  TAB2 change the value of b to b multiplied by a ;  $  TAB2 increment a by one ;  $  TAB2 decrement v by one ;  $  TAB1 print b ;
TAB0 create long long int fact(long int x) ;  $  TAB1 if x=0 or 1, return 1 ;  $  TAB1 return x * fact(x - 1) ;  $  TAB1 create long int a, b ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 if a > b ;  $  TAB2 print fact(b) and a newline ;  $  TAB1 else ;  $  TAB2 print fact(a) and a newline ;
TAB0 function fact (get int n, return int) ;  $  TAB1 if n is 1 return 1 ;  $  TAB1 return n*fact(n-1) ;  $  TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 output=fact(int(min(a,b))) ;  $  TAB1 print output ;
TAB0 maxn = 1e5 + 7 ;  $  TAB1 create int a and b ;  $  TAB1 read a, b ;  $  TAB1 set c to min of a and b ;  $  TAB1 ans = 1 ;  $  TAB1 for i=1 to c inclusive, set ans to ans *i ;  $  TAB1 print ans ;
TAB0 define function fact with long long as argument and returns a long long ;  $  TAB1 if x less than or equal to 1 then ;  $  TAB2 return 1 to the calling statement ;  $  TAB1 else do the following ;  $  TAB2 return x * return value of fact(x-1) to the calling statement ;  $  TAB1 create long long a, b ;  $  TAB1 read a, b ;  $  TAB1 if a greater than b then ;  $  TAB2 call fact(b) and print the return value ;  $  TAB1 else do the following ;  $  TAB2 call fact(a) and print the return value ;
TAB0 in function fact with argument integer n that returns an unsigned long long ;  $  TAB1 ans = unsigned long long = 1 ;  $  TAB1 while . >= 1 ;  $  TAB2 ans = ans * n ;  $  TAB2 decrease n by 1 ;  $  TAB1 return ans ;  $  TAB1 a, b = integer ;  $  TAB1 read a, b ;  $  TAB1 print call fact with argument of the lower value between a and b ;
TAB0 ll = long long with value of 1 ;  $  TAB1 a, b = integers ;  $  TAB1 read a and b ;  $  TAB1 if a is greater than b then set a to b ;  $  TAB1 for i = 2 to a inclusive set ll to ll * i ;  $  TAB1 print ll ;
TAB1 let a, b, x, i, k be long integers with k = 1 ;  $  TAB1 read a, b ;  $  TAB1 x is equal to minimum of a and b ;  $  TAB1 for i = 1 to x inclusive , k is equal to k * i ;  $  TAB1 print k and newline ;
TAB1 a,b=long long ;  $  TAB1 read a,b ;  $  TAB1 c=min(a,b) ;  $  TAB1 ans=1 ;  $  TAB1 for i=1 to c inclusive multiply ans by i ;  $  TAB1 print ans ;
TAB1 a, b, c, d =integers with c = 1 ;  $  TAB1 Read a, b ;  $  TAB1 set d to minimum value of a and b ;  $  TAB1 for i = 1 to d exclusive, then set c to c * i ;  $  TAB1 print c and a new line ;
TAB1 a, b = long long ;  $  TAB1 read a and b ;  $  TAB1 if a is less than b then set a to a otherwise set a to b ;  $  TAB1 set b to 1 ;  $  TAB1 for i = 2 to a inclusive set b to b * i ;  $  TAB1 print b ;
TAB1 declare integers a, b ;  $  TAB1 while read a, b ;  $  TAB2 declare integer t ;  $  TAB2 let t be a ;  $  TAB2 if b is less than a, let t be b ;  $  TAB2 declare integer i ;  $  TAB2 declare integer k = 1 ;  $  TAB2 for i = 1 to t inclusive, let k be k * i ;  $  TAB2 print k and newline ;
TAB1 create long long ints a and b ;  $  TAB1 read a and b ;  $  TAB1 let i and f = 1 be long long integers ;  $  TAB1 loop until break ;  $  TAB2 f = f * i ;  $  TAB2 if i is equal to a or i is equal to b ;  $  TAB3 print f ;  $  TAB3 break ;
TAB0 in long long function factorial taking n = long long ;  $  TAB1 if n > 1 ;  $  TAB2 return n * factorial of n-1 ;  $  TAB1 else ;  $  TAB2 return 1 ;  $  TAB1 a, b, ans = long long ;  $  TAB1 read a and b ;  $  TAB1 set ans to min of a and b ;  $  TAB1 print factorial of ans ;
TAB0 declare facto with long long n as argument, returning long long ;  $  TAB1 if n is 0 or n is 1, return 1 from function ;  $  TAB1 declare long long array fact size 18 = {0} ;  $  TAB1 let fact[0] be 1 ;  $  TAB1 for i = 1 to n inclusive, let fact[i] be fact[i-1] * i ;  $  TAB1 return fact[n] from function ;  $  TAB1 declare long longs a, b ;  $  TAB1 read a and b ;  $  TAB1 print result of run facto with minimum of a and b as argument, "\n" ;
TAB1 t, a, b, c, i, d, k =integers with i = 0, d = 1, k = 1 ;  $  TAB1 Read a, c ;  $  TAB1 set i to minimum value of a and c ;  $  TAB1 for t = 1 to i exclusive ;  $  TAB1 print d and a new line ;
TAB1 create integer n ;  $  TAB1 while read n is true ;  $  TAB2 create long long answ with answ = n ;  $  TAB2 for i = 1, a to n inclusive, incrementing i ;  $  TAB3 read a ;  $  TAB3 increment answ by long long casted i * ( a - 1 ) ;  $  TAB2 print answ print newline ;
TAB0 function Fast_Read_Out ;  $  TAB0 define function Random ;  $  TAB1 define unsigned long long seed ;  $  TAB1 call asm with arguments "rdtsc" : "=A"(seed) ;  $  TAB1 initialze random number generator with seed ;  $  TAB0 unsigned long long function Time ;  $  TAB1 unsigned long long time = clock() / 1000.00 ;  $  TAB1 return time ;  $  TAB0 create constant long long inf with value (1e9) + 123 ;  $  TAB0 a is an array of long longs with size 101 ;  $  TAB0 dp is an long long array with size 101 ;  $  TAB1 invoke function Random ;  $  TAB1 invoke function Fast_Read_Out ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 for i = 1 to n inclusive set dp[i] = to (a[i] - 1) * i + 1 ;  $  TAB1 create long long sum = 0 ;  $  TAB1 for i = 1 to n inclusive increase sum by dp[i] ;  $  TAB1 print sum and a new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create long long array arr with size n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 create long long ans with ans = 0 ;  $  TAB1 for i = 0 to n exclusive, set ans to ans + ( i + 1 ) * arr[i] - i ;  $  TAB1 print ans print newline ;
TAB1 n is long long ;  $  TAB1 read n ;  $  TAB1 declare long long called tot = 0 ;  $  TAB1 declare long long called input ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 read input ;  $  TAB2 increase tot by i * (input - 1) ;  $  TAB1 increase tot by n ;  $  TAB1 print tot and a new line ;
TAB1 create long long integers n, s, m with s = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read m ;  $  TAB2 increment s by m + i * ( m - 1 ) ;  $  TAB1 print s print newline ;
TAB0 n and ans are long longs with ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare long long a ;  $  TAB2 read a ;  $  TAB2 increase ans by (a - 1) * (i - 1) + a ;  $  TAB1 print ans and a new line ;
TAB1 declare integer n ;  $  TAB1 create long longs a and Ans and long long array ara with size 101 ;  $  TAB1 read n ;  $  TAB1 read a ;  $  TAB1 assign value of a to Ans ;  $  TAB1 for integer i = 1 to n exclusive ;  $  TAB2 read ara[i] ;  $  TAB2 increase Ans by (ara[i] - 1) * (i + 1) + 1 ;  $  TAB1 print Ans ;
TAB1 n = long long, a = array of 101 long long filled with 0, ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive read a[i] ;  $  TAB1 for i=1 to n inclusive sum (a[i]-1])*i+1 to ans ;  $  TAB1 print ans ;
TAB0 desperate_optimization is a void function with integer argument precision ;  $  TAB1 cout.setf(ios::fixed) ;  $  TAB1 cout.setf(ios::showpoint) ;  $  TAB1 cout.precision(precision) ;  $  TAB0 in the function hora with integer argument tc ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 declare long long variable tot = 0 ;  $  TAB1 for long long i = 1 to n inclusive ;  $  TAB2 create long long x ;  $  TAB2 read x ;  $  TAB2 increase tot by (i) * (x - 1) + 1 ;  $  TAB1 print tot and '\n' ;  $  TAB1 call desperate_optimization with 10 as an argument ;  $  TAB1 declare integer variable ntc = 1 ;  $  TAB1 for integer tc = 1 to ntc inclusive, call hora of tc ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 declare long long ans = 0 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 declare long long variable a ;  $  TAB2 read a ;  $  TAB2 increase ans by (i + 1) * (a - 1) + 1 ;  $  TAB1 print ans and a new line ;
TAB0 create constant integer M with M = 100 + 10 ;  $  TAB0 create long long integer a with size M ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 create long long integer ans with ans = 0 ;  $  TAB1 for i = 1 to n inclusive, set ans to ans + (i - 1) * (a[i] - 1) + a[i] ;  $  TAB1 print ans print newline ;
TAB1 declare long long variables a, b, i and k where b = 0 ;  $  TAB1 read a ;  $  TAB1 for i = 1 to a inclusive ;  $  TAB2 read k ;  $  TAB2 if i = 1 || k = 1 ;  $  TAB3 increase b by k ;  $  TAB2 else ;  $  TAB3 multiply k by i ;  $  TAB3 decrease k by i - 1 ;  $  TAB3 increase b by k ;  $  TAB1 print b and a new line ;
TAB0 create long longs ans, n create long long array a with size 101 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = 1 to n inclusive, set ans to ans + a[i] * i + 1 - i ;  $  TAB1 print ans print newline ;
TAB1 create integer n ;  $  TAB1 create long long array arr with size 102 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read arr[i] ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 for i = 1 to n inclusive, increment sum by (arr[i]-1)*i ;  $  TAB1 increment sum by n ;  $  TAB1 print sum print newline ;
TAB0 create long longs, n, ans, cnt, create long long array a with size 105 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 set ans to a[n-1] ;  $  TAB1 for i = n - 2 to 0 inclusive, decrementing i, increment a[i] by a[i + 1] - 1, increment ans by a[i] ;  $  TAB1 print ans print newline ;
TAB1 create long longs n and a ;  $  TAB1 read n ;  $  TAB1 create long long ans = 0 ;  $  TAB1 for long long i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 increase ans by (a - 1) * i + 1 ;  $  TAB1 print ans ;
TAB1 create long longs a, b, i, k, with b = 0 ;  $  TAB1 read a ;  $  TAB1 for i = 1 to a inclusive ;  $  TAB2 read k ;  $  TAB2 if i is 1 or k is 1 ;  $  TAB3 increment b by k ;  $  TAB2 else ;  $  TAB3 set k to k * i ;  $  TAB3 decrement k by i - 1 ;  $  TAB3 increment b by k ;  $  TAB1 print b print newline ;
TAB0 let a,i,k,n be unsigned long integers ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 k is equal to k + (a - 1) * i ;  $  TAB2 increase k by 1 ;  $  TAB1 print k and endline ;
TAB1 declare long longs n, a and ans ;  $  TAB1 read n and a ;  $  TAB1 set ans to a ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 read a ;  $  TAB2 increase ans by 1 + (a - 1) * i ;  $  TAB1 print ans and a new line ;
TAB0 create interger t ;  $  TAB0 create long integer a ;  $  TAB0 create long integer sum ;  $  TAB1 while(t value is entered) ;  $  TAB2 set sum to 0 ;  $  TAB2 for(int i=0 to t(exclusive)) ;  $  TAB3 read a ;  $  TAB3 add (a-1) * i +a to sum ;  $  TAB2 print out sum ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 let total(0) be a long type integer ;  $  TAB1 for ( long integer p=0 to n exclusive ) ;  $  TAB2 let m be a long integer ;  $  TAB2 read m ;  $  TAB2 let the value of total is equal to total + (m - 1) * (p + 1) + 1 ;  $  TAB1 print total and newline ;
TAB0 create long longs ans, n, create long long array a with size 105 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = 1 to n inclusive, set ans to ans + a[i] * i + 1 - i ;  $  TAB1 print ans print '\n' ;
TAB1 declare long long variable n ;  $  TAB1 read n ;  $  TAB1 long long total = 0 ;  $  TAB1 for long = 0 to n exclusive ;  $  TAB2 create long long m ;  $  TAB2 read m ;  $  TAB2 increase total by (m - 1) * (p + 1) + 1 ;  $  TAB1 print total ;
TAB1 create long long n ;  $  TAB1 create long long sum ;  $  TAB1 while reading n ;  $  TAB2 set sum to 0 ;  $  TAB2 for integer i = 1 to n inclusive ;  $  TAB3 declare long long m ;  $  TAB3 read m ;  $  TAB3 increase sum by i * (m - 1) + 1 ;  $  TAB2 print sum ;
TAB0 declare abs with long long, long long as arguments, returning long long ;  $  TAB0 declare solve with no arguments, returning void ;  $  TAB1 create long longs n, a, t, with t = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n + 1 exclusive ;  $  TAB2 read a ;  $  TAB2 increment t by ((a - 1) * i + 1) ;  $  TAB1 print t print "\n" ;  $  TAB1 create long long TESTS with TESTS = 1 ;  $  TAB1 while decrement TESTS is true, run solve ;  $  TAB0 declare abs with long longs a, b as arguments, returning long long ;  $  TAB1 if a is greater than b ;  $  TAB2 return a - b from function ;  $  TAB1 else ;  $  TAB2 return b - a from function ;
TAB0 create constant integer INF with value 0x3f3f3f3f ;  $  TAB0 create integer array a with 105 elements ;  $  TAB1 declare long long variables i, j, k and l where l = 0 ;  $  TAB1 create long longs n and m ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive read a[i] and decrement it ;  $  TAB1 create long long s = n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i], increment s by a[i] + a[i] * i ;  $  TAB1 print s ;
TAB1 create integer n ;  $  TAB1 declare long long integer array a with size 150 ;  $  TAB1 declare long long integer variable sum = 0 ;  $  TAB1 while reading n ;  $  TAB2 assign value of 0 to sum ;  $  TAB2 for i = 1 to n inclusive read a[i] ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if i = 1 ;  $  TAB4 increase sum by a[1] ;  $  TAB3 else ;  $  TAB4 increase sum by (a[i] - 1) * i + 1 ;  $  TAB2 print sum ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare long long array a with size n ;  $  TAB1 read a[i] n times ;  $  TAB1 declare long long variable sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 increase sum by a[i] ;  $  TAB2 increase sum by (a[i] - 1) * i ;  $  TAB1 print sum ;
TAB1 declare integer n and integer array a with size 101 ;  $  TAB1 read n ;  $  TAB1 declare long long ans = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 increase ans by 1LL * (a[i] - 1) * (i - 1) + a[i] ;  $  TAB1 print ans ;
TAB0 assign value 0x3f3f3f3f to constant integer inf ;  $  TAB0 assign value 10005 to constant integer MAXN ;  $  TAB0 assign value 19260817 to constant integer mod ;  $  TAB0 assign value 0x7fffffff to constant integer INF ;  $  TAB0 ans is an long long array with size 101 ;  $  TAB1 create integers n and x ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive write input to ans[i] ;  $  TAB1 declare long long variable sum = 0 ;  $  TAB1 for i = 1 to n inclusive, increase sum by ans[i] * i - i + 1 ;  $  TAB1 print sum and a new line ;
TAB1 arr is a new array of integers with size 3 by 1005 ;  $  TAB1 define integers n and s ;  $  TAB1 read standard input to n and s ;  $  TAB1 in a for loop, change i from 0 to 2 exclusive incrementing i ;  $  TAB2 change j from 1 to n inclusive in a loop and read input to arr[i][j] on each iteration ;  $  TAB1 create integer variable with name cek ;  $  TAB1 if arr[0][1] != 0 and (arr[0][s] != 0 or arr[1][s] != 0 ) ;  $  TAB2 change the value of cek to 1 ;  $  TAB2 if arr[0][s] is equal to 0 ;  $  TAB3 assign 0 to cek ;  $  TAB3 for i from s + 1 to n inclusive incrementing i ;  $  TAB4 if arr[0][i] and arr[1][i] are both not 0, change the value of cek to 1 ;  $  TAB1 else ;  $  TAB2 change the value of cek to 0 ;  $  TAB1 print "YES" if cek is not 0, otherwise print "NO" ;
TAB1 define new integers n and m, and arrays a and b with 1111 element ;  $  TAB1 read from the input to n and m ;  $  TAB1 read standard input to n elements of a, starting from the index 1 ;  $  TAB1 read from the input to n items of b, starting from the index 1 ;  $  TAB1 if a[1] is equal to 0 ;  $  TAB2 print "NO" to the standard output ;  $  TAB1 flag is a new integer variable with value 0 ;  $  TAB1 if a[m] is not 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 if b[m] is 0 ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 for integer i = m + 1 to n inclusive ;  $  TAB4 if both a[i] and b[i] are not 0 ;  $  TAB5 assign 1 to flag ;  $  TAB5 print "YES" ;  $  TAB3 if flag is false, print "NO" ;
TAB1 let n, s be integers ;  $  TAB1 read n, s ;  $  TAB1 a = array of integers of length n , b = array of integers of length n ;  $  TAB1 for i = 0 to n exclusive , read a[i] ;  $  TAB1 for i = 0 to n exclusive , read b[i] ;  $  TAB1 if a[0] equals 0 ;  $  TAB2 print NO and newline ;  $  TAB1 else if a[s - 1] equals 0 and b[s - 1] equals 0 ;  $  TAB2 print NO and newline ;  $  TAB1 else if a[s - 1] equals 1 ;  $  TAB2 print YES and newline ;  $  TAB1 else if a[s - 1] equals 0 and b[s - 1] equals 1 ;  $  TAB2 the integer value of k = 0 ;  $  TAB2 for i = s to n exclusive ;  $  TAB3 if a[i] equals 1 and b[i] equals 1 ;  $  TAB4 k is equal to 1 ;  $  TAB4 print YES and newline ;  $  TAB2 if k equals 0 ;  $  TAB3 print NO and newline ;
TAB0 n, s = int ;  $  TAB0 a, b = bool array of size 1111 ach ;  $  TAB1 read n then s ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 for i = 1 to n inclusive read b[i] ;  $  TAB1 if not a[1] ;  $  TAB2 print "NO" ;  $  TAB1 else if a[1] and a[s] ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 flag = int with flag = = ;  $  TAB2 for i = s + 1 to n inclusive ;  $  TAB3 if a[i] ;  $  TAB4 if b[i] and b[s] ;  $  TAB5 set flag to 1 ;  $  TAB5 break ;  $  TAB2 if flag ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 let N and S be integers ;  $  TAB1 read in N and S ;  $  TAB1 decrement S ;  $  TAB1 let a and b be arrays of integers of size N ;  $  TAB1 read in N values into a ;  $  TAB1 read in N values into b ;  $  TAB1 if a[0] and a[S] are true ;  $  TAB2 print YES ;  $  TAB1 for k = S + 1 to k < N ;  $  TAB2 if a[0] and a[k] and b[k] and b[S] are true ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB0 declare an arrays of ints a and b with 1005 elements ;  $  TAB1 declare new int variables n and m ;  $  TAB1 read n and m from the input ;  $  TAB1 read n elements into array a from the input, starting from the index 1 ;  $  TAB1 read n elements into b, starting from the index 1 ;  $  TAB1 if a[1] is equal to 0 ;  $  TAB2 print "NO" ;  $  TAB1 else if a[1] and a[m] are both equal to 1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 if b[m] = 0 ;  $  TAB3 print "NO" to the output stream ;  $  TAB2 else ;  $  TAB3 declare new integer variable bj with value 0 ;  $  TAB3 in a for loop, change i from m + 1 to n inclusive ;  $  TAB4 set the value of bj to 1 if a[i] and b[i] are both = 1 ;  $  TAB3 if bj is not 0 ;  $  TAB4 print "YES" to the standard output ;  $  TAB3 else ;  $  TAB4 print "NO" ;
TAB0 create constant integer mx = 1000 ;  $  TAB0 define new integers n and s ;  $  TAB0 create bool arrays a and b with size mx ;  $  TAB0 in the function solve ;  $  TAB1 read input to n and s ;  $  TAB1 declare new int variables t1 and t2 = 0 ;  $  TAB1 read n elements to the a ;  $  TAB1 read n elements into items of b ;  $  TAB1 if a[0] = 1, change the value of t1 to 1 ;  $  TAB1 if a[s - 1] = 1 or b[s - 1] = 1 ;  $  TAB2 in a for loop, change i from s - 1 to n exclusive incrementing i ;  $  TAB3 if values of a[i] and b[i] are both = 1 ;  $  TAB4 set the value of t2 to 1 ;  $  TAB4 break ;  $  TAB1 if t1 = 1 and (t2 = 1 or a[s - 1] = 1) ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;  $  TAB1 call method solve() ;
TAB0 let maxn be a constant integer 1e5 + 5 ;  $  TAB0 let a, b be integer arrays of size maxn ;  $  TAB1 n, m be integers ;  $  TAB1 read n, m ;  $  TAB1 for integer i = 0 to n inclusive, read a[i] ;  $  TAB1 for integer j = 0 to n inclusive, read b[j] ;  $  TAB1 if a[1] equal 0 ;  $  TAB2 print NO and newline ;  $  TAB1 if a[m] equal 1 ;  $  TAB2 print YES and endline ;  $  TAB1 for integer i = m to n inclusive ;  $  TAB2 if a[i] ,b[i] ,b[m] all equal 1 ;  $  TAB3 print YES and endline ;  $  TAB1 print NO and newline ;
TAB0 create function solve ;  $  TAB1 long long integer as n,s ;  $  TAB1 read n,s ;  $  TAB1 long long integer as a[n],b[n] ;  $  TAB1 input a[i] ;  $  TAB1 input b[i] ;  $  TAB1 if a[0] is 1 then do the following ;  $  TAB2 if a[s - 1] is 1 then do the following ;  $  TAB3 output YES\n ;  $  TAB2 else ;  $  TAB3 long long integer as ng long h = 0 ;  $  TAB3 for s to less than n do the following ;  $  TAB4 if a[i] and b[i] is 1 then do the following ;  $  TAB5 set h to 2 ;  $  TAB5 break ;  $  TAB3 if h is 2 and b[s - 1] is 1 then do the following ;  $  TAB4 output YES\n ;  $  TAB3 else ;  $  TAB4 output NO\n ;  $  TAB1 else ;  $  TAB2 output NO\n ;  $  TAB1 long long integer as t = 1 ;  $  TAB1 if t is true then run solve function ;
TAB1 let n, s be long integers , a = array of integers of length 1001, b = array of integers of length 1001 ;  $  TAB1 read n , s ;  $  TAB1 for long integer i = 1 to n inclusive , read a[i] ;  $  TAB1 for long integer i = 1 to n inclusive, read b[i] ;  $  TAB1 if a[1] equals 0 ;  $  TAB2 print NO and newline ;  $  TAB1 if a[s] equals 1 ;  $  TAB2 print YES and newline ;  $  TAB1 the boolean value of flag = false ;  $  TAB1 for long integer i = s + 1 to n inclusive ;  $  TAB2 if a[i] equals 1 and b[i] equals 1 ;  $  TAB3 flag is equal to true ;  $  TAB3 stop ;  $  TAB1 if flag is equal to false ;  $  TAB2 print NO and newline ;  $  TAB1 if b[s] equals 1 ;  $  TAB2 print YES and newline ;  $  TAB1 print NO and newline ;
TAB1 make ints n and s ;  $  TAB1 read n and s ;  $  TAB1 create integer array a of size n + 1 with {0} ;  $  TAB1 make int array b of size n + 1 with {0} ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 for i = 1 to n, read b[i] ;  $  TAB1 if a[1] is equal to 0 ;  $  TAB2 print "NO\n" ;  $  TAB1 if a[s] is equal to 1 ;  $  TAB2 show "YES\n" ;  $  TAB1 for i = s + 1 to n ;  $  TAB2 if a[i] is equal to 1 and b[i] is equal to 1 and b[s] is equal to 1 ;  $  TAB3 show "YES\n" ;  $  TAB1 display "NO\n" ;
TAB1 define new integers n and s ;  $  TAB1 read n and s from the input ;  $  TAB1 new vector of integers forward with size = n + 1, filled with 0 ;  $  TAB1 declare vector of integers called backward with n + 1 element filled with 0 ;  $  TAB1 for integer i = 1 to n inclusive, read input to forward[i] ;  $  TAB1 read n elements to backward, starting from the index 1 ;  $  TAB1 if forward[1] = 0 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 if forward[s] = 1 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 if backward[s] is equal to 1 ;  $  TAB4 declare boolean variable with name availabe and value false ;  $  TAB4 for i from s + 1 to n inclusive incrementing i ;  $  TAB5 if forward[i] and backward[i] = 1 ;  $  TAB6 assign true to availabe ;  $  TAB6 break the loop ;  $  TAB4 print "YES" if availabe is true, print "NO" otherwise ;  $  TAB3 else ;  $  TAB4 print "NO" ;
TAB0 make integer arrays a of size 10000 and b of size 10000 ;  $  TAB0 create bool ab = 0 ;  $  TAB1 make ints n, s, i, z = 1, x, and c ;  $  TAB1 read n and s ;  $  TAB1 set x to n + 1 ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 for i = 1 to n, read b[i] ;  $  TAB1 if a[s] is equal to 1 and a[1] is equal to 1 ;  $  TAB2 set ab to 1 ;  $  TAB1 else do ;  $  TAB2 for i = n to 1 by decreasing by 1 ;  $  TAB3 if a[i] is equal to 1 and b[i] is equal to 1 ;  $  TAB4 if i is greater than s and b[s] is equal to 1, set ab to 1 ;  $  TAB1 if a[1] is 0, set ab to 0 ;  $  TAB1 if ab is equal to 1 ;  $  TAB2 display "YES" ;  $  TAB1 otherwise ;  $  TAB2 output "NO" ;
TAB1 n, s =integers ;  $  TAB1 t1, t2 = array of 100000 integers each ;  $  TAB1 Read n, s ;  $  TAB1 Read n values into array t1 ;  $  TAB1 Read n values into array t2 ;  $  TAB1 if t1[0] is equal to 1 ;  $  TAB2 if t1[s - 1] is equal to 1 ;  $  TAB3 print YES and a new line ;  $  TAB2 if t2t[s - 1] is equal to 1 ;  $  TAB3 for i = s to n exclusive ;  $  TAB4 if t1[i] is 1 and t2[i] is 1 ;  $  TAB5 print YES and a new line ;  $  TAB1 print NO and a new line ;
TAB1 let n and s be integers ;  $  TAB1 read in n and s ;  $  TAB1 let a be an array of integers of size n + 1, let b be an array of integers of size n + 1 ;  $  TAB1 read in n values into array a ;  $  TAB1 read in n values into array b ;  $  TAB1 if a[1] is equal to 1 ;  $  TAB2 if a[s] is equal to 1 ;  $  TAB3 print YES ;  $  TAB2 else if b[s] is equal to 1 ;  $  TAB3 for i = s + 1 to i <= n ;  $  TAB4 if a[i] is equal to 1 and b[i] is equal to 1 ;  $  TAB5 print YES ;  $  TAB3 print NO ;  $  TAB2 or else ;  $  TAB3 print NO ;  $  TAB1 or else ;  $  TAB2 print NO ;
TAB0 let n be a integer ;  $  TAB0 the integer value of ans = -1 ;  $  TAB0 the integer value of res = 0 ;  $  TAB1 read n ;  $  TAB1 a = array of integers of length n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is equal to 1 , increment res by 1 ;  $  TAB1 if res is equal to n ;  $  TAB2 print n - 1 and newline ;  $  TAB1 if n is equal to 1 and a[0] is equal to 1 ;  $  TAB2 print 0 and newline ;  $  TAB1 for j = 0 to n exclusive ;  $  TAB2 for k = 0 to n exclusive ;  $  TAB3 the integer value of cnt = 0 ;  $  TAB3 for l = 0 to n exclusive ;  $  TAB4 if l >= k and l <= j ;  $  TAB5 increment cnt by (1 - a[l]) ;  $  TAB4 else do the following ;  $  TAB5 increment cnt by a[l] ;  $  TAB3 ans is equal to maximum of ans and cnt ;  $  TAB1 print ans and newline ;
TAB0 create n ;  $  TAB0 ans = -1 ;  $  TAB0 res=0 ;  $  TAB1 read n ;  $  TAB1 create int a[n] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] = 1, increment res ;  $  TAB1 if res=n ;  $  TAB2 print n-1 ;  $  TAB1 if n = 1 and a[0] = 1 ;  $  TAB2 print 0 ;  $  TAB1 for j=0 to n exclusive ;  $  TAB2 for k=0 to n inclusive ;  $  TAB3 cnt=0 ;  $  TAB3 for l=0 to n exclusive ;  $  TAB4 if l >= k and l <= j ;  $  TAB5 cnt = cnt + !a[l] ;  $  TAB4 else ;  $  TAB5 set cnt = cnt + a[l] ;  $  TAB3 set ans to max of ans and cnt ;  $  TAB1 print ans ;
TAB1 let max = 0, n, i, sum = 0, a[105], p be ints ;  $  TAB1 read n ;  $  TAB1 set p to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a at i ;  $  TAB2 increment sum by a at i ;  $  TAB1 if sum = n ;  $  TAB2 print sum - 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a [i] = 0 ;  $  TAB3 increment p ;  $  TAB2 else if a[i] = 1 and p < 0 ;  $  TAB3 reset p to 0 ;  $  TAB2 else if a[i] = 1 and p > 0 ;  $  TAB3 decrement p ;  $  TAB2 if max < p then set max to p ;  $  TAB1 increment sum by max ;  $  TAB1 print sum ;
TAB1 make ints n, a, cnt_1 = 0, cnt_0 = 0, and cnt_max0 = -1 ;  $  TAB1 read n ;  $  TAB1 while n-- is truthy ;  $  TAB2 read a ;  $  TAB2 if a is equal to 1 ;  $  TAB3 add 1 to cnt_1 ;  $  TAB3 if cnt_0 is greater than 0, subtract 1 from cnt_0 ;  $  TAB2 if a is equal to 0 ;  $  TAB3 add 1 to cnt_0 ;  $  TAB3 if cnt_0 is greater than cnt_max0, set cnt_max0 is equal to cnt_0 ;  $  TAB1 make integer ans = cnt_1 + cnt_max0 ;  $  TAB1 display ans ;
TAB0 cnt1, cnt0 = int array of size 105 each ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = int array of size n + 1 ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 set cnt1[0] to 0 ;  $  TAB1 set cnt0[0] to 0 ;  $  TAB1 maxv = int with maxv = -100 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 set cnt1[i] to cnt1[i - 1] + a[i] ;  $  TAB2 set cnt0[i] to i - cnt1[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = i to n inclusive ;  $  TAB3 if (cnt0[j] - cnt0[i - 1]) - (cnt1[j] - cnt1[i - 1]) + cnt1[n] > maxv set maxv to (cnt0[j] - cnt0[i - 1]) - (cnt1[j] - cnt1[i - 1]) + cnt1[n] ;  $  TAB1 print maxv ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 arr = array of integers of size n ;  $  TAB1 set cnt = 0 ;  $  TAB1 set def = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 a, b = integers set a and b = 0 ;  $  TAB2 for j = i to 0 inclusive ;  $  TAB3 if arr[j] = 0 ;  $  TAB4 increment a ;  $  TAB3 else ;  $  TAB4 increment b ;  $  TAB3 set d = max of def and a-b ;  $  TAB2 if arr[i] = 1 increment cnt ;  $  TAB1 print cnt + def ;
TAB0 the 1001th element of array a is equal to 0 ;  $  TAB1 let n, c be integers with c = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is equal to 1 ;  $  TAB3 a[i] = -1 ;  $  TAB3 increment c by 1 ;  $  TAB2 else do the following ;  $  TAB3 a[i] is equal to 1 ;  $  TAB1 let ans, maxx be integers with ans = a[0], maxx = a[0] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 maxx = maximum of a[i] and maxx + a[i] ;  $  TAB2 ans = maximum of ans and maxx ;  $  TAB1 print c + ans and newline ;
TAB1 let n, a, count1(0), extra0(0), extra0max(-1) be integers ;  $  TAB1 read n ;  $  TAB1 while n is decremented by 1 ;  $  TAB2 read a ;  $  TAB2 if a is equal to 1 ;  $  TAB3 increment count1 by 1 ;  $  TAB3 if extra0 is greater than 0 , decrement extra0 by 1 ;  $  TAB2 else do the following ;  $  TAB3 increment extra0 by 1 ;  $  TAB3 if extra0 is greater than extra0max , extra0max is equal to extra0 ;  $  TAB1 print count1 + extra0max and newline ;
TAB1 create int a[105], n, ans, set ans =0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive, read a[i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to i inclusive ;  $  TAB3 v=0 ;  $  TAB3 for k=0 to n exclusive ;  $  TAB4 if k >=j and k<= i ;  $  TAB5 set v=v+a[k]=0 ;  $  TAB4 else ;  $  TAB5 v= v+a[k] ;  $  TAB3 set ans to max of ans and v ;  $  TAB1 print ans and a newline ;
TAB1 a = int array of size 105 ;  $  TAB1 n, ans = int with ans = 0 ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 for i = 0 to n ;  $  TAB2 for j = 0 to i inclusive ;  $  TAB3 v = int with v = 0 ;  $  TAB3 for k = 0 to n ;  $  TAB4 if k >= j and k <= i ;  $  TAB5 increment v by not a[k] ;  $  TAB4 else ;  $  TAB5 increment v by a[k] ;  $  TAB3 set ans to max of ans, v ;  $  TAB1 print ans ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create vector int a(n) ;  $  TAB1 cnt =0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] = 1 ;  $  TAB3 a[i] = -1 ;  $  TAB3 increment cnt ;  $  TAB2 if a[i] = 0, a[i] = 1 ;  $  TAB1 set gmax = INT_MIN, lmax = 0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set lmax to lmax + a[i] ;  $  TAB2 set gmax = max(gmax, lmax) ;  $  TAB2 if lmax <0, lmax =0 ;  $  TAB1 print cnt + gmax ;
TAB1 create ints n, a, count1(0), extra0(0), and extra0max(-1) ;  $  TAB1 read n ;  $  TAB1 while n-- is truthy ;  $  TAB2 read a ;  $  TAB2 if a is equal to 1 ;  $  TAB3 add 1 to count1 ;  $  TAB3 if extra0 is greater than 0, subtract 1 from extra0 ;  $  TAB2 else do ;  $  TAB3 add 1 to extra0 ;  $  TAB3 if extra0 is greater than extra0max, set extra0max to extra0 ;  $  TAB1 show result of count1 + extra0max ;
TAB0 declare constant integer N = 1e6+7 ;  $  TAB1 declare integer n ;  $  TAB1 declare integer cnt = 0 ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 read n ;  $  TAB1 declare integer array a size n ;  $  TAB1 for i = 0 to integer casted ( n - 1 ) inclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is true ;  $  TAB3 let a[i] be -1, increment cnt ;  $  TAB2 else ;  $  TAB3 let a[i] be 1 ;  $  TAB1 declare integer mx = INT_MIN ;  $  TAB1 for i = 0 to integer casted ( n - 1 ) inclusive ;  $  TAB2 increment ans by a[i] ;  $  TAB2 if ans is greater than mx, let mx be ans ;  $  TAB2 if ans less than 0, let ans be 0 ;  $  TAB1 print mx + cnt and '\n' ;
TAB1 create ints n, a, count1(0), extra0(0), and extra0max(-1) ;  $  TAB1 read n ;  $  TAB1 while n-- is truthy ;  $  TAB2 read a ;  $  TAB2 if a is equal to 1 ;  $  TAB3 add 1 to count1 ;  $  TAB3 if extra0 is greater than 0, set extra0 to extra0 - 1 ;  $  TAB2 else do ;  $  TAB3 set extra0 to extra0 + 1 ;  $  TAB3 if extra0 is greater than extra0max, set extra0max to extra0 ;  $  TAB1 display the result of count1 + extra0max ;
TAB0 let a be an integer of arrays of size 1000 ;  $  TAB0 define function flip with takes in integers n, i, and j as arguments ;  $  TAB1 let b be an integer of arrays of size 1000 ;  $  TAB1 iterate for n times, set b[i] to a[i] n times ;  $  TAB1 let count be an integer and set its value to 0 ;  $  TAB1 for k = i iterate until k is less than or equal to j ;  $  TAB2 if b[k] is equal to 0 ;  $  TAB3 set b[k] to 1 ;  $  TAB2 or else ;  $  TAB3 set b[k] to 0 ;  $  TAB1 iterate for n times ;  $  TAB2 if b[k] is equal to 1, increment count ;  $  TAB1 return the value of count from the function ;  $  TAB1 let n be an integer ;  $  TAB1 read in n ;  $  TAB1 read in a[i] n times ;  $  TAB1 let max be an integer and set its value to -1 ;  $  TAB1 iterate for n times ;  $  TAB2 for j = i iterate while j is less than n ;  $  TAB3 let count be an integer and set its value to flip(n, i, j) ;  $  TAB3 if count is greater than max, set max to count ;  $  TAB1 print max ;
TAB1 create ints n, x, one_cnt = 0, len_max = 0, and len_cur = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if x is equal to 0 ;  $  TAB3 if ++len_cur is greater than len_max, set len_max is equal to len_cur ;  $  TAB2 else do ;  $  TAB3 if --len_cur is less than 0, set len_cur to 0 ;  $  TAB3 add 1 to one_cnt ;  $  TAB1 display (one_cnt + (len_max == 0 ? -1 : len_max)) ;
TAB1 declare new ints n, x and mx where mx = 0, and an int array a with size 101 ;  $  TAB1 change a[0] to 0 ;  $  TAB1 read n ;  $  TAB1 change i from 1 to n inclusive in a for loop ;  $  TAB2 read input to x ;  $  TAB2 assign a[i - 1] + x to a[i] ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 in a for loop, change j from i to n inclusive, assigning the new value = max of a[n] + j - i + 1 - 2 * (a[j] - a[i - 1]) and mx to mx on each iteration ;  $  TAB1 print mx ;
TAB1 declare integer n ;  $  TAB1 declare integer array num size 100 ;  $  TAB1 declare integer array a size 100 ;  $  TAB1 read n ;  $  TAB1 declare integer count = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read num[i] ;  $  TAB2 if num[i] is 1 ;  $  TAB3 let a[i] be -1 ;  $  TAB3 increment count ;  $  TAB2 else ;  $  TAB3 let a[i] be 1 ;  $  TAB1 declare integer max = -2 ;  $  TAB1 declare integer sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 increment sum by a[i] ;  $  TAB2 if sum is greater than max, let max be sum ;  $  TAB2 if sum is less than 0, let sum be 0 ;  $  TAB1 print max + count and newline ;
TAB1 let n, k be long integers ;  $  TAB1 read n, k ;  $  TAB1 let t be a long integer with t = n / k ;  $  TAB1 if t modulo 2 is true ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 declare long longs n and m ;  $  TAB1 read n and m ;  $  TAB1 if n / m % 2 != 0 ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 create long long n, k ;  $  TAB1 print n, k ;  $  TAB1 if n/k is even ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;
TAB1 n, k, x = long long ;  $  TAB1 read n then k ;  $  TAB1 set x to n / k ;  $  TAB1 if x is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n, k = long long ;  $  TAB1 read n, k ;  $  TAB1 if n / k is odd ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 declare long long int variable n ;  $  TAB1 create long long int k ;  $  TAB1 read n ;  $  TAB1 read input to k ;  $  TAB1 if (n / k) is odd ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create long longs n and k ;  $  TAB1 read n and k ;  $  TAB1 if (n / k) is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n, k = long long ;  $  TAB1 read n, k ;  $  TAB1 if the result of n / k ends in a 1 in binary ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n, k = long long ;  $  TAB1 read n, k ;  $  TAB1 print YES if the last bit of n / k ends in 1 else print NO ;
TAB1 n, x =integers ;  $  TAB1 Read n and x ;  $  TAB1 if (n / x) modulo 2 is 0 ;  $  TAB2 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 print YES and a new line ;
TAB1 create long longs n and k ;  $  TAB1 read input to n and k ;  $  TAB1 if n / k is odd ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 if (n / k) modulo 2 is 0 ;  $  TAB2 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 print YES and a new line ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 th = integer, set to n / k ;  $  TAB1 if th is odd ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 let st, cross, t_turn be long integers ;  $  TAB1 read st , cross ;  $  TAB1 the value of t_turn is equal to st / cross ;  $  TAB1 if not t_turn & 1 ;  $  TAB2 print NO and newline ;  $  TAB1 else do the following ;  $  TAB2 print YES and newline ;
TAB1 declare long long variables n and k ;  $  TAB1 read n and k ;  $  TAB1 declare long long variable count = n / k ;  $  TAB1 if count is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 declare unsigned long long int variables k and n ;  $  TAB1 read n and k ;  $  TAB1 if (n / k) & 1 is not 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create long long variables n and k ;  $  TAB1 read n and k ;  $  TAB1 print the result of ((n / k) & 1 ? "YES" : "NO") ;
TAB0 n, k, x = long long ;  $  TAB1 read n then k ;  $  TAB1 set x to n / k ;  $  TAB1 if x is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n,k,s=long long int ;  $  TAB1 while read n,k ;  $  TAB2 s=n/k ;  $  TAB2 if s is even ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" ;
TAB1 create long longs n, k and x ;  $  TAB1 read input to n and k ;  $  TAB1 assign n / k to x ;  $  TAB1 if x is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 create long longs n, k ;  $  TAB1 read n read k ;  $  TAB1 if ( n / k ) % 2 is 0 ;  $  TAB2 print "NO" print newline ;  $  TAB1 else ;  $  TAB2 print "YES" print newline ;
TAB0 n, k, x = integers ;  $  TAB1 Read n and k ;  $  TAB1 set x to n / k ;  $  TAB1 if x is even ;  $  TAB2 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 print YES and a new line ;
TAB1 declare long longs n and m ;  $  TAB1 read n and m ;  $  TAB1 if n / m is odd ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 declare READ with strings INPUT, OUTPUT with INPUT default "NO", OUTPUT default "NO" as arguments, returning void ;  $  TAB1 if INPUT is not "NO", resuse stream stdin to open c string of INPUT in read mode ;  $  TAB1 if OUTPUT is not "NO", reuse stream stdout to open c string of OUTPUT in write mode ;  $  TAB1 create long longs n, k ;  $  TAB1 read n read k ;  $  TAB1 print "YES" if ( n / k ) % 2 is true, else "NO", print "\n" ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 if (n / k) modulo 2 is 0 ;  $  TAB2 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 print YES and a new line ;
TAB1 create long long integers n, k, m ;  $  TAB1 read n read m ;  $  TAB1 set m to 2 * k ;  $  TAB1 if n % m is greater than or equal to k ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 if (n / k) modulo 2 is 0 ;  $  TAB2 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 print YES and a new line ;
TAB1 declare long longs n and k ;  $  TAB1 read n and k ;  $  TAB1 print "NO\n" if (((n / k) & 1LL) == 0 or "YES\n" otherwise ;
TAB1 define integers n, k ;  $  TAB1 read n, k ;  $  TAB1 define integer h ;  $  TAB1 set h to quotient of n, k ;  $  TAB1 if h is even ;  $  TAB2 print "NO" and a newline ;  $  TAB1 else ;  $  TAB2 print "YES" and newline ;
TAB0 in function solve ;  $  TAB1 n, k = long long int ;  $  TAB1 read n then k ;  $  TAB1 pre = long long int with pre = n / k ;  $  TAB1 if pre is not even ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB1 t = long long int with t = 1 ;  $  TAB1 loop t times call solve ;
TAB1 create long long n and k ;  $  TAB1 read n, k ;  $  TAB1 if n/k is even ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES and a newline ;
TAB0 create constant integer N = 1e5 + 10 and INF = 1e9 + 7 ;  $  TAB1 create long long integers n and k ;  $  TAB1 read n and k ;  $  TAB1 print "YES" if (n / k) % 2 is true or "NO" if not ;
TAB1 create unsigned long longs n, k and res ;  $  TAB1 read n and k ;  $  TAB1 assign n / k to res ;  $  TAB1 if res & 1 = 1 ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 declare long long variables n, k and x ;  $  TAB1 read n and k ;  $  TAB1 set x to n / k ;  $  TAB1 if x is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 print YES if n / k bitwise and 1 is true, if ok is false print NO and a new line ;
TAB1 declare long long int variables x, a and b ;  $  TAB1 read input to a and b ;  $  TAB1 change x to a / b ;  $  TAB1 if x is even ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB0 create long longs n and m ;  $  TAB1 read n and m ;  $  TAB1 if n / m % 2 is true ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 create long long n, k ;  $  TAB1 print n, k ;  $  TAB1 set turnsDone = n / k ;  $  TAB1 assign n mod k to remaining ;  $  TAB1 if turnsDone mod 2 = 1 ;  $  TAB2 print YES and a newline ;  $  TAB1 else ;  $  TAB2 print NO and a newline+ ;
TAB1 create long longs n, k ;  $  TAB1 read n read k ;  $  TAB1 if ( n / k ) % 2 is not 0 ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 let long long ints n and k ;  $  TAB1 read n and k ;  $  TAB1 if n / k modulo 2 is not equal to 0 ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 create long longs n, m, green, blue, yellow, foo, foobar ;  $  TAB1 read n read m read yellow read green read blue ;  $  TAB1 set foobar to ( blue * 3 ) + green ;  $  TAB1 set foo to ( yellow * 2 ) + green ;  $  TAB1 print maximum of ( 0LL and foobar - m ) + maximum of ( 0LL and foo - n ) print newline ;
TAB1 create long longs yc, bc, yb, gb, bb ;  $  TAB1 read yc read bc ;  $  TAB1 read yb read gb read bb ;  $  TAB1 create long long yelo, blu ;  $  TAB1 set yelo to yb * 2 + gb ;  $  TAB1 set blu to 3 * bb + gb ;  $  TAB1 set yelo to yelo - yc ;  $  TAB1 set blu to blu - bc ;  $  TAB1 if yelo is greater than or equal to 0 and blu is greater than or equal to 0 ;  $  TAB2 print yelo + blu print newline ;  $  TAB1 else if yelo is less than 0 and blu is greater than or equal to 0 ;  $  TAB2 print blu print newline ;  $  TAB1 else if yelo is greater than or equal to 0 and blu is less than 0 ;  $  TAB2 print yelo print newline ;  $  TAB1 else ;  $  TAB2 print 0 print newline ;
TAB1 create long long integers y, b, ye, gr, bl, a, c, ans with ans = 0 ;  $  TAB1 read y read b read ye read gr read bl ;  $  TAB1 set a to ( 2 * ye ) + gr ;  $  TAB1 set c to ( 3 * bl ) + gr ;  $  TAB1 if y - a is less than 0, increment ans by a - y ;  $  TAB1 if b - c is less than 0, increment ans by c - b ;  $  TAB1 print ans print newline ;
TAB1 set a, b = 0 as large integer ;  $  TAB1 read a and b ;  $  TAB1 set x, y, z = 0 as large integer ;  $  TAB1 read x y x ;  $  TAB1 set Y, B, t = 0 as large integer ;  $  TAB1 set Y = (2*x) + (1*y) ;  $  TAB1 set B = (1*Y) + (3*z) ;  $  TAB1 if Y > a ;  $  TAB2 Y = Y - a ;  $  TAB1 else ;  $  TAB2 Y = 0 ;  $  TAB1 if B > b ;  $  TAB2 B = B - b ;  $  TAB1 else ;  $  TAB2 B = 0 ;  $  TAB1 t = Y + B ;  $  TAB1 print t ;
TAB1 let a, b, x, y, z = long long ;  $  TAB1 read a,b,x,y,z ;  $  TAB1 let yellow = long long = 2*x+y ;  $  TAB1 let blue = long long = y+3*z ;  $  TAB1 res = long long = 0 ;  $  TAB1 if a is less than yellow, res = res + yellow - a ;  $  TAB1 if b is less than blue, res = res + blue - b ;  $  TAB1 print res ;
TAB1 declare long long integer variables n, t, m and k ;  $  TAB1 declare long long integer variables x, y and z ;  $  TAB1 declare long long integer variables a and b ;  $  TAB1 read a and b ;  $  TAB1 read x, y and z ;  $  TAB1 declare long long integer variables yn and bn ;  $  TAB1 yn = (x * 2 + y) ;  $  TAB1 declare long long integer variable dif = yn - a ;  $  TAB1 declare long long integer need = 0 ;  $  TAB1 if dif >= 0, add dif to need ;  $  TAB1 bn = (y + z * 3) ;  $  TAB1 assign value of (bn - b) to dif ;  $  TAB1 if dif >= 0, add dif to need ;  $  TAB1 print need ;
TAB0 let N be a constant integer set to 1e6 + 10 ;  $  TAB0 let mod be a constant integer set to 998244353 ;  $  TAB0 a, b, x, y, z, q, p, r = long longs ;  $  TAB1 read a, b, x, y and z ;  $  TAB1 increment q by 2 * x ;  $  TAB1 increment q by y ;  $  TAB1 increment p by y ;  $  TAB1 increment p by 3 * z ;  $  TAB1 print max(r, q - a) + max(r, p - b) ;
TAB0 let n, m, a, b, c be long integers ;  $  TAB0 let Yellow, Blue, ans be long integers ;  $  TAB1 read n,m,a,b,c ;  $  TAB1 Yellow is equal to a * 2 + b ;  $  TAB1 Blue is equal to b + c * 3 ;  $  TAB1 if (Yellow is greater than n) , ans = ans + Yellow - n ;  $  TAB1 if (Blue is greater than m) , ans = ans + Blue - m ;  $  TAB1 print ans and newline ;
TAB1 create long long integers a, b, x, y, z, c, d, sum ;  $  TAB1 read a read b ;  $  TAB1 read x read y read z ;  $  TAB1 set x to x * 2 + y ;  $  TAB1 set z to z * 3 + y ;  $  TAB1 if a is greater than x ;  $  TAB2 set c to 0 ;  $  TAB1 else ;  $  TAB2 set c to x - a ;  $  TAB1 if b is greater than z ;  $  TAB2 set d to 0 ;  $  TAB1 else ;  $  TAB2 set d to z - b ;  $  TAB1 print c + d print newline ;
TAB0 create long long a, b, x, y, z, na, nb, zer with zer = 0 ;  $  TAB1 read a read b read x read y read z ;  $  TAB1 set na to x * 2 + y ;  $  TAB1 set nb to z * 3 + y ;  $  TAB1 print maximum of ( maximum of ( na - a and zer ) + maximum of ( nb - b and zer ) and zer ) print '\n' ;
TAB1 declare long longs n and m ;  $  TAB1 read n and m ;  $  TAB1 let a, b and c be long longs ;  $  TAB1 read a, b and c ;  $  TAB1 create long long ans with value = max of 0 and b + (2 * a) - n ;  $  TAB1 increase ans by max of 0 and b + (3 * c) - m ;  $  TAB1 print ans and a new line ;
TAB1 create long longs a, b ;  $  TAB1 read a read b ;  $  TAB1 create long longs x, y, z ;  $  TAB1 read x read y read z ;  $  TAB1 create long long ans with ans = 0 ;  $  TAB1 if y is greater than a ;  $  TAB2 increment ans by y - a ;  $  TAB2 set a to 0 ;  $  TAB1 else ;  $  TAB2 decrement a by y ;  $  TAB1 if y is greater than b ;  $  TAB2 increment ans by y - b ;  $  TAB2 set b to 0 ;  $  TAB1 else ;  $  TAB2 decrement b by y ;  $  TAB1 if x * 2 is greater than a, increment ans by x * 2 - a ;  $  TAB1 if x * 3 is greater than b, increment ans by z * 3 - b ;  $  TAB1 print ans print newline ;
TAB1 create long longs a, b ;  $  TAB1 read a read b ;  $  TAB1 create long longs x, y, z ;  $  TAB1 read x read y read z ;  $  TAB1 create long longs reala, realb with reala = 2 * x + y, realb = y + 3 * z ;  $  TAB1 print maximum of ( reala - a and 0ll ) + maximum of ( realb - b and 0ll ) print newline ;
TAB1 create long longs a, b and ans, with ans = 0 ;  $  TAB1 read a and b ;  $  TAB1 let a1, a2 and a3 be long longs ;  $  TAB1 read a1, a2 and a3 ;  $  TAB1 decrease a by a1 * 2 ;  $  TAB1 decrease a by a2 ;  $  TAB1 decrease b by a2 ;  $  TAB1 decrease b by 3 * a3 ;  $  TAB1 if a is less than 0, increase ans by a ;  $  TAB1 if b is less than 0, increase ans by b ;  $  TAB1 print negative ans and a new line ;  $  TAB1 ; ;
TAB0 n, m, a, b and c are long longs ;  $  TAB0 declare long longs Yellow, Blue and ans ;  $  TAB1 read n, m, a, b and c ;  $  TAB1 Yellow = a * 2 + b ;  $  TAB1 Blue = b + c * 3 ;  $  TAB1 if Yellow >= n and Blue >= m ;  $  TAB2 increase ans by Yellow + Blue - n - m ;  $  TAB1 else if Yellow < n and Blue is greater than m ;  $  TAB2 increase ans by Blue - m ;  $  TAB1 else if Yellow > n and Blue is less than m ;  $  TAB2 increase ans by Yellow - n ;  $  TAB1 print ans and a new line ;
TAB1 create long longs i, c, a, b, x, y, z, with c = 0 ;  $  TAB1 read a read b read x read y read z ;  $  TAB1 decrement a by x * 2 ;  $  TAB1 decrement a by y ;  $  TAB1 decrement b by y ;  $  TAB1 decrement b by 3 * z ;  $  TAB1 if a is less than 0, increment c by absolute value of a ;  $  TAB1 if b is less than 0, increment c by absolute value of b ;  $  TAB1 print c print newline ;
TAB1 a, b, x, y and z are long longs ;  $  TAB1 read a, b, x, y and z ;  $  TAB1 create long long ans = 0 ;  $  TAB1 if y <= a ;  $  TAB2 decrease a by y ;  $  TAB1 else ;  $  TAB2 increase ans by y - a ;  $  TAB2 assign value of 0 to a ;  $  TAB1 if y <= b ;  $  TAB2 decrease b by y ;  $  TAB1 else ;  $  TAB2 increase ans by y - b ;  $  TAB2 set value of b to 0 ;  $  TAB1 if x * 2 <= a ;  $  TAB2 decrease a by x * 2 ;  $  TAB1 else ;  $  TAB2 increase ans by 2 * x - a ;  $  TAB2 a = 0 ;  $  TAB1 if z * 3 <= b ;  $  TAB2 decrease b by z * 3 ;  $  TAB1 else ;  $  TAB2 increase ans by z * 3 - b ;  $  TAB2 set value of b to 0 ;  $  TAB1 print ans and a new line ;
TAB1 create long long integers n, m ;  $  TAB1 read n read m ;  $  TAB1 create long long integers x, y, z ;  $  TAB1 read x read y read z ;  $  TAB1 create long long integer ans with ans = 0 ;  $  TAB1 if n is greater than or equal to 2 * x ;  $  TAB2 set n to n - 2 * x ;  $  TAB1 else ;  $  TAB2 increment ans by 2 * x - n ;  $  TAB2 set n to 0 ;  $  TAB1 if m is greater than or equal to 3 * z ;  $  TAB2 set m to m - 3 * z ;  $  TAB1 else ;  $  TAB2 increment ans by 3 * z - m ;  $  TAB2 set m to 0 ;  $  TAB1 if n is less than y, increment ans by y - n ;  $  TAB1 if m is less than y, increment ans by y - m ;  $  TAB1 print ans print newline ;
TAB1 create long longs a, b, x, y, z ;  $  TAB1 read a read b read x read y read z ;  $  TAB1 create long long ans with ans = 0 ;  $  TAB1 create long longs sy, sb ;  $  TAB1 set sy to 2 * x + y - a ;  $  TAB1 if sy is less than 0, set sy to 0 ;  $  TAB1 set sb to 3 * z + y - b ;  $  TAB1 if sb is less than 0, set sb to 0 ;  $  TAB1 increment ans by sy + sb ;  $  TAB1 print ans print '\n' ;
TAB1 let i, c, a, v, x, y, z be long long with c = 0 ;  $  TAB1 read a, b, x, y and z ;  $  TAB1 let a = a - x*2 ;  $  TAB1 let a = a - y ;  $  TAB1 let b = b - y ;  $  TAB1 let b = b - 3*z ;  $  TAB1 if a is less than 0 set c = c+ absolute value of a ;  $  TAB1 if b is less than 0 set c = c+ absolute value of b ;  $  TAB1 print c and new line ;
TAB1 a, b, ans = long longs ;  $  TAB1 read a and b ;  $  TAB1 x, y, z = long longs ;  $  TAB1 read x, y and z ;  $  TAB1 ye = long long integer set to (2 * x) + y ;  $  TAB1 bl = long long integer set to y + (3 * z) ;  $  TAB1 n = long long integer set to ye - a ;  $  TAB1 m = long long integer set to (bl - b ;  $  TAB1 if n is less than 0 set n to 0 ;  $  TAB1 if m is less than 0 set m to 0 ;  $  TAB1 set ans to n + m ;  $  TAB1 print ans ;
TAB1 declare long long variables a, b, c, d, e and ans, with ans = 0 ;  $  TAB1 read a, b, c, d and e ;  $  TAB1 if c * 2 + d - a is greater than 0, add (c * 2 + d) - a to ans ;  $  TAB1 if d + e * 3 - b is greater than 0, add (d + e * 3) - b to ans ;  $  TAB1 print ans and a new line ;
TAB1 A,B =integers ;  $  TAB1 x, y, z = integers ;  $  TAB1 Read A and B ;  $  TAB1 Read x, y, z ;  $  TAB1 yello, green, bule = integers and all set to 0 ;  $  TAB1 set yello to x * 2 + y ;  $  TAB1 set bule to z * 3 + y ;  $  TAB1 set sum1 to yello - A ;  $  TAB1 set sum2 to bule - B ;  $  TAB1 if sum1 is less than 0, then set sum1 to 0 ;  $  TAB1 if sum2 is less than 0, then set sum2 to 0 ;  $  TAB1 print sum1 + sum2 and a new line ;
TAB1 declar longs A, B, x, y, z, and e to be zero ;  $  TAB1 input A, B, x, y, and z ;  $  TAB1 if A is less than double x plus y, increment a by x * 2 + y - A ;  $  TAB1 if B is less than y plus z times 3, increment a by y + 3 * z - B ;  $  TAB1 print a and endline ;
TAB1 create long longs n, m, a, b, c, ans1, ans2 and sum, with ans1, ans2 and sum = 0 ;  $  TAB1 read n and m ;  $  TAB1 read a, b and c ;  $  TAB1 ans1 = a * 2 + b * 1 ;  $  TAB1 ans2 = b * 1 + c * 3 ;  $  TAB1 sum = ans1 - n if ans1 > n, or 0 if it is not ;  $  TAB1 increase sum by ans2 - m if ans2 > m ;  $  TAB1 print sum and a new line ;
TAB0 create constant integer N with N = 1 bitshift left 20 ;  $  TAB1 create long longs a, b ;  $  TAB1 read a read b ;  $  TAB1 create long longs ye, bl, g ;  $  TAB1 read ye read g read bl ;  $  TAB1 create long long y1 with y1 = 2 * ye ;  $  TAB1 create long long y2 with y2 = g ;  $  TAB1 create long long b1 with b1 = g ;  $  TAB1 create long long b2 with b2 = 3 * bl ;  $  TAB1 create long longs ans1, ans2 ;  $  TAB1 if a is greater than or equal to y1 + y2 ;  $  TAB2 set ans1 to 0 ;  $  TAB1 else ;  $  TAB2 set ans1 to absolute value of ( a - ( y1 + y2 ) ) ;  $  TAB1 if b is greater than b1 + b2 ;  $  TAB2 set ans2 to 0 ;  $  TAB1 else ;  $  TAB2 set ans2 to absolute value of ( b - ( b1 + b2) ) ;  $  TAB1 print ans1 + ans2 print newline ;
TAB1 create long longs a, b, x, y, z, q, w, with q = 0, w = 0 ;  $  TAB1 read a read b ;  $  TAB1 read x read y read z ;  $  TAB1 set q to 2 * x + y ;  $  TAB1 set w to y + 3 * z ;  $  TAB1 create long long ans with ans = 0 ;  $  TAB1 if q - a is greater than 0, set ans to q - a ;  $  TAB1 if w - b is greater than 0, increment ans by w - b ;  $  TAB1 print ans print '\n' ;
TAB0 let const int maxn = 1e5 + 10 ;  $  TAB0 create ints a, b, c, and n ;  $  TAB1 while cin >> a >> b >> c >> n is truthy ;  $  TAB2 if a is less than c or b is less than c ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 let int num = (a - c) + (b - c) + c ;  $  TAB3 if num is greater than or equal to n ;  $  TAB4 print -1 ;  $  TAB3 else ;  $  TAB4 print n - num ;
TAB1 a, b, c, n = integers ;  $  TAB1 read a, b, c, n ;  $  TAB1 d = integer with d = a - c ;  $  TAB1 e = integer with e = b - c ;  $  TAB1 f = integer with f = n - d - e - c ;  $  TAB1 if d >= 0 and e >= 0 and c >= 0 and f > 0 ;  $  TAB2 print f ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 declare long long ints a, b, c and n ;  $  TAB1 read a, b, c and n ;  $  TAB1 create integer temp = min of a and b ;  $  TAB1 if c is greater than temp ;  $  TAB2 print "-1\n" ;  $  TAB1 if (a + b) - c is less than n ;  $  TAB2 print n - ((a + b) - c) ;  $  TAB1 else ;  $  TAB2 print "-1\n" ;
TAB1 a, b, c, n = integers ;  $  TAB1 while read a, b, c, n ;  $  TAB2 res = integer with res = -1 ;  $  TAB2 if (a <= n) and (b <= n) and (c <= n) ;  $  TAB3 onlyA = integer with onlyA = a - c ;  $  TAB3 onlyB = integer with onlyB = b - c ;  $  TAB3 if (onlyA >= 0 and onlyB >= 0) and (onlyA + onlyB < n), res = n - onlyA - onlyB - c ;  $  TAB2 if res is 0, res = -1 ;  $  TAB2 print res ;
TAB1 let a, b, c, d be ints ;  $  TAB1 read a, b, c, d ;  $  TAB1 if a + b - c >= d or c > a or c > b ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print d - (a + b - c) ;
TAB0 create integers a, b, c, n, i ;  $  TAB1 read a read b read c read n ;  $  TAB1 if a + b - c + 1 is greater than n or c is greater than a or c is greater than b or c is greater than a + b or c is greater than n ;  $  TAB2 print -1 print newline ;  $  TAB1 else ;  $  TAB2 print n + c - a - b print newline ;
TAB0 let A, B, C, N be ints ;  $  TAB1 read A, B, C, N ;  $  TAB1 let con be a false bool ;  $  TAB1 if A > N or B > N or C > N then change con to true ;  $  TAB1 if C > A or C > B then set con to true ;  $  TAB1 let T = A + B - C = int ;  $  TAB1 if T >= N, change con to true ;  $  TAB1 if con is true print -1 else print N - T ;
TAB1 create integers a, b, c, n and sum ;  $  TAB1 read a, b, c and n and loop further ;  $  TAB2 set sum to a + b - c ;  $  TAB2 if sum >= n or a < c or b < c ;  $  TAB3 print "-1" ;  $  TAB3 skip the rest of the loop ;  $  TAB2 else ;  $  TAB3 print n - sum ;
TAB1 declare integers a, b, c and n ;  $  TAB1 read input to a, b, c and n ;  $  TAB1 declare integer x = n - (a - c + b) ;  $  TAB1 if x < 1 or a < c or b < c or a > n or b > n or c > n ;  $  TAB2 print "-1\n" ;  $  TAB1 else ;  $  TAB2 print x ;
TAB1 flag =0 ;  $  TAB1 create long long ans ;  $  TAB1 res = long long ;  $  TAB1 create int a, b, c and n ;  $  TAB1 read a, b, c and n ;  $  TAB1 if c>a or c>b ;  $  TAB2 set flag to 1 ;  $  TAB1 else ;  $  TAB2 assign a + b - c to res ;  $  TAB2 set ans to n - res ;  $  TAB1 if flag equal to 1 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 if ans <= 0 ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print ans and a newline ;
TAB1 create integer a, b, c, n ;  $  TAB1 get a, b, c, n ;  $  TAB1 if a+b-c less than n and c less than or equal to a and b then ;  $  TAB2 print n+c-a-b ;  $  TAB1 else do the following ;  $  TAB2 print "-1\n" ;
TAB1 create integers n, a, b, c ;  $  TAB1 read a, b, c and n ;  $  TAB1 if a<c or b<c ;  $  TAB2 print -1 ;  $  TAB1 set ans to n - (a + b - c) ;  $  TAB1 if ans >= 1 ;  $  TAB2 print ans ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 declare int variables A, B, C and N ;  $  TAB1 read input to A, B, C and N ;  $  TAB1 if ((A + B - C) < N) and (A >= C) and (B >= C) ;  $  TAB2 print N - (A + B - C) ;  $  TAB1 else ;  $  TAB2 print "-1" ;
TAB0 set INF to 0x3f3f3f3f ;  $  TAB1 create int i, j, k ;  $  TAB1 let n, m, t be int ;  $  TAB1 create integers a, b, c, d ;  $  TAB1 read a, b, c, d ;  $  TAB1 if c>b or c>a ;  $  TAB2 print -1 ;  $  TAB1 set a to a + b - c ;  $  TAB1 set d = d-a ;  $  TAB1 if d<1 or a<0 ;  $  TAB2 print -1 ;  $  TAB1 otherwise ;  $  TAB2 print d and a newline ;
TAB0 a, b, c, n = integers ;  $  TAB1 read a, b, c, n ;  $  TAB1 num = integer with num = a + b - c ;  $  TAB1 t = integer with t = n - 1 ;  $  TAB1 if t >= num and num >= 0 and a >= c and b >= c ;  $  TAB2 print t - num + 1 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 create integers a, b, c, n ;  $  TAB1 read a read b read c read n ;  $  TAB1 if a is greater than n or c is greater than b or c is greater than a or ( a + b - c is greater than or equal to n ) ;  $  TAB2 print -1 print newline ;  $  TAB1 if n - a - b + c is greater than or equal to 1 ;  $  TAB2 print n - a - b + c print newline ;  $  TAB1 else ;  $  TAB2 print -1 print newline ;
TAB0 create ints a, b, c and n ;  $  TAB0 function solve that returns integer ;  $  TAB1 declare int variable k = a + b - c ;  $  TAB1 if c is greater than min of a and b, return -1 ;  $  TAB1 if k is less than 0, return -1 ;  $  TAB1 if n - k is less than 1, return -1 ;  $  TAB1 return n - k ;  $  TAB1 read a, b, c and n ;  $  TAB1 print the result of solve() and "\n" ;
TAB1 a, b, c, d = int ;  $  TAB1 read a then b then c then d ;  $  TAB1 temp = int with temp = d - (a + b - c) ;  $  TAB1 if c is greater than a or c is greater than b or a + b - c is greater or equal to d ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print temp ;
TAB1 create integers A, B, C and N ;  $  TAB1 read A, B, C and N ;  $  TAB1 if (A + B - C<= N - 1) and (A < N and B < N and C <= A and C <=B ) ;  $  TAB2 print N - (A + B - C) ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB0 create constant integer MAX with MAX = 2e5 + 5 ;  $  TAB0 create constant integer INF with INF = 0x3f3f3f3f ;  $  TAB0 create map mp from character to integer ;  $  TAB0 create map iterator it from character to integer ;  $  TAB1 create integers i, j, k, n, m, a, b, c ;  $  TAB1 read a read b read c read n ;  $  TAB1 if a + b - c is greater than or equal to n or c is greater than a or c is greater than b ;  $  TAB2 print "-1" ;  $  TAB1 print n - ( a + b - c ) print newline ;
TAB1 create long longs a, b, c and d ;  $  TAB1 read a, b, c and d and loop further ;  $  TAB2 declare long long ans = d - a - b + c ;  $  TAB2 if ans > 0 and a >= c and b >= c ;  $  TAB3 print ans ;  $  TAB2 else ;  $  TAB3 print -1 ;
TAB1 create integers a, b, c, n, output ;  $  TAB1 read a read b read c read n ;  $  TAB1 set output to n - (a + b - c) ;  $  TAB1 if (a + b - c) is greater than or equal to n or c is greater than a or c is greater than b ;  $  TAB2 print -1 print newline ;  $  TAB1 else ;  $  TAB2 print output print newline ;
TAB1 a, b, c, n = integers ;  $  TAB1 read a, b, c, n ;  $  TAB1 if a < c or b < c ;  $  TAB2 print -1 ;  $  TAB1 all = integer with all = a + b - c ;  $  TAB1 if all <= n - 1 ;  $  TAB2 print n - all ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 a, b, c, n = int ;  $  TAB1 read a then b then c then n ;  $  TAB1 if (a + b - c) >= n or a < c or b < c ;  $  TAB2 print "-1" ;  $  TAB1 else ;  $  TAB2 print n - a - b + c ;
TAB0 create constant int N = 400000 + 10 ;  $  TAB1 let ints x, y, z, and n ;  $  TAB1 read x, y, z, and n and while x, y, z, and n are truthy ;  $  TAB2 set x to x - z ;  $  TAB2 set y to y - z ;  $  TAB2 let int ans = n - x - y - z ;  $  TAB2 if x is less than 0 or y is less than 0 or ans is less than or equal to 0 ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print ans ;
TAB0 declare integer variables a, b, c and n ;  $  TAB0 declare integers x, y and z ;  $  TAB1 read a, b, c and n and loop further ;  $  TAB2 assign a - c to x ;  $  TAB2 assign b - c to y ;  $  TAB2 change z to x + y + c ;  $  TAB2 if z >= n or a < c or b < c ;  $  TAB3 print "-1" ;  $  TAB2 else ;  $  TAB3 print n - z ;
TAB1 create integers a, b, c and n ;  $  TAB1 loop, reading a, b, c and n from the input ;  $  TAB2 create int ans = a + b - c ;  $  TAB2 change ans to n - ans ;  $  TAB2 if ans <= 0 or a < c or b < c ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print ans ;
TAB1 create integers a, b, c and n ;  $  TAB1 read input to a, b, c and n ;  $  TAB1 declare integer sum = a + b - c ;  $  TAB1 if sum >= n or a > n or b > n or c > n or n = 0 or c > a or c > b ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print n - sum ;
TAB1 create int a, b, c, n ;  $  TAB1 read a, b, c, n ;  $  TAB1 if a less than c or b <c ;  $  TAB2 print -1 and a newline ;  $  TAB1 set ans to n - (a + b - c) ;  $  TAB1 if ans less than 1 ;  $  TAB2 print -1 and a newline ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB1 create long long ints a, b, c, n, k ;  $  TAB1 read a, b, c, and n ;  $  TAB1 set k to a + b - c ;  $  TAB1 set k to n - k ;  $  TAB1 if k is greater than or equal to 1 and c is less than or equal to a and c is less than or equal to b ;  $  TAB2 print k ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 declare ints a, b, c and d ;  $  TAB1 read a, b, c and d ;  $  TAB1 if a + b - c >= d or c > a or c > b ;  $  TAB2 print "-1" ;  $  TAB1 else ;  $  TAB2 print d - (a + b - c) ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create vector in a(n) ;  $  TAB1 mx = 0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 mx = max of mx and a[i] ;  $  TAB1 ans = 1e9 ;  $  TAB1 for k=mx to 1e5 inclusive ;  $  TAB2 create int x and y ;  $  TAB2 set x and y to 0 ;  $  TAB2 for i=0 to n exclusive ;  $  TAB3 assign x + a[i] to x ;  $  TAB3 set y = t + k - a[i] ;  $  TAB2 if y greater than x ;  $  TAB3 print k and a newline ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 sum, x and mx are integers with sum and mx = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 add x to sum ;  $  TAB2 assign max of mx and x to mx ;  $  TAB1 multiply sum by 2 ;  $  TAB1 increment sum ;  $  TAB1 print max of sum / n rounded up and mx ;
TAB0 create integers n, ans, ma and sum, and integer array a with 105 elements ;  $  TAB0 define function gets ;  $  TAB1 create integer v with value 0 ;  $  TAB1 assign value 0 to boolean f ;  $  TAB1 ch = character ;  $  TAB1 read ch from the input and continue the loop if ch is not a digit ;  $  TAB2 if ch = '-', set f to 1 ;  $  TAB1 assign value of ch - 48 to v ;  $  TAB1 read ch from the input and continue the loop if ch is a digit, changing v to v * 10 + ch - 48 ;  $  TAB1 return -v if f is true, or v otherwise ;  $  TAB1 assign result of gets() to n ;  $  TAB1 for i = 1 to n inclusive, set a[i] to the result of gets(), ma to max of ma and a[i], and increase sum by a[i] ;  $  TAB1 ans = sum * 2 / n + 1 ;  $  TAB1 ans = max of ans and ma ;  $  TAB1 print ans ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create integer pointer a pointed to new array of integers with n elements ;  $  TAB1 declare int sum = 0 ;  $  TAB1 declare int max ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 read input to a[i] ;  $  TAB2 set sum to sum + a[i] ;  $  TAB2 if i is equal to 0 ;  $  TAB3 set max to a[i] ;  $  TAB2 else ;  $  TAB3 if a[i] is greater than max, change max to a[i] ;  $  TAB1 create integer f = (2 * sum / n) + 1 ;  $  TAB1 if f is greater than max ;  $  TAB2 print f ;  $  TAB1 else ;  $  TAB2 print max ;
TAB1 create int n ;  $  TAB1 set mx to 0 ;  $  TAB1 assign 0 to sum ;  $  TAB1 read n ;  $  TAB1 create int a ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 set mx to max of mx and a ;  $  TAB2 assign sum + a to sum ;  $  TAB1 set sum to sum*2 ;  $  TAB1 set sum = sum+n ;  $  TAB1 sum = sum / n ;  $  TAB1 print max of sum and mx ;
TAB1 declare int variables n, i and j and int array a with 100002 elements ;  $  TAB1 read n ;  $  TAB1 declare int sum = 0 ;  $  TAB1 declare integer variable mx = - 1 ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increase sum by a[i] ;  $  TAB2 assign max of mx and a[i] to mx ;  $  TAB1 looping infinitely ;  $  TAB2 if mx * n - sum is greater than sum ;  $  TAB3 print mx ;  $  TAB2 else ;  $  TAB3 increment mx ;
TAB0 create integer n ;  $  TAB1 read n ;  $  TAB1 create integers sum, temp, Max with sum = 0, Max = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read temp ;  $  TAB2 if temp is greater than Max, set Max to temp ;  $  TAB2 increment sum by temp ;  $  TAB1 print maximum of ( Max and sum * 2 / n + 1 ) print newline ;
TAB1 create int n ;  $  TAB1 read input to n ;  $  TAB1 create integers ans, mayor and a with ans and mayor = 0 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 set ans to ans + a ;  $  TAB2 set mayor to max of mayor and a ;  $  TAB1 change ans to max of (ans * 2) / n + 1 and mayor ;  $  TAB1 print ans ;
TAB1 declare long long variable n ;  $  TAB1 read n ;  $  TAB1 let a be long long array with size n ;  $  TAB1 declare long long variable maxi = 0 ;  $  TAB1 declare long long sum = 0 ;  $  TAB1 for i = 0 and _n = n while i < _n, incrementing i ;  $  TAB2 read input to a[i] ;  $  TAB2 assign max of maxi and a[i] to maxi ;  $  TAB2 set sum to sum + a[i] ;  $  TAB1 declare long long variable k = 0 ;  $  TAB1 increment k while n * k <= 2 * sum ;  $  TAB1 if k is less than maxi, set k to maxi ;  $  TAB1 print k ;
TAB1 let n, sum, sum1 and ans be integers with sum and sum1 = 0 ;  $  TAB1 read n ;  $  TAB1 let ar be an array of integers of size n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read ar[i] ;  $  TAB2 increase sum by ar[i] ;  $  TAB1 sort ar ;  $  TAB1 for i = ar[n - 1], incrementing i ;  $  TAB2 assign value of 0 to sum1 ;  $  TAB2 for j = 0 to n exclusive, increase sum1 by i - ar[j] ;  $  TAB2 if sum1 is greater than sum ;  $  TAB3 set value of ans to i ;  $  TAB3 stop the loop ;  $  TAB1 print ans ;
TAB1 declare int variable n ;  $  TAB1 read n ;  $  TAB1 declare int array a with size n ;  $  TAB1 create integer sum = 0 ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read input to a[i] ;  $  TAB2 add a[i] to sum ;  $  TAB1 create int k = (2 * sum) / n + 1 ;  $  TAB1 sort a ;  $  TAB1 if k >= a[n - 1] ;  $  TAB2 print k ;  $  TAB1 else ;  $  TAB2 print a[n - 1] ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 arr = integer vector of size n ;  $  TAB1 max = maximum integer value, sum = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 sum = sum + arr[i] ;  $  TAB2 if max < arr[i], then max = arr[i] ;  $  TAB1 if n * max > 2 * sum ;  $  TAB2 print max ;  $  TAB1 else ;  $  TAB2 if (2 * sum) modulo n is 0 ;  $  TAB3 print the result of (2 * n) / n + 1 ;  $  TAB2 else ;  $  TAB3 print the result of (2 * sum) / n rounded up to the next whole number ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 pointer location of d = integer array of size n ;  $  TAB1 k = integer = 0, s = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read d[i] ;  $  TAB2 s = s + d[i] ;  $  TAB2 k = the highest value betweek k and d[i] ;  $  TAB1 sum = integer = 0 ;  $  TAB1 do ;  $  TAB2 sum = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB2 increase k by 1 ;  $  TAB1 while sum <= s ;  $  TAB1 print the result of k - 1 ;
TAB1 create integers n, s, k with s = 0, k = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create integer a ;  $  TAB2 read a ;  $  TAB2 set k to maximum of k and a ;  $  TAB2 increment s by a ;  $  TAB1 for n * k is less than or equal to 2 * s, incrementing k ;  $  TAB2 end statement ;  $  TAB1 print k print '\n' ;
TAB1 n, sum, ans = int with sum = 0 and ans = 0 ;  $  TAB1 read n ;  $  TAB1 arr = int array of size n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read arr[i] ;  $  TAB2 increment sum by arr[i] ;  $  TAB1 sort arr ;  $  TAB1 for i = 0 to n - 1 increment ans by -arr[i] + arr[n - 1] ;  $  TAB1 loop infinitely ;  $  TAB2 if ans is greater than sum then break ;  $  TAB2 increment ans by n ;  $  TAB2 increment arr[n - 1] ;  $  TAB1 print arr[n - 1] ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer vector arr initialized with ( n + 5 ) ;  $  TAB1 create integer max_val with max_val = 0 ;  $  TAB1 create long long sum with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 set max_val to maximum of ( max_val and arr[i] ) ;  $  TAB2 increment sum by arr[i] ;  $  TAB1 create integer i with i = max_val ;  $  TAB1 for i is less than 10000, incrementing i ;  $  TAB2 create long long val with val = i * n - sum ;  $  TAB2 if val is greater than sum, break loop ;  $  TAB1 print i print newline ;
TAB1 define integers n, i, sum, max1, ans, sum1, i1, and j, setting sum and max1 to 0 ;  $  TAB1 read into n ;  $  TAB1 define integer array a to be of n + 2 elements ;  $  TAB1 for i from 0 to n (exclusive) by 1 ;  $  TAB2 read into a[i] ;  $  TAB2 increment sum by a[i] ;  $  TAB2 set max1 to max. of max1, a[i] ;  $  TAB1 for j from max1 to max1 * 2 + 2 by 1 ;  $  TAB2 zero sum1 ;  $  TAB2 for i1 from 0 to n (exclusive) by 1, increment sum1 by j - a[i1] ;  $  TAB2 if sum1 > sum ;  $  TAB3 assign j to ans ;  $  TAB3 break out ;  $  TAB1 print ans and newline ;
TAB1 n, i, j, k1, k, suma, sumb = int with k = 0 and suma = 0 and sumb = 0 ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is greater than k then set k to a[i] ;  $  TAB2 increment suma by a[i] ;  $  TAB1 for i = 0 to n increment sumb by k - a[i] ;  $  TAB1 for i = 0 ;  $  TAB2 if sumb is less or equal to suma ;  $  TAB3 set sumb to 0 ;  $  TAB3 increment k ;  $  TAB3 for j = 0 to n increment sumb by k - a[j] ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 print k ;
TAB0 declare an array of integers value with size 101 ;  $  TAB1 declare integers n, k and sum where sum = 0 and k = -1 ;  $  TAB1 read input to n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read value[i] ;  $  TAB2 add value[i] to sum ;  $  TAB2 if value[i] is greater than k, set k to value[i] ;  $  TAB1 while k * n - sum <= sum, increment k ;  $  TAB1 print k ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer array a with size n, create integer sum with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer k ;  $  TAB2 read k ;  $  TAB2 set a[i] to k ;  $  TAB2 set sum to sum + a[i] ;  $  TAB1 create integer lar with lar = a[0] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if lar is less than a[i], set lar to a[i] ;  $  TAB1 for j = lar, incrementing j ;  $  TAB2 if j * n is greater than ( 2 * sum ) ;  $  TAB3 print j print newline ;  $  TAB3 break loop ;
TAB1 create integer n, create integer array a with size 200 ;  $  TAB1 read n ;  $  TAB1 create integers sum1, k, with sum1 = 0, k = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment sum1 by a[i] ;  $  TAB2 set k to maximum of k and a[i] ;  $  TAB1 create integer flag with flag = 0 ;  $  TAB1 while not flag ;  $  TAB2 create integer sum2 with sum2 = 0 ;  $  TAB2 for i = 0 to n exclusive, increment sum2 by k - a[i] ;  $  TAB2 if sum2 is greater than sum1 ;  $  TAB3 set flag to 1 ;  $  TAB2 else ;  $  TAB3 increment k ;  $  TAB1 print k print newline ;
TAB0 declare long long const mod = 1e9 + 7 ;  $  TAB0 power is a long long function with long long arguments x, y and mod ;  $  TAB1 declare long long variable ans = 1 ;  $  TAB1 x = x modulo mod ;  $  TAB1 while y ;  $  TAB2 if y & 1 != 0, assign (x * ans) % mod to ans ;  $  TAB2 set x to (x * x) % mod ;  $  TAB2 y = y >> 1 ;  $  TAB1 return ans ;  $  TAB0 gcd is a long long function with long long arguments a and b ;  $  TAB1 if a = 0, return b ;  $  TAB1 return gcd(b % a, a) ;  $  TAB1 declare long long variables n, id1 and id2 ;  $  TAB1 read n, id1 and id2 ;  $  TAB1 create string second ;  $  TAB1 read input to second ;  $  TAB1 if second[id1 - 1] is equal to second[id2 - 1] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create integers n, a, b ;  $  TAB1 create string s ;  $  TAB1 create integer ans ;  $  TAB1 read n read a read b read s ;  $  TAB1 if s[a-1] is s[b-1] ;  $  TAB2 set ans to 0 ;  $  TAB1 else ;  $  TAB2 set ans to 1 ;  $  TAB1 print ans print '\n' ;
TAB0 create const int inf = 0x3f3f3f3f ;  $  TAB1 let ints n, a, and b ;  $  TAB1 read n, a, and b ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 if s[a - 1] is equal to s[b - 1] ;  $  TAB2 print 0 ;  $  TAB1 create int set st ;  $  TAB1 let char ch = ' ' ;  $  TAB1 create int pos = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if ch is equal to ' ' ;  $  TAB3 set ch to s[i] ;  $  TAB3 continue to next loop iteration ;  $  TAB2 if s[i] is equal to ch ;  $  TAB3 set pos to i ;  $  TAB2 else ;  $  TAB3 insert i - pos into set st ;  $  TAB3 set pos to i ;  $  TAB3 set char to s[i] ;  $  TAB1 print *st.end() ;
TAB0 declare an array of booleans vis with size 200005 ;  $  TAB0 declare int arrays cnt and freq with 200005 elements ;  $  TAB1 declare integers n, a and b ;  $  TAB1 read input to n, a and b ;  $  TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 if s[a - 1] = s[b - 1] ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print "1" ;
TAB0 declare integers n, a and b ;  $  TAB0 create string s ;  $  TAB1 read n, a, b and s ;  $  TAB1 decrement a ;  $  TAB1 decrement b ;  $  TAB1 if s[a] != s[b] ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 create integers n, a and b ;  $  TAB1 read n, a and b ;  $  TAB1 declare an array of chars arr with size n + 2 ;  $  TAB1 read n elements into arr ;  $  TAB1 if arr[a - 1] = arr[b - 1] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 create string s ;  $  TAB1 create int n, a and b ;  $  TAB1 read n, a, b and s ;  $  TAB1 if a equal to b or s[a - 1] = s[b - 1] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 and a newline ;
TAB1 n, a, b = integers ;  $  TAB1 s = string ;  $  TAB1 read n, a, b ;  $  TAB1 decrement a, decrement b ;  $  TAB1 read s ;  $  TAB1 if s[a] is s[b] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 declare ints n, ans, a and b; create arrays of ints be and af with 100001 elements ;  $  TAB0 declare string s with value ;  $  TAB1 read variables n, a, b and s from the input ;  $  TAB1 if s[a - 1] is equal to s[b - 1] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare integers n, a and b ;  $  TAB1 read input to n, a and b ;  $  TAB1 declare character array aN with size 100000 ;  $  TAB1 read aN ;  $  TAB1 if aN[a - 1] != aN[b - 1] ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB0 create integer array num with size 1000000 with num = {0} ;  $  TAB0 declare fx with character array a as argument, returning void ;  $  TAB1 create integers n, a, b ;  $  TAB1 create character array z with size 1000000 ;  $  TAB1 read n read a read b ;  $  TAB1 read z ;  $  TAB1 if z[a-1] is z[b-1] ;  $  TAB2 print "0" print newline ;  $  TAB1 else ;  $  TAB2 print "1" print newline ;
TAB1 create integers n, a and b ;  $  TAB1 create string s ;  $  TAB1 declare int variable ans ;  $  TAB1 read n, a, b and s ;  $  TAB1 if s[a - 1] = s[b - 1] ;  $  TAB2 set ans to 0 ;  $  TAB1 else ;  $  TAB2 set ans to 1 ;  $  TAB1 print ans and '\n' ;
TAB0 declare const int maxn = 1e6 + 6 ;  $  TAB0 create ints n, a and b ;  $  TAB0 declare an array of integers arr with size maxn ;  $  TAB0 declare int variable len = 0 ;  $  TAB0 declare string variable str ;  $  TAB1 read input to n, a and b ;  $  TAB1 read input to str ;  $  TAB1 loop i from 1 to n inclusive, assign str[i - 1] to arr[i] ;  $  TAB1 if arr[a] is equal to arr[b] ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print "1" ;
TAB0 define vector VI, VI2, VI3, VI4 ;  $  TAB0 define n, m, f, t, a, b as integers ;  $  TAB0 define s as string ;  $  TAB1 read n, a, b, s ;  $  TAB1 print abs(s[--a] - s[--b]) ;
TAB0 create integers n, a, b ;  $  TAB0 create string s ;  $  TAB1 read n read a read b read s ;  $  TAB1 if s[a-1] is s[b-1] ;  $  TAB2 print 0 print "\n" ;  $  TAB1 else ;  $  TAB2 print 1 print "\n" ;
TAB1 s = string ;  $  TAB1 n, m, k = int ;  $  TAB1 read n then m then k ;  $  TAB1 read s ;  $  TAB1 prepend '#' to s ;  $  TAB1 print 1 if s[m] is not s[k] else print 0 ;
TAB0 define integral constant maxn to be 1e6 + 6 ;  $  TAB0 define integers n, a, b ;  $  TAB0 define maxn-element int array arr ;  $  TAB0 define int len, set to zero ;  $  TAB0 define string str ;  $  TAB1 read n, a, and then b ;  $  TAB1 read str ;  $  TAB1 for int i from i to n by 1, assign str[i - 1] to arr[i] ;  $  TAB1 if arr[a] is arr[b] ;  $  TAB2 print "0" and newline ;  $  TAB1 otherwise ;  $  TAB2 print "1" and a newline ;
TAB0 create string s ;  $  TAB1 create integers n, a, b ;  $  TAB1 read n read a read b read s ;  $  TAB1 if a is b or s[a-1] is s[b-1] ;  $  TAB2 print "0" print newline ;  $  TAB1 else ;  $  TAB2 pirnt "1" print newline ;
TAB1 create integers a, b, n ;  $  TAB1 create string s ;  $  TAB1 read n read a read b read s ;  $  TAB1 decrement a ;  $  TAB1 decrement b ;  $  TAB1 print ((s[a] - '0') ^ (s[b] - '0')) print newline ;
TAB0 create constant long long int mod = 998244353 ;  $  TAB0 create const long long int inf = 2e18 ;  $  TAB0 let const int maxn = 200005 ;  $  TAB0 let const int maxa = 300005 ;  $  TAB0 declare gcd taking in long long ints a and b and returning long long ;  $  TAB1 return gcd(b, a % b) if b is truthy or a if not ;  $  TAB0 declare powmod taking in long long ints a and b and returning long long ;  $  TAB1 let long long in res = 1 ;  $  TAB1 set a to a % mod ;  $  TAB1 if b is less than 0, return -1 ;  $  TAB1 loop until b is falsy ;  $  TAB2 if b & 1 is truthy, set res to res * a % mod ;  $  TAB2 set a to a * a % mod ;  $  TAB1 return res ;  $  TAB0 let int INF = 10000000 ;  $  TAB1 let int T ;  $  TAB1 create ints n, m, l, r ;  $  TAB1 create int ans = 0 ;  $  TAB1 create string str ;  $  TAB1 read n, l, and r ;  $  TAB1 create str ;  $  TAB1 let int array a of size maxn ;  $  TAB1 for i = 0 to n exclusive, set a[i + 1] to str[i] - '0' ;  $  TAB1 if a[l] is equal to a[r], return the result of 0 * puts("0") ;  $  TAB1 print "1" ;
TAB1 let n, a, b be integers ;  $  TAB1 let str be a string ;  $  TAB1 read n, a and b ;  $  TAB1 read str ;  $  TAB1 print the absolute value of str[a-]-'0' - str[b-1]+'0' ;
TAB1 locale loc ;  $  TAB1 declare int variables n, s and e ;  $  TAB1 read input to n, s and e ;  $  TAB1 declare string variable str ;  $  TAB1 read str ;  $  TAB1 if str[s - 1] = str[e - 1] ;  $  TAB2 print 0 and "\n" ;  $  TAB1 else ;  $  TAB2 print 1 and "\n" ;
TAB1 declare ints n, a and b ;  $  TAB1 read n, a and b ;  $  TAB1 declare integer variables i and val ;  $  TAB1 declare vector of integers called v with size n + 1 ;  $  TAB1 declare string variable s ;  $  TAB1 read input to s ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 if s[i] is equal to '1' ;  $  TAB3 set v[i + 1] to 1 ;  $  TAB2 else ;  $  TAB3 assign 0 to v[i + 1] ;  $  TAB1 declare int variable aa = min of a and b ;  $  TAB1 declare int variable bb = max of a and b ;  $  TAB1 declare int j ;  $  TAB1 create int count = 0 ;  $  TAB1 loop i from aa while i <= bb ;  $  TAB2 if v[i] = 0 ;  $  TAB3 declare integer variable index = i ;  $  TAB3 for j = i to bb inclusive ;  $  TAB4 if v[j] = 0, set index to j ;  $  TAB3 if index = bb, break the loop ;  $  TAB3 if index != bb ;  $  TAB4 change i to index + 1 ;  $  TAB4 increment count by one ;  $  TAB2 else ;  $  TAB3 create integer index = i ;  $  TAB3 for j from i to bb inclusive ;  $  TAB4 if v[j] is equal to 1, assign j to index ;  $  TAB3 if index is equal to bb, break ;  $  TAB3 if index != bb ;  $  TAB4 set i to index + 1 ;  $  TAB4 increment count by one ;  $  TAB1 print count ;
TAB1 declare ints n, a and b ;  $  TAB1 read input to n, a and b ;  $  TAB1 declare string s ;  $  TAB1 read input to s ;  $  TAB1 if s[a - 1] is equal to s[b - 1] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 let n, a, b be integers ;  $  TAB1 let s be a string ;  $  TAB1 read n, a, b ;  $  TAB1 read s ;  $  TAB1 if s[a - 1] is equal to s[b - 1] ;  $  TAB2 print 0 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 1 and newline ;
TAB1 let a be a string ;  $  TAB1 let n be a integer ;  $  TAB1 read a ;  $  TAB1 read n ;  $  TAB1 the 26th element of integer array kiek is equal to 0 ;  $  TAB1 if length of a is less than n ;  $  TAB2 print impossible and newline ;  $  TAB1 for i = 0 to length of a exclusive , increment kiek[a[i] - a] by 1 ;  $  TAB1 let k be a integer with k = 0 ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if kiek[i] >= 1 , increment k by 1 ;  $  TAB1 if k is less than n ;  $  TAB2 print n - k and newline ;  $  TAB1 else do the following ;  $  TAB2 print 0 and newline ;  $  TAB1 semicolumn ;
TAB1 declare new string s ;  $  TAB1 read input to s ;  $  TAB1 k is a new integer ;  $  TAB1 read input to k ;  $  TAB1 create new integer called cnt with value 0 ;  $  TAB1 if k is greater than length of s ;  $  TAB2 print "impossible" ;  $  TAB1 else ;  $  TAB2 create new integer exrt ;  $  TAB2 create new array of integers freq with size 30 filled with 0 ;  $  TAB2 for i from 0 to length of s exclusive incrementing i ;  $  TAB3 assign the new value = (s[i]) - 96 to exrt ;  $  TAB3 increment freq[exrt] by one ;  $  TAB2 in a for loop, change i from 0 to 30 exclusive ;  $  TAB3 increment cnt if freq[i] != 0 ;  $  TAB2 if k <= cnt ;  $  TAB3 print "0" to the standard output ;  $  TAB2 else ;  $  TAB3 print k - cnt ;
TAB0 create constant long long integer INF = (1LL << 60) - 1 ;  $  TAB0 new const long long integer MAX = 998244353 ;  $  TAB0 fast_exp is a long long int function with long long int arguments base, exp and m ;  $  TAB1 declare long long integer variable res = 1 ;  $  TAB1 while exp > 0 ;  $  TAB2 if exp is odd, assign (res * base) % m to res ;  $  TAB2 change the value of base to base squared % m ;  $  TAB2 divide exp by 2 ;  $  TAB1 return res modulo m ;  $  TAB1 s is a new string ;  $  TAB1 declare integers k and cnt with cnt = 0 ;  $  TAB1 read variables s and k from the input ;  $  TAB1 freq is a new array of integers with 26 elements filled with 0 ;  $  TAB1 declare integer n with value length of s ;  $  TAB1 start for loop from i = 0 to n exclusive, incrementing freq[s[i] - 'a'] ;  $  TAB1 in a for loop, change i from 0 to 26 exclusive incrementing i ;  $  TAB2 if freq[i] is not 0, increment cnt by one ;  $  TAB1 if cnt >= k ;  $  TAB2 print 0 ;  $  TAB1 if n is less than k ;  $  TAB2 print "impossible" ;  $  TAB1 print k - cnt ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is greater than integer casted size of s ;  $  TAB2 print "impossible\n" ;  $  TAB1 else ;  $  TAB2 print maximum of ( o and n - size of integer casted character set initialized with ( beginning of s to end of s )), '\n' ;
TAB0 create string a ;  $  TAB0 create int s, num, p[1001] ;  $  TAB1 read a and s ;  $  TAB1 if size of a < s ;  $  TAB2 print impossible ;  $  TAB1 for i=0 to size of s exclusive ;  $  TAB2 if p[a[i]]=0, increment ans ;  $  TAB2 set p[a[i]] = 1 ;  $  TAB1 print max of 0 and s-m ;
TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 k = long long integer ;  $  TAB1 read k ;  $  TAB1 freq = long long integer array of size 27, freq[0] = 0 ;  $  TAB1 if k > size of str ;  $  TAB2 print impossible ;  $  TAB1 else ;  $  TAB2 for i = 0 to size of str exclusive, then increase by 1 freq[str[i] - a + 1] ;  $  TAB2 count = long long integer = 0 ;  $  TAB2 for i = 1 to 26 inclusive ;  $  TAB3 if freq[i] is not 0, then increase count by 1 ;  $  TAB2 if count >= k ;  $  TAB3 print 0 ;  $  TAB2 else ;  $  TAB3 print k - count ;  $  TAB1 print endline ;
TAB0 declare constant integer maxn = 3e5 + 5 ;  $  TAB0 declare integer array a size 50 = {} ;  $  TAB1 declare string s ;  $  TAB1 declare integer k ;  $  TAB1 read s and k ;  $  TAB1 for i = 0 to length of s exclusive, increment a[s[i]-'a'] ;  $  TAB1 declare integers sum = 0, cnt = 0 ;  $  TAB1 for i = 0 to 30 exclusive ;  $  TAB2 if a[i] is greater than 0, increment cnt ;  $  TAB2 increment sum by a[i] ;  $  TAB1 if sum is less than k, return print "impossible", 0 ;  $  TAB1 if cnt is greater than or equal to k, return print "0", 0 ;  $  TAB1 print k - cnt and newline ;
TAB0 declare constant integer inf = 0x3f3f3f3f ;  $  TAB0 declare constant integer mod = integer casted 1e9 + 7 ;  $  TAB0 declare constant integer maxn = integer casted 1e5 + 5 ;  $  TAB0 declare integer array vis size 30 ;  $  TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare integer len = size of s ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is greater than len, return 0 * print "impossible" ;  $  TAB1 for i = 0 to len exclusive, increment vis[s[i] - 'a'] ;  $  TAB1 declare integer cnt = 0 ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if vis[i], increment cnt ;  $  TAB1 if cnt is greater than or equal to n ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print n - cnt and newline ;
TAB1 s=string ;  $  TAB1 k=int, cnt=array of 26 int filled with 0 ;  $  TAB1 read s,k ;  $  TAB1 if length of s < k ;  $  TAB2 print "impossibile" ;  $  TAB3 print newline ;  $  TAB1 else ;  $  TAB2 for i=0 to length of s exclusive increment cnt[s[i]-97] ;  $  TAB2 res=0 ;  $  TAB2 for i=0 to 26 exclusive ;  $  TAB3 if cnt[i] increment res ;  $  TAB2 print max(0, k-res) ;
TAB1 declare integer k ;  $  TAB1 declare string s ;  $  TAB1 read s and k ;  $  TAB1 if size of s is less than k, return print "impossible\n", 0 ;  $  TAB1 sort from beginning of s to end of s ;  $  TAB1 resize s to size ( remove all duplicates but one from ( beginning of s to end of s ) - beginning of s ) ;  $  TAB1 print maximum of ( k - integer casted size of s and 0 ) and newline ;
TAB0 declare integers n, num, ans ;  $  TAB0 declare string str ;  $  TAB1 read str ;  $  TAB1 read n ;  $  TAB1 if size of str is less than n ;  $  TAB2 print "impossible\n" ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if first index of 'a' + i in str is not -1, increment num ;  $  TAB1 print maximum of ( n - num and 0 ) and "\n" ;
TAB0 create constant integer N with value 2e6 + 5 ;  $  TAB0 long long function power with long long arguments x and p and unsigned long long argument y ;  $  TAB1 create new long long variable res with value 1 ;  $  TAB1 assign x modulo p to x ;  $  TAB1 while y > 0 ;  $  TAB2 if y & 1 is not 0, change res to (res * x) % p ;  $  TAB2 assign the new value = y to y ;  $  TAB2 change x to (x * x) % p ;  $  TAB1 return res ;  $  TAB0 declare new long long variables i and j ;  $  TAB1 declare string variable with name s ;  $  TAB1 create new long long k ;  $  TAB1 read s and k from the input ;  $  TAB1 if k is greater than length of s ;  $  TAB2 print "impossible" and '\n' to the standard output ;  $  TAB1 else ;  $  TAB2 temp is a set of unique characters ;  $  TAB2 for i = 0 to length of s exclusive ;  $  TAB3 insert s[i] into temp ;  $  TAB3 if length of temp = k ;  $  TAB4 print 0 and '\n' ;  $  TAB2 print k - length of temp and '\n' ;
TAB1 declare string s ;  $  TAB1 declare integer k ;  $  TAB1 read s and k ;  $  TAB1 if k is greater than size of s ;  $  TAB2 print "impossible\n" ;  $  TAB1 sort from beginning of s to end of s ;  $  TAB1 remove from ( remove all but first of ( beginning of s to end of s ) ) to end of s from s ;  $  TAB1 print maximum of ( k - integer casted size of s and 0 ) and newline ;
TAB0 let N, K, ans , val, x, y be integers with ans = 2e9 , A = array of integers of length 26 ;  $  TAB0 let T, S be strings ;  $  TAB1 read S, N ;  $  TAB1 if length of S is less than N ;  $  TAB2 print impossible and newline ;  $  TAB1 for integer i = 0 to length of S exclusive ;  $  TAB2 increment A[S[i] - a] by 1 ;  $  TAB2 if A[S[i] - a is equal to 1 , increment val by 1 ;  $  TAB1 print maximum of 0, N - val and newline ;
TAB0 create new int k and an array of ints haSh with 30 elements ;  $  TAB0 declare string variable s ;  $  TAB1 read standard input to s and k ;  $  TAB1 if k is greater than length of s ;  $  TAB2 print "impossible" ;  $  TAB1 start for loop from i = 0 to length of s exclusive ;  $  TAB2 if haSh[(s[i] - 'a')] is false ;  $  TAB3 change haSh[s[i] - 'a'] to 1 ;  $  TAB3 decrement k by one ;  $  TAB1 if k <= 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print k ;
TAB1 declare string variable with name s ;  $  TAB1 k is a new integer ;  $  TAB1 read standard input to s and k ;  $  TAB1 ms is a set of unique characters ;  $  TAB1 insert all elements of s into ms ;  $  TAB1 if length of s is less than k ;  $  TAB2 print "impossible" ;  $  TAB1 else ;  $  TAB2 if length of ms is less than k ;  $  TAB3 print k - length of ms ;  $  TAB2 else ;  $  TAB3 print 0 to the standard output ;
TAB0 create new constant integer INF = 0x3f3f3f3f ;  $  TAB0 declare integer constant mod with value 998244353 ;  $  TAB0 create new string s ;  $  TAB0 declare integers k and cnt and an integer array vis with 26 elements ;  $  TAB1 read s and k from the input ;  $  TAB1 if length of s is less than k ;  $  TAB2 return puts("impossible"), 0 ;  $  TAB1 else ;  $  TAB2 in a for loop, change i from 0 to length of s exclusive ;  $  TAB3 if vis[s[i] - 'a'] is equal to 0 ;  $  TAB4 set the value of vis[s[i] - 'a'] to 1 ;  $  TAB4 increment cnt ;  $  TAB2 if cnt >= k ;  $  TAB3 print 0 ;  $  TAB2 else ;  $  TAB3 print k - cnt ;
TAB1 create new strings input and insertion ;  $  TAB1 create new integers unique and inputLength with inputLength = 0 ;  $  TAB1 read input and unique from the input ;  $  TAB1 assign the new value = length of input to inputLength ;  $  TAB1 if inputLength is less than unique ;  $  TAB2 print "impossible" ;  $  TAB1 else ;  $  TAB2 create new set of unique strings called inputs ;  $  TAB2 start for loop from i = 0 to inputLength exclusive ;  $  TAB3 change the value of insertion to input[i] ;  $  TAB3 insert insertion to the inputs ;  $  TAB2 if unique is greater than length of inputs ;  $  TAB3 print unique - length of inputs ;  $  TAB2 else ;  $  TAB3 print 0 ;
TAB0 maxn = constant integer = 3e5 + 5 ;  $  TAB0 a = integer array of size 50 ;  $  TAB1 s = string ;  $  TAB1 k = integer ;  $  TAB1 read s, k ;  $  TAB1 for i = 0 to length of s, then increase a[s[i] - a] by 1 ;  $  TAB1 sum = integer = 0, cnt = integer = 0 ;  $  TAB1 for i = 0 to 30 exclusive ;  $  TAB2 if a[i] > 0, then increase cnt by 1 ;  $  TAB2 sum = sum + a[i] ;  $  TAB1 if sum < k, then print impossible then end execution of code ;  $  TAB1 if cnt >= k print 0 then end execution of code ;  $  TAB1 print k - cnt ;
TAB1 let n, pre, cur, nex, sum be integers, let sum = 0 ;  $  TAB1 read n ;  $  TAB1 if n equals 1 or 2, return and print 0 ;  $  TAB1 read pre, cur ;  $  TAB1 subract 2 from n ;  $  TAB1 while n > 0 ;  $  TAB2 read nex ;  $  TAB2 if cur > pre && cur > nex or cur < pre && cur < nex, add one to sum ;  $  TAB2 let pre = cur ;  $  TAB2 let cur = nex ;  $  TAB1 print sum ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 create vector of integers a with size n ;  $  TAB1 read n elements from the user input and out them into a ;  $  TAB1 ans is a new integer with value 0 ;  $  TAB1 start a loop from i = 1 to n - 1 exclusive ;  $  TAB2 if (a[i] - a[i - 1]) * (a[i] - a[i + 1]) is greater than 0, increment ans ;  $  TAB1 print ans ;
TAB1 declare integers n, c = 0 ;  $  TAB1 declare integer vector v ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare integer a ;  $  TAB2 read a ;  $  TAB2 add a to end of v ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if v[i] is greater than v[i+1] and v[i] is greater than v[i-1] ;  $  TAB3 increment c ;  $  TAB2 else if v[i] is less than v[1+i] and v[i] is less than v[i-1] ;  $  TAB3 increment c ;  $  TAB1 print c and newline ;
TAB0 create int a[1005] ;  $  TAB1 create int n, set ans to 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive, read a[i] ;  $  TAB1 for i=1 to n-1 exclusive ;  $  TAB2 if a[i] > a[i - 1] and a[i] > a[i + 1], increment ans ;  $  TAB2 if a[i] < a[i - 1] and a[i] < a[i + 1], increment ans ;  $  TAB1 print ans ;
TAB0 create int n, a[1001] ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive, read a[i] ;  $  TAB1 ans=0 ;  $  TAB1 for i=2 to n exclusive ;  $  TAB2 if a[i] > a[i + 1] and a[i] > a[i - 1] ;  $  TAB3 increment ans ;  $  TAB3 continue ;  $  TAB2 if a[i] < a[i + 1] and a[i] < a[i - 1], increment ans ;  $  TAB1 print ans ;
TAB0 maxsum, minsum, a, n = integers with a = array of size 1005 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 foe i = 2 to n exclusive ;  $  TAB2 if (a[i] > a[i - 1] and a[i] > a[i + 1]), increment maxsum ;  $  TAB2 if (a[i] < a[i - 1] and a[i] < a[i + 1]), increment minsum ;  $  TAB1 print maxsum + minsum ;
TAB1 declare long long integer n ;  $  TAB1 read n ;  $  TAB1 declare long long integer array a size n + 1 = {0} ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 declare long long integers c = 0, d = 0 ;  $  TAB1 for i = 2 to n exclusive ;  $  TAB2 if a[i] is greater than a[i-1] and a[i] is greater than a[i+1] or a[i] is less than a[i-1] and a[i] is less than a[i+1], increment c ;  $  TAB1 print c and newline ;
TAB0 g = 9.8 ;  $  TAB0 set mod = 1000000007 ;  $  TAB0 create int n, i, j, k, ans ;  $  TAB0 set x = 1e5 ;  $  TAB0 create long long a[x] ;  $  TAB1 create int i, j, k, m, n, t ;  $  TAB1 read t ;  $  TAB1 for i=0 to t exclusive, read a[i] ;  $  TAB1 num=0 ;  $  TAB1 for i=1 to t-1 exclusive ;  $  TAB2 if a[i] > a[i - 1] and a[i] > a[i + 1], increment num ;  $  TAB2 if a[i] < a[i - 1] and a[i] < a[i + 1], add 1 to num ;  $  TAB1 print num ;
TAB0 make constant integer maxn = 1e5 + 5 ;  $  TAB0 make const double esp = 1e-8 ;  $  TAB0 declare inline read returning integer ;  $  TAB1 make int X = 0 and w = 0 ;  $  TAB1 let char ch = 0 ;  $  TAB1 while ch is not a digit ;  $  TAB2 set w to w | ch == '-' ;  $  TAB2 read ch ;  $  TAB1 while ch is a digit, set X to X << 3) + (X << 1) + (ch ^ 48) and ch to getchar() ;  $  TAB1 return -X if w is truthy or X if not ;  $  TAB0 make long long int array a of size maxn ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 create integer num = 0 ;  $  TAB1 for i = 1 to n - 1 ;  $  TAB2 if a[i] is greater than a[i + 1] and a[i] is greater than a[i - 1] or a[i] is less than a[i - 1] or a[i] is less than a[i - 1] and a[i] is less than a[i + 1], increment num ;  $  TAB1 output num ;
TAB0 create ints n, l, mid, r, and now ;  $  TAB1 read n ;  $  TAB1 make integer ans = 0 ;  $  TAB1 read l ;  $  TAB1 if n is greater than or equal to 1 ;  $  TAB2 end statement ;  $  TAB1 if n is greater than or equal to 2, read mid ;  $  TAB1 if n is greater than or equal to 3 ;  $  TAB2 set n to n - 2 ;  $  TAB2 while n-- is truthy ;  $  TAB3 read r ;  $  TAB3 if mid is less than 1 and mid is less than r ;  $  TAB4 set ans to ans + 1 ;  $  TAB3 else if mid is greater than 1 and mid is greater than r ;  $  TAB4 set ans to ans + 1 ;  $  TAB3 set l to mid ;  $  TAB3 set mid to r ;  $  TAB1 output ans ;
TAB1 create int a[1002], n, i, set ans to 0 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive, read a[i] ;  $  TAB1 for i=2 to n exclusive ;  $  TAB2 if a[i] > a[i + 1] and a[i] > a[i - 1] ;  $  TAB3 increment ans ;  $  TAB2 else if a[i] < a[i + 1] and a[i] < a[i - 1] ;  $  TAB3 increment ans ;  $  TAB1 print ans ;
TAB0 a = long long array length 1001 ;  $  TAB1 let n, ans = 0 be long long ;  $  TAB1 read n ;  $  TAB1 read the first n elements of a ;  $  TAB1 for long long i = 1 to n-1 exclusive ;  $  TAB2 if a[i] > a[i-1] and a[i] > a[i+1] then increment ans ;  $  TAB2 if a[i] < a[i-1] and a[i] < a[i+1] then increment ans ;  $  TAB1 print ans ;
TAB1 let n and ans be integers, set ans to 0 ;  $  TAB1 read in n ;  $  TAB1 let a be an array of integers of size n ;  $  TAB1 read in n values into a ;  $  TAB1 for i = 1 to n -1 ;  $  TAB2 if a[i] > a[i - 1] and a[i] > a[i + 1] or a[i] < a[i - 1] and a[i] < a[i + 1], increment a ;  $  TAB1 print ans and a newline ;  $  TAB1 read in n ;
TAB1 create int n, set c to 0 ;  $  TAB1 read n ;  $  TAB1 create int a[n + 2] ;  $  TAB1 for i=0 to n exclusive, read a[i] ;  $  TAB1 for i=1 to n-1 exclusive ;  $  TAB2 if a[i] < a[i - 1] and a[i] < a[i + 1] ;  $  TAB3 increment c ;  $  TAB2 else if a[i] > a[i - 1] and a[i] > a[i + 1] ;  $  TAB3 increment c ;  $  TAB1 print c ;
TAB0 let gcd be a function which accepts long integers a and b and returns a long integer ;  $  TAB1 return a if (not b) else return gcd of b and a modulo b ;  $  TAB0 let lcm be a function which accepts long integers a and b and returns a long integer ;  $  TAB1 return the value of (a / gcd of a and b) * b ;  $  TAB0 let dix be an integer array with elements as 1, -1, 0, 0, 1, 1, -1, -1 ;  $  TAB0 let diy be an integer array with elements as 0, 0, 1, -1, 1, -1, 1, -1 ;  $  TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 create a vector of integers v and size n ;  $  TAB1 the integer value of res = 0 ;  $  TAB1 for i = 0 to n exclusive , read v[i] ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if v[i] is greater than v[i - 1] and v[i] is greater than v[i + 1] , increment res by 1 ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if v[i] is less than v[i - 1] and v[i] is less than v[i + 1] , increment res by 1 ;  $  TAB1 print res and newline ;  $  TAB1 semicolumn ;
TAB1 n = integer ;  $  TAB1 while read n ;  $  TAB2 a = integer array of size 1005 ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 num = integer with num = 0 ;  $  TAB2 for i = 1 to n - 1 exclusive ;  $  TAB3 if (a[i] > a[i - 1] and a[i] > a[i + 1]), increment num ;  $  TAB3 if (a[i] < a[i - 1] and a[i] < a[i + 1]), increment num ;  $  TAB2 print num ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 arr = int array length n ;  $  TAB1 read the first n elements of arr ;  $  TAB1 sol = 0 = int ;  $  TAB1 for i = 1 to n - 1exclusive ;  $  TAB2 if ((arr[i] - arr[i - 1]) * (arr[i] - arr[i + 1])) is stricly positive then increment sol ;  $  TAB1 print sol ;
TAB1 r =integer ;  $  TAB1 while reading values r ;  $  TAB2 sum = integer with 0 ;  $  TAB2 a = array of 1001 integers with 0 elements ;  $  TAB2 Read r values into array a ;  $  TAB2 for i = 1 to r - 1 exclusive ;  $  TAB3 if a[i] is less than a[i - 1] ;  $  TAB4 if a[i] is less than a[i + 1] ;  $  TAB5 increment sum ;  $  TAB4 else do the following ;  $  TAB5 do nothing ;  $  TAB3 else if a[i] is greater than a[i - 1] ;  $  TAB4 if a[i] is less than a[i + 1], then increment sum ;  $  TAB2 print sum and new line ;
TAB1 let n, i, extrema = 0, arr[1000 + 5] be ints ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive increment i first, read arr[i] ;  $  TAB1 for i = 1 to n-1 increment i first ;  $  TAB2 if arr[i] > arr[i-1] and arr[i] > arr[i+1] ;  $  TAB3 increment first extrema ;  $  TAB2 else if arr[i] < arr[i - 1] and arr[i] < arr[i + 1] ;  $  TAB3 increment first extrema ;  $  TAB1 print extrema ;  $  TAB1 return 0 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let *elements be a integer with *elements = new int[n] ;  $  TAB1 for i = 0 to n exclusive , read elements[i] ;  $  TAB1 the integer value of count = 0 ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 the integer value of prev = elements[i - 1] ;  $  TAB2 the integer value of cur = elements[i] ;  $  TAB2 the integer value of next = elements[i + 1] ;  $  TAB2 if (cur is less than prev and cur is less than next) or (cur is greater than prev and cur is greater than next) , increment count by 1 ;  $  TAB1 print count and newline ;
TAB1 declare new ints n and k and an int array a with size 1005 ;  $  TAB1 read n and loop further ;  $  TAB2 change k to 0 ;  $  TAB2 read n elements into a in a loop ;  $  TAB2 for i from 1 to n - 1 exclusive incrementing i ;  $  TAB3 increment k if a[i] > a[i - 1] and a[i] > a[i + 1] or a[i] < a[i - 1] and a[i] < a[i + 1] ;  $  TAB2 print k to the standard output ;
TAB1 n, a = ints with a an int array of length 1020 ;  $  TAB1 i = int ;  $  TAB1 read n ;  $  TAB1 read the first n elements of a ;  $  TAB1 cnt = 0 = int ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if a at i > a at i - 1 and a at i > a at i + 1 then increment cnt ;  $  TAB2 if a[i] < a[i - 1] and a[i + 1] > a[i] then increment cnt ;  $  TAB1 print cnt ;
TAB0 make ints n and c = 0 ;  $  TAB0 make integer vector a of size 1000 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 1 to n - 2 ;  $  TAB2 if a[i - 1] is greater than a[i] and a[i + 1] is greater than a[i], add 1 to c ;  $  TAB2 if a[i - 1] is less than a[i] and a[i + 1] is less than a[i], increment c ;  $  TAB1 show c ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 v = array of integers of size n ;  $  TAB1 read n integers into array v ;  $  TAB1 create integer ans = 0 ;  $  TAB1 for q=1 to n-1 exclusive ;  $  TAB2 if v[q] > v[q-1] and v[q] > v[q+1] then ;  $  TAB3 increment ans ;  $  TAB2 else if v[q] < v[q-1] and v[q] < v[q+1] then ;  $  TAB3 increment ans ;  $  TAB1 print ans and newline ;
TAB0 declare constant integer maxn = 1e4 + 10 ;  $  TAB0 a is a new array of integers with size maxn ;  $  TAB0 create integer variable n ;  $  TAB0 declare new integer cnt = 0 ;  $  TAB1 read variable n from the input ;  $  TAB1 start a loop from i = 1 to n inclusive, and read a[i] from the input on each loop ;  $  TAB1 in a for loop, change i from 2 to n - 1 inclusive incrementing i ;  $  TAB2 if a[i] > a[i - 1] and a[i] > a[i + 1] or a[i] < a[i - 1] and a[i] < a[i + 1], increment cnt ;  $  TAB1 print cnt ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create character stack st ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if st is empty ;  $  TAB3 add element s[i] to top of st ;  $  TAB2 else if top of st is s[i] ;  $  TAB3 remove element from top of st ;  $  TAB2 else ;  $  TAB3 add element s[i] to top of st ;  $  TAB1 create string tmp with tmp = "" ;  $  TAB1 while st is not empty ;  $  TAB2 increment tmp by top of st ;  $  TAB2 remove element from top of st ;  $  TAB1 reverse element order between beginning of tmp and end of tmp ;  $  TAB1 print tmp print "\n" ;
TAB0 create character stack chars ;  $  TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 create character ch ;  $  TAB1 for i = 0 to str[i] is not '\0', iincrementing i ;  $  TAB2 set ch to str[i] ;  $  TAB2 if chars is not empty ;  $  TAB3 if top of chars is ch ;  $  TAB4 remove element from top of chars ;  $  TAB3 else ;  $  TAB4 add element ch to top of chars ;  $  TAB2 else ;  $  TAB3 add element ch to top of chars ;  $  TAB1 create character vector result ;  $  TAB1 while chars is not empty ;  $  TAB2 add element top of chars to end of result ;  $  TAB2 remove element from top of chars ;  $  TAB1 for i = size of result - 1 to 0 inclusive, decrementing i, print result[i] ;  $  TAB1 print "\n" ;
TAB0 OO = const long long with OO = 1e8 ;  $  TAB0 o_o = const integer with o_o = 0 ;  $  TAB0 EPS = double with EPS = double epsilon numeric_limits ;  $  TAB0 MAX = integer const with MAX = 2 * 100000 + 9 ;  $  TAB0 ar = character array of size MAX ;  $  TAB0 co = integer with co = -1 ;  $  TAB0 in the function inzlition ;  $  TAB1 for i = 0 to MAX exclusive, ar[i] = 0 ;  $  TAB1 text = string ;  $  TAB1 read text ;  $  TAB1 call inzlition ;  $  TAB1 co = -1 ;  $  TAB1 for i = 0 to text.size() exclusive ;  $  TAB2 if co is -1 ;  $  TAB3 increment co ;  $  TAB3 ar[co] = text[i] ;  $  TAB2 else if text[i] is ar[co] ;  $  TAB3 ar[co] = 0 ;  $  TAB3 decrement co ;  $  TAB2 else ;  $  TAB3 increment co ;  $  TAB3 ar[co] = text[i] ;  $  TAB1 for j = 0 to co, print ar[j] ;  $  TAB1 print next line ;
TAB1 declare string s ;  $  TAB1 create vector of characters a ;  $  TAB1 read input to s ;  $  TAB1 declare long int n = length of s ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 if a is empty ;  $  TAB3 push s[i] into a ;  $  TAB2 else if last element of a is not s[i] ;  $  TAB3 push s[i] into a ;  $  TAB2 else ;  $  TAB3 remove last element from a ;  $  TAB1 for i = 0 to length of a exclusive print a[i] ;  $  TAB1 print a new line ;
TAB0 create string s ;  $  TAB1 read s ;  $  TAB1 create integer i with i = size of s - 1 ;  $  TAB1 while i is greater than 0 ;  $  TAB2 if s[i] is s[i-1], erase from i - 1 to length 2 from s ;  $  TAB2 decrement i ;  $  TAB1 print s print "\n" ;
TAB1 x = integer with x = 0 ;  $  TAB1 s2 = string ;  $  TAB1 read s2 ;  $  TAB1 for i = s2.length() - 2 down to 0 ;  $  TAB2 if s2[i] is s2[i + 1], erase(i, 2) from s2 ;  $  TAB1 print s2 ;
TAB1 Let s be a string ;  $  TAB1 Read s ;  $  TAB1 Create integer l and set it to length of s ;  $  TAB1 for i = 1 to l exclusive ;  $  TAB2 if s[i] equals s[i - 1] ;  $  TAB3 erase characters i-1 and i from s ;  $  TAB3 set i = i - 2 ;  $  TAB1 Print s ;
TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 size = int with size = size of str ;  $  TAB1 s = char stack ;  $  TAB1 push str[0] to s ;  $  TAB1 for i = 1 to size if s is not empty and str[i] is top of s then pop s else push str[i] to s ;  $  TAB1 ans = string with ans = "" ;  $  TAB1 loop while s is not empty ;  $  TAB2 append top of s to ans ;  $  TAB2 pop s ;  $  TAB1 reverse ans ;  $  TAB1 print ans ;
TAB0 create constant integer maxn with maxn = 2 * 1e5 + 10 ;  $  TAB0 create character stack s ;  $  TAB0 create string array maxn ;  $  TAB1 while s is not empty, remove element from top of s ;  $  TAB1 create integer len ;  $  TAB1 read string into str + 1 ;  $  TAB1 set len to string length of str + 1 ;  $  TAB1 for i = len to 1 inclusive, decrementing i ;  $  TAB2 if not size of s ;  $  TAB3 add element str[i] to top of s ;  $  TAB2 else ;  $  TAB3 if top of s is str[i] ;  $  TAB4 remove element from top of s ;  $  TAB3 else ;  $  TAB4 add str[i] to top of s ;  $  TAB1 while s is not empty ;  $  TAB2 print top of s ;  $  TAB2 remove element from top of s ;  $  TAB1 print newline ;
TAB1 create characters stack s ;  $  TAB1 declare string f ;  $  TAB1 read input to f ;  $  TAB1 for i from 0 to length of f exclusive ;  $  TAB2 if s is empty ;  $  TAB3 push f[i] to s ;  $  TAB2 else ;  $  TAB3 if f[i] = top element of s ;  $  TAB4 remove top element of s ;  $  TAB3 else ;  $  TAB4 push f[i] to s ;  $  TAB1 declare string variable t = "" ;  $  TAB1 while s is not empty ;  $  TAB2 add top element of s to t ;  $  TAB2 remove top element of s ;  $  TAB1 loop i from length of t - 1 to 0 inclusive counting down, print t[i] ;  $  TAB1 print ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create character stack c ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if c is not empty and top of c is s[i] ;  $  TAB3 remove element from top of c ;  $  TAB2 else ;  $  TAB3 add element s[i] to top of c ;  $  TAB1 create string a ;  $  TAB1 create integer y with y = size of c ;  $  TAB1 while c is not empty ;  $  TAB2 increment a by top of c ;  $  TAB2 remove element from top of c ;  $  TAB1 for i = y - 1 to 0 inclusive, decrementing i, print a[i] ;  $  TAB1 print newline ;
TAB0 create constant integer N with N = 1e5 + 5 ;  $  TAB0 create constant integer inf with inf = 1e9 ;  $  TAB0 create constant long long INF with INF = 1e18 ;  $  TAB0 create constant double PI with PI = acosign of -1.0 ;  $  TAB0 create constant double EPS with EPS = 1e-8 ;  $  TAB0 create constant integer MOD with MOD = 1000000007 ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create character stack st ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if st is empty ;  $  TAB3 add element s[i] to top of st ;  $  TAB2 else ;  $  TAB3 if st is not empty and top of st is s[i] ;  $  TAB4 while st is not empty and top of st is s[i], remove top of st ;  $  TAB3 else ;  $  TAB4 add element s[i] to top of st ;  $  TAB1 create string ans with ans = "" ;  $  TAB1 while st is not emtpy, increment and by top of st, remove top element from st ;  $  TAB1 reverse element order from beginning of and to end of ans ;  $  TAB1 prnt ans print newline ;
TAB0 declare string a ;  $  TAB0 create int i ;  $  TAB1 read a ;  $  TAB1 loop i from length of a to 0 inclusive decrementing i ;  $  TAB2 if a[i] = a[i + 1], remove 2 elements at the index i of a ;  $  TAB1 print a ;
TAB1 create string s ;  $  TAB1 get s ;  $  TAB1 create character array stack with size of s ;  $  TAB1 create long integer j with j=0 ;  $  TAB1 for integer i=0 to size of s exclusive ;  $  TAB2 if j is equal to 0 then ;  $  TAB3 set stack[j] to s[i] and increment j ;  $  TAB2 else if stack[j-1] not equal to s[i] then ;  $  TAB3 set stack[j] to s[i] and increment j ;  $  TAB2 else do the following ;  $  TAB3 decrement j ;  $  TAB1 for i=0 to j exclusive print stack[i] ;  $  TAB1 print a new line ;
TAB0 maxn = const int with maxn = 200010 ;  $  TAB0 str = char array of size maxn ;  $  TAB1 loop while reading str ;  $  TAB2 j, len = int with j = 1 and len = strlen of str ;  $  TAB2 for i = 1 to len ;  $  TAB3 if str[i] is str[j - 1] ;  $  TAB4 decrement j ;  $  TAB4 set str[j] to '\0' ;  $  TAB3 else ;  $  TAB4 set str[j] to str[i] then increment j ;  $  TAB2 set str[j] to '\0' ;  $  TAB2 print str ;
TAB0 create stack of chars st ;  $  TAB1 declare string s ;  $  TAB1 read input to s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if st is not empty and top element of st is not s[i] ;  $  TAB3 remove top element of st ;  $  TAB2 else ;  $  TAB3 push s[i] into st ;  $  TAB1 set s to "" ;  $  TAB1 while st is not emptu ;  $  TAB2 increase s by top element of st ;  $  TAB2 remove top element of st ;  $  TAB1 loop i from length of s - 1 to 0 inclusive decrementing i, printing s[i] ;  $  TAB1 print a new line ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 for i = s.size() - 2 down to 0 ;  $  TAB2 if s[i] is s[i + 1], erase(i, 2) from s ;  $  TAB1 print s ;
TAB1 s = string array ;  $  TAB1 read s ;  $  TAB1 for i = (s.length() - 1) to greater than or equal to 0 do the following ;  $  TAB2 if s[i] is s[i + 1] then do the following s.erase(i, 2) ;  $  TAB1 output s ;
TAB0 declare const int INF = 1e9 + 7 casted to int ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 p is a stack of chars ;  $  TAB1 loop a from 0 to length of s exclusive ;  $  TAB2 if p is empty ;  $  TAB3 push s[a] into p ;  $  TAB2 else ;  $  TAB3 if top element of p = s[a] ;  $  TAB4 remove top element from p ;  $  TAB3 else ;  $  TAB4 push s[a] into p ;  $  TAB1 assign "" to s ;  $  TAB1 while p is not empty ;  $  TAB2 append top element of p to s ;  $  TAB2 remove top element from p ;  $  TAB1 reverse s ;  $  TAB1 print s ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create character stack st ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if st is not empty and s[i] is top of st ;  $  TAB3 remove element from top of st ;  $  TAB2 else ;  $  TAB3 add element s[i] to top of st ;  $  TAB1 set s to "" ;  $  TAB1 while st is not empty ;  $  TAB2 increment s by top of st ;  $  TAB2 remove top element from st ;  $  TAB1 for i = size of s - 1 to 0 inclusive, decrementing i, print s[i] ;  $  TAB1 print newline ;
TAB1 make string str ;  $  TAB1 read str ;  $  TAB1 let ints pearls = 0 and links = 0 ;  $  TAB1 for i = 0 to str.size() exclusive ;  $  TAB2 if str[i] is equal to 'o' ;  $  TAB3 increment pearls ;  $  TAB2 else do ;  $  TAB3 add 1 to links ;  $  TAB1 if pearls is equal to 0 or links is equal to 0 ;  $  TAB2 print "YES" ;  $  TAB1 if (links % pearls) is not equal to 0 ;  $  TAB2 show "NO" ;  $  TAB1 otherwise ;  $  TAB2 display "YES" ;
TAB0 maxn=110 ;  $  TAB0 inf=3fffffff in exadecimal ;  $  TAB0 s=array of maxn char ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 cnt1,cnt2=0 ;  $  TAB1 for i=0 to size of s exclusive ;  $  TAB2 if s[i] is 'o' ;  $  TAB3 increment cnt1 ;  $  TAB2 else ;  $  TAB3 increment cnt2 ;  $  TAB1 if cnt1 is 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 if cnt2 modulo cnt1 is 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 declare character array s size 106 ;  $  TAB1 while read string into s ;  $  TAB2 declare integers a = 0, b = 0, ll = string length of s ;  $  TAB2 for i = 0 to ll exclusive ;  $  TAB3 if s[i] is '-' ;  $  TAB4 increment a ;  $  TAB3 else if s[i] is 'o' ;  $  TAB4 increment b ;  $  TAB2 if b is 0 or a % b is 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare integers z = 0, x = 0 ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is 'o', increment z ;  $  TAB2 if s[i] is '-', increment x ;  $  TAB1 if z is 0 or x is 0 or x % z is 0 ;  $  TAB2 print "YES" and newline ;  $  TAB1 else ;  $  TAB2 print "NO" and newline ;
TAB0 create chars zhu and xian and char array s of size 243554 ;  $  TAB1 read s ;  $  TAB1 make int len = strlen(s) ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if s[i] is equal to '0' ;  $  TAB3 increment zhu ;  $  TAB2 else do ;  $  TAB3 increase xian by 1 ;  $  TAB1 if zhu is equal to 0 ;  $  TAB2 print "YES" ;  $  TAB1 else if xian modulo zhu is 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 maxn = 110 = int const ;  $  TAB0 inf = 0x3f3f3f3f = const int ;  $  TAB0 s = char array of length maxn ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 cnt1 = cnt2 = 0 = int ;  $  TAB1 for i = 0 to size of s ;  $  TAB2 if s at i is 'o' ;  $  TAB3 increment cnt1 ;  $  TAB2 else ;  $  TAB3 increment cnt2 ;  $  TAB1 if cnt1 = 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 if cnt2 mod cnt1 is 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 x = 0 = int ;  $  TAB1 for i = 0 to length of s ;  $  TAB2 if s[i] = 'o' then increment x ;  $  TAB1 if x = 0 ;  $  TAB2 print YES and new line ;  $  TAB1 else ;  $  TAB2 if length of s mod x = 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB0 declare new string called s ;  $  TAB0 create ints p and l = 0 ;  $  TAB1 read from the input to s ;  $  TAB1 for integer i = 0 to length of s exclusive ;  $  TAB2 if s[i] = '-' ;  $  TAB3 increment l by one ;  $  TAB2 else ;  $  TAB3 increment p ;  $  TAB1 if p = 0 or l % p = 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 s = string ;  $  TAB1 j, k =integers, both set to 0 ;  $  TAB1 Read s ;  $  TAB1 for i = 0 to length of string s exclusive ;  $  TAB2 if s[i] is - ;  $  TAB3 increment j ;  $  TAB2 else do the following ;  $  TAB3 increment k ;  $  TAB1 if k is equal to 0 ;  $  TAB2 print Yes and a new line ;  $  TAB1 else if j modulo k is 0 ;  $  TAB2 print Yes and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and new line ;
TAB0 set INF to 0x3f3f3f3f ;  $  TAB0 create char s[1005] ;  $  TAB1 create int i, j and k ;  $  TAB1 create int n and m ;  $  TAB1 read s ;  $  TAB1 set cou and co to 0 ;  $  TAB1 for i=0 to length of s exclusive ;  $  TAB2 if s[i] = o ;  $  TAB3 increment cou ;  $  TAB2 else ;  $  TAB3 increment co ;  $  TAB1 if cou =0 ;  $  TAB2 print YES ;  $  TAB1 if co < cou and > 0 ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 if co mod cou =0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 x , o =integers with x = 0, o = 0 ;  $  TAB1 n =string ;  $  TAB1 Read n ;  $  TAB1 for i = 0 to length of string t exclusive ;  $  TAB2 if n[i] is o ;  $  TAB3 increment o ;  $  TAB2 else do the following ;  $  TAB3 increment x ;  $  TAB1 if o is greater than 0 ;  $  TAB2 if x modulo o is 0 ;  $  TAB3 print YES and a new line ;  $  TAB2 else do the following ;  $  TAB3 print NO and a new line ;  $  TAB1 else do the following ;  $  TAB2 print YES and a new line ;
TAB1 set char to S[101] ;  $  TAB1 set pearls and dash to 0 ;  $  TAB1 read S ;  $  TAB1 for i=0 to S[i] ;  $  TAB2 if S[i] = - ;  $  TAB3 increment dash ;  $  TAB2 else ;  $  TAB3 increment pearls ;  $  TAB1 if pearls=0 or dash mod pearls =0 ;  $  TAB2 print YES and a newline ;  $  TAB1 else ;  $  TAB2 print NO and a newline ;
TAB0 len, n1, n2 = long long integers ;  $  TAB0 s = array of 105 characters ;  $  TAB1 Read s ;  $  TAB1 set len to length of string s ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if s[i] is o ;  $  TAB3 increment n1 ;  $  TAB2 else if s[i] is - ;  $  TAB3 increment n2 ;  $  TAB1 if n1 is 0 ;  $  TAB2 print YES and a new line ;  $  TAB1 else if n2 modulo n1 is 0 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 count , p, i, n =integers with count = 0, p = 0 ;  $  TAB1 a =string ;  $  TAB1 Read a ;  $  TAB1 set n to length of string a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is - ;  $  TAB3 increment count ;  $  TAB2 else do the following ;  $  TAB3 increment p ;  $  TAB1 if count is 0 OR p is 0 ;  $  TAB2 print YES and a new line ;  $  TAB1 else if count modulo p is 0 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 declare string variable with name cad ;  $  TAB1 read cad from the input ;  $  TAB1 declare new int variables guiones and perlas = 0 ;  $  TAB1 for integer i = 0 to length of cad exclusive incrementing i ;  $  TAB2 if cad[i] is equal to '-' ;  $  TAB3 increment guiones by one ;  $  TAB2 else ;  $  TAB3 increment perlas ;  $  TAB1 if guiones or perlas is equal to 0 ;  $  TAB2 print "YES\n" to the standard output ;  $  TAB1 else ;  $  TAB2 if guiones is less than perlas ;  $  TAB3 print "NO\n" ;  $  TAB2 else ;  $  TAB3 if guiones = perlas ;  $  TAB4 print "YES\n" to the standard output ;  $  TAB3 else ;  $  TAB4 if guiones % perlas = 0 ;  $  TAB5 print "YES\n" ;  $  TAB4 else ;  $  TAB5 print "NO\n" ;
TAB1 link, pearl = integers with link = 0, pearl = 0 ;  $  TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 for i = 0 to str.length() exclusive ;  $  TAB2 if (str[i] is -) ;  $  TAB3 increment link ;  $  TAB2 else ;  $  TAB3 increment pearl ;  $  TAB1 if (pearl is 0) ;  $  TAB2 print YES ;  $  TAB1 if (link % pearl == 0) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 bul = integer = 0, ris = integer = 0 ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is - ;  $  TAB3 ris = ris + 1 ;  $  TAB2 else ;  $  TAB3 bul = bul + 1 ;  $  TAB1 if bul is 0 ;  $  TAB2 print YES ;  $  TAB1 else if ris modulo bul is 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 a=array of 1001 char ;  $  TAB1 n,m=int ;  $  TAB1 while read a ;  $  TAB2 n,m=0 ;  $  TAB2 for i=0 to length of s exclusive ;  $  TAB3 if a[i] is '-' ;  $  TAB4 increment n ;  $  TAB3 else if a[i] is 'o' ;  $  TAB4 increment m ;  $  TAB2 if n is 0 or m is 0 or n modulo m is 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 s = string ;  $  TAB1 a, b = integers ;  $  TAB1 Read s ;  $  TAB1 for i = 0 to length of string s exclusive ;  $  TAB2 if s[i] is - ;  $  TAB3 increment b ;  $  TAB2 else do the following ;  $  TAB3 increment a ;  $  TAB1 if a is 0 OR b modulo a is 0 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB0 Create constant integer maxN with value 10^5 ;  $  TAB1 n, x, y = integers ;  $  TAB1 read n, x, and y ;  $  TAB1 create double t and set it to ceil of n * y * 1.0 / 100.0 ;  $  TAB1 call max on (int) t - x and 0 and print the result ;
TAB0 declare const int M = 100 + 5 ;  $  TAB1 declare ints n, x and y ;  $  TAB1 read n, x and y ;  $  TAB1 declare integer variable tmp = n * y / 100 + ((n * y) % 100 !=0) - x ;  $  TAB1 declare integer ans = max of tmp and 0 ;  $  TAB1 print ans ;
TAB1 define ints n, x, and y ;  $  TAB1 read n, x, and y ;  $  TAB1 define integer z and set it to the ceiling of ( (double) n * y / 100) ;  $  TAB1 if z is greater than x ;  $  TAB2 print z - x followed by a newline ;  $  TAB1 else ;  $  TAB2 print 0 followed by a newline ;
TAB1 create long longs n, x, y, ans and xx ;  $  TAB1 read n, x and y ;  $  TAB1 change xx to n * y / 100 ;  $  TAB1 while xx * 100 < n * y ;  $  TAB1 set ans to max of 0LL and xx - x ;  $  TAB1 print ans and "\n" ;
TAB1 create integers n, x, y ;  $  TAB1 create integer p with p = 1 ;  $  TAB1 read n ;  $  TAB1 read x ;  $  TAB1 read y ;  $  TAB1 set p to n * y ;  $  TAB1 if p % 100 is not 0 ;  $  TAB2 set p to p / 100 + 1 ;  $  TAB1 else ;  $  TAB2 set p to p / 100 ;  $  TAB1 if p is less than or equal to x ;  $  TAB2 print 0 print newline ;  $  TAB1 else ;  $  TAB2 print p - x print newline ;
TAB0 create doubles size_n, size_x, size_y ;  $  TAB0 create double result ;  $  TAB1 create doubles man, have_now ;  $  TAB1 read size_n read size_x read size_y ;  $  TAB1 set man to size_n * 0.01 ;  $  TAB1 set have_now to size_x / man ;  $  TAB1 if have_now is less than size_y ;  $  TAB2 set result to (size_y - have_now) * man ;  $  TAB2 if double casted ( integer casted ( result ) ) is not result, increment result by 1 ;  $  TAB1 else ;  $  TAB2 set result to 0 ;  $  TAB1 print integer casted result print newline ;
TAB1 define doubles n, x, and y ;  $  TAB1 read n, x, y ;  $  TAB1 define int r, setting it to the ceiling of (y / 100 * n) ;  $  TAB1 if x >= r... ;  $  TAB2 print 0 and a newline ;  $  TAB1 otherwise... ;  $  TAB2 print the difference of r and x, followed by a newline ;
TAB1 declare long long int variables x, y and n ;  $  TAB1 read n, x and y ;  $  TAB1 create double m = (n * y) / 100 ;  $  TAB1 declare long long int dem = m rounded up ;  $  TAB1 if x >= dem ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print dem - x ;
TAB0 n, x, y = integers ;  $  TAB1 read n, x, y ;  $  TAB1 print max(0, (n * y + 99) / 100 - x) ;
TAB0 create constant long long mod with mod = 1e9 + 7 ;  $  TAB0 create constant integer N with N = 1e5 + 5 ;  $  TAB0 declare gcd with long longs a, b as arguments, returning long long ;  $  TAB1 return result of run gcd with b, a % b as arguments if b is true, else a ;  $  TAB0 declare pwr with long longs x, y as arguments, returning long long ;  $  TAB0 declare isprime with long long x as argument, returning boolean ;  $  TAB1 create integers n, x, y ;  $  TAB1 read n read x read y ;  $  TAB1 create integer ans with ans = ((n * y ) / 100 + boolean casted ((n * y ) % 100 ) ;  $  TAB1 if x is greater than ans ;  $  TAB2 print 0 print newline ;  $  TAB1 print ans - x print newline ;  $  TAB0 declare pwr with long longs x, y as arguments, returning long long ;  $  TAB1 create long long ans with ans = 1 ;  $  TAB1 set x to x % mod ;  $  TAB1 while y is greater than 0 ;  $  TAB2 if y bitwise and 1, set ans to (x * ans) % mod ;  $  TAB2 set x to ( x * x ) % mod ;  $  TAB2 set y to y / 2 ;  $  TAB1 return ans from function ;  $  TAB0 declare isprime with long long x as argument, returning boolean ;  $  TAB1 if x is less than 2, return false from function ;  $  TAB1 if x is less than 4, return true from function ;  $  TAB1 if x % 2 is 0 or x % 3 is 0 , return false from fucntion ;  $  TAB1 for i = 5 to i * i is less than or equal to x, increment i by 6 ;  $  TAB2 if x % i is 0 or x % ( i + 2 ) is 0, return false from function ;  $  TAB1 return true from function ;
TAB1 integers = n,x,y ;  $  TAB1 read n,x,y ;  $  TAB1 ans is the rounding up of ((double)y / 100 * n) ;  $  TAB1 if ans - x is greater than 0 then do the following ;  $  TAB2 output ans - x ;  $  TAB1 else ;  $  TAB2 output 0 ;
TAB1 declare doubles n, x and y ;  $  TAB1 read n, x and y ;  $  TAB1 declare integer variable temp = x ;  $  TAB1 while (x / n) * 100 < y ;  $  TAB1 print x - temp ;
TAB1 declare integers n, x and y ;  $  TAB1 read n, x and y ;  $  TAB1 create int res = ((y / 100.0) * n) rounded up - x ;  $  TAB1 if res is less than 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print res ;
TAB1 n, x, y = int ;  $  TAB1 read n then x then y ;  $  TAB1 temp = int with temp = (y * n / 100) + 1 if (y * n % 100) is not 0 ;  $  TAB1 decrement temp by x ;  $  TAB1 if temp is less or equal to 0 ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print temp ;
TAB1 Create x, y, and z as double precision number ;  $  TAB1 Set x to the first input, y to the second input, and z to the third input ;  $  TAB1 Create ans as an integer and set to the next bigger integer of (x*z)/100 then subtract y ;  $  TAB1 If ans is negative ;  $  TAB2 Output 0 ;  $  TAB1 Otherwise ;  $  TAB2 Output ans ;
TAB1 create doubles n, x, y ;  $  TAB1 read n read x read y ;  $  TAB1 create long long z with z = round up ( ( y / 100 ) * n ) ;  $  TAB1 create long long ans with ans = 0 ;  $  TAB1 if z is greater than x, set ans to z - x ;  $  TAB1 print ans print newline ;
TAB1 let n, x, y be ints ;  $  TAB1 read n, x, and y ;  $  TAB1 print (y*n - min(y*n, x*100) + 99)/100 ;
TAB1 create int n, x and y ;  $  TAB1 read n, x, y ;  $  TAB1 set p to (x * 100.0) / (n * 1.0) ;  $  TAB1 if p >= y ;  $  TAB2 print 0 ;  $  TAB1 S=0 ;  $  TAB1 for i= x+1 to 1000010 inclusive ;  $  TAB2 increment S ;  $  TAB2 if (i * 100.0) / (n * 1.0) >= y, break the loop ;  $  TAB1 print S ;
TAB1 define ints n, x, y ;  $  TAB1 read n, x, and y ;  $  TAB1 define int clones set to (n y + 99) / 100 - x ;  $  TAB1 if clones is negative, then set clones to 0 ;  $  TAB1 print clones and newline ;
TAB0 N, K, ans, A, val, x, y = integers with A = array of size 10 ;  $  TAB0 T, S, P = string ;  $  TAB0 cek = bool ;  $  TAB1 read N, x, y ;  $  TAB1 print max(0, (N * y - 1) / 100 + 1 - x) ;
TAB1 create integers x, y, z, t1, t2, t3 ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 create integers el, st ;  $  TAB1 set el to absolute value of ( x - z ) * t2 + 3 * t3 + absolute value of ( y - x ) * t2 ;  $  TAB1 set st to absolute value of ( x - y ) * t1 ;  $  TAB1 if st is less than el ;  $  TAB2 print "NO\n" ;  $  TAB1 else ;  $  TAB2 print "YES\n" ;
TAB1 x, y, z, t1, t2, t3 = integers ;  $  TAB1 read x and y and z and t1 and t2 and t3 ;  $  TAB1 set k = x - y ;  $  TAB1 if k < 0 set k = k * -1 ;  $  TAB1 set l = z - x ;  $  TAB1 if l < 0 then l = l * -1 ;  $  TAB1 set stairs = k * t1 ;  $  TAB1 set elevator = 1 * t2 + k * t2 + 3 * t3 ;  $  TAB1 if stairs < elevator ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;
TAB1 create integers x, y, z, t1, t2, t3, st, el ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 set st to absolute value of (x - y) * t1 ;  $  TAB1 set el to (absolute value of (x-z) + absolute value of(x-y)) * t2 + t3 * 3 ;  $  TAB1 if el is less than or equal to st ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 create integers x, y, z, t1, t2, t3 ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 if ( ( absolute value of ( z - x ) + absolute value of ( x - y ) ) * t2 + 3 * t3 is less than or equal to absolute value of ( x - y ) * t1 ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 x, y, z, t1, t2, t3 =integers ;  $  TAB1 Read x, y, z, t1, t2, t3 ;  $  TAB1 masha_time = integer, set to absolute value of x - y * t1 ;  $  TAB1 elevator_time = integer, set to absolute value of x - z * t2 + absolute value of x - y * t2 + t3 + t3 + t3 ;  $  TAB1 if elevator_time is less than or equal to masha_time ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 let x, y, z, t1, t2 and t3 be integers ;  $  TAB1 read x, y, z, t1, t2 and t3 ;  $  TAB1 if abs(x - z) * t2 + abs(x - y) * t2 + t3 * 3 <= abs(x - y) * t1 ;  $  TAB2 print "YES" and '\n' ;  $  TAB1 else ;  $  TAB2 print "NO" and '\n' ;
TAB0 create constant integer INF with INF = 0x3f3f3f3f ;  $  TAB1 create integers x, y, z, t1, t2, t3 ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 create integers tv, ts with tv = 0, ts = 0 ;  $  TAB1 set ts to t1 * absolute value of ( y - x ) ;  $  TAB1 set tv to t2 * absolute value of ( z - x ) + t2 * absolute value of ( y - x ) + t3 * 3 ;  $  TAB1 if tv is less than or equal to ts ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create integers x, y, z, t1, t2, t3 ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 create integer str_dif with str_dif = x - y ;  $  TAB1 create integer elv_dif with elv_dif = x - z ;  $  TAB1 if str_dif is less than 0 or elv_dif is less than 0 ;  $  TAB2 if str_dif is less than 0, set str_dif to str_dif * -1 ;  $  TAB2 if elv_dif is less than 0, set elv_dif to elv_dif * -1 ;  $  TAB1 create integer str_time with str_time = str_dif * t1 ;  $  TAB1 create integer elv_time with elv_time = elv_dif * t2 + str_dif * t2 + 3 * t3 ;  $  TAB1 if str_time is less than elv_time ;  $  TAB2 print "NO" print newline ;  $  TAB1 else ;  $  TAB2 print "YES" print newline ;
TAB1 x, y, z, t1, t2, t3 = integers ;  $  TAB1 read x, y, z, t1, t2, t3 ;  $  TAB1 set stairs to abs(y - x) * t1 ;  $  TAB1 elevator = abs(z - x) * t2 + abs(y - x) * t2 + 3 * t3 ;  $  TAB1 if elevator <= stairs ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 x , y, z , t1 ,t2 ,t3 = integers ;  $  TAB1 read x , y, z , t1 ,t2 and t3 ;  $  TAB1 if (((abs(x - y) + abs(x - z)) * t2) + (3 * t3) <= ((abs(x - y)) * t1))) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 declare integer variables x, y, z, t1, t2 and t3 ;  $  TAB1 read x, y, z, t1, t2 and t3 ;  $  TAB1 declare integer variables ans1 and ans2 with ans2 = (absolute value of x - y) * t1 ;  $  TAB1 ans1 = (absolute value of z - x) * t2 + t3 * 3 + (absolute value of x - y) * t2 ;  $  TAB1 if ans1 <= ans2 ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB1 let a, b, c, d, e, f, g, m, s, l, n, t be integers ;  $  TAB1 read a,b,c,d,e and f ;  $  TAB1 s is equal to (a - b) * d ;  $  TAB1 if (s is less than 0) , s is equal to -1 * s ;  $  TAB1 l is equal to ((c - a) * e); ;  $  TAB1 if (l is less than 0) , l is equal to -l; ;  $  TAB1 t is equal to (a - b) * e ;  $  TAB1 if (t is less than 0) , t is equal to -t ;  $  TAB1 m is equal to t + l + 3 * f ;  $  TAB1 if (m is less than or equal to s) ;  $  TAB2 print YES and endline ;  $  TAB1 else do something ;  $  TAB2 print NO and endline ;
TAB1 x, y, z, t1, t2, t3=integers ;  $  TAB1 read x, y, z, t1, t2 and t3 ;  $  TAB1 a,b,c,d = long integers ;  $  TAB1 if(x>y) execute ;  $  TAB2 set a to y-x ;  $  TAB1 else execute ;  $  TAB2 set a to x-y ;  $  TAB1 set c to a*t1 ;  $  TAB1 if(z is greater than x) execute ;  $  TAB2 b=z-x ;  $  TAB1 else execute ;  $  TAB2 b=x-z ;  $  TAB1 set d to (b + a) * t2 + 3 * t3 ;  $  TAB1 if(c is greater than or equal to d) ;  $  TAB2 Print out YES ;  $  TAB1 else ;  $  TAB2 Print out NO ;
TAB0 assign value 4 to constant integer MAX ;  $  TAB1 let x, y, z, t1, t2 and t3 be integers ;  $  TAB1 read x, y, z, t1, t2 and t3 ;  $  TAB1 let a and b be integers ;  $  TAB1 a = abs(z - x) * t2 + t3 * 3 + abs(x - y) * t2 ;  $  TAB1 b = abs(x - y) * t1 ;  $  TAB1 if a <= b ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB1 declare integers x, y, z, a, b, c ;  $  TAB1 read x, y, z, a, b, c ;  $  TAB1 declare integer stair as (absolute value of x-y) times a ;  $  TAB1 declare integer lift as (absolute value (x - z) + absolute value (x - y)) * b + (3 * c) ;  $  TAB1 if lift is less than or equal to stair ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB1 create integers x, y, z, t1, t2, t3 ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 create integer tot1 with tot1 = absolute value of ( z - x ) * t2 + t3 * 3 + absolute value of ( y - x ) * t2 ;  $  TAB1 create integer tot2 with tot2 = absolute value of ( y - x ) * t1 ;  $  TAB1 if tot1 is greater than tot2 ;  $  TAB2 print "NO" print newline ;  $  TAB1 else ;  $  TAB2 print "YES" print newline ;
TAB0 let x, y, z, t1, t2, t3, e be long integers ;  $  TAB1 read the values x, y, z, t1, t2, t3 ;  $  TAB1 let the value of e is equal to abs(z - x) * t2 ;  $  TAB1 let the value of e is equal to e + t3 * 3 ;  $  TAB1 let the value of e is equal to e +abs(y - x) * t2 ;  $  TAB1 let the value of t1 is equal to t1 * abs(y - x) ;  $  TAB1 if ( t1 is greater than or equal to e ) ;  $  TAB2 print YES and newline ;  $  TAB1 else , do the following ;  $  TAB2 print NO and newline ;
TAB0 let mod is a long integer with value 1e9 + 7 ;  $  TAB0 do map<int, int> mp ;  $  TAB0 let a is an array of size 200001 which is a long integer ;  $  TAB0 let b is an array of size 200001 which is a long integer ;  $  TAB0 let c is an array of size 11 which is a long integer ;  $  TAB0 let u is an array of size 151 which is a long integer ;  $  TAB1 let n, m, mn , l, t1, t2, t3 be long integers with mn is equal to 0 ;  $  TAB1 initialize the long integers cnt and ans to 0 ;  $  TAB1 read the values n,m and l ;  $  TAB1 read the values t1,t2 and t3 ;  $  TAB1 let the value of long integer res = abs(n - l) * t2 + t3 + t3 + abs(n - m) * t2 + t3; ;  $  TAB1 let the value of long integer oi is equal to abs(n - m) * t1 ;  $  TAB1 if (res is greater than oi) ;  $  TAB2 print NO and newline ;  $  TAB1 else do the following ;  $  TAB2 print YES and endline ;
TAB0 declare abs with integer x as argument, returning integer ;  $  TAB1 if x is less than 0, return -x ;  $  TAB1 return x ;  $  TAB0 declare solve with no arguments, returning void ;  $  TAB1 create integers x, y, z, t1, t2, t3 ;  $  TAB1 read x read y read z read t1 read t2 read t3 ;  $  TAB1 create integer timeWalk with timeWalk = absolute value of ( y - x ) * t1 ;  $  TAB1 create integer timeTakeElevator with timeTakeElevator = t3 * 3 ;  $  TAB1 increment timeTakeElevator by absolute value of ( x - z ) * t2 ;  $  TAB1 increment timeTakeElevator by absolute value of ( y - x ) * t2 ;  $  TAB1 if timeTakeElevator is greater than timeWalk ;  $  TAB2 print "NO\n" ;  $  TAB1 else ;  $  TAB2 print "YES\n" ;  $  TAB1 run solve ;
TAB1 x,y,z,t1,t2,t3 = int ;  $  TAB1 read x,y,z,t1,t2,t3 ;  $  TAB1 fd = absolute value of x-y ;  $  TAB1 cd = absolute value of x-z ;  $  TAB1 stt, lift_t = int ;  $  TAB1 stt = fd*t1 ;  $  TAB1 nw = int ;  $  TAB1 nw = fd+cd ;  $  TAB1 lift_t = (nw*t2)+(3*t3) ;  $  TAB1 mn = int ;  $  TAB1 if lift_t <= stt ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 x, y, z, t1, t2 and t3 are integers ;  $  TAB1 read x, y, z, t1, t2 and t3 ;  $  TAB1 walk_time is integer = asbolute value of(x - y) * t1 ;  $  TAB1 lift_time = asbolute value of( x - z ) * t2 + asbolute value of( x - y ) * t2 ;  $  TAB1 increase lift_time by (t3 * 3) ;  $  TAB1 if lift_time <= walk_time ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB0 create integers x, y, z, a, b, c ;  $  TAB1 read x read y read z read a read b read c ;  $  TAB1 create integer r with r = absolute value of ( x - y ) * a ;  $  TAB1 create integer s with s = absolute value of ( x - z ) * b + 3 * c + absolute value of ( x - y ) * b ;  $  TAB1 if r is less than s ;  $  TAB2 print "NO\n" ;  $  TAB1 else ;  $  TAB2 print "YES\n" ;
TAB0 function absu with integer argument q that returns integer ;  $  TAB1 if q is greater than 0 ;  $  TAB2 return q ;  $  TAB1 else ;  $  TAB2 return -q ;  $  TAB1 create integers x, y, z, t1, t2, t3, a and b ;  $  TAB1 read x, y, z, t1, t2 and t3 ;  $  TAB1 a = absu(x - y) * t1 ;  $  TAB1 b = absu(x - z) * t2 + absu(x - y) * t2 + 3 * t3 ;  $  TAB1 if a is less than b ;  $  TAB2 print "NO" and a new line ;  $  TAB1 else ;  $  TAB2 print "YES" and a new line ;
TAB0 MOD = 998244353 ;  $  TAB0 N, M, K, H, W, L, R = long long integers ;  $  TAB1 a, b, c, d, e, f = integers ;  $  TAB1 read a, b, c, d, e and f ;  $  TAB1 N = absolute value of (a - b) * d ;  $  TAB1 M = absolute value of (a - c) * e ;  $  TAB1 M = M + absolute value of (b - a) * e ;  $  TAB1 M = M + 3 * f ;  $  TAB1 if N is greater or equal than M ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 a = array of integers of length 100 ;  $  TAB1 let n, count, ans be integers with ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 count is equal to 0 ;  $  TAB2 for j = i to n exclusive ;  $  TAB3 if a[j] is equal to 1, increment count by 1 ;  $  TAB2 for k = 0 to i exclusive ;  $  TAB3 if a[k] is equal to 0, increment count by 1 ;  $  TAB2 ans = maximum of ans, count ;  $  TAB1 print ans and newline ;
TAB1 create int n, a[105], temp, ans, i and j, set ans to 1 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive, read a[i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 temp=0 ;  $  TAB2 for j=0 to i exclusive ;  $  TAB3 if a[j]=0, increment temp ;  $  TAB2 for j=i to n exclusive ;  $  TAB3 if a[j] different from 0, increment temp ;  $  TAB2 set ans to max of ans and temp ;  $  TAB1 print ans ;
TAB0 inf = const int with inf = 0x3f3f3f3f ;  $  TAB0 s, dp = int array of size 105 each and n = int ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive read s[i] ;  $  TAB1 set dp[1] to s[1] ;  $  TAB1 len = int with len = 1 ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if s[i] >= dp[len] ;  $  TAB3 increment lent then set dp[len] to s[i] ;  $  TAB2 else ;  $  TAB3 index = int with index = upper_bound of (dp + 1, dp + 1 + len, s[i]) - dp ;  $  TAB3 set dp[index] to s[i] ;  $  TAB1 print len ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = integer array of size 200 ;  $  TAB1 one, zero = integers with one = 0, zero = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if (a[i]) increment one ;  $  TAB1 ans = integer with ans = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if (a[i] is 0) increment zero ;  $  TAB2 ans = max ans and one + zero ;  $  TAB2 if (a[i] is 1) decrement one ;  $  TAB1 print ans ;
TAB0 create integer array cont of size 1005 ;  $  TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read cont[i] ;  $  TAB1 let integer ans = 0 ;  $  TAB1 let int now = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if cont[i] is 0 ;  $  TAB3 add 1 to now ;  $  TAB3 set ans to max of ans and now ;  $  TAB2 else do ;  $  TAB3 create int tmp = now ;  $  TAB3 for j = i to n exclusive ;  $  TAB4 if cont[j] is truthy, add 1 to tmp ;  $  TAB3 set ans to max of ans and temp ;  $  TAB1 display ans ;
TAB0 declare new constant integer MAXN with value 100+5 ;  $  TAB0 create constant integer called INF = 0x3f3f3f3f ;  $  TAB1 create new integer called n ;  $  TAB1 read standard input to n ;  $  TAB1 data is a new array of integers with MAXN elements ;  $  TAB1 read n elements to data from the user input ;  $  TAB1 let cnt and ans be integers where ans = n ;  $  TAB1 start for loop from i = 1 to n exclusive incrementing i ;  $  TAB2 change the value of cnt to 0 ;  $  TAB2 if data[i - 1] = data[i], go to the start of the loop ;  $  TAB2 for j = 0 to i exclusive ;  $  TAB3 if data[j] != 0, increment cnt ;  $  TAB2 for j from i to n exclusive incrementing j ;  $  TAB3 if data[j] != 1, increment cnt ;  $  TAB2 assign min of ans and cnt to ans ;  $  TAB1 set cnt to 0 ;  $  TAB1 in a for loop, change i from 0 to n exclusive incrementing i ;  $  TAB2 if data[i] != 0, increment cnt by one ;  $  TAB1 assign min of ans and cnt to ans ;  $  TAB1 change the value of cnt to 0 ;  $  TAB1 start for loop from i = 0 to n exclusive incrementing i ;  $  TAB2 if data[i] != 1, add 1 to cnt ;  $  TAB1 set ans to min of ans and cnt ;  $  TAB1 print n - ans and '\n' to the standard output ;
TAB1 create int n ;  $  TAB1 while read n ;  $  TAB2 create int game[n] ;  $  TAB2 for i=0 to n exclusive, read game[i] ;  $  TAB2 set large and prezero =0 ;  $  TAB2 for i=0 to n exclusive ;  $  TAB3 if game[i] =0 ;  $  TAB4 increment prezero ;  $  TAB4 set large to max of large and prezero ;  $  TAB3 else ;  $  TAB4 set cur to prezero ;  $  TAB4 for j=i to n exclusive ;  $  TAB5 if game[j] =1, increment cur ;  $  TAB4 set large to max of cur and large ;  $  TAB2 print large and a newline ;
TAB0 make const integer maxn = 100005 ;  $  TAB0 make int arrays s of size maxn and dp of size maxn ;  $  TAB0 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read s[i] ;  $  TAB1 set dp[1] to s[1] ;  $  TAB1 create int len = 1 ;  $  TAB1 for i = 2 to n ;  $  TAB2 if s[i] is greater than or equal to dp[len] ;  $  TAB3 set dp[++len] to s[i] ;  $  TAB2 otherwise ;  $  TAB3 create int index = upper_bound(dp + 1, dp + len + 1, s[i]) - dp ;  $  TAB3 set dp[index] to s[i] ;  $  TAB1 print len ;
TAB1 i,j,n,t=int, a=1, s=array of 10000 int ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive read s[i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 t=0 ;  $  TAB2 for j=0 to i inclusive ;  $  TAB3 if not s[j] increment t ;  $  TAB2 for j=i to n exclusive ;  $  TAB3 if s[j] increment t ;  $  TAB2 a=max(a,t) ;  $  TAB1 print a ;
TAB0 a, d = integer array of size 4005 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 d[1] = a[1] ;  $  TAB1 len = integer with len = 1 ;  $  TAB1 for i = 2 to n ;  $  TAB2 if (a[i] >= d[len]) ;  $  TAB3 d[increment len] = a[i] ;  $  TAB2 else ;  $  TAB3 j = integer with j = upper_bound(d + 1, d + len + 1, a[i]) - d ;  $  TAB3 d[j] = a[i] ;  $  TAB1 print len ;
TAB1 create ints n, p = 1, and cnt = 0 and int array a of size 1000 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 for i = 1 to n ;  $  TAB2 create int t = 0 ;  $  TAB2 for j = 1 to i ;  $  TAB3 if a[j] is equal to 0, increment t ;  $  TAB2 for j = i to n ;  $  TAB3 if a[j] is equal to 1, increment t ;  $  TAB2 set cnt to max of cnt and t ;  $  TAB1 print cnt ;
TAB0 declare new constant integer called N = 105 ;  $  TAB0 create new ints n and ans; declare int arrays s and dp with N elements ;  $  TAB1 read user input to n ;  $  TAB1 read input to s[i] from the index 1 to n inclusive ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 set dp[i] to 1 ;  $  TAB2 for j from i - 1 to 1 inclusive decrementing j ;  $  TAB3 if s[i] is equal to 0 ;  $  TAB4 if s[j] = 0, change the value of dp[i] to max of dp[i] and 1 + dp[j] ;  $  TAB3 else ;  $  TAB4 change the value of dp[i] to max of dp[i] and 1 + dp[j] ;  $  TAB2 assign max of dp[i] and ans to ans ;  $  TAB1 print ans and "\n" ;
TAB0 size = const integer with size = 105 ;  $  TAB0 suf, pre = integers with pre, suf = integer array of size size = {0} ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 arr = integer array of size n + 1 = {0} ;  $  TAB1 for i = 1 to n, read arr[i], suf[i] = (arr[i]), pre[i] = (not arr[i]) ;  $  TAB1 for i = n down to 1, suf[i] = suf[i] + suf[i + 1] ;  $  TAB1 for i = 1 to n, pre[i] = pre[i] + pre[i - 1] ;  $  TAB1 ans = integer with ans = 0 ;  $  TAB1 for i = 1 to n, ans = max(ans, pre[i] + suf[i]) ;  $  TAB1 print ans ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = integer array of size 200 ;  $  TAB1 one, zero = integers with one = 0, zero = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if (a[i]) increment one ;  $  TAB1 ans = integer with ans = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 if (a[i] is 0), increment zero ;  $  TAB2 ans = max of ans and one + zero ;  $  TAB2 if (a[i] is 1), decrement one ;  $  TAB1 print ans ;
TAB0 create const integer maxn = 10005 ;  $  TAB0 create integer array s of size maxn ;  $  TAB0 make int array dp of size dp ;  $  TAB0 create int len = 0 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read s[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set dp[i] to 1 ;  $  TAB2 for j = 0 to i exclusive ;  $  TAB3 if s[i] is greater than or equal to s[j] and dp[j] + 1 is greater than dp[i], set dp[i] to dp[j] + 1 ;  $  TAB2 set len to max of dp[i] and len ;  $  TAB1 print len ;
TAB0 make long long integer a of size 204 ;  $  TAB1 create long long integer n, i, j, k, x, y, t, and m ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 make long long integer mx = 0 and cnt1 = 0 ;  $  TAB1 for i = 1 to n ;  $  TAB2 create long long integer cnt = 0 ;  $  TAB2 if a[i] is 1, increment cnt1 ;  $  TAB2 if a[i] is 0 ;  $  TAB3 for j = 1 to i ;  $  TAB4 if a[j] is 0, increment cnt ;  $  TAB3 for j = i + 1 to n ;  $  TAB4 if a[j] is 1, add 1 to cnt ;  $  TAB3 set mx to max of mx and cnt ;  $  TAB1 print max of mx and cnt1 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 game = int vector of size n ;  $  TAB1 numOf0 = int with numOf0 = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 read game[i] ;  $  TAB2 if game[i] is 0 increment numOf0 ;  $  TAB1 if numOf0 is 0 or n ;  $  TAB2 print n ;  $  TAB1 last0 = int with last0 = n - 1 ;  $  TAB1 loop while last0 >= 0 and game[last0] is 1 decrement last0 ;  $  TAB1 numOf1 = int with numOf1 = n - 1 - last0 ;  $  TAB1 ans = int with ans = numOf0 + numOf1 ;  $  TAB1 for i = last0 to 0 inclusive decrementing i ;  $  TAB2 if game[i] is 1 ;  $  TAB3 increment numOf1 ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 set ans to max of ans, numOf0 + numOf1 ;  $  TAB3 decrement numOf0 ;  $  TAB1 print max of ans, numOf1 ;
TAB1 create integers n, res, one and zero, all except n with value 0 ;  $  TAB1 read from the input to n ;  $  TAB1 a is a new array of integers with n elements ;  $  TAB1 for integer i = 0 to n exclusive incrementing i ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is true ;  $  TAB3 set one to max of one and zero ;  $  TAB3 increment one by one ;  $  TAB2 else ;  $  TAB3 increment zero ;  $  TAB1 change the value of res to max of one and zero ;  $  TAB1 print res and "\n" to the standard output ;
TAB1 n,i,j=int, s,max=0, a and b=array of 105 int ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is 0 increment s ;  $  TAB2 b[i]=s ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if a[i] is 0 ;  $  TAB3 if 2*b[i]+n-1-i-s > max max=2*b[i]+n-1-i-s ;  $  TAB2 if a[i] is 1 ;  $  TAB3 if 2*b[i]+n-i-s > max max=2*b[i]+n-i-s ;  $  TAB1 print max ;
TAB1 x=long long ;  $  TAB1 read x ;  $  TAB1 if x is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create new long long variable a ;  $  TAB1 read user input to a ;  $  TAB1 if a is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 to stdout ;
TAB0 create long long int k, n, a[100000] ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare n as long long ;  $  TAB1 read n ;  $  TAB1 if n bitwise and 1 ;  $  TAB2 print 1, newline ;  $  TAB1 else ;  $  TAB2 print 2 and newline ;
TAB1 create long longs x and y ;  $  TAB1 read from the input to x ;  $  TAB1 assign x % 2 to y ;  $  TAB1 if y = 0 ;  $  TAB2 print 2 to the standard output ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 reverse s ;  $  TAB1 id s[0]=0, 2, 4, 6 or 8 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 and a newline ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n mod 2 = 1 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 2 ;
TAB1 declare new long long called n ;  $  TAB1 read n from the user input ;  $  TAB1 print 2 - n % 2 ;
TAB0 declare long long variables n, mid and f ;  $  TAB1 set decimal precision of the output to 30 and change notation to floating-point ;  $  TAB1 read standard input to n ;  $  TAB1 print 2 - n % 2 and '\n' to the standard output ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is 1 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 2 ;
TAB1 create new unsigned long long variable n ;  $  TAB1 read from the input to n ;  $  TAB1 print 2 if n is even and 1 if n is odd ;
TAB0 end statement ;  $  TAB0 declare constant long long INT64M = 0X3F3F3F3F3F3F3F3F ;  $  TAB0 declare constant integer INT32M = 0x3F3F3F3F ;  $  TAB0 declare constant integer mod = 1e9 + 7 ;  $  TAB1 declare n as long long ;  $  TAB1 read n ;  $  TAB1 if n bitwise and 1 ;  $  TAB2 print 1, newline ;  $  TAB1 else ;  $  TAB2 print 2, newline ;
TAB0 MAX = n, a[1005], sum = 0, m, cmp ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 and a newline ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is equal to 0 ;  $  TAB2 print 2 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 1 and newline ;
TAB1 n = long long int ;  $  TAB1 read n ;  $  TAB1 if n is uneven ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 2 ;
TAB0 v is a new vector of long long integers ;  $  TAB1 create new long long integer variable n ;  $  TAB1 read n from the input ;  $  TAB1 if n is even ;  $  TAB2 print 2 to the standard output ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create new long long variable called n ;  $  TAB1 read the value of n from the input ;  $  TAB1 if n modulo 2 is not 0 ;  $  TAB2 print "1" to the output ;  $  TAB1 else ;  $  TAB2 print "2" to stdout ;
TAB1 create new unsigned long long integer called n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 create constant integer inf with value 0x3f3f3f ;  $  TAB1 create new long long n ;  $  TAB1 read n and loop further ;  $  TAB2 if n is even ;  $  TAB3 print 2 ;  $  TAB2 else ;  $  TAB3 print 1 to the standard output ;
TAB1 a = long long ;  $  TAB1 read a ;  $  TAB1 if a is uneven print 1 else print 2 ;
TAB0 create constant int INF = 0x3f3f3f3f ;  $  TAB0 let long long integer mod = 10000000000LL ;  $  TAB0 declare cheng taking in long long integers a, b, and c and returning long long integer ;  $  TAB1 make long long int ret = 0 ;  $  TAB1 while b is truthy ;  $  TAB2 if b & 1 are truthy ;  $  TAB3 set ret to ret + a ;  $  TAB3 if ret is greater than or equal to c, set ret to ret - c ;  $  TAB2 set a to a + a ;  $  TAB2 if a is greater than or equal to c, set a to a - c ;  $  TAB2 move bits of b 1 place to right ;  $  TAB1 return ret ;  $  TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 make long long integer ans = cheng(n, n, mod) ;  $  TAB1 if ans modulo 2 is 0 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 create constant long long MAX = 1000 ;  $  TAB1 declare long long variable n ;  $  TAB1 read input to n ;  $  TAB1 if n is odd ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 2 to the output ;
TAB1 n=long long ;  $  TAB1 read n ;  $  TAB1 print 1 if n is odd else 2 ;
TAB0 create constant int MAX = 1e5 + 5 ;  $  TAB1 let long long n ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare long long n ;  $  TAB1 read n from the input ;  $  TAB1 print 2 - (n modulo 2) to the standard output ;
TAB1 n is a new long long variable ;  $  TAB1 declare new long long called a = 1 ;  $  TAB1 create new long long called b with value 2 ;  $  TAB1 read user input to n ;  $  TAB1 if n is even ;  $  TAB2 print b to the standard output ;  $  TAB1 else ;  $  TAB2 print a ;
TAB1 let n = long long ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n is odd ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 2 ;
TAB0 make long long integers a, b, c, e, and f ;  $  TAB1 read a ;  $  TAB1 if a modulo 2 is truthy ;  $  TAB2 print 1 ;  $  TAB1 otherwise do ;  $  TAB2 print 2 ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n and 1 different from 0 ;  $  TAB2 print 1\n ;  $  TAB1 else ;  $  TAB2 print 2\n ;
TAB1 create long long int n ;  $  TAB1 read n and while n is truthy ;  $  TAB2 if n modulo 2 is 1 ;  $  TAB3 print "1" ;  $  TAB2 else ;  $  TAB3 print "2" ;  $  TAB2 print new line ;
TAB1 n = unsigned long long ;  $  TAB1 read n ;  $  TAB1 if n is even then print 2 else print 1 ;
TAB0 declare constant integer maxn = 1e5 + 5 ;  $  TAB1 declare long long n as argument ;  $  TAB1 read n ;  $  TAB1 if n % 2 ;  $  TAB2 print "1", newline ;  $  TAB1 else ;  $  TAB2 print "2", newline ;
TAB1 declare n as long long ;  $  TAB1 read n ;  $  TAB1 if n % 2 is 0 ;  $  TAB2 print "2", newline ;  $  TAB1 else ;  $  TAB2 print "1', newline ;
TAB1 declare long long x ;  $  TAB1 read x ;  $  TAB1 if x % 2 is 0 ;  $  TAB2 print 2 and newline ;  $  TAB1 else ;  $  TAB2 print 1 and newline ;
TAB1 declare new long long n ;  $  TAB1 read n and keep looping ;  $  TAB2 if n is even ;  $  TAB3 print "2" to the otuput stream ;  $  TAB2 else ;  $  TAB3 print "1" ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 print 2 - (n % 2) ;
TAB1 a_i, b_i, n = long long ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 declare constant integer maxn = 1e5 + 10 ;  $  TAB0 declare constant integer maxm = 1e6 + 10 ;  $  TAB0 declare constant integer INF = 0x3f3f3f3f ;  $  TAB0 declare long longs casn, n, m, k ;  $  TAB0 declare long long array num size maxn ;  $  TAB0 declare cal with long long x as argument, returning lon glong ;  $  TAB1 declare long long ans = 1 ;  $  TAB1 for i = 1 to x inclusive, let ans be ans * i ;  $  TAB1 return ans from function ;  $  TAB1 read n ;  $  TAB1 print 1 + ( n % 2 is 0 ), newline ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let count be a vector of integers ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 read x ;  $  TAB2 increase count[x] by 1 ;  $  TAB1 print *max_element from beginning to end of count and endline ;
TAB0 let n, ans = 0, a[111], vis[100010] be long long ;  $  TAB0 in inline long long function read ;  $  TAB1 x = long long = 0 ;  $  TAB1 bool = 0 = f ;  $  TAB1 ch = char = get char ;  $  TAB1 for , until not ch is digit set ch to get char, f bit exclusive or (ch == '-') ;  $  TAB1 for , is digit of ch = false, set ch = get char; set x to (x << 3) + (x << 1) + (ch ^ 48) ;  $  TAB1 is f not 0 ? then return -x else return x ;  $  TAB1 n = read() ;  $  TAB1 for resgister int i = 1 to n inclusive, set a[i] to read, increment vis at a[i] ;  $  TAB1 for register int i = 1 to n inclusive ;  $  TAB2 if ans < vis at a[i] ;  $  TAB1 then set ans to vis at a[i] ;
TAB0 max_elemento is a integer function with vector of integers argument coins_array ;  $  TAB1 create integer max_element with value 0 ;  $  TAB1 for i from 0 to length of coins_array exclusive incrementing i ;  $  TAB2 if coins_array[i] is greater than max_element, set max_element to coins_array[i] ;  $  TAB1 return max_element ;  $  TAB1 create integer coins_nro ;  $  TAB1 create new integer variable coin_value ;  $  TAB1 create vector of integers coins_array with size 105 filled with 0 ;  $  TAB1 result is a new integer variable ;  $  TAB1 read variable coins_nro from the input ;  $  TAB1 in a for loop, change i from 0 to coins_nro exclusive incrementing i ;  $  TAB2 read from the input to coin_value ;  $  TAB2 increment coins_array[coin_value] by one ;  $  TAB1 assign the new value = max_elemento(coins_array) to result ;  $  TAB1 print result and '\n' ;
TAB0 declare integer array a size 10005 ;  $  TAB1 declare integers n, m, d = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read m ;  $  TAB2 increment a[m] ;  $  TAB1 for j = 0 to 10000 exclusive ;  $  TAB2 if a[j] is greater than d, let d be a[j] ;  $  TAB1 print d and newline ;
TAB1 create long long integer n ;  $  TAB1 read n ;  $  TAB1 make long long int array a of size and long long c = 0 ;  $  TAB1 let long long int array x of size 101 containing {0} ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment x[a[i]] ;  $  TAB1 display *max_element(x, x + 101) ;
TAB0 declare integer array a size 250, integers ans, sum = 1 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is 1 ;  $  TAB2 print "1" and newline ;  $  TAB1 for i = 0 to n inclusive, read a[i] ;  $  TAB1 sort from a + 1 to a + n + 1 ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if a[i] is a[i-1], increment sum ;  $  TAB2 let ans be maximum of ans and sum ;  $  TAB2 if a[i] is not a[i-1], let sum be 1 ;  $  TAB1 print ans and newline ;
TAB1 integer as n,a[1000],i,j ;  $  TAB1 create memset with pointer a, value of 0, and byte size of a ;  $  TAB1 read n ;  $  TAB1 for = 0 to less than n do the following ;  $  TAB2 read j ;  $  TAB2 add one to a[j] ;  $  TAB1 integer as m = -999 ;  $  TAB1 for = 0 to less than 1000 do the following ;  $  TAB2 if a[i] is greater than m then do the following m = a[i] ;  $  TAB1 output m ;
TAB0 let INF be a constant integer with INF = 0x3f3f3f3f ;  $  TAB0 let v be an integer array of size 105 ;  $  TAB1 let i, j, k be integers ;  $  TAB1 let n, m, x be integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read x and increase v[x] by 1 ;  $  TAB1 sort the values v and v + 101 ;  $  TAB1 print v[100] and endline ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 arr = array of integers of length n ;  $  TAB1 for i = 0 to n exclusive , read arr[i] ;  $  TAB1 count = array of integers of length 101 ;  $  TAB1 for i = 0 to 101 exclusive , count[i] is equal to 0 ;  $  TAB1 for i = 0 to n exclusive , increment count[arr[i]] by 1 ;  $  TAB1 the integer value of answer = 0 ;  $  TAB1 for i = 0 to 101 exclusive ;  $  TAB2 if count[i] is greater than answer , answer is equal to count[i] ;  $  TAB1 print answer and newline ;
TAB0 arr is a vector of integers ;  $  TAB1 n,x be integers ;  $  TAB1 read n ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 increase arr[x] by 1 ;  $  TAB1 print *max_element(arr.begin(), arr.end()) and endline ;
TAB0 declare cmp with integers a, b as arguments, returning boolean ;  $  TAB1 return a is greater than b ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integer array a size 200 = {0} ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare integer mid ;  $  TAB2 read mid ;  $  TAB2 increment a[mid] ;  $  TAB1 sort from a to a + 105 using cmp to compare ;  $  TAB1 print a[0] and newline ;
TAB0 integer as array a of size 10005 ;  $  TAB1 integer as n,m,b = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to less than or equal to n do the following ;  $  TAB2 read m ;  $  TAB2 add one to a[m] ;  $  TAB1 for i = 0 to less than or equal to 10000 do the following ;  $  TAB2 if a[i] is greater than b then b = a[i] ;  $  TAB1 output b ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 make long long vector coins ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create long long aux ;  $  TAB2 read aux ;  $  TAB2 append aux to coins ;  $  TAB1 sort coins ;  $  TAB1 create long long ints cont = 1 and resp = 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if coins[i] is equal to coins[i - 1] ;  $  TAB3 increment cont ;  $  TAB2 else do ;  $  TAB3 if cont is greater than resp, set resp to cont ;  $  TAB3 set cont to 1 ;  $  TAB1 if cont is greater than resp, set resp to cont ;  $  TAB1 display resp ;
TAB1 declare integers n, max = -1, cnt, integer array arr size 105 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let cnt be 0 ;  $  TAB2 if arr[i] is -5000000, end loop iteration ;  $  TAB2 declare integer tmp = arr[i] ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if tmp is arr[j] ;  $  TAB4 increment cnt ;  $  TAB4 let arr[j] be -5000000 ;  $  TAB2 if cnt is greater than or equal to max, let max be cnt ;  $  TAB1 print max, newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 make integer ma = 0 ;  $  TAB1 make integer array a of size 110 ;  $  TAB1 set all content of a to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make integer num ;  $  TAB2 read num ;  $  TAB2 add 1 to a[num] ;  $  TAB2 set ma to max of a[num] and ma ;  $  TAB1 print ma ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 create integer vector of v(101, 0) ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 integer as x ;  $  TAB2 read x ;  $  TAB2 add one to v[x] ;  $  TAB1 integer as MAX = value pointed to by max_element within v ;  $  TAB1 output MAX ;
TAB1 create long long ints n and i ;  $  TAB1 read n ;  $  TAB1 make long long array a of size n and long long max = 0 ;  $  TAB1 make map m of long long ints to long long ints ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment m[a[i]] ;  $  TAB2 if m[a[i]] is greater than max, set max to m[a[i]] ;  $  TAB1 print max ;
TAB1 n is a new integer ;  $  TAB1 loop, reading n from the input ;  $  TAB2 declare integer ans with value 0 ;  $  TAB2 let p be a map from integers to integers ;  $  TAB2 increment i in a loop from 0 to n exclusive ;  $  TAB3 new integer val ;  $  TAB3 read val ;  $  TAB3 increment p[val] ;  $  TAB3 assign the new value = max of p[val] and ans to ans ;  $  TAB2 print ans ;
TAB0 let cont be a long integer array ;  $  TAB1 n is a long integer ;  $  TAB1 read n ;  $  TAB1 for long integer i = 0 to n exclusive ;  $  TAB2 num is a long integer ;  $  TAB2 read num ;  $  TAB2 increase cont[num] by 1 ;  $  TAB1 maxi is a long integer 0 ;  $  TAB1 for long integer i = 1 to 100 inclusive, maxi = max(maxi, cont[i] ;  $  TAB1 print maxi and endline ;
TAB1 integer as n,i,j,maxx ;  $  TAB1 read n ;  $  TAB1 integer as a[n] ;  $  TAB1 integer as freq[101] = 0 ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 read array a[i] ;  $  TAB2 add one to freq[a[i]] ;  $  TAB1 do nothing ;  $  TAB1 set maxx to INT_MIN ;  $  TAB1 for i = 0 to less than 101 do the following ;  $  TAB2 if freq[i] is greater than or equal to maxx then do the following maxx = freq[i] ;  $  TAB1 output maxx ;
TAB1 n, m, c = int with m = 0 and c = 0 and arr = int array of size 101 ;  $  TAB1 read n ;  $  TAB1 read n values into arr ;  $  TAB1 sort arr from index 0 to n ;  $  TAB1 for i = 1 to n ;  $  TAB2 if arr[i - 1] is arr[i] ;  $  TAB3 increment c ;  $  TAB2 else ;  $  TAB3 set c to 0 ;  $  TAB2 set m to max of m, c ;  $  TAB1 if m is 0 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print m + 1 ;
TAB1 create integers n, i, t and max = 0 ;  $  TAB1 read user input to n ;  $  TAB1 f is a new vector of integers with size 101 filled with 0 ;  $  TAB1 start for loop from i = 0 to n exclusive incrementing i ;  $  TAB2 read standard input to t ;  $  TAB2 increment f[t] ;  $  TAB1 in a for loop, change i from 1 to 100 inclusive, changing max to maximum of f[i] and max on each iteration ;  $  TAB1 print max ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 make long long int array c of size n and int max = 1 ;  $  TAB1 for i = 0 to n exclusive, read c[i] ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 create long long cnt = 1 ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 if c[j] is equal to c[i], increment cnt ;  $  TAB2 if i is equal to 0, set max to cnt ;  $  TAB2 if cnt is greater than or equal to max, set max to cnt ;  $  TAB1 display max ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 create integer vector of coins 101, 0 ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 integer as value ;  $  TAB2 read value ;  $  TAB2 add one to coins[value] ;  $  TAB1 integer as minPockets = -1 ;  $  TAB1 for i = 0 to less than 101 then minPockets = maximum of minpockets or coins[i] ;  $  TAB1 output minPockets ;
TAB0 p1,p2,p3,p4,a,b=int ;  $  TAB1 read p1,p2,p3,p4,a,b ;  $  TAB1 ans=0 ;  $  TAB1 p=min(p1,p2) ;  $  TAB1 p=min(p,p3) ;  $  TAB1 p=min(p,p4) ;  $  TAB1 if b<p ;  $  TAB2 print b-a+1 ;  $  TAB1 if p-a>0 ans=p-a ;  $  TAB1 print ans ;
TAB0 declare integer array p size 4, integers a, b, ans ;  $  TAB1 for i = 0 to 4 exclusive, read p[i] ;  $  TAB1 read a, b ;  $  TAB1 let ans be b - a + 1 ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 for j = 0 to 4 exclusive ;  $  TAB3 if i is less than p[j], end loop iteration ;  $  TAB3 decrement ans ;  $  TAB3 end loop ;  $  TAB1 print ans and newline ;
TAB1 declare integers p1, p2, p3, p4, a and b ;  $  TAB1 read input to p1, p2, p3, p4, a and b ;  $  TAB1 declare integer variable with name sum = 0 ;  $  TAB1 for i from a to b inclusive ;  $  TAB2 if i % p1 = i and i % p2 = i and i % p3 = i and i % p4 = i, increment sum by one ;  $  TAB1 print sum ;
TAB1 p=array of 4 int ;  $  TAB1 for i=0 to 4 exclusive read p[i] ;  $  TAB1 esq,dir=int ;  $  TAB1 read esq,dir ;  $  TAB1 res=0 ;  $  TAB1 for i=esq to dir inclusive ;  $  TAB2 sort p ;  $  TAB2 cnt=0 ;  $  TAB2 do ;  $  TAB3 x=i ;  $  TAB3 for j=0 to 4 exclusive x=x modulo p[j] ;  $  TAB3 if x is i increment cnt ;  $  TAB2 while next_permutation(p, p+4) ;  $  TAB2 if cnt >= 7 increment res ;  $  TAB1 print res ;
TAB1 p1, p2, p3, p4 = int ;  $  TAB1 a, b = int ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 read p1 then p2 then p3 then p4 then a then b ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 if i mod p1 is i and i mod p2 is is and i mod p3 is i and i mod p4 is i increment ans ;  $  TAB1 print ans ;
TAB1 create long long ints p1, p2, p3, p4, a, b, and ans = 0 ;  $  TAB1 read p1, p2, p3, p4, a, and b ;  $  TAB1 for i = a to b ;  $  TAB2 if i % p1 is equal to i, i % p2 is equal to i, i % p3 is equal to i, and i % p4 is equal to i, increment ans ;  $  TAB1 print ans ;
TAB1 p1,p2,p3,p4,a,b,x=int, cnt=0 ;  $  TAB1 read p1,p2,p3,p4,a,b ;  $  TAB1 for i=a to b inclusive ;  $  TAB2 x = (((i modulo p1) modulo p2) modulo p3) modulo p4 ;  $  TAB2 if x is i increment cnt ;  $  TAB1 print cnt ;
TAB1 create integers a, b, c, d, x, y and s where s = 0 ;  $  TAB1 read standard input to a, b, c, d, x and y ;  $  TAB1 for i from x to y inclusive ;  $  TAB2 if i % a, i % b, i % c and i % d are all equal to i, increment s ;  $  TAB1 print s ;
TAB1 a, b, p, q, r, s = short ;  $  TAB1 read p then q then r then s then a then b ;  $  TAB1 ans = short with ans = 0 ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 if ((((i mod p) mod q) mod r) mod s) is i increment ans ;  $  TAB1 print ans ;
TAB1 create int p, a, b ;  $  TAB1 set min to 99999999 ;  $  TAB1 for i=1 to 4 inclusive ;  $  TAB2 read p ;  $  TAB2 if p < min, min=p ;  $  TAB1 read a and b ;  $  TAB1 if min >=a and <= b ;  $  TAB2 print min-a ;  $  TAB1 else if min < a ;  $  TAB2 print 0 ;  $  TAB1 else if min > b ;  $  TAB2 print b - a + 1 ;
TAB0 ifstream in( txt.in ) ;  $  TAB0 ofstream out( txt.out ) ;  $  TAB1 print fixed and setprecision(12) ;  $  TAB1 let mx be a long integer with mx = 2e9 ;  $  TAB1 for i = 1 to 4 inclusive ;  $  TAB2 let x be a long integer ;  $  TAB2 read x ;  $  TAB2 mx is equal to minimum of mx, x ;  $  TAB1 let a, b be long integers ;  $  TAB1 read a, b ;  $  TAB1 let cnt be a long integer with cnt = 0 ;  $  TAB1 for i = a to b inclusive , cnt is equal to cnt + i is less than mx ;  $  TAB1 print cnt and newline ;
TAB1 declare integers a, b, integer array p size 4 ;  $  TAB1 for i = 0 to 4 exclusive, read p[i] ;  $  TAB1 read a and b ;  $  TAB1 sort between p and p + 4 ;  $  TAB1 declare integers x, cnt = 0 ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 declare integer match = 0 ;  $  TAB2 start loop ;  $  TAB3 let x be i ;  $  TAB3 for i = 0 to 4 exclusive, let x be x % p[i] ;  $  TAB3 if x is i, increment match ;  $  TAB2 while ( re-arrange elements lexicographically p, p + 4 ) ;  $  TAB2 if match is greater than or equal to 7, increment cnt ;  $  TAB1 print cnt and '\n' ;
TAB1 declare ints a, b, c, d, x, y and cnt ;  $  TAB1 read a, b, c, d, x and y and keep looping ;  $  TAB2 change the value of cnt to 0 ;  $  TAB2 for i from x to y inclusive ;  $  TAB3 if i % a % b % c % d is equal to i, increment cnt by one ;  $  TAB2 print cnt ;
TAB1 let a, b, s be integers with s = 0 , p = array of integers of length 4 ;  $  TAB1 read p[0] , p[1] , p[2] , p[3] , a , b ;  $  TAB1 sort the values p, p + 4 ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 if i is less than p[0], increment s by 1 ;  $  TAB1 print s and newline ;
TAB1 declare integers p1, p2, p3, p4, a, b ;  $  TAB1 read p1, p2, p3, p4, a, b ;  $  TAB1 declare ans = 0 as integer ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 declare integer ans = ((((i % p1) % p2) % p3) % p4) ;  $  TAB2 if ans is i, increment ans ;  $  TAB1 print ans and newline ;
TAB1 create int x ;  $  TAB1 read x ;  $  TAB1 for i=0 to 3 exclusive ;  $  TAB2 create int y ;  $  TAB2 read y ;  $  TAB2 x = min of x and y ;  $  TAB1 create int a and b ;  $  TAB1 read a and b ;  $  TAB1 c=0 ;  $  TAB1 for i=a to b inclusive and to x, increment c ;  $  TAB1 print c ;
TAB1 a, b = int and s = int array of size 4 ;  $  TAB1 loop while reading s[0] then s[1] then s[2] then s[3] then a then b ;  $  TAB2 sort s ;  $  TAB2 if s[0] > b ;  $  TAB3 print b - a + 1 ;  $  TAB2 else if s[0] > a ;  $  TAB3 print s[0] - a ;  $  TAB2 else ;  $  TAB3 print "0" ;
TAB1 call precision of 7 on cout ;  $  TAB2 p1, p2, p3, p4, a, b = int ;  $  TAB2 read p1 then p2 then p3 then p4 then a then b ;  $  TAB2 minP = int with minP = mind of p1, min of p2, min of p3, p4 ;  $  TAB2 print max of 0, min of minP - a, b - a + 1 ;
TAB1 create int a, b, c, d ;  $  TAB1 create int p and m ;  $  TAB1 set p to 1000 and q to 31415 ;  $  TAB1 create int ans ;  $  TAB1 read a, b, c and d ;  $  TAB1 read n and m ;  $  TAB1 set p to min of p and a ;  $  TAB1 assign min of p and b to p ;  $  TAB1 set p = min of p and c ;  $  TAB1 p = min(p, d) ;  $  TAB1 if p > m ;  $  TAB2 set ans to m - n + 1 ;  $  TAB1 else ;  $  TAB2 set ans = p - n ;  $  TAB1 if ans <0, set ans equal to 0 ;  $  TAB1 print ans ;
TAB1 declare integers p1, p2, p3, p4 ;  $  TAB1 declare integers a, b ;  $  TAB1 read p1, p2, p3, p4, a, b ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 if i is (((i % p1) % p2) % p3) % p4, increment ans ;  $  TAB1 print ans and newline ;
TAB0 declare new array of integers p with size 4 ;  $  TAB0 let a and b be new integer variables ;  $  TAB0 create integer variable with name cnt ;  $  TAB1 read input to p[0], p[1], p[2], p[3], a and b ;  $  TAB1 start for loop from i = a to b inclusive incrementing i ;  $  TAB2 sort p ;  $  TAB2 create integer variable s with value 0 ;  $  TAB2 start the loop ;  $  TAB3 increment s if (((i % p[0]) % p[1]) % p[2]) % p[3] == i ;  $  TAB2 loop again while next_permutation(p, p + 4) is true ;  $  TAB2 if s >= 7 ;  $  TAB1 print cnt ;
TAB0 declare long longs p1, p2, p3, p4, a, b, ans = 0 ;  $  TAB0 declare inline read with no arguments, returning long long ;  $  TAB1 declare x = 0 as long long ;  $  TAB1 declare f = 0 as boolean ;  $  TAB1 declare ch = read character as character ;  $  TAB1 for ch is not digit, setting ch to read character, let f be f xor ( ch is '0' ) ;  $  TAB1 for ch is digit, setting ch to read character, let x be ( x bitshift left 3 ) + ( x bitshift left 1 ) + ( ch bitwise xor 48 ) ;  $  TAB1 return -x if f is true, else x ;  $  TAB1 let p1 = result of run read, p2 = result of run read, p3 = result of run read, p4 = result of run read ;  $  TAB1 let a be result of run read, let b be result of run read ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 declare long longs z = i % p1, zz = i % p2, zzz = i % p3, zzzz = i % p4 ;  $  TAB2 if zz is zzz and zz is z and zz is zzzz and z is i, increment ans ;  $  TAB1 print ans and newline ;
TAB1 p1,p2,p3,p4,a,b=int, p=0 ;  $  TAB1 read p1,p2,p3,p4,a,b ;  $  TAB1 for i=a to b inclusive ;  $  TAB2 if i modulo p1 modulo p2 modulo p3 modulo p4 is i increment p ;  $  TAB1 print p ;
TAB0 let minn be a integer function which accepts integers a, b, c, d ;  $  TAB1 a is equal to minimum of a and b ;  $  TAB1 c is equal to minimum of c and d ;  $  TAB1 return the value minimum of a and c ;  $  TAB1 let p1, p2, p3, p4, a, b be integers ;  $  TAB1 while read p1, p2, p3, p4, a, b ;  $  TAB2 if p1 <= a or p2 <= a or p3 <= a or p4 <= a ;  $  TAB3 print 0 and newline ;  $  TAB3 proceed to next ;  $  TAB2 let the value of integer p = minn(p1, p2, p3, p4) ;  $  TAB2 if p is greater than b ;  $  TAB3 print b - a + 1 and newline ;  $  TAB3 proceed to next ;  $  TAB2 print p - a and newline ;
TAB0 a, b = integer, p = integer array of size 5 ;  $  TAB0 ans = integer = 0 ;  $  TAB1 read p[1], p[2], p[3], p[4], a, b ;  $  TAB1 Min = integer = the lowest value between p[1], p[2], p[3], p[4] ;  $  TAB1 if a < Min ;  $  TAB2 ans = ans + (Min - a) ;  $  TAB2 if b >= Min ;  $  TAB3 print ans ;  $  TAB2 ans = b = a + 1 ;  $  TAB1 print ans ;
TAB0 create constant double pi = 3.14159265358979323846 ;  $  TAB1 create int array p of size 4 ;  $  TAB1 create integers a and b ;  $  TAB1 read p[0], p[1], p[2], p[3], a, and b ;  $  TAB1 let ints i, j, k, l, and m ;  $  TAB1 create integer ctr = 0 ;  $  TAB1 make integer ans = 0 ;  $  TAB1 for i = a to b + 1 exclusive ;  $  TAB2 for j = 0 to 4 exclusive ;  $  TAB3 for k = 0 to 4 exclusive ;  $  TAB4 if k is equal to j, continue to next loop ;  $  TAB4 if l = 0 to 4 exclusive ;  $  TAB5 if i is equal to j or l is equal to k, continue to next loop iteration ;  $  TAB5 for m = 0 to 4 exclusive ;  $  TAB6 if m is 1 or m is j or m is k, continue loop ;  $  TAB6 if i is equal to (((i % p[j]) % p[k]) % p[l]) % p[m], increment ctr ;  $  TAB2 if ctr is greater than or equal to 7, increment ans ;  $  TAB2 set ctr to 0 ;  $  TAB1 print ans ;
TAB0 arrA be integer array with 100005 elements ;  $  TAB0 arrB be integer array with 100005 elements ;  $  TAB0 nA, nB, k, m be integer ;  $  TAB1 read nA, nB ;  $  TAB1 read k, m ;  $  TAB1 for integer i = 0 to nA exclusive, read arrA[i] ;  $  TAB1 for integer i = 0 to nA exclusive, read arrB[i] ;  $  TAB1 if arrA[k - 1] is less than arrB[nB - m] ;  $  TAB2 print YES and newline ;  $  TAB1 else ;  $  TAB2 print NO and newline ;
TAB1 let n1, n2, k, m be integers ;  $  TAB1 read n1, n2, k, m ;  $  TAB1 decrease k by 1 ;  $  TAB1 decrease m by 1 ;  $  TAB1 v1, v2 are ineger vectors ;  $  TAB1 for integer i = 1 to n1 inclusive, read v1[i] ;  $  TAB1 for integer i = 1 to n2 inclusive, read v2[i] ;  $  TAB1 sort v1 from begin to end ;  $  TAB1 sort v2 from begin to end ;  $  TAB1 if v1[k] is less than v2[v2.size() - m - 1] ;  $  TAB2 print YES and endline ;  $  TAB1 else ;  $  TAB2 print NO and newline ;
TAB0 s=100002 ;  $  TAB0 a and b=array of s int ;  $  TAB1 n1,n2=int ;  $  TAB1 read n1,n2 ;  $  TAB1 k,m=int ;  $  TAB1 read k,m ;  $  TAB1 for i=0 to n1 exclusive read a[i] ;  $  TAB1 for i=0 to n2 exclusive read b[i] ;  $  TAB1 if a[k-1] < b[n2-m] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 long long integer as a,b,m,n ;  $  TAB1 read a,b ;  $  TAB1 read m,n ;  $  TAB1 integer as array ar size a + 5 and array br with size of b + 5 ;  $  TAB1 for i = 0 to less than a do the following ;  $  TAB1 for j = 0 to less than b do the following ;  $  TAB1 if ar[m - 1] is less than br[b - n] then do the following ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB1 a, b, n, k, c, p, i = int with c = 0 and p = 0 and i = 0 ;  $  TAB1 read a then b then n then k ;  $  TAB1 A = int array of size a and B = int array of size b ;  $  TAB1 read a values into A ;  $  TAB1 read b values into B ;  $  TAB1 for j = b - 1 to b - 1 - k decrementing j ;  $  TAB2 if A[n - 1] < B[j] ;  $  TAB3 increment c ;  $  TAB2 else ;  $  TAB3 goto jump ;  $  TAB0 goto label jump ;  $  TAB1 if c is k ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 na=int64_t ;  $  TAB0 nb=int64_t ;  $  TAB0 k=int64_t ;  $  TAB0 m=int64_t ;  $  TAB0 i=0 ;  $  TAB0 a=int64_t ;  $  TAB1 read na ;  $  TAB1 read nb ;  $  TAB1 read k ;  $  TAB1 read m ;  $  TAB1 an=array of na int64_t ;  $  TAB1 bn=array of nb int64_t ;  $  TAB1 while i<na ;  $  TAB2 read a ;  $  TAB2 an[i]=a ;  $  TAB2 increment i ;  $  TAB1 end of while ;  $  TAB1 i=0 ;  $  TAB1 while i<nb ;  $  TAB2 read a ;  $  TAB2 bn[i]=a ;  $  TAB2 increment i ;  $  TAB1 sort an ;  $  TAB1 sort bn ;  $  TAB1 if an[k-1]<bn[nb-m] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;  $  TAB1 end if ;
TAB1 a,b,k,m=int ;  $  TAB1 read a,b,k,m ;  $  TAB1 arr1=array of a+5 int,arr2=array of b+5 int ;  $  TAB1 for i=0 to a exclusive read arr1[i] ;  $  TAB1 sort first a items of arr1 ;  $  TAB1 for i=0 to b exclusive read arr2[i] ;  $  TAB1 sort first b items of arr2 ;  $  TAB1 if arr1[k-1]<arr2[b-m] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 let n, m, a, b be integers , arr = array of integers of length 100009 , brr = array of integers of length 100009 ;  $  TAB1 read n, m, a, b ;  $  TAB1 for i = 1 to n inclusive , read arr[i] ;  $  TAB1 for i = 1 to m inclusive , read brr[i] ;  $  TAB1 if arr[a] is less than brr[m - b + 1] ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB1 na,nb,ka,kb=int ;  $  TAB1 read na,nb,ka,kb ;  $  TAB1 a=vector of na int, b=vector of nb int ;  $  TAB1 for i=0 to na exclusive read a[i] ;  $  TAB1 for i=0 to nb exclusive read b[i] ;  $  TAB1 k=0 ;  $  TAB1 for i=nb-1 down to 0 inclusive ;  $  TAB2 if a[ka-1]<b[i] ;  $  TAB3 increment k ;  $  TAB2 else if k<kb and a[ka-1]>=b[i] ;  $  TAB3 print NO ;  $  TAB1 print YES ;
TAB1 let a and b be integers ;  $  TAB1 read in a and b ;  $  TAB1 let n and m be integers ;  $  TAB1 read in n and m ;  $  TAB1 let mx and mn be integers ;  $  TAB1 iterate for a times ;  $  TAB2 let x be an integer ;  $  TAB2 read in x ;  $  TAB2 if i + 1 is equal to n, set mx to x ;  $  TAB1 iterate for b times ;  $  TAB2 let x be an integer ;  $  TAB2 read in x ;  $  TAB2 if i is equal to b - m, set mn to x ;  $  TAB1 if mx is less than mn ;  $  TAB2 print YES ;  $  TAB1 or else ;  $  TAB2 print NO ;
TAB1 let line1, line2, first, second, i, j be long integers ;  $  TAB1 read line1, line2 ;  $  TAB1 read first, second ;  $  TAB1 stud1 = array of integers of length line1 , stud2 = array of integers of length line2 ;  $  TAB1 for i = 0 to line1 exclusive , read stud1[i] ;  $  TAB1 for i = 0 to line2 exclusive , read stud2[i] ;  $  TAB1 sort the values of stud1 and stud1 + line1 ;  $  TAB1 sort the values of stud2 and stud2 + line2 ;  $  TAB1 the integer value of mx = stud2[line2 - (second)] ;  $  TAB1 let tot , y be integers with tot = 0, y = 0 ;  $  TAB1 for i = 0 to line1 exclusive ;  $  TAB2 if stud1[i] is less than mx , increment tot by 1 ;  $  TAB2 if tot equals first ;  $  TAB3 increment y by 1 ;  $  TAB3 stop ;  $  TAB2 if stud1[i] is greater than mx , stop ;  $  TAB1 if y is true ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 declare integer vector a ;  $  TAB0 declare integer vector b ;  $  TAB1 declare integers na, nb, counta = 0, countb = 0 ;  $  TAB1 read na, nb ;  $  TAB1 declare integers k, m, A, B ;  $  TAB1 read k, m ;  $  TAB1 for i = 0 to na exclusive ;  $  TAB2 read A ;  $  TAB2 add A to end of a ;  $  TAB1 for i = 0 to nb exclusive ;  $  TAB2 read B ;  $  TAB2 add B to end of b ;  $  TAB1 sort from beginning of a to end of a ;  $  TAB1 sort from reverse beginning of b to reverse end of b ;  $  TAB1 if a[k-1] is less than b[m-1] ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 declare strings n1, n2, k, m ;  $  TAB1 declare integers v1, v2, x ;  $  TAB1 read n1, n2 ;  $  TAB1 read k, m ;  $  TAB1 for i = 0 to n1 exclusive ;  $  TAB2 read x ;  $  TAB2 if i is k - 1, let v1 be k ;  $  TAB1 for i = 0 to n2 exclusive ;  $  TAB2 read x ;  $  TAB2 if i is n2 - m, let v2 be x ;  $  TAB1 if v1 is less than v2 ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 let n1, n2 be long integers ;  $  TAB0 a is a long integer array of size 100007 ;  $  TAB0 b is a long integer array of size 100007 ;  $  TAB0 let k, m be long integers ;  $  TAB1 read n1, n2 ;  $  TAB1 read k, m ;  $  TAB1 for long integer i = 0 to n1-1, read a[i] ;  $  TAB1 for long integer i = 0 to n2-1, read b[i] ;  $  TAB1 sort the values a, a + n1 ;  $  TAB1 sort the values b, b + n2, greater<long long int>() ;  $  TAB1 if a[k - 1] is less than b[m - 1] ;  $  TAB2 print YES ;  $  TAB3 newline ;  $  TAB1 else ;  $  TAB2 print NO ;  $  TAB3 newline ;
TAB0 let r1, r2 be integer array of size 100001 ;  $  TAB1 let a, b, c, d, e, f, g, h be integers ;  $  TAB1 let v be a vector of integers ;  $  TAB1 while read a, b ;  $  TAB2 read c, d ;  $  TAB2 for e= 1 to a inclusive, read r1[e] ;  $  TAB2 f equals 0 ;  $  TAB2 for e= 1 to b inclusive ;  $  TAB3 read r2[e] ;  $  TAB3 if r2[e] > r1[c], increase f by 1 ;  $  TAB2 if f is greater than or equal to d ;  $  TAB3 print YES and newline ;  $  TAB2 else ;  $  TAB3 print NO and newline ;
TAB1 a, b be integer arrays of size 100040 ;  $  TAB1 let na, nb be integers ;  $  TAB1 let x1, x2, y1, y2 be integers ;  $  TAB1 let i, k, j, m be integers ;  $  TAB1 s is a 2d character array ;  $  TAB1 read na, nb ;  $  TAB1 read k, m ;  $  TAB1 for i = 0 to na exclusive , read a[i] ;  $  TAB1 for j = 0 to nb exclusive , read b[j] ;  $  TAB1 sort from a to a + na ;  $  TAB1 sort from b to b + nb ;  $  TAB1 for i = 0 to nb exclusive ;  $  TAB2 if b[i] is greater than a[k - 1], stop ;  $  TAB1 if i + m is less than or equal to nb ;  $  TAB2 print YES and newline ;  $  TAB1 else ;  $  TAB2 print NO and newline ;
TAB1 create integer vector of arr1, arr2 ;  $  TAB1 integer as a,b,k,m ;  $  TAB1 read a,b,k,m ;  $  TAB1 if k is greater than a or m is greater than b then do the following ;  $  TAB2 output NO ;  $  TAB1 for i = 0 to less than a do the following ;  $  TAB2 integer as inp ;  $  TAB2 read inp ;  $  TAB2 add new element inp to end of vector arr1 ;  $  TAB1 for i = 0 to less than b do the following ;  $  TAB2 integer as inp ;  $  TAB2 read inp ;  $  TAB2 add new element inp to end of vector arr2 ;  $  TAB1 if arr1[k - 1] is less than arr2[b - m] then do the following ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 declare constant integer MAX = 100001 ;  $  TAB0 declare long long arrays An size MAX, Bn size MAX ;  $  TAB1 declare integers n, m, a, b ;  $  TAB1 read n, m, a, b ;  $  TAB1 for i = 1 to n inclusive, read An[i] ;  $  TAB1 for i = 1 to m inclusive, read Bn[i] ;  $  TAB1 sort from An + 1 to An + n + 1 ;  $  TAB1 sort from Bn + 1 to Bn + m + 1 ;  $  TAB1 if An[a] is less than Bn[m-b+1] ;  $  TAB2 print "YES" and newline ;  $  TAB1 else ;  $  TAB2 print "NO", newline ;
TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 k,m=int ;  $  TAB1 read k,m ;  $  TAB1 ar1=array of a int ;  $  TAB1 ar2=array of b int ;  $  TAB1 for i=0 to a exclusive read ar1[i] ;  $  TAB1 for i=0 to b exclusive read ar2[i] ;  $  TAB1 if ar1[k-1]<ar2[b-m] and k<=a and m<=b ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 define integers a, b, c and d ;  $  TAB1 read user input to a and b ;  $  TAB1 if a is less than b ;  $  TAB2 assign a to c ;  $  TAB2 change the value of d to (b - a) / 2 ;  $  TAB2 print c, ' ' and d to the standard output ;  $  TAB1 else ;  $  TAB2 change c to b ;  $  TAB2 set the value of d to (a - b) / 2 ;  $  TAB2 print c, ' ' and d to the output ;
TAB0 a,b,c,d=int ;  $  TAB1 read a,b ;  $  TAB1 d=min(a,b) ;  $  TAB1 c=max(a,b)-d ;  $  TAB1 if c is odd, change sign of c ;  $  TAB1 print d, space, c/2 ;
TAB1 declare integers a = 0, b = 0 ;  $  TAB1 declare integer counter_moda = 0, counter_utility = 0 ;  $  TAB1 read a and b ;  $  TAB1 while a is greater than 0 and b is greater than 0 ;  $  TAB2 decrement a ;  $  TAB2 decrement b ;  $  TAB2 increment counter_moda ;  $  TAB1 while a is greater than or equal to 2 or b is greater than or equal to 2 ;  $  TAB2 increment counter_utility ;  $  TAB2 if a is greater than b ;  $  TAB3 decrement a by 2 ;  $  TAB2 else ;  $  TAB3 decrement b by 2 ;  $  TAB1 print counter_moda, " ", counter_utility, newline ;
TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 if a>b swap a and b ;  $  TAB1 print a, space, (b-a)/2 ;
TAB1 declare integers a, b ;  $  TAB1 read a, b ;  $  TAB1 declare m = minimum of a and b as integer ;  $  TAB1 print m, ' ' ;  $  TAB1 decrement a by m ;  $  TAB1 decrement b by m ;  $  TAB1 print a/ 2 + b / 2, newline ;
TAB1 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 the integer value of r1 = minimum of a and b ;  $  TAB1 the integer value of r2 = (max(a, b) - min(a, b)) / 2 ;  $  TAB1 print r1 and space and r2 and newline ;
TAB1 declare integers a, b ;  $  TAB1 read a, b ;  $  TAB1 declare integer MIN = minimum of a and b ;  $  TAB1 declare integer MAX = maximum of a and b ;  $  TAB1 print MIN and ' ' and (MAX-MIN) / 2 and newline ;
TAB1 let a, b, ans be integers with ans = 0 ;  $  TAB1 read a, b ;  $  TAB1 ans is equal to mimimum of a, b ;  $  TAB1 print ans and space ;  $  TAB1 ans equals max(a, b) - ans) >> 1 ;  $  TAB1 print ans and endline ;
TAB1 a,b=int ;  $  TAB1 while read a,b print min(a,b),space,(max(a-b)-min(a,b))/2 ;
TAB0 declare long long n, a, b, res ;  $  TAB0 declare string s ;  $  TAB0 declare long long array arr size 100005 ;  $  TAB0 declare long long array arr1 size 100005 ;  $  TAB1 read a, b ;  $  TAB1 print minimum of ( a and b ), " ", absolute value of ( a - b ) / 2 ;  $  TAB1 print "\n" ;
TAB0 declare integer variables a, b and x ;  $  TAB1 read variables a and b from the input ;  $  TAB1 assign the new value = min of a and b to x ;  $  TAB1 print x and " " ;  $  TAB1 decrease a by x ;  $  TAB1 change b to b - x ;  $  TAB1 print b / 2 if a = 0, or a / 2 if a is not 0 ;  $  TAB1 print "\n" ;
TAB1 declare integers n, m ;  $  TAB1 read n and m ;  $  TAB1 declare integer a = minimum of n and m ;  $  TAB1 declare integer b = ( maximum of ( n and m ) - a ) / 2 ;  $  TAB1 print a and " " and b and newline ;
TAB1 a, b = int ;  $  TAB1 read a, b ;  $  TAB1 ds, ss, k = int with ds = 0, ss = 0, k = 0 ;  $  TAB1 if (a > b) ;  $  TAB2 ds = b ;  $  TAB2 k = a - b ;  $  TAB2 ss = k / 2 ;  $  TAB1 else if (a < b) ;  $  TAB2 ds = a ;  $  TAB2 k = b - a ;  $  TAB2 ss = k / 2 ;  $  TAB1 else ;  $  TAB2 ds = a ;  $  TAB2 ss = 0 ;  $  TAB1 print ds," ",ss ;
TAB1 let a, b be integers ;  $  TAB1 read a , b ;  $  TAB1 if a equals b ;  $  TAB2 print a and space ;  $  TAB3 print 0 and newline ;  $  TAB1 else if a is greater than b ;  $  TAB2 print b and space and (a - b) / 2 and newline ;  $  TAB1 else do the following ;  $  TAB2 print a and space and (b - a) / 2 and newline ;
TAB1 declare integer variables a and b ;  $  TAB1 read input to a and b ;  $  TAB1 prazn is a new integer with value min of a and b ;  $  TAB1 create new integer podin = ((max of a and b) - prazn) / 2 ;  $  TAB1 print prazn, " " and podin to the standard output ;
TAB1 declare ints r and b ;  $  TAB1 read r and b from the user input ;  $  TAB1 if r is less than b ;  $  TAB2 print r, " " and (b - r) / 2 ;  $  TAB1 else ;  $  TAB2 print b, " " and (r - b) / 2 ;
TAB1 let n, m, i and k be integers ;  $  TAB1 while reading in n and m ;  $  TAB2 if n is less than m set i to n, otherwise set i to m ;  $  TAB2 set k to abs(n - m) / 2 ;  $  TAB2 print i, ' ', and k ;
TAB1 let a, b, count1 , count2 be integers with count1 = 0, count2 = 0 ;  $  TAB1 read a , b ;  $  TAB1 for integer i = 0 , the condition is always true , increment i by 1 ;  $  TAB2 if (a equals 0 and b equals 1) or (a equals 1 and b equals 0) or (a equals 0 and b equals 0) , stop ;  $  TAB2 decrement a by 1 ;  $  TAB2 decrement b by 1 ;  $  TAB2 increment count1 by 1 ;  $  TAB2 if a equals 0 and b is greater than 1 ;  $  TAB3 while b is not equal to 0 ;  $  TAB4 decrement b by 2 ;  $  TAB4 increment count2 by 1 ;  $  TAB4 if b is less than 0 or b equals 1 , stop ;  $  TAB3 stop ;  $  TAB2 if a is greater than 1 and b equals 0 ;  $  TAB3 while a is not equal to 0 ;  $  TAB4 decrement a by 2 ;  $  TAB4 increment count2 by 1 ;  $  TAB4 if a is less than 0 or a equals 1 , stop ;  $  TAB3 stop ;  $  TAB1 print count1 and space and count2 and newline ;
TAB1 let n, m be integers ;  $  TAB1 read n and m ;  $  TAB1 print min(n, m) and space and (max(n, m) - min(n, m)) / 2 and newline ;
TAB1 r,b=int ;  $  TAB1 p,q=int ;  $  TAB1 read r,b ;  $  TAB1 p=min(r,b) ;  $  TAB1 q=abs(r-b)/2 ;  $  TAB1 print p, space, q ;
TAB0 function prime with int argument n that returns bool ;  $  TAB1 declare integer c with value 0 ;  $  TAB1 in a for loop, change i from 1 to n exclusive incrementing i ;  $  TAB2 increment c if n modulo i is 0 ;  $  TAB1 if c is equal to 1 ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB1 create ints a, b, a2, b2, a1 and b1 with a1 and b1 = 0 ;  $  TAB1 read standard input to a and b ;  $  TAB1 if a is greater than b ;  $  TAB2 set a2 to a ;  $  TAB2 for i = 0 to a2 exclusive ;  $  TAB3 if b != 0 ;  $  TAB4 increment a1 by one ;  $  TAB4 decrement b ;  $  TAB4 decrement a by one ;  $  TAB3 if b is equal to 0, set the value of b1 to a / 2 ;  $  TAB1 else if a is less than b ;  $  TAB2 change b2 to b ;  $  TAB2 for i from 0 to b2 exclusive incrementing i ;  $  TAB3 if a != 0 ;  $  TAB4 increment a1 by one ;  $  TAB4 decrement b ;  $  TAB4 decrement a ;  $  TAB3 if a is equal to 0, set the value of b1 to b / 2 ;  $  TAB1 else ;  $  TAB2 set a1 to (a + b) / 2 ;  $  TAB1 print a1, " " and b1 to the standard output ;
TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 mn=min(a,b), mx=max(a,b) ;  $  TAB1 print mn, space, (mx-mn)/2 ;
TAB1 let a , b be integers ;  $  TAB1 read a , b ;  $  TAB1 print min(a, b) and space and (max(a, b) - min(a, b)) / 2 and newline ;
TAB0 INF=3f3f3f3f in exadecimal ;  $  TAB0 mod = 1000000007 ;  $  TAB0 EPS=0.0000000001 ;  $  TAB0 PI=2*acos(0) ;  $  TAB0 maxn=101666 ;  $  TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 c=min(a,b) ;  $  TAB1 print c, space ;  $  TAB1 subtract c from a and from b ;  $  TAB1 if a is 0 ;  $  TAB2 print b/2 ;  $  TAB1 else ;  $  TAB2 print a/2 ;
TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 ans1 and ans2=int ;  $  TAB1 ans1=min(a,b) ;  $  TAB1 ans2=max(a,b) ;  $  TAB1 subtract ans1 from ans2 ;  $  TAB1 divide ans2 by 2 ;  $  TAB1 print ans1, space, ans2 ;
TAB1 declare integers a, b ;  $  TAB1 while read a, b ;  $  TAB2 declare integer ans1 = minimum of a and b ;  $  TAB2 declare integer k = maximum of a and b ;  $  TAB2 declare integer ans2 = ( k - ans1 ) / 2 ;  $  TAB2 print ans1 and " " ans2 and newline ;
TAB1 declare integers a, b, x, y, c = 0 ;  $  TAB1 read a, b ;  $  TAB1 let x be absolute value of ( a - b ) ;  $  TAB1 print minimum of ( a and b ), " ", x / 2, newline ;
TAB0 declare integers a, b ;  $  TAB1 read a, b ;  $  TAB1 print minimum of a and b, " ", ( maximum of ( a and b ) - minimum of ( a and b ) ) / 2, newline ;
TAB0 declare integer dx = {1, 0, -1, 0} ;  $  TAB0 declare integer dy = {0, -1, 0, 1} ;  $  TAB1 declare long longs a, b ;  $  TAB1 read a, b ;  $  TAB1 declare long longs Min, s ;  $  TAB1 if a is greater than b ;  $  TAB2 let Min be minimum of a and b ;  $  TAB2 let s be ( a - Min ) / 2 ;  $  TAB2 print Min and " " and s and newline ;  $  TAB1 else ;  $  TAB2 let Min be minimum of a and b ;  $  TAB2 let s be ( b - Min ) / 2 ;  $  TAB2 print Min and " " and s and newline ;
TAB1 a, b = int ;  $  TAB1 read a then b ;  $  TAB1 if a < b swap a and b ;  $  TAB1 print b and a - b ;
TAB1 a, b, max, min, ans be integers ;  $  TAB1 read a, b ;  $  TAB1 if a is greater than b ;  $  TAB2 max equals a ;  $  TAB2 min equals b ;  $  TAB1 else ;  $  TAB2 max equals b ;  $  TAB2 min equals a ;  $  TAB1 ans equals (max - min) / 2 ;  $  TAB1 print min space ans and endline ;
TAB0 create long long ints n, m, a and b ;  $  TAB1 read n, m, a and b ;  $  TAB1 declare long long int variable _s = 0 ;  $  TAB1 if n % m is not 0 ;  $  TAB2 create long long int x = n / m * m + m ;  $  TAB2 declare long long int variable y = x - m ;  $  TAB2 change _s to min of (x - n) * a and (n - y) * b ;  $  TAB1 print _s and "\n" ;
TAB1 n, m, a, b = long long ;  $  TAB1 read n then m then a then b ;  $  TAB1 if n is a multiple of m ;  $  TAB2 print 0 ;  $  TAB1 else if n is greater than m ;  $  TAB2 res = long long ;  $  TAB2 if n / m equals 1 ;  $  TAB3 set res to 2 ;  $  TAB2 else ;  $  TAB3 set res to n / m + 1 ;  $  TAB2 print min of (n - n / m * m) * b and (res * m - n) * a ;  $  TAB1 else ;  $  TAB2 print min of n * b and (m - n) * a ;
TAB1 create long longs a, b, n, m and ans ;  $  TAB1 read n, m, a and b ;  $  TAB1 if n % m is 0 ;  $  TAB2 assign 0 to ans ;  $  TAB1 else if n is less than m ;  $  TAB2 assign min(n * b, (m - n) * a) to ans ;  $  TAB1 else ;  $  TAB2 declare long longs cnt1 and cnt2 ;  $  TAB2 set cnt1 to n modulo m ;  $  TAB2 set cnt2 to n / m + 1 ;  $  TAB2 assign min((cnt2 * m - n) * a, cnt1 * b) to ans ;  $  TAB1 print ans ;
TAB0 S, T = string ;  $  TAB0 M,A,B,sum,x,y,K,ans,val,L,a = long long integer ;  $  TAB0 create character variable C ;  $  TAB1 read N,M,A,B ;  $  TAB1 set x to ((N - 1) / M + 1) * M ;  $  TAB1 set y to N / M * M ;  $  TAB1 output min((x - N) * A, (N - y) * B) ;
TAB0 lim = const int with lim = 2e5 ;  $  TAB0 inp = int array of size lim + 3 ;  $  TAB1 n, m, a, b = long long ;  $  TAB1 read n then m then a then b ;  $  TAB1 ans = long long with ans = min of (n mod m) * b and (m - (n mod m)) * a ;  $  TAB1 print ans ;
TAB0 declare long longs n, m, a and b ;  $  TAB1 read n, m, a and b and loop further ;  $  TAB2 declare long long tmp = n / m ;  $  TAB2 declare long long ans = 1e15 ;  $  TAB2 set ans to min of ans and (n - tmp * m) * b ;  $  TAB2 set ans to min of ans and (tmp + 1) * m - n) * a ;  $  TAB2 print ans ;
TAB1 n, m = long long integers ;  $  TAB1 integers = a,b ;  $  TAB1 read n,m,a,b ;  $  TAB1 set long long x to (n - n / m * m) * b, y =((n / m + 1) * m - n) * a ;  $  TAB1 if x is greater than y then do ;  $  TAB2 output y ;  $  TAB1 else ;  $  TAB2 output x ;
TAB0 declare const double pi = acos(-1) ;  $  TAB0 declare const double EPS = 1e-6 ;  $  TAB0 declare const int INF = 1e9 + 40 ;  $  TAB0 create const long long INF64 = 1e18 + 40 ;  $  TAB0 create const double INFd = 1e9 + 40.0 ;  $  TAB0 declare const long long MOD = (int)1e18 + 7 ;  $  TAB0 declare const long long MODf = 998244353 ;  $  TAB0 declare const int N = 1000 * 10 + 15 ;  $  TAB0 integer function solve ;  $  TAB1 declare long longs n, m, a and b ;  $  TAB1 read n, m, a and b ;  $  TAB1 print min of n % m * b and (m - n % m) * a; print '\n' ;  $  TAB1 call function solve ;
TAB1 define integers n, m, a, b ;  $  TAB1 define ints dem, bui, and tm ;  $  TAB1 read n, m, a, and b ;  $  TAB1 set tm to n / m ;  $  TAB1 assign (n - tm m) b to dem ;  $  TAB1 set bui to ((tm + 1) m - n) a ;  $  TAB1 print min(dem, bui) and a newline ;
TAB0 m, n, a, b = integers ;  $  TAB1 Read m, n, a, b ;  $  TAB1 if n modulo m is 0 ;  $  TAB2 print 0 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print minimum value of (m * (n / m + 1) - n) * a and n % m * b and a new line ;
TAB1 i, j, k, m, n, t, a, b =integers ;  $  TAB1 Read n, m, a, b ;  $  TAB1 if n modulo m is 0 ;  $  TAB2 print 0 and a new line ;  $  TAB1 set k to n / m ;  $  TAB1 set i to n - k * m ;  $  TAB1 set j to (k + 1) * m - n ;  $  TAB1 print minimum value of a * j and b * i and a new line ;
TAB1 create long long int n, m a and b ;  $  TAB1 print n, m, a and b ;  $  TAB1 let sum, min, ans be long long int ;  $  TAB1 if n mod m = 0 ;  $  TAB2 set min = 0 ;  $  TAB1 else ;  $  TAB3 sum = a * (((n / m + 1) * m) - n) ;  $  TAB3 assign sum to min ;  $  TAB3 set ans = b * (n - ((n / m) * m)) ;  $  TAB3 if ans less than min, min = ans ;  $  TAB1 print min ;
TAB0 create constant long long mod with mod = 1e9+7 ;  $  TAB0 create constant integer MAX with MAX = 1e6+7 ;  $  TAB0 create long longs n, d, a, b ;  $  TAB1 read n read d read a read b ;  $  TAB1 create long long ans with ans = ( n % d ) * b ;  $  TAB1 create long long r with r = ( n / d + 1 ) * d ;  $  TAB1 set ans to minimum of ( ans and ( r - n ) * a ) ;  $  TAB1 print ans print "\n" ;
TAB1 n,m,a,b = long long integers ;  $  TAB1 read n,m,a,b ;  $  TAB1 output min(b * (n modulo m), a * (((n / m) + 1) * m - n)) ;
TAB1 create long longs n, m, a, b ;  $  TAB1 while read n read m read a read b, print minimum of ( (m - n % m) * a and n % m * b ) print newline ;
TAB0 declare long long variables n and k ;  $  TAB0 create ints a and b ;  $  TAB1 read n, k, a and b ;  $  TAB1 if n % k is 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 declare long long sum1 = n % k * b ;  $  TAB2 declare long long variable sum2 = (k - n % k) * a ;  $  TAB2 print min of sum1 and sum2 ;
TAB1 n,m,a,b = long long integers ;  $  TAB1 read n,m,a,b ;  $  TAB1 if n modulo m is 0 then do ;  $  TAB2 output 0 ;  $  TAB1 else ;  $  TAB2 set long long tmp to n / m ;  $  TAB2 output min((n - tmp * m) * b, ((tmp + 1) * m - n) * a) ;
TAB1 n, m, a, b, sum1, sum2 =integers ;  $  TAB1 Read n, m, a, b ;  $  TAB1 if(n modulo m is 0 ;  $  TAB2 print 0 and a new line ;  $  TAB1 set sum1 to ((n / m + 1) * m - n) * a ;  $  TAB1 set sum2 to (n - (n / m) * m) * b ;  $  TAB1 if sum1 is greater than sum2 ;  $  TAB2 print sum2 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print sum1 and a new line ;
TAB1 n, m = long long ;  $  TAB1 a, b = int ;  $  TAB1 read n then m then a then b ;  $  TAB1 plus, minus = long long with plus = 0 and minus = 0 ;  $  TAB1 mod = long long with mod = n mod m ;  $  TAB1 div = long long with div = n / m ;  $  TAB1 if n is not a multiple of m ;  $  TAB2 if n is less than m ;  $  TAB3 set plus to m - n ;  $  TAB3 set minus to n ;  $  TAB2 else ;  $  TAB3 set plus to absolute of n - ((div * m) + m) ;  $  TAB3 set minus to mod ;  $  TAB1 else ;  $  TAB2 print 0 ;  $  TAB1 print min of plus * a and minus * b ;
TAB1 n, m, a, b, r = long long int ;  $  TAB1 read n, m, a, b ;  $  TAB1 r = n modulo m ;  $  TAB1 print min of r * b and (m - r) * a) ;
TAB1 n, m, a, b, x =integers ;  $  TAB1 Read n, m, a, b ;  $  TAB1 sum, sum2 =integers, both set to 0 ;  $  TAB1 if n is greater than or equal to m ;  $  TAB2 if n modulo m is 0 ;  $  TAB3 print 0 and a new line ;  $  TAB1 set x to n modulo m ;  $  TAB1 set sum1 to sum1 + b * x ;  $  TAB1 set sum2 to sum2 + a * (m - x) ;  $  TAB1 print minimum value of sum1 and sum2 and a new line ;
TAB1 create long longs n, m, a, b ;  $  TAB1 read n read m read a read b ;  $  TAB1 create long longs resa, resb ;  $  TAB1 create long long mod with mod = n % m ;  $  TAB1 set resb to mod * b ;  $  TAB1 if n is greater than or equal to m ;  $  TAB2 set resa to ( round up ( double casted ( n ) / m ) * m - n ) * a ;  $  TAB1 else ;  $  TAB2 set resa to ( m - n ) * a ;  $  TAB1 print minimum of resa and resb print newline ;
TAB0 create constant integer INF with INF = 0x3f3f3f3f ;  $  TAB0 create constant double PI with PI = acosign of -1.0 ;  $  TAB1 create long longs n, m, a , b ;  $  TAB1 read n read m read a read b ;  $  TAB1 create long long res with res = minimum of ( (m - (n % m)) * a and (n % m) * b) ;  $  TAB1 print res print newline ;
TAB1 n, m , a, b num = long long with num having value of 0 ;  $  TAB1 read n, m, a and b ;  $  TAB1 if n mod m equals 0 ;  $  TAB2 set num to 0 ;  $  TAB1 else if n is less than m ;  $  TAB2 set num to the minimum of (a * (m-n)) and n*b ;  $  TAB1 else ;  $  TAB2 y, z = long long with y value of n mod m and z value of m minus n mod m ;  $  TAB2 set num to the minimum of y*b and z*a ;  $  TAB1 print num ;
TAB1 n, m, a, b =integers ;  $  TAB1 Read n, m, a, b ;  $  TAB1 print minimum value of (m - n % m) * a and n % m * b and a new line ;
TAB1 declare long longs n and m ;  $  TAB1 declare integers a and b ;  $  TAB1 read from the input to n, m, a and b ;  $  TAB1 print min of n % m * b and (m - n % m) * a ;
TAB1 let n, m, a, b = long long ;  $  TAB1 whilte reading new values for n, m, a, and b, print min((m - n modulo m) * a, n modulo m * b) ;
TAB1 n, m, a, b = long long ;  $  TAB1 read n, m, a, b ;  $  TAB1 ans = long long ;  $  TAB1 if n > m ;  $  TAB2 ans = min of (m - n modulo m) modulo m * a and (n % m) * b ;  $  TAB1 else ;  $  TAB2 if n modulo m is 0 ;  $  TAB3 ans = 0 ;  $  TAB2 else ;  $  TAB3 ans = (n + (m - n modulo m) modulo m) / m ;  $  TAB3 ans = min of (ans * m - n) * a and (n - (n / m) * m) * b ;  $  TAB1 print ans ;
TAB1 n, m, a, b = long long ;  $  TAB1 read n then m then a then b ;  $  TAB1 s = long long with s = (n + m - 1) / m ;  $  TAB1 t = long long with t = n / m ;  $  TAB1 print min of (s * m - n) * a and (n - t * m) * b ;
TAB1 n, m, a, b, x, y =integers ;  $  TAB1 Read n, m, a, b ;  $  TAB1 set x to n modulo m ;  $  TAB1 set y to m - x ;  $  TAB1 set x to x * b ;  $  TAB1 set y to y * a ;  $  TAB1 print minimum value of x and y and a new line ;
TAB1 let n, m, a and b be long long ;  $  TAB1 read n, m, a and b ;  $  TAB1 set k= n/m ;  $  TAB1 assign (n - k * m) * b to t1 ;  $  TAB1 t2 = (m * (k + 1) - n) * a ;  $  TAB1 if t1 greater than t2 ;  $  TAB2 print t2 ;  $  TAB1 else ;  $  TAB2 print t1 and a newline ;
TAB1 a,b,c=int ;  $  TAB1 read a,b,c ;  $  TAB1 x,y,z=int ;  $  TAB1 z=sqrt((b*c)/a) ;  $  TAB1 y=c/z ;  $  TAB1 x=b/z ;  $  TAB1 print 4*(x+y+z) ;
TAB1 create ints A1, A2 and A3 ;  $  TAB1 read standard input to A1, A2 and A3 ;  $  TAB1 declare integer variable with name l = square root of (A1 * A2 / A3) ;  $  TAB1 declare integer variable b with value = square root of (A3 * A1 / A2) ;  $  TAB1 create new integer called h = square root of (A3 * A2 / A1) ;  $  TAB1 print 4 * (l + b + h) and "\n" ;
TAB1 create ints ab, bc, ca, a, b, c and s ;  $  TAB1 read user input to ab, bc and ca ;  $  TAB1 assign square root of ((ab * ca) / bc) to a ;  $  TAB1 change b to the square root of ((bc * ab) / ca) ;  $  TAB1 set c to the square root of ((ca * bc) / ab) ;  $  TAB1 assign 4 * (a + b + c) to s ;  $  TAB1 print s ;
TAB0 create new long longs a, b and c ;  $  TAB1 read from the input to a, b and c ;  $  TAB1 create long long variable with name z with value = sqrt((b * c) / a) ;  $  TAB1 create new long long x = c / z ;  $  TAB1 declare long long y = b / z ;  $  TAB1 print x * 4 + y * 4 + z * 4 and '\n' ;
TAB1 l,h,b,a1,a2,a3=int ;  $  TAB1 read a1,a2,a3 ;  $  TAB1 l=sqrt((a2*a3)/a1) ;  $  TAB1 b=sqrt((a1*a3)/a2) ;  $  TAB1 h=sqrt((a2*a1)/a3) ;  $  TAB1 print 4*(l+b+h) ;
TAB1 u,v,w=long long int ;  $  TAB1 read u,v,w ;  $  TAB1 t1,t2,t3=long long int ;  $  TAB1 t1=sqrt((u*v*w))/u ;  $  TAB1 t2=sqrt((u*v*w))/v ;  $  TAB1 t3=sqrt((u*v*w))/w ;  $  TAB1 print 4*(t1+t2+t3) ;
TAB1 a,b,c=int ;  $  TAB1 read a,b,c ;  $  TAB1 print 4*(sqrt(a*c/b)+sqrt(b*c/a)+sqrt(a*b/c)) ;
TAB1 let a, b, c be double values ;  $  TAB1 read a, b, c ;  $  TAB1 let s be a double value with s = square root of a * b * c ;  $  TAB1 print 4.0 * (s / a + s / b + s / c) and newline ;
TAB1 lb,bh,hl,l,b,h=int ;  $  TAB1 read lb,bh,hl ;  $  TAB1 b=sqrt(lb*bh/hl) ;  $  TAB1 l=lb/b ;  $  TAB1 h=hl/l ;  $  TAB1 print 4*(l+b+h) ;
TAB1 create ints a, b and c ;  $  TAB1 read user input to a, b and c ;  $  TAB1 create new integer m with value = (max of a and max(b, c)) ;  $  TAB1 declare integer r = 0 ;  $  TAB1 in a for loop, change i from 1 to m inclusive incrementing i ;  $  TAB2 if a % i = 0 and b % i = 0 and (a / i) * (b / i) = c ;  $  TAB3 change r to a / i + b / i + i ;  $  TAB3 set r to r multiplied by 4 ;  $  TAB1 print r to the standard output ;
TAB0 in the function gcd that takes integer a,b and returns integer ;  $  TAB1 if b is 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 gcd of b and a modulo b ;  $  TAB1 x, y, z = integers ;  $  TAB1 while read x, y, z ;  $  TAB2 c = integer with c = square root of (z * y) / x) ;  $  TAB2 a = integer with a = (x * c) / y ;  $  TAB2 b = integer with b = x / a ;  $  TAB2 print a * 4 + b * 4 + c * 4 ;
TAB1 a, b, c = int ;  $  TAB1 read a then b then c ;  $  TAB1 print 4 * (sqrt of a * b / c + sqrt of b * c / a + sqrt of a * c / b) ;
TAB1 a, b, c, i, j, k = int ;  $  TAB1 read a then b then c ;  $  TAB1 for i = 1 to 10005 ;  $  TAB2 for j = 1 to 10005 ;  $  TAB3 for k = 1 to 10005 ;  $  TAB4 if i * j is a and i * k is b and j * k is c ;  $  TAB5 print 4 * i + 4 * j + 4 * k ;  $  TAB4 if i * k is greater than b or j * k is greater than c break ;  $  TAB3 if i * j is greater than a or j is greater than c break ;  $  TAB2 if i is greater than a or b beak ;
TAB1 declare x, y, z as integers ;  $  TAB1 read x, y, z ;  $  TAB1 declare integers a, b, c ;  $  TAB1 let a be square root of (x * z) / y ;  $  TAB1 let b be square root of (x * y) / z ;  $  TAB1 let c be square root of (y * z) / x ;  $  TAB1 print 4 * ( a + b + c ), newline ;
TAB1 a, b, c = int ;  $  TAB1 loop while reading a then b then c ;  $  TAB2 ans = int with ans = 4 * (sqrt of a * b / c + sqrt of a * c / b + sqrt of b * c / a) ;  $  TAB2 print ans ;
TAB1 create doubles A, B and C ;  $  TAB1 declare integers a, b and c ;  $  TAB1 read a, b and c ;  $  TAB1 change A to the square root of a * b / c ;  $  TAB1 assign sqrt(b * c / a) to B ;  $  TAB1 assign the square root of c * a / b to C ;  $  TAB1 create new integer variable count = (A + B + C) * 4 ;  $  TAB1 print count to the standard output ;
TAB0 create long long integers a, b, c, and s ;  $  TAB0 declare solve ;  $  TAB1 read a, b, and c ;  $  TAB1 set s to s + (long long)sqrt(a * b / c) ;  $  TAB1 set s to s + (long long)sqrt(b * c / a) ;  $  TAB1 set s to s + (long long)sqrt(a * c / b) ;  $  TAB1 print s * 4 ;  $  TAB0 declare prep ;  $  TAB1 let long long int t = 1 ;  $  TAB1 call prep ;  $  TAB1 print fixed and setprecision(12) ;  $  TAB1 while t-- is truthy, call solve ;
TAB1 declare three integer variables ab, bc, and ac ;  $  TAB1 read in ab, bc and ac ;  $  TAB1 variable b is equal to the square root of the value of ab * bc divided by ac ;  $  TAB1 variable a is equal to ab divided by b ;  $  TAB1 c is equal to bc divided by b ;  $  TAB1 print the sum of a multiplied by 4, b multiplied by 4 and c multiplied by 4 ;
TAB1 a,b,c=int ;  $  TAB1 x,y,z=int ;  $  TAB1 read a,b,c ;  $  TAB1 x=sqrt((a*c)/b) ;  $  TAB1 y=sqrt((b*a)/c) ;  $  TAB1 z=sqrt((b*c)/a) ;  $  TAB1 print x*4+y*4+z*4 ;
TAB1 x, y, z = long long ;  $  TAB1 read x then y then z ;  $  TAB1 abc = long long with abc = (sqrt of x * y * z + 0.00001) as long long ;  $  TAB1 ans = long long with ans = 4 * (abc / x + abc / y + abc / z) ;  $  TAB1 print ans ;
TAB1 create long long ints a, b, and c ;  $  TAB1 read a, b, and c ;  $  TAB1 let long long int p = sqrt(a * b * c) ;  $  TAB1 let long long integer res = 0 ;  $  TAB1 set res to res + (p / a + p / b + p / c) ;  $  TAB1 print res * 4 ;
TAB1 create int a, b and c ;  $  TAB1 read a, b, c ;  $  TAB1 sum=0 ;  $  TAB1 set sum to square root of (a * b) / c) + sqrt of (b * c) / a) + sqrt((c * a) / b) ;  $  TAB1 print sum*4 ;
TAB1 declare a, b, c, as integers ;  $  TAB1 read a and b and c ;  $  TAB1 declare x = 0, y = 0, z = 0, flag = 0, as integers ;  $  TAB1 let x be square root of ((b * c) / a) ;  $  TAB1 let y be square root of ((c * a) / b) ;  $  TAB1 let z be square root of ((a * b) / c) ;  $  TAB1 print 4 * ( x + y + z ), newline ;
TAB1 m,n,p=int ;  $  TAB1 read m,n,p ;  $  TAB1 a=sqrt(p*m/n) ;  $  TAB1 b=sqrt(m*n/p) ;  $  TAB1 c=sqrt(n*p/m) ;  $  TAB1 sum=4*(a+b+c) ;  $  TAB1 print sum ;
TAB1 declare integers m, n, p, sum = 0, a, b, c ;  $  TAB1 read m read n read p ;  $  TAB1 let a be square root of p * m / n ;  $  TAB1 let b be square root of m * n / p ;  $  TAB1 let b be square root of n * p / m ;  $  TAB1 let sum = 4 * (a + b + c) ;  $  TAB1 print sum print newline ;
TAB1 declare integers a, b and c ;  $  TAB1 read standard input to a, b and c ;  $  TAB1 declare integer variable with name x with value sqrt((a * b) / c) ;  $  TAB1 declare integer y with value = square root of ((a * c) / b) ;  $  TAB1 z is a new integer = square root of ((b * c) / a) ;  $  TAB1 print 4 * (x + y + z) to the standard output ;
TAB1 x1, x2, x3 = integers ;  $  TAB1 read x1, x2, x3 ;  $  TAB1 sum = integer with sum = sqrt((x1 * x3) / x2) + sqrt((x2 * x1) / x3) + sqrt((x3 * x2) / x1) ;  $  TAB1 sum = sum * 4 ;  $  TAB1 print sum ;
TAB0 create integer array arr of size 104 ;  $  TAB1 make ints n and k ;  $  TAB1 read n and k ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 make integer total = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB2 set total to total + arr[i] ;  $  TAB2 subtract min(total, 8) from total ;  $  TAB2 if k is less than or equal to 0 ;  $  TAB3 print i + 1 ;  $  TAB1 show -1 ;
TAB1 declare int variables n and k ;  $  TAB1 read from the input to n and k ;  $  TAB1 define new integer a ;  $  TAB1 define integers totalChocolate, days and remain = 0 ;  $  TAB1 declare boolean variable with name flag with value false ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read standard input to a ;  $  TAB2 change a to the sum of a and remain ;  $  TAB2 if a is greater than 8 ;  $  TAB3 assign a - 8 to remain ;  $  TAB3 change totalChocolate to the sum of totalChocolate and 8 ;  $  TAB2 else ;  $  TAB3 add a to totalChocolate ;  $  TAB3 assign the new value = 0 to remain ;  $  TAB2 increment days by one ;  $  TAB2 if totalChocolate >= k ;  $  TAB3 assign true to flag ;  $  TAB3 break ;  $  TAB1 if flag is true ;  $  TAB2 print days ;  $  TAB1 else ;  $  TAB2 print "-1" to the standard output ;
TAB0 let MAX be a constant integer 100001 ;  $  TAB0 An, Bn are integer arrays ;  $  TAB1 n, k are integers ;  $  TAB1 read n, k ;  $  TAB1 for integer i = 1 to n inclusive, print An[i] ;  $  TAB1 sum , flag, coun be integers 0 ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 increase coun by An[i] ;  $  TAB2 if coun is greater than 8 ;  $  TAB3 increase sum by 8 ;  $  TAB3 decrease coun by 8 ;  $  TAB2 else ;  $  TAB3 increase sum by coun ;  $  TAB3 coun is 0 ;  $  TAB2 if sum is greater than k ;  $  TAB3 flag is 0 ;  $  TAB3 print i and endline ;  $  TAB3 stop ;  $  TAB1 if flag is 0, print -1 and endline ;
TAB1 n,k,a=int, c,v=0 ;  $  TAB1 read n,k ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 if a <= 8 ;  $  TAB3 if c >= 8-a ;  $  TAB4 add 8 to v ;  $  TAB4 subtract 8-a from c ;  $  TAB3 else ;  $  TAB4 add a+c to v ;  $  TAB4 c=0 ;  $  TAB2 else ;  $  TAB3 add 8 to v ;  $  TAB3 add a-8 to c ;  $  TAB2 if v >= k ;  $  TAB3 print i ;  $  TAB1 print -1 ;
TAB1 create int a, b, c, t, l, i, j, m, set sum and count to 0 ;  $  TAB1 read a and b ;  $  TAB1 for i=1 to a inclusive ;  $  TAB2 read c ;  $  TAB2 set sum to sum + c ;  $  TAB2 set m to min of 8 and sum ;  $  TAB2 set sum to sum - m ;  $  TAB2 b= b-m ;  $  TAB2 increment count ;  $  TAB2 if b<=0 ;  $  TAB1 if b>0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print count ;
TAB1 n,k,ans,sum,aux,candies=int ;  $  TAB1 ans,sum,candies=0 ;  $  TAB1 found=false ;  $  TAB1 read n,k ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read aux ;  $  TAB2 if found continue ;  $  TAB2 add aux to candies ;  $  TAB2 aux=min(candies, 8) ;  $  TAB2 add aux to sum ;  $  TAB2 increment ans ;  $  TAB2 subtract aux from candies ;  $  TAB2 if sum>=k found=true ;  $  TAB1 if not found ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB1 let n, k, a, b = 1, c = 0, d = 0, e, s be integers ;  $  TAB1 read n. k ;  $  TAB1 for integer i = 1 to n inclusive. read s[i] ;  $  TAB1 while b is less than or equal to n ;  $  TAB2 e equals s[b] + d ;  $  TAB2 if e is less than or equal to 8 ;  $  TAB3 c equals c + e ;  $  TAB3 d equals 0 ;  $  TAB3 b increased by 1 ;  $  TAB3 if c is greater than or equal to k, stop ;  $  TAB2 else if e is greater than 8 ;  $  TAB3 increment c by 8 ;  $  TAB3 d equals e minus 8 ;  $  TAB3 increment b by 1 ;  $  TAB3 if c is greater than or equal to k, stop ;  $  TAB1 if c is less than k ;  $  TAB2 print -1 and newline ;  $  TAB1 else ;  $  TAB2 print b - 1 and newline ;
TAB0 n, k = integers ;  $  TAB0 a = array of 1007 integers ;  $  TAB1 Read n, k ;  $  TAB1 _d, _c =integers with _d = 0, _c = 0 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 Read n values into array a ;  $  TAB2 if k is greater than 0 ;  $  TAB3 set _c to _c + a[i] ;  $  TAB3 x = integer, set to minimum value of 8LL,and _c ;  $  TAB3 set k to k - x ;  $  TAB3 set _c to _c - x ;  $  TAB3 set _d to i ;  $  TAB1 if k is less than or equal to 0 ;  $  TAB2 print _d and a new line ;  $  TAB1 else do the following ;  $  TAB2 print -1 and a new line ;
TAB1 n, k =integers ;  $  TAB1 Read n, k ;  $  TAB1 arr = array of n integers with 0 elements ;  $  TAB1 answer = integer with 0 ;  $  TAB1 sum = integer with 0 ;  $  TAB1 Read n values into array arr ;  $  TAB1 temp = integer with 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set arr[i] to arr[i] + temp ;  $  TAB2 if arr[i] is greater than or equal to 8 ;  $  TAB3 set k to k - 8 ;  $  TAB3 set temp to arr[i] - 8 ;  $  TAB3 increment answer ;  $  TAB2 else do the following ;  $  TAB3 set k to k - arr[i] ;  $  TAB3 set temp to 0 ;  $  TAB3 increment answer ;  $  TAB2 if k is less than or equal to 0 ;  $  TAB3 print answer and a new line ;  $  TAB1 print -1 and a new line ;
TAB1 n, k, a, b, c, d, e = integers and s = array of 117 integers ;  $  TAB1 Read n and k ;  $  TAB1 Read n values into array s ;  $  TAB1 while b is less than or equal to n ;  $  TAB2 set e to s[b] + d ;  $  TAB2 if e is less than or equal to 8 ;  $  TAB3 set c to c + e ;  $  TAB3 set d to 0 ;  $  TAB3 increment b ;  $  TAB3 if c is greater than or equal to k, then Terminate the loop ;  $  TAB2 else if e is greater than 8 ;  $  TAB3 set c to c + 8 ;  $  TAB3 set d to e - 8 ;  $  TAB3 increment b ;  $  TAB3 if c is greater than or equal to k, then Terminate the loop ;  $  TAB1 if c is less than k ;  $  TAB2 print -1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print b - 1 and a new line ;
TAB1 define integers n and k ;  $  TAB1 read n and k ;  $  TAB1 declare integer variables arya and bran = 0 ;  $  TAB1 define new integer called s = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer t ;  $  TAB2 read standard input to t ;  $  TAB2 if t + arya >= 8 ;  $  TAB3 increase bran by 8 ;  $  TAB3 increase arya by t - 8 ;  $  TAB3 increase s by 1 ;  $  TAB2 else ;  $  TAB3 add t + arya to bran ;  $  TAB3 change arya to 0 ;  $  TAB3 increase s by 1 ;  $  TAB2 if bran >= k ;  $  TAB3 print s ;  $  TAB1 if bran <= k, print -1 to the standard output ;
TAB0 declare solve taking in ints n and k and int array arr and returning integer ;  $  TAB1 create integer t = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set t to t + arr[i] ;  $  TAB2 make integer val = min(8, t) ;  $  TAB2 subtract val from k ;  $  TAB2 set t to t - val ;  $  TAB2 if k is less than or equal to 0, return i + 1 ;  $  TAB1 return -1 ;  $  TAB1 create ints n and k ;  $  TAB1 read n and k ;  $  TAB1 create int array arr of size n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 print the result of solve(arr, n, k) ;
TAB1 n, i, k, j, t, m =integers with t = 0 ;  $  TAB1 Read n and k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read j ;  $  TAB2 set j to j + t ;  $  TAB2 set t to 0 ;  $  TAB2 if j is greater than or equal to 8 ;  $  TAB3 set t to t + j - 8 ;  $  TAB3 set j to 8 ;  $  TAB2 set k to k - j ;  $  TAB2 if k is greater than or equal to 0, then Terminate the loop ;  $  TAB1 if k is greater than 0 ;  $  TAB2 print -1 and new line ;  $  TAB1 else do the following ;  $  TAB2 print i + 1 and a new line ;
TAB1 declare new integer variables n and k ;  $  TAB1 read n and k from the input ;  $  TAB1 create vector of integers a with n elements ;  $  TAB1 create new integer called curr = 0 ;  $  TAB1 goal is a new integer = k ;  $  TAB1 create integer variable count with value 0 ;  $  TAB1 for integer i = 0 to n exclusive incrementing i ;  $  TAB2 read a[i] ;  $  TAB2 set curr to curr + a[i] ;  $  TAB2 declare integer variable with name maxGive = min of 8 and curr ;  $  TAB2 set the value of curr to curr - maxGive ;  $  TAB2 change goal to goal - maxGive ;  $  TAB2 if goal <= 0 ;  $  TAB2 else ;  $  TAB3 increment count ;  $  TAB1 if goal is greater than 0, set the value of count to -2 ;  $  TAB1 print count + 1 ;
TAB1 n, k = int ;  $  TAB1 read n, k ;  $  TAB1 c = int array length n ;  $  TAB1 for i = 0 to n exclusive, read c[i] ;  $  TAB1 if k <= n*8 ;  $  TAB2 sum = 0 = int ;  $  TAB2 p = 0 = int ;  $  TAB2 for i = 0 to n excluisve ;  $  TAB3 if c[i] <= 8 ;  $  TAB4 set c[i] to c[i] ;  $  TAB3 else ;  $  TAB4 a = int = c[i] - 8 ;  $  TAB4 set c[i] to 8 ;  $  TAB4 set c[i+1] to c[i+1]+a ;  $  TAB3 increment sum by c[i] ;  $  TAB3 if sum >= k ;  $  TAB4 print i + 1 ;  $  TAB4 exit loop ;  $  TAB3 else ;  $  TAB4 increment p ;  $  TAB2 if p = n then print -1 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 declare integers a, b, c = 0 ;  $  TAB1 read a, b ;  $  TAB1 while b is true ;  $  TAB2 declare integer d = b % 10 ;  $  TAB2 let c be c * 10 + d ;  $  TAB2 let b be b / 10 ;  $  TAB1 print a + c and newline ;
TAB1 a, b = long long ;  $  TAB1 read a, b ;  $  TAB1 temp = long long with temp = 0 ;  $  TAB1 while (b > 0) ;  $  TAB2 temp = (temp * 10) + (b modulo 10) ;  $  TAB2 b = b / 10 ;  $  TAB1 print a + temp ;
TAB1 a and num are integers with num = 0 ;  $  TAB1 b is a new array of characters with 100 elements ;  $  TAB1 read a from the user input ;  $  TAB1 read standard input to b ;  $  TAB1 reverse b ;  $  TAB1 increment i by 1 in a loop, starting from 0 to the length of b, ans change num to (num * 10) + (b[i] - '0') on every loop ;  $  TAB1 print num + a ;
TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 y=array of 30 int ;  $  TAB1 r=b, d=0 ;  $  TAB1 while r>0 ;  $  TAB2 y[d]=r modulo 10 ;  $  TAB2 divide r by 10 ;  $  TAB2 increment d ;  $  TAB1 for i=0 to d/2 exclusive swap y[i] and y[d-1-i] ;  $  TAB1 w=0, k=1 ;  $  TAB1 for i=0 to d exclusive ;  $  TAB2 add y[i]*k to w ;  $  TAB2 multiply k by 10 ;  $  TAB1 print w+a ;
TAB1 a, b, c = integers set c = 0 ;  $  TAB1 read a and b ;  $  TAB1 while b != 0 ;  $  TAB2 set c = c * 10 + b decrement 10 ;  $  TAB2 set b = b / 10 ;  $  TAB1 print a + c ;
TAB0 a, be and eb are integers with eb = 0 ;  $  TAB1 read standard input to a and be ;  $  TAB1 while be is not 0 ;  $  TAB2 change the value of eb to 10 * eb + be % 10 ;  $  TAB2 change the value of be to be divided by 10 ;  $  TAB1 print a + eb and '\n' ;
TAB1 let a, b and c be integers, set c to 0 ;  $  TAB1 read in a and b ;  $  TAB1 while b is not 0 ;  $  TAB2 let d be an integer and set it to b % 10 ;  $  TAB2 set c to c * 10 + d ;  $  TAB2 set b to b / 10 ;  $  TAB1 print a + c ;
TAB1 let a, ans , plus be long integers with ans = 0 ;  $  TAB1 let b be a string ;  $  TAB1 read a and b ;  $  TAB1 for i = 0 to (length of b) - 1 inclusive ;  $  TAB2 plus = (int)b[i] - 48 ;  $  TAB2 for j = 0 to i inclusive , plus is equal to plus * 10 ;  $  TAB2 divide plus by 10 ;  $  TAB2 increment ans by plus ;  $  TAB1 increment ans by a ;  $  TAB1 print ans and new line ;
TAB1 a, b =integers ;  $  TAB1 Read a, b ;  $  TAB1 reversedNumber, remainder = integers with reversedNumber = 0 ;  $  TAB1 while b is not equal to 0 ;  $  TAB2 set remainder to b modulo 10 ;  $  TAB2 set reversedNumber to reversedNumber * 10 + remainder ;  $  TAB2 set b to b / 10 ;  $  TAB1 print a + reversedNumber and a new line ;
TAB0 in int rever taking n = int ;  $  TAB1 rn = 0 = int ;  $  TAB1 while n ;  $  TAB2 set rn to rn * 10 + n mod 10 ;  $  TAB2 divide n by 10 ;  $  TAB1 return rn ;  $  TAB1 a,b = int ;  $  TAB1 while reading a and b, print a + rever of b ;
TAB1 let ff be the ifstream file.txt ;  $  TAB1 s1, s2 = string ;  $  TAB1 read s1 and s2 ;  $  TAB1 reverse s2 ;  $  TAB1 while length of s1 is not length of s2 ;  $  TAB2 if lenght of s1 is > length of s2 ;  $  TAB3 call insert on s2 with args beginning of s2, 1, '0' ;  $  TAB2 else ;  $  TAB3 call insert on s1 with args beginning of s1, 1, '0' ;  $  TAB1 x, y = int ;  $  TAB1 iss of s2 = istringstream ;  $  TAB1 iss >> x ;  $  TAB1 iss1 of s1 = istringstream ;  $  TAB1 iss1 >> y ;  $  TAB1 print x+y ;
TAB1 create int int a, b, c, set c to 0 ;  $  TAB1 read a and b ;  $  TAB1 while b different from b ;  $  TAB2 set d to b mod 10 ;  $  TAB2 set c to c * 10 + d ;  $  TAB2 assign b/10 to b ;  $  TAB1 print a+c ;
TAB0 declare rev taking in long long x and returning long long ;  $  TAB1 create long long int ans = 0 ;  $  TAB1 while x is truthy ;  $  TAB2 set ans to ans * 10 + (x % 10) ;  $  TAB2 set x to x / 10 ;  $  TAB1 return ans ;  $  TAB1 make long long ints a and b ;  $  TAB1 read a and b and while a and b are truthy ;  $  TAB2 set b to return result of rev(b) ;  $  TAB2 output a + b ;
TAB1 declare strings a, b, c ;  $  TAB1 read a and b ;  $  TAB1 reverse sort from beginning of a to end of a ;  $  TAB1 while size of a is less than size of b, increment a by "0" ;  $  TAB1 while size of b is less than size of a, increment b by "0" ;  $  TAB1 declare integer vector ans ;  $  TAB1 declare integer sisa = 0 ;  $  TAB1 for i = 0 to size of a exclusive ;  $  TAB2 declare integer x = a[i] - '0' + b[i] - '0' + sisa ;  $  TAB2 let sisa be 0 ;  $  TAB2 add ( x % 10 ) to end of ans ;  $  TAB2 let sisa be x / 10 ;  $  TAB1 while sisa is greater than 0 ;  $  TAB2 add (sisa%10) to end of ans ;  $  TAB2 let sisa be sisa / 10 ;  $  TAB1 while size of ans is greater than 1 and back of ans is 0, remove last element from ans ;  $  TAB1 for i = size of ans - 1 to 0 inclusive, decrementing i, print ans[i] ;  $  TAB1 print newline ;
TAB0 declare long longs n, i, j, ans = 0 ;  $  TAB1 declare strings s1, s2 ;  $  TAB1 read s1, s2 ;  $  TAB1 reverse sort from beginning of s2 to end of s2 ;  $  TAB1 declare stringstreams geek initialized with s2, geek1 initialized with s1 ;  $  TAB1 declare long long a ;  $  TAB1 read a using geek ;  $  TAB1 declare long long b ;  $  TAB1 read b using geek1 ;  $  TAB1 print a + b and newline ;
TAB1 declare new string variables a and b ;  $  TAB1 read a and b ;  $  TAB1 reverse b ;  $  TAB1 create new stringstream n1 from the string a ;  $  TAB1 create new stringstream n2 from the string b ;  $  TAB1 define new integers num1 and num2 ;  $  TAB1 read num1 from n1 ;  $  TAB1 read the new value for num2 from n2 ;  $  TAB1 declare long long integer res = num1 + num2 ;  $  TAB1 print res to the standard output ;
TAB1 let a, b be strings ;  $  TAB1 read a, b ;  $  TAB1 reverse the values of b from beginning to end ;  $  TAB1 stringstream allows you to read n1 from a ;  $  TAB1 stringstream allows you to read n2 from b ;  $  TAB1 let num1, num2 be integers ;  $  TAB1 n1 >> num1 ;  $  TAB1 n2 >> num2 ;  $  TAB1 the long integer value of res = num1 + num2 ;  $  TAB1 print res and newline ;
TAB1 create int a, b, c, set c to 0 ;  $  TAB1 read a and b ;  $  TAB1 while b different from 0 ;  $  TAB2 d= b mod 10 ;  $  TAB2 set c = c * 10 + d ;  $  TAB2 b= b/10 ;  $  TAB1 print a +c ;
TAB1 a1, a2, k, a3 =integers with a3 = 0 ;  $  TAB1 Read a1, a2 ;  $  TAB1 while a2 is not equal to 0 ;  $  TAB2 sett k to a2 modulo 10 ;  $  TAB2 set a3 to a3 * 10 + k ;  $  TAB2 set a2 to a2 / 10 ;  $  TAB1 print a1 + a3 and a new line ;
TAB0 create int a, b, c ;  $  TAB1 read a and b ;  $  TAB1 while b > 0 ;  $  TAB2 set d to b mod 10 ;  $  TAB2 set c = c * 10 + d ;  $  TAB2 assign b/10 to b ;  $  TAB1 print a + c ;
TAB0 declare boolean flag ;  $  TAB0 declare integer arrays a size 71720, dp size 811 by 811, integers n, i, sumend, m, j, k, x, y, b, c ;  $  TAB0 declare long long integer sum ;  $  TAB0 declare boolean cmp with integers a, b as arguments, returning boolean ;  $  TAB1 return a is greater than b ;  $  TAB0 declare gcd with integers a, b as arguments, returning integer ;  $  TAB1 if not b, return a from function ;  $  TAB1 return result of run gcd(b,a%b) ;  $  TAB0 declare maxx with short integers a, b as arguments, returning integer ;  $  TAB1 if a is greater than b, return a ;  $  TAB1 return b from function ;  $  TAB0 declare gqt with integer n as argument, returning integer ;  $  TAB1 if not n or n, return 1 from function ;  $  TAB1 if n is 2, return 0 from function ;  $  TAB1 for i = 3 to square root of n inclusive ;  $  TAB2 if n % i is 0, return 1 ;  $  TAB1 read x, y ;  $  TAB1 while y is not 0 ;  $  TAB2 let sum be y % 10 ;  $  TAB2 let sumend be sumend * 10 ;  $  TAB2 increment sumend by sum ;  $  TAB2 let y be y / 10 ;  $  TAB1 increment sumend by x ;  $  TAB1 print sumend and newline ;
TAB1 declare int variables a and b ;  $  TAB1 read input to a and b ;  $  TAB1 create integers vectors x and y ;  $  TAB1 while a is not 0 ;  $  TAB2 push a % 10 after the last element of x ;  $  TAB2 change the value of a to a divided by 10 ;  $  TAB1 while b ;  $  TAB2 push b % 10 to the end of y ;  $  TAB2 set b to b divided by 10 ;  $  TAB1 reverse y ;  $  TAB1 push 0 to x while size of x < size of y ;  $  TAB1 push 0 to y while size of y < size of x ;  $  TAB1 for i from 0 to length of y exclusive, increase x[i] by y[i] ;  $  TAB1 declare new long long ans = 0 ;  $  TAB1 in a loop for i from size of - 1 to 0 inclusive, counting down, change ans to 10 * ans + x[i] ;  $  TAB1 print ans to the standard output ;
TAB1 create integers a, b, i, j, and x ;  $  TAB1 read a and b ;  $  TAB1 create integer sum = 0 ;  $  TAB1 while b is not 0 ;  $  TAB2 set sum to sum * 10 ;  $  TAB2 set sum to sum + b % 10 ;  $  TAB2 divide b by 10 ;  $  TAB1 set sum to sum + a ;  $  TAB1 display sum ;
TAB1 let s, ss be strings ;  $  TAB1 read s, ss ;  $  TAB1 reverse the values of ss from beginning to end ;  $  TAB1 let x , y be integers ;  $  TAB1 read a stringstream into sss and read a stringstream into ssss ;  $  TAB1 shift sss to the right by s ;  $  TAB1 shift sss to the left by x ;  $  TAB1 shift ssss to the right by ss ;  $  TAB1 shift ssss to the left by y ;  $  TAB1 print x + y and newline ;
TAB1 create string b ;  $  TAB1 create long long a, c, d ;  $  TAB1 read a and b ;  $  TAB1 c=0 ;  $  TAB1 for I00 to length of b -1 exclusive, set c = c * 10 + b[i] - 0 ;  $  TAB1 d=a+c ;  $  TAB1 print d ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 print 25 and newline ;
TAB1 declare new int variables a and b ;  $  TAB1 read variable a from the input ;  $  TAB1 print "25" ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 print "25" ;
TAB1 let n, a, i be float values ;  $  TAB1 let s be a integer ;  $  TAB1 read n ;  $  TAB1 s is equal to 25 ;  $  TAB1 if n is equal to 1 , s is equal to 5 ;  $  TAB1 print s and newline ;
TAB1 n=long long int ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n = long long ;  $  TAB1 loop while reading n ;  $  TAB2 if n is 1 ;  $  TAB3 print 5 ;  $  TAB2 else ;  $  TAB3 print 25 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n is equal to 1, print 5 ;  $  TAB1 if n equals 0, print 1 ;  $  TAB1 if n is greater than or equal to 2, print 25 ;
TAB0 long long function Q_pow with long long arguments a and b ;  $  TAB1 declare long long variable with name ans = 1 ;  $  TAB1 while b > 0 ;  $  TAB2 if b is odd ;  $  TAB3 change a to the remainder of a divided by 100 ;  $  TAB3 change ans to the ans modulo 100 ;  $  TAB3 set ans to ans multiplied by a ;  $  TAB2 change a to a modulo 100 ;  $  TAB2 multiply a by a ;  $  TAB2 divide b by 2 ;  $  TAB1 return ans % 100 ;  $  TAB1 create long long variable n ;  $  TAB1 read n and print the result of Q_pow(5, n) ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 in, ans =integer with ans = 25 ;  $  TAB1 Read in ;  $  TAB1 print ans and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB0 create integer i, j ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n = long long ;  $  TAB1 while n can be read as a valid long long, print 25 ;
TAB1 print 25 and a new line ;
TAB1 create unsigned long long variable n ;  $  TAB1 read user input to n ;  $  TAB1 print 25 to the standard output ;
TAB1 j =integer ;  $  TAB1 Read j ;  $  TAB1 print 25 and a new line ;
TAB1 n, b =integers with b = 25 ;  $  TAB1 Read n ;  $  TAB1 print b and a new line ;
TAB0 n=int ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 print 25 ;
TAB1 print 25 and a new line ;
TAB1 let n be a long integer ;  $  TAB1 while read n , print 25 and newline ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB0 in function Q_pow that returns a long long and takes arguments a, b = long long ;  $  TAB1 ans = long long with value of 1 ;  $  TAB1 while b is greater than 0 ;  $  TAB2 if b mod 2 equals 1 ;  $  TAB3 set a to a mod 100 ;  $  TAB3 set ans to ans mod 100 ;  $  TAB3 set ans to ans * a ;  $  TAB2 set a to a mod 100 ;  $  TAB2 set a to a * a ;  $  TAB2 set b to b/2 ;  $  TAB1 return ans mod 100 ;  $  TAB1 n = long long ;  $  TAB1 while read n do print the return of function Q_pow with arguments a = 5 and b = n ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n = long long ;  $  TAB1 loop while reading n print 25 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n=unsigned long lon ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB0 n = integer ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB0 mod = const long long with mod = 100 ;  $  TAB0 in function re taking long long a, long long n and returning long long ;  $  TAB1 ans = long long with ans = 1 ;  $  TAB1 loop while n > 0 ;  $  TAB2 if n bitwise-and 1 set ans to (ans * a) modulo mod ;  $  TAB2 set a to (a * a) modulo mod ;  $  TAB2 set n to n bitshfit right by 1 ;  $  TAB1 return ans ;  $  TAB1 n = long long ;  $  TAB1 loop while reading n ;  $  TAB2 result = long long with result = re of 5, n ;  $  TAB2 print result ;
TAB1 n = long long ;  $  TAB1 while reading n print 25 ;
TAB1 create long long integer n ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB0 MOD = const integer with MOD = 100 ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 v = integer with v = 5 ;  $  TAB1 ans = integer with ans = 1 ;  $  TAB1 for i = 0 to 62 with increment i, v = (v * v) modulo MOD ;  $  TAB2 if (n bitwise and (left shift i 1 place)), ans = (ans * v) modulo MOD ;  $  TAB1 print ans ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 create long long n ;  $  TAB1 read n and while n is truthy, print 25 ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 print "25" and newline ;
TAB1 i, j, n, c, ans =integers with c = 0 and ans = 25 ;  $  TAB1 Read n ;  $  TAB1 print ans and a new line ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 print "25" ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n = unsigned long long ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 create char n[20] ;  $  TAB1 while read n, print 25 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print 25 and a new line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print 25 ;
TAB0 create constant double eps = 1e-6 ;  $  TAB0 let const int MAXN = 8000 ;  $  TAB0 let double array a of size MAXN ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 let double x ;  $  TAB1 for i = 0 to 2 exclusive, read a[i] ;  $  TAB1 let double sum = 0 ;  $  TAB1 create int num = 0 ;  $  TAB1 for i = 0 to 2 exclusive ;  $  TAB2 set x to ((int)a[i] + 1) * 1.0 - a[i] ;  $  TAB2 if (fabs(x - 1) <= eps ;  $  TAB3 increment num++ ;  $  TAB2 else ;  $  TAB3 set sum to sum + x ;  $  TAB1 create integer m = 0 ;  $  TAB1 if num is less than 0, set m to n - num ;  $  TAB1 let double res = 0x3f3f3f3f * 1.0 ;  $  TAB1 loop until m <= min(2 * n - num, n), set res to min of res and fabs(sum - m) ;  $  TAB1 print fixed, setprecision(3), and res ;
TAB0 frac is a double function with double argument x ;  $  TAB1 return x - (x casted to long long) ;  $  TAB1 create integer n ;  $  TAB1 read variable n from the input ;  $  TAB1 declare double variable diff with value 0 ;  $  TAB1 create new long long called c with value 0 ;  $  TAB1 a is a new vector of doubles ;  $  TAB1 loop i from 0 to 2 * n exclusive ;  $  TAB2 x is a new double ;  $  TAB2 read x from the user input ;  $  TAB2 push frac(x) to the end of a ;  $  TAB2 if a[i] = 0, increment c ;  $  TAB2 increase diff by a[i] ;  $  TAB1 create new double ans = 1e9 ;  $  TAB1 for i from 0 to c inclusive ;  $  TAB2 if i is less than c - n, go to the start of the loop ;  $  TAB2 declare new double variable p = abs(diff - (n - i) * 1.0) ;  $  TAB2 set ans to min of p and ans ;  $  TAB1 set decimal output precision to 3 and force it to usefixed floating-point notation ;  $  TAB1 print ans and '\n' to the output ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 if n is 1 ;  $  TAB2 print 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 if n is odd, then decrement n ;  $  TAB2 print n / 2 + 1 and a new line ;
TAB0 Create global constant integers n = 100010 and INF = 1000000007 ;  $  TAB0 Create n as a global integer ;  $  TAB1 Set n to the input ;  $  TAB1 Output one plus n divided by 2 ;
TAB0 set const int maxa to 1000000 ;  $  TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 if n is 1 then do the following ;  $  TAB2 output 1 ;  $  TAB1 else ;  $  TAB2 output (n / 2) + 1 ;
TAB1 create integer n ;  $  TAB1 while read n is true, print n / 2 + 1 print newline ;
TAB1 declare int n ;  $  TAB1 read from the input to n ;  $  TAB1 print n / 2 + 1 and '\n' ;
TAB0 create const long long int MOD = 1000000007 ;  $  TAB0 create long long ints N, M, K, H, W, L and R ;  $  TAB1 read from the input to N ;  $  TAB1 print N / 2 + 1 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print n / 2 + 1 and a new line ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print n / 2 + 1 and a new line ;
TAB0 a = integer ;  $  TAB1 Read a ;  $  TAB1 print a / 2 + 1 and a new line ;
TAB1 num =integer ;  $  TAB1 Read num ;  $  TAB1 print (num / 2) + 1 and a new line ;
TAB1 create integer n ;  $  TAB1 read input to n ;  $  TAB1 print n / 2 + 1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 print n/2 +1 ;
TAB0 pi = const double with pi = 2 * acos of 0.0 ;  $  TAB0 maxn = const int with maxn = 2e2 + 10 ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 set n to n / 2 ;  $  TAB1 print n + 1 ;
TAB1 create unsigned long integer i, j, n, sum with sum = 0 ;  $  TAB1 read n ;  $  TAB1 set sum to n / 2 + 1 ;  $  TAB1 print sum print newline ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 output n / 2 + 1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 print n divided by 2 +1 ;
TAB0 n, k, s, p = integers ;  $  TAB1 read n ;  $  TAB1 print n/2 + 1 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print (n / 2) + 1 and a new line ;
TAB1 create integers n and m ;  $  TAB1 read n ;  $  TAB1 set m to n divided by 2 ;  $  TAB1 print m +1 ;
TAB0 integers = n ;  $  TAB1 read n ;  $  TAB1 output n / 2 + 1 ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 if n is 1 then do the following ;  $  TAB2 output 1 ;  $  TAB1 else ;  $  TAB2 output n / 2 + 1 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 print n / 2 + 1 and newline ;
TAB1 n, ans = long long with ans = 2 ;  $  TAB1 read n ;  $  TAB1 if n is 1 ;  $  TAB2 print 1 ;  $  TAB1 if n is 2 or n is 3 ;  $  TAB2 print 2 ;  $  TAB1 print n / 2 + 1 ;
TAB0 declare constant double PI to 2 times the arccosine of 0 ;  $  TAB0 declare constant int MOD to be 1e9 + 7 ;  $  TAB0 declare constant int oo to be 2 * MOD plus 1e3 ;  $  TAB0 declare function long long gcd of long long a, long long b ;  $  TAB1 if not b, return a, and if b, return gcd of b and a mod b ;  $  TAB1 declare int n ;  $  TAB1 input n ;  $  TAB1 output n over 1 plus 1 and a newline ;
TAB0 PI = const double with PI = acos of -1.0 ;  $  TAB0 eps = const double with eps = 1e-6 ;  $  TAB0 INF = const int with INF = 0x3f3f3f3f ;  $  TAB0 maxn = const int with maxn = 100 ;  $  TAB0 T, n, m = int ;  $  TAB1 loop while reading n print n / 2 + 1 ;
TAB1 integers = long int n ;  $  TAB1 read n ;  $  TAB1 output (n / 2 + 1) ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print n / 2 + 1 and a new line ;
TAB0 set inf = 205 ;  $  TAB0 let a[inf] be int array ;  $  TAB0 create int array b[inf] ;  $  TAB1 create int m, n, k, t, x ;  $  TAB1 while read n, print n/2 +1 ;
TAB0 set long long n, m, a, b, x, ff to 2e7 + 1, l, r, cnt, ans ;  $  TAB0 make a vector using long long integer out of v,f,and res ;  $  TAB0 s1, s2 = string ;  $  TAB0 used array of 1001 = long long integers ;  $  TAB1 read n ;  $  TAB1 output n / 2 + 1 ;
TAB1 n, k =integers ;  $  TAB1 Read n ;  $  TAB1 set k to n / 2 ;  $  TAB1 increment k ;  $  TAB1 print k and a new line ;
TAB0 n = long long integers ;  $  TAB1 read n ;  $  TAB1 output n / 2 + 1 ;
TAB1 integers = a ;  $  TAB1 while input of a output (a / 2) + 1 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print n / 2 + 1 and a new line ;
TAB1 n, b =integers ;  $  TAB1 Read n ;  $  TAB1 set b to n / 2 + 1 ;  $  TAB1 print b and a new line ;
TAB0 n = integer ;  $  TAB1 Read n ;  $  TAB1 print n / 2 + 1 and a new line ;
TAB1 n, ans =integers ;  $  TAB1 while reading values n ;  $  TAB2 set ans to n / 2 + 1 ;  $  TAB2 print ans and a new line ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 print n / 2 + 1 print "\n" ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 output n / 2 + 1 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print (n / 2) + 1 and a new line ;
TAB0 = long long integers ;  $  TAB1 read n ;  $  TAB2 integers = m,ans ;  $  TAB2 set m to n / 2 ;  $  TAB2 set ans to m + 1 ;  $  TAB2 output ans ;
TAB1 create integer n ;  $  TAB1 read n and print n / 2 + 1 in a loop ;
TAB0 N = integer ;  $  TAB1 Read N ;  $  TAB1 print N / 2 + 1 and a new line ;
TAB1 declare integer n ;  $  TAB1 read from the input to n ;  $  TAB1 print (n + 2) / 2 ;
TAB1 num =integer ;  $  TAB1 Read num ;  $  TAB1 print num / 2 + 1 and a new line ;
TAB1 declare integers n and ans with ans = 0 ;  $  TAB1 read n and keep looping, printing n / 2 + 1 on each iteration ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 print n / 2 + 1 print '\n' ;
TAB0 declare 2d int array dp with size 5000 by 5 ;  $  TAB0 declare integer arrays s and c with size 5000 ;  $  TAB1 create int n ;  $  TAB1 read input to n ;  $  TAB1 print n / 2 + 1 ;
TAB1 declare long longs n and ans where ans = 2 ;  $  TAB1 read from the input to n ;  $  TAB1 if n = 1 ;  $  TAB2 print 1 ;  $  TAB1 if n is 2 or n is 3 ;  $  TAB2 print 2 ;  $  TAB1 print n / 2 + 1 ;
TAB1 declare an uninitialized integer n and initialize integer count to zero ;  $  TAB1 read n ;  $  TAB1 print the value of n with one added after being divided by two and a newline ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 print n / 2 + 1 and a new line ;
TAB1 l, r, x, y, k = long long ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for long long i = x to y inclusive ;  $  TAB2 if i*k >= l and di* k < = r ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB1 declare long long variables z, x, c, v and b ;  $  TAB1 read standard input to z, x, c, v and b ;  $  TAB1 create new boolean cek with value false ;  $  TAB1 in a for loop, change q from c to v inclusive ;  $  TAB2 declare long long variable asd = q * b ;  $  TAB2 if asd >= z and asd <= x, assign the new value = true to cek ;  $  TAB1 if cek = true ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" to the standard output ;
TAB1 l, r, x, y, k, flag = long long integers with flag = 0 ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for j = x to y ;  $  TAB2 if ((k * j) >= l and (k * j) <= r), flag = 1 ;  $  TAB1 if (flag) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create long long l, r, x, y, k, i, j, c, c=0 ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for j=x to y inclusive ;  $  TAB2 if k * j <= r and k * j >= l ;  $  TAB3 print YES ;  $  TAB3 c=1 ;  $  TAB3 break ;  $  TAB1 if c=0, print NO ;
TAB1 let l, r, x, y, and k long long ints ;  $  TAB1 let exist a bool with value false ;  $  TAB1 read l, r, x, y, and k ;  $  TAB1 for i from x to y ;  $  TAB2 if i * k at most r and i * k at least l ;  $  TAB3 set exist to true ;  $  TAB3 leave loop ;  $  TAB1 if exist ;  $  TAB2 print YES ;  $  TAB1 otherwise ;  $  TAB2 print NO ;
TAB0 let l, r, x, y, k be long integers ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 let i be a long integer ;  $  TAB1 let ok be an integer which equals 0 ;  $  TAB1 for i = x to y inclusive ;  $  TAB2 if l <= i * k and r >= i * k, ok = 1 ;  $  TAB1 if ok is true ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB1 l,r,x,y,k=long long ;  $  TAB1 read l,r,x,y,k ;  $  TAB1 for i=x to y inclusive ;  $  TAB2 if k*i>=l and k*i<=r ;  $  TAB3 print YES ;  $  TAB3 goto end ;  $  TAB1 print NO ;  $  TAB0 label end ;
TAB1 let l, r, x, y, k be integers ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for integer i is equal to l, j is equal to x, i <= r and j <= y ;  $  TAB2 if i / j is equal to k and i modulo j is equal to 0 ;  $  TAB3 print YES and newline ;  $  TAB2 else if i / j >= k ;  $  TAB3 increment j by 1 ;  $  TAB2 else do the following ;  $  TAB3 increment i by 1 ;  $  TAB1 print NO and newline ;
TAB1 let l, r, x, and y be doubles ;  $  TAB1 let k be a double ;  $  TAB1 let flag be a boolean, set flag to false ;  $  TAB1 read in l, r, x, y, and k ;  $  TAB1 for i = 0 iterate until i <= y ;  $  TAB2 if k * i <= r and k * i >= l, set flag to true ;  $  TAB1 if flag is true ;  $  TAB2 print YES ;  $  TAB1 or else ;  $  TAB2 print NO ;
TAB1 l, r, x, y, k = long long ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 flag = 0 = int ;  $  TAB1 for i = x to y inclusve ;  $  TAB2 if i * k >= 1 and i * k <= r ;  $  TAB3 set flag to 1 ;  $  TAB3 exit loop ;  $  TAB1 if flag ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create long long int l, r, x, y, k ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 found = false ;  $  TAB1 for b=x to y inclusive ;  $  TAB2 set a = k*b ;  $  TAB2 if a >= 1 and a <= r ;  $  TAB3 set found to true ;  $  TAB3 break ;  $  TAB1 if found different from 0 ;  $  TAB2 print YES ;  $  TAB3 print a newline ;  $  TAB1 else ;  $  TAB2 print NO ;  $  TAB3 print a newline ;
TAB1 l, r, x, y, k = long long int ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for i = x to i <= y ;  $  TAB2 if i*k >= 1 and i*k <= r ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB0 create new constant integer maxn = 15 ;  $  TAB0 declare new cons integer called inf = 0x3f3f3f3f ;  $  TAB0 declare new constant double eps with value 1e-10 ;  $  TAB1 declare doubles l, r, x, y and k ;  $  TAB1 read standard input to l, r, x, y and k ;  $  TAB1 if r < k * x or l > k * y ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 start for loop from i = x to y inclusive incrementing i ;  $  TAB3 if i * k >= l and i * k <= r ;  $  TAB4 print "YES" to the standard output ;  $  TAB2 print "NO" ;
TAB0 let maxn a constant long long int with value 2e5 + 3 ;  $  TAB1 let l, r, x, y, k, t long long ints with t = 0 ;  $  TAB1 read l, r, x, y, and k ;  $  TAB1 for long long int i from x to y ;  $  TAB2 if i * k at least l and i * k at most r ;  $  TAB3 set t to 1 ;  $  TAB3 leave loop ;  $  TAB1 if t ;  $  TAB2 print YES ;  $  TAB1 otherwise ;  $  TAB2 print NO ;
TAB1 declare long longs l, r, x, y, k ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 if l is greater than k * y or r is less than k * x ;  $  TAB2 print "NO", newline ;  $  TAB1 for i = l to r inclusive ;  $  TAB2 for j = x to y inclusive ;  $  TAB3 if i is greater than k * y or i is less than k * x ;  $  TAB4 end loop ;  $  TAB3 else if i is k * j ;  $  TAB4 print "YES" and newline ;  $  TAB1 print "NO" and newline ;
TAB0 declare integer array marked with size 101 ;  $  TAB1 declare long longs l, r, x, y, k ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for i = x to y inclusive ;  $  TAB2 if i * k is greater than or equal to l and i * k is less than or equal to r ;  $  TAB3 print "YES" and newline ;  $  TAB3 go to jump point pause ;  $  TAB1 print "NO" and newline ;  $  TAB0 mark jump point pause ;  $  TAB1 declare integer pause ;  $  TAB1 read pause ;
TAB1 create float a, s, d, f, g ;  $  TAB1 create int i and flag, set flag to 0 ;  $  TAB1 read a, s, d, f, g ;  $  TAB1 for i=d to f inclusive ;  $  TAB2 if i*g <= s and g*i >= a ;  $  TAB3 flag=1 ;  $  TAB3 break ;  $  TAB1 if flag different from 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO and a newline ;
TAB1 l, r, x, y, k =integers ;  $  TAB1 Read l, r, x, y, k ;  $  TAB1 for i = x to y exclusive ;  $  TAB2 if i * k is greater than or equal to l an i * k is less than or equal to r ;  $  TAB3 print YES and a new line ;  $  TAB1 print NO and a new line ;
TAB1 create long long l, r, x, y, k ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 while l <= r and x <= y ;  $  TAB2 if l / x < k ;  $  TAB3 increment l ;  $  TAB2 else if l/x=k ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 increment x ;  $  TAB1 print NO and a newline ;
TAB0 declare constant integer variable inf = 0x3f3f3f3f ;  $  TAB0 declare long ints l, r, x, y and k ;  $  TAB0 bool function find with long int arguments start and end ;  $  TAB1 create new long integer variable mid = (start + end) / 2 ;  $  TAB1 return false if start + 1 is equal to end ;  $  TAB1 if mid * k is greater than r ;  $  TAB2 if find(start,mid) returned true ;  $  TAB3 return true ;  $  TAB2 else ;  $  TAB3 return false ;  $  TAB1 else if mid * k is less than l ;  $  TAB2 if find(mid,end) returned true ;  $  TAB3 return true ;  $  TAB2 else ;  $  TAB3 return false ;  $  TAB1 else ;  $  TAB2 return true ;  $  TAB1 create long long ints a, b, c, d and e ;  $  TAB1 read input to a, b, c, d and e ;  $  TAB1 for i = c to d inclusive incrementing i ;  $  TAB2 declare new long long num with value i*e ;  $  TAB2 if num >= a and num <= b ;  $  TAB3 print "YES" ;  $  TAB2 else if num is greater than b ;  $  TAB3 break ;  $  TAB1 print "NO" ;
TAB1 create long long l, r, x, y, k ;  $  TAB1 read l, r, x, y, k ;  $  TAB1 for b=x to y inclusive ;  $  TAB2 set a to k*b ;  $  TAB2 if a>=1 and a<=r ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB1 l,r,x,y=int ;  $  TAB1 k=float ;  $  TAB1 flag=0 ;  $  TAB1 read l,r,x,y,k ;  $  TAB1 for i=x to y inclusive ;  $  TAB2 if l<=k*i and k*i>=r flag=1 ;  $  TAB1 if flag ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create ints n and k ;  $  TAB1 read n and k and while they're truthy ;  $  TAB2 create int a = n * 2 / k + (n * 2 % k == 0 ? 0 : 1) ;  $  TAB2 make integer b = n * 5 / k + (n * 5 % k == 0 ? 0 : 1) ;  $  TAB2 let int c = n * 8 / k + (n * 8 % k == 0 ? 0 : 1) ;  $  TAB2 show the result of a + b + c ;
TAB1 make ints n and k ;  $  TAB1 read n and k ;  $  TAB1 create integer red = n * 2 / k ;  $  TAB1 make int green = n * 5 / k ;  $  TAB1 let int blue = n * 8 / k ;  $  TAB1 if red is less than n * 2.0 / k, set red to red + 1 ;  $  TAB1 if green is less than n * 5.0 / k, add 1 to green ;  $  TAB1 if blue is less than n * 8.0 / k, increase blue by 1 ;  $  TAB1 print the result of red + green + blue ;
TAB0 let n , k be long integers ;  $  TAB1 read n , k ;  $  TAB1 let ans be a long integer with ans = 0LL ;  $  TAB1 ans is equal to (n * 2LL) / k + (n * 2LL modulo k is not equal to 0) ;  $  TAB1 increment ans by (n * 5LL) / k + (n * 5LL modulo k is not equal to 0) ;  $  TAB1 increment ans by (n * 8LL) / k + (n * 8LL modulo k is not equal to 0) ;  $  TAB1 print ans and newline ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 sum = integer with 0 ;  $  TAB1 if n * 2 modulo k is 0 ;  $  TAB2 set sum to sum + n * 2 / k ;  $  TAB1 else do the following ;  $  TAB2 set sum to sum + n * 2 / k + 1 ;  $  TAB1 if n * 5 modulo k is 0 ;  $  TAB2 set sum to sum + n * 5 / k ;  $  TAB1 else do the following ;  $  TAB2 set sum to sum + n * 5 / k + 1 ;  $  TAB1 if n * 8 modulo k is 0 ;  $  TAB2 set sum to sum + n * 8 / k ;  $  TAB1 else do the following ;  $  TAB2 set sum to sum + n * 8 / k + 1 ;  $  TAB1 print sum and a new line ;
TAB1 n,k,red,green,blue,notebooks = long long integers ;  $  TAB1 read n,k ;  $  TAB1 set red to 2 * n ;  $  TAB1 set green to 5 * n ;  $  TAB1 set blue to 8 * n ;  $  TAB1 set notebooks to (red / k) + (green / k) + (blue / k) ;  $  TAB1 if red modulo k is not equal to 0 then do the following notebooks += 1 ;  $  TAB1 if green modulo k is not equal to 0 then do the following notebooks += 1 ;  $  TAB1 if blue modulo k is not equal to 0 then do the following notebooks += 1 ;  $  TAB1 write notebooks value ;
TAB1 p, q, lal, sobuj, nil = integers ;  $  TAB1 read p, q ;  $  TAB1 lal = ceil((p * 2) / q) ;  $  TAB1 sobuj = ceil((p * 5) / q) ;  $  TAB1 nil = ceil((p * 8) / q) ;  $  TAB1 mot = integer with mot = lal + sobuj + nil ;  $  TAB1 print mot ;
TAB1 n, k = int ;  $  TAB1 res, cur = int ;  $  TAB1 read n then k ;  $  TAB1 set res to 0 ;  $  TAB1 set cur to 2 * n ;  $  TAB1 increment res by (cur + k - 1) / k ;  $  TAB1 set cur to n * 5 ;  $  TAB1 increment res by (cur + k - 1) / k ;  $  TAB1 set cur to n * 8 ;  $  TAB1 increment res by (cur + k - 1) / k ;  $  TAB1 print res ;
TAB0 declare integer divUp ;  $  TAB1 return a / b + ( 1 if a % b is greater than 0, else 0) ;  $  TAB1 declare integers n, k ;  $  TAB1 read n and k ;  $  TAB1 print result of run divUp with 2 * n, k as arguments + result of run divUp(5 * n, k) + result of run divUp(8 * n, k), newline ;
TAB1 make doubles n and k ;  $  TAB1 read n and k ;  $  TAB1 create long long ints red = n * 2, green = n * 5, and blue = n * 8 ;  $  TAB1 display (long long)(ceil(red / k) + ceil(green / k) + ceil(blue / k)) ;
TAB0 create long long constant inf = 1e16 ;  $  TAB0 new long long constant MAXN with value 1e6 ;  $  TAB0 declare new double constant variable pi = acos of -1 ;  $  TAB0 declare new long longs n, k and ans ;  $  TAB1 read from the input to n and k ;  $  TAB1 decrement k by one ;  $  TAB1 change ans to ans + (n * 2 + k) / (k + 1) ;  $  TAB1 change ans to the sum of ans and (n * 5 + k) / (k + 1) ;  $  TAB1 add (n * 8 + k) / (k + 1) to ans ;  $  TAB1 print ans to the standard output ;
TAB1 create long long ints sum = 0, a, and b ;  $  TAB1 read a and b ;  $  TAB1 if (a * 2) % b is equal to 0 ;  $  TAB2 add (a * 2) / b to sum ;  $  TAB1 otherwise ;  $  TAB2 add ((a * 2) / b) + 1 to sum ;  $  TAB1 if (a * 5) % b is equal to 0 ;  $  TAB2 set sum to sum + (a * 5) / b ;  $  TAB1 else do ;  $  TAB2 set sum to sum + ((a * 5) / b) + 1 ;  $  TAB1 if (a * 8) % b is equal to 0 ;  $  TAB2 set sum to sum + (a * 8) / b ;  $  TAB1 else do ;  $  TAB2 set sum to sum + ((a * 8) / b) + 1 ;  $  TAB1 show sum ;
TAB1 create long longs n and k ;  $  TAB1 loop, reading n and k from the input ;  $  TAB2 declare new long longs sum1, sum2 and sum3 ;  $  TAB2 set sum1 to 2 * n / k ;  $  TAB2 if 2 * n % k != 0, add 1 to sum1 ;  $  TAB2 assign 5 * n / k to sum2 ;  $  TAB2 if 5 * n modulo k is not 0, increment sum2 ;  $  TAB2 change sum3 to 8 * n / k ;  $  TAB2 if 8 * n modulo k != 0, increment sum3 by one ;  $  TAB2 print sum1 + sum2 + sum3 ;
TAB0 n, k, ans = long ;  $  TAB0 in the function sheets that takes long a, b and returns long ;  $  TAB1 d, m = long ;  $  TAB1 d = a / b ;  $  TAB1 m = a modulo b ;  $  TAB1 if (m), return (d + 1) ;  $  TAB1 return d ;  $  TAB1 read n, k ;  $  TAB1 ans = ans + sheets(2 * n, k) ;  $  TAB1 ans = ans + sheets(5 * n, k) ;  $  TAB1 ans = ans + sheets(8 * n, k) ;  $  TAB1 print ans ;
TAB1 n, k, a, b, c, x, y, z, s =integers ;  $  TAB1 Read n and k ;  $  TAB1 set a to n * 2 ;  $  TAB1 set b to n * 5 ;  $  TAB1 set c to n * 8 ;  $  TAB1 if a is less than k ;  $  TAB2 set x to 1 ;  $  TAB1 else do the following ;  $  TAB2 if a modulo k is 0 ;  $  TAB3 set x to a / k ;  $  TAB2 else do the following ;  $  TAB3 set x to (a / k) + 1 ;  $  TAB1 if b is less than k ;  $  TAB2 set y to 1 ;  $  TAB1 else do the following ;  $  TAB2 if b modulo k is 0 ;  $  TAB3 set y to b / k ;  $  TAB2 else do the following ;  $  TAB3 set y to (b / k) + 1 ;  $  TAB1 if c is less than k ;  $  TAB2 set z to 1 ;  $  TAB1 else do the following ;  $  TAB2 if c modulo k is 0 ;  $  TAB3 set z to c / k ;  $  TAB2 else do the following ;  $  TAB3 set z to (c / k) + 1 ;  $  TAB1 set s to x + y + z ;  $  TAB1 print s and a new line ;
TAB1 n, k, r = integer ;  $  TAB1 read n, k ;  $  TAB1 r = ((2 * n) / k) + ((5 * n) / k) + ((8 * n) / k) ;  $  TAB1 if (2 * n) modulo k is not 0, increase r by 1 ;  $  TAB1 if (5 * n) modulo k is not 0, increase r by 1 ;  $  TAB1 if (8 * n) modulo k is not 0, increase r by 1 ;  $  TAB1 print r ;
TAB1 s, n and k are integers with s = 0 ;  $  TAB1 read n and k from the user input ;  $  TAB1 if (8 * n) modulo k = 0 ;  $  TAB2 assign the new value = s + 8 * n / k to s ;  $  TAB1 else ;  $  TAB2 change s to s + 8 * n / k + 1 ;  $  TAB1 if (2 * n) % k is equal to 0 ;  $  TAB2 assign s + 2 * n / k to s ;  $  TAB1 else ;  $  TAB2 assign s + 2 * n / k + 1 to s ;  $  TAB1 if (5 * n) modulo k is 0 ;  $  TAB2 assign the new value = s + 5 * n / k to s ;  $  TAB1 else ;  $  TAB2 change the value of s to s + 5 * n / k + 1 ;  $  TAB1 print s ;
TAB1 n, k =integers ;  $  TAB1 ans, asn = integers ;  $  TAB1 Read n, k ;  $  TAB1 set ans to 0 ;  $  TAB1 set asn to n * 2 ;  $  TAB1 set ans to ans + (asn + k - 1) / k ;  $  TAB1 set asn to n * 5 ;  $  TAB1 set ans to ans + (asn + k - 1) / k ;  $  TAB1 set asn to n * 8 ;  $  TAB1 set ans to ans + (asn + k - 1) / k ;  $  TAB1 print ans and a new line ;
TAB1 n, k, red, green, blue =integers ;  $  TAB1 Read n and k ;  $  TAB1 set red to 2 * n ;  $  TAB1 set green to 5 * n ;  $  TAB1 set blue to 8 * n ;  $  TAB1 if red modulo k is 0 ;  $  TAB2 set red to red / k ;  $  TAB1 else do the following ;  $  TAB2 set red to red / k + 1 ;  $  TAB1 if green modulo k is 0 ;  $  TAB2 set green to green / k ;  $  TAB1 else do the following ;  $  TAB2 set green to green / k + 1 ;  $  TAB1 if blue modulo k is 0 ;  $  TAB2 set blue to blue / k ;  $  TAB1 else do the following ;  $  TAB2 set blue to blue / k + 1 ;  $  TAB1 print red + green + blue and a new line ;
TAB1 n, k, t, l, m, g =integers ;  $  TAB1 Read n and k ;  $  TAB1 if n * 2 modulo k is 0 ;  $  TAB2 set t to n * 2 / k ;  $  TAB1 else do the following ;  $  TAB2 set t to n * 2 / k + 1 ;  $  TAB1 if n * 5 modulo k is 0 ;  $  TAB2 set l to n * 5 / k ;  $  TAB1 else do the following ;  $  TAB2 set l to n * 5 / k + 1 ;  $  TAB1 if n * 8 modulo k is 0 ;  $  TAB2 set m to n * 8 / k ;  $  TAB1 else do the following ;  $  TAB2 set m to n * 8 / k + 1 ;  $  TAB1 set g to m + l + t ;  $  TAB1 print g and a new line ;
TAB1 create ints n and a ;  $  TAB1 make ints ans and cnt ;  $  TAB1 read n and a ;  $  TAB1 set ans to 0 ;  $  TAB1 set cnt to n * 2 ;  $  TAB1 set ans to ans + (cnt + a - 1) / a ;  $  TAB1 set cnt to n * 5 ;  $  TAB1 add (cnt + a - 1) / a to ans ;  $  TAB1 set cnt to n * 8 ;  $  TAB1 set ans to ans + (cnt + a - 1) / a ;  $  TAB1 show ans ;
TAB1 let n, k be integers ;  $  TAB1 read n, k ;  $  TAB1 let red , green , blue be integers with red = 0, green = 0, blue = 0 ;  $  TAB1 let bookred , bookgreen , bookblue be integers with bookred = 0, bookgreen = 0, bookblue = 0 ;  $  TAB1 red is equal to n * 2 ;  $  TAB1 green is equal to n * 5 ;  $  TAB1 blue is equal to n * 8 ;  $  TAB1 if red modulo k is equal to 0 ;  $  TAB2 bookred is equal to red / k ;  $  TAB1 else do the following ;  $  TAB2 bookred is equal to red / k + 1 ;  $  TAB1 if blue modulo k is equal to 0 ;  $  TAB2 bookblue is equal to blue / k ;  $  TAB1 else do the following ;  $  TAB2 bookblue is equal to blue / k + 1 ;  $  TAB1 if green modulo k is equal to 0 ;  $  TAB2 bookgreen is equal to green / k ;  $  TAB1 else do the following ;  $  TAB2 bookgreen is equal to green / k + 1 ;  $  TAB1 let total be a integer with total is equal to 0 ;  $  TAB1 total is equal to bookred + bookblue + bookgreen ;  $  TAB1 print total and newline ;
TAB0 function Ceil with int arguments n and k that returns int ;  $  TAB1 return (n + k - 1) / k ;  $  TAB1 declare new ints n and k ;  $  TAB1 read input to n and k ;  $  TAB1 ans is a new integer variable = Ceil(2 * n, k) + Ceil(5 * n, k) + Ceil(8 * n, k) ;  $  TAB1 print ans and '\n' ;
TAB0 a = int array of size 1010 ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 sort a from beginning to n ;  $  TAB1 i = int ;  $  TAB1 for i = n - 1 to 0 inclusive decrementing i ;  $  TAB2 b = int with b = sqrt of a[i] ;  $  TAB2 if b * b is a[i] ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 print a[i] ;
TAB1 create integers n, i, x, maxi, tem, flag, with maxi = -1000000007 ;  $  TAB1 create double p ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 set flag to 0 ;  $  TAB2 read x ;  $  TAB2 if x is less than 0 ;  $  TAB3 if x is greater than maxi, set maxi to x ;  $  TAB3 set flag to 1 ;  $  TAB2 if flag is 1, set x to -x ;  $  TAB2 set p to square root of ( x * 1.00 ) ;  $  TAB2 set tem to p ;  $  TAB2 if tem is not p and flag is not 1 ;  $  TAB3 if x is greater than maxi, set maxi to x ;  $  TAB1 print maxi print newline ;
TAB1 declare integer variables n and a ;  $  TAB1 read n ;  $  TAB1 create priority_queue of integers t ;  $  TAB1 for i from 0 to n exclusive ;  $  TAB2 read input to a ;  $  TAB2 declare int variable l = square root of a ;  $  TAB2 if l squared != a, push a into t ;  $  TAB1 print top element of t ;
TAB0 let INF be a constant integer with INF = 0x3f3f3f3f ;  $  TAB1 let i, j, k be integers ;  $  TAB1 let n, m, t be integers ;  $  TAB1 a = array of integers of length 1005 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive , read a[i] ;  $  TAB1 sort the values a and a + n ;  $  TAB1 let x be a integer with x = 0 ;  $  TAB1 for i is equal to n - 1, i greater than or equal to 0 , decrement i by 1 ;  $  TAB2 if a[i] is less than 0, stop ;  $  TAB1 if i is less than 0 ;  $  TAB2 the value of x is equal to 0 ;  $  TAB1 else do the following ;  $  TAB2 the value of x is equal to i ;  $  TAB1 for i is equal to n - 1 , i greater than x , decrement i by 1 ;  $  TAB2 if square root of a[i] - floor of square root of a[i] is greater than 0.000001 ;  $  TAB3 print a[i] and newline ;  $  TAB3 stop ;  $  TAB1 if i <= x , print a[x] and newline ;
TAB1 create integers n, i, j, x, ans ;  $  TAB1 create vector of integers vec ;  $  TAB1 while read n is not 0 ;  $  TAB2 for i = 0 to n inclusive ;  $  TAB3 read n ;  $  TAB3 add x to the end of vec ;  $  TAB2 sort vec ;  $  TAB2 let flag be an int = 0 ;  $  TAB2 for i = n - 1 to i 0 inclusive decrement 1 ;  $  TAB3 set ans to the square root of vec[i] ;  $  TAB3 set ans to ans squared ;  $  TAB3 if ans is different from vec[i] ;  $  TAB4 set flag to i ;  $  TAB4 exit loop ;  $  TAB2 print vec[flag] and new line ;
TAB0 create const int maxn = 1010 ;  $  TAB0 declare int n ;  $  TAB0 declare int array a with size maxn ;  $  TAB1 read n ;  $  TAB1 loop i from 0 to n exclusive, read a[i] ;  $  TAB1 sort a ;  $  TAB1 for i from n - 1 to 0 inclusive counting down ;  $  TAB2 if square root of a[i] * square root of a[i] != a[i] ;  $  TAB3 print a[i] ;  $  TAB3 stop the loop ;
TAB1 n, i, x = integers, ans = integer = -1000001 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if the square root of x to the power of 2 is not x and x > ans, then ans = x ;  $  TAB1 print ans ;
TAB0 maxn = const int with maxn = 1e3 + 5 ;  $  TAB0 arr = int array of size maxn ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 read n values into arr ;  $  TAB1 sort arr from beginning to n ;  $  TAB1 for i = n - 1 to 0 inclusive decrementing i ;  $  TAB2 if arr[i] is less than 0 ;  $  TAB3 print arr[i] ;  $  TAB2 temp = int with temp = arr[i] ;  $  TAB2 if floor of sqrt of temp is sqrt of temp ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 print arr[i] ;
TAB0 let t be integer ;  $  TAB0 let a be integer array with length 1005 ;  $  TAB0 function cmp with integer argument a and b returns boolean ;  $  TAB1 return a greater than b ;  $  TAB1 read t ;  $  TAB1 for i =1 to t inclusive read i element of array a ;  $  TAB1 call sort function on a +1, a + 1 + t, and cmp ;  $  TAB1 for i = 1 to t inclusive ;  $  TAB2 if ((int)sqrt(a[i]) * (int)sqrt(a[i]) is not equal to i element of array a ;  $  TAB3 print i element of array a ;  $  TAB3 break ;
TAB0 define Boolean function cmp, consuming pass-by-reference int constants A and B ;  $  TAB1 return A > B ;  $  TAB0 define 1,005-element int array num ;  $  TAB1 define int n ;  $  TAB1 read n ;  $  TAB1 for i from 0 to n (exclusive) by 1, read num[i] ;  $  TAB1 sort(num, num + n, cmp) ;  $  TAB1 define int i and set it to 0 ;  $  TAB1 for i from 0 to n (exclusive) by 1 ;  $  TAB2 define int p, set to squareroot of num[i] ;  $  TAB2 if p ^ 2 isn't num[i], then break ;  $  TAB1 print num[i] and newline ;
TAB0 create integer t ;  $  TAB0 create integer array a with size 1005 ;  $  TAB0 declare cmp with integers a, b as arguments, returning boolean ;  $  TAB1 return a is greater than b from function ;  $  TAB1 read t ;  $  TAB1 for i = 1 to t inclusive, read a[i] ;  $  TAB1 sort elements from a + 1 to a + 1 + t using cmp to compare ;  $  TAB1 for i = 1 to t inclusive ;  $  TAB2 if integer casted square root of a[i] * integer casted square root of a[i] is not a[i] ;  $  TAB3 print a[i] print newline ;  $  TAB3 break loop ;
TAB0 create integer array nums with size 1001 ;  $  TAB0 declare compare_int with integer addresses lhs, rhs as arguments, returning boolean ;  $  TAB1 return lhs is greater than rhs from function ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer max_num with max_num = 0 ;  $  TAB1 for currnum = 0 to n exclusive, read nums[currnum] ;  $  TAB1 sort elements from nums to nums + n using compare_int to compare ;  $  TAB1 create integer non_perfect with non_perfect = 0 ;  $  TAB1 for currnum = 0 to n exclusive ;  $  TAB2 create integer sqrtroot with sqrtroot = square root of nums[currnum] ;  $  TAB2 if sqrtroot * sqrtroot is not nums[currnum] ;  $  TAB3 set non_perfect to nums[currnum] ;  $  TAB3 break loop ;  $  TAB1 print non_perfect print newline ;
TAB0 declare check taking in integer x and returning integer ;  $  TAB1 if x is less than 0, return 1 ;  $  TAB1 create integer t = sqrt(x) ;  $  TAB1 if t * t is equal to x ;  $  TAB1 else ;  $  TAB2 return 1 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer a[1005] ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort array a ;  $  TAB1 for i = n - 1 to 0 ;  $  TAB2 if check(a[i]) returns truthy ;  $  TAB3 print a[i] ;  $  TAB3 break loop ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 a = array of 1005 integers ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 for i = n-1 to 0 exclusive ;  $  TAB2 t = integer, set to square root of a[i] ;  $  TAB2 if t * t is not a[i] ;  $  TAB3 print a[i] and a new line ;
TAB0 a = array of integers of length 2000005 ;  $  TAB1 let n, tmp be integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read tmp ;  $  TAB2 increment a[tmp + 1000000] by 1 ;  $  TAB1 let ans be integer with ans = 0 ;  $  TAB1 for i = 0 to 1000 inclusive, the value of a[i * i + 1000000] is equal to 0 ;  $  TAB1 for i = 0 to 2000005 exclusive ;  $  TAB2 if a[i] is true , the value of ans = i - 1000000 ;  $  TAB1 print ans and newline ;
TAB0 create integer array sq with size 1001 with sq = ;  $  TAB1 0 ;  $  TAB0 end statement ;  $  TAB0 declare check with integer x as argument, returning integer ;  $  TAB1 if not element between sq and sq + 1001 is x ;  $  TAB2 return 1 from function ;  $  TAB1 else ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer array a with size n ;  $  TAB1 for i = 0 to 1000 inclusive, set sq[i] to i * i ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 create integer m with m = INT_MIN ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is greater than m and result of run check with a[i] as argument is true, set m to a[i] ;  $  TAB1 print m print newline ;
TAB1 create integer array a with size 10000 ;  $  TAB1 for i = 0 to 1001 exclusive, set a[i] to i * i ;  $  TAB1 create integer b create integer array c with size 10000 ;  $  TAB1 read b ;  $  TAB1 for i = 0 to b exclusive, read c[i] ;  $  TAB1 sort elements form c to c + b ;  $  TAB1 for i = b - 1 to -1 exclusive, decrementing i ;  $  TAB2 for j = 0 to 1001 exclusive ;  $  TAB3 if c[i] is a[j], go to jump point momo ;  $  TAB2 print c[i] print newline ;  $  TAB1 mark jump point momo ;
TAB0 create integer array a with size 1005 ;  $  TAB0 create map mp from integer to integer ;  $  TAB0 create constant double eps with eps = 1e-8 ;  $  TAB0 declare init with no arguments, returning void ;  $  TAB1 for i = 0 to 1000 inclusive, set mp[i*i] to 1 ;  $  TAB1 run init ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort elements from a to a + n ;  $  TAB1 for i = n - 1 to 0 inclusive, decrementing i ;  $  TAB2 if not mp[a[i]] ;  $  TAB3 print a[i] print newline ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 arr=vector of int ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 temp=int ;  $  TAB2 read temp ;  $  TAB2 add temp at end of arr ;  $  TAB1 sort arr ;  $  TAB1 for i=n-1 down to 0 inclusive ;  $  TAB2 s=sqrt(arr[i]) ;  $  TAB2 if s^2 not equal arr[i] ;  $  TAB3 print arr[i] ;  $  TAB3 break ;
TAB1 create int A, B, C, D ;  $  TAB1 read A, B, C, D ;  $  TAB1 if (A * 2 + 3 > D and D + 1 >= A) or (B * 2 + 3 > C and C + 1 >= B) ;  $  TAB2 print YES ;  $  TAB1 otherwise ;  $  TAB2 print NO and a new line ;
TAB1 let A, B, C, D be integers ;  $  TAB1 read A, B, C, D ;  $  TAB1 if ((A * 2 + 3 is greater than D and D + 1 is greater than or equal to A) or (B * 2 + 3 is greater than C and C + 1 is greater than or equal to B)) ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 let boolean solve(int a, int b) be a function which accepts integers a and b and returns integer values ;  $  TAB1 return the value of ( a is less than or equal to b + 1 and b is less than or equal to (a + 1) * 2) ;  $  TAB1 let la, ra, lb, rb be integers ;  $  TAB1 read la, ra, lb, rb ;  $  TAB1 if (solve(la, rb) or solve(ra, lb)) ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB1 declare integers gl, gr, bl and br ;  $  TAB1 read gl, gr, bl and br ;  $  TAB1 if 2 * (gl + 1) >= br && gl - 1 <= br || 2 * (gr + 1) >= bl && gr <= bl ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create integers a, s, z, x ;  $  TAB1 read a read s read z read x ;  $  TAB1 create boolean cek with cek = false ;  $  TAB1 if ( x is greater than or equal to a - 1 and x is less than or equal to a * 2 + 2 ) or ( z is greater than or equal to s - 1 and z is less than or equal to s * 2 + 2 ) , set cek to true ;  $  TAB1 if cek is true ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 declare integers l, r, ml and mr ;  $  TAB0 judge is a boolean function with integer arguments g and b ;  $  TAB1 if b is less than g - 1 ;  $  TAB2 return false ;  $  TAB1 else if b is greater than 2 * g + 2 ;  $  TAB2 return false ;  $  TAB1 else ;  $  TAB2 return true ;  $  TAB1 read l, r, ml and mr ;  $  TAB1 if judge(l, mr) or judge(r, ml) are true ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 let a, b, c, d be long integers ;  $  TAB1 while ( read the values a,b,c,d ) ;  $  TAB2 let ck be a long integer with value as 0 ;  $  TAB2 let a1 be a long integer with value as a1 is equal to a * 2 + 2 ;  $  TAB2 let a2 be a long integer with value a2 is equal to a-1 ;  $  TAB2 if (d is greater than or equal to a2 and d is less than or equal to a1) , ck is equal to 1 ;  $  TAB2 let a1 is equal to ( b * 2 + 2) ;  $  TAB2 let a2 is equal to b - 1 ;  $  TAB2 if (c is greater than or equal to a2 and c is less than or equal to a1), ck is equal to 1 ;  $  TAB2 if (ck is equal to 1) ;  $  TAB3 print YES and newline ;  $  TAB2 else do the following ;  $  TAB3 print NO and newline ;
TAB1 create long longs gl, gr, bl, br ;  $  TAB1 read gl read gr read bl read br ;  $  TAB1 if br is greater than or equal to gl - 1 and br is less than or equal to 2 * ( gl + 1 ) ;  $  TAB2 print "YES" print newline ;  $  TAB1 if bl is greater than or equal to gr - 1 and bl is less than or equal to 2 * ( gr + 1 ) ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 create integers gl, gr, bl, br ;  $  TAB1 read gl read gr read bl read br ;  $  TAB1 if gl - 1 is less than or equal to br and br is less than or equal to 2 * gl + 2 ;  $  TAB2 print "YES" print '\n' ;  $  TAB1 else if gr - 1 is less than or equal to bl and bl is less than or equal to 2 * gr + 2 ;  $  TAB2 print "YES" print '\n' ;  $  TAB1 else ;  $  TAB2 print "NO" print '\n' ;
TAB1 create integers A, B, C, D ;  $  TAB1 read A read B read C read D ;  $  TAB1 if ( A * 2 + 3 is greater than D and D + 1 is greater than or equal to A ) or ( B * 2 + 3 is greater than C and C + 1 is greater than or equal to B ) ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 create integers a1, a2, a11, a12, b1, b2, b11, b12 ;  $  TAB1 read b1 read b2 read a1 read a2 ;  $  TAB1 if a1 % 2 is 0 ;  $  TAB2 set a11 to a1 / 2 - 1 ;  $  TAB1 else ;  $  TAB2 set a11 to a1 / 2 ;  $  TAB1 if a2 % 2 is 0 ;  $  TAB2 set a12 to a2 / 2 - 1 ;  $  TAB1 else ;  $  TAB2 set a12 to a2 / 2 ;  $  TAB1 set b11 to b1 - 1 ;  $  TAB1 set b12 to b2 - 1 ;  $  TAB1 if b12 is less than or equal to a1 and a11 is less than or equal to b2 or a12 is less than or equal to b1 and b11 is less than or equal to a2 ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 create integers vl, vr, ml and mr ;  $  TAB0 boolean function judge with integer arguments g and b ;  $  TAB1 if b is less than g - 1 ;  $  TAB2 return false ;  $  TAB1 else if b is greater than 2 * g + 2 ;  $  TAB2 return false ;  $  TAB1 else ;  $  TAB2 return true ;  $  TAB1 read vl, vr, ml and mr ;  $  TAB1 if either judge(vl, mr) or judge(vr, ml) is true ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create integers b, bb, g, gg, yes, with yes = 0 ;  $  TAB1 read g read gg read b read bb ;  $  TAB1 if g is less than or equal to bb + 1 and bb is less than or equal to (g + 1) * 2, set yes to 1 ;  $  TAB1 if gg is less than or equal to b + 1 and b is less than or equal to (gg+1) * 2, set yes to 1 ;  $  TAB1 if yes is true ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 create integers A, B, C, D ;  $  TAB1 read A read B read C read D ;  $  TAB1 if (A * 2 + 3 is greater than D and D + 1 is greater than or equal to A ) or ( B * 2 + 3 is greater than C and C + 1 is greater than or equal to B ) ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 M = constant integer = 1000 + 5 ;  $  TAB1 create int gl, gr ;  $  TAB1 read gl and gr ;  $  TAB1 bl, br = integers ;  $  TAB1 read bl and br ;  $  TAB1 create boolean ok = false ;  $  TAB1 if gr - 1 is equal to or less than bl and bl is equal to or less than 2 * (gr+1), set ok = true ;  $  TAB1 if gl - 1 is equal to or less than br and br is equal to or less than 2 * (gl+1), set ok = true ;  $  TAB1 if ok is true ;  $  TAB2 print YES ;  $  TAB1 otherwise ;  $  TAB2 print NO ;
TAB0 declare integers vl, vr, ml and mr ;  $  TAB0 boolean function judge with integer arguments g and b ;  $  TAB1 if b is less than g - 1 ;  $  TAB2 return false ;  $  TAB1 else if b is greater than 2 * g + 2 ;  $  TAB2 return false ;  $  TAB1 else ;  $  TAB2 return true ;  $  TAB1 read vl, vr, ml and mr ;  $  TAB1 if judge(vl, mr) or judge(vr, ml) ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 declare check with integers d, m as arguments, returning boolean ;  $  TAB1 if m is less than or equal to 2 * ( d + 1 ) and ( m is greater than or equal to d - 1 ), return 1 from function ;  $  TAB1 create integers l1, r1, l2, r2 ;  $  TAB1 read l1 read r1 read l2 read r2 ;  $  TAB1 if result of run check with l1, r2 as arguments or result of run check with r1, l2 as arguments ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 let INF be a constant integer with value as INF = 0x3f3f3f3f ;  $  TAB1 let i,j,k be integers ;  $  TAB1 let n,m be integers ;  $  TAB1 let a,b,c,d be integers ;  $  TAB1 read a,b,c,d ;  $  TAB1 if ((c - (b - 1)) is less than 5 and c - b + 1 is greater than or equal to 0) ;  $  TAB2 print YES and newline ;  $  TAB1 if ((d - (a - 1)) is less than 5 and d - a + 1 is greater than or equal to 0) ;  $  TAB2 print YES and newline ;  $  TAB1 if ((c - (b - 1) * 2) is less than 5 and c - (b - 1) is greater than or equal to 0) ;  $  TAB2 print YES and newline ;  $  TAB1 if ((d - (a - 1) * 2) is less than 5 and d - (a - 1) is greater than or equal to 0) ;  $  TAB2 print YES and newline ;  $  TAB1 print NO and newline ;
TAB1 create integers gl, gr, bl, br ;  $  TAB1 create boolean verdict ;  $  TAB1 read gl read gr read bl read br ;  $  TAB1 if 2 * ( gl + 1 ) is greater than or equal to br and gl - 1 is less than or equal to br or 2 * ( gr + 1 ) is greater than or equal to bl and gr is less than or equal to bl ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB0 integer function pan with integer arguments x and y ;  $  TAB1 if x = 0 return true if y < 2 or false otherwise ;  $  TAB1 if y = 0 return true if x < 3 or false otherwise ;  $  TAB1 if x = y return 1 ;  $  TAB1 if x is less than y ;  $  TAB2 if y - x <= 1 return 1 ;  $  TAB1 else ;  $  TAB2 if x / (y + 1) <= 2 ;  $  TAB3 if x / (y + 1) = 1 return 1 ;  $  TAB3 if x / (y + 1) = 2 ;  $  TAB4 if x modulo (y + 1) is less than 1 return 1 ;  $  TAB1 declare integers a, b, x and y ;  $  TAB1 read a, b, x and y ;  $  TAB1 if pan(x, b) or pan(y, a) is not 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 function fp with long long arguments n and p that returns long long ;  $  TAB1 if p is 0, return 1 ;  $  TAB1 if p is 1, return n ;  $  TAB1 create long long res ;  $  TAB1 res = fp(n, p / 2) % int(1e9 + 7) ;  $  TAB1 res = (res * res) % int(1e9 + 7) ;  $  TAB1 if p % 2 > 0, set res = (res * n) % int(1e9 + 7) ;  $  TAB1 return res % int(1e9 + 7) ;  $  TAB0 function get with integer arguments a and b that returns integer ;  $  TAB1 while b <= 2011 ;  $  TAB2 declare integer variables dif = 0, t = b and tt = a ;  $  TAB2 while a > 0 and dif < 2 ;  $  TAB3 increment dif if a % 10 != b % 10 ;  $  TAB3 divide a and b by 10 ;  $  TAB2 set b = t, a = tt ;  $  TAB2 return bif dif is less than 2 ;  $  TAB2 increment b ;  $  TAB1 return 1e5 ;  $  TAB1 create integers a, b, c and d ;  $  TAB1 read a, b, c and d ;  $  TAB1 if a - 2 < d and d < 2 * a + 3 or b - 2 < c and c < 2 * b + 3 ;  $  TAB2 print "YES" and '\n' ;  $  TAB1 else ;  $  TAB2 print "NO" and '\n' ;
TAB1 create long longs gl, gr, bl, br ;  $  TAB1 read gl read gr read bl read br ;  $  TAB1 if br is greater than or equal to gl - 1 and br is less than or equal to 2 * ( gl + 1 ) ;  $  TAB2 print "YES" print newline ;  $  TAB1 if bl is greater than or equal to gr -1 and bl is less than or equal to 2 * ( gr + 1 ) ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 a, b, c, d = integers ;  $  TAB1 read a, b, c, d ;  $  TAB1 if (d >= a - 1 and d <= 2 * (a + 1)) or (c >= b - 1 and c <= 2 * (b + 1)) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n is a new integer variable ;  $  TAB1 read standard input to n ;  $  TAB1 create new vector of integers v with 2 * n elements ;  $  TAB1 read all elements from the input to the vector v ;  $  TAB1 sort v ;  $  TAB1 if v[n - 1] is less than v[n] ;  $  TAB2 print "YES\n" to the standard output ;  $  TAB1 else ;  $  TAB2 print "NO\n" to the standard output ;
TAB0 let n be an int ;  $  TAB0 let arr be an int vector of size 210 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2*n inclusive, increment i, read arr[i] ;  $  TAB1 sort form arr + 1 to arr + 2*n + 1 using greater<int> ;  $  TAB1 if arr[n] > arr[n + 1] ;  $  TAB2 print YES and ;  $  TAB3 new line ;  $  TAB1 else ;  $  TAB2 print NO and ;  $  TAB3 new line ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integer array a size n + n ;  $  TAB1 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB1 sort from a to a + n * 2 ;  $  TAB1 if a[n] is greater than a[n-1] ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 function read that returns inline integer ;  $  TAB1 declare new integers x = 0 and f = 1 ;  $  TAB1 ch is a new character variable read from the user input ;  $  TAB1 while ch is not a digit character ;  $  TAB2 if ch is equal to '-', change f to -1 ;  $  TAB2 set ch to char from the input ;  $  TAB1 while c is a digit character ;  $  TAB2 change x to x * 10 + ch - '0' ;  $  TAB2 change ch to char from the input ;  $  TAB1 return x multiplied by f ;  $  TAB0 create int n and an array of ints a with size 1005 ;  $  TAB1 change n to the result of read() * 2 ;  $  TAB1 in a for loop, change i from 1 to n inclusive, changing a[i] to the result of read() on each loop ;  $  TAB1 sort a from position 1 to n + 1 ;  $  TAB1 if a[n >> 1] is less than a[(n >> 1) + 1], return 0 * puts("YES") ;  $  TAB1 print "NO" to stdout ;
TAB0 declare integer n ;  $  TAB0 create vector of integers arr with 210 elements ;  $  TAB1 read variable n from the input ;  $  TAB1 start for loop from i = 1 to 2 * n inclusive, read input to arr[i] on each loop iteration ;  $  TAB1 sort arr from index 1 to 2 * n + 1, using greater<int>() as a comparator ;  $  TAB1 if arr[n] is greater than arr[n + 1] ;  $  TAB2 print "YES" ;  $  TAB3 print "\n" ;  $  TAB1 else ;  $  TAB2 print "NO" to the standard output ;  $  TAB3 print "\n" ;
TAB0 declare an array of integers named a of size 204 ;  $  TAB1 declare an integer named n ;  $  TAB1 read in n ;  $  TAB1 loop through the code 2 multiplied by n times and input a value into a every time ;  $  TAB1 sort the inputted values in the array in ascending order ;  $  TAB1 if the value of position n in a is greater than the value of position n-1 in a ;  $  TAB2 print YES ;  $  TAB1 or else ;  $  TAB2 print NO ;
TAB0 let int n ;  $  TAB0 create int array arr of size 210 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2 * n, read arr[i] ;  $  TAB1 sort arr + 1 using argument arr + n + n + 1 ;  $  TAB1 print "YES" if arr[n] < arr[n + 1] is true or "NO" if not ;
TAB0 n = integer, a = integer array of size 210 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 2 * n exlusive, then read a[i] ;  $  TAB1 sort a in asecnding order ;  $  TAB1 if a[n - 1] >= a[n] ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;
TAB0 n = long long, a = long long array of size 205 ;  $  TAB0 in function solve that returns nothing ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2 * n + 1 exclusive, read a[i] ;  $  TAB1 sort a for all elements that contain a value ;  $  TAB1 if a[n] is not a[n + 1] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;  $  TAB0 in function prep that returns nothing ;  $  TAB1 t = integer = 1 ;  $  TAB1 call prep ;  $  TAB1 any output to the user is in fixed-point notation and is precise to 10 decimal points ;  $  TAB1 while looping decrease t by 1, the contents of the loop is to call solve ;
TAB1 declare integer a ;  $  TAB1 read a ;  $  TAB1 declare integer arrays b size 10000, c size a, d size a ;  $  TAB1 for i = 0 to a * 2 exclusive, read b[i] ;  $  TAB1 sort from b to b + a * 2 ;  $  TAB1 for i = 0 to a exclusive, let c[i] be b[i] ;  $  TAB1 for i = a to a * 2 exclusive, let d[i-a] be b[i] ;  $  TAB1 for i = 0 to a exclusive ;  $  TAB2 for j = 0 to a exclusive ;  $  TAB3 if c[j] is greater than or equal to d[i] ;  $  TAB4 print "NO", newline ;  $  TAB1 print "YES", newline ;
TAB0 declare integer array a size 205 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2 * n inclusive, read a[i] ;  $  TAB1 sort elements from a to a + 2 * n + 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = n + 1 to 2 * n inclusive ;  $  TAB3 if a[i] is greater than or equal to a[j] ;  $  TAB4 print "NO", newline ;  $  TAB1 print "YES", newline ;
TAB1 make integer n ;  $  TAB1 create int array a of size 1001 ;  $  TAB1 let int array b of size 1001 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2 * n, read a[i] ;  $  TAB1 make int max = 1 ;  $  TAB1 for i = 1 to 2 * n ;  $  TAB2 for j = 1 to 2 * n ;  $  TAB3 if a[max] is less than a[j], set max to j ;  $  TAB2 set b[i] to a[max] ;  $  TAB2 set a[max] to -1 ;  $  TAB1 if b[n] is greater than b[n + 1] ;  $  TAB2 print "YES" ;  $  TAB1 else do ;  $  TAB2 print "NO" ;
TAB1 n = integer ;  $  TAB1 a = integer array of size 210 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 2 * n, read a[i] ;  $  TAB1 sort a and a + 2 * n ;  $  TAB1 if a[n] > a[n - 1] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = integer array of size 2 * n ;  $  TAB1 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB1 sort a in ascending order ;  $  TAB1 if a[n] is a[n - 1] ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;
TAB0 create new array of 4 integers dx with values 0, 0, -1, 1 ;  $  TAB0 dy is a new array of 4 integers with elements 1, -1, 0, 0 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n from the input ;  $  TAB1 a is an array of integers with size 2 * n ;  $  TAB1 for integer i = 0 to 2 * n exclusive increasing i by 1, read user input to a[i] ;  $  TAB1 sort all elements of a ;  $  TAB1 declare integer variable with name x = a[n] ;  $  TAB1 for i = 0 to n exclusive increasing i by 1 ;  $  TAB2 if x <= a[i] ;  $  TAB3 print "NO\n" ;  $  TAB1 print "YES\n" ;
TAB0 a = int array of size 205 with all values set to 0 ;  $  TAB0 N = int ;  $  TAB1 read N ;  $  TAB1 set N to N * 2 ;  $  TAB1 read N values into a ;  $  TAB1 sort a from position 0 to N ;  $  TAB1 set N to N / 2 ;  $  TAB1 decrement N ;  $  TAB1 if a[N] >= a[N + 1] ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB0 n = int and a = int array of size 10000 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 2 * n inclusive read a[i] ;  $  TAB1 sort a from position 1 to 2 * n + 1 ;  $  TAB1 if a[n] is a[n + 1] ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB0 create new integer called n ;  $  TAB0 x is an array of integers with size 200001 ;  $  TAB1 read n from the user input ;  $  TAB1 for i = 1 to 2 * n inclusive, read user input to x[i] ;  $  TAB1 sort x from position 1 to 1 + 2 * n ;  $  TAB1 if x[n] is less than x[n + 1] ;  $  TAB2 print "YES" to the standard output ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 vet = int array of size 2 * n ;  $  TAB1 read 2 * n values into vet ;  $  TAB1 sort vet ;  $  TAB1 if vet[n - 1] < vet[n] ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create long long integer variable with name n ;  $  TAB1 read n from the input ;  $  TAB1 create new vector of long long integers v ;  $  TAB1 for i = 0 to 2 * n exclusive incrementing i ;  $  TAB2 declare new long long integer x ;  $  TAB2 read variable x from the input ;  $  TAB2 push x to the end of vector v ;  $  TAB1 sort vector v ;  $  TAB1 if v[n] is greater than v[n - 1] ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" to the standard output ;  $  TAB1 print new line to the output ;
TAB0 create constant int N = 210 ;  $  TAB0 let integer n ;  $  TAB0 make int array in of size N ;  $  TAB1 read n and while n is truthy ;  $  TAB2 for i = 0 to 2 * n exclusive, read in[i] ;  $  TAB2 sort in using argument in + 2 * n ;  $  TAB2 if in[n] is greater than in[n - 1] ;  $  TAB3 print "YES" ;  $  TAB2 else do ;  $  TAB3 print "NO" ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 let n be n * 2 ;  $  TAB1 declare integer array a size 1005 ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort from a to a + n ;  $  TAB1 if a[n/2 - 1] is not a[n/2] ;  $  TAB2 print "YES", newline ;  $  TAB1 else ;  $  TAB2 print "NO", newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create int vector v of size 2 * n ;  $  TAB1 for i = 0 to 2 * n exclusive, read v[i] ;  $  TAB1 sort vector v ;  $  TAB1 print (v[n] > v[n - 1] ? "YES\n" : "NO\n") ;
TAB1 n is a new long long variable ;  $  TAB1 read standard input to n ;  $  TAB1 p is a new long long with value 2 * n ;  $  TAB1 create new array of long longs arr with p elements ;  $  TAB1 start for loop from i = 0 to 2 * n exclusive, read input to arr[i] on each loop ;  $  TAB1 sort arr ;  $  TAB1 if arr[n - 1] = arr[n] ;  $  TAB2 print "NO" to the standard output ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB0 create integer N ;  $  TAB0 declare string variable S ;  $  TAB1 read N and S ;  $  TAB1 sort array S ;  $  TAB1 print S and '\n' ;
TAB0 MaxN = constant long long equal to 301002 ;  $  TAB0 create long long n ;  $  TAB0 create string s ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 call sort on s ;  $  TAB1 print s and a new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string a ;  $  TAB1 read a ;  $  TAB1 sort a from beginning to end ;  $  TAB1 print a and a new line ;
TAB0 const is keyword for declaration of function then integer oo=1e9 ;  $  TAB1 integer =n ;  $  TAB1 read n ;  $  TAB1 string=s ;  $  TAB1 read s ;  $  TAB1 sort the function begin to end in descending order ;  $  TAB1 print s ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 sort s ;  $  TAB1 print s and a new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 sort elements from beginning of str to end of str ;  $  TAB1 print str print newline ;
TAB0 create constant integer inf 0x3f3f3f3f ;  $  TAB0 create long long a ;  $  TAB0 create string s ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 sort elements from beginning of s to end of s ;  $  TAB1 print s print newline ;
TAB0 let v be a vector of ints ;  $  TAB1 let n be an int ;  $  TAB1 read n ;  $  TAB1 let s be a string ;  $  TAB1 read s ;  $  TAB1 sort(s.begin(), s.end()) ;  $  TAB1 print s and a newline ;
TAB1 create integer n ;  $  TAB1 create string s ;  $  TAB1 read n read s ;  $  TAB1 sort elements from beginning of s to end of s ;  $  TAB1 print s print newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 sort elements from beginning of str to end of str ;  $  TAB1 print str print newline ;
TAB1 n =integer ;  $  TAB1 s =string ;  $  TAB1 Read n and s ;  $  TAB1 sort strings in alphabetical order ;  $  TAB1 print s and a new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 sort elements from beginning of s to end of s ;  $  TAB1 print s print "\n" ;
TAB1 create string s ;  $  TAB1 create integer n ;  $  TAB1 read n and s ;  $  TAB1 sort s ;  $  TAB1 print s ;
TAB1 create integer n ;  $  TAB1 create string s ;  $  TAB1 read n read s ;  $  TAB1 sort elements from beginning of s to end of s ;  $  TAB1 print s print newline ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 sort string s ;  $  TAB1 print s ;
TAB1 a = int ;  $  TAB1 read a ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 arr = int array of size 26 with each value set to 0 ;  $  TAB1 for i = 0 to a increment arr[s[i] - 'a'] ;  $  TAB1 for i = 0 to 26 ;  $  TAB2 for j = 0 to arr[i] print 'a' + i as char ;  $  TAB1 print a newline ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 sort the elements of s ;  $  TAB1 print s ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 declare string variable s ;  $  TAB1 read s ;  $  TAB1 sort s ;  $  TAB1 print s and "\n" ;
TAB0 create constant double PI with PI = 2.0 * acosign of 0.0 ;  $  TAB0 create constant integer MOD with MOD = 1e9 + 7 ;  $  TAB0 create constant integer oo with oo = 2 * MOD + 1e3 ;  $  TAB0 declare gcd with long longs a, b as arguments, returning long long ;  $  TAB1 return a if not b, else return result of run gcd with b, a % b as arguments from function ;  $  TAB1 create integer n ;  $  TAB1 create string str ;  $  TAB1 read n read str ;  $  TAB1 sort elements from beginning of str to end of str ;  $  TAB1 print str print '\n' ;
TAB1 declare integer variable n ;  $  TAB1 declare string variable s ;  $  TAB1 read n and s ;  $  TAB1 sort s ;  $  TAB1 print s ;
TAB1 create int64_t variable n ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 sort s ;  $  TAB1 print s ;
TAB0 declare constant integer mod = 1000000007 ;  $  TAB0 declare constant long long inf = 1000000000000 ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 declare string variable s ;  $  TAB1 read s ;  $  TAB1 sort s ;  $  TAB1 print s and '\n' ;
TAB0 int the function fpow that takes long long n, k, p with p = 1000000007 and returns long long ;  $  TAB1 r = 1 ;  $  TAB1 for k >>= 1 if k ;  $  TAB2 if k & 1 r = r * n % p ;  $  TAB2 n = n * n % p ;  $  TAB1 return r ;  $  TAB0 in the function inv that takes long long a, p with p = 1000000007 and returns long long ;  $  TAB1 return fpow with a, p - 2 and p as arguments ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 sort s.begin() and s.end() ;  $  TAB1 print s ;
TAB1 create character array a with size 100005 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 read character ;  $  TAB1 read string into a ;  $  TAB1 sort elements from a to a + n ;  $  TAB1 print a ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 declare string variable second ;  $  TAB1 read second ;  $  TAB1 sort second ;  $  TAB1 print second ;
TAB0 vis= array of 100005 boolean values ;  $  TAB0 define comp which takes a = pair from int to char, b = pair int to char as parameters ;  $  TAB1 return a.first > b.first ;  $  TAB1 let n be an int ;  $  TAB1 read n ;  $  TAB1 let s be a string ;  $  TAB1 read s ;  $  TAB1 execute sort with s.begin(), s.end() as arguments ;  $  TAB1 print s and one newline ;
TAB0 mod = unsigned long long const with mod = 1000000007 ;  $  TAB0 md = unsigned long long const with md = 998244353 ;  $  TAB0 in function mypow taking two unsigned long longs a and b and returning an unsigned long long ;  $  TAB1 res = unsigned long long with res = 1 ;  $  TAB1 set a to a modulo mod ;  $  TAB1 call assert on b is greater or equal to 0 ;  $  TAB1 loop while b is not 0 bitshifting b right by 1 each time ;  $  TAB2 if b bitwise-and 1 is not 0 then set res to res * a modulo mod ;  $  TAB2 set a to a * a modulo mod ;  $  TAB1 return res ;  $  TAB0 in = ifstream on "txt.in" ;  $  TAB0 out = ofstream on "txt.out" ;  $  TAB1 call fixed and setprecision of 12 on cout ;  $  TAB1 n = unsigned long long ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 sort s ;  $  TAB1 print s ;
TAB1 declare int variable N ;  $  TAB1 read N ;  $  TAB1 declare string variable S ;  $  TAB1 read S ;  $  TAB1 sort S ;  $  TAB1 print S and "\n" ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 sort array s ;  $  TAB1 print s and a newline ;
TAB1 create float A and C ;  $  TAB1 create float max, min ;  $  TAB1 read A and C ;  $  TAB1 if A and C equal to 0 ;  $  TAB2 max =0 ;  $  TAB2 assign 0 to min ;  $  TAB1 else if A=0 ;  $  TAB2 print Impossible ;  $  TAB1 else if C=0 ;  $  TAB2 max = A ;  $  TAB2 set min equal to A ;  $  TAB1 else if C less than A ;  $  TAB2 min = A ;  $  TAB2 set max to A + C-1 ;  $  TAB1 else ;  $  TAB2 set max = A + C -q ;  $  TAB2 assign C/A*A to min ;  $  TAB1 print min, " ", max and a newline ;
TAB0 declare const int N = 1e6 ;  $  TAB0 declare integers n and m ;  $  TAB0 declare ints mx and mn ;  $  TAB1 read input to n and m ;  $  TAB1 if n = 0 and m > 0 ;  $  TAB2 print "Impossible" ;  $  TAB1 if m is equal to 0 ;  $  TAB2 print n, " " and n ;  $  TAB1 change mx to n + m - 1 ;  $  TAB1 if n >= m ;  $  TAB2 change mn to n ;  $  TAB1 else ;  $  TAB2 change mn to m ;  $  TAB1 print mn, " " and mx ;
TAB0 define integers n and m ;  $  TAB1 read n, m ;  $  TAB1 if n is 0 and m is nonzero ;  $  TAB2 print Impossible ;  $  TAB1 otherwise ;  $  TAB2 print n + maximum of 0LL and m -n, " ", n + maximum of 0LL and m - 1, and a newline ;  $  TAB1 ; ;
TAB1 n, m = long long ;  $  TAB1 read n, m ;  $  TAB1 if n is 0 and m is 0 ;  $  TAB2 print 0 0 ;  $  TAB1 if n is 0 ;  $  TAB2 print Impossible ;  $  TAB1 mx = long long = n + m ;  $  TAB1 if m carries a nonzero value, decrease mx by 1 ;  $  TAB1 mn = long long = n + m ;  $  TAB1 mn = mn = lowest number between n and m ;  $  TAB1 print mn mx ;
TAB1 n, m =integers ;  $  TAB1 Read n and m ;  $  TAB1 if n is equal to 0 ;  $  TAB2 if m is equal to 0 ;  $  TAB3 print 0, 0 and a new line ;  $  TAB2 else do the following ;  $  TAB3 print Impossible and a new line ;  $  TAB1 else do the following ;  $  TAB2 mn, mx, a, b, c, d = integers ;  $  TAB2 if m is equal to 0 ;  $  TAB3 set mx to n ;  $  TAB2 else do the following ;  $  TAB3 set mx to m + n - 1 ;  $  TAB2 set mn to n - 1 ;  $  TAB2 set m to m - n - 1 ;  $  TAB2 if m is greater than 0 ;  $  TAB3 set mn to mn + m ;  $  TAB2 else do the following ;  $  TAB3 set mn to mn + 1 ;  $  TAB2 print mn, mx and a new line ;
TAB1 let mn be a long integer ;  $  TAB1 let a, b be integers ;  $  TAB1 read a and b ;  $  TAB1 if a is equal to 0 and b is equal to 0 ;  $  TAB2 print 0 and space and 0 and newline ;  $  TAB1 if a is equal to 0 ;  $  TAB2 print Impossible and newline ;  $  TAB2 semicolumn ;  $  TAB1 if b is equal to 0 ;  $  TAB2 print a and space and a and newline ;  $  TAB1 let mx be a long integer ;  $  TAB1 if b >= a ;  $  TAB2 the value of mn = a + (b - a) ;  $  TAB1 else do the following ;  $  TAB2 the value of mn is equal to a ;  $  TAB1 the value of mx is equal to a + (b - 1) ;  $  TAB1 print mn and space and mx and newline ;
TAB1 create integers n, m ;  $  TAB1 read n read m ;  $  TAB1 if n is 0 and m is greater than 0 ;  $  TAB2 print "Impossible" print newline ;  $  TAB1 create integers mn, mx ;  $  TAB1 set mn to n + ( maximum of ( 0 and m - n ) ) ;  $  TAB1 set mx to n + maximum of ( m - 1 ) ;  $  TAB1 print mn print " " print mx print newline ;
TAB1 declare integer variables n and m ;  $  TAB1 read n and m and keep looping ;  $  TAB2 create integer mx = n + max of m - 1 and 0 ;  $  TAB2 create integer mn = n + max of 0 and m - n ;  $  TAB2 if mn is greater than mx ;  $  TAB3 print "Impossible" ;  $  TAB2 else ;  $  TAB3 print mn, " " and mx ;
TAB1 ch, ad = integers ;  $  TAB1 read ch, ad ;  $  TAB1 if ad is 0 and ch > 0 ;  $  TAB2 print Impossible ;  $  TAB1 else ;  $  TAB2 print ad + ch - min(ad, ch)," ",ad + max(ch - 1, 0) ;
TAB1 create long longs n, m ;  $  TAB1 read n read m ;  $  TAB1 create long longs x, y ;  $  TAB1 if n is 0 ;  $  TAB2 if m is true ;  $  TAB3 print "Impossible\n" ;  $  TAB2 else ;  $  TAB3 print "0 0\n" ;  $  TAB1 else ;  $  TAB2 if m is true ;  $  TAB3 set y to ( n - 1 ) + m ;  $  TAB3 set x to n ;  $  TAB3 if m is greater than n, increment x by ( m - n ) ;  $  TAB2 else ;  $  TAB3 set x to y to n ;  $  TAB2 print x print " " print y print "\n" ;
TAB1 n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 if n is 0 and m is 0 ;  $  TAB2 print 0," ",0 ;  $  TAB1 else if n is 0 ;  $  TAB2 print Impossible ;  $  TAB1 else ;  $  TAB2 print if n > m, n else m," ",if m > 0, n + m - 1 else n ;
TAB1 create integers n, m ;  $  TAB1 read n read m ;  $  TAB1 if n is 0 and m is greater than 0 ;  $  TAB2 print "Impossible" print newline ;  $  TAB1 else ;  $  TAB2 print n + m - minimum of n and m print " " print n + maximum of m - 1 and 0, print newline ;
TAB1 n, m, mn, mx =integers ;  $  TAB1 Read n and m ;  $  TAB1 if n is equal to 0 ;  $  TAB2 if m is equal to 0 ;  $  TAB3 print 0 0 and a new line ;  $  TAB2 else do the following ;  $  TAB3 print Impossible and a new line ;  $  TAB1 if m is equal to 0 ;  $  TAB2 print n, " ", n and a new line ;  $  TAB1 set mx to n + m - 1 ;  $  TAB1 if n is greater than or equal to m ;  $  TAB2 set mn to n ;  $  TAB1 else do the following ;  $  TAB2 set mn to n ;  $  TAB1 print mn, " ", mx and a new line ;
TAB1 n, m = long long int ;  $  TAB1 read n then m ;  $  TAB1 if n is 0 and m is greater than 0 ;  $  TAB2 print "Impossible" ;  $  TAB1 else ;  $  TAB2 if n is greater or equal to m ;  $  TAB3 print n and ' ' ;  $  TAB2 else ;  $  TAB3 print (m / n) * n + (m % n) and ' ' ;  $  TAB2 if m is greater than 0 ;  $  TAB3 print (n - 1) + m ;  $  TAB2 else ;  $  TAB3 print n ;
TAB1 declare integers n and m ;  $  TAB1 read n and m ;  $  TAB1 if n = 0 and m > 0 ;  $  TAB2 print "Impossible" ;  $  TAB1 declare int variables mn and mx ;  $  TAB1 set mn to n ;  $  TAB1 if m = 0 ;  $  TAB2 assign n to mx ;  $  TAB1 else ;  $  TAB2 set mx to n + (m - 1) ;  $  TAB1 if m is greater than n, increase mn by m - n ;  $  TAB1 print mn, " " and mx ;
TAB1 n, m = long long ;  $  TAB1 read n, m ;  $  TAB1 if n is 0 and m is not 0 ;  $  TAB2 print Impossible ;  $  TAB1 if n is 0 and m is 0 ;  $  TAB2 print 0," ",0 ;  $  TAB1 if n is not 0 and m is 0 ;  $  TAB2 print n," ",n ;  $  TAB1 if n <= m ;  $  TAB2 print m," ",n - 1 + m ;  $  TAB1 else ;  $  TAB2 print n," ",n + m - 1 ;
TAB1 let n, m, c, d be integers ;  $  TAB1 while read n , m ;  $  TAB2 if n is equal to 0 and m is equal to 0 ;  $  TAB3 print 0 and space and 0 and newline ;  $  TAB2 else do the following ;  $  TAB3 if n is equal to 0 ;  $  TAB4 print Impossible and newline ;  $  TAB3 else do the following ;  $  TAB4 if n is equal to 1 ;  $  TAB5 if m is equal to 0 ;  $  TAB6 print n and space and n and newline ;  $  TAB5 else do the following ;  $  TAB6 print m and space and m and newline ;  $  TAB4 else do the following ;  $  TAB5 if n >= m ;  $  TAB6 if m is equal to 0 ;  $  TAB7 print n and space and n and newline ;  $  TAB6 else do the following ;  $  TAB7 c is equal to m + n - 1 ;  $  TAB7 print n and space and c and newline ;  $  TAB5 else do the following ;  $  TAB6 d is equal to m + n - 1 ;  $  TAB6 print m and space and d and newline ;
TAB1 declare int variables n and m ;  $  TAB1 read input to n and m ;  $  TAB1 if n = 0 and m != 0 ;  $  TAB2 print "Impossible" ;  $  TAB1 else if n = 0 and m = 0 ;  $  TAB2 print 0, " " and 0 ;  $  TAB1 else ;  $  TAB2 declare integer mx = n + (max of 0 and m - 1) ;  $  TAB2 declare integer mn = n + (max of 0 and m - n) ;  $  TAB2 print mn, " " and mx ;
TAB0 create integer array dx with dx = {-1, 0, 1, 0} ;  $  TAB0 create integer array dy with dy = {0, 1, 0, -1} ;  $  TAB1 create long longs n, m ;  $  TAB1 read n read m ;  $  TAB1 if m is 0 and n is greater than or equal to 0 ;  $  TAB2 print n print " " print n print newline ;  $  TAB1 if n is 0 and m is greater than 0 ;  $  TAB2 print "Impossible" print newline ;  $  TAB1 create long long maxsum with maxsum = m + n - 1 ;  $  TAB1 create long long minsum with minsum = n + maximum of ( m - n and 0LL ) ;  $  TAB1 print minsum print " " print maxsum print newline ;
TAB1 create int t, s, q ;  $  TAB1 cnt=0 ;  $  TAB1 read t, s and q ;  $  TAB1 while s < t ;  $  TAB2 set s to s*q ;  $  TAB2 increment cnt ;  $  TAB1 print cnt ;
TAB0 declare integers t, s, q ;  $  TAB1 read t, s, q ;  $  TAB1 declare integer ans = 1 ;  $  TAB1 declare integer temp = s * q ;  $  TAB1 while temp is less than t ;  $  TAB2 increment ans ;  $  TAB2 let temp be temp * q ;  $  TAB1 print ans, newline ;
TAB1 create long long ints a, b, c, and coun = 0 ;  $  TAB1 read a, b, and c ;  $  TAB1 while a is greater than b ;  $  TAB2 set b to b * c ;  $  TAB2 add 1 to coun ;  $  TAB1 show coun ;
TAB0 the constant double value of PI = acos(-1) ;  $  TAB0 let mod be a inline function that accepts long long n, long long m and returns a long integer value ;  $  TAB1 the long integer value of ret = n modulo m ;  $  TAB1 if ret is less than 0 , increment ret by m ;  $  TAB1 return the value of ret ;  $  TAB0 let gcd be a function that accepts long long a, long long b and returns a long integer ;  $  TAB1 if a equals 0 ;  $  TAB2 return the value of b ;  $  TAB1 else do the following ;  $  TAB2 return the value of gcd of b modulo a and a ;  $  TAB1 let q, s, t be long integers ;  $  TAB1 read t , s , q ;  $  TAB1 the long integer value of ans = 0 ;  $  TAB1 while s is less than t ;  $  TAB2 s is equal to s * q ;  $  TAB2 increment ans by 1 ;  $  TAB1 print ans and newline ;
TAB0 declare constant integer MAXN = 1e4 + 4 ;  $  TAB0 declare integers n, a, b ;  $  TAB1 read n, a, b ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 while a is less than n ;  $  TAB2 let a be a * b ;  $  TAB2 increment ans ;  $  TAB1 print ans and "\n" ;
TAB1 let t, s, q, c be long integers with c = 0 ;  $  TAB1 read t , s , q ;  $  TAB1 while t is greater than s ;  $  TAB2 s is equal to s * q ;  $  TAB2 increment c by 1 ;  $  TAB1 print c and newline ;
TAB1 let t, s, q be integers ;  $  TAB1 while read t, s, q ;  $  TAB2 let ans be integer 0 ;  $  TAB2 while s is less than t ;  $  TAB3 increment ans by 1 ;  $  TAB3 multiply s by q ;  $  TAB2 print ans and newline ;
TAB0 create new integer constant called maxn with value 2e3 + 10 ;  $  TAB0 create constant integer eps = 1e-14 ;  $  TAB0 mod is a new constant integer with value 1e9+7 ;  $  TAB0 declare long long constant inf = 1e18 ;  $  TAB1 define integers t, s and p ;  $  TAB1 read standard input to t, s and p ;  $  TAB1 cnt is a new integer with value 0 ;  $  TAB1 while s < t ;  $  TAB2 multiply s by p ;  $  TAB2 add 1 to cnt ;  $  TAB1 print cnt ;
TAB0 create ints t, s, and q ;  $  TAB0 make integer ans = 1 ;  $  TAB1 read t, s, and q ;  $  TAB1 make long double now = 0 ;  $  TAB1 create long double last = s ;  $  TAB1 while last is less than t ;  $  TAB2 make long double tmp = (last - now ) * q ;  $  TAB2 if last + tmp * (q - 1) / 2 is greater than or equal to t, break loop ;  $  TAB2 set last to last + ceil(tmp) * (q - 1) / q ;  $  TAB2 add ceil(tmp) to now ;  $  TAB2 subtract last from now ;  $  TAB2 increment ans ;  $  TAB1 show ans ;
TAB1 create long long int s, t, and q ;  $  TAB1 read t, s, and q ;  $  TAB1 make long long ans = 0 ;  $  TAB1 while s is less than t ;  $  TAB2 set s to s * q ;  $  TAB2 increment ans ;  $  TAB1 show ans ;
TAB1 declare integers t, s and q ;  $  TAB1 read from the input to t, s and q ;  $  TAB1 ans is a new integer variable = 1 ;  $  TAB1 while s * q < t ;  $  TAB2 increment ans by one ;  $  TAB2 set s to s multiplied by q ;  $  TAB1 print ans ;
TAB1 declare new integers t, s and q ;  $  TAB1 read variables t, s and q from the input ;  $  TAB1 create new integer variable ans = 0 ;  $  TAB1 while s < t ;  $  TAB2 set s to s multiplied by q ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB1 declare new int variables t, s and q ;  $  TAB1 read input to t, s and q ;  $  TAB1 define integer ans = 1 ;  $  TAB1 define new integer x with value s * q ;  $  TAB1 while x < t ;  $  TAB2 increment ans ;  $  TAB2 change the value of x to x multiplied by q ;  $  TAB1 print ans ;
TAB0 declare integers n, m ;  $  TAB0 declare integer array b size 200007 ;  $  TAB0 declare integer arrays a size 200007, c size 200007 ;  $  TAB0 declare integer vector v ;  $  TAB1 declare integers i, j, l, h, t = 0 ;  $  TAB1 declare strings s, s1, s2, s3 ;  $  TAB1 declare long longs RE, DE, HE ;  $  TAB1 read RE and DE and HE ;  $  TAB1 while DE * HE is less than RE ;  $  TAB2 increment t ;  $  TAB2 let DE be DE * HE ;  $  TAB1 print t + 1 and newline ;
TAB1 declare integer variables a, b and c ;  $  TAB1 declare integer variable ans = 0 ;  $  TAB1 read variables a, b and c from the input ;  $  TAB1 while b < a ;  $  TAB2 change the value of b to b multiplied by c ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB1 create ints t, s, and q ;  $  TAB1 make int count = 0 ;  $  TAB1 read t, s, and q ;  $  TAB1 while s is less than t ;  $  TAB2 set s to s * q ;  $  TAB2 set count to count + 1 ;  $  TAB1 show count ;
TAB1 declare doubles t, s, q, c and ans with c and ans = 0 ;  $  TAB1 read user input to t, s and q ;  $  TAB1 while s < t ;  $  TAB2 change s to the product of s and q ;  $  TAB2 increment ans by one ;  $  TAB1 print ans to the standard output ;
TAB0 create const int maxn = 1e5 + 5 ;  $  TAB1 create long long ints t, s, q, and ans = 0 ;  $  TAB1 read t, s, and q ;  $  TAB1 while s is less than t ;  $  TAB2 set s to s * q ;  $  TAB2 add 1 to ans ;  $  TAB1 show ans ;
TAB1 t,s,q=int, ans=0 ;  $  TAB1 read t,s,q ;  $  TAB1 downloaded=s ;  $  TAB1 while downloaded<t ;  $  TAB2 add s*(q-1) to downloaded ;  $  TAB2 s=downloaded ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB0 let MOD be a integer constant which equals 1e9 + 7 ;  $  TAB0 let INF be a integer constant which equals INT_MAX ;  $  TAB0 let LINF be a long long constant which equals LLONG_MAX ;  $  TAB0 let ans be integer ;  $  TAB0 let t, s, q be long double values ;  $  TAB1 read t, s, q ;  $  TAB1 let x, z, y be long integers with x, z equals 0 and y equals s ;  $  TAB1 while s is less than t ;  $  TAB2 multiply s by q ;  $  TAB2 increase ans by 1 ;  $  TAB1 print ans and endline ;
TAB0 declare integer variables ans, t, s and q ;  $  TAB1 set ans to 0 ;  $  TAB1 read standard input to t, s and q ;  $  TAB1 while s < t ;  $  TAB2 multiply s by q ;  $  TAB2 increment ans by one ;  $  TAB1 print ans to the standard output ;
TAB1 let a, b, c be integers ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read c ;  $  TAB1 let s(b), x(0) be integers ;  $  TAB1 while s is less than a ;  $  TAB2 s is equal to s * c ;  $  TAB2 increment x by 1 ;  $  TAB1 print x and newline ;
TAB0 create long longs t, s and q ;  $  TAB1 new integer cnt = 1 ;  $  TAB1 read input to t, s and q ;  $  TAB1 in the infinite loop ;  $  TAB2 if s * q >= t ;  $  TAB3 stop the loop ;  $  TAB2 else ;  $  TAB3 set s to s * q ;  $  TAB3 increment cnt ;  $  TAB1 print cnt to the standard output ;
TAB0 declare integers n, s, q ;  $  TAB1 declare integers t, w, i, j, k, cnt, ans = 0 ;  $  TAB1 read n, s, q ;  $  TAB1 while s is less than n ;  $  TAB2 increment ans ;  $  TAB2 let s be s * q ;  $  TAB1 print ans, newline ;
TAB1 integer as t,s,q,cnt = 0 ;  $  TAB1 read t,s,q ;  $  TAB1 if s is less than t then do the following ;  $  TAB2 add one to cnt ;  $  TAB2 multiply s by q ;  $  TAB1 output cnt ;
TAB1 create integers t, s and q ;  $  TAB1 read t, s and q and keep looping ;  $  TAB2 declare integer variable with name ans = 0 ;  $  TAB2 while s < t ;  $  TAB3 increment ans by one ;  $  TAB3 multiply s by q ;  $  TAB2 print ans to the standard output ;
TAB1 let T, S, q be integers ;  $  TAB1 read T, S, q ;  $  TAB1 print (int)ceil(log(T * 1.0 / S) / log(q)) and newline ;
TAB1 create long long t, s, q ;  $  TAB1 read t, s and q ;  $  TAB1 ans=0 ;  $  TAB1 while s < t ;  $  TAB2 s= s*q ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB1 n, m and a are long long integers ;  $  TAB1 read n, m and a ;  $  TAB1 n = n % 10000000000 ;  $  TAB1 m = m % 10000000000 ;  $  TAB1 a = a % 10000000000 ;  $  TAB1 let int ans be long longs ;  $  TAB1 if a > n and a > m ;  $  TAB2 assign value of 1 to the ans ;  $  TAB1 else ;  $  TAB2 if n % a is greater than 0 ;  $  TAB3 n = n / a + 1 ;  $  TAB2 else ;  $  TAB3 n = n / a ;  $  TAB2 if m % a is greater than 0 ;  $  TAB3 m = m / a + 1 ;  $  TAB2 else ;  $  TAB3 m = m / a ;  $  TAB2 ans = n * m ;  $  TAB1 print ans and a new line ;
TAB1 create integers n, m and a ;  $  TAB1 read n, m and a ;  $  TAB1 print 1ll * (n + a - 1) / a * ((m + a - 1) / a) and a new line ;
TAB0 create integers m, n, a ;  $  TAB1 read m ;  $  TAB1 read n ;  $  TAB1 read a ;  $  TAB1 create integer l with l = round up ( n / (a*1.0) ) ;  $  TAB1 create integer w with w = round up ( m / (a*1.0) ) ;  $  TAB1 print long long casted l * long long casted w print newline ;
TAB0 m, n and a = integers ;  $  TAB1 read m ;  $  TAB1 read n ;  $  TAB1 read a ;  $  TAB1 int l = ceil of n / (a * 1.0) ;  $  TAB1 int w = ceil of m / (a * 1.0) ;  $  TAB1 print l * w and a new line ;
TAB1 declare long longs called a, b and c ;  $  TAB1 read a, b and c ;  $  TAB1 print (((a + c - 1) / c) * ((b + c - 1) / c)) and "\n" ;
TAB1 create doubles n, m and a ;  $  TAB1 read n, m and a ;  $  TAB1 print (n / a * 1.0) rounded upward * (m / a * 1.0) rounded upward, and a new line ;
TAB1 n, m, a, x and y are long longs ;  $  TAB1 read n, m and a ;  $  TAB1 if n % a != 0 and m % a != 0 ;  $  TAB2 x = n / a + 1 ;  $  TAB2 y = m / a + 1 ;  $  TAB1 else if n % a = 0 and m % a != 0 ;  $  TAB2 x = n / a ;  $  TAB2 y = m / a + 1 ;  $  TAB1 else if n % a != 0 and m % a = 0 ;  $  TAB2 x = n / a + 1 ;  $  TAB2 y = m / a ;  $  TAB1 else ;  $  TAB2 x = n / a ;  $  TAB2 y = m / a ;  $  TAB1 print x * y and a new line ;
TAB1 create long longs n, m, a, x, y ;  $  TAB1 read n read m read a ;  $  TAB1 if a % a is not 0 and m % a is not 0 ;  $  TAB2 set x to n / a + 1 ;  $  TAB2 set y to m / a + 1 ;  $  TAB1 else if n % a is 0 and m % a is not 0 ;  $  TAB2 set x to n / a ;  $  TAB2 set y to m / a + 1 ;  $  TAB1 else if n % a is not 0 and m % a is 0 ;  $  TAB2 set x to n / a + 1 ;  $  TAB2 set y to m / a ;  $  TAB1 else ;  $  TAB2 set x to n / a ;  $  TAB2 set y to m / a ;  $  TAB1 print x * y print newline ;
TAB1 declare long longs i, j, c1, c2, n, m and a ;  $  TAB1 read n, m and a ;  $  TAB1 if n % a = 0 ;  $  TAB2 c1 = n / a ;  $  TAB1 else ;  $  TAB2 c1 = n / a + 1 ;  $  TAB1 if m % a = 0 ;  $  TAB2 c2 = m / a ;  $  TAB1 else ;  $  TAB2 c2 = m / a + 1 ;  $  TAB1 print c1 * c2 and a new line ;
TAB1 create long longs n, m and a ;  $  TAB1 read n, m and a ;  $  TAB1 long long stones = (n / a) * (m / a) ;  $  TAB1 if n % a != 0 add m / a to stones ;  $  TAB1 if m % a != 0 add n / a to stones ;  $  TAB1 if m % a != 0 && n % a != 0 add 1 to stones ;  $  TAB1 print stones and a new line ;
TAB1 let n, m and a be long longs ;  $  TAB1 read n, m and a ;  $  TAB1 set long long ans to 0 ;  $  TAB1 if n % a is equal to 0 ;  $  TAB2 n = n / a ;  $  TAB1 else ;  $  TAB2 n = n / a + 1 ;  $  TAB1 if m % a is equal to 0 ;  $  TAB2 m = m / a ;  $  TAB1 else ;  $  TAB2 m = m / a + 1 ;  $  TAB1 print m * n and a new line ;
TAB0 m, n and a are integers ;  $  TAB1 read m, n and a ;  $  TAB1 int l = n / (a * 1.0) rounded down ;  $  TAB1 int w = m / (a * 1.0) rounded down ;  $  TAB1 print l * w and a new line ;
TAB1 n, m and a = doubles ;  $  TAB1 read n, m and a ;  $  TAB1 print (n / a) rounded up * (m / a) rounded up, and a new line ;
TAB1 let n, m and a be long longs ;  $  TAB1 i and j are long longs with i = 0 and j = 0 ;  $  TAB1 while car rean n, m and a ;  $  TAB2 if n % a is 1 ;  $  TAB3 i = n / a + 1 ;  $  TAB2 else ;  $  TAB3 i = n / a ;  $  TAB2 if m % a is 1 ;  $  TAB3 j = m / a + 1 ;  $  TAB2 else ;  $  TAB3 j = m / a ;  $  TAB2 print i * j and a new line ;
TAB1 create long longs n, m, a ;  $  TAB1 create long longs i, j, with i = 0, j = 0 ;  $  TAB1 while read n read m read a is true ;  $  TAB2 if n % a is true ;  $  TAB3 set i to n / a + 1 ;  $  TAB2 else ;  $  TAB3 set i to n / a ;  $  TAB2 if m % a ;  $  TAB3 set j to m / a + 1 ;  $  TAB2 else ;  $  TAB3 set j to m / a ;  $  TAB2 print i * j print newline ;
TAB1 n = long long ;  $  TAB1 m = long long ;  $  TAB1 a = long long ;  $  TAB1 read n, m and a ;  $  TAB1 print ((n + a - 1) / a) * ((m + a - 1) / a) and a new line ;
TAB1 create long long n ;  $  TAB1 create long long m ;  $  TAB1 create long long a ;  $  TAB1 read n read m read a ;  $  TAB1 print ((n + a - 1) / a) * ((m + a - 1) / a) print newline ;
TAB1 int n, m, a and ans = long longs ;  $  TAB1 read n, m and a in a loop ;  $  TAB2 if a > and a > m ;  $  TAB3 print "1" and a new line ;  $  TAB2 else ;  $  TAB3 if n % a is greater than 0 ;  $  TAB4 n = (n / a) + 1 ;  $  TAB3 else ;  $  TAB4 n = (n / a) ;  $  TAB3 if m % a is greater than 0 ;  $  TAB4 m = (m / a) + 1 ;  $  TAB3 else ;  $  TAB4 m = (m / a) ;  $  TAB3 ans = n * m ;  $  TAB3 print ans and a new line ;
TAB1 create long longs x, y and a ;  $  TAB1 read x, y and a ;  $  TAB1 declare long longs xx = x / a and yy = y / a ;  $  TAB1 if x % a != 0 increment xx ;  $  TAB1 if y % a != 0 increment yy ;  $  TAB1 print xx * yy and a new line ;
TAB1 create long longs x, y, a ;  $  TAB1 read x read y read a ;  $  TAB1 create long longs xx, yy, with xx = x/a, yy = y/a ;  $  TAB1 if x % a is not 0, increment xx ;  $  TAB1 if y % a is not 0, increment yy ;  $  TAB1 print xx * yy print newline ;
TAB1 declare long longs called n, m and a ;  $  TAB1 read n, m and a ;  $  TAB1 create long long rows = (n + a - 1) / a ;  $  TAB1 create long long cols = (m + a - 1) / a ;  $  TAB1 print rows * cols and a new line ;
TAB1 let n, m, a be long integers ;  $  TAB1 read n, m, a ;  $  TAB1 if n modulo a is equal to 0 ;  $  TAB2 the value of n = n / a ;  $  TAB1 else do the following ;  $  TAB2 the value of n = n / a + 1 ;  $  TAB1 if m modulo a is equal to 0 ;  $  TAB2 the value of m = m / a ;  $  TAB1 else do the following ;  $  TAB2 the value of m = m / a + 1 ;  $  TAB1 print n * m and newline ;
TAB1 create long longs a, b, c ;  $  TAB1 while read a read b read c ;  $  TAB2 create long longs d, e ;  $  TAB2 if a % c is not 0, set d to a / c + 1 ;  $  TAB2 if b % c is not 0, set e to b / c + 1 ;  $  TAB2 if a % c is 0, set d to a / c ;  $  TAB2 if b % c is 0, set e to b / c ;  $  TAB2 create long long f with f = d * e ;  $  TAB2 print f print newline ;
TAB1 n, m, a = long lon ;  $  TAB1 while reading n then m then a print ((n + a - 1) / a) * ((m + a - 1) / a) ;
TAB1 create long long x, y and a ;  $  TAB1 read x, y and a ;  $  TAB1 set xx to x/a and yy = y/a ;  $  TAB1 if x mod a different from 0, increment xx ;  $  TAB1 if y mod a different from 0, add 1 to yy ;  $  TAB1 print xx * yy ;
TAB1 create long longs n, m, a ;  $  TAB1 read n read m read a ;  $  TAB1 create long longs nN, nM ;  $  TAB1 set nN to n / a ;  $  TAB1 set nM to m / a ;  $  TAB1 if n % a is not 0, increment nN ;  $  TAB1 if m % a is not 0, increment nM ;  $  TAB1 print nN * nM print newline ;
TAB1 a, b, c, d =integers ;  $  TAB1 Read a, b, c ;  $  TAB1 if c is greater than or equal to a and c is greater than or equal to b ;  $  TAB2 print 1 and a new line ;  $  TAB1 if c is less than a and c is greater than or equal to b ;  $  TAB2 if a modulo c is 0 ;  $  TAB3 print a / c and a new line ;  $  TAB2 else do the following ;  $  TAB3 print a / c + 1 and a new line ;  $  TAB1 if c is greater than or equal to a and c is less than b ;  $  TAB2 if b modulo c is 0 ;  $  TAB3 print b / c and a new line ;  $  TAB2 else do the following ;  $  TAB3 print b / c + 1 and a new line ;  $  TAB1 if c is less than a and c is less than b ;  $  TAB2 if b modulo c is 0 and a modulo c is 0 ;  $  TAB3 print (a * b) / (c * c) and a new line ;  $  TAB2 else if b modulo c is not 0 and a modulo c is 0 ;  $  TAB3 print (a / c) * (b / c + 1) and a new line ;  $  TAB2 else if b modulo c is 0 and a modulo c is not 0 ;  $  TAB3 print (b / c) * (a / c + 1) and a new line ;  $  TAB2 else do the following ;  $  TAB3 print (a / c + 1) * (b / c + 1) and a new line ;
TAB1 noOfOranges, Orange, maxSize, maxWaste, Waste, cnt = integers with Waste = 0, cnt = 0 ;  $  TAB1 read noOfOranges, maxSize, maxWaste ;  $  TAB1 for i = 0 to noOfOranges exclusive ;  $  TAB2 read Orange ;  $  TAB2 if (Orange > maxSize) ;  $  TAB3 continue next itereation ;  $  TAB2 else ;  $  TAB3 Waste = Waste + Orange ;  $  TAB3 if (Waste > maxWaste) ;  $  TAB4 increment cnt ;  $  TAB4 Waste = 0 ;  $  TAB1 print cnt ;
TAB1 let n, b, d, v, sum , c be integers with sum = 0, c = 0 ;  $  TAB1 read n , b , d ;  $  TAB1 for x = 0 to n exclusive ;  $  TAB2 read v ;  $  TAB2 if v <= b , increment sum by v ;  $  TAB2 if sum is greater than d ;  $  TAB3 sum is equal to 0 ;  $  TAB3 increment c by 1 ;  $  TAB1 print c and endline ;
TAB0 new constant integer N = 1e5 + 100 ;  $  TAB0 define constant double PI with value 3.14159 ;  $  TAB0 create vector of booleans v ;  $  TAB0 declare integers n, m, now, ans, b and d, and an array of integers a with N elements ;  $  TAB0 st is a set of integers ;  $  TAB0 define strings s and t ;  $  TAB1 read n, b and d ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 read a[i] from the input ;  $  TAB2 go to the start of the loop if a[i] is greater than b ;  $  TAB2 change now to now + a[i] ;  $  TAB2 if now is greater than d ;  $  TAB3 increment ans by one ;  $  TAB3 change the value of now to 0 ;  $  TAB1 print ans to the standard output ;
TAB1 n, b, d, a, c, c2 = integers ;  $  TAB1 read n, b, d ;  $  TAB1 while decrement n ;  $  TAB2 read a ;  $  TAB2 if (a <= b), c = c + a ;  $  TAB2 if (c > d) ;  $  TAB3 increment c2 ;  $  TAB3 c = 0 ;  $  TAB1 print c2 ;
TAB1 create integer n, b, d, result, counter with result=0, counter=0 ;  $  TAB1 read n, b, d ;  $  TAB1 create integer array oranges with size n ;  $  TAB1 for integer i=0 to n-1 with increment i ;  $  TAB2 read oranges[i] ;  $  TAB2 if oranges[i] less than or equal to b then add oranges[i] to counter ;  $  TAB2 if counter greater than d then ;  $  TAB3 increment result ;  $  TAB3 set counter to 0 ;  $  TAB1 print result ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 b = integer ;  $  TAB1 Read b ;  $  TAB1 d = integer ;  $  TAB1 Read d ;  $  TAB1 orange, volume, counter = integers with volume = 0, counter = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read orange ;  $  TAB2 if orange is less than or equal to b, set volume to volume + orange ;  $  TAB2 if volume is greater than d ;  $  TAB3 set volume to 0 ;  $  TAB3 increment counter ;  $  TAB1 print counter and a new line ;
TAB1 n, b, d =integers ;  $  TAB1 Read n, b, d ;  $  TAB1 temp, ans = integers with ans = 0 ;  $  TAB1 cont =integer with 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read temp ;  $  TAB2 if temp is less than or equal to b ;  $  TAB3 set cont to cont + temp ;  $  TAB3 if cont is greater than d ;  $  TAB4 increment ans ;  $  TAB4 set cont to 0 ;  $  TAB1 print ans and new line ;
TAB1 n = long double with value of 0 ;  $  TAB1 s = long double with value of 0 ;  $  TAB1 b = long double with value of 0 ;  $  TAB1 d = long double with value of 0 ;  $  TAB1 e = long double with value of 0 ;  $  TAB1 output = integer with value of 0 ;  $  TAB1 read n, b and d ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s ;  $  TAB2 if s is greater than b ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 increase e by s ;  $  TAB3 if e is greater than d ;  $  TAB4 add 1 to output ;  $  TAB4 set e to 0 ;  $  TAB1 print output ;
TAB1 create long long ints n, b, d, and i ;  $  TAB1 read n, b, and d and while they're truthy ;  $  TAB2 create long long ints sum = 0 and c = 0 and int array a of size n + 5 ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a[i] is less than or equal to b, set sum to sum + a[i] ;  $  TAB3 if sum is greater than d ;  $  TAB4 set sum to 0 ;  $  TAB4 add 1 to c ;  $  TAB2 display c ;
TAB1 let n, b, d, v, sum and c be unsigned long integers with sum and c = 0 ;  $  TAB1 read from the input to n, b and d ;  $  TAB1 start a loop from x = 0 to n exclusive incrementing x ;  $  TAB2 read standard input to v ;  $  TAB2 if v <= b, change sum to sum + v ;  $  TAB2 if sum is greater than d ;  $  TAB3 assign 0 to sum ;  $  TAB3 increment c by one ;  $  TAB1 print c ;
TAB1 create integers n, b, d, i, cnt and tmp with cnt and tmp = 0; create an array of integers a with 100001 element ;  $  TAB1 read n, b and d from the input ;  $  TAB1 read elements of a from the input n times in a loop ;  $  TAB1 start for loop from i = 0 to n exclusive incrementing i ;  $  TAB2 if a[i] <= b and cnt <= d, add a[i] to cnt ;  $  TAB2 if cnt is greater than d ;  $  TAB3 assign 0 to cnt ;  $  TAB3 increment tmp by one ;  $  TAB1 print tmp to the standard output ;
TAB1 create int int n, b, d,,set result and temp to 0 ;  $  TAB1 read n, b and d ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create int size ;  $  TAB2 read size ;  $  TAB2 if size <= b, set temp to temp + size ;  $  TAB2 if temp > d ;  $  TAB3 increment result ;  $  TAB3 set temp to 0 ;  $  TAB1 print result ;
TAB0 n, b, d = integers ;  $  TAB1 read n, b, d ;  $  TAB1 ans, cnt = integers with ans = 0, cnt = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 if (x <= b) ;  $  TAB3 cnt = cnt + x ;  $  TAB3 if (cnt > d) ;  $  TAB4 increment ans ;  $  TAB4 cnt = 0 ;  $  TAB1 print ans ;
TAB1 n, b, d, sum and ans are integers where sum and ans = 0 ;  $  TAB1 read input to n, b and d ;  $  TAB1 for integer i = 0 to n exclusive incrementing i ;  $  TAB2 t is a new integer variable ;  $  TAB2 read t ;  $  TAB2 if t <= b ;  $  TAB3 increase sum by t ;  $  TAB3 if sum is greater than d ;  $  TAB4 assign 0 to sum ;  $  TAB4 increment ans ;  $  TAB1 print ans to the output stream ;
TAB1 let n, b, d be integers ;  $  TAB1 read n, b, d ;  $  TAB1 let integer value of sum = 0 ;  $  TAB1 let integer value of count = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let a be a integer ;  $  TAB2 read a ;  $  TAB2 if a <= b , increment sum by a ;  $  TAB2 if sum is greater than d ;  $  TAB3 increment count by 1 ;  $  TAB3 sum is equal to 0 ;  $  TAB1 print count and newline ;
TAB0 s is a new array of integers with 100000 + 5 elements ;  $  TAB1 create integers n, b, d, ans and sum with ans and sum = 0 ;  $  TAB1 read n, b and d from the user input ;  $  TAB1 start for loop from i = 0 to n exclusive ;  $  TAB2 read s[i] from the input ;  $  TAB2 if s[i] is greater than b ;  $  TAB3 skip the rest of the loop ;  $  TAB2 else ;  $  TAB3 increase sum by s[i] ;  $  TAB2 if sum is greater than d ;  $  TAB3 change sum to 0 ;  $  TAB3 increment ans by one ;  $  TAB1 print ans to the standard output ;
TAB1 create long n, b, d, c, set c to 0 ;  $  TAB1 read n, b and d ;  $  TAB1 create long orange[n] ;  $  TAB1 out=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read orange[i] ;  $  TAB2 if orange[i] > b ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 set out to out + orange[i] ;  $  TAB3 if out > d ;  $  TAB4 increment c ;  $  TAB4 out=0 ;  $  TAB1 print c ;
TAB0 let n, b, d be long integers ;  $  TAB0 a = array of long integers of length 100007 ;  $  TAB1 read n, b, d ;  $  TAB2 for long integer $i = 0 to n - 1 inclusive , read a[$i] ;  $  TAB1 let c be a long integer with c = 0 ;  $  TAB1 let s be a long integer with s = 0 ;  $  TAB1 for long integer i = 0 to n - 1 inclusive ;  $  TAB2 if a[i] <= b ;  $  TAB3 increment s by a[i] ;  $  TAB3 if s is greater than d ;  $  TAB4 increment c by 1 ;  $  TAB4 s is equal to 0 ;  $  TAB1 print c and newline ;
TAB1 let n, b, d be integers ;  $  TAB1 read n, b, d ;  $  TAB1 ret, tot = integers with value of 0 ;  $  TAB1 for int i = 0 to n ;  $  TAB2 a = int ;  $  TAB2 read a ;  $  TAB2 if a > b, continue ;  $  TAB2 add a to tot ;  $  TAB2 if tot > d ;  $  TAB3 add one to ret ;  $  TAB3 let tot = 0 ;  $  TAB1 print ret ;
TAB1 x, y, a, b = integers ;  $  TAB1 read x, y, a, b ;  $  TAB1 x = (x * y) / the result of calling __gcd with arguments of x and y ;  $  TAB1 print the result of b / x - (a - 1) / x ;
TAB0 let gcd be a long integer function which accepts long integers a, b ;  $  TAB1 if a is equal to 0 or b is equal to 0, return 0 ;  $  TAB1 if a is equal to b , return a ;  $  TAB1 if a is greater than b , return gcd of a - b, b ;  $  TAB1 return gcd of a, b - a ;  $  TAB1 let f, l, x, y, a, b, i, cnt be long integers with cnt = 0 ;  $  TAB1 read x, y, a, b ;  $  TAB1 let lcm be a long integer with lcm is equal to (x * y) / gcd of x, y ;  $  TAB1 print ((b / lcm) - ((a - 1) / lcm)) and newline ;
TAB1 declare x, y, a, b as integers ;  $  TAB1 read x read y read a read b ;  $  TAB1 declare val = ( x * y ) / ( run __gcd(x, y) ) as integer ;  $  TAB1 declare integer ans ;  $  TAB1 if a % val is 0 ;  $  TAB2 let ans be b / val - a / val + 1 ;  $  TAB1 else ;  $  TAB2 let ans be b / val - a / val ;  $  TAB1 print ans, "\n" ;
TAB1 declare long long integers a, b, x, y ;  $  TAB1 read x, y, a, b ;  $  TAB1 declare long long integer g = run __gcd(x, y) ;  $  TAB1 let x be ( x * y ) / g ;  $  TAB1 if a % x is 0 ;  $  TAB2 print b / x - a / x + 1 ;  $  TAB1 else ;  $  TAB2 print b / x - a / x ;  $  TAB1 print newline ;
TAB1 create new integers x, y, a and b ;  $  TAB1 read standard input to x, y, a and b ;  $  TAB1 create integer variable with name lcm = x * y / __gcd(x, y) ;  $  TAB1 declare integer ans with value b / lcm - (a - 1) / lcm ;  $  TAB1 print ans ;
TAB0 in function gcd with arguments integer a and integer b that returns an integer ;  $  TAB1 return the result of calling gcd with arguments of b and a modulo b if b is nonzero else return a ;  $  TAB1 x, y, a, b, v, k = integers ;  $  TAB1 read x, y, a, b ;  $  TAB1 v = x * y / the result of calling gcd with arguments of x and y ;  $  TAB1 k = b / v - (a - 1) / v ;  $  TAB1 print k ;
TAB0 integer function gcd with int arguments a and b ;  $  TAB1 return a if b=0, or gcd(b, a % b) otherwise ;  $  TAB0 function lcm with int arguments a and b that returns integer ;  $  TAB1 return a * (b / gcd(a, b)) ;  $  TAB1 declare integers x, y, a and b ;  $  TAB1 read variables x, y, a and b from the input ;  $  TAB1 declare integer variable MCM with value = result of lcm(x, y) ;  $  TAB1 print (b / MCM) - ((a - 1) / MCM) to the standard output ;
TAB0 in function gcd taking int a, int b and returning int ;  $  TAB1 if b is 0 return a ;  $  TAB1 return gcd of b, a mod b ;  $  TAB0 in function LCM taking int a, int b and returning int ;  $  TAB1 return (a * b) / gcd of a, b ;  $  TAB1 ans, x, y, aa, bb, m = int ;  $  TAB1 read x then y then aa then bb ;  $  TAB1 set m to LCM of max of x, y, min of x, y ;  $  TAB1 set ans to (bb / m) - (aa - 1) / m ;  $  TAB1 print ans ;
TAB1 x, y, a, b, m, n = int ;  $  TAB1 read x then y then a then b ;  $  TAB1 p, q = int with p = x and q = y ;  $  TAB1 loop while q ;  $  TAB2 set n to q ;  $  TAB2 set q to p mod q ;  $  TAB2 set p to n ;  $  TAB1 set n to (x * y) / n ;  $  TAB1 set m to not (a mod n) ;  $  TAB1 print (b / n - a / n + m) ;
TAB0 declare integer f with integers a, b as arguments ;  $  TAB1 declare integers t, x = a, y = b ;  $  TAB1 if x is less than y ;  $  TAB2 let t be x ;  $  TAB2 let x be y ;  $  TAB2 let y be t ;  $  TAB1 while x % y is not 0 ;  $  TAB2 let t be y ;  $  TAB2 let y be x % y ;  $  TAB2 let x be t ;  $  TAB1 return a * b / y ;  $  TAB1 declare integers x, y, a, b ;  $  TAB1 while read x, y, a, b is true ;  $  TAB2 declare integer t = result of run f(x,y) ;  $  TAB2 declare integer p = b / t - a / t + 1 if a % t is 0, else b / t - a / t ;  $  TAB2 print p, newline ;
TAB0 declare function GCD taking int a, int b and returning int ;  $  TAB1 x, y = int ;  $  TAB1 a, b = int ;  $  TAB1 read x then y then a then b ;  $  TAB1 set x to x * y / GCD of x, y ;  $  TAB1 print b / x - (a - 1) / x ;  $  TAB0 in function GCD taking int a, int b and returning int ;  $  TAB1 n = int with n = a mod b ;  $  TAB1 loop while n is not 0 ;  $  TAB2 set a to b ;  $  TAB2 set b to n ;  $  TAB2 set n to a mod b ;  $  TAB1 return b ;
TAB0 function gcd (gets two ints a and b, return int) ;  $  TAB1 if a is 0 return b ;  $  TAB1 return gcd(b modulo a, a) ;  $  TAB1 x,y=int ;  $  TAB1 a,b=int ;  $  TAB1 read x ;  $  TAB1 read y ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 M=x/gcd(x,y)*y ;  $  TAB1 l=a/M ;  $  TAB1 r=b/M ;  $  TAB1 if l*M < a increment l ;  $  TAB1 print r-l+1 ;
TAB0 let x, y, a, b be integers ;  $  TAB0 let ans be a integer ;  $  TAB0 it is a function which returns Greatest Common Divisor of two integers k, l ;  $  TAB1 if l is equal to 0 ;  $  TAB2 return the value of k ;  $  TAB1 else do the following ;  $  TAB2 return the Greatest Common Divisor of l, k modulo l ;  $  TAB0 it is a function which returns Least Common Multiple of two integers m, n ;  $  TAB1 return the value of (m * n) / Greatest Common Divisor of m, n ;  $  TAB1 ans is equal to 0 ;  $  TAB1 read x, y, a, b ;  $  TAB1 let kpk be a integer ;  $  TAB1 kpk is equal to Least Common Multiple of x, y ;  $  TAB1 ans is equal to floor (b / kpk) - floor ((a - 1) / kpk) ;  $  TAB1 print ans and newline ;
TAB1 let x, y, a, b, p, ans, u, v, gcd, lcm be int ;  $  TAB1 read x, y, a, b ;  $  TAB1 set p to the __gcd of x and y ;  $  TAB1 set lcm to x*y/p ;  $  TAB1 set u = a / lcm ;  $  TAB1 set v = b / lcm ;  $  TAB1 set ans = v - u ;  $  TAB1 if a mod lcm is 0 then increment ans ;  $  TAB1 print ans ;
TAB0 declare integer gcd with integers a, b as arguments ;  $  TAB1 return a if b is 0, else gcd ( b, a % b ) ;  $  TAB0 declare lcm as integer with integers a, b as arguments ;  $  TAB1 return a / result of run gcd with a, b as arguments * b ;  $  TAB1 declare x, y, a, b as integers ;  $  TAB1 read x and y and a and b ;  $  TAB1 declare LCM = run lcm(x,y) ;  $  TAB1 print (b/LCM) - ((a - 1) / LCM), newline ;
TAB0 declare gcd with integers x, y as arguments, returning integer ;  $  TAB1 if y is 0, return x ;  $  TAB1 return result of run gcd with y, x % y as arguments from function ;  $  TAB0 declare lcm with integers x, y as arguments, returning integer ;  $  TAB1 return ( x * y ) / run gcd(x,y) ;  $  TAB1 declare x, y, a, b, ans = 0 as integers ;  $  TAB1 read x, y, a, b ;  $  TAB1 let ans be -a/ result of run lcm(x,y) + b / result of run lcm(x,y) ;  $  TAB1 if a % result of run lcm(x,y) is 0, increment ans by 1 ;  $  TAB1 print ans, newline ;
TAB1 declare x, y, a, b, p as integers ;  $  TAB1 read x read y read a read b ;  $  TAB1 let b be result of run __gcd(x, y) ;  $  TAB1 let x be x * y ;  $  TAB1 let x be x / p ;  $  TAB1 if a % x is 0 ;  $  TAB2 let a be a / x ;  $  TAB2 decrement a ;  $  TAB1 else ;  $  TAB2 let a be a / x ;  $  TAB1 let b be b / x ;  $  TAB1 print b - a print newline ;
TAB0 integer function gcd with int arguments a and b ;  $  TAB1 while b > 0 ;  $  TAB2 declare new integer tmp with value b ;  $  TAB2 set b to a % b ;  $  TAB2 change a to tmp ;  $  TAB1 return a ;  $  TAB0 int function lcm with int arguments a and b ;  $  TAB1 return a * b / gcd of a and b ;  $  TAB1 set output decimal precision to 12 ;  $  TAB1 declare new integer called x ;  $  TAB1 read from the input to x ;  $  TAB1 create new integer variable y ;  $  TAB1 read the input to y ;  $  TAB1 create new integer a ;  $  TAB1 read user input to a ;  $  TAB1 declare new integer called b ;  $  TAB1 read variable b from the input ;  $  TAB1 print b / lcm(x, y) - (a - 1) / lcm(x, y) ;
TAB1 create int a, b, c, x, y, z ;  $  TAB1 read x, y, a and b ;  $  TAB1 set z to (x * y) / __gcd(x, y) ;  $  TAB1 assign b/z to c ;  $  TAB1 set c to c - (a - 1) / z ;  $  TAB1 print c and a newline ;
TAB0 let gcd be a integer function which accepts integers x and y ;  $  TAB1 if x is equal to y, return the value of x ;  $  TAB1 while x is not equal to 0 and y is not equal to 0 ;  $  TAB2 if x is greater than y ;  $  TAB3 x is equal to x modulo y ;  $  TAB2 else do the following ;  $  TAB3 y is equal to y modulo x ;  $  TAB1 return y if x is less than y else return x ;  $  TAB1 let x, y, a, b be integers ;  $  TAB1 read x, y, a, b ;  $  TAB1 let z be a integer with z is equal to x * y / gcd of x, y ;  $  TAB1 print b / z - (a - 1) / z and newline ;
TAB0 declare constant integer INF = 0x3f3f3f3f ;  $  TAB0 declare gcd with integers a, b as arguments, returning integer ;  $  TAB1 if a is less than b, swap values between a and b ;  $  TAB1 if not b, return a ;  $  TAB1 return run gcd ( b , a % b ) ;  $  TAB1 declare i, j, k as integers ;  $  TAB1 declare n, m, a, b, c, d as integers ;  $  TAB1 read a, b, c, d ;  $  TAB1 let k be run gcd(a,b) ;  $  TAB1 let k be a / k * b; ;  $  TAB1 let m be d / k - c / k ;  $  TAB1 if c % k is 0, increment m ;  $  TAB1 print m and newline ;
TAB0 let gcd be a function which accepts long integers a and b ;  $  TAB1 if b is equal to 0 ;  $  TAB2 return the value of a ;  $  TAB1 else do the following ;  $  TAB2 return value gcd of b , a modulo b ;  $  TAB1 let x, y, a, b be long integers ;  $  TAB1 read x, y, a, b ;  $  TAB1 let g be a long integer with g = gcd of maximum of x, y and minimum of x, y ;  $  TAB1 let lcm be a long integer with lcm = (x * y) / g ;  $  TAB1 let r be a long integer with r = b / lcm ;  $  TAB1 let l be a long integer with l = (a - 1) / lcm ;  $  TAB1 print r - l and newline ;
TAB1 let cns, cnt be integers with cns is equal to 0, cnt is equal to 0x3f3f3f3f ;  $  TAB1 let n, strength be integers with strength is equal to array of integers of length 100001 ;  $  TAB1 read n ;  $  TAB1 for i= 0 to n exclusive ;  $  TAB2 read ith element of array strength ;  $  TAB2 if (ith element of array strength is greater than cns), cns is equal to ith element of array strength ;  $  TAB2 if (ith element of array strength is less than cnt), cnt is equal to ith element of array strength ;  $  TAB1 let vis be a integer with value is equal to 0 ;  $  TAB1 for (i = 0 to n exclusive) ;  $  TAB2 if (ith element of array strength is equal to cns or ith element of array strength is equal to cnt), increase vis by 1 ;  $  TAB1 print n - vis and newline ;
TAB1 size, maior, menor c = int with maior = -0x3f3f3f3f and menor = 0x3f3f3f3f and c = 0 ;  $  TAB1 read size ;  $  TAB1 vector = int vector of size size ;  $  TAB1 for i = 0 to size ;  $  TAB2 read vctor[i] ;  $  TAB2 set maior to max of maior and vetor[i] then set menor to min of menor and vetor[i] ;  $  TAB1 for i = 0 to size ;  $  TAB2 increment c if vetor[i] is greater then menor and less than maior ;  $  TAB1 print c ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 cnt = int with cnt = 0 ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 call sort on a + 1 and a + 1 + n ;  $  TAB1 if n equals 1 or 2 ;  $  TAB2 print 0 ;  $  TAB1 else if n is greater than 2 ;  $  TAB2 minn = int with minn = a[1] ;  $  TAB2 mixx = int with mixx = a[n] ;  $  TAB2 for i = 2 to n - 1 inclusive ;  $  TAB3 if a[i] is between minn and mixx then increment cnt ;  $  TAB2 print cnt ;
TAB1 n = int and a = int array of size 100010 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 sort all n elements in array a starting at a + 1 ;  $  TAB1 b, c = int with b = a[1] and c = a[n] ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] is between b and c then increment ans ;  $  TAB1 print ans ;
TAB0 MAX = 100005 ;  $  TAB0 n,cnt,ans = int, arr = array of MAX int ;  $  TAB0 dict = set of int ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 insert arr[i] into dict ;  $  TAB1 cnt=0 ;  $  TAB1 iterate on dict incrementing cnt ;  $  TAB1 if cnt < 3 ;  $  TAB2 print "0" ;  $  TAB1 sort first n elements of arr ;  $  TAB1 ans = n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if arr[i] == arr[0] or arr[n-1] decrement ans ;  $  TAB1 print ans ;
TAB1 i, n, cnt =integers with cnt = 0 and a = array of 100001 integers ;  $  TAB1 Read n ;  $  TAB1 Read n values into array a ;  $  TAB1 mx = integer, set to a[0] ;  $  TAB1 mn = integer, set to a[0] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is greater than mx, set mx to a[i] ;  $  TAB2 if a[i] is less than mn, set mn to a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is greater than mn and a[i] is less than mx ;  $  TAB1 print cnt and a new line ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 arr = int array of size n ;  $  TAB1 read n values into arr ;  $  TAB1 sort array arr ;  $  TAB1 a, b = int with a = arr[0] and b = arr[n - 1] ;  $  TAB1 x = int with x = value of upper_bound of arr, arr + n and a - arr ;  $  TAB1 y = int with y = value of lower_bound of arr, arr + n and a - arr ;  $  TAB1 if y is 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print y - x ;
TAB1 create integer s ;  $  TAB1 read s ;  $  TAB1 let a be integer array with size s ;  $  TAB1 for i = 0 to s exclusive read a[i] ;  $  TAB1 sort a ;  $  TAB1 if s = 1 || s = 2 ;  $  TAB2 print "0" ;  $  TAB1 declare integer variable t = s - 2 ;  $  TAB1 for integer i = 1 to s - 1 exclusive ;  $  TAB2 if a[i] > a[0] and a[i] < a[s - 1] ;  $  TAB3 skip the rest of the loop ;  $  TAB2 else ;  $  TAB3 decrease t by one ;  $  TAB1 print t ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer t ;  $  TAB1 create integer vector a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t ;  $  TAB2 add element t to end of a ;  $  TAB1 if size of a is less than 3 ;  $  TAB2 print 0 print newline ;  $  TAB1 sort elements from beginning of a to end of a ;  $  TAB1 create integer cnt with cnt = 0 ;  $  TAB1 for i = 1 to n - 2 inclusive ;  $  TAB2 if a[i] is greater than a[0] and a[i] is less than a[n-1], increment cnt ;  $  TAB1 print cnt print newline ;
TAB1 create integers n, sum with sum = 0, create integer array a with size 100000 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 create integers max, min with max = a[0], min = a[0] ;  $  TAB1 for j = 0 to n exclusive ;  $  TAB2 if max is less than a[j], set max to a[j] ;  $  TAB2 if min is greater than a[j], set min to a[j] ;  $  TAB1 for t = 0 to n exclusive ;  $  TAB2 if a[t] is less than max and a[t] is greater than min, increment sum ;  $  TAB1 print sum print newline ;
TAB0 let a be integer array with size 100005 ;  $  TAB1 declare integer variables n, c1, c2, maxx and minn with c1, c2 and maxx = 0 and minn = 1000000007 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 maxx = max of maxx and a[i], minn = min of minn and a[i] ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 increment c1 if a[i] = maxx ;  $  TAB2 increment c2 if a[i] = minn ;  $  TAB1 if maxx = minn ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print n - c1 - c2 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 arr = int array of size n ;  $  TAB1 read n values into arr ;  $  TAB1 if n is less than 3 ;  $  TAB2 print 0 ;  $  TAB1 sort array arr ;  $  TAB1 cnt = int with cnt = 0 ;  $  TAB1 for i = 1 to n - 1 ;  $  TAB2 if arr[i] is between the first and last value of arr then increment cnt ;  $  TAB1 print cnt ;
TAB1 n, b, s, ans = integers with ans = 0 ;  $  TAB1 read n ;  $  TAB1 arr = integer array of n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 b = arr[0] ;  $  TAB1 s = arr[0] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] > b, b = arr[i] ;  $  TAB2 if arr[i] < s, s = arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] is b or arr[i] is s, continue next iteration ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB0 create int array a of length 100005 ;  $  TAB1 create n and m ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive, read a[i] ;  $  TAB1 sort a + 1, a + n + 1 ;  $  TAB1 t = n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if a[i] = a[1] or a[i] = a[n], decrement t ;  $  TAB1 print t ;
TAB1 n, count = integer with count = 0 ;  $  TAB1 read n ;  $  TAB1 a = integer array of size n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort a and a + n ;  $  TAB1 mx = integer with mx = pointer max_element(a, a + n) ;  $  TAB1 mn = integer with mn = pointer min_element(a, a + n) ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] > mn and a[i] < mx, increment count ;  $  TAB1 print count ;
TAB1 declare long long variables n and cnt where cnt = 0 ;  $  TAB1 read n ;  $  TAB1 x is vector of long longs with n elements ;  $  TAB1 y is a set of long longs ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 read x[i] ;  $  TAB2 insert x[i] into y ;  $  TAB1 if n <= 2 or size of y <= 2 ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 sort x ;  $  TAB2 loop i from 0 to n exclusive ;  $  TAB3 if x[i] != x[0] and x[i] != x[n - 1], increment cnt by one ;  $  TAB2 print cnt ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 se = int vector ;  $  TAB1 answer = int with answer = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 x = int ;  $  TAB2 read x ;  $  TAB2 append x to se ;  $  TAB1 sort se ;  $  TAB1 min = int with min = se[0] ;  $  TAB1 max = int with max = last value of se ;  $  TAB1 for i = 0 to n ;  $  TAB2 if se[i] is between min and max then increment answer ;  $  TAB1 print answer ;
TAB1 create integer array a with size 100000, create integers n, c1, c2, mx, mn with c1 = 0, c2 = 0, mx = 0, mn = 1000000000 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 set mx to maximum of mx and a[i] ;  $  TAB2 set mn to minimum of mn and a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is mx, increment c1 ;  $  TAB2 if a[i] is mn, increment c2 ;  $  TAB1 if mx is mn ;  $  TAB2 print 0 print newline ;  $  TAB1 else ;  $  TAB2 print ( n - c1 - c2 ) print newline ;
TAB1 n, res, mn, mx = integers with res = 0, mn = INT_MAX, mx = INT_MIN ;  $  TAB1 a = integer array of size 100001 ;  $  TAB1 b1, b2 = bool with b1 = 0, b2 = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 mn = min of a[i] and mn ;  $  TAB2 mx = max of a[i] and mx ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] > mn and a[i] < mx, increment res ;  $  TAB1 print res ;
TAB1 create integer t, integer array a with dimension 105 ;  $  TAB1 read t ;  $  TAB1 for integer i=0 to t-1 with increment i do read a[i] ;  $  TAB1 sort a ;  $  TAB1 print a[t-1] and a blank space ;  $  TAB1 for integer i=1 to t-2 with increment i do print a[i] and a blank space ;  $  TAB1 print a[0] ;
TAB0 create integer array a of size 101 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read a[i] ;  $  TAB1 sort a + 1 using argument a + n + 1 ;  $  TAB1 print a[n] and ' ' ;  $  TAB1 for i = 2 to n - 1, print a[i] and ' ' ;  $  TAB1 print a[1] ;
TAB0 declare constant integer mod with value 1e9 + 7 ;  $  TAB0 max i a new constant integer with value 110 ;  $  TAB0 create new constant int inf = 0x3f3f3f3f ;  $  TAB0 p is an array of integers with maxn elements ;  $  TAB0 declare new array of integers q with size maxn ;  $  TAB1 create new integer variable t ;  $  TAB1 read t and loop further ;  $  TAB2 for i from 1 to t inclusive, read from the input to p[i] ;  $  TAB2 sort p ;  $  TAB2 print p[t] and ' ' ;  $  TAB2 in a for loop, change i from 2 to t exclusive, printing p[i] and ' ' on each loop iteration ;  $  TAB2 print p[1] ;
TAB0 a is a new array of integers with size 105 ;  $  TAB0 inf is a new constant integer = 0x3f3f3f3f ;  $  TAB1 create integer variable n ;  $  TAB1 loop, reading n from the input ;  $  TAB2 declare integer variables ma with value -inf and mi = inf ;  $  TAB2 for i from 0 to n exclusive incrementing i ;  $  TAB3 read variable a[i] from the input ;  $  TAB3 change the value of ma to max of ma and a[i] ;  $  TAB3 assign the new value = min of mi and a[i] to mi ;  $  TAB2 sort a ;  $  TAB2 print ma and ' ' ;  $  TAB2 print elements of a from the index 1 to n - 1 exclusive with ' ' after each one ;  $  TAB2 print mi ;
TAB0 declare new constant integer INF with value 100000000 ;  $  TAB0 a is a new array of integers with size 150 ;  $  TAB1 create integer n ;  $  TAB1 read n and loop further ;  $  TAB2 read standard input to a from the index i to n inclusive ;  $  TAB2 sort a ;  $  TAB2 create integer variable t with value a[1] ;  $  TAB2 assign a[n] to a[1] ;  $  TAB2 change a[n] to t ;  $  TAB2 print a[1] ;  $  TAB2 start for loop from i = 2 to n inclusive, print ' ' and a[i] on each loop ;  $  TAB2 print new line ;
TAB1 n, j, i, r = int and a = int array of size 200 ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 for j = 0 to n - 1 - i ;  $  TAB3 if a[j] > a[j + 1] ;  $  TAB4 set r to a[j] ;  $  TAB4 set a[j] to a[j + 1] ;  $  TAB4 set a[j + 1] to r ;  $  TAB1 print a[n - 1] ;  $  TAB1 for i = 1 to n - 1 print a[i] then " " ;  $  TAB1 print a[0] ;
TAB0 function qo with bool argument x that returns boolean ;  $  TAB1 return 0 if x is true and qo(!x) othersiwe ;  $  TAB0 mnx is a new constant integer = 1e7 + 9 ;  $  TAB0 declare new constant called mod with value 1e9+7 and type int ;  $  TAB0 create new long long n ;  $  TAB0 declare new array of long longs x with mnx elements ;  $  TAB0 create new array of long longs u with size mnx ;  $  TAB0 k is a new array of long longs with size mnx ;  $  TAB0 declare new long long variables cnt and c ;  $  TAB1 read n from the user input ;  $  TAB1 read n elements from the input to x[i] starting from the index 1 ;  $  TAB1 sort x from position 1 to n + 1 ;  $  TAB1 print x[n] and ' ' ;  $  TAB1 start for loop from i = 1 to n inclusive ;  $  TAB2 if i = n or i = 1, go to the start of the loop ;  $  TAB2 print x[i] and ' ' ;  $  TAB1 print x[1] and '\n' to the standard output ;
TAB0 declare constant integer N = 1e6 + 5 ;  $  TAB0 declare integers n, a, c = 2, ans ;  $  TAB0 declare integer vector v ;  $  TAB1 read n ;  $  TAB1 while decrement n is true, read a, add a to end of v ;  $  TAB1 sort from beginning of v to end of v ;  $  TAB1 if size of v is 2 ;  $  TAB2 print back of v, " ", v[0], newline ;  $  TAB1 print back of v, " " ;  $  TAB1 for i = 1 to size of v - 1 exclusive, print v[i], " " ;  $  TAB1 print v[0] and newline ;
TAB1 create int array a of size 101 ;  $  TAB1 create int n ;  $  TAB1 read n and while it's truthy ;  $  TAB2 create int i ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 sort a ;  $  TAB2 print a[n - 1] and ' ' ;  $  TAB2 for i = 1 to n - 1 exclusive, print a[i] and ' ' ;  $  TAB2 print a[0] ;
TAB1 n,i=int ;  $  TAB1 while read n ;  $  TAB2 arr and res=array of 110 int filled with 0, max=-10000, min=10000, p_max, p_min and k=int ;  $  TAB2 read arr[0] ;  $  TAB2 max = min = arr[0] ;  $  TAB2 p_max = p_min = 0 ;  $  TAB2 for i=1 to n exclusive ;  $  TAB3 read arr[i] ;  $  TAB3 if arr[i] < min ;  $  TAB4 min=arr[i] ;  $  TAB4 p_min=i ;  $  TAB3 else if arr[i]>max ;  $  TAB4 max=arr[i] ;  $  TAB4 p_max=i ;  $  TAB2 k=0 ;  $  TAB2 for i=0 to n exclusive ;  $  TAB3 if i is p_min or p_max continue ;  $  TAB3 res[k]=arr[i], increment k ;  $  TAB2 sort first k items of res ;  $  TAB2 if p_max is not p_min print max, space ;  $  TAB2 for i=0 to k exclusive print res[i], space ;  $  TAB2 print min ;
TAB1 n is a new integer ;  $  TAB1 a is a new array of integers with size 1000 ;  $  TAB1 read n and keep looping ;  $  TAB2 declare new integers b and c ;  $  TAB2 read n elements from the input stream into a[i] ;  $  TAB2 sort a ;  $  TAB2 assign the new value = a[0] to b ;  $  TAB2 assign a[n - 1] to c ;  $  TAB2 print c to the standard output ;  $  TAB2 in a for loop, change i from 1 to n - 1 exclusive, print " " and a[i] on each iteration ;  $  TAB2 print " " and b to the standard output ;
TAB0 let cmp be a boolean function which accepts integers a , b ;  $  TAB1 return a greater than b ;  $  TAB0 cc = array of integers of length 105 ;  $  TAB1 let n, res , flag , f be integers with res = 0, flag = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read cc[i] ;  $  TAB1 sort the values cc + 1 and cc + 1 + n ;  $  TAB1 swap the values cc[1], cc[n] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i is equal to n ;  $  TAB3 print cc[i] and newline ;  $  TAB2 else do the following ;  $  TAB3 print cc[i] and space ;
TAB0 INF = const integer with INF = 0x3f3f3f3f ;  $  TAB0 T = const integer with T = 103 ;  $  TAB0 row = integer array of size T ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read row[i] ;  $  TAB1 sort row and row + n ;  $  TAB1 print row[n - 1] ;  $  TAB1 for i = 1 to n -1 exclusive, print row[i] ;  $  TAB1 print row[0] ;
TAB0 declare new array of integers p with size 500 ;  $  TAB1 declare integer n ;  $  TAB1 read n and keep looping ;  $  TAB2 set values of first sizeof(p) bytes at the pointer p to 0 ;  $  TAB2 for integer i = 0 to n exclusive, read p[i] ;  $  TAB2 sort p from index 0 to n ;  $  TAB2 print p[n - 1] to the standard output ;  $  TAB2 print " " and p[i] to the standard output on a loop for i from 1 to n - 1 exclusive ;  $  TAB2 print " " and p[0] ;
TAB0 let A an int array of length 100010 ;  $  TAB1 let n an int ;  $  TAB1 read n ;  $  TAB1 read the first n values of A ;  $  TAB1 sort the first n values of A ;  $  TAB1 reverse the first n values of A ;  $  TAB1 let ans be a vector of ints ;  $  TAB1 print A[0] ;  $  TAB1 for i from n-2 down to 1, print A[i] ;  $  TAB1 print A[n-1] ;
TAB0 a = integer array of size 110 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 i = integer ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort a and a + n ;  $  TAB1 print a[n - 1] ;  $  TAB1 for i = 1 to n - 1 exclusive, print a[i] ;  $  TAB1 print a[0] ;
TAB1 v = vector of integer ;  $  TAB1 n, a = integers ;  $  TAB1 read n ;  $  TAB1 while decrement n ;  $  TAB2 read a ;  $  TAB2 append a in v ;  $  TAB1 sort v.begin() and v.end() ;  $  TAB1 print v[v.size() - 1] ;  $  TAB1 for i = 1 to i + 1 < v.size(), print v[i] ;  $  TAB1 print v[0] ;
TAB1 let n, i be integers ;  $  TAB1 read n ;  $  TAB1 a = array of integers of length n + 1 ;  $  TAB1 for i = 1 to n inclusive , read a[i] ;  $  TAB1 sort the values a + 1, a + n + 1 ;  $  TAB1 print a[n] and space ;  $  TAB1 for i = 2 to n exclusive , print a[i] and space ;  $  TAB1 print a[1] and newline ;
TAB1 declare string a ;  $  TAB1 read a ;  $  TAB1 declare integer s = 0 ;  $  TAB1 for i = 0 to a[i], incrementing i ;  $  TAB2 if a[i] is 'a' or a[i] is 'e' or a[i] is 'i' or a[i] is 'o' or a[i] is 'u' ;  $  TAB3 increment s ;  $  TAB2 else if a[i] is greater than or equal to '0' and a[i] is less than or equal to '9' and ( a[i] - 48 ) % 2 is not 0 ;  $  TAB3 increment s ;  $  TAB1 print s and newline ;
TAB1 create string a ;  $  TAB1 read a ;  $  TAB1 num = 0 ;  $  TAB1 b = aeiou13579 ;  $  TAB1 for i = 0 to size of a exclusive ;  $  TAB2 for j = 0 to size of b exclusive ;  $  TAB3 if a[i] = b[j] increment num ;  $  TAB1 print num ;
TAB0 function isVowel takes a character a and returns a boolean value ;  $  TAB1 return the value of (a is equal to a or a is equal to e or a is equal to i or a is equal to o or a is equal to u) ;  $  TAB0 function isOdd takes a character a and returns a boolean value ;  $  TAB1 return the value of (a is equal to 1 or a is equal to 3 or a is equal to 5 or a is equal to 7 or a is equal to 9) ;  $  TAB1 text is a string ;  $  TAB1 read text ;  $  TAB1 num is an integer and equals 0 ;  $  TAB1 for integer i = 0 to text.length() exclusive ;  $  TAB2 if isVowel(text[i]) or isOdd(text[i] is true, increase num by 1 ;  $  TAB1 print num and newline ;
TAB1 s = string ;  $  TAB1 num = integer = 0 ;  $  TAB1 while s is read as a valid string ;  $  TAB2 for i = 0 to length of s exclusive ;  $  TAB3 if s[i] contians a,e,i,o,u,1,3,5,7, or 9, then increase num by 1 ;  $  TAB2 print num ;
TAB1 make a map called t using character and integer ;  $  TAB1 set t[a] to 1 ;  $  TAB1 set t[e] to 1 ;  $  TAB1 set t[i] to 1 ;  $  TAB1 set t[o] to 1 ;  $  TAB1 set t[u] to 1 ;  $  TAB1 set t[1] to 1 ;  $  TAB1 set t[3] to 1 ;  $  TAB1 set t[5] to 1 ;  $  TAB1 set t[7] to 1 ;  $  TAB1 set t[9] to 1 ;  $  TAB1 integers = ans = 0 ;  $  TAB1 s = string array ;  $  TAB1 read s ;  $  TAB1 for i = 0 to less than s.size() then add one to t[s[i]] ;  $  TAB1 output ans ;
TAB1 declare integer variable with name res = 0 ;  $  TAB1 create new string a = "aeiou13579" ;  $  TAB1 create string variable str ;  $  TAB1 read str from the input ;  $  TAB1 in a for loop, change i from 0 to exclusive ;  $  TAB2 if there is part, that equals to str[i], in a, increment res ;  $  TAB1 print res ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 a = string = aeiou13579 ;  $  TAB1 cnt = integer = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 for j = 0 to size of a exclusive ;  $  TAB3 if s[i] is a[j], then increase cnt by 1 ;  $  TAB1 print cnt ;
TAB0 vowel is a bool function with char argument ch ;  $  TAB1 if ch is one of: 'a', 'e', 'i', 'o' or 'u' ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB0 boolean function even with char argument ch ;  $  TAB1 if ch is an odd digit character ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB1 declare new string s ;  $  TAB1 read user input to s ;  $  TAB1 create integer variable with name len ;  $  TAB1 count is a new integer with value 0 ;  $  TAB1 for i from 0 to len exclusive incrementing i ;  $  TAB2 create new character called ch with value s[i] ;  $  TAB2 if vowel(ch) returns true, increment count by one ;  $  TAB2 if even(ch) returns true, increment count by one ;  $  TAB1 print count ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare integers i and j ;  $  TAB1 declare integer len = length of s ;  $  TAB1 declare integer cnt = 0 ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if s[i] is greater than or equal to 'a' and s[i] is less than or equal to 'z' ;  $  TAB3 if s[i] is 'a' or s[i] is 'e' or s[i] is 'i' or s[i] is 'o' or s[i] is 'u', increment cnt ;  $  TAB2 if s[i] is greater than or equal to '0' and s[i] is less than or equal to '9' ;  $  TAB3 if ( s[i] - '0' ) % 2 is 1, increment cnt ;  $  TAB1 print cnt and newline ;
TAB1 let i, j, k, l, m, n be integers ;  $  TAB1 let s be a string ;  $  TAB1 read s ;  $  TAB1 m is equal to 0 ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is equal to a or s[i] is equal to e or s[i] is equal to i or s[i] is equal to o or s[i] is equal to u ;  $  TAB3 increment m by 1 ;  $  TAB2 else if s[i] >= 0 and s[i] <= 9 ;  $  TAB3 if (s[i] - 0) modulo 2 is not equal to 0, increment m by 1 ;  $  TAB1 print m and newline ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 dic = string = 13579aeiou ;  $  TAB1 cont = integer = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if i s[i] is in dic, the increase cont by 1 ;  $  TAB1 print cont ;
TAB0 s=set of char ;  $  TAB1 insert 'a' into s ;  $  TAB1 insert 'e' into s ;  $  TAB1 insert 'i' into s ;  $  TAB1 insert 'o' into s ;  $  TAB1 insert 'u' into s ;  $  TAB1 for i=1 to 10 by 2 exclusive insert i+'0' into s ;  $  TAB1 k=string ;  $  TAB1 ans=0 ;  $  TAB1 read k ;  $  TAB1 len=length of k ;  $  TAB1 for i=0 to len exclusive ;  $  TAB2 if k[i] is present in s increment ans ;  $  TAB1 print ans ;
TAB0 dict=array of 15 char filled with "13579aeiou" ;  $  TAB1 s=array of 55 char ;  $  TAB1 sum,i=0 ;  $  TAB1 read s ;  $  TAB1 while s[i] is not null byte ;  $  TAB2 flag=1 ;  $  TAB2 for j=0 to 10 exclusive ;  $  TAB3 if s[i] is dict[j] flag=0 ;  $  TAB2 if flag is 0 increment sum ;  $  TAB2 increment i ;  $  TAB1 print sum ;
TAB0 ans = int ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to size of s ;  $  TAB2 if isalpha of s[i] ;  $  TAB3 if s[i] is 'a' or 'e' or 'o' or 'i' or 'u' increment ans ;  $  TAB2 else if s[i] is uneven ;  $  TAB3 increment ans ;  $  TAB1 print ans ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 c = int with c = 0 ;  $  TAB1 for i = 0 to length of s ;  $  TAB2 if s[i] is 'a' or 'e'E or 'i' or 'o' or 'u' ;  $  TAB3 increment c ;  $  TAB2 else if (s[i] < 'a' or s[i] > 'z') and (s[i] - '0') mod 2 is not 0 ;  $  TAB3 increment c ;  $  TAB1 print c ;
TAB0 declare character set s ;  $  TAB1 insert 'a' into s ;  $  TAB1 insert 'e' into s ;  $  TAB1 insert 'i' into s ;  $  TAB1 insert 'o' into s ;  $  TAB1 insert 'u' into s ;  $  TAB1 for i = 1 to 10 exclusive, incrementing i by 2, insert ( i + '0' ) into s ;  $  TAB1 declare string k ;  $  TAB1 declare ans = 0 as integer ;  $  TAB1 read k ;  $  TAB1 deeclare len = length of k as integer ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if count of k[i] in s, increment ans ;  $  TAB1 print ans and newline ;
TAB1 a=array of 55 char ;  $  TAB1 read a ;  $  TAB1 i,cnt=0 ;  $  TAB1 while a[i] is not null byte increment i ;  $  TAB2 if a[i] is a digit ;  $  TAB3 if a[i]-'0' is odd increment cnt ;  $  TAB2 if a[i] is one of 'a', 'e', 'i', 'o', 'u' increment cnt ;  $  TAB1 print cnt ;
TAB0 in the function isvowel that takes character c and returns bool ;  $  TAB1 if (c is a or c is e or c is i or c is o or c is u), return true ;  $  TAB1 return false ;  $  TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 siz = integer with siz = str.length() ;  $  TAB1 cnt = integer with cnt = 0 ;  $  TAB1 for i = 0 to siz exclusive ;  $  TAB2 if (isvowel(str[i])) ;  $  TAB3 increment cnt ;  $  TAB2 else if (not isalpha(str[i]) and (str[i] - 0) bitwise and 1) ;  $  TAB3 increment cnt ;  $  TAB1 print cnt ;
TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 ans=0 ;  $  TAB1 for i=0 to length of s exclusive ;  $  TAB2 if s[i] is 'a' or 'e' or 'i' or 'o' or 'u' ;  $  TAB3 increment ans ;  $  TAB2 else if s[i]>'0' and <='9' and (s[i]-'0') is odd ;  $  TAB3 increment ans ;  $  TAB1 print ans ;
TAB1 make string s ;  $  TAB1 create integer c = 0 ;  $  TAB1 read s ;  $  TAB1 make integer len = s.size() ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if strchr("aeiou13579", s[i]) is truthy, increment c ;  $  TAB1 output c ;
TAB0 set const int INF to 0x3f3f3f3f ;  $  TAB0 set const int maxn to 5005 ;  $  TAB0 integers = arr as an array of maxn ;  $  TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 if n modulo 10 >= 0 and n modulo 10 is less than or equal to 5 then do the following ;  $  TAB2 output n / 10 * 10 ;  $  TAB1 else ;  $  TAB2 if n modulo 10 is true do then add 1 to n ;  $  TAB2 output n ;
TAB0 in the function func that takes long long x ;  $  TAB1 if ((x modulo 10) > 5) print (x / 10 + 1) * 10 ;  $  TAB1 if ((x modulo 10) <= 5) print (x / 10) * 10 ;  $  TAB1 x = long long ;  $  TAB1 while (print x), call func on x ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 if n % 10 is greater than 5 ;  $  TAB2 set n to n - n % 10 + 10 ;  $  TAB1 else ;  $  TAB2 set n to n - n % 10 ;  $  TAB1 print n print newline ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 if n mod 10 <= 5 ;  $  TAB2 print n/10 *10 ;  $  TAB1 else ;  $  TAB2 print (n / 10 + 1) * 10 and a newline ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 t = integer, set to n modulo 10 ;  $  TAB1 if t is greater than or equal to 6 ;  $  TAB2 set n to n - t + 10 ;  $  TAB1 else do the following ;  $  TAB2 set n to n - t ;  $  TAB1 print n and a new line ;
TAB1 n = long long integers ;  $  TAB1 read n ;  $  TAB1 integer t = n modulo 10 ;  $  TAB1 if t is greater than or equal to 6 then do the following ;  $  TAB2 set n to n - t + 10 ;  $  TAB1 else ;  $  TAB2 set n to n - t ;  $  TAB1 output n ;
TAB1 t, s, a, b, c =integers ;  $  TAB1 Read t ;  $  TAB1 print 1LL * ((t + 4) / 10) * 10 and a new line ;
TAB0 x, n = integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 10 <= 5 ;  $  TAB2 x = 0 ;  $  TAB1 else ;  $  TAB2 x = 1 ;  $  TAB1 print (n / 10 + x) * 10 ;
TAB0 create long long n ;  $  TAB1 read n ;  $  TAB1 if n mod 10 greater than 5 ;  $  TAB2 print n + (10 - n % 10) ;  $  TAB1 else ;  $  TAB2 print n - (n % 10) and a newline ;
TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 create int num = n modulo 10 ;  $  TAB1 if num = 0 ;  $  TAB2 print n ;  $  TAB1 else if num <= 5 ;  $  TAB2 print n - num ;  $  TAB1 else ;  $  TAB2 print n - num + 10 ;
TAB1 create long long integer n ;  $  TAB1 read n ;  $  TAB1 create long long integer m with m = n % 10 ;  $  TAB1 create long integer d with d = n / 10 ;  $  TAB1 if m is 0 ;  $  TAB2 print n print newline ;  $  TAB1 else if m is less than or equal to 5 ;  $  TAB2 print n - m print newline ;  $  TAB1 else if m is greater than 5 ;  $  TAB2 print n + 10 - m print newline ;
TAB1 let n, m and ans be integers ;  $  TAB1 read n while it is not 0 ;  $  TAB2 set m to n modulo 10 ;  $  TAB2 if m <= 5 ;  $  TAB3 assign n / 10 * 10 to ans ;  $  TAB2 else ;  $  TAB3 assign (n / 10 + 1) * 10 to ans ;  $  TAB2 print ans ;
TAB0 set pi to 3.1415926535 ;  $  TAB0 set mod to 998244353 ;  $  TAB0 assign 5e5 + 10 to maxn ;  $  TAB1 create int n ;  $  TAB1 while read n ;  $  TAB2 if n mod 10 <= 5 ;  $  TAB3 print n - n mod 10 ;  $  TAB2 else ;  $  TAB3 print n + 10 - n mod 10 and a newline ;
TAB0 declare const int N = 1e6 + 10 ;  $  TAB0 declare const int mod = 998244353 ;  $  TAB0 create long long x ;  $  TAB1 read x ;  $  TAB1 if x % 10 is equal to 0 ;  $  TAB2 print x ;  $  TAB1 else if x % 10 <= 5 ;  $  TAB2 print (x / 10) * 10 ;  $  TAB1 else ;  $  TAB2 print (x / 10) * 10 + 10 ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 if n modulo 10 is less than or equal to 5 then do the following ;  $  TAB2 output (n / 10) * 10 ;  $  TAB1 else ;  $  TAB2 output (n / 10 + 1) * 10 ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 if n / 10 is 0 ;  $  TAB2 if n is less than 6 ;  $  TAB3 print "0" ;  $  TAB2 else ;  $  TAB3 print "10" ;  $  TAB1 else ;  $  TAB2 if n mod 10 is less than 6 ;  $  TAB3 print n / 10 then 0 ;  $  TAB2 else ;  $  TAB3 print n / 10 + 1 then 0 ;
TAB0 create long long n ;  $  TAB0 create long long x ;  $  TAB1 read n ;  $  TAB1 x=n ;  $  TAB1 if n mod 10 =0 ;  $  TAB2 print n ;  $  TAB1 while x greater than 10, set x to x mod 10 ;  $  TAB1 if x <= 5 ;  $  TAB2 print n-x ;  $  TAB1 else ;  $  TAB2 print n + 10 - x and a newline ;
TAB1 create int n, result and c ;  $  TAB1 read n ;  $  TAB1 c = n mod 10 ;  $  TAB1 if c <= 5 ;  $  TAB2 assign n - c to result ;  $  TAB1 else ;  $  TAB2 set result = n + 10 - c ;  $  TAB1 print result ;
TAB1 create long long int n, m, k, l, j, p ;  $  TAB1 read n ;  $  TAB1 if n less than 10 ;  $  TAB2 if n<= 5 ;  $  TAB3 print 0 ;  $  TAB2 else ;  $  TAB3 p = n + (10 - n) ;  $  TAB3 print p ;  $  TAB1 else ;  $  TAB2 assign n mod 10 to k ;  $  TAB2 if k=0 ;  $  TAB3 print n ;  $  TAB2 else ;  $  TAB3 if k <= 5 ;  $  TAB4 set l to n - k ;  $  TAB4 print l ;  $  TAB3 else ;  $  TAB4 j = n + (10 - k) ;  $  TAB4 print j and a newline ;
TAB1 a, b, c, d, e, f = integers ;  $  TAB1 while read a ;  $  TAB2 if a mod 10 equals 0 ;  $  TAB3 print a ;  $  TAB2 else if a mod 10 equals 5 ;  $  TAB3 print a - 5 ;  $  TAB2 else if a mod 10 is less than 5 ;  $  TAB3 set b to a mod 10 ;  $  TAB3 print a - b ;  $  TAB2 else ;  $  TAB3 set b to a mod 10 ;  $  TAB3 set b to 10 - b ;  $  TAB3 print a + b ;
TAB0 define four-element int array dx and set them to 0, 0, -1, 1 ;  $  TAB0 define 4-element integral array dy, setting it to 1, -1, 0, and 0 ;  $  TAB1 define int n ;  $  TAB1 read n ;  $  TAB1 if n modulo 10 is <= 5 ;  $  TAB2 if n / 10 != 0 ;  $  TAB3 print n / 10, 0, and newline ;  $  TAB2 else ;  $  TAB3 print 0 and a newline ;  $  TAB1 else ;  $  TAB2 print n / 10 + 1, 0, newline ;
TAB1 declare integer variable n ;  $  TAB1 read input to n ;  $  TAB1 declare integer variables k, a, l and m where l and m = 0 ;  $  TAB1 set k to n ;  $  TAB1 assign n to a ;  $  TAB1 if n is even and n modulo 5 is 0 ;  $  TAB2 print n ;  $  TAB1 else ;  $  TAB2 loop i from 0 to 8 exclusive ;  $  TAB3 increment l by one ;  $  TAB3 if k is even and k modulo 5 = 0, stop the loop ;  $  TAB3 decrement k ;  $  TAB2 loop j from 0 to 8 exclusive ;  $  TAB3 increment m by one ;  $  TAB3 if a is even and a modulo 5 = 0, break the loop ;  $  TAB3 increment a ;  $  TAB2 if l is equal to m ;  $  TAB3 print k ;  $  TAB2 else if l is greater than m ;  $  TAB3 print a ;  $  TAB2 else ;  $  TAB3 print k ;
TAB1 n, x =integers with x = 0 ;  $  TAB1 Read n ;  $  TAB1 set x to n modulo 10 ;  $  TAB1 if x is greater than 5, then set n to n - x + 10 ;  $  TAB1 if x is less than 5, then set n to n - x ;  $  TAB1 print n and a new line ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 t = n mod 10 ;  $  TAB1 if t >= 6 ;  $  TAB2 n = n - t + 10 ;  $  TAB1 else ;  $  TAB2 assign n - t to n ;  $  TAB1 print n ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 declare array of integers of size n and integer count = 0 ;  $  TAB1 populate array a with n values ;  $  TAB1 set max to highest value in array a ;  $  TAB1 for i = 0 to n exclusive set count to count + max - a[i] ;  $  TAB1 print count ;
TAB1 create integer array a with size 1000, create integers i, n, ans with ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 sort elements from a + 1 to a + n + 1 ;  $  TAB1 for i = 1 to n exclusive, increment ans by a[n] - a[i] ;  $  TAB1 print ans print newline ;
TAB0 integers = t integer N = 1e5 + 50 ;  $  TAB0 integers = t integer M = 1e6 ;  $  TAB0 oo = 1e18 = constant long long integers ;  $  TAB0 integers = t integer mod = 1e9 + 7 ;  $  TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 sum = 0,mx = 0 = long long integers ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 ong a = long long integers ;  $  TAB2 read a ;  $  TAB2 sum equals sum plus a ;  $  TAB2 set mx to max(mx, a) ;  $  TAB1 output mx * n - sum ;
TAB1 create ints n, cnt and sum with cnt and sum = 0 ;  $  TAB1 read n ;  $  TAB1 let a be integer array with size n ;  $  TAB1 for i from 0 to n exclusive, read a[i] ;  $  TAB1 sort a ;  $  TAB1 declare int mx = a[n - 1] ;  $  TAB1 loop i from 0 to n exclusive, add abs(mx - a[i]) to sum ;  $  TAB1 print sum ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 welfare = vector of integer ;  $  TAB1 welfare_input = integer ;  $  TAB1 while welfare.size() < n ;  $  TAB2 read welfare_input ;  $  TAB2 append welfare in _inputwelfare ;  $  TAB1 sort welfare.rbegin() and welfare.rend() ;  $  TAB1 i = integer with i = 1 ;  $  TAB1 total = integer with total = 0 ;  $  TAB1 while welfare.size() > i ;  $  TAB2 if welfare[0] is not welfare[i] ;  $  TAB3 increment welfare[i] ;  $  TAB3 increment total ;  $  TAB2 else ;  $  TAB3 increment i ;  $  TAB1 print total ;
TAB1 n, a = integers with a = array of size 101 ;  $  TAB1 read n ;  $  TAB1 s, max = integer with s = 0, max = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 max = a[0] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if max < a[i], max = a[i] ;  $  TAB1 for i - 0 to n exclusive, s = s + abs(max - a[i]) ;  $  TAB1 print s ;
TAB1 create long long int mx, n, a[105] and sum, set mx to 0 and a to all 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive, read a[i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if a[i] greater than mx, mx = a[i] ;  $  TAB1 sum =0 ;  $  TAB1 for i=0 to n exclusive, set sum to sum + mx - a[i] ;  $  TAB1 print sum ;
TAB1 create integer n ;  $  TAB1 create integer array a with size 10000 ;  $  TAB1 create integer maxn ;  $  TAB1 create integer ans with ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is greater than maxn, set maxn to a[i] ;  $  TAB1 for i = 1 to n inclusive, set ans to ans + maxn - a[i] ;  $  TAB1 print ans print newline ;
TAB1 let n, arr , maxx , i, res be integers with arr = array of integers of length 109, maxx = 0, res = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read ith element of arr ;  $  TAB2 if maxx is less than arr[i] , maxx is equal to arr[i] ;  $  TAB1 for i = 0 to n exclusive, res is equal to res + (maxx - arr[i]) ;  $  TAB1 print res and newline ;
TAB1 a=array of 100 int ;  $  TAB1 n,i,k,max=int ;  $  TAB1 k=0 ;  $  TAB1 read n ;  $  TAB1 max = -1 ;  $  TAB1 for i=0 to n exclusive read a[i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if a[i] > max max = a[i] ;  $  TAB1 for i=0 to n exclusive add max-a[i] to k ;  $  TAB1 print k ;
TAB1 set sum =0 ;  $  TAB1 create int tc ;  $  TAB1 create int array a of size 100 ;  $  TAB1 read tc ;  $  TAB1 for i=0 to tc exclusive, read a[i] ;  $  TAB1 create int max = a[0] ;  $  TAB1 for i=0 to tc exclusive ;  $  TAB2 if a[i] > max, set max to a[i] ;  $  TAB1 for i=0 to tc exclusive, set sum = sum + max - a[i] ;  $  TAB1 print sum ;
TAB1 integers = n,a[105],i,s ;  $  TAB1 while inputting n loop the following ;  $  TAB2 set s to 0 ;  $  TAB2 read n values in array a ;  $  TAB2 if n is 1 then do the following ;  $  TAB3 output s ;  $  TAB2 else ;  $  TAB3 sort the values of a to a + n ;  $  TAB3 for = 0 to less than n - 1 add a[n - 1] - a[i] to s ;  $  TAB3 output s ;
TAB0 v = vector of integer ;  $  TAB1 n, x, hitung = integers with x = 0, hitung = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n ;  $  TAB2 m = integer ;  $  TAB2 read m ;  $  TAB2 append m in v ;  $  TAB2 if m >= x, x = m ;  $  TAB1 for i = 0 to n exclusive, hitung = hitung + (x - v[i]) ;  $  TAB1 print hitung ;
TAB1 n, arr = integers with arr = array of size 100 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 sort arr and arr + n ;  $  TAB1 biggest, res = integer with biggest = arr[n - 1], res = 0 ;  $  TAB1 for i = 0 to n exclusive, res = res + (biggest - arr[i]) ;  $  TAB1 print res ;
TAB1 Create n, i, s, and b as integers, set s to 0, and create a as an integer array with size of 101 ;  $  TAB1 Set n to the input ;  $  TAB1 Set a[i] to the input from i=0 to i=n-1 ;  $  TAB1 Sort the first n elements of a ;  $  TAB1 Increase s by (a[n-i]-a[i]) from i=0 to i=n-1 ;  $  TAB1 Output s ;
TAB1 n and ans are ints with ans = 0 ;  $  TAB1 create long int array a with 100 elements ;  $  TAB1 read n ;  $  TAB1 loop i from 0 to n exclusive, read a[i] ;  $  TAB1 sort n first elements of a ;  $  TAB1 for i from 0 to n exclusive, increase ans by a[n - 1] - a[i] ;  $  TAB1 print ans ;
TAB1 let n be a integer ;  $  TAB1 while read n ;  $  TAB2 A = array of integers of length 111 ;  $  TAB2 let maxx be a integer with maxx = -1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read ith element in a ;  $  TAB3 if a[i] is greater than maxx , initialize maxx = a[i] ;  $  TAB2 set integer sum to 0 ;  $  TAB2 for i = 1 to n inclusive , increase sum by maxx - a[i] ;  $  TAB2 print sum and newline ;
TAB0 let e be int array with size 105 ;  $  TAB1 declare int variable n ;  $  TAB1 read n ;  $  TAB1 create int m = 0 ;  $  TAB1 loop i from 1 to n inclusive ;  $  TAB2 create integer t ;  $  TAB2 read t ;  $  TAB2 set e[i] to t ;  $  TAB2 set m t if t <= m ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 for i from 1 to n inclusive, change ans to ans + m - e[i] ;  $  TAB1 print ans ;
TAB1 integers = n ;  $  TAB1 read n ;  $  TAB1 a[n] = long long integers ;  $  TAB1 cnt = 0,mx = 0 = long long integers ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 read a[i] ;  $  TAB2 set mx to max(a[i], mx) ;  $  TAB1 for i = 0 to less than n add mx - a[i] to cnt ;  $  TAB1 output cnt ;
TAB1 declare long ints n and ans where ans = 0 ;  $  TAB1 read n ;  $  TAB1 create integers vector v ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 push x to v ;  $  TAB1 sort v ;  $  TAB1 for i from 0 to n - 1 exclusive, increase ans by v[n - 1] - v[i] ;  $  TAB1 print ans ;
TAB1 declare int variable n and int array x with size 105 ;  $  TAB1 read n ;  $  TAB1 for i from 0 to n exclusive, read x[i] ;  $  TAB1 sort x ;  $  TAB1 Max and sum are integers with Max = x[n - 1] and sum = 0 ;  $  TAB1 for i from 0 to n exclusive, add Max - x[i] to sum ;  $  TAB1 print sum ;
TAB1 n, max, c = int with max = 0 and c = 0 ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 read n values into a ;  $  TAB1 for i = 0 to n ;  $  TAB2 if max is less than a[i] then set max to a[i] ;  $  TAB1 for i = 0 to n ;  $  TAB2 if a[i] is less than max then set c to c + max - a[i] ;  $  TAB1 print c ;
TAB1 create int n, maxi, sum and x, set maxi to -1 and sum =0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 set maxi to max of maxi and x ;  $  TAB2 assign sum + x to sum ;  $  TAB1 print maxi * n - sum ;
TAB1 n, i, large and ans are integers where ans = 0 and a is an integer array with 100 elements ;  $  TAB1 read input to n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 change large to a[0] ;  $  TAB1 loop i from 0 to n exclusive ;  $  TAB2 if large is less than a[i], set large to a[i] ;  $  TAB1 for i = 0 to n exclusive, add large - a[i] to ans ;  $  TAB1 print ans ;
TAB1 create int n and s ;  $  TAB1 read n and s ;  $  TAB1 print (s + n - 1) / n ;
TAB0 n, sum = long long integers ;  $  TAB1 read n, sum ;  $  TAB1 ans = long long integer with ans = 0 ;  $  TAB1 for i = n down to 1 ;  $  TAB2 ans = ans + sum / i ;  $  TAB2 sum = sum - (sum / i) * i ;  $  TAB1 print ans ;
TAB1 x, y, z = integers ;  $  TAB1 read x and y ;  $  TAB1 set z = (y -1)/x ;  $  TAB1 increment z ;  $  TAB1 print z ;
TAB1 declare integers n, s ;  $  TAB1 read n, s ;  $  TAB1 print s / n + 1 if s % n, else n / n, newline ;
TAB1 let n and s ints ;  $  TAB1 read n and s ;  $  TAB1 let ans an int with value s / n plus (1 if s mod n, 0 otherwise) ;  $  TAB1 print ans ;
TAB1 n, s =integers ;  $  TAB1 Read n, s ;  $  TAB1 if s modulo n is 0 ;  $  TAB2 print s / n and a new line ;  $  TAB1 else do the following ;  $  TAB2 print (s / n) + 1 and a new line ;
TAB0 declare constant integer maxn = 1e5 + 10 ;  $  TAB1 declare integers a, b ;  $  TAB1 while read a, b is true, print ( b - 1 ) / a + 1 and newline ;
TAB1 n, S = long long integers ;  $  TAB1 read n and S ;  $  TAB1 if S modulo n is equal to 0 ;  $  TAB2 print S / n ;  $  TAB1 else ;  $  TAB2 print S / n + 1 ;
TAB1 n, s =integers ;  $  TAB1 Read n, s ;  $  TAB1 if s modulo m is n ;  $  TAB2 print s / n + 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print s / n and a new line ;
TAB1 let n, s be integers ;  $  TAB1 read values for n, s ;  $  TAB1 if s mod n is equal to 0 then ;  $  TAB2 print s/n ;  $  TAB1 else do the following ;  $  TAB2 print (s/n) +1 ;
TAB1 n, s = int ;  $  TAB1 loop while reading n then s ;  $  TAB2 cnt = int with cnt = 0 ;  $  TAB2 for i = n to 0 decrementing i ;  $  TAB3 loop while s >= i ;  $  TAB4 decrement s by i ;  $  TAB4 increment cnt ;  $  TAB2 print cnt ;
TAB1 create int n and s ;  $  TAB1 read n and s ;  $  TAB1 if s mod n =0 ;  $  TAB2 print s/n ;  $  TAB1 else ;  $  TAB2 print s/n +1 ;
TAB1 n =integer ;  $  TAB1 S = integer ;  $  TAB1 Read n, S ;  $  TAB1 if S modulo s is n ;  $  TAB2 print S / n + 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print S / n and a new line ;
TAB0 n, s = integers ;  $  TAB1 Read n and s ;  $  TAB1 print s / n + (s modulo n is not 0) and a new line ;
TAB1 n, s = integer ;  $  TAB1 read n and s ;  $  TAB1 if s remainder n = 0 ;  $  TAB2 print s/n ;  $  TAB1 else ;  $  TAB2 print s/n + 1 ;
TAB1 make ints n and m ;  $  TAB1 read m and n ;  $  TAB1 if n % m is equal to 0 ;  $  TAB2 print n / m ;  $  TAB1 otherwise ;  $  TAB2 output n / m + 1 ;
TAB1 n=int ;  $  TAB1 S=int ;  $  TAB1 read n,S ;  $  TAB1 if S is multiple of n ;  $  TAB2 print S/n ;  $  TAB1 else ;  $  TAB2 print S/n+1 ;
TAB1 create int n and s ;  $  TAB1 read n and s ;  $  TAB1 print (n + s - 1) / n ;
TAB0 declare long long integers n, sum ;  $  TAB1 read n and sum ;  $  TAB1 declare long long integer ans = sum / n + 1 if sum % n, else sum / n ;  $  TAB1 print ans and '\n' ;
TAB1 create integers T, n and m ;  $  TAB1 read m and n from the user input ;  $  TAB1 print n / m + (1 if n modulo m is not 0) ;
TAB1 ans = 0 = itn ;  $  TAB1 n, s = int ;  $  TAB1 read n, s ;  $  TAB1 while s is strictly positive ;  $  TAB2 decrement s by n ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB1 x, y, z = long long ;  $  TAB1 read x, y ;  $  TAB1 let z = (y - 1) / x ;  $  TAB1 add one to z ;  $  TAB1 print z ;
TAB1 declare integer n, s ;  $  TAB1 read n and s ;  $  TAB1 declare integer sum = 0 ;  $  TAB1 while 1 is true ;  $  TAB2 increment sum by s / n ;  $  TAB2 let s be s % n ;  $  TAB2 decrement n ;  $  TAB2 if n is 0, end loop ;  $  TAB1 print sum and newline ;
TAB1 n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 if (m modulo n is not 0) ;  $  TAB2 print (m / n) + 1 ;  $  TAB1 else ;  $  TAB2 print (m / n) ;
TAB1 create int n and sum ;  $  TAB1 read n and sum ;  $  TAB1 if sum mod n different from 0 ;  $  TAB2 print sum/n + 1 ;  $  TAB1 else ;  $  TAB2 print sum/n ;
TAB1 s, n, cn =integers with cn = 0 ;  $  TAB1 Read n, s ;  $  TAB1 while s is greater than s ;  $  TAB2 set s to s - n ;  $  TAB2 increment cn ;  $  TAB1 print cn + 1 and a new line ;
TAB0 declare integers a, b ;  $  TAB1 read a, b ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 let ans be b / a ;  $  TAB1 if b % a is not 0, increment ans ;  $  TAB1 print ans and newline ;
TAB1 declare integers n, m ;  $  TAB1 read n, m ;  $  TAB1 declare integer ans = 0 ;  $  TAB1 if m % n is 0 ;  $  TAB2 let ans be m / n ;  $  TAB1 else ;  $  TAB2 increment ans by m / n + 1 ;  $  TAB1 print ans and newline ;
TAB1 n, s = int ;  $  TAB1 read n then s ;  $  TAB1 ans = int with ans = 0 ;  $  TAB1 loop while s ;  $  TAB2 if s is 0 break ;  $  TAB2 if s >= n ;  $  TAB3 decrement s by n then increment ans ;  $  TAB2 else ;  $  TAB3 decrement n ;  $  TAB1 print ans ;
TAB1 n, s =integers ;  $  TAB1 Read n, s ;  $  TAB1 count = integer with 0 ;  $  TAB1 for i = n to 0 exclusive ;  $  TAB2 a = integer, set to s / i ;  $  TAB2 set count to count + a ;  $  TAB2 set s to s % i ;  $  TAB2 if s is equal to 0, then Terminate the loop ;  $  TAB1 print count and a new line ;
TAB1 n, s, temp, c =integers with c = 0 ;  $  TAB1 Read n, s ;  $  TAB1 execute infinite loop ;  $  TAB2 if s is equal to 0, then Terminate the loop ;  $  TAB2 set temp to s ;  $  TAB2 set s to s modulo minimum value of sand n ;  $  TAB2 set c to c + temp / minimum value of temp and n ;  $  TAB1 print c and a new line ;
TAB1 n, s = long long ;  $  TAB1 read n, s ;  $  TAB1 ans = integer with ans = (s + n - 1) / n ;  $  TAB1 print ans ;
TAB1 n, S = long ;  $  TAB1 read n and S ;  $  TAB1 set coins = 0 ;  $  TAB1 set coins = coins + S/n ;  $  TAB1 set rem = S remainder n ;  $  TAB1 if rem = 0 ;  $  TAB2 print coins ;  $  TAB1 else ;  $  TAB2 print increment coins ;
TAB1 declare long long variables n, s and i ;  $  TAB1 read variables n and s from the input ;  $  TAB1 if s modulo n != 0 ;  $  TAB2 print s / n + 1 ;  $  TAB1 else ;  $  TAB2 print s / n ;
TAB1 N = string ;  $  TAB1 Read N ;  $  TAB1 if N[0] is greater than or equal to a and N[0] is less than z, set N[0] to N[0] - 32 ;  $  TAB1 print N and a new line ;
TAB1 declare ch as character array of size 1000 ;  $  TAB1 gets(ch) ;  $  TAB1 if ch[0] >= 'a' and ch[0] <= 'z' set ch[0] to ch[0] - 32 ;  $  TAB1 puts(ch) ;
TAB1 m = string ;  $  TAB1 call getline on cin and m ;  $  TAB1 if m[0] >= 97 and m[0] <= 122 then m[0] = (int)m[0] - 32 ;  $  TAB1 print m ;
TAB1 input = string ;  $  TAB1 Read input ;  $  TAB1 if input[0] is greater than or equal to a, set input[0] = input- 32 ;  $  TAB1 print input and a new line ;
TAB1 create string word ;  $  TAB1 read word ;  $  TAB1 set a to word[0] ;  $  TAB1 if a >99 ;  $  TAB2 a=a-32 ;  $  TAB2 assign a to word[0] ;  $  TAB2 print word ;  $  TAB1 else ;  $  TAB2 print word and a new line ;
TAB1 create character array s with length of 1001 ;  $  TAB1 read s ;  $  TAB1 convert first character of s to uppercase alphabet ;  $  TAB1 print out s ;
TAB1 declare string variable s ;  $  TAB1 read s ;  $  TAB1 change s[0] to upper case ;  $  TAB1 print s ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 set s[0] to upper case ;  $  TAB1 print s ;
TAB1 create character array str with 1000 elements ;  $  TAB1 while read str ;  $  TAB2 if 'a' <= str[0] && str[0] <= 'z', str[0] = 32 ;  $  TAB2 print str ;
TAB1 word = string ;  $  TAB1 Read word ;  $  TAB1 set word[0] to upper case of word[0] ;  $  TAB1 print word solution and a new line ;
TAB1 s = string ;  $  TAB1 Read s ;  $  TAB1 set s[0] to upper case of s[0] ;  $  TAB1 print s and a new line ;
TAB0 let s = string ;  $  TAB1 set s from input ;  $  TAB1 if islower called with s[0] is true then set s[0] to (char)((int)s[0] - 32) ;  $  TAB1 print s ;
TAB0 in the function toUpp that takes character s and returns character ;  $  TAB1 n = integer with n = s ;  $  TAB1 if n >= 97 and n <= 122 n = n - 32 ;  $  TAB1 return (char)n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 s[0] = call toUpp on s[0] ;  $  TAB1 print s ;
TAB1 declare integer variables n, i, t1 and t2 ;  $  TAB1 declare string a ;  $  TAB1 read input into a ;  $  TAB1 if a[0] > 96 && a[0] is less than 123, decrease a[0] by 32 ;  $  TAB1 print a ;
TAB1 create xay as string ;  $  TAB1 input xay ;  $  TAB1 if call islower with xay[0] is true set xay[0] to xay[0] converted to uppercase ;  $  TAB1 print xay ;
TAB1 let a be an array of char of length 1100 ;  $  TAB1 execute gets wich takes a as an argument ;  $  TAB1 if a[0] >= 'A' and a[0] <= 'Z' then execute puts with a as an argument ;  $  TAB1 if a[0] >= 'a' and a[0] <= 'z' then ;  $  TAB2 let a[0] = a[0] - 32 ;  $  TAB2 execute puts with a as an argument ;
TAB1 ch = string ;  $  TAB1 read ch ;  $  TAB1 capitalize first letter of ch ;  $  TAB1 print ch ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 capitalize first letter of s ;  $  TAB1 print s ;
TAB0 in the function capitalize that takes string reference word and returns void ;  $  TAB1 first = character with first = word.at(0) ;  $  TAB1 if first >= 97 and first <= 122 word.at(0) = word.at(0) - 32 ;  $  TAB1 input = string ;  $  TAB1 read input ;  $  TAB1 capitalize on input ;  $  TAB1 print input ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 set s[0] to uppercase letter of s[0] ;  $  TAB1 print s ;
TAB1 create char array a with length 1000 ;  $  TAB1 read from standard input and store in a ;  $  TAB1 if (a[0] is greater or equal to 'a' and a[0] is smaller or equal to 'z') set a[0] to a[0] - ('a' - 'A') ;  $  TAB1 print a ;
TAB1 s = string ;  $  TAB1 Read s ;  $  TAB1 set s[0] to upper case of s[0] ;  $  TAB1 print s solution and a new line ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 if s[0] is greater than 96 and s[0] is less than 123 then subtract 32 from s[0] ;  $  TAB1 print s ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 set s[0] to convert to uppercase s[0] ;  $  TAB1 print s print newline ;
TAB1 s = string ;  $  TAB1 Read s ;  $  TAB1 set s[0] to upper case of s[0] ;  $  TAB1 print s and a new line ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 if s[0]>= a and s[0]<= z, set s[0] to s[0]-32 ;  $  TAB1 print s ;
TAB1 n =integer ;  $  TAB1 s =string ;  $  TAB1 Read s ;  $  TAB1 set n to length of string s ;  $  TAB1 if s[0] is greater than 96 and s[0] is less than 123, then set s[0] to s[0] - 32 ;  $  TAB1 print s and a new line ;
TAB1 create string x ;  $  TAB1 read x ;  $  TAB1 if x[0] is lower case change x[0] to upper case ;  $  TAB1 print x ;
TAB1 create string word ;  $  TAB1 read word ;  $  TAB1 set word[0] to upper case word[0] ;  $  TAB1 print word print newline ;
TAB1 s = string ;  $  TAB1 Read s ;  $  TAB1 set s[0] to upper case of s[0] ;  $  TAB1 print s and a new line ;
TAB1 declare string variable s ;  $  TAB1 read s ;  $  TAB1 convert s[0] to the upper case ;  $  TAB1 print s ;
TAB1 declare string variable s ;  $  TAB1 read s ;  $  TAB1 if s[0] is a lowercase letter from a to z, change it to upper case ;  $  TAB1 print s ;
TAB1 let str be a string ;  $  TAB1 read str ;  $  TAB1 if (((int)str[0] is less than or equal to (int)'z') and ((int)str[0] is greater than or equal to a)), the 0th element of array str is equal to (char)((int)str[0] - 32) ;  $  TAB1 print str and newline ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 set value of s[0] to towupper(s[0]) ;  $  TAB1 print s ;
TAB0 declare character array a with size 1000000 ;  $  TAB0 declare character array b with size 53 with elements "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" ;  $  TAB1 read a ;  $  TAB1 for integer i = 0 to 26 exclusive ;  $  TAB2 if a[0] = b[i] ;  $  TAB3 set value of a[0] to b[i + 26] ;  $  TAB3 stop the loop ;  $  TAB1 print a ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 set s[0] to uppercase letter of s[0] ;  $  TAB1 print s ;
TAB1 create string word ;  $  TAB1 read word ;  $  TAB1 if word[0] >= a and word[0] <= z, set word[0]=word[0] - 32 ;  $  TAB1 print word ;
TAB1 let S be string ;  $  TAB1 read S ;  $  TAB1 call toupper with s[0] as argument and assign it to element 0 of array S ;  $  TAB1 print S ;
TAB1 declare string variable str ;  $  TAB1 read input to str ;  $  TAB1 change str[0] to uppercase ;  $  TAB1 print str ;
TAB1 let s be a string ;  $  TAB1 read s ;  $  TAB1 let the value of s[0] is equal to toupper(s[0]) ;  $  TAB1 print s and newline ;
TAB1 declare string variable a ;  $  TAB1 read line from the input to a ;  $  TAB1 if a[0] >= 'a' and a[0] <= 'z', decrease a[0] by 32 ;  $  TAB1 print a ;
TAB1 n, m = integers ;  $  TAB1 while read n, m ;  $  TAB2 cnt, ta, tb = integers with cnt = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read ta, tb ;  $  TAB3 if (cnt >= ta), cnt = max of cnt and tb ;  $  TAB2 print (if cnt >= m, YES else NO) ;
TAB1 create ints n and m ;  $  TAB1 read n and m ;  $  TAB1 make int vector a of size 101 with values 0 ;  $  TAB1 make ints x and y ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x and y ;  $  TAB2 increment a[x] ;  $  TAB2 subtract 1 from a[y] ;  $  TAB1 make integer cs = 0 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 set cs to cs + a[i] ;  $  TAB2 if cs is less than or equal to 0 ;  $  TAB3 display "NO" ;  $  TAB1 display "YES" ;
TAB1 n, m = integer ;  $  TAB1 read n, m ;  $  TAB1 c = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a, b = integer ;  $  TAB2 read a, b ;  $  TAB2 if c >= a, then c = bigger value between c and b ;  $  TAB1 if c >= m ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 declare constant integer MAX = 1e5 ;  $  TAB1 declare boolean array x size 150 ;  $  TAB1 set bytes from x to size of x to value false ;  $  TAB1 declare integers n, m ;  $  TAB1 declare integers l, r ;  $  TAB1 declare integers i, j ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read l and r ;  $  TAB2 for j = l to r exclusive, let x[j] be true ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 if not x[i], end loop ;  $  TAB1 if i is less than m ;  $  TAB2 print "NO" and newline ;  $  TAB1 else ;  $  TAB2 print "YES" and newline ;
TAB0 create integer array pos of size 110 ;  $  TAB1 make integers n and m ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make integers a and b ;  $  TAB2 read a and b ;  $  TAB2 for j = a + 1 to b, set pos[j] to 1 ;  $  TAB1 for i = 1 to m ;  $  TAB2 if pos[i] is falsy, print "NO\n" and return 0 ;  $  TAB1 display "YES\n" and return 0 ;
TAB0 declare integer array freq size 10000005 ;  $  TAB0 declare integers n, m ;  $  TAB1 read n and m ;  $  TAB1 declare integer array mat size n by 2 ;  $  TAB1 set bytes from freq to size of freq to value 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read mat[i][0], mat[i][1] ;  $  TAB2 for j = ( mat[i][0] ) + 1 to mat[i][1] inclusive, increment freq[j] ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 if not freq[i] ;  $  TAB3 print "NO" ;  $  TAB1 print "YES" ;
TAB0 let n , m be integers ;  $  TAB1 read n and m ;  $  TAB1 let a, b be integers ;  $  TAB1 let t be a integer with t = 0 ;  $  TAB1 while n is decremented by 1 ;  $  TAB2 read a, b ;  $  TAB2 if a <= t , t is equal to maximum of t and b ;  $  TAB1 if t >= m ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 a is a new array of integers with 105 elements ;  $  TAB1 create ints n, m, x, y, l and r where l = 0 ;  $  TAB1 read standard input to n and m ;  $  TAB1 change i from 1 to n inclusive, incrementing i, in a loop ;  $  TAB2 read x and y ;  $  TAB2 if i = 1 and x != 0 ;  $  TAB3 print "NO" ;  $  TAB2 if i is equal to 1 ;  $  TAB3 set r to y ;  $  TAB2 else if x <= r ;  $  TAB3 assign the new value = max of r and y to r ;  $  TAB1 if r >= m ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 n, m, s = integers ;  $  TAB1 l, r = integers ;  $  TAB1 read n, m ;  $  TAB1 while decrement n ;  $  TAB2 read l, r ;  $  TAB2 if (l <= s), if s = r < s, s else r ;  $  TAB1 if (s < m) ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;
TAB1 create int n, m, rightMost, set rightMost to 0 ;  $  TAB1 read n and m ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create int x and y ;  $  TAB2 read x and y ;  $  TAB2 if x <= rightMost and y > rightMost, rightMost = y ;  $  TAB1 if rightMost >= m ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 q = vector of integer with q on 1000 and 0 ;  $  TAB1 q[0] = 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a, b = integers ;  $  TAB2 read a, b ;  $  TAB2 if (q[a] is 1) ;  $  TAB3 while (a <= b) ;  $  TAB4 q[a] = 1 ;  $  TAB4 increment a ;  $  TAB1 f = bool with f = true ;  $  TAB1 for i = 0 to m, f = f bitwise and q[i] ;  $  TAB1 if (f) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create ints N and M ;  $  TAB1 read N and M ;  $  TAB1 make integer vector A of size N and B of size N ;  $  TAB1 for i = 0 to N exclusive, read A[i] and B[i] ;  $  TAB1 make integer max_ = 0 ;  $  TAB1 for i = 0 to N exclusive ;  $  TAB2 if max_ is less than A[i], break loop ;  $  TAB2 set max_ to max of max_ and B[i] ;  $  TAB1 if max_ is equal to M ;  $  TAB2 print "YES" ;  $  TAB3 print new line ;  $  TAB1 otherwise do ;  $  TAB2 display "NO" ;  $  TAB3 print new line ;
TAB0 a = integer array of size 105 ;  $  TAB1 n, m, x, y, l, r = integers with l = 0 ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n ;  $  TAB2 read x, y ;  $  TAB2 if (i is 1 and x is not 0) ;  $  TAB3 print NO ;  $  TAB2 if (i is 1) ;  $  TAB3 r = y ;  $  TAB2 else if (x <= r) ;  $  TAB3 r = max r and y ;  $  TAB1 if (r >= m) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 let freq be an integer array of size 10000005 ;  $  TAB0 let n, m, x, to be integers ;  $  TAB1 read n , m ;  $  TAB1 for int i = 0 to n ;  $  TAB2 read x, to ;  $  TAB2 for int j = x + 1 to to inclusive, ;  $  TAB1 for int i = 1 to m inclusive ;  $  TAB2 if freq[i] = 0 ;  $  TAB3 print out NO ;  $  TAB1 print out YES ;
TAB1 n,m=int ;  $  TAB1 read n,m ;  $  TAB1 multiply m by 2 ;  $  TAB1 v=array of 220 bool ;  $  TAB1 fill v with false ;  $  TAB1 while decremented value of n is not 0 ;  $  TAB2 a,b=int ;  $  TAB2 read a,b ;  $  TAB2 multiply a by 2 ;  $  TAB2 multiply b by 2 ;  $  TAB2 fill v from index a to b-a+1 with true ;  $  TAB1 ok=true ;  $  TAB1 for i=0 to m inclusive ;  $  TAB2 if not v[i] ok=false ;  $  TAB1 print YES if ok else NO ;
TAB0 freq = integer array of size 10000005 ;  $  TAB0 n, m, x, to = integers ;  $  TAB1 read n, m ;  $  TAB1 set all contents of freq to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x, to ;  $  TAB2 for j = x + 1 to to, increment freq[j] ;  $  TAB1 for i = 1 to m ;  $  TAB2 if (not freq[i]) ;  $  TAB3 print NO ;  $  TAB1 print YES ;
TAB0 getint is an inlined integer function ;  $  TAB1 declare ints r = 0 and k = 1 ;  $  TAB1 defin new char c with value from the input ;  $  TAB1 read char from the input into c, while c is not a digit character ;  $  TAB2 if c = '-', change k to - 1 ;  $  TAB1 while is a digit character, read new value for the c from the input, then change r to r * 10 + c - '0' ;  $  TAB1 return r * k ;  $  TAB1 new integer n with value from getint() ;  $  TAB1 m is a new integer with value from getint() ;  $  TAB1 define new integer maxx with value 0 ;  $  TAB1 in a for loop, change i from 1 to n inclusive ;  $  TAB2 declare integer variable with name x = result of getint() ;  $  TAB2 y is a new integer = value, returned from getint() ;  $  TAB2 if maxx >= x, change maxx to max of maxx and y ;  $  TAB1 if maxx >= m ;  $  TAB2 print "YES" to standard output ;  $  TAB1 else ;  $  TAB2 print "NO" to stdout ;
TAB1 let x, y, n, c be long values ;  $  TAB1 read n ;  $  TAB1 x equals n - 1 ;  $  TAB1 y equals 1 ;  $  TAB1 c equals 1 ;  $  TAB1 while x is greater than 0 ;  $  TAB2 increase c by 1 ;  $  TAB2 if x * x + y * y + 2 * y + 1 < n * n + 1 ;  $  TAB3 increase y by 1 ;  $  TAB2 else ;  $  TAB3 if x * x - 2 * x + y * y + 2 * y + 2 < n * n + 1 ;  $  TAB4 decrease x by 1 ;  $  TAB4 increase y by 1 ;  $  TAB3 else ;  $  TAB4 decrease x by 1 ;  $  TAB1 if n equals 0 ;  $  TAB2 print 1 and endline ;  $  TAB1 else ;  $  TAB2 print 4 * c and endline ;
TAB1 n, ans be long long values with ans being 0 ;  $  TAB1 read n ;  $  TAB1 double value R equals n ;  $  TAB1 tmp. k be long long values and tmp equals n ;  $  TAB1 for long long i = 1 to n inclusive ;  $  TAB2 double value r equals i ;  $  TAB2 k equals square root of R * R - r * r ;  $  TAB2 increase ans by tmp == k ? 1 : tmp - k ;  $  TAB2 tmp equals k ;  $  TAB1 if n equals 0 ;  $  TAB2 print 1 and endline ;  $  TAB1 else ;  $  TAB2 print ans * 4 and endline ;
TAB1 declare new long long n ;  $  TAB1 read n from the input ;  $  TAB1 if 0 < n < 40000001 ;  $  TAB2 create new long longs x = n, y = 0 and k = 0 ;  $  TAB2 while x > 0 ;  $  TAB3 increment k by one ;  $  TAB3 increment y by one ;  $  TAB3 decrement x if x * x + y * y is greater than n squared ;  $  TAB3 decrement y if x * x + y * y is greater than n squared ;  $  TAB2 print 4 * k ;  $  TAB1 else if n = 0 ;  $  TAB2 print 1 to the standard output ;
TAB1 declare long long n ;  $  TAB1 while read n is true ;  $  TAB2 declare long long x = n * square root of double casted 2 ;  $  TAB2 if n is 0 ;  $  TAB3 print 1, newline ;  $  TAB2 else ;  $  TAB3 print x * 4, newline ;
TAB0 Eu_distance is a function that returns a long value by taking in two long values ;  $  TAB1 return x * x + y * y ;  $  TAB1 n is a long integer ;  $  TAB1 read n ;  $  TAB1 if n equals 0 ;  $  TAB2 put string 1 ;  $  TAB1 else if n equals 1 ;  $  TAB2 put string 4 ;  $  TAB1 else ;  $  TAB2 x and y are long integers with y = n ;  $  TAB2 res is a long integer 0 ;  $  TAB2 for x=0 to n,y+1 exclusive ;  $  TAB3 while Eu_distance(x, y) is greater than n * n, decrease y by 1 ;  $  TAB3 if x is greater than y, stop ;  $  TAB3 if x is not equal to y ;  $  TAB4 increase res by 2 ;  $  TAB3 else ;  $  TAB4 increase res by 1 ;  $  TAB2 decrease res by 2 ;  $  TAB2 res equals res * 4 + 4 ;  $  TAB2 print res and endline ;
TAB1 let n be a long integer ;  $  TAB1 let w be a long integer ;  $  TAB1 let t be a long integer ;  $  TAB1 the integer value of q = 1 ;  $  TAB1 read n ;  $  TAB1 if n equals 0 ;  $  TAB2 print q and newline ;  $  TAB1 else do the following ;  $  TAB2 the long integer value of r = int(sqrt((n * n) / 2)) * 2 ;  $  TAB2 w is equal to n * n ;  $  TAB2 if (r / 2) * (r / 2) + (r / 2 + 1) * (r / 2 + 1) <= w , increment r by 1 ;  $  TAB2 print 4 * r and newline ;
TAB0 create const ints Maxn = 3010 and INF = 0x3f3f3f3f ;  $  TAB1 let long long int n ;  $  TAB1 read n ;  $  TAB1 if n is equal to 0 ;  $  TAB2 print 1 ;  $  TAB1 else do ;  $  TAB2 show ((long long)(n * sqrt(2))) * 4 ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 the long integer value of j = n - 1 ;  $  TAB1 the long integer value of lim = n * n ;  $  TAB1 let t be a long integer ;  $  TAB1 the long integer value of prevj = n ;  $  TAB1 the long integer value of sum = 0 ;  $  TAB1 if n equals 0 ;  $  TAB2 print 1 and newline ;  $  TAB1 for long integer i = 1 to n + 1 exclusive ;  $  TAB2 t is equal to i * i ;  $  TAB2 while j is greater than 0 and j * j is greater than (lim - t) , decrement j by 1 ;  $  TAB2 increment sum by 1 ;  $  TAB2 if prevj is not equal to j , increment sum by (prevj - j - 1) ;  $  TAB2 prevj is equal to j ;  $  TAB1 print 4 * sum and newline ;
TAB1 let n, max, save be long integers ;  $  TAB1 read n ;  $  TAB1 if n equals 0 ;  $  TAB2 print 1 and newline ;  $  TAB1 if n equals 1 ;  $  TAB2 print 4 and newline ;  $  TAB1 for max is equal to 0 , 2 * (max * max) is less than n * n , increment max by 1 , save is equal to max ;  $  TAB1 if (save + 1) * (save + 1) + save * save <= n * n ;  $  TAB2 n is equal to (save)*8 + 4 ;  $  TAB2 print n and newline ;  $  TAB1 n is equal to (save)*8 ;  $  TAB1 print n and newline ;
TAB1 n = int ;  $  TAB1 while reading n ;  $  TAB2 x = n*sqrt(2 to double) ;  $  TAB2 if n = 0 ;  $  TAB3 print 1 ;  $  TAB2 else ;  $  TAB3 print x*4 ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 if n is false ;  $  TAB2 output 1 ;  $  TAB1 else ;  $  TAB2 output (square root of 2 times n) times 4 ;
TAB0 create long long n ;  $  TAB0 declare inside taking in long long ints x and y and returning long long ;  $  TAB1 if sqrt(x * x + y * y) is less than or equal to n, return 1 ;  $  TAB1 make long long num ;  $  TAB1 read n ;  $  TAB1 set num to n / 2 ;  $  TAB1 while (num + 1) * sqrt(2.0) is less than or equal to n, increment num ;  $  TAB1 if n is 1 ;  $  TAB2 print 4 ;  $  TAB1 else if n is equal to 0 ;  $  TAB2 show 1 ;  $  TAB1 else if inside(num, num + 1) is truthy ;  $  TAB2 display 8 * num + 4 ;  $  TAB1 else if inside(num, num + 1) is falsy ;  $  TAB2 show 8 * num ;
TAB1 declare integer array a size 3 ;  $  TAB1 while read a[0], a[1], a[2] ;  $  TAB2 sort from a to a + 3 ;  $  TAB2 if a[0] + a[1] is greater than a[2] ;  $  TAB3 print '0' and '\n' ;  $  TAB2 else ;  $  TAB3 print a[2] + 1 - a[1] - a[0] and '\n' ;
TAB1 let a, b, c, res be integers with res = 0 ;  $  TAB1 read a, b, c ;  $  TAB1 if a >= b + c ;  $  TAB2 res is equal to a - (b + c) + 1 ;  $  TAB1 else if b >= a + c ;  $  TAB2 res is equal to b - (a + c) + 1 ;  $  TAB1 else if c >= a + b ;  $  TAB2 res is equal to c - (b + a) + 1 ;  $  TAB1 print res and newline ;
TAB0 let compare be a function that accepts integers a , b and returns a boolean value ;  $  TAB1 return a is less than b ;  $  TAB1 arr = array of integers of length 3 ;  $  TAB1 while read arr[0] , arr[1] , arr[2] ;  $  TAB2 sort the values arr, arr + 3 ;  $  TAB2 if arr[0] + arr[1] is greater than arr[2] ;  $  TAB3 print 0 and newline ;  $  TAB2 else do the following ;  $  TAB3 print (arr[2] + 1 - arr[1] - arr[0]) and newline ;
TAB1 a = array of integers of length 3 ;  $  TAB1 read a[0] , a[1] , a[2] ;  $  TAB1 sort the values a, a + 3 ;  $  TAB1 print (maximum of a[2] - a[1] - a[0] + 1 and 0) and newline ;
TAB1 create new array of integers a with size 3 ;  $  TAB1 read a[0], a[1] and a[2] from the input ;  $  TAB1 sort first 3 elements of a ;  $  TAB1 print max of 0 and a[2] - a[1] + 1 - a[0] and "\n" ;
TAB1 declare integer array a size 3 ;  $  TAB1 read a[0], a[1], a[2] ;  $  TAB1 sort from a to a + 3 ;  $  TAB1 print maximum of ( 0 and a[2] + 1 - (a[0]+a[1]) ), newline ;
TAB1 a, b, c, d, e, f, g are long long integers ;  $  TAB1 s and t are strings ;  $  TAB1 while reading a, b, c ;  $  TAB2 set d = 0 ;  $  TAB2 while 1 ;  $  TAB3 if a+b > c and b+c > a and a + c > b ;  $  TAB4 break ;  $  TAB3 else ;  $  TAB4 add 1 to d ;  $  TAB4 if a<=b and a<=c ;  $  TAB5 add 1 to a ;  $  TAB4 else if b<=a and b<=c ;  $  TAB5 add 1 to b ;  $  TAB4 else ;  $  TAB5 add 1 to c ;  $  TAB2 print d ;
TAB1 lines is a new vector of integers with size 3 ;  $  TAB1 read user input to lines[0], lines[1] and lines[2] ;  $  TAB1 sort vector lines ;  $  TAB1 define integer variable counter = 0 ;  $  TAB1 while lines[0] + lines[1] <= lines[2] ;  $  TAB2 increment lines[0] ;  $  TAB2 increment counter ;  $  TAB1 print counter ;
TAB0 declare checkValidity with integers a, b, c as arguments, returning boolean ;  $  TAB1 if a + b is less than or equal to c or a + c is less than or equal to b or b + c is less than or equal to a ;  $  TAB2 return false from function ;  $  TAB1 else ;  $  TAB2 return true from function ;  $  TAB1 declare long longs a, b, c ;  $  TAB1 read a, b, c ;  $  TAB1 declare integer counter = 100000 ;  $  TAB1 for i = a to 100 inclusive ;  $  TAB2 for j = b to 100 inclusive ;  $  TAB3 for k = c to 100 inclusive ;  $  TAB4 if result of run checkValidity(i, j, k) is true ;  $  TAB5 declare integer temp = absolute value of ( i - a ) + ( j - b ) + ( k - c ) ;  $  TAB5 let counter be minimum of ( counter and temp ) ;  $  TAB1 print counter, newline ;
TAB1 create int a, b , c ;  $  TAB1 create int max,ans ;  $  TAB1 read a and b and c ;  $  TAB1 max = a ;  $  TAB1 if (max < b) max = b ;  $  TAB1 if (max < c) max = c ;  $  TAB1 if ans( 2 * max - (a + b + c)) < 0) ;  $  TAB2 print 0 ;  $  TAB1 esle ;  $  TAB2 print ans +1 ;
TAB1 create int int a[3], i ;  $  TAB1 for i=0 to 3 exclusive, read a[i] ;  $  TAB1 sort elements between a and a+3 ;  $  TAB1 if a[0] + a[1] > a[2] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print a[2] + 1 - a[0] - a[1] ;
TAB1 a,b,c=int ;  $  TAB1 read a,b,c ;  $  TAB1 flag=0 ;  $  TAB1 while a+b<(c+1) ;  $  TAB2 increment flag ;  $  TAB2 increment a ;  $  TAB1 while a+c<(b+1) ;  $  TAB2 increment flag ;  $  TAB2 increment a ;  $  TAB1 while b+c<(a+1) ;  $  TAB2 increment flag ;  $  TAB2 increment b ;  $  TAB1 print flag ;
TAB0 declare contant double pi = arc cosine of -1 ;  $  TAB1 create array of integers a of size 3 and integer k = 0 ;  $  TAB1 read a[0], a[1] and a[2] ;  $  TAB1 sort array a ;  $  TAB1 if a[1] + a[0] is greater than a[2] and a[2] - a[0] is less than a[1] then ;  $  TAB2 print k ;  $  TAB1 if a[1] + a[0] is less than or equal to a[2] ;  $  TAB2 set k to a[2] - a[1] - a[0] + 1 ;  $  TAB2 print k ;
TAB0 let MAXP be a constant integer with MAXP = 55 ;  $  TAB1 a = array of integers of length 3 ;  $  TAB1 read a[0] , a[1] , a[2] ;  $  TAB1 sort the values a, a + 3 ;  $  TAB1 print maximum of 0 and a[2] - a[0] - a[1] + 1 and newline ;
TAB1 create ints a, b, and c ;  $  TAB1 read a, b, and c ;  $  TAB1 create integer min_cnt = 1e9 ;  $  TAB1 for i = a to 100 ;  $  TAB2 for j = b to 100 ;  $  TAB3 for k = c to 100 ;  $  TAB4 create double s = (i + j + k) / 2.0 ;  $  TAB4 create double under_root = s * (s - i) * (s - j) * (s - k) ;  $  TAB4 if under_root is greater than 0.0, set min_cnt to min(min_cnt, ((i - a) + (j - b) + (k - c))) ;  $  TAB1 display min_cnt ;
TAB0 maxn = 1e5 + 5 ;  $  TAB1 ans = 0 ;  $  TAB1 create int a[4] ;  $  TAB1 whle read a[1], a[2], a[3] ;  $  TAB2 sort elements between a + 1 and a + 4 ;  $  TAB2 ans=0 ;  $  TAB2 while a[1] + a[2] <= a[3] ;  $  TAB3 increment ans ;  $  TAB3 add 1 to a[1] ;  $  TAB2 print ans ;
TAB1 create int a[3] ;  $  TAB1 read a[0], a[1], a[2] ;  $  TAB1 sort elements between a and a+3 ;  $  TAB1 if a[0] + a[1] > a[2] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print a[2] + 1 - a[0] - a[1] ;
TAB1 a, b, c, s, m, d = int ;  $  TAB1 read a, b, c ;  $  TAB1 s = a + b + c ;  $  TAB1 m = max of max(a, b) and c ;  $  TAB1 d = 2 * m - s + 1 ;  $  TAB1 if (d <= 0), d = 0 ;  $  TAB1 print d ;
TAB1 a, b, c, d and l are ints where l = 0 ;  $  TAB1 read from the input to a, b and c ;  $  TAB1 if a + b > c and b + c > a and a + c > b ;  $  TAB2 change d to 0 ;  $  TAB2 print d ;  $  TAB1 else ;  $  TAB2 if a <= b or a <= c ;  $  TAB3 looping infinitely ;  $  TAB4 increment a ;  $  TAB4 increment l ;  $  TAB4 if a + b > c and b + c > a and a + c > b ;  $  TAB5 print l ;  $  TAB5 stop the loop ;  $  TAB2 else ;  $  TAB3 if b <= a or b <= c ;  $  TAB4 looping infinitely ;  $  TAB5 increment b ;  $  TAB5 increment l by one ;  $  TAB5 if a + b > c and b + c > a and a + c > b ;  $  TAB6 print l ;  $  TAB6 break the loop ;
TAB1 a = array of integers of length 3 ;  $  TAB1 read a[0] , a[1] , a[2] ;  $  TAB1 sort the values a, a + 3, greater<int>() ;  $  TAB1 if a[0] + a[1] is greater than a[2] and a[1] + a[2] is greater than a[0] and a[2] + a[1] is greater than a[0] ;  $  TAB2 print 0 and newline ;  $  TAB1 else if a[0] + a[1] is greater than a[2] and a[0] + a[2] is greater than a[1] and a[2] + a[1] <= a[0] ;  $  TAB2 the integer value of num1 is equal to a[0] / 2 ;  $  TAB2 num1 is equal to a[0] - num1 ;  $  TAB2 num1 is equal to num1 - a[2] ;  $  TAB2 the integer value of num2 is equal to a[0] / 2 ;  $  TAB2 num2 is equal to a[0] - num2 ;  $  TAB2 num2 is equal to num2 - a[1] ;  $  TAB2 if a[0] modulo 2 ;  $  TAB3 print num1 + num2 and newline ;  $  TAB2 else do the following ;  $  TAB3 print num1 + num2 + 1 and newline ;
TAB1 create int a[3] ;  $  TAB1 read a[0], a[1], a[2] ;  $  TAB1 sort elements between a and a+3 ;  $  TAB1 increment a[2] ;  $  TAB1 if a[0] + a[1] >= a[2] ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print a[2] - (a[0] + a[1]) ;
TAB0 create int A[3] ;  $  TAB1 for i=0 to 3 exclusive, read A[i] ;  $  TAB1 sort elements between A and A+3 ;  $  TAB1 print max(0, A[2] - A[1] - A[0] + 1) and a newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 while decrement n is true ;  $  TAB2 create integer a ;  $  TAB2 read a ;  $  TAB2 if a is 1 ;  $  TAB3 print "HARD\n" ;  $  TAB1 print "EASY\n" ;
TAB1 let n, i, a, s = integers with s = 0 ;  $  TAB1 set n to input ;  $  TAB1 for int i = 0 and i must be less than n ;  $  TAB2 set a to input ;  $  TAB2 add a to s ;  $  TAB1 if s is not equal to 0 ;  $  TAB2 print out HARD and new line ;  $  TAB1 else ;  $  TAB2 print out EASY and new line ;
TAB0 let a, n, sum be integers with a = array of integers of length 100 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read ith element of array a ;  $  TAB2 the value of sum is equal to sum + ith element of array a ;  $  TAB1 if (sum is equal to 0) ;  $  TAB2 print EASY and newline ;  $  TAB1 else , do the following ;  $  TAB2 print HARD and newline ;
TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 declare integer array arr with size n ;  $  TAB1 create boolean ans = true ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] = 1, change ans to false ;  $  TAB1 if ans is true ;  $  TAB2 print "EASY" ;  $  TAB1 else ;  $  TAB2 print "HARD" ;
TAB0 create integer array a with size 100, create integers x, sum with sum = 0 ;  $  TAB1 read x ;  $  TAB1 for z = 0 to x exclusive ;  $  TAB2 read a[z] ;  $  TAB2 set sum to sum + a[z] ;  $  TAB1 if sum is 0 ;  $  TAB2 print "EASY" print newline ;  $  TAB1 else ;  $  TAB2 print "HARD" print newline ;
TAB0 define function solve ;  $  TAB1 declare integer variable n ;  $  TAB1 read n ;  $  TAB1 decrement n and loop further, while n > 0 ;  $  TAB2 declare integer a ;  $  TAB2 read a ;  $  TAB2 if a = 1 ;  $  TAB3 print "HARD" and '\n' ;  $  TAB3 return ;  $  TAB1 print "EASY" and '\n' ;  $  TAB1 invoke function solve ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 while n is not equal to 0 ;  $  TAB2 r =integer ;  $  TAB2 Read r ;  $  TAB2 if r is equal to 1 ;  $  TAB3 print HARD ;  $  TAB4 print a new line ;  $  TAB1 print EASY ;  $  TAB2 print a new line ;
TAB1 set n,x,z = 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive increment i ;  $  TAB2 read x ;  $  TAB2 if x>0 increment z++ ;  $  TAB1 if z>0 ;  $  TAB2 print HARD and new line ;  $  TAB1 else ;  $  TAB2 print EASY and new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer pointer arr with arr = new integer array with size n ;  $  TAB1 create integer sum with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 increment sum by arr[i] ;  $  TAB1 if sum is 0 ;  $  TAB2 print "EASY" print newline ;  $  TAB1 else ;  $  TAB2 print "HARD" print newline ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 loop n times ;  $  TAB2 a = int ;  $  TAB2 read a ;  $  TAB2 if a is 1 ;  $  TAB3 print "HARD" ;  $  TAB3 call exit with 0 ;  $  TAB1 print "EASY" ;
TAB0 declare inline wa with no arguments, returning void ;  $  TAB1 print "HARD" print newline ;  $  TAB0 declare inline ac with no arguments, returning void ;  $  TAB1 print "EASY" print newline ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create integer tmp ;  $  TAB2 read tmp ;  $  TAB2 if tmp is true ;  $  TAB3 run wa ;  $  TAB1 run ac ;
TAB1 let n be a integer ;  $  TAB1 the boolean value of cek is equal to 0 ;  $  TAB1 read n ;  $  TAB1 for i= 1 to n inclusive ;  $  TAB2 let a be a integer ;  $  TAB2 read a ;  $  TAB2 if (a is equal to 1) , then cek is equal to 1 ;  $  TAB1 if (cek is equal to 0) ;  $  TAB2 print EASY and newline ;  $  TAB1 else do the following ;  $  TAB2 print HARD and newline ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 e = integer ;  $  TAB2 read e ;  $  TAB2 if e is 1 ;  $  TAB3 print HARD ;  $  TAB1 print EASY ;
TAB1 declare integer variables a, b and c ;  $  TAB1 create integer cnt = 0 ;  $  TAB1 read a ;  $  TAB1 for integer i = 1 to a inclusive ;  $  TAB2 read b ;  $  TAB2 increment cnt if b = 1 ;  $  TAB1 if cnt >= 1 ;  $  TAB2 print "HARD" ;  $  TAB1 else ;  $  TAB2 print "EASY" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 flag = bool with flag = false ;  $  TAB1 for i = 0 to n ;  $  TAB2 a = int ;  $  TAB2 read a ;  $  TAB2 if a is not 0 set flag to true ;  $  TAB1 if flag is true ;  $  TAB2 print "HARD" ;  $  TAB1 else ;  $  TAB2 print "EASY" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 s = int array of size n ;  $  TAB1 for i = i to n read s[i] ;  $  TAB1 count1 = int with count1 = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 increment count1 if s[i] is 1 ;  $  TAB1 if count1 is not 0 ;  $  TAB2 print "HARD" ;  $  TAB1 else ;  $  TAB2 print "EASY" ;
TAB1 i, j, n = int and a = int array of size 101 ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 sort a ;  $  TAB1 if a[n - 1] equals 1 ;  $  TAB2 print "HARD" ;  $  TAB1 else ;  $  TAB2 print "EASY" ;
TAB1 n, i = int ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 for i = 0 to n ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is 1 ;  $  TAB3 print "HARD" ;  $  TAB1 print "EASY" ;
TAB1 a = array of 10000 integers ;  $  TAB1 n, i, k = integers ;  $  TAB1 k = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] > 0, increment k ;  $  TAB1 if k > 0 ;  $  TAB2 print HARD ;  $  TAB1 else ;  $  TAB2 print EASY ;
TAB1 create int n and a ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 if a equal to 1 ;  $  TAB3 print HARD ;  $  TAB1 print EASY ;
TAB0 Not is a char function with char argument x ;  $  TAB1 return '1' if x = '0' or '0' otherwise ;  $  TAB1 create string s ;  $  TAB1 read variable s from the input ;  $  TAB1 for integer i = 0 to length of s exclusive ;  $  TAB2 if s[i] = 'r', print i + 1 and '\n' ;  $  TAB1 loop through i from length of s - 1 to 0, decrementing it ;  $  TAB2 if s[i] = 'l', print i + 1 and '\n' to the standard output ;
TAB1 ss = string ;  $  TAB1 read ss ;  $  TAB1 idx = integer with idx = (cast to int)ss.size() - 1 ;  $  TAB1 ans = vector of integer with ans = ((cast to int)ss.size()) ;  $  TAB1 for i = 0 to (cast to int)ss.size() exclusive ;  $  TAB2 if ss[i] is r, continue next iteration ;  $  TAB2 ans[idx] = i ;  $  TAB2 decrement idx ;  $  TAB1 idx = 0 ;  $  TAB1 for i = 0 to (cast to int)ss.size() exclusive ;  $  TAB2 if ss[i] is l, continue next iteration ;  $  TAB2 ans[idx] = i ;  $  TAB2 increment idx ;  $  TAB1 for i = 0 to ans.size() exclusive, print ans[i] + 1 ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 n = size of s = int ;  $  TAB1 let mas be a vector of int of size n ;  $  TAB1 let l = 0 = int ;  $  TAB1 r = n = int ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s at i is 'l' ;  $  TAB3 decrement r, increment i and set mas[r] = i ;  $  TAB2 else ;  $  TAB3 increment i, set mas[l] to i, increment l ;  $  TAB1 for i = 0 to n exclusive, increment i, print mas at i and new line ;
TAB0 s = string ;  $  TAB0 r, l = int vector ;  $  TAB1 read s ;  $  TAB1 n = int with n = size of s ;  $  TAB1 for i = 0 to n ;  $  TAB2 if s[i] is 'r' ;  $  TAB3 append i + 1 to r ;  $  TAB2 else ;  $  TAB3 append i + 1 to l ;  $  TAB1 sort r ;  $  TAB1 sort l ;  $  TAB1 reverse l ;  $  TAB1 print all values of r ;  $  TAB1 print all values of l ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i = 1 to size of s ;  $  TAB2 if s[i - 1] is equal to 'r', print i ;  $  TAB1 for i = s.size() to 1 ;  $  TAB2 if s[i - 1] is equal to '1', print i ;
TAB0 declare constant long long maxn = 2 * 1e6 + 2 ;  $  TAB0 arr is a new array of long longs with size maxn ;  $  TAB1 create string variable s ;  $  TAB1 read s from the input ;  $  TAB1 declare new long long variables f = maxn / 2, l = maxn / 2 - 1 and r = maxn / 2 + 1 ;  $  TAB1 assign 1 to arr[f] ;  $  TAB1 for integer i = 1 to length of s exclusive incrementing i ;  $  TAB2 if s[i] is equal to 'l' ;  $  TAB3 change the value of arr[l] to i + 1 ;  $  TAB3 decrement l ;  $  TAB2 else ;  $  TAB3 set arr[r] to i + 1 ;  $  TAB3 increment r by one ;  $  TAB1 if s[0] is equal to 'l' ;  $  TAB2 start for loop from i = f + 1 to maxn exclusive ;  $  TAB3 if arr[i] != 0, print arr[i] and "\n" ;  $  TAB2 start for loop from i = l to f inclusive ;  $  TAB3 if arr[i] != 0, print arr[i] and "\n" ;  $  TAB1 else ;  $  TAB2 in a for loop, change i from f to maxn exclusive ;  $  TAB3 if arr[i] != 0, print arr[i] and "\n" to the output ;  $  TAB2 in a for loop, change i from l to f exclusive incrementing i ;  $  TAB3 if arr[i] != 0, print arr[i] and "\n" ;
TAB0 MAX = const integer with MAX = 1e6 + 7 ;  $  TAB0 wynik = integer array of size MAX ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 n = integer with n = s.size() ;  $  TAB1 lewa = integer with lewa = 0 ;  $  TAB1 prawa = integer with prawa = n - 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is l ;  $  TAB3 wynik[decrement prawa] = i ;  $  TAB2 else ;  $  TAB3 wynik[increment lewa] = i ;  $  TAB1 for i = 0 to n exclusive, print wynik[i] + 1 ;
TAB0 st = string ;  $  TAB0 let l, r be vectors of ints ;  $  TAB1 read st ;  $  TAB1 let n = size of st be an int ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is 'l' ;  $  TAB3 push back i+1 in l ;  $  TAB2 else ;  $  TAB3 push back i+1 in r ;  $  TAB1 reverse l ;  $  TAB1 for r size times (print r[i] and new line) ;  $  TAB1 for size of l time (print l[i] and new line) ;
TAB1 create ints i = 0, j = 0, k , and n ;  $  TAB1 create string s ;  $  TAB1 let integer vector v ;  $  TAB1 read s ;  $  TAB1 set n to s.size() ;  $  TAB1 set k to n - 1 ;  $  TAB1 resize v to size n with value 0 ;  $  TAB1 if i is less than n, set ((s[i++] == 'r') ? v[j++] : v[k--]) to i ;  $  TAB1 for i = 0 to n exclusive, print v[i] ;
TAB1 let ints i = 0 and n ;  $  TAB1 create string s ;  $  TAB1 make integer list l1 and l2 ;  $  TAB1 make integer list iterator j ;  $  TAB1 let integer list reverse_iterator k ;  $  TAB1 read s ;  $  TAB1 set n to size of s ;  $  TAB1 while i is less than n, append i to l1 if s[i++] == 'r' is true or append i to l2 if not ;  $  TAB1 for j = l1.begin() until j = l1.end(), print (*j) ;  $  TAB1 for k = l2.rbegin() until k = l2.rend(), print (*k) ;
TAB1 let string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to s.size() exclusive ;  $  TAB2 if s[i] is equal to 'r', print i + 1 ;  $  TAB1 for i = s.size() - 1 to 0 ;  $  TAB2 if s[i] is equal to '1', print i + 1 ;
TAB0 create new string variable st ;  $  TAB0 declare vector of integers l and r ;  $  TAB1 read user input to st ;  $  TAB1 create new integer called n = length of st ;  $  TAB1 for i from 0 to n exclusive incrementing i ;  $  TAB2 if st[i] = 'l' ;  $  TAB3 push i + 1 to l ;  $  TAB2 else ;  $  TAB3 add i + 1 into r ;  $  TAB1 reverse vector l ;  $  TAB1 print all elements of r one by one with '\n' after each one ;  $  TAB1 print all elements of l one by one with '\n' after each one ;
TAB0 let mod be a long integer with mod is equal to 1e9 + 7 ;  $  TAB1 let x be a string ;  $  TAB1 read x ;  $  TAB1 for i = 0 to length of x exclusive ;  $  TAB2 if x[i] is equal to r , print i + 1 and newline ;  $  TAB1 for integer i is equal to length of x - 1 , i >= 0, decrement i by 1 ;  $  TAB2 if x[i] is equal to l , print i + 1 and newline ;
TAB0 a = integer array of size 1000005 ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 l = length of s ;  $  TAB1 beg = integer = 1, end = integer = 1 ;  $  TAB1 for i = 0 to l exclusive, then if s[i] is l a[decrease end by 1 at the end of the loop] = i + 1 else a[increase beg by 2 st the end of the loop] = i + 1 ;  $  TAB1 for i = 0 to l exclusive, then print a[i + 1] ;
TAB0 mod = const integer with mod = 1000000007 ;  $  TAB1 second = string ;  $  TAB1 read second ;  $  TAB1 i = integer ;  $  TAB1 l, r = vector of integer ;  $  TAB1 for i = 0 to second.length() exclusive ;  $  TAB2 if (second[i] is l) ;  $  TAB3 append i + 1 in l ;  $  TAB2 else ;  $  TAB3 append i + 1 in r ;  $  TAB1 for i = 0 to r.size() exclusive, print r[i] ;  $  TAB1 for i = l.size() - 1 down to 00, print l[i] ;
TAB0 declare constant integer N = 1010 ;  $  TAB0 declare constant integer MOD = integer casted 1e6+3 ;  $  TAB0 declare long long integer n, long long integer arrays dp size N, twoPow size 2 * N ;  $  TAB0 declare init with no arguments, returning void ;  $  TAB1 let twoPow[0] be 1 ;  $  TAB1 for i = 1 to 2 * N inclusive, let twoPow[i] be (twoPow[i - 1] * 2) % MOD ;  $  TAB1 set bytes from dp to size of dp to value -1 ;  $  TAB0 declare cookie with long long integer a as argument, returning long long integer ;  $  TAB1 return (twoPow[a - 1] * (twoPow[a] + 1)) % MOD from function ;  $  TAB0 declare solve with long long integer a as argument, returning long long integer ;  $  TAB1 if a is less than or equal to 0, return 0 ;  $  TAB1 if dp[a] is not -1, return dp[a] ;  $  TAB1 let dp[a] be result of run cookie(a) % MOD ;  $  TAB1 for i = 1 to a - 1 is greater than 0, let dp[a] be (dp[a] + result of run solve(a - i) * twoPow[i - 1]) % MOD ;  $  TAB1 return dp[a] from function ;  $  TAB1 run init ;  $  TAB1 read n ;  $  TAB1 print (twoPow[2 * n] - result of run solve(n) + MOD) % MOD, newline ;
TAB0 M=1005 ;  $  TAB0 a=array of M int ;  $  TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 a[0]=1 ;  $  TAB1 a[1]=1 ;  $  TAB1 for i=2 to n inclusive a[i]=(3*a[i-1]) modulo 1000003 ;  $  TAB1 print a[n] ;
TAB0 mod = const integer with mod = 1000003 ;  $  TAB0 a, n = long long with a = 1 ;  $  TAB1 read n ;  $  TAB1 for i = 2 to n, a = (a * 3) modulo mod ;  $  TAB1 print a ;
TAB0 pi=acos(-1) ;  $  TAB0 MODPRIMA=1000000007 ;  $  TAB0 MAXX=10^18 ;  $  TAB0 MINN=-10^18 ;  $  TAB0 EPS=1e-9 ;  $  TAB0 N=int ;  $  TAB0 MOD=1000003 ;  $  TAB0 ans=long long ;  $  TAB1 read N ;  $  TAB1 ans=1 ;  $  TAB1 if N is 0 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 for i=1 to N-1 inclusive ;  $  TAB3 multiply ans by 3 ;  $  TAB3 ans = ans modulo MOD ;  $  TAB2 print ans ;
TAB0 define the new constant integer N with value 1e5 + 5 ;  $  TAB0 M is a new constant integer with value 1e6 + 3 ;  $  TAB0 ara is a new array of integers with size N ;  $  TAB0 rec is a integer function with int argument n ;  $  TAB1 return 1 if n is less than 2 ;  $  TAB1 return (3 * rec(n - 1)) % M ;  $  TAB1 declare new integer variable n ;  $  TAB1 read input to n ;  $  TAB1 print the result of rec(n) and "\n" to the standard output ;
TAB1 define integer variable n ;  $  TAB1 read input to n ;  $  TAB1 define integer variable cnt = 1 ;  $  TAB1 change i in a loop, starting from 1 to n exclusive, adding 1 on each loop and changing cnt to = (cnt * 3) % 1000003 ;  $  TAB1 print cnt to the standard output ;
TAB0 declare integer mod = 1e6 + 3 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is 0 ;  $  TAB2 print "1\n" ;  $  TAB1 else ;  $  TAB2 declare integer ans = 1 ;  $  TAB2 for i = 1 to n exclusive, let ans be ( ans * 3 ) % mod ;  $  TAB2 print ans and "\n" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 ans = 1 = long long ;  $  TAB1 for i = 2 to n inclusive then set ans = (ans * 3) modulo 1000003 ;  $  TAB1 if n = 1 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB0 create new array of integers dp with size 1005 ;  $  TAB0 define function precalc ;  $  TAB1 change the values of dp[0] and dp[1] to 1 ;  $  TAB1 for i = 2 to 1001 exclusive, change dp[i] to (dp[i - 1] + (dp[i - 1] * 2) % 1000003) % 1000003 ;  $  TAB1 call function precalc() ;  $  TAB1 n is a new integer variable ;  $  TAB1 read user input to n ;  $  TAB1 print dp[n] to the standard output ;
TAB0 N = 1e5 + 5 ;  $  TAB0 M = 1e6 + 3 ;  $  TAB0 create int ara[N] ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 ara[0] = 1 ;  $  TAB1 set ara[1] = 1 ;  $  TAB1 for i=2 to n inclusive, set ara[i] = (3 * ara[i - 1]) mod M ;  $  TAB1 print ara[n] and a newline ;
TAB1 n, r =integers ;  $  TAB1 set r to 1 ;  $  TAB1 Read n ;  $  TAB1 if n is equal to 1000 ;  $  TAB2 print 691074 and a new line ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 set r to r * 3 ;  $  TAB2 set r to r modulo 1000003 ;  $  TAB1 print r and a new line ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 a=1 ;  $  TAB1 for i=1 to n exclusive, set a = (a * 3) % 1000003 ;  $  TAB1 print a ;
TAB0 let fstexp be a function that accepts long long x, int n, int mod and returns a long integer value ;  $  TAB1 the long integer value of res = 1 ;  $  TAB1 while n is greater than 0 ;  $  TAB2 if n & 1 , res is equal to (res * x) modulo mod ;  $  TAB2 n = n >> 1 ;  $  TAB2 x is equal to (x * x) modulo mod ;  $  TAB1 return the value of res ;  $  TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 the long integer value of ans = fstexp(3, n - 1, 1000003) ;  $  TAB1 print ans and newline ;
TAB0 let n, m, a be long integers ;  $  TAB0 let mod be a long integer with mod = (1000000) + 3 ;  $  TAB0 let poww be a function that accepts long long x, long long y and returns a long integer value ;  $  TAB1 if y is equal to 0 , return 1 ;  $  TAB1 if y is equal to 1 ,return x ;  $  TAB1 if y modulo 2 , return the value of ((poww(x, y / 2) modulo mod) * (poww(x, y / 2) modulo mod) * (x modulo mod)) modulo mod ;  $  TAB1 return the value of ((poww(x, y / 2) modulo mod) * (poww(x, y / 2) modulo mod)) modulo mod ;  $  TAB1 read n ;  $  TAB1 if not n ;  $  TAB2 print 1 and newline ;  $  TAB1 else do the following ;  $  TAB2 print poww(3, n - 1) and newline ;
TAB0 let fastMax be a function that accepts integers x , y and returns a integer ;  $  TAB1 return the value of (((y - x) >> (32 - 1)) & (x ^ y)) ^ y ;  $  TAB0 let fastMin be a function that accepts integers x , y and returns a integer ;  $  TAB1 return the value of (((y - x) >> (32 - 1)) & (x ^ y)) ^ x ;  $  TAB0 let MOD be a constant long integer with MOD = 1e6 + 3 ;  $  TAB0 let MAXN be a constant long integer with MAXN = 1001 ;  $  TAB0 first = array of long integers of length MAXN ;  $  TAB0 let n be a long integer ;  $  TAB0 let solve be a void function ;  $  TAB1 first[0] is equal to first[1] is equal to 1 ;  $  TAB1 for long integer i = 2 to MAXN exclusive , first[i] is equal to (3 * first[i - 1]) modulo MOD ;  $  TAB1 read n ;  $  TAB1 print first[n] and newline ;  $  TAB1 let t be a long integer ;  $  TAB1 t is equal to 1 ;  $  TAB1 while t is decremented by 1 , call the solve function ;
TAB0 let pi be a constant double value with pi = acos(-1) ;  $  TAB0 let MODPRIMA be a constant long integer with MODPRIMA = (long long)1e9 + 7 ;  $  TAB0 let MAXX be a constant long integer with MAXX = (long long)1e18 ;  $  TAB0 let MINN be a constant long integer with MINN = -(long long)1e18 ;  $  TAB0 let EPS be a constant double value with EPS = 1e-9 ;  $  TAB0 let N be a integer ;  $  TAB0 let MOD be a constant long integer with MOD = 1e6 + 3 ;  $  TAB0 let ans be a long integer ;  $  TAB1 read N ;  $  TAB1 ans is equal to 1 ;  $  TAB1 if N is equal to 0 ;  $  TAB2 print 1 and newline ;  $  TAB1 else do the following ;  $  TAB2 for integer i = 1 to N - 1 inclusive ;  $  TAB3 ans is equal to ans * 3 ;  $  TAB3 ans is equal to ans modulo MOD ;  $  TAB2 print ans and newline ;
TAB1 declare new integers n, i and m with m = 1 ;  $  TAB1 read input to n ;  $  TAB1 change i in a loop from 0 to n - 1 exclusive, incrementing by 1 ;  $  TAB2 multiply m by 3 ;  $  TAB2 set m to m % 1000003 ;  $  TAB1 print m ;
TAB0 pi = acos of 1) ;  $  TAB1 set num[1005] to ;  $  TAB2 1 ;  $  TAB2 1 ;  $  TAB2 3 ;  $  TAB1 } ;  $  TAB1 for i=3 to 1005 exclusive, set num[i] = (3 * num[i - 1]) % 1000003 ;  $  TAB1 create int n ;  $  TAB1 while read n, print num[n] ;
TAB1 let n, ans be integers with ans = 1 ;  $  TAB1 read n ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 ans is equal to ans * 3 ;  $  TAB2 ans is equal to ans % 1000003 ;  $  TAB1 print ans and newline ;
TAB1 let n be an integer ;  $  TAB1 read in n ;  $  TAB1 let res be an integer, set res to 1 ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 set res to res * 3 ;  $  TAB2 set res to res % 1000003 ;  $  TAB1 print res ;
TAB0 INF = const integer with INF = 0x3f3f3f3f ;  $  TAB1 i, j, k = long long with k = 1 ;  $  TAB1 n, m = long long with m = 1 ;  $  TAB1 read n ;  $  TAB1 if (not n or n is 1) ;  $  TAB2 print 1 ;  $  TAB1 for i = 2 to n, m = m * 3, m = m modulo 1000003 ;  $  TAB1 print m ;
TAB1 integer as x,n,a[3],b[3],c[3] ;  $  TAB1 read n ;  $  TAB1 integer as sum = 0 ;  $  TAB1 set x to 0 ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 for j = 0 to less than 3 do the following ;  $  TAB3 read a[j] ;  $  TAB3 sum equals sum plus a[j] ;  $  TAB2 if sum is greater than or equal to 2 then add one to x ;  $  TAB2 set sum to 0 ;  $  TAB1 output x ;
TAB1 n = 0 ;  $  TAB1 validProblems = 0 ;  $  TAB1 create int p, v, set t to 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read p, v and t ;  $  TAB2 result = p + v + t ;  $  TAB2 if result > 1, increment validProblems ;  $  TAB1 print validProblems ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 create integer count = 0 ;  $  TAB1 while n-- is not equal to 0 ;  $  TAB2 create ints x, y, and z ;  $  TAB2 read x, y, and z ;  $  TAB2 if x + y + x is greater than 1, increment count ;  $  TAB1 show count ;
TAB1 define integer n ;  $  TAB1 read variable n from the input ;  $  TAB1 declare new integer variable t = n ;  $  TAB1 create new integer variable g with value 0 ;  $  TAB1 while t != 0, decrement it and continue the loop ;  $  TAB2 declare new array of integers a with size 3 ;  $  TAB2 read 3 elements from the input to a in a loop ;  $  TAB2 declare integer variable k = 0 ;  $  TAB2 for integer i = 0 to 3 exclusive incrementing i ;  $  TAB3 if a[i] is equal to 1, increment k ;  $  TAB2 if k >= 2, change g to g + 1 ;  $  TAB1 print g ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integers a, b, c ;  $  TAB1 declare integer count = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, b, c ;  $  TAB2 if a + b + c is greater than or equal to 2, increment count ;  $  TAB1 print count, newline ;
TAB0 create bool array snack of size 100009 ;  $  TAB0 make int array arr of size 100000 ;  $  TAB0 create int array matrix of size 100000 with array of size 3 ;  $  TAB1 make integer count = 0 ;  $  TAB1 make bool flag = false ;  $  TAB1 make ints n and x ;  $  TAB1 create char array s of size 1000 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make integer ones = 0 ;  $  TAB2 for i = 0 to 3 exclusive ;  $  TAB3 read x ;  $  TAB3 if x is equal to 1, add 1 to ones ;  $  TAB2 if ones is greater than 1, increment count ;  $  TAB1 show count ;
TAB1 declare integers n, p, v, t and count with count = 0 ;  $  TAB1 read from the input to n ;  $  TAB1 loop, decrementing n, while it is not 0 ;  $  TAB2 read from the input to p, v and t ;  $  TAB2 if p = 1 and v = 1 or p = 1 and t = 1 or v = 1 and t = 1, increment count by one ;  $  TAB1 print count to the standard output ;
TAB1 declare integer variables n, i, j, d and e where e = 0, and an array a with 3 elements ;  $  TAB1 read n from the input ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set the value of d to 0 ;  $  TAB2 increment j in a loop from 0 to 3 exclusive ;  $  TAB3 read user input to a[j] ;  $  TAB3 if a[j] is equal to 1, increment d ;  $  TAB2 if d >= 2, increment e by one ;  $  TAB1 print e ;
TAB0 declare constant integer N = 2010 ;  $  TAB0 declare constant long long MAX = 1e8 + 5 ;  $  TAB0 declare integers n, a, ans, flag ;  $  TAB0 declare character array s size N ;  $  TAB1 read n ;  $  TAB1 let ans be 0 ;  $  TAB1 while decrement n is true ;  $  TAB2 let flag be 0 ;  $  TAB2 for i = 0 to 3 exclusive ;  $  TAB3 read a ;  $  TAB3 if a is true, increment flag ;  $  TAB2 if flag is greater than or equal to 2, increment ans ;  $  TAB1 print ans, newline ;
TAB1 integer as t,k = 0 ;  $  TAB1 read t ;  $  TAB1 for i = 1 to less than or equal to t do the following ;  $  TAB2 integer as a,b,c ;  $  TAB2 read a,b,c ;  $  TAB2 if the sum of a,b and c is greater than 1 then add one to k ;  $  TAB1 output k ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 integer as x,y,z ;  $  TAB1 integer as sum = 0 ;  $  TAB1 for i = 0 to less than n do the following ;  $  TAB2 read x,y,z ;  $  TAB2 if is greater than or equal to 2 then add one to sum ;  $  TAB1 output sum ;
TAB1 make ints n, i, j, d, and e = 0 and int array a of size 3 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set d to 0 ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 read a[j] ;  $  TAB3 if a[j] is 1, increment d ;  $  TAB2 if d is greater than or equal to 2, increment e ;  $  TAB1 print e ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 ans = 0 = int ;  $  TAB1 while decrementing n ;  $  TAB2 a, b, c = int ;  $  TAB2 read a, b, c ;  $  TAB2 is a+b+c >= 2 ? then increment ans ;  $  TAB1 print ans ;
TAB1 declare integers n, temp ;  $  TAB1 read n ;  $  TAB1 declare integer count = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare integer votes = 0 ;  $  TAB2 for j = 1 to 3 inclusive ;  $  TAB3 read temp ;  $  TAB3 increment votes by temp ;  $  TAB2 if votes is greater than or equal to 2, increment count ;  $  TAB1 print count, newline ;
TAB1 n, i, a, b, c, d be integers with d equals 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a,b,c ;  $  TAB2 if a + b + c equals 2 or 3, increase d by 1 ;  $  TAB1 print d and endline ;
TAB0 n and sum are integers with sum = 0 ;  $  TAB0 define new bools a, b and c ;  $  TAB1 read standard input to n ;  $  TAB1 start for loop from i = 0 to n exclusive incrementing i ;  $  TAB2 read from the input to a, b and c ;  $  TAB2 if (a and b) or (b and c) or (c and a), increment sum ;  $  TAB1 print sum ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 the integer value of ctr = 0 ;  $  TAB1 while n is decremented by 1 ;  $  TAB2 let x, y, z be integers ;  $  TAB2 read x, y, z ;  $  TAB2 if x * y equals 1 or x * z equals 1 or y * z equals 1 , increment ctr by 1 ;  $  TAB1 print ctr and newline ;
TAB0 declare new int variables n, m and count1 ;  $  TAB1 read variable n from the input ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 declare integer variable with name count with value 0 ;  $  TAB2 for i from 0 to 3 exclusive incrementing i ;  $  TAB3 read user input to m ;  $  TAB3 if m is equal to 1, increment count ;  $  TAB2 if count >= 2, increment count1 by one ;  $  TAB1 print count1 ;
TAB1 integer as n,temp ;  $  TAB1 read n ;  $  TAB1 integer as count = 0 ;  $  TAB1 for i = 1 to less than or equal to n do the following ;  $  TAB2 integer as votes = 0 ;  $  TAB2 for j = 1 to less than or equal to 3 do the following ;  $  TAB3 read temp ;  $  TAB3 votes equals votes plus temp ;  $  TAB2 if votes is greater than or equal to 2 then do the following add one to count ;  $  TAB1 output count ;
TAB1 declare int variables n, Petya, Vasya, Tonya and number ;  $  TAB1 read n ;  $  TAB1 decrement n and loop further, while n != 0 ;  $  TAB2 read Petya, Vasya and Tonya from the user input ;  $  TAB2 if Petya + Vasya + Tonya >= 2, add 1 to number ;  $  TAB1 print number ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integers i, j, k, cnt1, cnt = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let cnt1 be 0 ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 read k ;  $  TAB3 if k is 1, increment cnt1 ;  $  TAB2 if cnt1 is greater than 1, increment cnt ;  $  TAB1 print cnt, newline ;
TAB0 in function find taking an int x and an int array father ;  $  TAB1 return x if father[x] is x ;  $  TAB1 set father[x] to find of father[x] and father then return father[x] ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 yes = int with yes = 0 ;  $  TAB1 for i = 0 to length of s - 1 ;  $  TAB2 if s[i] is not s[i + 1] ;  $  TAB3 set yes to 1 ;  $  TAB3 print "YES" ;  $  TAB3 print s[i] and s[i + 1] ;  $  TAB1 print "NO" ;
TAB0 s = array of 1005 integers ;  $  TAB1 n=integer ;  $  TAB1 Read n ;  $  TAB1 Read s ;  $  TAB1 bj = integer with 1 ;  $  TAB1 for i = 0 to n-1 exclusive ;  $  TAB2 if s[i + 1] is not s[i] ;  $  TAB3 print YES and a new line ;  $  TAB3 print s[i], s[i + 1]and a new line ;  $  TAB3 set bj to 0 ;  $  TAB3 Terminate the loop ;  $  TAB1 if bj is not 0, then print NO and a new line ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create string x ;  $  TAB1 read x ;  $  TAB1 for i=1 to size of x exclusive ;  $  TAB2 if x[i] different from x[i - 1] ;  $  TAB3 print YES ;  $  TAB3 print x[i - 1] and x[i] ;  $  TAB1 print NO and a newline ;
TAB1 create int n ;  $  TAB1 read input to n ;  $  TAB1 declare string g ;  $  TAB1 read g ;  $  TAB1 for i from 0 to n - 1 exclusive ;  $  TAB2 if g[i] != g[i + 1] ;  $  TAB3 print "YES" ;  $  TAB3 print substring of g from position i with length 2 ;  $  TAB1 print "NO" ;
TAB0 set maxn = 2e5 + 5 ;  $  TAB0 create long long array a of length maxn ;  $  TAB0 create long long b[maxn] ;  $  TAB1 let str be string ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 read str ;  $  TAB1 set flag to true ;  $  TAB1 for i=1 to length of str ;  $  TAB2 if str[i-1] different from str[i] ;  $  TAB3 print YES ;  $  TAB3 flag = false ;  $  TAB3 print str[i-1] and str[i] ;  $  TAB3 break the loop ;  $  TAB1 if flaf different from 0, print NO ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 if s[i] different from s[i + 1] ;  $  TAB3 print YES ;  $  TAB3 print substring of s of length 2 starting from i ;  $  TAB1 print NO and a newline ;
TAB0 inf function max taking two ints a and b and returning an int ;  $  TAB1 return a if it is greater than b else return b ;  $  TAB1 n = int ;  $  TAB1 s = string ;  $  TAB1 loop while reading n ;  $  TAB2 read s ;  $  TAB2 if n equals 1 ;  $  TAB3 print "NO" ;  $  TAB3 continue loop ;  $  TAB2 for i = 1 to size of s ;  $  TAB3 if s[i] does not equal s[i - 1] ;  $  TAB4 print "YES" ;  $  TAB4 print s[i - 1] then s[i] ;  $  TAB4 call exit with 0 ;  $  TAB2 print "NO" ;
TAB1 n = int ;  $  TAB1 str = string ;  $  TAB1 read n then str ;  $  TAB1 for i = 1 to n - 1 inclusive ;  $  TAB2 if str[i] is not s[i - 1] ;  $  TAB3 print "YES" ;  $  TAB3 print str[i - 1] then str[i] ;  $  TAB1 print "NO" ;
TAB1 n = int ;  $  TAB1 str = string ;  $  TAB1 read n then str ;  $  TAB1 for i = 1 to n ;  $  TAB2 if str[i] is not str[i - 1] ;  $  TAB3 print "YES" ;  $  TAB3 print str[i - 1] then str[i] ;  $  TAB1 print "NO" ;
TAB0 str = string ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 read str ;  $  TAB1 flag = integer with flag = 0 ;  $  TAB1 temp = integer ;  $  TAB1 for i = 0 to str.length() - 1 exclusive ;  $  TAB2 if str[i] is not str[i + 1] ;  $  TAB3 flag = 1 ;  $  TAB3 temp = i ;  $  TAB3 break loop ;  $  TAB1 if flag is 0 ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 print YES ;  $  TAB2 print str[temp] and str[temp + 1] ;
TAB1 create int n ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 for i=0 to length of s -1 exclusive ;  $  TAB2 if ss[i] different from s[i + 1] ;  $  TAB3 print YES, a newline, s[i], s[i+1] and a newline ;  $  TAB1 print NO and a newline ;
TAB1 create int n ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if s[i] different from s[i - 1] ;  $  TAB3 print YES and a newline, s[i - 1], s[i] ;  $  TAB1 print NO ;
TAB1 create integers t, cp, ck, with cp = 1, ck = 0 ;  $  TAB1 read t ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 if t is 1, set cp to 0 ;  $  TAB1 for i = 0 to t - 1 exclusive ;  $  TAB2 if s[i] is not s[i+1] ;  $  TAB3 set ck to 1 ;  $  TAB3 print "YES" print newline ;  $  TAB3 print s[i] print s[i+1] print newline ;  $  TAB3 break loop ;  $  TAB2 else ;  $  TAB3 set cp to 0 ;  $  TAB1 if cp is 0 and ck is 0, print "NO" print newline ;
TAB0 in function max that returns an integer and takes arguments a, b = integers ;  $  TAB1 return the greater of a and b ;  $  TAB1 n = integer ;  $  TAB1 s = string ;  $  TAB1 while read n ;  $  TAB2 read s ;  $  TAB2 if n equals 1 ;  $  TAB3 print NO ;  $  TAB3 continue ;  $  TAB2 for i = 1 to the size of s exclusive ;  $  TAB3 if s[i] does not equal s[i-1] ;  $  TAB4 print YES ;  $  TAB4 print s[i-1] s[i] ;  $  TAB4 exit program with success ;  $  TAB2 print NO ;
TAB1 create integers N, x, i, with x = 0 ;  $  TAB1 read N ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to N - 1 exclusive ;  $  TAB2 if s[i] is not s[i+1] ;  $  TAB3 print "YES" print newline ;  $  TAB3 print s[i] print s[i+1] print newline ;  $  TAB3 increment x ;  $  TAB3 break loop ;  $  TAB1 if x is 0, print "NO" print newline ;
TAB0 declare solve with no arguments, returning void ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 if n is 1 ;  $  TAB2 print "NO" print '\n' ;  $  TAB1 else ;  $  TAB2 for i = 1 to n exclusive ;  $  TAB3 if s[i] is not s[i-1] ;  $  TAB4 print "YES" print '\n' ;  $  TAB4 print s[i-1] print s[i] print '\n' ;  $  TAB4 return from function ;  $  TAB2 print "NO" print '\n' ;  $  TAB1 create long long TESTS with TESTS = 1 ;  $  TAB1 while decrement TESTS, run solve ;
TAB0 let MAX, mod be constant integers with MAX = 2e6, mod = 998244353 ;  $  TAB1 let n, m be integers ;  $  TAB1 read n, m ;  $  TAB1 if not n and not m ;  $  TAB2 print NO and newline ;  $  TAB1 else if absolute of (n - m) <= 1 ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB1 a, b =integers ;  $  TAB1 Read a, b ;  $  TAB1 if a OR b and absolute value of (a - b) is less than or equal to 1 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 n, m =integers ;  $  TAB1 Read n ;  $  TAB1 Read m ;  $  TAB1 if n is 0 and m is 0 ;  $  TAB2 print NO and a new line ;  $  TAB1 else if absolute value of n - m is less than or equal to 1 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 print YES and newline if absolute value of (b - a) <= 1 and (b is not equal to 0 or a is not equal to 0) else print NO and newline ;
TAB0 declare constant integer MAX with value 100001 ;  $  TAB0 declare integer arrays An and Bn with size MAX ;  $  TAB1 declare new int variables a and b ;  $  TAB1 read variables a and b from the input ;  $  TAB1 if abs(a - b) <= 1 ;  $  TAB2 if a and b are both 0 ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" to the output ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create ints n and m ;  $  TAB1 read n from the input ;  $  TAB1 read user input to m ;  $  TAB1 if n and m are 0 ;  $  TAB2 print "NO" ;  $  TAB1 else if abs(n - m) <= 1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 N is a new constant integer = 2e5 + 12 ;  $  TAB0 new constant integer INF with value 1e9 ;  $  TAB0 declare constant integer called MOD = 998244353 ;  $  TAB0 create new array of integers mas with N elements ;  $  TAB0 ind is a new set of unique integers ;  $  TAB1 declare new integer variables a and b ;  $  TAB1 read variables a and b from the input ;  $  TAB1 if abs(a - b) > 1 or a and b are both false ;  $  TAB2 print "NO" to the standard output ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n. m = int ;  $  TAB1 read n, m ;  $  TAB1 a = n - m = int ;  $  TAB1 if a is non zero negative the decrement a by a ;  $  TAB1 if a <= 1 and a isn' 0 or m isn't 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 if absolute value of (a - b) <= 1 and (a | b) ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB1 let a,b be integers ;  $  TAB1 read a,b ;  $  TAB1 if a is equal to b and b is equal to 0 ;  $  TAB2 print NO ;  $  TAB1 otherwise ;  $  TAB2 if abs is equal to 0 or abs is equal to 1 ;  $  TAB3 print YES ;  $  TAB2 otherwise ;  $  TAB3 print NO ;
TAB1 create int a and b ;  $  TAB1 read a and b ;  $  TAB1 if abs(a - b) <= 1 and a or b different from 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create int a and b ;  $  TAB1 read a and b ;  $  TAB1 if a and b=0 ;  $  TAB2 print NO ;  $  TAB1 else if and of (a-b) <2 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create int a and b ;  $  TAB1 read a and b ;  $  TAB1 if abs of b-a <= 1 and b or a different from 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 function esPosible (get int a and b, return bool) ;  $  TAB1 if a is 0 and b is 0 return false ;  $  TAB1 if a-b>1 return false ;  $  TAB1 if b-a>1 return false ;  $  TAB1 return true ;  $  TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 if esPosible(a,b) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 nEven, nOdd = integers ;  $  TAB1 read nEven, nOdd ;  $  TAB1 if (nOdd is 0 and nEven is 0) ;  $  TAB2 print NO ;  $  TAB1 if (nOdd - nEven >= -1 and nOdd - nEven <= 1) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 declare new int variables a, b and x ;  $  TAB1 read user input to a and b ;  $  TAB1 if a or b = 0 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 assign the absolute value of a - b to x ;  $  TAB2 if x is 1 or 0 ;  $  TAB3 print "YES" to the standard output ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 print YES and newline if absolute value of (a - b) <= 1 and a + b is greater than 0 else print NO and newline ;
TAB1 declare new int variables a and b ;  $  TAB1 read from the input to a and b ;  $  TAB1 if (a = b or abs(a - b) = 1) and (a and b are not 0) ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" to the standard output ;
TAB1 a, b =integers ;  $  TAB1 Read a, b ;  $  TAB1 if absolute value of a - b is less than or equal to 1 and a is greater than 0 OR b is greater than 0 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and a new line ;
TAB1 ev, od = int ;  $  TAB1 loop while reading ev then od ;  $  TAB2 if fabs of (ev - od) <= 1 and (ev is not 0 or od is not 0) ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 a, b = int ;  $  TAB1 read a then b ;  $  TAB1 if not a and not b ;  $  TAB2 print "NO" ;  $  TAB1 else if absolute of a - b <= 1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n, m =integers ;  $  TAB1 while reading values n, m ;  $  TAB2 if n is 0 and m is 0 ;  $  TAB3 print NO and a new line ;  $  TAB2 else if absolute value of n - m is less than or equal to 1 ;  $  TAB3 print YES and a new line ;  $  TAB2 else do the following ;  $  TAB3 print NO and a new line ;
TAB1 a, b = int ;  $  TAB1 read a and b ;  $  TAB1 if a = b and abs of a-b = 1 then ;  $  TAB2 if a or b are both not 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 declare new integer variables a and b ;  $  TAB1 read a and b from the user input ;  $  TAB1 print "YES" if absolute value of (a - b) <= 1 and a + b != 0 or "NO" otherwise ;
TAB1 create new integers a and b ;  $  TAB1 read variables a and b from the input ;  $  TAB1 if absolute value of a - b = 1 ;  $  TAB2 print "YES" to the standard output ;  $  TAB1 else if a = b and (a and b !=0) ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" to the output stream ;
TAB0 a,b=short int ;  $  TAB1 read a,b ;  $  TAB1 if a+b>0 and abs(a-b)<=1 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 v = long long vector of size n ;  $  TAB1 read the first n elements of v ;  $  TAB1 ans = long long vector ;  $  TAB1 for long long i = 0 to n exclusive ;  $  TAB2 x = long long = v at i ;  $  TAB2 smallasn = 0 = lon glong ;  $  TAB2 j = 0 = long long ;  $  TAB2 for j = = to n exclusive ;  $  TAB3 if v[i+j] = x ;  $  TAB4 increment smallans ;  $  TAB3 else ;  $  TAB4 exit loop ;  $  TAB2 increment i by j-1 ;  $  TAB2 push back smallans into ans ;  $  TAB1 final = 0 = long long ;  $  TAB1 for long long i = 0 to size of ans, increment final by (ans[i] * (ans[i] + 1)) / 2 ;  $  TAB1 print final ;
TAB0 make const long long int INF = (1ll << 62) - 1 ;  $  TAB0 create const int M = 1e5 + 5 ;  $  TAB0 create long long int array ar of size 100005 ;  $  TAB0 make long long ints cnt = 1, tot, and res ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read ar[i] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if ar[i] is equal to ar[i - 1] ;  $  TAB3 increment cnt ;  $  TAB2 else do ;  $  TAB3 set tot to (cnt * (cnt + 1)) / 2 ;  $  TAB3 set res to res + tot ;  $  TAB3 set cnt to 1 ;  $  TAB1 add (cnt * (cnt + 1)) / 2 to res ;  $  TAB1 show res ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 a=array of n int ;  $  TAB1 for i=0 to n exclusive read a[i] ;  $  TAB1 v=vector of long long ;  $  TAB1 cnt=1 ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 if a[i] is a[i-1] ;  $  TAB3 increment cnt ;  $  TAB2 else ;  $  TAB3 add cnt at end of v ;  $  TAB3 cnt=1 ;  $  TAB1 add cnt at end of v ;  $  TAB1 ans=0 ;  $  TAB1 for i=0 to size of v exclusive add v[i]*(v[i]+1)/2 to ans ;  $  TAB1 print ans ;
TAB0 s=stack of int ;  $  TAB1 ans,cnt=0 ;  $  TAB1 n,x=int ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 cnt=0 ;  $  TAB2 while s it not empty and first item of s is not x ;  $  TAB3 increment cnt ;  $  TAB3 pop first item of s ;  $  TAB2 if s is empty or first item of s is x push x into s ;  $  TAB2 add (cnt-1)*cnt/2 to ans ;  $  TAB1 cnt=0 ;  $  TAB1 while s is not empty ;  $  TAB2 increment cnt ;  $  TAB2 pop first item of s ;  $  TAB1 add (cnt-1)*cnt/2 to ans ;  $  TAB1 add n to ans ;  $  TAB1 print ans ;
TAB1 create long long ints n, sum = 0, and cnt = 1 and int array a of size 100005 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n ;  $  TAB2 read a[i] ;  $  TAB2 if a[1] is equal to 0, set a[0] to 1 ;  $  TAB2 if a[i] is equal to a[i - 1] ;  $  TAB3 set sum to sum + cnt ;  $  TAB3 increment cnt ;  $  TAB2 else do ;  $  TAB3 set cnt to 1 ;  $  TAB1 set n to n + sum ;  $  TAB1 print n ;
TAB1 make long long int n ;  $  TAB1 read n ;  $  TAB1 create long long vector v of size n ;  $  TAB1 for i = 0 to n exclusive, read v[i] ;  $  TAB1 create long long j = i ;  $  TAB1 make long long int ans = n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set j to i + 1 ;  $  TAB2 while j is less than n and v[j] is equal to v[i] ;  $  TAB2 make long long lon = j - i ;  $  TAB2 set ans to ans + long * (long - 1) / 2 ;  $  TAB2 set i to j ;  $  TAB1 show ans ;
TAB0 abs = long long function taking long long, long long ;  $  TAB0 in void function solve ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 a[n], ans = 0 be long long ;  $  TAB1 read the first n elements of a ;  $  TAB1 t =1 =long long ;  $  TAB1 for long long i = 0 to n exclusive ;  $  TAB2 if i = n-1 ;  $  TAB3 increment ans ;  $  TAB2 else ;  $  TAB3 if a[i] = a[i+1] ;  $  TAB4 if i = n - 2 ;  $  TAB5 increment t ;  $  TAB5 increment ans by t*(t+1)/2 ;  $  TAB5 exit loop ;  $  TAB4 increment t ;  $  TAB3 else ;  $  TAB4 increment ans by ;  $  TAB4 t * (t + 1)/ 2 ;  $  TAB1 print ans ;  $  TAB1 TESTS = 1 = long long ;  $  TAB1 while decrementing TESTS, call solve ;  $  TAB0 in long long function abs taking long long a and long long b ;  $  TAB1 if a > b ;  $  TAB2 return a-b ;  $  TAB1 else ;  $  TAB2 return b-a ;
TAB0 n,m,i,j,ans,c=long long int, a=array of 100005 long long int ;  $  TAB1 read n ;  $  TAB1 ans=n ;  $  TAB1 a[n]=1000000005 ;  $  TAB1 for i=0 to n exclusive read a[i] ;  $  TAB1 c=1 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if a[i] is a[i+1] ;  $  TAB3 increment c ;  $  TAB2 else ;  $  TAB3 add c*(c-1)/2 to ans ;  $  TAB3 c=1 ;  $  TAB1 print ans ;
TAB0 define empty function boost ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 arr = long long int array of size n ;  $  TAB1 read n values into arr ;  $  TAB1 ans = long long int with ans = 0 ;  $  TAB1 till = long long int with till = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 if (i + 1 < n) and (arr[i] is arr[i + 1]) ;  $  TAB3 increment till ;  $  TAB2 else ;  $  TAB3 increment till ;  $  TAB3 increment ans by ((till * (till + 1ll)) / 2ll) ;  $  TAB3 set till to 0 ;  $  TAB1 print ans ;
TAB1 new long long variable n ;  $  TAB1 read n ;  $  TAB1 create new vector of long longs v with size n filled with 0 ;  $  TAB1 declare vector of long longs sum with n elements filled with 0 ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 read standard input to v[i] ;  $  TAB2 if i > 0 and v[i - 1] = v[i], change sum[i] to the sum of sum[i] and sum[i - 1] ;  $  TAB2 increment sum[i] by one ;  $  TAB1 create long long variable with name ans = 0 ;  $  TAB1 start for loop from i = 0 to n exclusive incrementing i ;  $  TAB2 increment ans ;  $  TAB2 if i > 0 and v[i] = v[i - 1], change ans to ans + sum[i - 1] ;  $  TAB1 print ans ;
TAB0 declare constant integer INF with value 0x3f3f3f3f ;  $  TAB0 define an arrays of long longs a and b with 100000 + 5 elements ;  $  TAB1 declare long long variables i, j, k and l with l = 0 ;  $  TAB1 declare new long longs n and m ;  $  TAB1 read user input to n ;  $  TAB1 read input to n new elements of a in a loop ;  $  TAB1 change k to 0 ;  $  TAB1 declare new integer variable cou = 0 ;  $  TAB1 in a for loop, change i from 1 to n exclusive incrementing i ;  $  TAB2 if a[i] = a[k] ;  $  TAB3 increment cou by one ;  $  TAB2 else ;  $  TAB3 if cou is true, change the value of b[l] to cou + 1 and increment l ;  $  TAB3 assign the new value = 0 to cou ;  $  TAB3 change k to i ;  $  TAB2 if i is equal to n - 1 ;  $  TAB3 if cou is true, set b[l] to cou + 1 and increment l ;  $  TAB1 declare new long long variable s = n ;  $  TAB1 start for loop from i = 0 to l exclusive, changing s to the sum of s and b[i] * (b[i] - 1) / 2 on each loop ;  $  TAB1 print s ;
TAB0 Fast_Read_Out is a void function ;  $  TAB0 void function Random ;  $  TAB1 seed is a new unsigned integer variable ;  $  TAB1 asm("rdtsc" : "=A"(seed)) ;  $  TAB1 initialize random number generator with the value of seed ;  $  TAB0 unsigned integer function Time ;  $  TAB1 create new unsigned integer variable time = clock() /1000.00 ;  $  TAB1 return time ;  $  TAB0 create constant integer inf with value 1e9 + 123 ;  $  TAB0 assign value 1e5 + 123 to the new constant integer N ;  $  TAB0 s is a set of integers ;  $  TAB0 let d be a map from integers to integers ;  $  TAB0 a is a new array of integers with N elements ;  $  TAB0 Calc is a long long function with int argument x ;  $  TAB1 return (x squared - x) / 2 ;  $  TAB1 call Random() ;  $  TAB1 call Fast_Read_Out() ;  $  TAB1 declare integer n ;  $  TAB1 read from the input to n ;  $  TAB1 read n elements into a starting from the index 1 ;  $  TAB1 declare new long long variables ans and res = 0 ;  $  TAB1 for i from 2 to n inclusive ;  $  TAB2 if a[i] = a[i - 1] ;  $  TAB3 increment res ;  $  TAB3 change ans to the sum of ans and res ;  $  TAB2 else ;  $  TAB3 change the value of res to 0 ;  $  TAB1 print ans + n to the standard output ;
TAB1 n = integer ;  $  TAB1 s = string ;  $  TAB1 read n and s ;  $  TAB1 ans = string with value of "" ;  $  TAB1 i = integer ;  $  TAB1 flag = integer with value of 1 ;  $  TAB1 for i = 0 to n-1 exclusive ;  $  TAB2 if not flag break ;  $  TAB2 if s[i+1] is greater than or equal to s[i] ;  $  TAB3 increase ans by s[i] ;  $  TAB2 else ;  $  TAB3 set flag to 0 ;  $  TAB1 if not flag ;  $  TAB2 for i to n exclusive increase ans by s[i] ;  $  TAB1 print ans ;
TAB1 let n be a integer ;  $  TAB1 let s be a string ;  $  TAB1 let t, flag be integers with flag value as 0 ;  $  TAB1 read n , s ;  $  TAB1 for ( i = 0 to s.length() ) , increase i value by 1 ;  $  TAB2 if ( ith element in array s is greater than [i+1]th element of array s) ;  $  TAB3 flag value is equal to 1 ;  $  TAB3 t is equal to i ;  $  TAB3 stop ;  $  TAB1 if (flag is equal to 0) ;  $  TAB2 for (integer i = 0 to s.length() - 1) , print ith element in array s ;  $  TAB2 print endline ;  $  TAB1 else do the following ;  $  TAB2 for (integer i = 0 to s.length()) ;  $  TAB3 if (i is equal to t) , proceed to next ;  $  TAB3 print ith element of array s ;  $  TAB2 print newline ;
TAB0 integer function find with integer arguments x and father ;  $  TAB1 if father[x] = x return x ;  $  TAB1 return father[x] = find(father[x], father) ;  $  TAB1 declare integer called n ;  $  TAB1 read n ;  $  TAB1 declare string called s ;  $  TAB1 read s ;  $  TAB1 let pos be integer = 0 ;  $  TAB1 for integer i = 1 to n exclusive ;  $  TAB2 if s[i] is less than s[i - 1] ;  $  TAB3 set value of pos to i - 1 ;  $  TAB3 break the loop ;  $  TAB2 else ;  $  TAB3 set value of pos to i ;  $  TAB1 erase 1 character at pos from s ;  $  TAB1 print s and "\n" ;
TAB1 create integer n ;  $  TAB1 create string s ;  $  TAB1 read n read s ;  $  TAB1 create integer pos with pos = n - 1 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if s[i] is greater than s[i+1] ;  $  TAB3 set pos to i ;  $  TAB3 break loop ;  $  TAB1 print substring of s from 0 to pos + substring of s from pos + 1 print newline ;
TAB0 declare inline MAX2 with long long a, long long integer b as arguments, returning long long ;  $  TAB1 return a if a is greater than b, else b, from function ;  $  TAB0 declare inline MAX3 with long longs a, b, c as arguments, returning long long ;  $  TAB1 return (a) is greater than (b) ternary ((a) is greater than (c) ternary (a) : (c)) : ((b) is greater than (c) ternary (b) : (c)) from function ;  $  TAB0 declare inline MIN2 with long longs a, b as arguments, returning long long ;  $  TAB1 return a if a is greater than b, else b, from function ;  $  TAB0 declare inline MIN3 with long longs a, b, c as arguments, returning long long ;  $  TAB1 (a) is less than (b) ternary ((a) is less than (c) ternary (a) : (c)) : ((b) is less than (c) ternary (b) : (c)) ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create integers temp, result, with result = n - 1 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 set temp to integer casted s[i] - integer casted s[i-1] ;  $  TAB2 if temp is less than 0 ;  $  TAB3 set result to i - 1 ;  $  TAB3 break loop ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i is not result, print s[i] ;  $  TAB1 print newline ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create long long check = n - 1 ;  $  TAB1 for long long i = 0 to n - 1 exclusive ;  $  TAB2 if s[i] is greater than s[i + 1] ;  $  TAB3 assign value of i to check ;  $  TAB3 stop the loop ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if check != i, print s[i] ;  $  TAB1 print new line ;
TAB1 set stdout output decimal precision to 10 ;  $  TAB1 set stdout floatfield format flag to fixed ;  $  TAB1 declare long long variable n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 declare long long variable pos = n - 1 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if s[i] is less than s[i - 1], set pos to min of pos and i - 1 ;  $  TAB1 remove 1 character at position pos from s ;  $  TAB1 print s ;
TAB1 create integer t ;  $  TAB1 read t ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 if s[i] is greater than s[i+1] ;  $  TAB3 set s[i] to 1 ;  $  TAB3 break loop ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 if s[i] is greater than or equal to 'a' and s[i] is less than or equal to 'z', print s[i] ;  $  TAB1 print newline ;
TAB1 s = string ;  $  TAB1 f = bool set f = 1 ;  $  TAB1 n = integer ;  $  TAB1 read n , s ;  $  TAB1 for i = 0 to (n-1) exclusive ;  $  TAB2 if s[i] > s[i + 1] and f > 0 ;  $  TAB3 f = 0 ;  $  TAB2 else ;  $  TAB3 print s[i] ;  $  TAB1 if f = 0 print s[n - 1] ;  $  TAB1 print newline ;
TAB1 declare integer variable n ;  $  TAB1 declare string variable ss ;  $  TAB1 read n and ss ;  $  TAB1 declare integer variable in = -1 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if ss[i] is greater than ss[i + 1] ;  $  TAB3 assign value of i to in ;  $  TAB3 stop the loop ;  $  TAB1 decrement n if in = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i != in print ss[i] ;  $  TAB1 print new line ;
TAB1 n = integer ;  $  TAB1 let s be a string ;  $  TAB1 read n and s ;  $  TAB1 set pos to n - 1 ;  $  TAB1 for i = 0 to n - 1 exclusive incrementing by 1 at the start of each iteration ;  $  TAB2 if s[i] is greater than s[i+1] ;  $  TAB3 assign i to pos ;  $  TAB3 break ;  $  TAB1 print s.substr(0, pos) + s.substr(pos + 1) ;
TAB1 declare integer n ;  $  TAB1 declare string str ;  $  TAB1 read n and str ;  $  TAB1 for integer i = 0 to n exclusive ;  $  TAB2 if str[i] is greater than str[i + 1] ;  $  TAB3 remove 1 character from position i from str ;  $  TAB3 break the loop ;  $  TAB1 print str ;
TAB1 declare integer variable n ;  $  TAB1 create string en ;  $  TAB1 read n ;  $  TAB1 read en ;  $  TAB1 declare integer variables i and j ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if en[i] is greater than en[i + 1] ;  $  TAB3 print i elements of en ;  $  TAB3 for j = i + 1 to n exclusive print en[j] ;  $  TAB3 break the loop ;  $  TAB1 if i = n - 1 ;  $  TAB2 print i elements of en ;  $  TAB1 print new line ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create boolean p = 0 ;  $  TAB1 for integer i = 0 to n - 1 exclusive ;  $  TAB2 if s[i] is greater than s[i + 1] ;  $  TAB3 p = 1 ;  $  TAB3 break the loop ;  $  TAB1 if p is 0 ;  $  TAB2 for integer i = 0 to n - 1 exclusive ;  $  TAB2 print new line ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if s[i] is greater than s[i + 1] ;  $  TAB3 for integer j = i + 1 to n exclusive print s[j] ;  $  TAB3 print new line ;  $  TAB2 print s[i] ;
TAB0 declare string s ;  $  TAB0 declare integer n ;  $  TAB1 read s ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] is '1' ;  $  TAB3 for j = i to size of s exclusive ;  $  TAB4 if s[j] is '0', increment n ;  $  TAB3 if n is greater than or equal to 6 ;  $  TAB4 print "yes", newline ;  $  TAB3 else ;  $  TAB4 print "no", newline ;  $  TAB1 print "no", newline ;
TAB1 s = string array ;  $  TAB1 read s ;  $  TAB1 integer as c = 0,k = 0 ;  $  TAB1 ans = no = string array ;  $  TAB1 reverse the sequence of string s ;  $  TAB1 if s.length is less than 7 then do the following ;  $  TAB2 output ans ;  $  TAB1 else ;  $  TAB2 for i = 0 to less than s.length() do the following ;  $  TAB3 if s[i] is 0 then do the following ;  $  TAB4 add one to c ;  $  TAB4 if c is 6 then do the following ;  $  TAB5 set k to i ;  $  TAB5 break ;  $  TAB2 if k is not equal to 0 then do the following ;  $  TAB3 for j = k + 1 to less than s.length() do the following ;  $  TAB4 if s[j] is 1 then do the following ;  $  TAB5 set ans to yes ;  $  TAB5 break ;  $  TAB4 else ;  $  TAB5 continue ;  $  TAB2 output ans ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare string ans = "no" ;  $  TAB1 if size of s is less than 7 ;  $  TAB2 print ans and newline ;  $  TAB1 else ;  $  TAB2 declare integer k = 0 ;  $  TAB2 reverse sort from beginning of s to end of s ;  $  TAB2 declare integer count = 0, i = 0 ;  $  TAB2 while count is less than 6 and i is less than size of s ;  $  TAB3 if s[i] is '0' ;  $  TAB4 increment count ;  $  TAB4 let k be i ;  $  TAB3 increment i ;  $  TAB2 if k is not 0 and count is 6 ;  $  TAB3 for i = k + 1 to size of s exclusive ;  $  TAB4 if s[i] is '1' ;  $  TAB5 let ans be "yes' ;  $  TAB5 end loop ;  $  TAB4 else ;  $  TAB5 end current loop ;  $  TAB2 else ;  $  TAB3 let ans be "no" ;  $  TAB2 print ans and newline ;
TAB1 make char array a of size 101 ;  $  TAB1 read a ;  $  TAB1 make ints x = 0 and y = 0 ;  $  TAB1 for i = 0 while a[i] is not '\0' ;  $  TAB2 make integer flag = 0 ;  $  TAB2 if a[i] is equal to '1' ;  $  TAB3 for j = i + 1 while a[j] is not '\0' ;  $  TAB4 if a[j] is equal to '0', increment x ;  $  TAB4 if x is equal to 6, break loop ;  $  TAB3 set flag to 1 ;  $  TAB2 if flag is equal to 1, break loop ;  $  TAB1 is x is greater than or equal to 6 ;  $  TAB2 print "yes" ;  $  TAB1 else ;  $  TAB2 output "no" ;
TAB1 declare string s ;  $  TAB1 while read s is true ;  $  TAB2 while s[0] is '0', remove from 0 to 1 from s ;  $  TAB2 while bitwise not first index of "1" in s is true, remove from first index of "1" in s to 1 in s ;  $  TAB2 if size of s is greater than or equal to 6 ;  $  TAB3 print "yes" and newline ;  $  TAB2 else ;  $  TAB3 print "no" and newline ;
TAB1 create new string s ;  $  TAB1 read standard input to s ;  $  TAB1 define integer n ;  $  TAB1 in a for loop, change i from 0 to n exclusive incrementing i ;  $  TAB2 declare new integer called c = 0 ;  $  TAB2 if s[i] - '0' is true ;  $  TAB3 for integer j = i + 1 to n exclusive incrementing j ;  $  TAB4 if s[j] - '0' = 0, increment c by one ;  $  TAB3 if c >= 6 ;  $  TAB4 print "yes" ;  $  TAB1 print "no" to the standard output ;
TAB0 create character variable ;  $  TAB0 integer as n,b = 0 ;  $  TAB1 set a to getchar() ;  $  TAB1 if a is not equal to \n then do the following ;  $  TAB2 set (a = 1) and (b to 1) ;  $  TAB2 if b and a is 0 then do the following n++ ;  $  TAB2 set a to getchar() ;  $  TAB2 if n is greater than or equal to 6 then return write yes to stdout ;  $  TAB1 write no to stdout ;
TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 first_one=-1 ;  $  TAB1 for i=0 to length of s exclusive ;  $  TAB2 if s[i] is '1' ;  $  TAB3 first_one=i ;  $  TAB3 break ;  $  TAB1 if first_one is -1 ;  $  TAB2 print "no" ;  $  TAB1 total=0 ;  $  TAB1 for i=first_one+1 to length of s exclusive ;  $  TAB2 if s[i] is '0' increment total ;  $  TAB1 if total >= 6 ;  $  TAB2 print "yes" ;  $  TAB1 else ;  $  TAB2 print "no" ;
TAB1 create string s ;  $  TAB1 read from the input to s ;  $  TAB1 define new integers len = length of s, ipos and cnt = 0 ;  $  TAB1 start for loop from ipos = 0 to len exclusive ;  $  TAB2 if s[ipos] is equal to '1', stop the loop ;  $  TAB1 if ipos = len, return puts("no"), 0 ;  $  TAB1 increment ipos and start a loop, while ipos < len, incrementing ipos by 1 on each iteration ;  $  TAB2 increment cnt if s[ipos] = '0' ;  $  TAB1 print "yes" if nt >= 6 or "no" otherwise ;
TAB0 a, n = integers ;  $  TAB0 p = character ;  $  TAB1 while reading p ;  $  TAB2 if a is equal to 0 ;  $  TAB3 if p is equal to 1, then set a to 1 ;  $  TAB2 else do the following ;  $  TAB3 if p is equal to 0, then increment n ;  $  TAB1 if n is greater than or equal to 6 ;  $  TAB2 print yes and a new line ;  $  TAB1 else do the following ;  $  TAB2 print no and a new line ;
TAB1 p = string ;  $  TAB1 read p ;  $  TAB1 y = 0 = int ;  $  TAB1 while p[y] is '0' increment y ;  $  TAB1 rsp = 0 = int ;  $  TAB1 for i = y + 1 to size of p exclusive increment i after, increment rsp by (p[i] == '0') ;  $  TAB1 if rsp >= 6 ;  $  TAB2 print yes ;  $  TAB1 else ;  $  TAB2 print no ;
TAB1 make string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to s.length() exclusive ;  $  TAB2 if s[i] is equal to '1' ;  $  TAB3 make integer sum = 0 ;  $  TAB3 for j = i + 1 to s.length() exclusive ;  $  TAB4 if s[j] is equal to '0', increment sum ;  $  TAB3 if sum is greater than or equal to 6 ;  $  TAB4 print "yes" ;  $  TAB3 break loop ;  $  TAB1 show "no" ;
TAB0 integer as array dx = 0,0,-1,1 ;  $  TAB0 integer as array dy = 1,-1,0,0 ;  $  TAB1 s = string array ;  $  TAB1 read s ;  $  TAB1 integer as i0 = -1,i1 = -1,cnt = 0 ;  $  TAB1 for i = s.size() - 1 to greater than or equal to 0 do the following ;  $  TAB2 if s[i] is 0 then add one to cnt ;  $  TAB2 if cnt is 6 then do ;  $  TAB3 set i0 to i ;  $  TAB3 break ;  $  TAB1 for i = 0 to less than s.size do the following ;  $  TAB2 if s[i] is 1 then do the following ;  $  TAB3 set i1 to i ;  $  TAB3 break ;  $  TAB1 if i1 is -1 or i0 then do the following ;  $  TAB2 output no ;  $  TAB1 if i1 is greater than or equal to i0 then do the following ;  $  TAB2 output no ;  $  TAB1 output yes ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB1 print maximum value of 0 and 3 * n - k and a new line ;
TAB0 TOLL be a constant double 1e-9 ;  $  TAB0 memo is an integer array ;  $  TAB0 recur is an integer function ;  $  TAB1 if n, k both equal 0, return 0 ;  $  TAB1 if n equal 0, return 1000 ;  $  TAB1 if k equal 0, return 1000 ;  $  TAB1 if memo[n][k] not equal -1, return memo[n][k] ;  $  TAB1 rv is integer 1000 ;  $  TAB1 for integer i = 2 to 5 inclusive ;  $  TAB2 if i is less than or equal to k ;  $  TAB3 integer now equals recur(n - 1, k - i) ;  $  TAB3 if i equals 2, increase now by 1 ;  $  TAB3 rv = min(now, rv) ;  $  TAB1 return memo[n][k] equals rv ;  $  TAB1 memset(memo, -1, sizeof memo) ;  $  TAB1 n, k be integers ;  $  TAB1 while read n, k, print recur(n, k) and newline ;
TAB0 dpis long long array of 52 rows, 252 columns ;  $  TAB0 f is a function of long long integer ;  $  TAB1 if slot equals 0 ;  $  TAB2 if n equals 0 ;  $  TAB2 else ;  $  TAB3 return 1e10 ;  $  TAB1 if dp[slot][n] not equals -1, return dp[slot][n] ;  $  TAB1 ans is a long long value equal to 1e10 ;  $  TAB1 for integer i = 2 to 5 inclusive ;  $  TAB2 if i is 2 ;  $  TAB3 ans equals minimum of ans, 1 + f(slot - 1, n - i) ;  $  TAB2 else ;  $  TAB3 ans equals minimum of ans, f(slot - 1, n - i) ;  $  TAB1 return dp[slot][n] equals ans ;  $  TAB1 n, k are long long values ;  $  TAB1 read n, k ;  $  TAB1 memory set of dp, -1, sizeof(dp) ;  $  TAB1 print f(n, k) and newline ;
TAB1 n, k are integers ;  $  TAB1 read n, k ;  $  TAB1 if n * 3 is greater than or equal to k ;  $  TAB2 print 0 and endline ;  $  TAB1 else ;  $  TAB2 print 0 and endline ;
TAB1 n,k=int ;  $  TAB1 read n,k ;  $  TAB1 if 3*n-k > 0 ;  $  TAB2 print 3*n-k ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 n,k=int ;  $  TAB1 read n,k ;  $  TAB1 ex=vector of n int filled with 5 ;  $  TAB1 idx=n-1 ;  $  TAB1 while true ;  $  TAB2 sum=0 ;  $  TAB2 for i=0 to n exclusive add ex[i] to sum ;  $  TAB2 if sum is k break ;  $  TAB2 if idx is -1 idx=n-1 ;  $  TAB2 decrement ex[idx] ;  $  TAB2 decrement idx ;  $  TAB1 res=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if ex[i] is 2 increment res ;  $  TAB1 print res ;
TAB1 declare new ints n and k ;  $  TAB1 read input to n and k ;  $  TAB1 if k / n = 2 ;  $  TAB2 print n - k % n ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 n, a, coun = int ;  $  TAB1 read n, a ;  $  TAB1 if 3*n <= a ;  $  TAB2 set coun to 0 ;  $  TAB1 else ;  $  TAB2 set coun to 3 * n - a ;  $  TAB1 print coun ;
TAB1 let n, k, ans be integers ;  $  TAB1 while read n , k ;  $  TAB2 if k / n equals 2 ;  $  TAB3 ans is equal to k modulo n ;  $  TAB3 print n - ans and newline ;  $  TAB2 else do the following ;  $  TAB3 print 0 and newline ;
TAB1 n,k=int ;  $  TAB1 read n,k ;  $  TAB1 c=k/n ;  $  TAB1 if c>=3 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print n-k modulo n ;
TAB1 create integers a and b ;  $  TAB1 read a and b from the input ;  $  TAB1 create new integer called x with value 3*a ;  $  TAB1 if x <= b ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print x - b ;
TAB1 n, k = int ;  $  TAB1 read n the k ;  $  TAB1 ans = int with ans = -1 ;  $  TAB1 set ans to n ;  $  TAB1 set ans to ans * 3 ;  $  TAB1 decrement ans by k ;  $  TAB1 if ans >= 0 ;  $  TAB2 print ans ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB0 T = 1 = int ;  $  TAB0 in void function solve ;  $  TAB1 n, k = int ;  $  TAB1 read n, k ;  $  TAB1 is 0 > n - (k - (2 * n)) then print 0, else print n - (k - (2 * n)) ;  $  TAB1 while decrementing T, calls solve ;
TAB0 create const int N = 1e5 + 100 ;  $  TAB0 make ints n, k, and ans and int array a of size 55 ;  $  TAB0 create integer vector v ;  $  TAB0 make bool flag ;  $  TAB0 declare check returning bool ;  $  TAB1 make integer sum = 0 ;  $  TAB1 for i = 0 to n exclusive, add a[i] to sum ;  $  TAB1 if sum is equal to k, return true ;  $  TAB1 return false ;  $  TAB1 read n and k ;  $  TAB1 for i = 0 to n exclusive, set a[i] to 2 ;  $  TAB1 if check() returns true ;  $  TAB2 show n ;  $  TAB1 for i = 2 to 5 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 increment a[j] ;  $  TAB3 if check() is truthy ;  $  TAB4 set flag to true ;  $  TAB4 break loop ;  $  TAB2 if flag is truthy, break loop ;  $  TAB1 if flag is true ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a[i] is equal to 2, add 1 to ans ;  $  TAB1 display ans ;
TAB1 a,b=int ;  $  TAB1 read a,b ;  $  TAB1 x=3*a ;  $  TAB1 if x<=b ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print x-b ;
TAB1 n, k = int ;  $  TAB1 while reading n, k ;  $  TAB2 if k >= 3n ;  $  TAB3 print 0 ;  $  TAB2 else if k <= 2n ;  $  TAB3 print n ;  $  TAB2 else ;  $  TAB3 print n - k + k / n * n ;
TAB1 a, b are integers ;  $  TAB1 read a, b ;  $  TAB1 if b is greater than or equal to 3 * a ;  $  TAB2 print 0 and newline ;  $  TAB1 else ;  $  TAB2 print 3 * a - b and endline ;
TAB1 create int n and k ;  $  TAB1 read n and k ;  $  TAB2 if k >= 3 * n ;  $  TAB3 print 0 ;  $  TAB2 else if k <= 2 * n ;  $  TAB3 print n ;  $  TAB2 else ;  $  TAB3 print n - k + k / n * n ;
TAB1 k, n = int ;  $  TAB1 read n then k ;  $  TAB1 print max of 0, n - (k / 2 - n) * 2 - k mod 2 ;
TAB1 n, m, ans =integers with ans = 0 ;  $  TAB1 Read n and m ;  $  TAB1 set ans to m - 2 * n ;  $  TAB1 set ans to n - ans ;  $  TAB1 if ans is less than 0 ;  $  TAB2 print 0 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print ans and a new line ;
TAB0 maxn is a new constant integer variable = 1e5 + 7 ;  $  TAB0 counter is a integer function with int argument x ;  $  TAB1 create integer variable with name myAss = 0 ;  $  TAB1 while x ;  $  TAB2 change x to x >> 1 ;  $  TAB2 increment myAss ;  $  TAB1 return myAss ;  $  TAB1 declare integer variable n ;  $  TAB1 in a while loop, read n and print the result of counter(n) ;
TAB1 n=int,cnt=0 ;  $  TAB1 read n ;  $  TAB1 while n ;  $  TAB2 increment ct ;  $  TAB2 divide n by 2 ;  $  TAB1 print ct ;
TAB0 ans = integer with ans = 0 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 while ((left shift ans 1 place) - 1 < n), increment ans ;  $  TAB1 print ans ;
TAB1 n, ans =integers with ans = 0 ;  $  TAB1 Read n ;  $  TAB1 while n is greater than 0 ;  $  TAB2 set n to n / 2 ;  $  TAB2 increment ans ;  $  TAB1 print ans and a new line ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 print round upward log2(n+1) ;
TAB0 n, c = integer ;  $  TAB1 read n ;  $  TAB1 while n > 0 ;  $  TAB2 n = n / 2 ;  $  TAB2 increase c by 1 ;  $  TAB1 print c ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 50 exclusive ;  $  TAB2 shift n value to the right by 1 ;  $  TAB2 if n is equal to 0 ;  $  TAB3 print i and newline ;
TAB1 create int a ;  $  TAB1 read a ;  $  TAB1 let ans = 1 be an integer ;  $  TAB1 loop while a is not 1 ;  $  TAB2 increment ans ;  $  TAB2 set a to a shifted by one bit to the right ;  $  TAB1 print ans ;
TAB0 let v be a vector of long integers ;  $  TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 let sum be a long integer with sum = 1 ;  $  TAB1 push_back 1 into vector v ;  $  TAB1 while sum is less than n ;  $  TAB2 let cur be a long integer with v[ length of v - 1] << 1 ;  $  TAB2 push_back cur into v ;  $  TAB2 increment sum by cur ;  $  TAB1 print length of v and newline ;
TAB0 create long long n, num[1000000]; ;  $  TAB1 read n ;  $  TAB1 for i=0 to num[i - 1] <= 1e10, set num[i] = num[i - 1] + num[i - 1] + 1 ;  $  TAB1 for i=1 to num[i] <= 1e10 ;  $  TAB2 if num[i - 1] < n and num[i] >= n ;  $  TAB3 print i ;
TAB0 create long long ints n, i, and x ;  $  TAB1 read n and while n is truthy ;  $  TAB2 set i to 0 ;  $  TAB2 set x to n ;  $  TAB2 while x is not 0 ;  $  TAB3 if x modulo 2 is 0 ;  $  TAB4 set x to x / 2 ;  $  TAB3 otherwise ;  $  TAB4 set x to (x - 1) / 2 ;  $  TAB3 add 1 to i ;  $  TAB2 show i ;
TAB1 n, t, x =integers with t = 0 and x = 1 ;  $  TAB1 Read n ;  $  TAB1 while x is less than or equal to n ;  $  TAB2 set x to x * 2 ;  $  TAB2 increment t ;  $  TAB1 print t and a new line ;
TAB0 n, k and has are long longs where k = 1 ;  $  TAB1 read from the input to n ;  $  TAB1 while k - 1 < n ;  $  TAB2 set k to k multiplied by 2 ;  $  TAB2 increment has by one ;  $  TAB1 print has to the standard output ;
TAB1 declare new long long variable n ;  $  TAB1 read n from the user input ;  $  TAB1 print log2(n) casted to integer + 1 ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 print (cast to int)log2(n) + 1 ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 cont = integer with 0 ;  $  TAB1 while n is greater than 0 ;  $  TAB2 set n to n / 2 ;  $  TAB2 increment cont ;  $  TAB1 print cont and a new line ;
TAB0 declare new constant integer called INF = 0x3f3f3f3f ;  $  TAB0 create new constant double variable eps = 1e-7 ;  $  TAB0 new long long constant mod with value 1e9 + 7 ;  $  TAB0 function CountNum with long long argument n that returns long long ;  $  TAB1 declare new integer variable ans with value 0 ;  $  TAB1 while n ;  $  TAB2 increment ans by one ;  $  TAB2 change the value of n to n divided by 2 ;  $  TAB1 return ans ;  $  TAB1 n is a new long long variable ;  $  TAB1 read n from the input ;  $  TAB1 print the result of CountNum(n) ;
TAB1 n = integer ;  $  TAB1 while n can be read as a valid integer ;  $  TAB2 num = integer = 0 ;  $  TAB2 while n is nonzero ;  $  TAB3 increase num by 1 ;  $  TAB3 n = n shifted 1 bit to the right ;  $  TAB2 print num ;
TAB1 p =integer with 0 ;  $  TAB1 n, x = integers with x = 1 ;  $  TAB1 Read n ;  $  TAB1 while x is less than or equal to n ;  $  TAB2 set x to x * 2 ;  $  TAB2 increment p ;  $  TAB2 if x - 1 is greater than or equal to n ;  $  TAB3 print p and a new line ;
TAB0 in the function gcd that takes integer a, b and returns integer ;  $  TAB1 if (b is 0), return a ;  $  TAB1 return gcd(b, a modulo b) ;  $  TAB1 a = integer ;  $  TAB1 read a ;  $  TAB1 ans = integer with ans = 1 ;  $  TAB1 while a modulo 1 ;  $  TAB2 increment ans ;  $  TAB2 a = right shift a 1 place ;  $  TAB1 print ans ;
TAB0 create new long longs n and num ;  $  TAB1 read from the input to n ;  $  TAB1 declare long long sum with value 1 ;  $  TAB1 declare integer count = 0 ;  $  TAB1 while sum - 1 < n ;  $  TAB2 change the value of sum to sum multiplied by 2 ;  $  TAB2 increment count by one ;  $  TAB1 print count ;
TAB0 create long long int array a of size 100010, b of size 100010, and c of size 100010 ;  $  TAB0 make long long ints n, m, k, t, r, s, aux, and rta ;  $  TAB1 read n and while n is truthy ;  $  TAB2 set all contents of a to 0 ;  $  TAB2 create integer rta = 0 ;  $  TAB2 while n is truthy, set n to n / 2 and increment rta ;  $  TAB2 show rta ;
TAB1 declare integer variable with name n ;  $  TAB1 read input to n ;  $  TAB1 print logarithm of n to the base 2 rounded down + 1 and '\n' ;
TAB1 create string s ;  $  TAB1 read lien from cin to s ;  $  TAB1 create character x ;  $  TAB1 create integer len with len = size of s - 1 ;  $  TAB1 create integer flag with flag = 1 ;  $  TAB1 while flag is true ;  $  TAB2 create character temp with temp = s[len] ;  $  TAB2 if temp is greater than or equal to 'A' and temp is less than or equal to 'Z' ;  $  TAB3 set x to temp ;  $  TAB3 set flag to 0 ;  $  TAB2 else if temp is greater than or equal to 'a' and temp is less then or equal to 'z' ;  $  TAB3 set x to temp ;  $  TAB3 set flag to 0 ;  $  TAB2 decrement len ;  $  TAB1 set x to lower case of x ;  $  TAB1 if x is 'a' or x is 'e' or x is 'i' or x is 'o' or x is 'u' or x is 'y' ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 let s be string ;  $  TAB1 read line from input into s ;  $  TAB1 x = character ;  $  TAB1 let len be integer = length of s - 1 ;  $  TAB1 create integer flag with value 1 ;  $  TAB1 while flag is 1 ;  $  TAB2 create character temp with value s[len] ;  $  TAB2 if temp is a capital letter character ;  $  TAB3 x = temp ;  $  TAB3 set value of flag to 0 ;  $  TAB2 else if temp >= 'a' && temp <= 'z' ;  $  TAB3 set x to temp ;  $  TAB3 flag = 0 ;  $  TAB2 decrease len by one ;  $  TAB1 set value of x to lower case of x ;  $  TAB1 if x = 'a' or x = 'e' or x = 'i' or x = 'o' or x = 'u' or x = 'y' ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB0 array of characters vol filled with 'y', 'Y', 'o', 'O', 'i', 'I', 'a', 'A', 'e', 'E', 'u' and 'U' ;  $  TAB1 let s be string ;  $  TAB1 read input into s ;  $  TAB1 for i = length of s - 1 to -1 exclusive decrementing i ;  $  TAB2 if s[i] != '?' and s[i] != ' ' ;  $  TAB3 for integer j = 0 to 12 exclusive ;  $  TAB4 if s[i] = vol[j] return cout << "YES" << '\n', 0 ;  $  TAB3 return cout << "NO" << '\n', 0 ;
TAB1 create character array s with size 500 ;  $  TAB1 read s ;  $  TAB1 create character c ;  $  TAB1 create integer len with len = string length of s ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 create character cc with cc = lower case s[i] ;  $  TAB2 if cc is greater than or equal to 'a' and cc is less than or equal to 'z', set c to cc ;  $  TAB1 if c is 'a' or c is 'e' or c is 'i' or c is 'o' or c is 'u' or c is 'y' ;  $  TAB2 print "YES" print newline ;  $  TAB1 else ;  $  TAB2 print "NO" print newline ;
TAB1 s = array of characters of size 500 ;  $  TAB1 get input into s ;  $  TAB1 c = character ;  $  TAB1 set integer len to length of s ;  $  TAB1 for integer i = 0 to len exclusive ;  $  TAB2 create character cc = character at s[i] converted to lower case ;  $  TAB2 if cc >= 'a' and cc <= 'z' ;  $  TAB1 if c is a vowel character ;  $  TAB2 print "YES" and a new line ;  $  TAB1 else ;  $  TAB2 print "NO" and a new line ;
TAB0 create string vow with value "aeiouy" ;  $  TAB1 let x be string ;  $  TAB1 read line and store it into x ;  $  TAB1 set boolean ok to false ;  $  TAB1 for integer i = 0 to length of x exclusive ;  $  TAB2 if isalpha(x[i]) is true ;  $  TAB3 if lowercase x[i] can be found in vow ;  $  TAB4 set value of ok to true ;  $  TAB3 else ;  $  TAB4 set ok to false ;  $  TAB1 print "YES" if ok is true or "NO" otherwise, and a new line ;
TAB0 create string vow with vow = "aeiouy" ;  $  TAB1 create string x ;  $  TAB1 read line from cin to x ;  $  TAB1 create boolean ok with ok = false ;  $  TAB1 for i = 0 to length of x exclusive ;  $  TAB2 if x[i] is alphanumeric ;  $  TAB3 if first index of lower case x[i] in vow is not -1 ;  $  TAB4 set ok to true ;  $  TAB3 else ;  $  TAB4 set ok to false ;  $  TAB1 print "YES" if ok is true, else "NO", print newline ;
TAB0 char array vocals with elements 'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U' and 'Y' ;  $  TAB0 function contains with char argument vocal and boolean return type ;  $  TAB1 for integer i = 0 to 12 exclusive ;  $  TAB2 return true if vocals[i] = vocal ;  $  TAB1 return false ;  $  TAB1 question = string ;  $  TAB1 read input into question ;  $  TAB1 for i = length of question - 2 to 0 inclusive counting down ;  $  TAB2 if question[i] != ' ' ;  $  TAB3 if contains(question[i]) ;  $  TAB4 print "YES" and a new line ;  $  TAB3 else ;  $  TAB4 print "NO" and a new line ;
TAB0 boolean function a with UNTYPED arguments char and c ;  $  TAB1 set value of c to lower case c ;  $  TAB1 if c is a vowel character return 1 ;  $  TAB0 declare string variable s ;  $  TAB1 read input into s ;  $  TAB1 for integer i = length of s - 2 to 0 inclusive, decrementing i ;  $  TAB2 if s[i] != ' ' ;  $  TAB3 if a(s[i]) is true ;  $  TAB4 print "YES" and a new line ;  $  TAB3 else ;  $  TAB4 print "NO" and a new line ;
TAB0 declare a with character c as argument, returning boolean ;  $  TAB1 set c to lower case c ;  $  TAB1 if c is 'a' or c is 'e' or c is 'i' or c is 'o' or c is 'u' or c is 'y', return 1 from function ;  $  TAB0 create string s ;  $  TAB1 read line from cin to s ;  $  TAB1 for i = size of s - 2 to 0 inclusive, decrementing i ;  $  TAB2 if s[i] is not ' ' ;  $  TAB3 if result of run a with s[i] as argument is true ;  $  TAB4 print "YES" print newline ;  $  TAB3 else ;  $  TAB4 print "NO" print newline ;
TAB0 let MOD be a constant long integer with MOD = 1e9 + 7 ;  $  TAB0 let INF be a constant long integer with INF = 1e9 + 7 ;  $  TAB0 let isVowel be a function that accepts character a and returns a boolean value ;  $  TAB1 if a is equal to a , return true ;  $  TAB1 if a is equal to i , return true ;  $  TAB1 if a is equal to u , return true ;  $  TAB1 if a is equal to e , return true ;  $  TAB1 if a is equal to o , return true ;  $  TAB1 if a is equal to y , return true ;  $  TAB1 return false ;  $  TAB1 let s be a string ;  $  TAB1 getline(cin, s) ;  $  TAB1 let ans be a character ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 s[i] is equal to tolower(s[i]) ;  $  TAB2 if isalpha(s[i])) , ans is equal to s[i] ;  $  TAB1 if isVowel(ans) ;  $  TAB2 print YES and newline ;  $  TAB1 else do the following ;  $  TAB2 print NO and newline ;
TAB0 declare string variable s ;  $  TAB0 inline bool function yy with char argument x ;  $  TAB1 return 1 if x is one of 'a', 'e', 'i', 'o', 'u' or 'y' ;  $  TAB1 new register int i ;  $  TAB1 read data from the input and put it into s ;  $  TAB1 change i from the length of s - 1, while isalpha(s[i]) returns false, decrementing i ;  $  TAB1 set s[i] to the lower case ;  $  TAB1 if yy(s[i]) is true ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" to stdout ;
TAB0 M = const integer with M = 105 ;  $  TAB1 s = string ;  $  TAB1 read line s ;  $  TAB1 c = character with c = s[0] ;  $  TAB1 for i = 0 to s.length() exclusive ;  $  TAB2 if ((s[i] >= a and s[i] <= z) or (s[i] >= A and s[i] <= Z)), c = s[i] ;  $  TAB1 le = character array of size 12 with le = {'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'} ;  $  TAB1 ok = bool with ok = false ;  $  TAB1 for i = 0 to 11 ;  $  TAB2 if (c is le[i]) ;  $  TAB3 ok = true ;  $  TAB3 break loop ;  $  TAB1 if (ok) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create int n, a, b ;  $  TAB1 read n, a, b ;  $  TAB1 print min of n -a and b+1 ;
TAB1 let n, a, b be integers ;  $  TAB1 read n, a, b ;  $  TAB1 print minimum of b + 1, n - a and newline ;
TAB1 n, a, b =integers ;  $  TAB1 Read n, a, b ;  $  TAB1 print n - maximum value of (a + 1) and (n - b) + 1 and a new line ;
TAB1 create new ints a, b and n ;  $  TAB1 loop, reading n, a and b from the input ;  $  TAB2 if a + b is greater than n ;  $  TAB3 print n - a to the output ;  $  TAB2 else ;  $  TAB3 print b + 1 if n - (a + b), else print b ;
TAB1 n, a, b and c are integers where c = 0 ;  $  TAB1 read user input to n, a and b ;  $  TAB1 for i from a to n - 1 inclusive ;  $  TAB2 if n - i >= 1 and n - i - 1 <= b, increment c by one ;  $  TAB1 print c ;
TAB1 n, a, b, ans =integers ;  $  TAB1 Read n, a, b, ans ;  $  TAB1 print n - maximum value of (a + 1) and (n - b) + 1 and a new line ;
TAB1 make ints n, a, and b ;  $  TAB1 read n, a, and b ;  $  TAB1 make integer count = 0 ;  $  TAB1 for i = 1 to n ;  $  TAB2 if a is less than or equal to (i - 1) and (n - i) is less than or equal to b, increment count ;  $  TAB1 print count ;
TAB1 create int n, i, j, x, y, z ;  $  TAB1 read n, x and y ;  $  TAB1 set z to x+y ;  $  TAB1 if n-x=1 and n differenf from z ;  $  TAB2 print 1 ;  $  TAB1 else if n>z ;  $  TAB2 print y+1 ;  $  TAB1 else if z>n and n-x>1 ;  $  TAB2 print n-x ;  $  TAB1 else if n equal to z ;  $  TAB2 print y ;
TAB1 let n, a, b be integers ;  $  TAB1 read n, a, b ;  $  TAB1 let i , c be integers with i = a + 1, c = 0 ;  $  TAB1 while b >= 0 and i <= n ;  $  TAB2 increment c by 1 ;  $  TAB2 increment i by 1 ;  $  TAB2 decrement b by 1 ;  $  TAB1 print c and newline ;
TAB1 n, a, b =integers ;  $  TAB1 Read n, a, b ;  $  TAB1 set x to n - b ;  $  TAB1 set y to a + 1 ;  $  TAB1 set sum to n - maximum value of x and y + 1 ;  $  TAB1 print sum and a new line ;
TAB0 declare new int variables n, a and b ;  $  TAB1 read variables n, a and b from the input ;  $  TAB1 print min of n - a and b + 1 ;
TAB1 declare integers n, a, b, X = 0 ;  $  TAB1 read n and a and b ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i - 1 is greater than or equal to a and n - i is less than or equal to b, increment X ;  $  TAB1 print X and newline ;
TAB0 n,a,b=int ;  $  TAB1 read n,a,b ;  $  TAB1 print min(n-a, b+1) ;
TAB0 n, a, b = integer ;  $  TAB1 count = integer = 0 ;  $  TAB1 read n, a, b ;  $  TAB1 if a + b + 1 < n, then ans a = n - b -1 ;  $  TAB1 count = n - a ;  $  TAB1 print count ;
TAB1 create int n, a and b ;  $  TAB1 read n, a and b ;  $  TAB1 if a + b >= n ;  $  TAB2 print n-a ;  $  TAB1 else ;  $  TAB2 print b+1 ;
TAB0 n, a, b = integers ;  $  TAB1 Read n, a, b ;  $  TAB1 print minimum value of n - a and b + 1 and a new line ;
TAB1 declare integers n, a, b, i = 0, c = 0 ;  $  TAB1 read n, a, b ;  $  TAB1 let i be n - a ;  $  TAB1 let c be b + 11 ;  $  TAB1 if i is less than or equal to c ;  $  TAB2 print i and newline ;  $  TAB1 else ;  $  TAB2 print c and newline ;
TAB1 declare new int variables a, b and n ;  $  TAB1 read n, a and b and loop, then print b + 1 if n - a > b, or n -a otherwise, then loop again ;
TAB1 n, a, b =integers ;  $  TAB1 Read n, a, b ;  $  TAB1 print minimum value of b + 1 and n - a and a new line ;
TAB1 n, a, b =integers ;  $  TAB1 Read n, a, b ;  $  TAB1 print minimum value of n - a and b + 1 and a new line ;
TAB0 n,l,r,i=int ;  $  TAB1 read n,l,r ;  $  TAB1 print n-max(l,n-r-1) ;
TAB1 declare new int variables n, a and b ;  $  TAB1 read from the input to n, a and b ;  $  TAB1 declare integer variable called x = min of n - a and b + 1 ;  $  TAB1 print x ;
TAB0 create integers n, a and b ;  $  TAB1 read n, a and b ;  $  TAB1 print min of n - a and b + 1 to the standard output ;
TAB1 declare integers a, b, c ;  $  TAB1 read a, b, c ;  $  TAB1 if a - b is greater than c + 1 ;  $  TAB2 print c + 1 and newline ;  $  TAB1 else ;  $  TAB2 print a - b and newline ;
TAB0 declare res as integer ;  $  TAB1 declare n, a, b as integer ;  $  TAB1 read n and a and b ;  $  TAB1 let res be maximum of ( a + 1 and n - b ) ;  $  TAB1 print n - res + 1 and newline ;
TAB1 declare integers n, a, b ;  $  TAB1 read n and a and b ;  $  TAB1 declare long long c = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if ( i is greater than a ) and ( n - i ) is less than or equal to b, increment c ;  $  TAB1 print c and "\n" ;
TAB1 n,a,b=int, d and c=0 ;  $  TAB1 read n,a,b ;  $  TAB1 d=n-a ;  $  TAB1 c=b+1 ;  $  TAB1 if d<=c ;  $  TAB2 print d ;  $  TAB1 else ;  $  TAB2 print c ;
TAB1 n,a,b=int ;  $  TAB1 read n,a,b ;  $  TAB1 k=n-a ;  $  TAB1 print min(k, b+1) ;
TAB1 n,a,b=int ;  $  TAB1 while read n,a,b ;  $  TAB2 cnt=0 ;  $  TAB2 subtract a from n ;  $  TAB2 if n<=b+1 ;  $  TAB3 print n ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 print b+1 ;
TAB1 let a, b, c long long ints ;  $  TAB1 read a, b, and c ;  $  TAB1 let k, g long long ints with k = 0, g = b + 1 ;  $  TAB1 while g at most a ;  $  TAB2 if a - g at most c, increment k ;  $  TAB2 increment g ;  $  TAB1 print k ;
TAB0 maxx = constant integer = 1e3 + 10 ;  $  TAB0 a = integer array of size maxx ;  $  TAB0 n = integer ;  $  TAB1 while n is read with a valid integer ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 sort a in ascending order ;  $  TAB2 sum = long long = 0 ;  $  TAB2 for i = 1 to n exclusive, then sum = sum + (a[i] - a[i - 1] - 1) ;  $  TAB2 print sum ;
TAB1 create ints n, x, max = 0, and min = INT_MAX ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if x is greater than or equal to max, set max to x ;  $  TAB2 if min is greater than x, set min to x ;  $  TAB1 print max - min + 1 - n ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = int array of size n ;  $  TAB1 read n values into a ;  $  TAB1 sort a ;  $  TAB1 print a[n - 1] - a[0] + 1 - n ;
TAB1 n, result =integers and a = array of 1000 integers ;  $  TAB1 Read n ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 set result to a[n - 1] - a[0] - n + 1 ;  $  TAB1 print result and a new line ;
TAB1 n, i, j, l, r =integers with l = 1000000000000000 and r = 0 ;  $  TAB1 Read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read j ;  $  TAB2 set l to minimum value of l and j ;  $  TAB2 set r to minimum value of r and j ;  $  TAB1 print (r - l + 1) - n and a new line ;
TAB0 let inf = 0x3f3f3f3f = const int ;  $  TAB0 N = 1010 = int const ;  $  TAB0 let a be a long long array of length N ;  $  TAB1 m = int ;  $  TAB1 read m ;  $  TAB1 read the first m elements of a ;  $  TAB1 sort the first m elements of a ;  $  TAB1 ans = 0 = long long ;  $  TAB1 for i = 1 to m exclusive then increment ans by a[i]+a[i-1]-1 ;  $  TAB1 print ans ;
TAB1 let n and res be ints with res = 0 ;  $  TAB1 read input to n ;  $  TAB1 declare new array of long longs arr with n elements ;  $  TAB1 read standard input to arr n times ;  $  TAB1 sort arr ;  $  TAB1 for integer i = 1 to n exclusive ;  $  TAB2 if arr[i] != arr[i - 1] + 1, change res to the sum of res and arr[i] - arr[i - 1] - 1 ;  $  TAB1 print res and "\n" ;
TAB1 create long long int arra[1100] ;  $  TAB1 create long long int i, j, k, l, p, q, r, s, t, u, v, w, n, max_i, set max_i to 0 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive, read arra[i] ;  $  TAB1 sort elements between arra and arra + n + 1 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if arra[i] >= max_i, set max_i = arra[i] ;  $  TAB1 if n equal to 1 ;  $  TAB2 print 0 and a new line ;  $  TAB1 else ;  $  TAB2 set l to max_i - arra[1] + 1 - n ;  $  TAB2 print l and a newline ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 mi, mx = int with mi = 1 bitshift left by 30 and mx = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 x = int ;  $  TAB2 read x ;  $  TAB2 set mi to min of x, mi ;  $  TAB2 set mx to max of x, mx ;  $  TAB1 print mx - mi + 1 - n ;
TAB0 set maxn to 1000010 ;  $  TAB0 assign 500000 to MAXM ;  $  TAB1 create int n ;  $  TAB1 while read n ;  $  TAB2 create int a[1005] ;  $  TAB2 for i=0 to n exclusive, read a[i] ;  $  TAB2 sort elements between a and a + n ;  $  TAB2 cnt =0 ;  $  TAB2 for i=1 to n exclusive ;  $  TAB3 if a[i] - a[i - 1] > 1, cnt = cnt + (a[i] - a[i - 1]) - 1 ;  $  TAB2 print cnt ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 mx = integer with 0 ;  $  TAB1 mn = integer with 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 t = integer ;  $  TAB2 Read t ;  $  TAB2 set mx to maximum value of mx and t ;  $  TAB2 set mn to minimum value of mx and t ;  $  TAB1 print mx - mn + 1 - n and a new line ;
TAB0 a = array of 1010 integers ;  $  TAB1 n=integer ;  $  TAB1 Read n ;  $  TAB1 Read n values into array a ;  $  TAB1 sort array elements of a in ascending order ;  $  TAB1 print a[n - 1] - a[0] - n + 1 and a new line ;
TAB1 create n and res = 0 ;  $  TAB1 read n ;  $  TAB1 make long long integer arr of size n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 sort arr using argument arr + n ;  $  TAB1 for i = 1 to exclusive ;  $  TAB2 if arr[i] is not equal to arr[i - 1] + 1, set res to res + arr[i] - arr[i - 1] - 1 ;  $  TAB1 print res ;
TAB0 maxn = const integer with maxn = 1e6 ;  $  TAB0 n, a, res = long long with a = array of size maxn ;  $  TAB1 read n ;  $  TAB1 for i = cast to int(0) to cast to int(n), read a[i] ;  $  TAB1 sort a and a + n ;  $  TAB1 res = a[n - 1] - a[0] - n + 1 ;  $  TAB1 print res ;
TAB1 create new integer variable n ;  $  TAB1 read n and loop further ;  $  TAB2 a is a new array of integers with size 1005 ;  $  TAB2 read n elements into a ;  $  TAB2 sort a ;  $  TAB2 cnt is a new integer variable = 0 ;  $  TAB2 for i from 1 to n exclusive ;  $  TAB3 if a[i] - a[i - 1] is greater than 1, change cnt to cnt + (a[i] - a[i - 1]) - 1 ;  $  TAB2 print cnt ;
TAB1 declare long long variable with name n ;  $  TAB1 read standard input to n ;  $  TAB1 a is a new array of long longs with n elements ;  $  TAB1 read n elements into a ;  $  TAB1 sort a ;  $  TAB1 declare new long long variable ans with value 0 ;  $  TAB1 start for loop from i = 0 to n - 1 exclusive ;  $  TAB2 if a[i + 1] - a[i] is greater than 1, assign the new value = ans + ((a[i + 1] - a[i]) - 1) to ans ;  $  TAB1 print ans ;
TAB0 create constant integer inf = 0x3f3f3f3f ;  $  TAB0 make const int N = 1010 ;  $  TAB0 make long long array a of size N ;  $  TAB1 make int m ;  $  TAB1 read m ;  $  TAB1 for i = 0 to m exclusive, read a[i] ;  $  TAB1 sort a using argument a + m ;  $  TAB1 create long long int ans = 0 ;  $  TAB1 for i = 1 to m exclusive, add a[i] - a[i - 1] - 1 to ans ;  $  TAB1 print ans ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create long long ar[n + 1] ;  $  TAB1 i=0 to n exclusive, read ar[i] ;  $  TAB1 sort elements between ar and ar+n ;  $  TAB1 count =0 ;  $  TAB1 set temp to n-2 ;  $  TAB1 count = (ar[n - 1] - ar[0] - 1) - temp ;  $  TAB1 print (count) and a newline ;
TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 create long long array a of size 100001 ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort a using a + n ;  $  TAB1 print a[n -1] - a[0] + 1 - n ;
TAB0 inf = constant integer = 0x3f3f3f3f ;  $  TAB0 N = constant integer = 1010 ;  $  TAB0 a = long long array of size N ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, then read a[i] ;  $  TAB1 sort a in ascending order ;  $  TAB1 ans = long long = 0 ;  $  TAB1 for i = 1 to n exclusive, then ans = ans + a[i] - a[i - 1] - 1 ;  $  TAB1 print ans ;
TAB0 declare long long variables i, j, k, n, t, m, x, z and ans and an array a with size 200007 ;  $  TAB1 read n from the input ;  $  TAB1 read n elements into a from the input ;  $  TAB1 sort a ;  $  TAB1 in a loop, change i from 1 to n exclusive, increasing ans by a[i] - a[i - 1] - 1 on each loop ;  $  TAB1 print ans ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n % 2 is 0 ;  $  TAB2 print "0\n" ;  $  TAB1 else ;  $  TAB2 print "1\n" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if even ;  $  TAB2 print 0 ;  $  TAB1 if not even ;  $  TAB2 print 1 ;
TAB1 i,j,m,n,x,y,k=int ;  $  TAB1 read n ;  $  TAB1 print n modulo 2 ;
TAB1 create integer n ;  $  TAB1 read from the input to n ;  $  TAB1 print 1 if n & 1 = 1, or 0, and '\n' ;
TAB1 a = int ;  $  TAB1 read a ;  $  TAB1 if a is even ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 print n % 2 and '\n' ;
TAB0 declare constant integer maxn = 5001 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 print n % 2 and newline ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 print remainder of n % 2 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 print remainder of n / 2 ;
TAB1 create integer variable a ;  $  TAB1 read standard input to a ;  $  TAB1 if a is odd ;  $  TAB2 print "1" ;  $  TAB1 else ;  $  TAB2 print "0" to the standard output ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n % 2 is 0 ;  $  TAB2 print "0" and newline ;  $  TAB1 else ;  $  TAB2 print "1" and newline ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n % 2 == 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 a = int ;  $  TAB1 read a ;  $  TAB1 if a is even ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 a = int ;  $  TAB1 read a ;  $  TAB1 print remainder of a / 2 ;
TAB0 INF = const int with INF = 0x3f3f3f3f ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print "1" ;
TAB1 let a = int ;  $  TAB1 read a ;  $  TAB1 if remainder of a / 2 equals 1 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 create integer x ;  $  TAB1 read x ;  $  TAB1 print x % 2 ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n & 1 is truthy ;  $  TAB2 print 1 ;  $  TAB1 else do ;  $  TAB2 show 0 ;
TAB1 a = int ;  $  TAB1 read a ;  $  TAB1 if a % 2 ;  $  TAB2 print 1 and new line ;  $  TAB1 else ;  $  TAB2 print 0 and new line ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 print n and 1 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 equals 0 ;  $  TAB2 print 0 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 1 and newline ;
TAB1 n is a new integer variable ;  $  TAB1 read variable n from the input ;  $  TAB1 print n & 1 ;
TAB1 create new integer variable n ;  $  TAB1 read n from the user input ;  $  TAB1 print n % 2 ;
TAB1 let num be an integer ;  $  TAB1 read in num ;  $  TAB1 if num is even ;  $  TAB2 print 0 ;  $  TAB1 or else ;  $  TAB2 print 1 ;
TAB1 new integer n ;  $  TAB1 read from the input to n ;  $  TAB1 if n & 1 != 0 ;  $  TAB2 print "1" ;  $  TAB1 else ;  $  TAB2 print "0" ;
TAB0 declare integer n ;  $  TAB1 read n ;  $  TAB1 print n % 2 and newline ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is equal to 0 ;  $  TAB2 print 1 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 0 and newline ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 print n modulo 2 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if even ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare integer a ;  $  TAB1 read a ;  $  TAB1 print a % 2, "\n" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n bitwise and 1 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 x = int ;  $  TAB1 read x ;  $  TAB1 print remainder of x / 2 ;
TAB1 create int in ;  $  TAB1 read in ;  $  TAB1 print in % 2 ;
TAB0 a = int ;  $  TAB1 read a ;  $  TAB1 print remainder of a / 2 ;
TAB1 declare long longs a, b, c ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read c ;  $  TAB1 print 2 * c * (a + b - 2) - 8 * (c * (c - 1)) and newline ;
TAB1 declare integers w, h, k ;  $  TAB1 read w, h, k ;  $  TAB1 print 2 * k * (w + h - 2) - 8 * (k * (k - 1)) and newline ;
TAB0 let can be a function that accepts integers i , j , k and returns a boolean value ;  $  TAB1 if i + j is greater than k and j + k is greater than i and i + k is greater than j , return true ;  $  TAB1 return false ;  $  TAB1 let w, h, k be integers ;  $  TAB1 read w, h, k ;  $  TAB1 let ans be a integer with ans = 0 ;  $  TAB1 while w is greater than 0 and h is greater than 0 and k is greater than 0 ;  $  TAB2 increment ans by 2 * (w + h) - 4 ;  $  TAB2 decrement w by 4 ;  $  TAB2 decrement h by 4 ;  $  TAB2 decrement k by 1 ;  $  TAB1 print ans and newline ;
TAB1 create ints w, h, and k ;  $  TAB1 read w, h, and k ;  $  TAB1 show the result of 2 * k * (w + h - 2) - 8 * (k * (k - 1)) ;
TAB0 let n, m, k be long long ints ;  $  TAB0 let ans be a long long int with value 0 ;  $  TAB1 read n and m and k ;  $  TAB1 for longlong int i=0 to k ;  $  TAB2 let len be a long long int with value n-(i*2)*2 ;  $  TAB2 let win be a long long int with value m-(i*2)*2 ;  $  TAB2 set ans to ans+ ((len+wid)*2-4) ;  $  TAB1 print ans and newline ;
TAB1 make ints w, h, i, and r = 0 ;  $  TAB1 read w, h, and i ;  $  TAB1 while i is greater than or equal to 1 ;  $  TAB2 set r to r + (w + h - 2) * 2 ;  $  TAB2 set w to (w - 4) ;  $  TAB2 set h to (h - 4) ;  $  TAB2 subtract 1 from i ;  $  TAB1 print r ;
TAB1 let x, y, z, and t ints with t = 0 ;  $  TAB1 read x, y, and z ;  $  TAB1 for i from 0 to z exclusive ;  $  TAB2 set t to t + 2 * x + 2 * y - 4 ;  $  TAB2 subtract 4 from x ;  $  TAB2 subtract 4 from y ;  $  TAB1 print t ;
TAB0 i, b, a, t, k, l, ans = long long ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read k ;  $  TAB1 for i = 1 to k inclusive ;  $  TAB2 set ans to ans + (a + b) * 2 - 4 ;  $  TAB2 decrement a by 4 ;  $  TAB2 decrement b by 4 ;  $  TAB1 print ans ;
TAB1 create ints w, h, and k ;  $  TAB1 read w, h, and k ;  $  TAB1 make int cnt = 0 ;  $  TAB1 for i = 1 to k ;  $  TAB2 create int size = (w - 4 * (i - 1)) * (h - 4 * (i - 1)) ;  $  TAB2 if size is less than or equal to 0 ;  $  TAB3 break loop ;  $  TAB2 else do ;  $  TAB3 set cnt to cnt + (w - 4 * (i - 1)) * 2 + (h - 4 * (i - 1) - 2) * 2 ;  $  TAB1 display cnt ;
TAB0 create ints w, h, and k ;  $  TAB1 make int ans = 0 ;  $  TAB1 read w, h, and k ;  $  TAB1 for i = 1 to k ;  $  TAB2 create int _w = w - (i - 1) * 4 ;  $  TAB2 let integer _h = h - (i - 1) * 4 ;  $  TAB2 set ans to ans + 2 * (_w + _h) - 4 ;  $  TAB1 display ans ;
TAB1 w,h,k=int, res and i=0 ;  $  TAB1 read w,h,k ;  $  TAB1 while decremented value of k is not 0 ;  $  TAB2 add 2*(w-(4*i)+h-(4*i))-4 to res ;  $  TAB2 increment i ;  $  TAB1 print res ;
TAB1 create ints w, h, k and counter_yello = 0 ;  $  TAB1 read standard input to w, h and k ;  $  TAB1 for i from 0 to k exclusive incrementing i ;  $  TAB2 change counter_yello to counter_yello + 2 * w + 2 * h - 4 ;  $  TAB2 change w to w - 4 ;  $  TAB2 change h to h - 4 ;  $  TAB1 print counter_yello to the standard output ;
TAB1 create long long integers a, b, c, r = 0 ;  $  TAB1 read a, b and c ;  $  TAB1 for c iterations set r to r + ((((a - (4 * i)) - 1) + ((b - (4 * i)) - 1)) * 2) ;  $  TAB1 print r ;
TAB1 let w, h, k, count be integers with count = 0 ;  $  TAB1 read w, h, k ;  $  TAB1 while k is decremented by 1 ;  $  TAB2 increment count by 2 * (w + h) - 4 ;  $  TAB2 decrement w by 4 ;  $  TAB2 decrement h by 4 ;  $  TAB1 print count and newline ;
TAB0 create long long ints w, h, and k ;  $  TAB1 read w, h, and k ;  $  TAB1 make long long int _rs = 0 ;  $  TAB1 while k-- is truthy ;  $  TAB2 set _rs to _rs + 2 * (w + h) - 4 ;  $  TAB2 set w to w - 4 ;  $  TAB2 set h to h - 4 ;  $  TAB1 print _rs ;
TAB1 declare new integer variables w, h and k = 0 ;  $  TAB1 read w, h and k from the input ;  $  TAB1 create new integer called cells = 0 ;  $  TAB1 while k != 0, decrement it and continue the loop ;  $  TAB2 set cells to cells + ((2 * (w + h)) - 4) ;  $  TAB2 subtract 4 from w ;  $  TAB2 decrease h by 4 ;  $  TAB1 print cells and "\n" ;
TAB0 declare new constant integer called maxn = 1e3 + 5 ;  $  TAB0 declare new int variables w, h and k ;  $  TAB1 read input to w, h and k ;  $  TAB1 create integer variable total = 0 ;  $  TAB1 declare integer variable sum with value 0 ;  $  TAB1 change the value of sum to (w + h - 2) * 2 ;  $  TAB1 in a for loop, change i from 1 to k inclusive ;  $  TAB2 a is a new integer with value sum - 16 * (i - 1) ;  $  TAB2 assign total + a to total ;  $  TAB1 print total ;
TAB1 make ints w, h, and k ;  $  TAB1 read w, h, k and while they're truthy ;  $  TAB2 make integer sum = 0 ;  $  TAB2 for i = 0 to k exclusive ;  $  TAB3 add 2 * (w + h) - 4 to sum ;  $  TAB3 substract 4 from w ;  $  TAB3 set h to h - 4 ;  $  TAB2 print sum ;
TAB1 create integers w, h, k, and value = 0 ;  $  TAB1 read w, h, and k ;  $  TAB1 create integers deck = 0 and it = 2 ;  $  TAB1 for i = 1 to k ;  $  TAB2 set value to (((h - deck) * 2) + ((w - it) * 2)) + value ;  $  TAB2 set deck to deck + 4 ;  $  TAB2 set it to it + 4 ;  $  TAB1 show value ;
TAB1 let w, h, k, sum be integers with sum = 0 ;  $  TAB1 read w, h, k ;  $  TAB1 for q = 0 to k exclusive ;  $  TAB2 increment sum by (2 * w) + (2 * h) - 4 ;  $  TAB2 decrement w by 4 ;  $  TAB2 decrement h by 4 ;  $  TAB2 if w <= 1 or h <= 1 , stop ;  $  TAB1 print sum and new line ;
TAB1 let h, w, k be long integers ;  $  TAB1 read h, w, k ;  $  TAB1 let g be a long integer with g = 0 ;  $  TAB1 while k is greater than 0 ;  $  TAB2 increment g by h * 2 + (w - 2) * 2 ;  $  TAB2 decrement k by 1 ;  $  TAB2 decrement h by 4 ;  $  TAB2 decrement w by 4 ;  $  TAB2 if h <= 0 , stop ;  $  TAB2 if w <= 0 , stop ;  $  TAB1 print g and newline ;
TAB1 create int n, a, count, set count to 0 ;  $  TAB1 read n and a ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if a mod i =0 and (a / i) <= n, increment count ;  $  TAB1 print count ;
TAB1 let n and z be long long variables ;  $  TAB1 get value of n and x ;  $  TAB1 let c be integer = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if x modulo i is zero and x less than or equal to n * i then increment c ;  $  TAB1 print c ;
TAB1 n = long long ;  $  TAB1 x = long long ;  $  TAB1 read n, x ;  $  TAB1 cnt = 0 = int ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if x mod i = 0 and x <= i *n then increment cnt ;  $  TAB1 print cnt ;
TAB1 let n, x and r be ints where r = 0 ;  $  TAB1 read from the input to n and x ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 skip the rest of the loop if x % i is not 0 ;  $  TAB2 create integer variable y with value x / i ;  $  TAB2 if y <= n, increment r by one ;  $  TAB1 print r ;
TAB1 let n, x and count = 0 be integers ;  $  TAB1 read n and x ;  $  TAB1 if x equal to 1 ;  $  TAB2 print 1 ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if x modulo i is equal to 0 and x/i less then or equal to n then increment count ;  $  TAB1 if x less than or equal to n print count +1 or print count ;
TAB1 let n, m be integers ;  $  TAB1 while read n , m ;  $  TAB2 the integer value of flag = 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 the integer value of k = m / i ;  $  TAB3 if m modulo i is equal to 0 and k <= n , increment flag by 1 ;  $  TAB2 print flag and newline ;
TAB1 let a, b, c be integers with c = 0 ;  $  TAB1 read a , b ;  $  TAB1 if a is equal to 1 and b is equal to 1 ;  $  TAB2 print 1 and newline ;  $  TAB1 if a is equal to 1 and b is equal to 0 ;  $  TAB2 print 0 and newline ;  $  TAB1 for i = 1 to a inclusive ;  $  TAB2 if b modulo i is equal to 0 and b / i <= a ;  $  TAB1 print c and newline ;
TAB1 let tabeSize, num, i and cnt be long long ints with cnt = 0 ;  $  TAB1 read input to tabeSize and num ;  $  TAB1 start for loop from i = 1 to tabeSize inclusive incrementing i ;  $  TAB2 increment cnt if num % i = 0 and num / i <= tabeSize ;  $  TAB1 print cnt ;
TAB1 n, x, cnt = 0 be ints ;  $  TAB1 read n, x ;  $  TAB1 for i =1, until i^2 <= x ;  $  TAB2 if x mod i = 0 ;  $  TAB3 if i = x / i and i <= n and x / i <= n then increment cnt ;  $  TAB3 if i isn't x/i and i <= n and x/i <= n then increment cnt by 2 ;  $  TAB1 print cnt ;
TAB1 create long long n, x ;  $  TAB1 read n and x ;  $  TAB1 c=0 ;  $  TAB1 if x <= n, increment c ;  $  TAB1 for i=2 to n inclusive ;  $  TAB2 if x % i = 0 and x / i <= n, increment c ;  $  TAB1 print c ;
TAB1 let n, i, c, t, d be integers with d = 0 ;  $  TAB1 read n , t ;  $  TAB1 c is equal to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if t modulo i is equal to 0 ;  $  TAB3 d is equal to t / i ;  $  TAB3 if d >= 1 and d <= n , increment c by 1 ;  $  TAB1 print c and newline ;
TAB1 declare long long ints a, b, c, d, e, f, g, h, i and j ;  $  TAB1 declare vectors of long long integers s v, x and u ;  $  TAB1 create new strings s and t ;  $  TAB1 read a and b and keep looping ;  $  TAB2 for c from 1 to a inclusive, add element = c to the end of v ;  $  TAB2 assign the new value = 0 to e ;  $  TAB2 change f to a - 1 ;  $  TAB2 assign 0 to g ;  $  TAB2 while e <= f ;  $  TAB3 if v[e] * v[f] = b and v[e] != v[f] ;  $  TAB4 add 2 to g ;  $  TAB4 decrement f by one ;  $  TAB3 else if v[e] * v[f] = b and v[e] is equal to v[f] ;  $  TAB4 change g to g + 1 ;  $  TAB4 decrement f ;  $  TAB3 else if v[e] * v[f] is less than b ;  $  TAB4 increment e by one ;  $  TAB3 else ;  $  TAB4 decrement f by one ;  $  TAB2 print g ;  $  TAB2 clear vector v ;
TAB1 declare new integers n and x ;  $  TAB1 read n and x from the user input ;  $  TAB1 declare new integer called ans with value 0 ;  $  TAB1 for i from 1 to n inclusive ;  $  TAB2 increment ans if x modulo i = 0 and x / i <= n ;  $  TAB1 print ans ;
TAB1 create ints i, j, k, n, m, ans, mn and count with ans and count = 0 ;  $  TAB1 read user input to n and m ;  $  TAB1 change the value of mn to min of n and m ;  $  TAB1 in a for loop, change i from 1 to mn inclusive incrementing i ;  $  TAB2 if m % i = 0 and m / i <= n, increment count ;  $  TAB1 print count to the standard output ;
TAB1 create new ints n and k ;  $  TAB1 read standard input to n and k ;  $  TAB1 define integer cnt = 0 ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 increment cnt if k % i = 0 and i * 1LL * n >= k ;  $  TAB1 print cnt ;
TAB1 define long long ints n, x and occurances with occurances = 0 ;  $  TAB1 read n and x ;  $  TAB1 in a for loop, change i from 1 to n inclusive incrementing i ;  $  TAB2 if x % i = 0 and x / i <= n, increment occurances ;  $  TAB1 print occurances and "\n" ;
TAB0 i, j = int ;  $  TAB0 in function cnt taking int n and returning int ;  $  TAB1 ans, res = int with ans = 1 ;  $  TAB1 iterate i from 2 while i * i <= n ;  $  TAB2 set res to 0 ;  $  TAB2 loop while n is a multiple of i ;  $  TAB3 set n to n / i ;  $  TAB3 increment res ;  $  TAB2 set ans to ans* (res + 1) ;  $  TAB1 return ans ;  $  TAB1 n, x, ans = int with ans = 0 ;  $  TAB1 read n then x ;  $  TAB1 iterate i from 1 while i * i <= x and i <= n ;  $  TAB2 if x is not a multiple of i continue ;  $  TAB2 if x / i <= n increment ans by 2 ;  $  TAB2 if i * i is x decrement ans ;  $  TAB1 print ans ;
TAB1 create long long n, t, cont, set cont to 0 ;  $  TAB1 read na dn t ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if t mod i =0 ;  $  TAB3 if t / i >= 1 and t / i <= n, increment cont ;  $  TAB1 print cont ;
TAB1 create long long int n, x, i, cnt, set cnt to 0 ;  $  TAB1 read n and x ;  $  TAB1 for i=0 to n inclusive ;  $  TAB2 if x mod i=0 and x <= (i * n), increment cnt ;  $  TAB1 print cnt ;
TAB1 declare ints n and k ;  $  TAB1 a is a new array of integers with 105 elements ;  $  TAB1 read from the input to n and k ;  $  TAB1 create integer ans = 0 ;  $  TAB1 start for loop from i = 0 to n exclusive incrementing i ;  $  TAB2 read user input to a[i] ;  $  TAB2 if a[i] is equal to 0, break ;  $  TAB2 if k is greater than 0 ;  $  TAB3 decrement k ;  $  TAB3 increment ans by one ;  $  TAB2 else if a[i] is equal to a[i - 1] ;  $  TAB3 increment ans by one ;  $  TAB2 else ;  $  TAB3 stop the loop ;  $  TAB1 print ans ;
TAB1 create int n and k ;  $  TAB1 read n and k ;  $  TAB1 create int prev, next, cnt, set cnt to 0 ;  $  TAB1 read prev ;  $  TAB1 set total_cnt = 0 ;  $  TAB1 if prev different from 0 ;  $  TAB2 total_cnt = 1 ;  $  TAB2 for i=1 to n exclusive ;  $  TAB3 read next ;  $  TAB3 if next=0, break ;  $  TAB3 if prev different from next ;  $  TAB4 if total_cnt + 1 > k, break ;  $  TAB3 increment total_cnt ;  $  TAB3 set prev to nect ;  $  TAB1 print total_cnt ;
TAB1 create ints n, k, f, a, count and temp where count = 0 and f = 1 ;  $  TAB1 read input to n and k ;  $  TAB1 in a for loop, change i from 0 to n exclusive incrementing i ;  $  TAB2 read from the input to a ;  $  TAB2 if f > k and temp != a ;  $  TAB3 break the loop ;  $  TAB2 else if a is greater than 0 ;  $  TAB3 increment count by one ;  $  TAB2 assign the new value = a to temp ;  $  TAB2 increment f by one ;  $  TAB1 print count ;
TAB1 i, n, m, x = int ;  $  TAB1 read n then m ;  $  TAB1 a = int array of size n ;  $  TAB1 for i = 1 to n inclusive read a[i] ;  $  TAB1 set x to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if (a[i] >= a[m]) and (a[i] > 0) increment x ;  $  TAB1 print x ;
TAB1 let n, k be integers and 50th element of integer array a is 0 ;  $  TAB1 read n and k ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 if a[k - 1] is not equal to 0 ;  $  TAB2 while a[k - 1] is equal to a[k] , increment k by 1 ;  $  TAB2 print k and newline ;  $  TAB1 else do the following ;  $  TAB2 if k is equal to 1 ;  $  TAB3 print 0 and newline ;  $  TAB2 else do the following ;  $  TAB3 k is decremented by 1 ;  $  TAB3 while a[k - 1] is equal to 0, decrement k by 1 ;  $  TAB3 print k and newline ;
TAB0 n, k, a, b = long long integers ;  $  TAB1 Read n and k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read a ;  $  TAB2 if a is 0 ;  $  TAB3 print i and a new line ;  $  TAB1 for i = k to n exclusive ;  $  TAB2 Read b ;  $  TAB2 if b is not a ;  $  TAB3 print i and a new line ;  $  TAB1 print n and a new line ;
TAB1 ara = integer array of size 10000 ;  $  TAB1 n, k = integers ;  $  TAB1 read n, k ;  $  TAB1 cnt = integer with cnt = 0 ;  $  TAB1 for i = 0 to n exclusive, read ara[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if (ara[i] >= ara[k - 1] and ara[i] > 0), increment cnt ;  $  TAB1 print cnt ;
TAB0 x = integer array of size 1000001 ;  $  TAB1 k, n, points = integers with points = 0 ;  $  TAB1 read n, k ;  $  TAB1 for i = 0 to n exclusive, read x[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if (x[i] >= x[k - 1] and x[i] is not 0) increment points ;  $  TAB1 print points ;
TAB1 n, k = int ;  $  TAB1 read n then k ;  $  TAB1 a = int array of size n ;  $  TAB1 noop ;  $  TAB1 i, 1 = int ;  $  TAB1 for i = 0 to n ;  $  TAB2 rad a[i] ;  $  TAB2 if k is i + 1 set t1 to a[i] ;  $  TAB1 sort a using greater of type int ;  $  TAB1 c = int with c = 0 ;  $  TAB1 for i = 0 to n ;  $  TAB2 if a[i] is not 0 and a[i] >= t1 increment c ;  $  TAB1 if a[0] is 0 ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 print c ;
TAB1 declare integers n, k, i, c = 0, integer array A size 110 ;  $  TAB1 read n and k ;  $  TAB1 for i= 1 to n inclusive, read A[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if A[i] is greater than or equal to A[k]] and A[i] is greater than 0, increment c ;  $  TAB1 print c and newline ;
TAB1 create int n, k, i, a[100], cnt. set cnt to 0 ;  $  TAB1 read n and k ;  $  TAB1 for i=1 to n inclusive, read a[i] ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if a[i] >= a[k] and a[i] > 0, increment cnt ;  $  TAB1 print cnt ;
TAB0 create integers n, k and ans with ans = 0; create an array of integers a with size 1000 filled with 0 ;  $  TAB1 read n and k ;  $  TAB1 read n elements into a ;  $  TAB1 change i in a loop from 0 to n exclusive ;  $  TAB2 increment ans if a[i] >= a[k - 1] and a[i] > 0 ;  $  TAB1 print ans to the standard output ;
TAB1 declare integer array a size 101, integers n, c, s = 0 ;  $  TAB1 read n and c ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is greater than 0 and a[i] is greater than or equal to a[c-1], increment s by i ;  $  TAB1 print s and newline ;
TAB1 n, k = int ;  $  TAB1 read n and k ;  $  TAB1 let a pointer be a new int array of length n ;  $  TAB1 output = 0 = int ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a at i ;  $  TAB2 if i <= k-1 and a[i] is positive ;  $  TAB3 increment output ;  $  TAB2 else if i > k-1 and a[i] is positive and a[i] = a[k-1] ;  $  TAB3 increment output ;  $  TAB2 else ;  $  TAB3 exit loop ;  $  TAB1 print output ;
TAB1 create new int variables n, k and sum with sum = 0 and a new int pointer *arr ;  $  TAB1 read input to n and k ;  $  TAB1 set arr to point to the new integer array with n elements ;  $  TAB1 read n elements into arr ;  $  TAB1 in a for loop, change i from 0 to n exclusive ;  $  TAB2 if arr[k - 1] = 0 ;  $  TAB3 if arr[i] is greater than arr[k - 1], add 1 to sum ;  $  TAB2 else ;  $  TAB3 if arr[i] >= arr[k - 1], change sum to sum + 1 ;  $  TAB1 print sum ;
TAB0 create ints x and y and int array ar of size 100 ;  $  TAB1 make integer c = 0 ;  $  TAB1 read x and y ;  $  TAB1 for i = 0 to x exclusive ;  $  TAB2 read ar[i] ;  $  TAB2 if ar[i] is greater than or equal to ar[y - 1] and ar[i] is greater than 0 ;  $  TAB1 print c ;
TAB0 create long long n, k ;  $  TAB1 read n and k ;  $  TAB1 if k mod n=0 ;  $  TAB2 print k/n ;  $  TAB1 else ;  $  TAB2 print k/n + 1 ;
TAB1 n,k=long long ;  $  TAB1 while read n,k ;  $  TAB2 ans=k/n ;  $  TAB2 if k is not multiple of n increment ans ;  $  TAB2 print ans ;
TAB1 create new long longs n and m ;  $  TAB1 read user input to n and m ;  $  TAB1 if m % n != 0 ;  $  TAB2 print m / n + 1 to the output ;  $  TAB1 else ;  $  TAB2 print m / n ;
TAB1 create long long n, k, h ;  $  TAB1 read n and k ;  $  TAB1 if k mod n=0 ;  $  TAB2 print k/n ;  $  TAB1 else ;  $  TAB2 print k/n + 1 ;
TAB1 n, m = long long int ;  $  TAB1 read n then m ;  $  TAB1 if m <= n ;  $  TAB2 print "1" ;  $  TAB1 else ;  $  TAB2 if m is a multiple of n ;  $  TAB3 print m / n ;  $  TAB2 else ;  $  TAB3 print m / n + 1 ;
TAB1 n,k,h=long long int ;  $  TAB1 read n,k ;  $  TAB1 if k<=n ;  $  TAB2 h=1 ;  $  TAB1 else ;  $  TAB2 if k is not multiple of n ;  $  TAB3 h=k/n+1 ;  $  TAB2 else ;  $  TAB3 h=k/n ;  $  TAB1 print h ;
TAB1 n, k = long long ;  $  TAB1 read n then k ;  $  TAB1 counts = long long with counts = 0 ;  $  TAB1 if k is not a multiple of n increment counts ;  $  TAB1 increment counts by k / n ;  $  TAB1 print counts ;
TAB0 MAXN = const int = 1e4 + 20 ;  $  TAB0 const int = INF = 1e9 + 100 ;  $  TAB0 MOD = const int = 1e9 ;  $  TAB1 n, k = long long ;  $  TAB1 while read n and k, print (k + n - 1) / n ;
TAB1 n, k, h =integers ;  $  TAB1 Read n and k ;  $  TAB1 set h to k / n ;  $  TAB1 if h is not equal to 0 ;  $  TAB2 if k modulo n is equal to 0 ;  $  TAB3 print h and a new line ;  $  TAB2 else do the following ;  $  TAB3 print h + 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print 1 and a new line ;
TAB1 create new long longs n and k ;  $  TAB1 loop, reading n and k from the input ;  $  TAB2 if k % n = 0 ;  $  TAB3 print k / n ;  $  TAB2 else ;  $  TAB3 print k / n + 1 ;
TAB1 n, k =integers ;  $  TAB1 while reading values n, k ;  $  TAB2 if k modulo n is 0 ;  $  TAB3 print k / n and a new line ;  $  TAB2 else do the following ;  $  TAB3 print k / n + 1 and a new line ;
TAB1 n, k, h =integers ;  $  TAB1 while reading values n, k, h ;  $  TAB2 if n is 0 OR k is 0, then Terminate the loop ;  $  TAB2 set h to k / n ;  $  TAB2 if k modulo n is 0 ;  $  TAB3 print h and a new line ;  $  TAB2 else do the following ;  $  TAB3 print h + 1 and a new line ;
TAB1 let n, k be long integers ;  $  TAB1 read n , k ;  $  TAB1 if n >= k ;  $  TAB2 print 1 and newline ;  $  TAB1 else if k modulo n equals 0 ;  $  TAB2 print k / n and newline ;  $  TAB1 else do the following ;  $  TAB2 print k / n + 1 and newline ;
TAB1 n, k = long long ;  $  TAB1 read n then k ;  $  TAB1 if n >= k ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 if k is a multiple of n ;  $  TAB3 print k / n ;  $  TAB2 else ;  $  TAB3 print k / n + 1 ;
TAB1 define new long longs n and s ;  $  TAB1 read n and s from the user input ;  $  TAB1 print (s / n) + (1 if s modulo n != 0, or 0 otherwise) ;
TAB1 a=int ;  $  TAB1 n,k=long long ;  $  TAB1 read n,k ;  $  TAB1 if k <= n ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 if k is multiple of n ;  $  TAB3 print k/n ;  $  TAB2 else ;  $  TAB3 print k/n+1 ;
TAB0 create long long n, k ;  $  TAB1 while read n and k ;  $  TAB2 if k<= n ;  $  TAB3 print 1 ;  $  TAB2 else if k mod n =0 ;  $  TAB3 print k/n ;  $  TAB2 else if k mod n different from 0 ;  $  TAB3 print k/n +1 ;
TAB0 n,l=long long ;  $  TAB0 function c1 (get long long n and k, return long long) ;  $  TAB1 if n is multiple of k return n/k ;  $  TAB1 return n/k+1 ;  $  TAB1 read n ;  $  TAB1 print cl(k, n) ;
TAB0 n, k = integers ;  $  TAB1 while reading values n, k ;  $  TAB2 ans = integer, set to k / n ;  $  TAB2 if k modulo n, then increment ans ;  $  TAB2 print ans and a new line ;
TAB1 create new long longs n and m ;  $  TAB1 read n and m from the user input ;  $  TAB1 if n >= m ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 if m % n = 0 ;  $  TAB3 print m / n ;  $  TAB2 else ;  $  TAB3 print m / n + 1 ;
TAB1 n, k =integers ;  $  TAB1 Read n and k ;  $  TAB2 if k modulo n is 0 ;  $  TAB3 print k / n and a new line ;  $  TAB2 else do the following ;  $  TAB3 print k / n + 1 and a new line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if ((n modulo 3) is 1), decrement n ;  $  TAB1 if ((n modulo 3) is 2), increment n ;  $  TAB1 n = n / 3 ;  $  TAB1 feet = integer with feet = n / 12 ;  $  TAB1 inch = integer with inch = n modulo 12 ;  $  TAB1 print feet," ",inch ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let ans1 be a integer with ans1 = n / 3 ;  $  TAB1 n is equal to n modulo 3 ;  $  TAB1 if n >= 2 , increment ans1 by 1 ;  $  TAB1 let ans2 be a integer with ans2 = ans1 / 12 ;  $  TAB1 ans1 is equal to ans1 modulo 12 ;  $  TAB1 print ans2 and space and ans1 and newline ;
TAB1 let n an int ;  $  TAB1 read n ;  $  TAB1 let inches an int with value n / 3 ;  $  TAB1 if n mod 3 is 2, add 1 to inches ;  $  TAB1 print inches / 12, followed by a space, followed by inches mod 12 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 let k be a integer with k = (n + 1) / 3 ;  $  TAB1 print k / 12 and space and k modulo 12 and newline ;
TAB1 create new integer called n ;  $  TAB1 read standard input to n ;  $  TAB1 define new integer variable a = n / 36 ;  $  TAB1 define new integer b with value (n - 36 * a) / 3 ;  $  TAB1 c is a new integer variable with value n - 36 * a - b * 3 ;  $  TAB1 if c = 2, increase b by 1 ;  $  TAB1 if b = 12 ;  $  TAB2 add 1 to a ;  $  TAB2 assign 0 to b ;  $  TAB1 print a, " " and b ;
TAB1 n is a new integer ;  $  TAB1 read user input to n ;  $  TAB1 print (n + 1) / 36 and " " ;  $  TAB1 change the value of n to n modulo 36 ;  $  TAB1 if (n + 1) / 36 <= n / 36 ;  $  TAB2 print (n + 1) / 3 ;  $  TAB1 else ;  $  TAB2 print 0 to the standard output ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if ((n + 1) modulo 36 is 0), increment n ;  $  TAB1 ft = integer with ft = n / 36 ;  $  TAB1 n = n modulo 36 ;  $  TAB1 in = integer ;  $  TAB1 if (n modulo 3 is 0 or (n - 1) modulo 3 is 0) ;  $  TAB2 in = n / 3 ;  $  TAB1 else ;  $  TAB2 in = n / 3 + 1 ;  $  TAB1 print ft,' ',in ;
TAB1 create integer n ;  $  TAB1 read standard input to n ;  $  TAB1 define new integer inches with value n / 3 + (n modulo 3 > 1) ;  $  TAB1 print inches / 12, " ", inches modulo 12 and "\n" ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 c = integer, set to n / 3 ;  $  TAB1 if n modulo 3 is 2, then set c to c + 1 ;  $  TAB1 print c / 12, c modulo 12 and a new line ;
TAB1 n, foot, inch, x =integers ;  $  TAB1 Read n ;  $  TAB1 set foot to n / 36 ;  $  TAB1 set x to n modulo 36 ;  $  TAB1 if x is equal to 35 ;  $  TAB2 increment foot ;  $  TAB2 set inch to 0 ;  $  TAB2 print foot , inch and a new line ;  $  TAB1 else do the following ;  $  TAB2 set inch to x / 3 ;  $  TAB2 if x modulo 3 is 2, then increment inch ;  $  TAB2 print foot , inch and a new line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 k = integer with k = (n + 1) / 3 ;  $  TAB1 print k / 12,' ',k modulo 12 ;
TAB1 m=long long ;  $  TAB1 n=double ;  $  TAB1 read n ;  $  TAB1 m=round(n/3) ;  $  TAB1 print m/12, space, m modulo 12 ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 ft, cm = long long with ft = (n / 36) and cm =n - (36 * ft) ;  $  TAB1 in = long long with in = cm / 3 ;  $  TAB1 if cm mod 3 is 2 increment in ;  $  TAB1 if in is 12 increment ft then set in to 0 ;  $  TAB1 print ft and in ;
TAB1 new integer variable n ;  $  TAB1 read n and keep looping ;  $  TAB2 new integer variable inches with value (n+1) /3 ;  $  TAB2 define new integer foot = inches / 12 ;  $  TAB2 print foot and " " ;  $  TAB2 if inches - foot * 12 <= 0 ;  $  TAB3 print "0" ;  $  TAB2 else ;  $  TAB3 print inches - foot * 12 ;
TAB1 n, x, y = integers ;  $  TAB1 read n ;  $  TAB1 set x to n / 36 ;  $  TAB1 set n to n - x*36 ;  $  TAB1 if n mod 3 equals 2 ;  $  TAB2 set y to n / 3 + 1 ;  $  TAB1 else ;  $  TAB2 set y to n / 3 ;  $  TAB1 if y equals 12 ;  $  TAB2 print x+1 space 0 ;  $  TAB1 else ;  $  TAB2 print x space y ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 make int inch = 0 ;  $  TAB1 create integer feet = n / 36 ;  $  TAB1 subtract (n / 36) * 36 from n ;  $  TAB1 if n is 35 ;  $  TAB2 increment feet ;  $  TAB1 else do ;  $  TAB2 set inch to n / 3 ;  $  TAB2 set n to n - (n / 3) * 3 ;  $  TAB2 if n is equal to 2, increment inch ;  $  TAB1 show feet, " ", and inch ;
TAB0 define new integer constant INF with value 0x3f3f3f3f ;  $  TAB1 declare long long variables i, j and k ;  $  TAB1 create new long longs n and m ;  $  TAB1 read input to n ;  $  TAB1 assign n modulo 3 to k ;  $  TAB1 divide n by 3 ;  $  TAB1 if k is equal to 2, increment n ;  $  TAB1 print n / 12, ' ' and n modulo 12 to the output ;
TAB1 declare new integer variable n ;  $  TAB1 read n from the user input ;  $  TAB1 create new integer m = n / 36 ;  $  TAB1 define integer q with value (n % 36) / 3 ;  $  TAB1 mo is a new integer with value n modulo 36 modulo 3 ;  $  TAB1 if mo is equal to 2, add 1 to q ;  $  TAB1 assign 0 to q and increment m by one, if q = 12 ;  $  TAB1 print m, " " and q ;
TAB1 create long longs n, inches and feets ;  $  TAB1 read variable n from the input ;  $  TAB1 set inches to n / 3 ;  $  TAB1 if n modulo 3 is 2, add 1 to inches ;  $  TAB1 change feets to inches / 12 ;  $  TAB1 subtract feets * 12 from inches ;  $  TAB1 print feets, " " and inches ;
TAB1 define ints n, ft, inch and r ;  $  TAB1 read variable n from the input ;  $  TAB1 assign the new value = n / 36 to ft ;  $  TAB1 set inch to (n modulo 36) / 3 ;  $  TAB1 change the value of r to (n % 36) % 3 ;  $  TAB1 increment inch if r is greater than 1 ;  $  TAB1 if inch is 12 ;  $  TAB2 add one to ft ;  $  TAB2 set inch to 0 ;  $  TAB1 print ft, " " and inch to the standard output ;
TAB1 let m be a map from integers to integers ;  $  TAB1 create ints t, x, c and y with c and y = 1 ;  $  TAB1 read t ;  $  TAB1 create boolean variable hard with value false ;  $  TAB1 start for loop from i = 0 to t exclusive incrementing i ;  $  TAB2 read variable x from the input ;  $  TAB2 if m[x] >= c ;  $  TAB3 increment m[x] by one ;  $  TAB3 if m[x] is greater than y, assign the new value = m[x] to y ;  $  TAB2 else ;  $  TAB3 change the value of m[x] to c ;  $  TAB3 if m[x] is greater than y, set y to m[x] ;  $  TAB1 print t - y ;
TAB1 n =integer ;  $  TAB1 Read n ;  $  TAB1 j, d, t = integers with all set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 Read temp ;  $  TAB2 if temp is equal to 1 ;  $  TAB3 increment j ;  $  TAB2 else if temp is equal to 2 ;  $  TAB3 increment d ;  $  TAB2 else do the following ;  $  TAB3 increment t ;  $  TAB1 set maximum value of (maximum value of (j and t) and maximum value of(j and d)) ;  $  TAB1 print n - temp and a new line ;
TAB0 v is a new array of integers with 5 elements ;  $  TAB1 create new integer variable n ;  $  TAB1 read variable n from the input ;  $  TAB1 incrementi i in a for loop, changing it from 1 to n inclusive ;  $  TAB2 create new integer called x ;  $  TAB2 read from the input to x ;  $  TAB2 increment v[x] by one ;  $  TAB1 maxi is a new integer variable = max of v[1] and max(v[2], v[3]) ;  $  TAB1 print n - maxi ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 a = array of integers of length 1000005 ;  $  TAB1 let n1, n2, n3 be integers ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is equal to 1 ;  $  TAB3 increment n1 by 1 ;  $  TAB2 else if a[i] is equal to 2 ;  $  TAB3 increment n2 by 1 ;  $  TAB2 else do the following ;  $  TAB3 increment n3 by 1 ;  $  TAB1 if (n1 >= n2) and (n1 >= n3) ;  $  TAB2 print n - n1 and newline ;  $  TAB1 else if (n2 >= n1) and (n2 >= n3) ;  $  TAB2 print n - n2 and newline ;  $  TAB1 else do the following ;  $  TAB2 print n - n3 and newline ;
TAB1 set num[4] = {0} ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 create int tmp ;  $  TAB2 read tmp ;  $  TAB2 increment num[tmp] ;  $  TAB1 if num[1] >= num[2] and num[1] >= num[3] ;  $  TAB2 print num[2] + num[3] ;  $  TAB1 else if num[2] >= num[1] and num[2] >= num[3] ;  $  TAB2 print num[1] + num[3] ;  $  TAB1 else ;  $  TAB2 print num[1] + num[2] ;
TAB0 freq=array of 3 int ;  $  TAB1 a,b,mx=int ;  $  TAB1 read a ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 read b ;  $  TAB2 increment freq[b-1] ;  $  TAB1 mx=max of freq items ;  $  TAB1 print a-mx ;
TAB1 let n be an integer ;  $  TAB1 read n ;  $  TAB1 let a, b, c be integers with value of 0 ;  $  TAB1 for int i = 0 to n ;  $  TAB2 let x be an integer ;  $  TAB2 read x ;  $  TAB2 if x equals 1, add one to a ;  $  TAB2 if x equals 2, add one to b ;  $  TAB2 if x equals 3, add one to c ;  $  TAB1 if a is greater or equal to b and a is greater or equal to c ;  $  TAB2 print b + c ;  $  TAB1 else if b is greater or equal to a and b is greater or equal to c ;  $  TAB2 print a + c ;  $  TAB1 else if c is greater or equal to a and c is greater or equal to b ;  $  TAB2 print a + b ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let freq be integer array of length 3 and initiate it to blank ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let x be integer ;  $  TAB2 read x ;  $  TAB2 call freq with x-1 and increment ;  $  TAB1 let m be integer and assign max(freq[0], max(freq[1], freq[2])) to m ;  $  TAB1 print n - m ;
TAB1 create int n, i, j, k, x ;  $  TAB1 crate vector int ct ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 increment ct[x] ;  $  TAB1 print n - max of ct[1] and max(ct[2], ct[3]), and a newline ;  $  TAB1 ; ;
TAB0 a = array of 11 integers ;  $  TAB1 n, i, x = integers ;  $  TAB1 Read n ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 Read x ;  $  TAB2 increment a[x] ;  $  TAB1 max = integer, set to -1 ;  $  TAB1 for i = 1 to 3 exclusive ;  $  TAB2 if a[i] is greater than max, set max to a[i] ;  $  TAB1 print n - max and a new line ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 set a, b and c = 0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create int x ;  $  TAB2 read x ;  $  TAB2 if x=1, increment a ;  $  TAB2 if x =2, increment b ;  $  TAB2 if x=3, add 1 to c ;  $  TAB1 if a >= b and a >= c ;  $  TAB2 print b+c ;  $  TAB1 else if b >= a and b >= c ;  $  TAB2 print a+c ;  $  TAB1 else if c >= a and c >= b ;  $  TAB2 print a+b ;
TAB0 a = integer array of size 1000005 ;  $  TAB0 in the function max that takes integer a, b and returns integer ;  $  TAB1 return if a > b, a else b ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 x, y, z = integers x = 0, y = 0, z = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if (a[i] is 1), increment x ;  $  TAB2 if (a[i] is 2), increment y ;  $  TAB2 if (a[i] is 3), increment z ;  $  TAB1 print x + y + z - max(max(x, y), z) ;
TAB0 num = int array of length 4 ;  $  TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a = int ;  $  TAB2 read a ;  $  TAB2 increment num at a ;  $  TAB1 max_num = -1 = int ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 if num[i] > max_num then set max_num to num at i ;  $  TAB1 print n - max_num ;
TAB0 create int A[4] ;  $  TAB1 create int n and inp ;  $  TAB1 read n ;  $  TAB1 while read inp, pre increment A[inp] ;  $  TAB1 print n - max(A[1], max(A[2], A[3])) ;
TAB1 create long long n and a ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 a= n/2 ;  $  TAB1 else ;  $  TAB2 set ((n + 1) / 2) * (-1) ;  $  TAB1 print a ;
TAB1 let n be a long integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is equal to 0 ;  $  TAB2 print n / 2 and newline ;  $  TAB1 else do the following ;  $  TAB2 print (-n - 1) / 2 and newline ;
TAB0 in function MIN taking long long int a, long long int b and returning long long int ;  $  TAB1 if a > b ;  $  TAB2 return b ;  $  TAB1 else ;  $  TAB2 return a ;  $  TAB0 in function MAX taking long long int a, long long int b and returning long long int ;  $  TAB1 if a > b ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return b ;  $  TAB0 in function MOD taking long long int x and returning long long int ;  $  TAB1 if x >= 0 ;  $  TAB2 return x ;  $  TAB1 else ;  $  TAB2 return -x ;  $  TAB1 n = long long int ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n / 2 ;  $  TAB1 else ;  $  TAB2 d = long long int with d = n / 2 ;  $  TAB2 decrement d by n ;  $  TAB2 print d ;
TAB1 n, a = long long ;  $  TAB1 read n ;  $  TAB1 set a to n / 2 ;  $  TAB1 if n is even ;  $  TAB2 print a ;  $  TAB1 else ;  $  TAB2 print a - n ;
TAB1 declare long longs a, b = 0 ;  $  TAB1 read a ;  $  TAB1 declare integer i ;  $  TAB1 if a % 2 is not 0 ;  $  TAB2 let i be -1 ;  $  TAB1 else ;  $  TAB2 let i be 0 ;  $  TAB1 let b be a / 2 * ( -1 raised to power of a % 2 ) + i ;  $  TAB1 print b and newline ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n/2 ;  $  TAB1 else ;  $  TAB2 print -(n + 1) / 2 ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n/2 ;  $  TAB1 else ;  $  TAB2 print -, (n + 1) / 2 ;
TAB1 declare long longs n, a ;  $  TAB1 read n ;  $  TAB1 if n % 2 is 0 ;  $  TAB2 let a be n / 2 ;  $  TAB1 else ;  $  TAB2 let a be ((n + 1) / 2) * (-1) ;  $  TAB1 print a and newline ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n/2 ;  $  TAB1 else if n=1 ;  $  TAB2 print -1 and a newline ;  $  TAB1 create long long int div ;  $  TAB1 div = n/2 ;  $  TAB1 set n = (n * (-1)) + div ;  $  TAB1 print n ;
TAB1 n = 0 ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n/2 ;  $  TAB1 else ;  $  TAB2 print -((n + 1) / 2) ;
TAB1 n = long long int ;  $  TAB1 read n ;  $  TAB1 if ((n modulo 2) is 0) ;  $  TAB2 print n / 2 ;  $  TAB1 else ;  $  TAB2 print (n / 2) - n ;
TAB0 declare f with long long as argument, returning long long ;  $  TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 run f(n) ;  $  TAB0 declare f with long long n as argument, returning long long ;  $  TAB1 if n % 2 is 0 ;  $  TAB2 print ( n / 2 ) and newline ;  $  TAB1 else ;  $  TAB2 print ( n / 2 - n ) and newline ;
TAB0 declare integer array dx = {1, 0, -1, 0, 1, 1, -1, -1} ;  $  TAB0 declare integer array dy = {0, 1, 0, -1, 1, -1, 1, -1} ;  $  TAB0 declare fast with no arguments, returning void ;  $  TAB0 declare constant long long md = 1e9 + 7 ;  $  TAB1 run fast ;  $  TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 if n % 2 is 0 ;  $  TAB2 print n / 2 and "\n" ;  $  TAB1 else ;  $  TAB2 print -(n+1)/2 and "\n" ;
TAB1 declare long long variable n ;  $  TAB1 read n from the input ;  $  TAB1 if n is even ;  $  TAB2 print n / 2 ;  $  TAB1 else ;  $  TAB2 print - (n + 1) / 2 to the output ;
TAB1 create long long variable n ;  $  TAB1 read user input to n ;  $  TAB1 define long long chk = 0 ;  $  TAB1 assign n / 2 to chk ;  $  TAB1 if chk * 2 is equal to n ;  $  TAB2 print chk to the standard output ;  $  TAB1 else ;  $  TAB2 print chk - n to the standard output ;  $  TAB1 print new line ;
TAB1 n = long long ing ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n / 2 ;  $  TAB1 else ;  $  TAB2 ans = long long int with value of (n - 1) / 2 ;  $  TAB2 print -1 - ans ;
TAB1 n, y = long long ;  $  TAB1 x = double ;  $  TAB1 read n ;  $  TAB1 if n % 2 = 0 && n != 0m print n / 2 ;  $  TAB1 if n % 2 != 0 && n != 0 ;  $  TAB2 let x = ceil(1. * n / 2) ;  $  TAB2 let y = x ;  $  TAB2 print -y ;
TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 declare long long k1 = ((2 + (n - 1 if n % 2 is 1, else n)) / 2) * (n / 2) ;  $  TAB1 declare long long k2 = ((1 + (n if n % 2 is 1, else n - 1)) / 2) * ((n + 1) / 2) ;  $  TAB1 print k1 - k2 and '\n' ;
TAB1 num = char ;  $  TAB1 n = int, n = 0 ;  $  TAB1 while num is not a new line ;  $  TAB2 let num = getchar ;  $  TAB2 if n = 0 and num = 9 ;  $  TAB3 print num ;  $  TAB2 else if num >= 5 ;  $  TAB3 print 9 ;  $  TAB2 else ;  $  TAB3 print num ;  $  TAB2 add one to n ;
TAB0 function check with int arguments x and y that returns int ;  $  TAB1 if x <= y, return x ;  $  TAB1 return y ;  $  TAB1 define strings s and p with p = "" ;  $  TAB1 declare int variables i and j ;  $  TAB1 read variable s from the input ;  $  TAB1 assign the new value = s to p ;  $  TAB1 for i = length of s - 1 to 0 counting down ;  $  TAB2 change j to the result of check(s[i] - '0', 9 - (s[i] - '0')) ;  $  TAB2 assign the new value = (j + '0') casted to char, to p[i] ;  $  TAB1 change j to 9 - (s[0] - '0') ;  $  TAB1 if j is not 0 ;  $  TAB2 assign the returned value of check(s[0] - '0', 9 - (s[0] - '0')) to j ;  $  TAB2 change p[0] to (j + '0') casted to char ;  $  TAB1 print p ;
TAB1 declare string s ;  $  TAB1 new integer i ;  $  TAB1 read s and keep looping ;  $  TAB2 change the value of i to 0 ;  $  TAB2 if s[0] is equal to '9', increment i by one ;  $  TAB2 while i < length of s, increment it by 1 in a loop ;  $  TAB3 if s[i] is greater than '4', assign the value = '9' - s[i] + '0' to s[i] ;  $  TAB2 print s to the standard output ;
TAB1 declare new string s ;  $  TAB1 read variable s from the input ;  $  TAB1 for integer i = 0 to length of s exclusive ;  $  TAB2 if s[i] - '0' >= 5 ;  $  TAB3 create integer x with value = 9 - (s[i] - '0') ;  $  TAB3 change s[i] to x + '0' ;  $  TAB2 if s[0] is equal to '0', set s[0] to '9' ;  $  TAB1 print s ;
TAB1 define string s ;  $  TAB1 read from the input to s ;  $  TAB1 for i from 0 to length of s exclusive ;  $  TAB2 if i = 0 and s[i] is equal to '9', go to the start of the loop ;  $  TAB2 if s[i] >= '5', change s[i] to '9' - s[i] + '0' ;  $  TAB1 print s ;
TAB1 create new string s ;  $  TAB1 read standard input to s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] = '9' ;  $  TAB3 if i is equal to 0 ;  $  TAB4 go to the start of the loop ;  $  TAB3 else ;  $  TAB4 assign the new value = '0' to s[i] ;  $  TAB3 go to the start of the loop ;  $  TAB2 if s[i] - '0' is greater than 4, set s[i] to 48 + 9 - (s[i] - '0') ;  $  TAB1 print s and "\n" to the standard output ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 i = unsigned long long int with i = 0 ;  $  TAB1 if s[i] is '9' ;  $  TAB2 print s[i] ;  $  TAB2 increment i ;  $  TAB1 continue iterating i while i < length of s print min of s[i] - '0', 9 - (s[i] - '0') ;  $  TAB1 print newline ;
TAB1 let numero be a string ;  $  TAB1 read numero ;  $  TAB1 let n be a integer with n is equal to length of numero ;  $  TAB1 for i = 0 to n - 1 inclusive ;  $  TAB2 let x be a integer with x = numero[i] - 0 ;  $  TAB2 if i is equal to 0 ;  $  TAB3 if 5 <= x and x <= 8 , numero[i] is equal to (char)(0 + 9 - x) ;  $  TAB2 else if 5 <= x ;  $  TAB3 numero[i] is equal to (char)(0 + 9 - x) ;  $  TAB1 print numero and newline ;
TAB0 declare integer array a size 100010 ;  $  TAB0 declare long long array cnt size 100010 ;  $  TAB1 declare character array c size 155 ;  $  TAB1 declare integer array num size 155 ;  $  TAB1 read c ;  $  TAB1 declare integer len = string length of c ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if c[i] is greater than or equal to '5' and c[i] is less than or equal to '9' ;  $  TAB3 if c[i] is '9' and i is 0 ;  $  TAB4 let num[i] be c[i] - '0' ;  $  TAB3 else ;  $  TAB4 let num[i] be 9 - ( c[i] - '0' ) ;  $  TAB2 else ;  $  TAB3 let num[i] be c[i] - '0' ;  $  TAB1 for i = 0 to len exclusive, print num[i] ;  $  TAB1 print newline ;
TAB1 declare character array x size 20 ;  $  TAB1 declare integer ok = 1 ;  $  TAB1 while read x is true ;  $  TAB2 declare integer len = string length of x ;  $  TAB2 for i = 0 to len exclusive ;  $  TAB3 if i is 0 ;  $  TAB4 if x[i] is '9' ;  $  TAB5 print x[i] ;  $  TAB4 else if x[i] is greater than or equal to '5' ;  $  TAB5 print '9' - x[i] ;  $  TAB4 else ;  $  TAB5 print x[i] ;  $  TAB3 else ;  $  TAB4 if x[i] is greater than or equal to '5' ;  $  TAB5 print '9' - x[i] ;  $  TAB4 else ;  $  TAB5 print x[i] ;  $  TAB2 print newline ;
TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 for i=0 to size of str exclusive ;  $  TAB2 if i = 0 and str[i] = 9, continue ;  $  TAB2 if str[i] > 4, set str[i] = 9 - str[i] + 48 ;  $  TAB1 print str ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i=0 to length of s exclusive ;  $  TAB2 if s[i] > 9 - s[i] + 0, s[i] = 9 - s[i] + 0 ;  $  TAB2 if s[0] = 0, s[0] = 9 ;  $  TAB1 print s ;
TAB1 define new string a ;  $  TAB1 read user input to a ;  $  TAB1 for i = 0 to length of a exclusive ;  $  TAB2 if a[i] >= '5', change the value of a[i] to 9 - (a[i] - '0') + '0' ;  $  TAB1 if a[0] is equal to '0' ;  $  TAB2 print 9 ;  $  TAB1 else ;  $  TAB2 print a[0] ;  $  TAB1 print all elements of a, starting from the index 1, to the output ;  $  TAB1 print new line ;
TAB1 create strings s and output ;  $  TAB1 read from the input to s ;  $  TAB1 start for loop from i = 0 to length of s exclusive ;  $  TAB2 declare new integer temp with value s[i] - 48 ;  $  TAB2 create new character called tempChar = '\0' ;  $  TAB2 if (i = 0 and temp = 9) or temp < 5 ;  $  TAB3 add new element = s[i] after the last element of output ;  $  TAB2 else ;  $  TAB3 assign (9 - temp) + 48 to tempChar ;  $  TAB3 push tempChar to the variable output ;  $  TAB1 print output to the stdout ;
TAB0 create int array dp of size 2505 with array of size 2505 ;  $  TAB0 make ints n and m ;  $  TAB0 declare cntt taking in int k and returning integer ;  $  TAB1 create integers k - 1 and res = 0 ;  $  TAB1 for i = 1 to n ;  $  TAB2 for j = 1 to m ;  $  TAB3 create integer cnt = 0 ;  $  TAB3 set cnt to cnt + dp[min(i + k1, n)][min(j + k1, m)] ;  $  TAB3 set cnt to cnt - dp[i - 1][min(j + k1, m)] ;  $  TAB3 subtract dp[min(i + k1, n)][j - 1] from cnt ;  $  TAB3 add dp[i - 1][j - 1] to cnt ;  $  TAB3 add min(cnt, k * k - cnt) to res ;  $  TAB1 return res ;  $  TAB1 read n and m ;  $  TAB1 create string s ;  $  TAB1 for i = 1 to n ;  $  TAB2 read s ;  $  TAB2 for j = 1 to m, set dp[i][j] to dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + s[j - 1] - '0' ;  $  TAB1 create integer res = n * m ;  $  TAB1 for k = 2 to min(n, m), set res to min of res and cntt(k) ;  $  TAB1 show res ;
TAB0 MAXN, MAXM = const int with MAXN = 2500 and MAXM = 2500 ;  $  TAB0 S = two dimensional int array of sizes MAXN + 1 and MAXM + 1 ;  $  TAB1 N, M = int ;  $  TAB1 read N then M ;  $  TAB1 for i = 1 to N inclusive ;  $  TAB2 R = string ;  $  TAB2 read R ;  $  TAB2 for j = 1 to M inclusive set S[i][j] to (R[j - 1] - '0') + S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] ;  $  TAB1 ans = int with ans = INT_MAX ;  $  TAB1 iterate k from 2 while k <= N or k <= M ;  $  TAB2 aux = int with aux = 0 ;  $  TAB2 for i = 1 to N inclusive incrementing i by k ;  $  TAB3 for j = 1 to M inclusive incrementing j by k ;  $  TAB4 ii, jj = int with ii = min of N, i + k - 1 and jj = min of M, j + k - 1 ;  $  TAB4 q = int with q = S[ii][jj] - S[ii][j - 1] - S[i - 1][jj] + S[i - 1][j - 1] ;  $  TAB4 increment aux by min of q, k * k - q ;  $  TAB2 set ans to min of ans, aux ;  $  TAB1 print ans ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 if n equals 2 ;  $  TAB2 print 2 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 1 and newline ;
TAB1 n=int ;  $  TAB1 while read n ;  $  TAB2 if n is 2 ;  $  TAB3 print 2 ;  $  TAB2 else ;  $  TAB3 print 1 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n is 2 ;  $  TAB2 print "2" ;  $  TAB1 else ;  $  TAB2 print "1" ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n = 2 ;  $  TAB2 print n ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 integer as l,r,a,b,d,i,n ;  $  TAB1 read n ;  $  TAB1 output 2 if n =2, else output 1 ;
TAB0 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is 2 ;  $  TAB2 print 2 and newline ;  $  TAB1 else ;  $  TAB2 print 1 and newline ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n is 2 ;  $  TAB2 print 2 and newline ;  $  TAB1 else ;  $  TAB2 print 1 and newline ;
TAB1 declare integer v ;  $  TAB1 read v ;  $  TAB1 if v is 2 ;  $  TAB2 print 2 and newline ;  $  TAB1 else ;  $  TAB2 print 1 and newline ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 if n is not 2 ;  $  TAB2 print "1" ;  $  TAB1 else ;  $  TAB2 print "2" ;
TAB1 let n, x, v be long integers ;  $  TAB1 read v ;  $  TAB1 n is equal to v ;  $  TAB1 if n is greater than 2 ;  $  TAB2 n is equal to 1 ;  $  TAB1 else if n is equal to 2 ;  $  TAB2 n is equal to 2 ;  $  TAB1 print n and newline ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 if n is 1 or n is 2 then do the following ;  $  TAB2 output n ;  $  TAB1 else ;  $  TAB2 output 1 ;
TAB1 let n be a integer ;  $  TAB1 read n ;  $  TAB1 if n equals 2 ;  $  TAB2 print 2 and newline ;  $  TAB1 else do the following ;  $  TAB2 print 1 and newline ;
TAB1 let n be a long integer ;  $  TAB1 while read n ;  $  TAB2 if n equals 2 ;  $  TAB3 print 2 and newline ;  $  TAB2 else do the following ;  $  TAB3 print 1 and newline ;
TAB1 n=int ;  $  TAB1 read n ;  $  TAB1 if n is 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if (n is 2) ;  $  TAB2 read n ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 k = int, k = n - 1 ;  $  TAB1 if n = 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print n - k ;
TAB1 integer as n ;  $  TAB1 read n ;  $  TAB1 if n is 2 then do the following ;  $  TAB2 output 2 ;  $  TAB1 else ;  $  TAB2 output 1 ;
TAB0 let N be a constant integer with N is equal to 1e5 + 50 ;  $  TAB0 let oo be a constant integer with oo is equal to1e9 ;  $  TAB0 let mod be a constant integer with mod is equal to 1e9 + 7 ;  $  TAB0 let a, b,f1,f2 be string arrays of size 2001 ;  $  TAB1 let n be a integer ;  $  TAB1 read n, m ;  $  TAB1 for integer i = 0 to n exclusive, read a[i] ;  $  TAB1 for integer i = 0 to m exclusive, read b[i] ;  $  TAB1 for integer i = 0 to n-m inclusive, ;  $  TAB2 f1[i] is empty ;  $  TAB2 for integer j = 0 to m exclusive, increase f1[i] with a[i + j] ;  $  TAB1 for integer i = 0 to n-m inclusive, ;  $  TAB2 f2[i] is empty ;  $  TAB2 for integer j = 0 to m exclusive, increase f2[i] withb[j].substr(i, m) ;  $  TAB1 for integer i = 0 to n-m inclusive, ;  $  TAB2 for integer j = 0 to n-m inclusive, ;  $  TAB3 if f1[i] equals f2[j] ;  $  TAB4 print i + 1 space j + 1 and endline ;
TAB0 declare constant integer maxn = 2000 + 5 ;  $  TAB0 declare string arrays s1 size maxn, s2 size maxn ;  $  TAB1 declare integers n, m ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to n exclusive, read s1[i] ;  $  TAB1 for i = 0 to m exclusive, read s2[i] ;  $  TAB1 for i = 0 to n - m inclusive ;  $  TAB2 for j = 0 to n - m inclusive ;  $  TAB3 declare boolean flag = true ;  $  TAB3 for p = 0 to p is less than m and flag, incrementing p ;  $  TAB4 if memory compare between address of s1[i + p][0] and address of s2[p][j] comparing m bytes, let flag be false ;  $  TAB3 if flag is true ;  $  TAB4 print i + 1, " ", j + 1, "\n" ;
TAB1 n, m = int ;  $  TAB1 read n, m ;  $  TAB1 A, B = string vectors with size of A = n and size of B = m ;  $  TAB1 read all A ;  $  TAB1 read all B ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 pos = -1 = int ;  $  TAB2 while pos+1 < n ;  $  TAB3 ok = 1 = bool ;  $  TAB3 set pos to find A[i], pos + 1 on B[0] ;  $  TAB3 if pos = -1 then break ;  $  TAB3 for k = m - 1, until k <= 0 and is ok, decrement k ;  $  TAB4 if A[i+k] isn't substring from pos to m of b then set ok to 0 ;  $  TAB3 if ok then return print i+1 and space and pos + 1 and new line ;  $  TAB1 print -1 ;
TAB0 let mp[2][2001][2001] be a array of character elements ;  $  TAB1 let n , m be integers ;  $  TAB1 read n , m ;  $  TAB1 for i = 0 to n exclusive , read mp[0][i] ;  $  TAB1 for i = 0 to m exclusive , read mp[1][i] ;  $  TAB1 for i = 0 to n - m inclusive ;  $  TAB2 for j = 0 to n - m inclusive ;  $  TAB3 the integer value of ok = 1 ;  $  TAB3 for integer p = 0, p is less than m and ok equals 1, increment p by 1 , ok &= !memcmp(&mp[0][i + p][0], &mp[1][p][j], m) ;  $  TAB3 if ok is true ;  $  TAB4 print i + 1 and ' ' and j + 1 and newline ;
TAB0 declare constant integer N = 1e5 + 50 ;  $  TAB0 declare constant integer oo = 1e9 ;  $  TAB0 declare constant integer mod = 1e9 + 7 ;  $  TAB0 declare string arrays a size 2001, b size 201, f1 size 2001, f2 size 2001 ;  $  TAB1 declare integers n, m ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to m exclusive, read b[i] ;  $  TAB1 for i = 0 to i + m is less than or equal to n, incrementing i ;  $  TAB2 let f1[i] be "" ;  $  TAB2 for j = 0 to m exclusive, increment f1[i] by a[i+j] ;  $  TAB1 for i = 0 to i + m is less than or equal to n, incrementing i ;  $  TAB2 let f2[i] be "" ;  $  TAB2 for j = 0 to m exclusive, increment f2[i] by substring of b[j] from i to m ;  $  TAB1 for i = 0 to i + m is less than or equal to n, incrementing i ;  $  TAB2 for j = 0 to j + m is less than or equal to n, incrementing j ;  $  TAB3 if f1[i] is f2[j] ;  $  TAB4 print i + 1, ' ', j + 1, newline ;
TAB0 declare character array mp size 2 by 2001 by 2001 ;  $  TAB1 declare integers n, m ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to n exclusive, read mp[0][i] ;  $  TAB1 for i = 0 to m exclusive, read mp[1][i] ;  $  TAB1 declare integers i, j ;  $  TAB1 for i = 0 to n - m inclusive ;  $  TAB2 for j = 0 to n - m inclusive ;  $  TAB3 declare boolean ok = true ;  $  TAB3 for p = 0 to p is less than m and ok, incrementing p, let ok be ok bitwise and not ( memory compare ( address of mp[0][i + p][0] and address of mp[1][p][j] comparing m bytes ) ) ;  $  TAB3 if ok is true ;  $  TAB4 print i + 1, ' ', j + 1, newline ;
TAB1 n, m = int ;  $  TAB1 read n, m ;  $  TAB1 let v1(2002), v2(202), v3(2002), v4(2002) be vector of string ;  $  TAB1 for i = 0 to n exlcusive, read v[i] ;  $  TAB1 read the first m elements of v2 ;  $  TAB1 for i = 0 until i+m <=n increment i after ;  $  TAB2 for j = 0 to m exlcusive, increment v3 at i by v1[i+j] ;  $  TAB1 for i = 0 until i+m <= n increment i after ;  $  TAB2 for j = 0 to m exclusive, increment v4[j] by substring of v2[j] form i to m ;  $  TAB1 for i = 0 until i+m <= n ;  $  TAB2 for j = 0 until j + m <= n ;  $  TAB3 if v3 at i is v4 at j ;  $  TAB4 print i + 1 << ' ' << j + 1 << ;
TAB1 t = int ;  $  TAB1 read t ;  $  TAB1 loop t times ;  $  TAB2 n, r = int ;  $  TAB2 read n then r ;  $  TAB2 x = int then for i = 1 to n read x then decrement r by x ;  $  TAB2 print (r mod n + n) mod n + 1 ;
TAB1 t, n, r, k = integer ;  $  TAB1 q = integer array of size 5 ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 k = 0 ;  $  TAB2 read n, r ;  $  TAB2 for j = 0 to n - 1 exclusive ;  $  TAB3 read q[j] ;  $  TAB3 k = k + q[j] ;  $  TAB2 print the result of ((r - k) modulo n + n) modulo n + 1 ;
TAB1 test = integer ;  $  TAB1 read test ;  $  TAB1 while looping decrease test by 1 ;  $  TAB2 n, r = integers ;  $  TAB2 read n, r ;  $  TAB2 sum = integer = r ;  $  TAB2 for i = 0 to n - 1 exclusive ;  $  TAB3 val = integer ;  $  TAB3 read val ;  $  TAB3 sum = sum - val ;  $  TAB2 sum = (sum modulo n + n) modulo n ;  $  TAB2 print the result of sum + 1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 while decrement n ;  $  TAB2 create unsigned int a, b and sum, set sum to 0 ;  $  TAB2 read a and b ;  $  TAB2 for i=1 to a exclusive ;  $  TAB3 create int c ;  $  TAB3 read c ;  $  TAB3 set sum to sum + c ;  $  TAB2 assign sum mod a to sum ;  $  TAB2 sum = (a + b - sum) % a ;  $  TAB2 print sum +1 ;
TAB0 create int nums[5], r, n, T ;  $  TAB1 read T ;  $  TAB1 while decrement T ;  $  TAB2 read n and r ;  $  TAB2 set sum to 0 ;  $  TAB2 for c=1 to n exclusive ;  $  TAB3 create int i ;  $  TAB3 read i ;  $  TAB3 set sum to sum -i ;  $  TAB2 set sum = sum +r ;  $  TAB2 assign sum + n*1000 to sum ;  $  TAB2 print sum mod n + 1 ;
TAB0 no, appr, st = long long arrays all with length 300001 ;  $  TAB0 app = long long vector with length 300001 ;  $  TAB1 i, j, n, m, k, cnt, ans, t = long long with cnt and ans having value of 0 and t having value of 1 ;  $  TAB1 read n and t ;  $  TAB1 v = long long vector ;  $  TAB1 pos = long long with value of 0 ;  $  TAB1 while t is not zero subtract 1 from t and do ;  $  TAB2 read m and k ;  $  TAB2 if m equals 1 ;  $  TAB3 set no[cnt] to k ;  $  TAB3 append cnt to the end of app[k] ;  $  TAB3 set st[cnt] to 0 ;  $  TAB3 append cnt to the end of v ;  $  TAB3 add 1 to cnt ;  $  TAB3 add 1 to ans ;  $  TAB2 else if m equals 2 ;  $  TAB3 for i = appr[k] to the size of app[k] exclusive ;  $  TAB4 if st[app[k][i]] equals 0 subtract 1 from ans ;  $  TAB4 set st[app[k][i]] to 1 ;  $  TAB3 set appr[k] to the size of app[k] ;  $  TAB2 else ;  $  TAB3 for i = pos to k exclusive ;  $  TAB4 if st[v[i]] equals 0 subtract 1 from ans ;  $  TAB4 set st[v[i]] to 1 ;  $  TAB3 set pos to the maximum of pos and k ;  $  TAB2 print ans ;
TAB0 MAXN = 3 * 1e5 + 5 ;  $  TAB0 create int N, M, S, x, y, j, z, r ;  $  TAB0 create vector int V[MAXN] ;  $  TAB0 create int v[MAXN] ;  $  TAB0 create bool R[MAXN] ;  $  TAB1 read N and M ;  $  TAB1 while decrement M ;  $  TAB2 read x and y ;  $  TAB2 if x = 1 ;  $  TAB3 assign j to last element of V[y] ;  $  TAB3 increment j ;  $  TAB3 increment S ;  $  TAB2 if x = 2 ;  $  TAB3 set z to size of V[y] ;  $  TAB3 for i=v[y] to z exclusive ;  $  TAB4 if R[V[y][i]] = 0, decrement S ;  $  TAB4 set R[V[y][i]] = true ;  $  TAB3 set v[y] = z ;  $  TAB2 if x = 3 ;  $  TAB3 for i=r to y exclusive ;  $  TAB4 if R[i]=0, decrement S ;  $  TAB4 assign true to R[i] ;  $  TAB3 set r to max of r and y ;  $  TAB2 print S ;
TAB0 create long long m and an array of long longs a with size 200000 ;  $  TAB0 create array of long long pairs b with size 200000 ;  $  TAB0 create long long array cnt with size 200000 ;  $  TAB1 read m ;  $  TAB1 for integer i = 0 to m exclusive read a[i] ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read b[i].first ;  $  TAB2 b[i].second = i ;  $  TAB1 sort array a ;  $  TAB1 sort b ;  $  TAB1 reverse b ;  $  TAB1 for i = 0 to m exclusive, set cnt[b[i].second] to a[i] ;  $  TAB1 for i = 0 to m exclusive, print cnt[i] and " \n"[i == m - 1] ;
