TAB1 declare integers c, small, big, a, l ;  $  TAB1 read c, small, big, a, l ;  $  TAB1 set cnt to 0 ;  $  TAB1 set p to 0 ;  $  TAB1 set v to small ;  $  TAB1 while p < c ;  $  TAB2 increment cnt ;  $  TAB2 if cnt == 1 ;  $  TAB3 increase p by v ;  $  TAB3 set v to min(v + a, big) ;  $  TAB2 else ;  $  TAB3 decrease p by l ;  $  TAB3 increase p by v ;  $  TAB3 set v to min(v + a, big) ;  $  TAB1 write cnt and newline ;
TAB0 in function A, taking int n ;  $  TAB1 let sum, tmp be integers with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read tmp ;  $  TAB2 increase sum by tmp ;  $  TAB1 define ans = 0 ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if((sum + i) % (n + 1) != 1) increment ans ;  $  TAB1 print ans ;  $  TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 call A with n ;
TAB1 let n,a,b,c be long long ints ;  $  TAB1 read n,a,b,c ;  $  TAB1 set n to n%4 ;  $  TAB1 let tot be long long with tot= 4-n ;  $  TAB1 if tot is 4 ;  $  TAB2 print 0 ;  $  TAB1 else do the following ;  $  TAB2 if tot is 1 ;  $  TAB3 print minimum of a and min(b+c, 3*c) ;  $  TAB2 else if tot is 2 ;  $  TAB3 print minimum of 2*a and min(b,2*c) and new line ;  $  TAB2 else if tot is 3 ;  $  TAB3 print minimum of 3*a and min(c,b+a) ;
TAB1 create a,b,c,d,e,f,g integers ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read c ;  $  TAB1 set d= a+b*c ;  $  TAB1 set e=a * (b + c) ;  $  TAB1 set f = a * b * c ;  $  TAB1 set g = (a + b) * c ;  $  TAB1 create integer y= a + b + c ;  $  TAB1 create integers o,p,r ;  $  TAB1 set r to maximum of d and y ;  $  TAB1 set o to maximum of r and e ;  $  TAB1 set p to maximum of f and g ;  $  TAB1 print maximum of o and p ;
TAB0 make integers n and ans with n = 0 and ans = 0 ;  $  TAB0 make integer arrays a and b of size 100005 each ;  $  TAB1 make integer i ;  $  TAB1 read i ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input a[i] ;  $  TAB2 assign a[i] to b[i] ;  $  TAB1 call sort on a + 1 and a + n + 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] doesn't equal b[i] then add 1 to ans ;  $  TAB2 if ans is greater than 2 ;  $  TAB3 print NO ;  $  TAB1 print YES ;
TAB1 t = integer set = 5 ;  $  TAB1 sum = integer set = 0 ;  $  TAB1 while decrementing t by 1 is > 0 ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 increment sum by x ;  $  TAB1 if sum modulo 5 = 0 and sum != 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 read -1 ;
TAB0 graph = array of ints of lengths 105 and 105 ;  $  TAB0 x and y = integer arrays of length 105 each ;  $  TAB0 visited = integer array of length 105, n = integer ;  $  TAB0 in function dfs with integer argument s and return void ;  $  TAB1 assign 1 to visited[s] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if graph[s][i] and visited[i] are equal to 0, then call function dfs with argument i ;  $  TAB1 return ;  $  TAB1 let i, j, and k be integers ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, output x[i] and y[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to j inclusive ;  $  TAB3 if x[i] is equal to x[j] or y[i] is equal to y[j], then assign 1 to graph[i][j] ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if visited[i] is equal to 0 ;  $  TAB3 call function dfs with argument i ;  $  TAB3 increment ans ;  $  TAB1 output ans - 1 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 in = string ;  $  TAB1 read in ;  $  TAB1 temp = char set to 'D' ;  $  TAB1 cnt = integer set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if temp = 'U' and index i of in = 'R' or temp = 'R' and index i of in = 'U' ;  $  TAB3 set temp to 'D' ;  $  TAB2 else if temp = 'U' and index i of in = 'U' or temp = 'R' and index i of in = 'R' ;  $  TAB3 increment cnt by 1 ;  $  TAB2 else ;  $  TAB3 if index i of in = 'U' ;  $  TAB4 set temp = 'U' ;  $  TAB4 increment cnt by 1 ;  $  TAB3 else ;  $  TAB4 set temp = 'R' ;  $  TAB4 increment cnt by 1 ;  $  TAB1 read cnt ;
TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 l = integer with l = size of s ;  $  TAB1 if s[0] is greater than or equal to the character a and s[0] is less than or equal to the character z ;  $  TAB2 output s[0] - 32 as a character ;  $  TAB1 else ;  $  TAB2 output s[0] ;  $  TAB1 for i = 1 to 1 exclusive, output s[i] ;  $  TAB1 output newline ;
TAB1 create long long integer q ;  $  TAB1 read q ;  $  TAB1 if q modulo 4 is equal to 0 or q modulo 4 is equal to 3 ;  $  TAB2 output 0 ;  $  TAB1 else ;  $  TAB2 print "1" ;
TAB1 n = long long ;  $  TAB1 input n ;  $  TAB1 if n mod 2 equals 0 ;  $  TAB2 output Mahmoud ;  $  TAB1 else ;  $  TAB2 output Ehab ;
TAB1 create integers a1, a2, a3, a4, a5, a6 ;  $  TAB1 read a1, a2, a3, a4, a5, a6 ;  $  TAB1 create integer answer=0 ;  $  TAB1 answer = answer + (a1 + a2 + a3) * (a1 + a2 + a3) ;  $  TAB1 answer = answer - a1*a1 ;  $  TAB1 answer = answer - a5*a5 ;  $  TAB1 answer = answer - a3*a3 ;  $  TAB1 print answer and a new line ;
TAB1 create long long integers n,a,b,c ;  $  TAB1 read n,a,b,c ;  $  TAB1 let long long integer k= n%4 ;  $  TAB1 if k is equal to 0 ;  $  TAB2 print 0 and newline ;  $  TAB1 else if k is equal to 3 then do the following ;  $  TAB2 if a<=b+c and a<=3*c ;  $  TAB3 print a ;  $  TAB2 else if b+c<=3*c then ;  $  TAB3 print b+c ;  $  TAB2 else do the following ;  $  TAB3 print 3*c ;  $  TAB1 else if k is equal to 2 ;  $  TAB2 if 2 * a <= b and 2 * a <= 2 * c ;  $  TAB3 print 2*a ;  $  TAB2 else if b<=2*c then do the following ;  $  TAB3 print b and new line ;  $  TAB2 else do the following ;  $  TAB3 print 2*c ;  $  TAB1 else if k is equal to 1 ;  $  TAB2 if 3 * a <= (a + b) and 3 * a <= c ;  $  TAB3 print 3*a ;  $  TAB2 else if a+b<=c then do the following ;  $  TAB3 print a+b and new line ;  $  TAB2 else do the following ;  $  TAB3 print c ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 while n is greater than 0 while decrementing n by 1 ;  $  TAB2 a = integer ;  $  TAB2 read a ;  $  TAB2 if a = 1 ;  $  TAB3 print "HARD\n" ;  $  TAB3 exit loop ;  $  TAB1 read "EASY\n" ;
TAB0 create long long integers x1 and yy1 ;  $  TAB0 create long long integers x2 and y2 ;  $  TAB1 read x1 and yy1 ;  $  TAB1 read x2 and y2 ;  $  TAB1 d = long long integer with d = max(absolute value of x1 - x2, absolute value of yy1 - y2) ;  $  TAB1 output d ;
TAB1 n = integer ;  $  TAB1 s = string ;  $  TAB1 read n and s ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if index i of s = 'o' and index i + 1 of s = 'g' and index i + 2 of s = 'o' ;  $  TAB3 increment i + 2 ;  $  TAB3 while index i + 1 of s = 'g' and index i + 2 = 'o', increment i + 2 ;  $  TAB3 print '***' ;  $  TAB2 else ;  $  TAB3 read index i of s ;  $  TAB1 newline ;
TAB1 a, b, c = integers ;  $  TAB1 read a, b, c ;  $  TAB1 increment a by 1 ;  $  TAB1 while decrementing a by 1 is greater than 0 ;  $  TAB2 if b is greater than or equal to 2 * a and c is greater than or equal to 4 * a, break loop ;  $  TAB1 print a + 2 * a + 4 * a ;
TAB1 create long long integers n and m ;  $  TAB1 read n and m ;  $  TAB1 create integer array f of size n+1 ;  $  TAB1 create integer array s of size n+1 ;  $  TAB1 read n values into array f ;  $  TAB1 ready m values into array s ;  $  TAB1 create integer rs= INT_MAX ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive ;  $  TAB3 if f[i] is equal to s[j] ;  $  TAB4 set rs to minimum of rs and f[i] ;  $  TAB3 else do the following ;  $  TAB4 set rs to minimum of rs and f[i]*10 +s[j] ;  $  TAB4 set rs to minimum of rs and s[j]*10 + f[i] ;  $  TAB1 print rs ;  $  TAB1 Don't do anything ;
TAB1 create integers n and k ;  $  TAB1 create string s ;  $  TAB1 read n and k ;  $  TAB1 read s ;  $  TAB1 create integer array a of size 26 and assign 0 to a ;  $  TAB1 for i = 0 to n exclusive, increment a[s[i] - the character A] ;  $  TAB1 let min be an int with min = 100005 ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 if a[i] is less than min, then assign a[i] to min ;  $  TAB1 output min * k ;
TAB1 let a be an integer ;  $  TAB1 let s1 be an integer with s1 = 0 ;  $  TAB1 let s2 be an integer with s2 = 0 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 p is an int ;  $  TAB2 input p ;  $  TAB2 assign s1 + p to s1 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 p is an integer ;  $  TAB2 input p ;  $  TAB2 assign s2 + p to s2 ;  $  TAB1 n = int ;  $  TAB1 input n ;  $  TAB1 r = int with r = s1 / 5 ;  $  TAB1 k = int with k = s2 / 10 ;  $  TAB1 p1 = int with p1 = s1 nod 5 ;  $  TAB1 p2 = int with p2 = s2 mod 10 ;  $  TAB1 create integer f with f = 0 ;  $  TAB1 if p1 and p2 are equal to zero then assign 1 to f ;  $  TAB1 if (r + k is less than or equal to (n - 2) ) ;  $  TAB2 output YES ;  $  TAB1 else if the sum of r and k equals n and f equals 1 ;  $  TAB2 output YES ;  $  TAB1 else if ((r + k is less than or equal to n - 1 and p1 equals 0) || (r + k is less than or equal to n - 1 and p2 equals 0)) ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB1 create integers n and m ;  $  TAB1 read n and m ;  $  TAB1 create integer vector a of size n ;  $  TAB1 create integer vector b of size m ;  $  TAB1 read n values into array a ;  $  TAB1 read m values into array b ;  $  TAB1 create integer ans=100500 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive ;  $  TAB3 if a[i]= b[j] then do the following ;  $  TAB4 set ans to minimum of ans and a[i] ;  $  TAB3 else do the following ;  $  TAB4 set ans to minimum of ans and a[i] * 10 + b[j] ;  $  TAB4 set ans to minimum of ans and b[i] * 10 + a[j] ;  $  TAB1 print ans ;
TAB1 create integers a,b,c,d,e,f,s1,u,sum,res,n and sum=-9999 ;  $  TAB1 create strings s and s2 ;  $  TAB1 input n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 input s,s1,u,a,b,c,d,e ;  $  TAB2 res=s1 * 100 - u * 50 + a + b + c + d + e ;  $  TAB2 if res>sum ;  $  TAB3 set sum=res ;  $  TAB3 set s2=s ;  $  TAB1 print s2 ;
TAB0 declare function gcd that takes integers a and b and returns int ;  $  TAB1 return b ? call gcd(b, a % b) : a ;  $  TAB1 a, b, n, simon = integers with simon = 1 ;  $  TAB1 input a, b, and n ;  $  TAB1 while n is equal to 1 ;  $  TAB2 if simon is equal to 1 ;  $  TAB3 set n to n - gcd(max(n, a), min(n, a)), set simon to 0 ;  $  TAB2 else ;  $  TAB3 set n to n - gcd(max(n, b), min(n, b), set simon to 1 ;  $  TAB1 output simon ;
TAB1 s = string ;  $  TAB1 print s ;  $  TAB1 contiguous = integer with value of 1 ;  $  TAB1 iterate i through the indices of s ;  $  TAB2 if index i of s = index i - 1 of s ;  $  TAB3 increment contiguous ;  $  TAB3 if contiguous = 7 ;  $  TAB4 print YES ;  $  TAB2 else ;  $  TAB3 set contiguous = 1 ;  $  TAB1 print NO ;
TAB1 create integers a, b, c, d, w, x, y, z, j, v ;  $  TAB1 read a, b, and c ;  $  TAB1 set w to a + (b * c) ;  $  TAB1 set x to a * (b + c) ;  $  TAB1 set y to a * b * c ;  $  TAB1 set z to (a + b) * c ;  $  TAB1 set v to a + b + c ;  $  TAB1 if w is greater than or equal to x and w is greater than or equal to y and w is greater than or equal to z and x is greater than or equal to v ;  $  TAB2 output w ;  $  TAB1 else if x is greater than or equal to w and x is greater than or equal to y and x is is greater than or equal to z and x is greater than or equal to v ;  $  TAB2 output x ;  $  TAB1 else if y is greater than or equal to w and y is greater than or equal to x and y is greater than or equal to z and y is greater than or equal to v ;  $  TAB2 output y ;  $  TAB1 else if z is greater than or equal to w and z is greater than or equal to x and is greater than or equal to y and z is greater than or equal to v ;  $  TAB2 output z ;  $  TAB1 else if v is greater than w and v is greater than x and v is greater than y and v is greater than z ;  $  TAB2 output v ;
TAB1 let a, b, and c be ints ;  $  TAB1 while read a, b, and c ;  $  TAB2 p = integer array of size 6, max = integer, i = integer ;  $  TAB2 set p[0] to a + b + c ;  $  TAB2 set p[1] to (a + b) * c ;  $  TAB2 set p[2] to a * (b + c) ;  $  TAB2 set p[3] to a * b * c ;  $  TAB2 set p[4] to a + b * c ;  $  TAB2 set p[5] to a * b + c ;  $  TAB2 assign p[0] to max ;  $  TAB2 for i = 1 to 6 exclusive ;  $  TAB3 if p[i] is less than max, then assign p[i] to max ;  $  TAB2 output max ;
TAB1 n = int, n = int array of size 100, sum, cnt = ints with sum = 0 and cnt = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input a[i] ;  $  TAB2 sum is assigned sum + a[i] ;  $  TAB1 for i = 1 to 6 exclusive ;  $  TAB2 if (sum + i) modulo (n+1) doesn't equal 1, then add 1 to cnt ;  $  TAB1 output cnt ;
TAB1 t, i, x, y, j, f = integers ;  $  TAB1 read t ;  $  TAB1 let a be an integer array of sizes t and 2 ;  $  TAB1 for j = 0 to t exclusive ;  $  TAB2 for i = 0 to 1 exclusive, read a[j][i] ;  $  TAB1 for i = 0 to t exclusive, print a[i][0] and (a[i][1] / a[i][0]) * a[i][0] ;
TAB1 n = integer, ans = integer = 0 ;  $  TAB1 create character temp ;  $  TAB1 read n ;  $  TAB1 let turn be an integer with turn = 1 ;  $  TAB1 create bool array act with length of 3 with act = {0, 1, 0} ;  $  TAB1 while read temp ;  $  TAB2 make bool t with t = (temp == 'a' ? 1 : 0) ;  $  TAB2 if turn mod n is equal to 1 and act[0] is equal to act[1] and act[1] is equal to act[2], then increment ans ;  $  TAB2 if turn mod n is equal to 0 ;  $  TAB3 set act[2] to t ;  $  TAB2 else if turn mod n is equal to n - 1 ;  $  TAB3 set act[1] to t ;  $  TAB2 else if turn mod n is equal to n - 2 ;  $  TAB3 set act[0] to t ;  $  TAB2 increment turn ;  $  TAB1 output ans ;
TAB0 a = integer array of size 12 ;  $  TAB0 pic = integer array of sizes 100 and 100 ;  $  TAB0 in the function printall ;  $  TAB1 for i = 1 to 6 inclusive ;  $  TAB2 for j = 1 to 27 inclusive ;  $  TAB3 if pic[i][j] is equal to 1, then print "+" ;  $  TAB3 if pic[i][j] is equal to 2, then print "-" ;  $  TAB3 if pic[i][j] is equal to 3, then print "|" ;  $  TAB3 if pic[i][j] is equal to 4, then print "O" ;  $  TAB3 if pic[i][j] is equal to 5, then print "." ;  $  TAB3 if pic[i][j] is equal to 6, the print "#" ;  $  TAB3 if pic[i][j] is equal to 7, then print ")" ;  $  TAB3 if pic[i][j] is equal to 8, then print D ;  $  TAB2 output endline ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n is less than or equal to 1 ;  $  TAB2 decrement n ;  $  TAB2 increment a[1] ;  $  TAB1 ii = int with ii set to 1 ;  $  TAB1 while n is greater than 0 ;  $  TAB2 if n is less than or equal to 3 ;  $  TAB3 set a[ii] to the sum of a[ii] and n ;  $  TAB3 set n to 0 ;  $  TAB2 else ;  $  TAB3 set a[ii] to the sum of a[ii] and 3 ;  $  TAB3 set n to n - 3 ;  $  TAB3 increment ii ;  $  TAB1 set pic[1][1], pic[1][26], pic[6][1], and pic[6][26] to 1 ;  $  TAB1 for int i = 2 to 25 inclusive, set pic[1][i] and pic[6][i] to 2 ;  $  TAB1 for int i = 2 to 5 inclusive, set pic[i][1] and pic[i][26] to 3 ;  $  TAB1 set pic[2][27] and pic[5][27] to 7 ;  $  TAB1 for i = 3 to 25 inclusive by increasing i by 2 ;  $  TAB2 for j = 3 to 5 inclusive ;  $  TAB3 assign 5 to pic[j][i] ;  $  TAB3 if j is equal to 2 and i is equal to 25, then set pic[j][i] to 8 ;  $  TAB1 for i = 3 to 25 inclusive, set pic[4][i] to 5 ;  $  TAB1 assign 3 to pic[2][24], pic[3][24], and pic[5][24] ;  $  TAB1 if a[1] is equal to 4, then assign 4 to pic[2][2], pic[3][2], pic[5][2], and pic[4][2] ;  $  TAB1 if a[1] is equal to 0, then assign 6 to pic[2][2], pic[3][2], pic[5][2], and pic[4][2] ;  $  TAB1 if a[1] is equal to 3 ;  $  TAB2 set pic[2][2], pic[3][2], and pic[4][2] to 4 ;  $  TAB2 set pic[5][2] to 6 ;  $  TAB1 if a[1] is equal to 2 ;  $  TAB2 set pic[2][2] and pic[3][2] to 4 ;  $  TAB2 set pic[5][2] and pic[4][2] to 6 ;  $  TAB1 if a[1] is equal to 1 ;  $  TAB2 set pic[2][2] to 4 ;  $  TAB2 assign 6 to pic[5][2], pic[4][2], and pic[3][2] ;  $  TAB1 for i = 2 to 11 inclusive ;  $  TAB2 if a[i] is equal to 3, assign 4 to pic[2][i * 2], pic[3][i * 2], and pic[5][i * 2] ;  $  TAB2 if a[i] is equal to 0, assign 6 to pic[2][i * 2], pic[3][i * 2], and pic[5][i * 2] ;  $  TAB2 if a[i] is equal to 1 ;  $  TAB3 set pic[2][i * 2] to 4 ;  $  TAB3 assign 6 to pic[3][i * 2] and pic[5][i * 2] ;  $  TAB2 if a[i] is equal to 2 ;  $  TAB3 assign 4 to pic[2][i * 2] and pic[3][i * 2] ;  $  TAB3 set pic[5][i * 2] to 6 ;  $  TAB1 call printall ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 n, y, c = integer set to 0 ;  $  TAB1 iterate i through the indices of s ;  $  TAB2 for j = i to n exclusive ;  $  TAB3 if index j of s = 'U' ;  $  TAB4 increment x by 1 ;  $  TAB3 else if index j of s = 'D' ;  $  TAB4 decrement x by 1 ;  $  TAB3 else if index j of s = 'R' ;  $  TAB4 increment y by 1 ;  $  TAB3 else ;  $  TAB4 decrement y by 1 ;  $  TAB3 if x = 0 and y = 0 increment c by 1 ;  $  TAB2 set x and y to 0 ;  $  TAB1 print c ;
TAB1 let sum1 and sum2 be integers with sum1 = 0 and sum2 = 0 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 set sum1 to sum1 + x ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 set sum2 to sum2 + x ;  $  TAB1 create integer cnt with cnt = (sum1 + 4) / 5 + (sum2 + 9) / 10 ;  $  TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 puts(cnt <= n ? "YES" : "NO") ;  $  TAB1 return 0 ;
TAB0 in the function power with arguments long long int x, long long int n, long long int m and return long long int ;  $  TAB1 if n is 0, then return 1 ;  $  TAB1 if n is 1, then return x ;  $  TAB1 x is assigned x mod m ;  $  TAB1 if n mod 2 is true, then return (x * (power((x * x) % m, n / 2, m) % m)) % m ;  $  TAB1 return power((x * x) % m, n / 2, m) mod m ;  $  TAB1 make long long integers hy, ay, dy, hm, am, dm, h, a, d ;  $  TAB1 read hy, ay, dy, hm, am, dm, h, a, d ;  $  TAB1 make long long integer ans with ans = 1000000000000000 ;  $  TAB1 for long long integer atk = ay to 200 inclusive ;  $  TAB2 for long long integer def = dy to 100 inclusive ;  $  TAB3 if atk is less than or equal to dm, then continue ;  $  TAB3 make long long integer t with t = hm / (atk - dm) ;  $  TAB3 if hm modulo (atk - dm) is not 0, then increment t ;  $  TAB3 make long long integer hr with hr = t * (max(0LL, am - def)) + 1 ;  $  TAB3 make long long integer cost with cost = 0 ;  $  TAB3 if hr is greater than hy, then add ((hr - hy) * h) to cost ;  $  TAB3 if atk is greater than ay, then add ((atk - ay) * a) to cost ;  $  TAB3 if def is greater than dy, then add ((def - dy) * d) to cost ;  $  TAB3 if ans is greater than cost, set ans to cost ;  $  TAB1 output ans ;
TAB1 let t, red, green, blue be ints with t = 29 ;  $  TAB1 read red, green, and blue ;  $  TAB1 while red is greater than 0 or green is greater than 0 or blue is greater than 0 ;  $  TAB2 increment t ;  $  TAB2 assign red - 2 to red ;  $  TAB2 if red is less than or equal to 0 and green is less than or equal to 0 and blue is less than or equal to 0, then break ;  $  TAB2 increment t ;  $  TAB2 assign green - 2 to green ;  $  TAB2 if red is less than or equal to 0 and green is less than or equal to 0 and blue is less than or equal to 0, then break ;  $  TAB2 increment t ;  $  TAB2 assign blue - 2 to blue ;  $  TAB2 if red is less than or equal to 0 and green is less than or equal to 0 and blue is less than or equal to 0, then break ;  $  TAB1 output t ;
TAB0 in function mina with integers a and b ;  $  TAB1 if a is less then or equal to b ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return b ;  $  TAB1 in function main ;  $  TAB1 read x and y ;  $  TAB1 set m to value of function mina with x / 2 and y / 24 ;  $  TAB1 decrement x by m * 2 ;  $  TAB1 decrement y by m * 24 ;  $  TAB1 if x equals 1 and y is greater than or equal to 34 ;  $  TAB2 set x to 0 ;  $  TAB2 decrement y by 34 ;  $  TAB1 if x equals 0 decrements y by y / 44 * 44 ;  $  TAB1 set m to mina with values x / 3 and y /14 ;  $  TAB1 decrement x by m * 3 ;  $  TAB1 decrement y by m * 14 ;  $  TAB1 set m to mina with values x / 4 and y / 4 ;  $  TAB1 decrement x by m * 4 ;  $  TAB1 decrement y by m * 4 ;  $  TAB1 if x is greater than or equal 2 and y is greater than or equal to 2 or x is greater than or equal to 1 and y is greater than or equal to 12 or y is greater than or equal to 22 ;  $  TAB2 print Ciel\n ;  $  TAB1 else ;  $  TAB2 print Hanako\n ;
TAB0 target = long long integer ;  $  TAB1 test = integer ;  $  TAB1 read test ;  $  TAB1 a, b = integer ;  $  TAB1 while test decremented - 1 is greater than 0 ;  $  TAB2 read a and b ;  $  TAB2 set target = 111 * a * b ;  $  TAB2 low, high = integers, low set = 1 and high set = 100000 ;  $  TAB2 if a = 1 and b = 1 ;  $  TAB3 print "Yes\n" ;  $  TAB3 continue ;  $  TAB2 if a = 1 and b doesn't = 1 or b = 1 and a doesn't = 1 ;  $  TAB3 print "No\n" ;  $  TAB3 continue ;  $  TAB2 while low is less than high ;  $  TAB3 mid = integer set = low + high / 2 ;  $  TAB3 if 111 * mid * mid * mid is less than target ;  $  TAB4 set low = mid + 1 ;  $  TAB3 else ;  $  TAB4 set high = mid ;  $  TAB2 if 111 * low * low * low = target and a modulo low = 0 and b modulo low = 0 ;  $  TAB3 print "Yes\n" ;  $  TAB2 else ;  $  TAB3 print "No\n" ;
TAB0 make integer n ;  $  TAB0 make integer array a of size 100005 ;  $  TAB0 make integer array a2 of size 100005 ;  $  TAB1 make integer cnt with cnt = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 assign a[i] to a2[i] ;  $  TAB1 call sort on a and a + n ;  $  TAB1 for i = 0 to n exclusive, cnt is assigned cnt + (a[i] is not equal to a2[i]) ;  $  TAB1 if cnt is less than or equal to 2 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n= integer ;  $  TAB1 input n ;  $  TAB1 let x be integer and x=0 ;  $  TAB1 while n>0 and decrement n ;  $  TAB2 increment x ;  $  TAB2 let s and d be integer ;  $  TAB2 input s and d ;  $  TAB2 if x is less than s ;  $  TAB3 set x=s ;  $  TAB2 else ;  $  TAB3 while (x - s) % d is true, increment x ;  $  TAB1 output x ;
TAB1 n, a, b, c = long long integers ;  $  TAB1 read n, a, b and c ;  $  TAB1 ans = long long integer set to 0x3f3f3f3f ;  $  TAB1 if n modulo 4 = 0 ;  $  TAB2 print '0' ;  $  TAB1 else ;  $  TAB2 for k = 0 to 4 inclusive ;  $  TAB3 for i = 0 to 4 inclusive ;  $  TAB4 for j = 0 to 4 inclusive ;  $  TAB5 if (n + k + i * 2 + j * 3) modulo 4 = 0, set ans to min of ans or k * a + i * b + j * c ;  $  TAB2 print ans ;
TAB1 let a, b, c, x, y, z, and n be long longs ;  $  TAB1 read a, b, c, x, y, z, and n ;  $  TAB1 p = long long with p = (a + b + c + 4) / 5 ;  $  TAB1 q = long long with q = (x + y + z + 9) / 10 ;  $  TAB1 if the sum of p and q is less than or equal to n ;  $  TAB2 print YES ;  $  TAB3 output newline ;  $  TAB1 else ;  $  TAB2 print NO ;  $  TAB3 output newline ;
TAB1 declare integers a1, a2, a3, a4, a5, a6 ;  $  TAB1 read a1, a2, a3, a4, a5, a6 ;  $  TAB1 define int triangulo = (a1 + a2 + a3)^2 ;  $  TAB1 decrease triangulo by a1^2 ;  $  TAB1 decrease triangulo by a3^2 ;  $  TAB1 decrease triangulo by a5^2 ;  $  TAB1 print triangulo ;
TAB1 let n, a, b, c, x, y, z be integers with x = 0, y = 0, z = 0 ;  $  TAB1 input n ;  $  TAB1 while decrement n ;  $  TAB2 read a, b, and c ;  $  TAB2 set x to x + a ;  $  TAB2 set y to y + b ;  $  TAB2 set z to z + c ;  $  TAB1 if x is equal to 0 and y is equal to 0 and z is equal to 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 n, m, k, maxm = long long integers ;  $  TAB0 d, s = arrays of long long integers with length of 2002 ;  $  TAB1 read m and k ;  $  TAB1 set n = m + 1 ;  $  TAB1 for i = 1 to m inclusive read index i of d ;  $  TAB1 for i = 1 to m inclusive read index i of s ;  $  TAB1 pet = long long integer set = 0 ;  $  TAB1 ans = long long integer set = 0 ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 increment pet by index i of s ;  $  TAB2 set maxm = max of maxm and index i of s ;  $  TAB2 if pet - index i of d >= 0 ;  $  TAB3 decrement pet by index i of d ;  $  TAB3 increment ans by index i of d ;  $  TAB3 continue ;  $  TAB2 req = long long integer set to index i of d - pet ;  $  TAB2 x = long long integer set to req / maxm ;  $  TAB2 if req modulo maxm != 0, increment x + 1 ;  $  TAB2 increment ans by index i of d ;  $  TAB2 increment ans by x * k ;  $  TAB2 increment pet by x * maxm ;  $  TAB2 decrement pet by index i of d ;  $  TAB1 print ans ;
TAB0 in function min with integers a, b and return integer ;  $  TAB1 if a is less than b ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return b ;  $  TAB1 let n be long long integer ;  $  TAB1 input n ;  $  TAB1 let a be integer pointer with a = new int[n] ;  $  TAB1 let b be integer pointer with b = new int[n] ;  $  TAB1 let count be integer with count = 0 ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 input a[i] ;  $  TAB2 set a[i] to b[i] ;  $  TAB1 call function sort with arguments b, b + n ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 if a[i] isn't equal to b[i], then increment count ;  $  TAB2 if count is greater than 2 ;  $  TAB3 print NO ;  $  TAB1 print YES ;
TAB0 in function power that takes in long long int x and long long int y and returns long long int ;  $  TAB1 create long long int temp ;  $  TAB1 if y equals 0 then return 1 ;  $  TAB1 temp = the function power with arguments x, y / 2 ;  $  TAB1 if y modulo 2 is 0 ;  $  TAB2 return temp * temp ;  $  TAB1 else ;  $  TAB2 if y is greater than 0 ;  $  TAB3 return x * temp * temp ;  $  TAB2 else ;  $  TAB3 return (temp * temp) / x ;  $  TAB0 let prime be a bool array of size 10000000 ;  $  TAB0 in the function sieve ;  $  TAB1 call memset on prime, true, and sizeof(prime) ;  $  TAB1 prime at index 0 is assigned prime at index 1 is set to false ;  $  TAB1 for p = 2 to 10000000 inclusive ;  $  TAB2 if prime at index p is true ;  $  TAB3 for p * 2 to 10000000 inclusive, prime at index i is set to false ;  $  TAB0 in function gcd that takes in long long ints a and b and returns long long int ;  $  TAB1 if a is equal to 0, then return b ;  $  TAB1 return gcd with arguments b mod a and a ;  $  TAB1 let n and m be long long ints ;  $  TAB1 input n and m ;  $  TAB1 let f be a long long int with f set to 0 ;  $  TAB1 for i = 0 to 100000 exclusive ;  $  TAB2 if n mod m is equal to 0 ;  $  TAB3 f is assigned 1 ;  $  TAB3 break ;  $  TAB2 n is set to n + n mod m ;  $  TAB1 if f is equal to 0 ;  $  TAB2 output No ;  $  TAB3 output newline ;  $  TAB1 else ;  $  TAB2 output Yes ;  $  TAB3 output newline ;
TAB1 let k, l, m, n, d be integers ;  $  TAB1 read k, l, m, n, d ;  $  TAB1 let arr = integer pointer with arr = new integer array of size d ;  $  TAB1 let counter be integer with counter = 0 ;  $  TAB1 for i = 0 to d exclusive ;  $  TAB2 create integer j and assign i + 1 to it ;  $  TAB2 if j modulo k equals 0, then set arr[i] to 1 ;  $  TAB2 if j modulo l equals 0, then set arr[i] to 1 ;  $  TAB2 if j modulo m equals 0, then set arr[i] to 1 ;  $  TAB2 if j modulo n equals 0, then set arr[i] to 1 ;  $  TAB2 if [arr[i] equals 1, then increment counter ;  $  TAB1 output counter ;
TAB1 a = array of integers size 5 and s = integer set to 0 ;  $  TAB1 for int = 0 to 5 exclusive ;  $  TAB2 read index i of a ;  $  TAB2 increment s by index i of a ;  $  TAB1 if s modulo 5 = 0 and s != 0 ;  $  TAB2 print s / 5 ;  $  TAB1 else ;  $  TAB2 print "-1\n" ;
TAB0 make constant integer INF with INF = (int)1e8 ;  $  TAB0 dat = integer array of size 55, h1, h2, a, b, c, d, and e are integers ;  $  TAB0 s = string array of size 55 ;  $  TAB1 let n be an integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s[i], h1, h2, a, b, c, d, and e ;  $  TAB2 set dat[i] to h1 * 100 - h2 * 50 + a + b + c + d + e ;  $  TAB1 make integer mx with mx = -INF ;  $  TAB1 make integer ans with ans = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if dat[i] is greater than mx ;  $  TAB3 assign dat[i] to mx ;  $  TAB3 assign i to ans ;  $  TAB1 output s[ans] ;
TAB1 n, flag = integers ;  $  TAB1 while reading n ;  $  TAB2 sum, minx and xx = long long integer with sum and minx set to 0 ;  $  TAB2 set flag = 1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read xx ;  $  TAB3 if xx modulo 2 doesn't = 0 and flag = 1 ;  $  TAB4 set flag = 0 ;  $  TAB4 set minx = xx ;  $  TAB3 if xx modulo 2 doesn't = 0 and minx is greater than or equal to xx, set minx = xx ;  $  TAB3 increment sum by xx ;  $  TAB2 if sum modulo 2 = 0 ;  $  TAB3 read sum ;  $  TAB2 else ;  $  TAB3 read sum - minx ;
TAB0 create long long int p=998244353 ;  $  TAB0 create long long int ans=0 ;  $  TAB0 in the function read that returns an integer ;  $  TAB1 create integer x=0 and f=1 ;  $  TAB1 read c ;  $  TAB1 while c<0 or c>9 do the following ;  $  TAB2 if c = - then set f to -1 ;  $  TAB2 read c ;  $  TAB1 while c>= 0 and c<=9 then set x=(x << 1) + (x << 3) + (c ^ 48) and read c ;  $  TAB1 return x*f ;  $  TAB1 in the function main ;  $  TAB1 create long long int n and m ;  $  TAB1 read n and m ;  $  TAB1 create integers dig_n=0 and dig_m=0 ;  $  TAB1 create integer arrays count_n and count_m of size 7 each ;  $  TAB1 create integer ans=0 ;  $  TAB1 call memset of count_n,0 and sizeof(count_n) ;  $  TAB1 call memset of count_m,0 and sizeof(count_m) ;  $  TAB1 while a is not 0 ;  $  TAB2 set a=a/7 ;  $  TAB2 increment dig_n ;  $  TAB1 while b is not 0 ;  $  TAB2 set b=b/7 ;  $  TAB2 increment dig_m ;  $  TAB1 if n=1 then set dig_n to 1 ;  $  TAB1 if m=1 then set dig_m to 1 ;  $  TAB1 if dig)_n + dig_m > 7 ;  $  TAB2 print 0 ;  $  TAB1 else do the following ;  $  TAB2 for i=0 to n-1 inclusive ;  $  TAB3 call memset of count_n,0 and sizeof(count_n) ;  $  TAB3 set a=i ;  $  TAB3 create integer ch=0 ;  $  TAB3 let count be an integer with count=0 ;  $  TAB3 while count is less than dig_n ;  $  TAB4 create integer r=a mod 7 ;  $  TAB4 set a=a/7 ;  $  TAB4 if count_n[r] is not 0 ;  $  TAB5 then set ch=1 ;  $  TAB5 break ;  $  TAB4 else do the following ;  $  TAB5 set count_n[r] = 1 ;  $  TAB4 add 1 to count ;  $  TAB3 if ch is 1 then continue ;  $  TAB3 for j=0 to m-1 inclusive ;  $  TAB4 call memset of count_m,0 and sizeof(count_m) ;  $  TAB4 set b=j ;  $  TAB4 create integer ch=0 ;  $  TAB4 let count be an integer with count=0 ;  $  TAB4 while count is less than dig_m ;  $  TAB5 create integer r=b mod 7 ;  $  TAB5 set b=b/7 ;  $  TAB5 if count_n[r] is not 0 or count_m[r] is not 0 ;  $  TAB6 set ch to 1 ;  $  TAB6 break ;  $  TAB5 else do the following ;  $  TAB6 set count_m[r]=1 ;  $  TAB5 add 1 to count ;  $  TAB4 if ch is 1 ;  $  TAB5 then continue ;  $  TAB4 else do the following ;  $  TAB5 add 1 to ans ;  $  TAB2 print ans ;
TAB1 n = long long, k = long long ;  $  TAB1 input n, k ;  $  TAB1 if k is less than or equal to ((n + 1) / 2) ;  $  TAB2 output (k * 2) - 1 ;  $  TAB1 else ;  $  TAB2 output (k - (n + 1) / 2) * 2 ;
TAB0 let N = int, A = int, P = int array of size 3, and H = int ;  $  TAB1 input N ;  $  TAB1 for i = 1 to N inclusive ;  $  TAB2 input A ;  $  TAB2 increment P[A] ;  $  TAB1 call min with arguments P[2], P[1] and assign it to H ;  $  TAB1 set H to H - P[2] ;  $  TAB1 set H to H - P[1] ;  $  TAB1 output H + P[1] / 3 ;
TAB1 n,z=integers with z=0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 z=z+x ;  $  TAB1 create integer c=0 ;  $  TAB1 for i=1 to 5 inclusive ;  $  TAB2 if (z + i) % (n + 1) is not 1 then increment c ;  $  TAB1 print c and newline ;
TAB0 y, m and s = arrays of length 5 ;  $  TAB0 ans, atkm, atky, mm, my, j, i, sum = integers ;  $  TAB1 for i = 1 to 3 inclusive, read index i of y ;  $  TAB1 for i = 1 to 3 inclusive, read index i of m ;  $  TAB1 for i = 1 to 3 inclusive, read index i of s ;  $  TAB1 set ans = 999999 ;  $  TAB1 for i = 0 to 200 inclusive ;  $  TAB2 for j = 0 j to 200 inclusive ;  $  TAB3 set sum = index 3 of s * j + index 2 of s * i ;  $  TAB3 set atky = i + index 2 of y - index 3 of m ;  $  TAB3 set atkm = index 2 of m - j - index 3 of y ;  $  TAB3 if atky is less than or equal to 0, continue ;  $  TAB3 if atkm is less than or equal to 0 ;  $  TAB4 set ans = the smaller number between ans and sum ;  $  TAB4 continue ;  $  TAB3 if index 1 of m modulo atky doesn't = 0 ;  $  TAB4 set mm = index 1 of m / atky + 1 ;  $  TAB3 else ;  $  TAB4 set mm = index 1 of m / atky ;  $  TAB3 if index 1 of y modulo atkm doesn't = 0 ;  $  TAB4 set my = index 1 of y / atkm + 1 ;  $  TAB3 else ;  $  TAB4 set my = index 1 of y / atkm ;  $  TAB3 if my is less than = mm, increment sum by (mm* atkm + 1 - index 1 of y) * index 1 of s ;  $  TAB3 set ans = the smaller number between ans and sum ;  $  TAB1 print ans ;
TAB1 declare integers a, b, st ;  $  TAB1 read a, b, st ;  $  TAB1 x, st_taken = integers with x = 0 ;  $  TAB1 while st != 0 ;  $  TAB2 st_taken = __gcd(a, st) ;  $  TAB2 set st to st - st_taken ;  $  TAB2 increment x ;  $  TAB2 swap a and b ;  $  TAB1 if x is odd ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 x = integer set to 0 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i to n exclusive ;  $  TAB2 str = string ;  $  TAB2 read str ;  $  TAB2 iterate j through the indices of str ;  $  TAB3 if index of str at j = '+' ;  $  TAB4 increment x by 1 ;  $  TAB4 exit loop ;  $  TAB3 if index of str at j = '-' ;  $  TAB4 decrement x by 1 ;  $  TAB4 exit loop ;  $  TAB1 print x ;
TAB1 create a integer n ;  $  TAB1 create integer m, t, k with t=0 and k=0 ;  $  TAB1 input n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read m ;  $  TAB2 if m=1 then increment t ;  $  TAB2 if m=2 then add 1 to k ;  $  TAB1 if k>=t ;  $  TAB2 print t ;  $  TAB1 else do the following ;  $  TAB2 print k+(t-k) /3 ;
TAB0 n = long long integer ;  $  TAB1 read n ;  $  TAB1 if n doesn't equal 0, then increment n ;  $  TAB1 if n mod 2 is equal to 0 ;  $  TAB2 output n / 2 ;  $  TAB1 else ;  $  TAB2 output n ;
TAB1 create long long integers x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,ans ;  $  TAB1 read x1,x2,x3,x4,x5,x6 ;  $  TAB1 set x7 to x1+x2+x3 raised to the power 2 ;  $  TAB1 set x8 to x1 raise to the power 2 ;  $  TAB1 set x9 to x3 raise to the power 2 ;  $  TAB1 set x10 to x5 raise to the power 2 ;  $  TAB1 set ans=x7-x8-x9-x10 ;  $  TAB1 print ans ;
TAB0 a, b = integers ;  $  TAB1 read a and b ;  $  TAB1 print a + b - 1 and a new line ;  $  TAB1 for i = 1 to b exclusive print 1, " ", i ;  $  TAB1 for i = 2 to a exclusive print i, " ", 1 ;
TAB1 let n, a, b, c be integers ;  $  TAB1 read n, a, b, and c ;  $  TAB1 let t be 4 - n modulo 4 ;  $  TAB1 let N be a long long array of size 100000 ;  $  TAB1 let re be an integer with re = 0x3f3f3f3f ;  $  TAB1 if t is equal to 4 and n ;  $  TAB2 assign 0 to re ;  $  TAB1 else ;  $  TAB2 for i = 0 to 100000 exclusive, set N[i] to 0x3f3f3f3f ;  $  TAB2 assign 0 to N[0] ;  $  TAB2 for i = 1 to 99999 inclusive, set N[i] to N[i - 1] + a ;  $  TAB2 for i = 2 to 99999 inclusive ;  $  TAB3 if b + N[i - 2] is less than N[i], then assign b + N[i - 2] to N[i] ;  $  TAB2 for i = 3 to 99999 inclusive ;  $  TAB3 if c + N[i - 3] is less than N[i], then assign c + N[i - 3] to N[i] ;  $  TAB2 for i = t to 99999 inclusive with i incremented by 4 ;  $  TAB3 if N[i] is less than re, then assign N[i] to re ;  $  TAB1 output re ;
TAB1 s1, s2 = string ;  $  TAB1 read s1 ;  $  TAB1 read s2 ;  $  TAB1 cnt1 = integer set = 0 ;  $  TAB1 cnt2 = integer set = 0 ;  $  TAB1 for i = 0 to the length of s1 length exclusive ;  $  TAB2 if index i of s1 - '0' = 7 and index i of s2 - '0' = 4, increment cnt1 by 1 ;  $  TAB2 if index i of s1 - '0' = 7 and index i of s2 - '0' = 4, increment cnt2 by 1 ;  $  TAB1 read the max of cnt1 and cnt2 ;
TAB1 declare integers a and b ;  $  TAB1 read a and b ;  $  TAB1 define long long aa = a * 100, bb = b * 10, h = 0 ;  $  TAB1 loop infinitely ;  $  TAB2 if h is even ;  $  TAB3 if a >= 2 and b >= 2 ;  $  TAB4 decrease a by 2 ;  $  TAB4 decrease b by 2 ;  $  TAB3 else if a >= 1 and b >= 12 ;  $  TAB4 decrease a by 1 ;  $  TAB4 decrease b by 12 ;  $  TAB3 else if b >= 22 ;  $  TAB4 decrease b by 22 ;  $  TAB3 else ;  $  TAB4 write "Hanako" and newline ;  $  TAB2 else ;  $  TAB3 if b >= 22 ;  $  TAB4 decrease b by 22 ;  $  TAB3 else if a >= 1 and b >= 12 ;  $  TAB4 decrease a by 1 ;  $  TAB4 decrease b by 12 ;  $  TAB3 else if a >= 2 and b >= 2 ;  $  TAB4 decrease a by 2 ;  $  TAB4 decrease b by 2 ;  $  TAB3 else ;  $  TAB4 write "Ciel" and newline ;  $  TAB2 increment h ;
TAB0 s1, s2 = strings ;  $  TAB0 num1, num2 = integers ;  $  TAB1 read s1 ;  $  TAB1 read s2 ;  $  TAB1 for i = 0 to length of s1 exclusive ;  $  TAB2 if index i of s1 = '7' and index i of s2 = '4' ;  $  TAB3 increment num1 by 1 ;  $  TAB2 else if index i of s1 = '4' and index i of s2 = '7' ;  $  TAB3 increment num2 by 1 ;  $  TAB1 print the greater number between num1 and num2 ;
TAB0 let n, m be integers ;  $  TAB0 used = bool array of size 7 ;  $  TAB0 counter, digitn, digitm = integers with counter = 0, digitn = 0, and digitm = 0 ;  $  TAB0 in the function checkh that takes integer x and return bool ;  $  TAB1 if x is greater than or equal to 0 and x is less than n, then return true ;  $  TAB1 return false ;  $  TAB0 in the function checkm that takes integer x and return bool ;  $  TAB1 if x is greater than or equal to 0 and x is less than m, then return true ;  $  TAB1 return false ;  $  TAB0 in the function permutem that takes integers a, number ;  $  TAB1 if number is equal to digitm ;  $  TAB2 if call checkm with argument a is true, then increment counter ;  $  TAB2 return ;  $  TAB1 for i = 0 to 7 exclusive ;  $  TAB2 if not used[i] ;  $  TAB3 set used[i] to true ;  $  TAB3 call permutem with arguments a * 7 + i, number + 1 ;  $  TAB3 set used[i] to false ;  $  TAB0 in the function permuteh that takes integers a, number ;  $  TAB1 if number is equal to digitn ;  $  TAB2 if call checkh with argument a is true, then call permutem with arguments 0, 0 ;  $  TAB2 return ;  $  TAB1 for i = 0 to 7 exclusive ;  $  TAB2 if not used[i] ;  $  TAB3 set used[i] to true ;  $  TAB3 call permuteh with arguments a * 7 + i, number + 1 ;  $  TAB3 set used[i] to false ;  $  TAB1 read n, m ;  $  TAB1 faken = integer = n - 1, fakem = integer = m - 1 ;  $  TAB1 if n is equal to 1, then assign 1 to faken ;  $  TAB1 if m is equal to 1, then assign 1 to fakem ;  $  TAB1 while faken is greater than 0 ;  $  TAB2 assign faken / 7 to faken ;  $  TAB2 increment digitn ;  $  TAB1 while fakem is greater than 0 ;  $  TAB2 assign fakem / 7 to fakem ;  $  TAB2 increment digitm ;  $  TAB1 if the sum of digitn and digitm is greater than 7 ;  $  TAB2 output 0 ;  $  TAB1 else ;  $  TAB2 call permuteh with arguments 0, 0 ;  $  TAB2 output counter ;
TAB1 let n be an int ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print Mahmoud ;  $  TAB1 else ;  $  TAB2 print Ehab ;
TAB1 n = integer ;  $  TAB1 input n ;  $  TAB1 if n isn't even ;  $  TAB2 print Ehab ;  $  TAB1 else ;  $  TAB2 print Mahmoud ;
TAB1 create integers a, b, c, inp, ca, cb with a = 0 and b = 0 ;  $  TAB1 create integer i ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 input inp ;  $  TAB2 a is assigned the sum of a and inp ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 input inp ;  $  TAB2 b is assigned the sum of b and inp ;  $  TAB1 set ca to (a + 4) / 5 ;  $  TAB1 set cb to (b + 9) / 10 ;  $  TAB1 input c ;  $  TAB1 if c is greater than or equal to the sum of ca and cb ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n = integer ;  $  TAB1 ans and sum = long long integer, both set = 0 ;  $  TAB1 read n ;  $  TAB1 i, x, mn, and cnt = integer, i set = 1, mn and cnt set = 0 ;  $  TAB1 for i to n inclusive ;  $  TAB2 read x ;  $  TAB2 if x address is 1 ;  $  TAB3 increment cnt by 1 ;  $  TAB3 if x is less than mn or mn = 0 ;  $  TAB4 increment sum by mn, set mn = x ;  $  TAB3 else ;  $  TAB4 increment sum by x ;  $  TAB2 else ;  $  TAB3 increment ans by x ;  $  TAB1 if cnt address is 1 ;  $  TAB2 increment ans by sum ;  $  TAB1 else ;  $  TAB2 increment ans by sum + mn ;  $  TAB1 print ans ;
TAB0 integers h = 0, ans = 0 ;  $  TAB0 integers r, g, b ;  $  TAB1 input r, g, b ;  $  TAB1 r is assigned ((r / 2) + (r % 2) - 1) * 3 + 1 ;  $  TAB1 g is assigned ((g / 2) + (g % 2) - 1) * 3 + 2 ;  $  TAB1 b is assigned ((b / 2) + (b % 2) - 1) * 3 + 3 ;  $  TAB1 h is assigned the max of r and the max of g and b ;  $  TAB1 ans is set to h + 29; ;  $  TAB1 output ans ;  $  TAB1 semicolon ;
TAB1 make integer a ;  $  TAB1 read a ;  $  TAB1 output a ;  $  TAB1 if a is greater than 1, then print " " ;  $  TAB1 for i = 0 to a - 1 exclusive ;  $  TAB2 output i + 1 ;  $  TAB2 if the sum of i and 2 doesn't equal a, then print " " ;  $  TAB1 output newline ;
TAB0 x, r = integers, r set to 1 ;  $  TAB1 read x ;  $  TAB1 while r * r + 1 is greater than 2 * x, increment r by 2 ;  $  TAB1 print 5 if x = 3 or print r ;
TAB0 ara = integer array of length110 ;  $  TAB1 ans = int with ans = 1e9 ;  $  TAB1 n, m = integers ;  $  TAB1 input n and m ;  $  TAB1 a = integer array of length n + 1, b = integer array of length m + 1 ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to m exclusive, read b[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if a[i] and b[j] are equal, set ans to min(ans, a[i]) ;  $  TAB3 set ans to min(ans, a[i] + 10 * b[j]) ;  $  TAB3 set ans to min(ans, b[j] + 10 * a[i]) ;  $  TAB1 output ans ;
TAB0 minodd, blyat, ans and ods = long long integers with minodd set = 69696969696 ;  $  TAB1 b = long long integer ;  $  TAB1 read b ;  $  TAB1 for a = 0, a to b exclusive ;  $  TAB2 read blyat ;  $  TAB2 increment ans by blyat ;  $  TAB2 if blyat modulo 2 = 1, increment odds + 1 ;  $  TAB2 if monodd is greater than blyat and blyat modulo 2 = 1, set minodd = blyat ;  $  TAB1 if b = 1 and minodd doesn't = 0 and odds is greater than 1 ;  $  TAB2 print 0 ;  $  TAB1 else if odds modulo 2 = 1 ;  $  TAB2 print ans - minodd ;  $  TAB1 else ;  $  TAB2 read ans ;
TAB0 a = integer array of size 100010 ;  $  TAB1 n, tot = integers with tot = 0 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive, input a[i] ;  $  TAB1 call sort on a + 1 and a + n + 1 ;  $  TAB1 let x = int = a[1] and y = int = a[n] ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if a[i] is greater than x and a[i] is less than y, then increment tot ;  $  TAB1 output tot ;
TAB0 in function print with arguments long long integer a[], long long integer n ;  $  TAB1 for long long integer i = 0 to n exclusive, output a[i] and " " ;  $  TAB1 output newline ;  $  TAB0 in function m with argument long long integer x and return long long integer ;  $  TAB1 return x mod 1000000007 ;  $  TAB0 in function gcd with arguments long long integer a, long long integer b and return long long int ;  $  TAB1 if a is equal to 0, then return b ;  $  TAB1 return gcd with arguments b mod a, a ;  $  TAB0 in function p with arguments long long integer a, long long integer b and return long long integer ;  $  TAB1 if b is equal to 0, then return 1 ;  $  TAB1 t = long long integer with t = call function p with arguments a, b / 2 ;  $  TAB1 if b mod 2 is equal to 0 ;  $  TAB2 return t squared ;  $  TAB1 else ;  $  TAB2 return a * t * t ;  $  TAB1 n = long long integer ;  $  TAB1 read n ;  $  TAB1 a[n] = long long integer array ;  $  TAB1 b[n] = long long integer array ;  $  TAB1 sum = long long integer with sum = 0 ;  $  TAB1 for long long integer i = 0 to n exclusive ;  $  TAB2 read a[i] and b[i] ;  $  TAB2 if a[i] is greater than sum ;  $  TAB3 assign a[i] to sum ;  $  TAB2 else ;  $  TAB3 v = long long integer with v = sum - a[i] ;  $  TAB3 sum is assigned a[i] + b[i] * (v / b[i] + 1) ;  $  TAB1 output sum ;
TAB1 a, b, c = integers ;  $  TAB1 read a, b and c ;  $  TAB1 t1, t2, t3 = integers ;  $  TAB1 t1 set to a / 1 ;  $  TAB1 t2 set to b / 2 ;  $  TAB1 t3 set to c / 4 ;  $  TAB1 if t1 is greater than t2, set t1 to t2 ;  $  TAB1 if t1 is greater than t3, set t1 to t3 ;  $  TAB1 sum = integer ;  $  TAB1 set sum to 7 * t1 ;  $  TAB1 read sum ;
TAB0 in function gcd that takes integers n,m and return integer ;  $  TAB1 if n<m then swap n and m ;  $  TAB1 if m is equal to 0 ;  $  TAB2 return n ;  $  TAB1 else if n mod m is equal to 0 ;  $  TAB2 return m ;  $  TAB1 else do the following ;  $  TAB2 return gcd(m,n%m) ;  $  TAB1 create integers a,b,n,k ;  $  TAB1 keep reading values of a, b, n ;  $  TAB2 for k=1 to infinite ;  $  TAB3 if k mod 2 is equal to 1 ;  $  TAB4 set n=n-gcd(n,a) ;  $  TAB4 if n is less than 0 ;  $  TAB5 print 1 ;  $  TAB5 break ;  $  TAB3 else do the following ;  $  TAB4 set n= n - gcd(n,b) ;  $  TAB4 if n is less than 0 ;  $  TAB5 print 0 ;  $  TAB5 break ;
TAB0 n = integer ;  $  TAB0 s = string ;  $  TAB1 read n and s ;  $  TAB1 ans = string = "" ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i is less than n - 2 and substring of s from index i to 3 is equal to "ogo" ;  $  TAB3 ans is assigned ans + "***" ;  $  TAB3 i is assigned i + 3 ;  $  TAB3 while i is less than n and substring of s from index i to 2 is equal to "go", then add 2 to i ;  $  TAB3 decrement i ;  $  TAB2 else ;  $  TAB3 assign ans + s[i] to ans ;  $  TAB1 output ans ;
TAB1 a=integer ;  $  TAB1 read a ;  $  TAB1 print ((a + 1) / 2) % 2 ;
TAB0 m, k = integers, s and d = arrays of integers length of 1002 ;  $  TAB0 void Input ;  $  TAB1 i = integer ;  $  TAB1 read m and k ;  $  TAB1 for i = 1 to m inclusive read index i of d ;  $  TAB1 for i = 1 to m inclusive read index i of s ;  $  TAB1 invoke Input ;  $  TAB1 i and p = integers ;  $  TAB1 sup = integer set to 0 ;  $  TAB1 tmp = integer set to 0 ;  $  TAB1 t = integer set to 0 ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 increment sup by index i of s ;  $  TAB2 if tmp < index i of s ;  $  TAB3 set p to i ;  $  TAB3 set tmp to index i of s ;  $  TAB2 while sup < index i of d ;  $  TAB3 increment t by k ;  $  TAB3 increment sup by index p of s ;  $  TAB2 increment t by index i of d ;  $  TAB2 decrement sup by index i of d ;  $  TAB1 print t ;
TAB0 in function gcd that takes integers x,y and return integer ;  $  TAB1 create integers i and r ;  $  TAB1 set r= x mod y ;  $  TAB1 while r is not equal to 0 ;  $  TAB2 set x= y ;  $  TAB2 set y=r ;  $  TAB2 set r= x mod y ;  $  TAB1 return y ;  $  TAB1 let simon, anti, heap be integers ;  $  TAB1 input simon, anti, heap ;  $  TAB1 while true ;  $  TAB2 set heap = heap - gcd (simon, heap) ;  $  TAB2 if heap is 0 ;  $  TAB3 print 0 and new line ;  $  TAB3 break ;  $  TAB2 set heap = heap - gcd(anti,heap) ;  $  TAB2 if heap is 0 ;  $  TAB3 print 1 ;  $  TAB3 break ;
TAB1 let n, i, j, res be integers ;  $  TAB1 read n ;  $  TAB1 let st be a string ;  $  TAB1 read st ;  $  TAB1 set res to 0 ;  $  TAB1 for i = 0 to n - 1 ;  $  TAB2 if st[i] is the same as st[i + 1], then add 1 to res ;  $  TAB1 output res ;
TAB1 let n,ans be integers with ans=0 ;  $  TAB1 input n ;  $  TAB1 let freq be an integer array of size 3 with freq[3]=0 ;  $  TAB1 let a be an integer array of size n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment freq[a[i]] ;  $  TAB1 if freq[2] >= freq[1] then ;  $  TAB2 ans = ans + freq[1] ;  $  TAB1 else do the following ;  $  TAB2 ans = ans + freq[2] ;  $  TAB2 freq[1]= freq[1]- freq[2] ;  $  TAB2 ans= ans + freq[1]/3 ;  $  TAB1 print ans ;
TAB1 i = integer set to 0 ;  $  TAB1 s, c = char with s set to [200100] ;  $  TAB1 while c, set to the function getchar, does not equal '\n' ;  $  TAB2 while i exists and value i - 1 of index s is less than c ;  $  TAB3 set index i of s to 0 ;  $  TAB3 decrement i by 1 ;  $  TAB2 set index i plus 1 to c ;  $  TAB1 for j = 0 to i exclusive, print index j of s ;  $  TAB1 print newline ;
TAB1 let n be an integer ;  $  TAB1 while input n, do the following ;  $  TAB2 if n modulo 2, do the following ;  $  TAB3 print Ehab ;  $  TAB2 else, do the following ;  $  TAB3 print Mahmoud ;
TAB0 function MIN returns a long integer with arguments long integer a and b ;  $  TAB1 if a is greater than b ;  $  TAB2 return b ;  $  TAB1 else ;  $  TAB2 return a ;  $  TAB0 function MAX returns a long integer with arguments long integer a and b ;  $  TAB1 if a is greater than b ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return b ;  $  TAB0 function MOD returns a long integer with argument long integer x ;  $  TAB1 if x is greater than or equal to 0 ;  $  TAB2 return x ;  $  TAB1 else ;  $  TAB2 return negative x ;  $  TAB1 sum = long integer set = 0 ;  $  TAB1 a = array with length of 5 ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 read index i of a ;  $  TAB2 increment sum by index i of a ;  $  TAB1 if sum modulo 5 = 0 and sum is greater than 0 ;  $  TAB2 d = long integer set = sum / 5 ;  $  TAB2 print d ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 n = long long integer ;  $  TAB1 read n ;  $  TAB1 a = array of long long integers size n ;  $  TAB1 b = array of long long integers size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read index i of a ;  $  TAB2 set index i of b = index i of a ;  $  TAB1 same = long long integer set to 0 ;  $  TAB1 cnt = long long integer set to 0 ;  $  TAB1 c = long long integer set to -1 ;  $  TAB1 d = long long integer set to -1 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if a[i + i] < a[i] ;  $  TAB3 increment cnt by 1 ;  $  TAB3 if c = -1 ;  $  TAB4 set c = i ;  $  TAB3 else if d = -1 ;  $  TAB4 set d = i ;  $  TAB1 if cnt > 2 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 if c = -1 and d = -1 ;  $  TAB3 print "YES" ;  $  TAB2 else if c != -1 and d = -1 ;  $  TAB3 if n = 2 ;  $  TAB4 print "YES" ;  $  TAB3 else ;  $  TAB4 pr = long long integer set to c ;  $  TAB4 wile a[c] = a[pr] and pr >= 0, decrement pr by 1 ;  $  TAB4 dr = long long integer set to c + 1 ;  $  TAB4 while a[c + 1] = a[dr] and dr < n, increment dr by 1 ;  $  TAB4 increment pr by 1 ;  $  TAB4 decrement pr by 1 ;  $  TAB4 set b[pr] = a[pr] ;  $  TAB4 set d[dr] = a[pr] ;  $  TAB4 ct = long long integer set to 0 ;  $  TAB4 for i = 0 to n - 1 exclusive ;  $  TAB5 if b[i] > b[i + 1], increment c by 1 ;  $  TAB4 if ct > 0 ;  $  TAB5 print "NO" ;  $  TAB4 else ;  $  TAB5 print "YES" ;  $  TAB2 else ;  $  TAB3 ct = long long integer set to 0 ;  $  TAB3 tp = long long integer ;  $  TAB3 set b[c] = a[d + 1] ;  $  TAB3 set b[d - 1] = a[c] ;  $  TAB3 for i = 0 to n -1 exclusive ;  $  TAB4 if b[i] > b[i + 1], increment c++ ;  $  TAB3 if ct > 0 ;  $  TAB4 print "NO" ;  $  TAB3 else ;  $  TAB4 print "YES" ;
TAB1 make integers a, b, c, d ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 read c ;  $  TAB1 read d ;  $  TAB1 make integer sol1 ;  $  TAB1 make integer sol2 ;  $  TAB1 set the absolute value of c - a to sol1 ;  $  TAB1 set the absolute value of d - b to sol2 ;  $  TAB1 if sol1 is greater than sol2 ;  $  TAB2 output sol1 ;  $  TAB1 else ;  $  TAB2 output sol2 ;
TAB1 n, x = integers with x set to 0 ;  $  TAB1 read n ;  $  TAB1 while n >= 1 ;  $  TAB2 if n % 2 = 1 ;  $  TAB3 increment x by 1 ;  $  TAB3 decrement n -1 ;  $  TAB2 else ;  $  TAB3 set n = n /2 ;  $  TAB1 print x ;
TAB0 function gcd returns a long long integer which takes two arguments a and b ;  $  TAB1 if b = 0 return a ;  $  TAB1 return gcd with arguments b and a modulo b ;  $  TAB1 a, b = long long integers ;  $  TAB1 read a and b ;  $  TAB1 x, y = long long integers ;  $  TAB1 read x and y ;  $  TAB1 print whichever is greater between the absolute value of x -a and the absolue value of y - b ;
TAB1 a, b, c, store = integers ;  $  TAB1 s = string with s = "No" ;  $  TAB1 read a, b, and c ;  $  TAB1 for i = 0 and increment i unconditionally ;  $  TAB2 set store to c - b * i ;  $  TAB2 if store mod a equals 0 and store is greater than or equal to 0 ;  $  TAB3 set s to "Yes" ;  $  TAB3 break ;  $  TAB2 set store to c - a * i ;  $  TAB2 if store mod b equals 0 and store is greater than or equal to 0 ;  $  TAB3 set s to "Yes" ;  $  TAB3 break ;  $  TAB2 if i * a is greater than c and i * b is greater than c, then break ;  $  TAB1 output s ;
TAB0 define const long long N = 1e9 + 3 ;  $  TAB0 define const long long MN = 1e9 ;  $  TAB0 let long long n, m, k, c with c = 1 ;  $  TAB1 read n, k, m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to k inclusive ;  $  TAB3 if c == m print i " " j ;  $  TAB3 increment c ;  $  TAB3 if c == m print i " " j ;  $  TAB3 increment c ;  $  TAB1 if m is odd ;  $  TAB2 print "L" ;  $  TAB1 else ;  $  TAB2 print "R" ;  $  TAB1 print newline ;
TAB0 in function lowerbound that takes integer a and return integer ;  $  TAB1 create integer lb ;  $  TAB1 if a is even ;  $  TAB2 lb is assigned a / 2 - 1 ;  $  TAB1 else ;  $  TAB2 lb is assigned a / 2 ;  $  TAB1 return lb ;  $  TAB1 create integers gr, gl, bl, br ;  $  TAB1 input gl and gr ;  $  TAB1 input bl and br ;  $  TAB1 create integer flag ;  $  TAB1 if (gl is greater than or equal to call lowerbound with argument br) and (gl is less than or equal to the sum of br and 1) ;  $  TAB2 set flag to 1 ;  $  TAB1 else if (gr is greater than or equal to call lowerbound with argument bl) and (gr is less than or equal to the sum of bl and 1) ;  $  TAB2 set flag to 1 ;  $  TAB1 else ;  $  TAB2 set flag to 0 ;  $  TAB1 if flag is true ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create long long integers i,n,d,cnt with cnt =2 and a=array of integers of size 110 ;  $  TAB1 ; ;  $  TAB1 read n and d ;  $  TAB1 read n values into array i ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 if a[i+1]- a[i] is greater than 2*d then do the following ;  $  TAB3 set cnt = cnt +2 ;  $  TAB2 else if a[i+1] - a[i] is equal to 2*d ;  $  TAB3 set cnt = cnt +1 ;  $  TAB1 print cnt and newline ;
TAB1 a and b = integers ;  $  TAB1 read a and b ;  $  TAB1 print "Second" if b is greater than or equal to a, otherwise print "First" ;
TAB1 k and n are long long integers ;  $  TAB1 read n, k ;  $  TAB1 if k is less than or equal to (n + 1) / 2 ;  $  TAB2 output (k - 1) * 2 + 1 ;  $  TAB1 else ;  $  TAB2 output (k - (n + 1) / 2 - 1) * 2 + 2 ;
TAB1 declare integers a, b, c, d, e, f ;  $  TAB1 read a, b, c, d, e, f ;  $  TAB1 increase b by a + c ;  $  TAB1 write b * b - a * a - c * c - e * e ;
TAB1 create ints a, b, and c ;  $  TAB1 read a, b, and c ;  $  TAB1 while c is greater than or equal to b and c mod a, set c to c - b ;  $  TAB1 output c % a ? "No" : "Yes" ;
TAB0 n, a_counter, d_counter= integers ;  $  TAB0 let c be char ;  $  TAB1 input n ;  $  TAB1 while n>0 ;  $  TAB2 input c ;  $  TAB2 if c is A ;  $  TAB3 increment a_counter ;  $  TAB2 else if c is D do the following ;  $  TAB3 add 1 to d_counter ;  $  TAB2 subtract 1 from n ;  $  TAB1 if a_counter is greater than d_counter ;  $  TAB2 print Anton ;  $  TAB3 print new line ;  $  TAB1 else if a_counter<d_counter then ;  $  TAB2 print Danik ;  $  TAB3 print new line ;  $  TAB1 else do the following ;  $  TAB2 print Friendship ;  $  TAB3 print a new line ;
TAB0 declare 64 bit long variables a, b, x, y, z ;  $  TAB1 print a, b, x, y, z ;  $  TAB1 for i to x exclusive, decrement a -2 ;  $  TAB1 for i to y exclusive, decrement a -1 and b - 1 ;  $  TAB1 for i to z exclusive, decrement b - 3 ;  $  TAB1 if a is greater than or equal to 0 and b is greater than or equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else if a is greater than 0 and b is greater than 0 ;  $  TAB2 print the absolute value of a + b ;  $  TAB1 else if a is greater than 0 ;  $  TAB2 print the absolute value of a ;  $  TAB1 else ;  $  TAB2 print the absolute value of b ;
TAB1 T = integer ;  $  TAB1 input T ;  $  TAB1 for i = 0 to T-1 ;  $  TAB2 x = integer ;  $  TAB2 input x ;  $  TAB2 if x is equal to 1 ;  $  TAB3 print HARD ;  $  TAB1 print EASY ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 = 0 ;  $  TAB2 print "Mahmoud" ;  $  TAB1 else ;  $  TAB2 print "Ehab" ;
TAB1 declare string str ;  $  TAB1 read str ;  $  TAB1 if int(str[0]) >= 97 and int(str[0]) <= 122 decrease str[0] by 32 ;  $  TAB1 print str ;
TAB0 let n be an integer ;  $  TAB1 input n ;  $  TAB1 if n mod 2 equals 0 ;  $  TAB2 print Mahmoud ;  $  TAB1 else ;  $  TAB2 print Ehab ;
TAB1 create long long a ;  $  TAB1 read a ;  $  TAB1 let easy be bool with easy = true ;  $  TAB1 for i = 0 to a exclusive ;  $  TAB2 create long long aux ;  $  TAB2 read aux ;  $  TAB2 if aux, then assign false to easy ;  $  TAB1 if easy is true ;  $  TAB2 print EASY ;  $  TAB1 else ;  $  TAB2 print HARD ;
TAB0 h = array of integers set to length 111111 ;  $  TAB1 n = integer ;  $  TAB1 x, y = long long integers ;  $  TAB1 read n ;  $  TAB1 while n decremented by 1 is greater than 0 ;  $  TAB2 read x, y ;  $  TAB2 cunt = long long integer ;  $  TAB2 for ;; ;  $  TAB3 if x <= 0 or y <= 0, break ;  $  TAB3 if x < y ;  $  TAB4 add y / x to cunt ;  $  TAB4 set y to y modulo x ;  $  TAB3 else ;  $  TAB4 add x / y to cunt ;  $  TAB4 set x to x modulo y ;  $  TAB2 print cunt ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 create long long integer ans= 26 ;  $  TAB1 set ans = 25*length of s ;  $  TAB1 print ans and new line ;
TAB1 t=integer ;  $  TAB1 ang=float ;  $  TAB1 read t ;  $  TAB1 while t is true then do the following ;  $  TAB2 decrement t ;  $  TAB2 read ang ;  $  TAB2 create a float n=(360) / (180 - (ang) ;  $  TAB2 if n=0 ;  $  TAB3 print "NO" ;  $  TAB2 else if n =int(n) ;  $  TAB3 print "YES" ;  $  TAB2 else do the following ;  $  TAB3 print 'NO" ;
TAB1 let x, jawab be long longs with jawab = 0 ;  $  TAB1 input x ;  $  TAB1 while x is larger than 0 ;  $  TAB2 if x mod 2 is 1 ;  $  TAB3 decrement x, increment jawab ;  $  TAB2 else ;  $  TAB3 set x to x / 2 ;  $  TAB1 display jawab ;
TAB0 declare int n, m[3][2] ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 for j =0 to 2 exclusive: read m[i][j] ;  $  TAB1 define int a = min of m[0][1] and n - m[1][0] - m[2][0] ;  $  TAB1 define int b = min of m[1][1] and n - a - m[2][0] ;  $  TAB1 print a, " ", b, " ", n - a - b ;
TAB1 a, b = long long integers ;  $  TAB1 read a, b ;  $  TAB1 answer = long long integer set to a ;  $  TAB1 for i = 0 to a inclusive ;  $  TAB2 if 5 * i * i + 1 > 480 - 2 * b ;  $  TAB3 set answer to i - 1 ;  $  TAB3 break ;  $  TAB1 print answer ;
TAB1 let t, s, q be integers ;  $  TAB1 input t, s, q ;  $  TAB1 let ans be an integer set to 0 ;  $  TAB1 while t is greater than s ;  $  TAB2 multiply s by q ;  $  TAB2 increment ans ;  $  TAB1 display ans ;
TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if i is odd ;  $  TAB3 display I hate that ;  $  TAB2 else ;  $  TAB3 display I love that ;  $  TAB1 if n is odd, display I hate it ;  $  TAB1 if n is even, display I love it ;
TAB1 n = long long integer ;  $  TAB1 read n ;  $  TAB1 ar= vector of long long int of size n ;  $  TAB1 read n values into the array ar ;  $  TAB1 create long long integer tot_arr=0 ;  $  TAB1 create a boolean variable block=false ;  $  TAB1 create long long integer len_block ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if i is equal to 0 ;  $  TAB3 set len_block to 1 ;  $  TAB2 else if ar[i] is equal to ar[i-1] ;  $  TAB3 increment len_block ;  $  TAB2 else do the following ;  $  TAB3 set tot_arr = tot_arr + ((len_block) * (len_block + 1)) / 2 ;  $  TAB3 assign 1 to len_block ;  $  TAB1 set tot_arr = tot_arr + ((len_block) * (len_block + 1)) / 2 ;  $  TAB1 print tot_arr ;
TAB0 create a array of boolean of size 123456 ;  $  TAB0 in the function pri which takes a int n and return a int ;  $  TAB1 set all values of prime true ;  $  TAB1 for i=2 to i*i<n inclusive ;  $  TAB2 if prime[i] is true ;  $  TAB3 for j=2*i to n inclusive set prime[j]= false ;  $  TAB1 call pri function with 120001 ;  $  TAB1 n,k=integers ;  $  TAB1 read n,k ;  $  TAB1 create a int vector ans ;  $  TAB1 for i=2 to n exclusive ;  $  TAB2 if prime[i] is true ;  $  TAB3 create an integer got with got=0 ;  $  TAB3 while n mod i is equal to 0 ;  $  TAB4 if size of ans is equal to k-1 ;  $  TAB5 set got=1 ;  $  TAB5 break ;  $  TAB4 add i to the end of ans ;  $  TAB4 set n=n/i ;  $  TAB3 if size of ans is equal to k-1 ;  $  TAB4 set got=1 ;  $  TAB4 break ;  $  TAB3 if got = 1 then break ;  $  TAB1 if size of ans is equal to k-1 and n is not equal to 1 ;  $  TAB2 for i=0 to ans.size exclusive print ans[i] ;  $  TAB2 print n ;  $  TAB1 else do the following ;  $  TAB2 print -1 and a new line ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let col = n arrays of integers size = 2 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read col[i][0] ;  $  TAB2 read col[i][1] ;  $  TAB1 let and = long integer with value = 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to n exclusive do the following ;  $  TAB3 if col[i][0] is col[j][1] increment ans ;  $  TAB3 if col[i][1] is col[j][0] increment ans ;  $  TAB1 print ans ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 a = multidimensional char array, size is n * n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, read a[i][j] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 c = int = 0 ;  $  TAB3 if a[i - 1][j] equals 'o' and i - 1 is greater than or equal to 0, increment c ;  $  TAB3 if a[i + 1][j] equals 'o' and i +1 is less than n, increment c ;  $  TAB3 if a[i][j - 1] equals 'o' and j - 1 is greater than or equal to 0, increment c ;  $  TAB3 if a[i][j + 1] equals 'o' and j +1 is less than n, increment c ;  $  TAB3 if c is even ;  $  TAB4 continue ;  $  TAB3 else ;  $  TAB4 print "NO" ;  $  TAB1 print "YES" ;
TAB1 n, x, y, i, len are integers, a = integer array of size 100005 ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 set len to size of s ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if s[i] isn't the character a ;  $  TAB3 set x to i ;  $  TAB3 break ;  $  TAB1 if i equals len ;  $  TAB2 assign the character z to s[len - 1] ;  $  TAB1 else ;  $  TAB2 for i = x + 1 to len exclusive ;  $  TAB3 if s[i] is the character a ;  $  TAB4 set y to i - 1 ;  $  TAB4 break ;  $  TAB2 if i equals len, set y to len - 1 ;  $  TAB2 for i = 1 to y inclusive, subtract 1 from s[i] ;  $  TAB1 output s ;
TAB1 declare int n, m ;  $  TAB1 read n and m ;  $  TAB1 while m is greater than or equal to 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if m - i is greater than or equal to 0 ;  $  TAB4 decrease m by i ;  $  TAB3 else ;  $  TAB4 if m is less than i ;  $  TAB5 print m ;  $  TAB5 exit with status 0 ;  $  TAB1 print m ;
TAB1 create empty strings s1,s2,s3 ;  $  TAB1 read s1,s2 ;  $  TAB1 for i =0 to length of s1 exclusive ;  $  TAB2 if s1[i] is not equal to s2[i] ;  $  TAB3 set s3=s3+1 ;  $  TAB2 else do the following ;  $  TAB3 set s3=s3+0 ;  $  TAB1 print s3 ;
TAB1 s = string set to "qwertyuiopasdfghjkl;zxcvbnm,./" ;  $  TAB1 dire = character ;  $  TAB1 cadena = string ;  $  TAB1 read dire, cadena ;  $  TAB1 for i = 0 to size of cadena exclusive ;  $  TAB2 if dire is 'L' ;  $  TAB3 aux = integer set to find cadena[i] of s ;  $  TAB3 print s[aux + 1] ;  $  TAB2 if dire is 'R' ;  $  TAB3 aux = integer set to find cadena[i] of s ;  $  TAB3 print s[aux -1] ;  $  TAB1 print new line ;
TAB1 n, k, tf, tr, tg, tb, trd, trm, tgd, tgm, tbd, tbm are integers with tf = 0, tr = 2, tg = 5, tb = 8 ;  $  TAB1 read n, k ;  $  TAB1 multiply tr by n ;  $  TAB1 multiply tg by n ;  $  TAB1 multiply tb by n ;  $  TAB1 set trd to tr / k ;  $  TAB1 set trm to tr mod k ;  $  TAB1 if trm is positive, add 1 to trd ;  $  TAB1 set tgd to tg / k ;  $  TAB1 set tgm to tg mod k ;  $  TAB1 if tgm is positive, add 1 to tgd ;  $  TAB1 set tbd to tb / k ;  $  TAB1 set tbm to tb mod k ;  $  TAB1 if tbm is positive, add 1 to tbd ;  $  TAB1 set tf to trd + tgd + tbd ;  $  TAB1 output tf ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to n exclusive do the following ;  $  TAB3 if abs(i - (n+1)) / 2 +1) + abs(j - (n+1) /2 + 1) is less than or equal to (n + 1) / 2 -1 ;  $  TAB4 print D ;  $  TAB3 else ;  $  TAB4 print * ;  $  TAB2 print a new line ;
TAB1 let a be integer ;  $  TAB1 read ;  $  TAB1 print a mod 2 with newline ;
TAB1 create ints n, m, i, j, x = 0 ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if (i is even and i modulo 4 is not equal to 0 and j is not equal to m) or (i modulo 4 equals 0 and j is greater than 1) ;  $  TAB4 print '.' ;  $  TAB3 else ;  $  TAB4 print '#' ;  $  TAB2 print newline ;
TAB1 create integer n,m,t with t=0 ;  $  TAB1 read n,m ;  $  TAB1 for b=0 to b^2 <=m ;  $  TAB2 create integer a= m - b^2 ;  $  TAB2 if a^2 + b = n then add 1 to t ;  $  TAB1 print t ;
TAB1 let a, b, c, s1, s2, s3 = integers ;  $  TAB1 read s1, s2, s3 ;  $  TAB1 set a = square root of (s1 * s3) / s2 ;  $  TAB1 set b = square root of (s1 * s2) / s3 ;  $  TAB1 set c = square root of (s2 * s3) / s1 ;  $  TAB1 print 4 * (a+b+c) ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 let a be an integer array of size 2*n+1 ;  $  TAB1 set a[0]=-1 ;  $  TAB1 read 2*n values into array a from 1 to 2n ;  $  TAB1 sort array a ;  $  TAB1 if a[n+1] > a[n] ;  $  TAB2 print YES ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB0 let freq = array of integers with size = 1005 ;  $  TAB0 let n, m, x, to = integers ;  $  TAB1 read n, m ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read x, to ;  $  TAB2 for integer j=x+1 to to inclusive set freq[j] = 1 ;  $  TAB1 for integer i=1 to m inclusive do the following ;  $  TAB2 if not freq[i] dothe following ;  $  TAB3 write NO to stdout ;  $  TAB1 write YES to stdout ;
TAB0 a and b are integers, p is an integer array of length 5 ;  $  TAB0 ans is an integer with ans = 0 ;  $  TAB1 read p[1], p[2], p[3], p[4], a, b ;  $  TAB1 Min = integer = call min with(call min with (call min with(p[1], p[2]), p[3]), p[4]) ;  $  TAB1 if a is less than Min ;  $  TAB2 add Min - a to ans ;  $  TAB2 if b is at least Min ;  $  TAB3 display ans ;  $  TAB2 set ans to b - a + 1 ;  $  TAB2 display ans ;  $  TAB1 else ;  $  TAB2 display ans ;
TAB1 sumA, sumB, a are long longs with sumA = 0, sumB = 0 ;  $  TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 iterate n times ;  $  TAB2 input a ;  $  TAB2 set sumA to a or sumA ;  $  TAB1 iterate n times ;  $  TAB2 input a ;  $  TAB2 set sumB to a or sumB ;  $  TAB1 output sumA + sumB ;
TAB1 a = character array of size 103 ;  $  TAB1 read a ;  $  TAB1 one = boolean = false ;  $  TAB1 zeroCount = long long = 0 ;  $  TAB1 for i = 0 to string length a exclusive ;  $  TAB2 if a[i] is the character 1 ;  $  TAB3 set one to true ;  $  TAB2 else if one ;  $  TAB3 increment zeroCount ;  $  TAB1 display yes if one and zeroCount are at least 6, otherwise display no ;
TAB1 n, t are integers ;  $  TAB1 while read n, t ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if i is divisible by 2 ;  $  TAB4 for j = 0 to t exclusive, display # ;  $  TAB4 display newline ;  $  TAB3 else ;  $  TAB4 if i is divisible by 4 ;  $  TAB5 for j = 0 to t - 1 exclusive, display . ;  $  TAB5 display # ;  $  TAB4 else ;  $  TAB5 display # ;  $  TAB5 for j = 0 to t - 1 exclusive, display . ;  $  TAB5 display newline ;
TAB1 let n = integer and ts = array of integers size 26 ;  $  TAB1 let s = string ;  $  TAB1 read n, s ;  $  TAB1 if n is 1 do the following ;  $  TAB2 print Yes ;  $  TAB1 set sizeof(ts) bytes starting at ts to 0 ;  $  TAB1 for integer i=0 to n exclusive increment ts[s[i]-a] ;  $  TAB1 call sort on ts and ts + 26 ;  $  TAB1 if ts[25] is less than 2 ;  $  TAB2 print No ;  $  TAB1 else ;  $  TAB2 print Yes ;
TAB1 i, n, j, k are integers, flag and sum are both integers both set to 0 ;  $  TAB1 a is an integer array of length 6 ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 read a[i] ;  $  TAB2 add a[i] to sum ;  $  TAB1 if sum mod 2 isn't 1 ;  $  TAB2 for i = 0 to 6 exclusive ;  $  TAB3 for j = i + 1 to 6 exclusive ;  $  TAB4 for k = j + 1 to 6 exclusive ;  $  TAB5 if a[i] + a[j] + a[k] equals sum / 2 ;  $  TAB6 assign 1 to flag ;  $  TAB6 break ;  $  TAB1 if flag is 1 ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 declare int min1, max1, min2, max2, min3, max3 ;  $  TAB1 read min1, max1 ;  $  TAB1 read min2, max2 ;  $  TAB1 read min3, max3 ;  $  TAB1 if max1 + min2 + min3 is greater than or equal to n ;  $  TAB2 print n - min2 - min3, " ", min2, " ", min3 ;  $  TAB1 else if max1 + max2 + min3 is greater than or equal to n ;  $  TAB2 print max1, " ", n - max1 - min3, " ", min3 ;  $  TAB1 else ;  $  TAB2 max1, " ", max2, " ", n - max1 - max2 ;
TAB0 declare integer function func taking in integer array arr and integers size and n ;  $  TAB1 let sum = integer with value = 0 ;  $  TAB1 if n is 0 return 0 ;  $  TAB1 for integer i=size-1 to 0 inclusive decrementing do the following ;  $  TAB2 set sum = sum + arr[i] ;  $  TAB2 if sum is less than n return size -1 ;  $  TAB1 return -1 ;  $  TAB1 let n = integer ;  $  TAB1 let size = integer constant with value = 12 ;  $  TAB1 let arr = array of integers of size size ;  $  TAB1 read n ;  $  TAB1 read size values into array arr ;  $  TAB1 call sort on arr and arr \= size ;  $  TAB1 print result of call to func on arr, size and n ;
TAB0 let PI = double constant with value = acos(-1.0) ;  $  TAB0 let inf = integer constant with value = 1000000000 ;  $  TAB0 let mod = integer constant with value = 1000000007 ;  $  TAB0 let n, m, k, l, w, h, sum, mx, mn = long longs ;  $  TAB1 set mn = 1000000000, sum = 0, mx = 0 ;  $  TAB1 read n ;  $  TAB1 let x, y, sum2 = long longs with sum = 0 ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 read x, y ;  $  TAB2 if x is greater than y ;  $  TAB3 increment sum ;  $  TAB2 else if x is less than y ;  $  TAB3 increment sum2 ;  $  TAB1 if sum is greater than sum2 ;  $  TAB2 print Mishka ;  $  TAB1 else if sum2 is greater than sum ;  $  TAB2 print Chris ;  $  TAB1 else ;  $  TAB2 print Friendship is magic ;  $  TAB1 print a new line ;
TAB1 create int n, m, array arr of length 1000, array arr1 of length 1000, count = 0 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 for i = 0 to m exclusive, read arr1[i] ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if arr[j] equals -2 or arr[j] equals -3, continue ;  $  TAB3 if arr1[i] is greater than or equal to arr[j] ;  $  TAB4 increment count ;  $  TAB4 set arr[j] to -2 ;  $  TAB4 break ;  $  TAB3 if arr[i] is less than arr[j], set arr[j] to -3 ;  $  TAB1 print count ;
TAB0 let mp = 1000 arrays of integers size 1000 ;  $  TAB0 declare boolean function check taking in integers x, y, z ;  $  TAB1 if mp[x][y] is 1 and mp[x][z] is 1 and mp[y][z] is 1 return true ;  $  TAB1 return false ;  $  TAB1 set sizeof(mp) bytes starting at mp to 0 ;  $  TAB1 let n, m = integer ;  $  TAB1 read n, m ;  $  TAB1 let cost = array of integers size 1000 ;  $  TAB1 read n values into array cost ;  $  TAB1 for integer i=0 to m exclusive do the following ;  $  TAB2 let x, y = integers ;  $  TAB2 read x, y ;  $  TAB2 set mp[x][y] = 1 ;  $  TAB2 set mp[y][x] = 1 ;  $  TAB1 let sum = integer ;  $  TAB1 let ans = integer with value = -1 ;  $  TAB1 for integer i=1 to n inclusive ;  $  TAB2 for integer j=1 to n inclusive ;  $  TAB3 for integer k=1 to n inclusive do the following ;  $  TAB4 if result of call check on i, j, k is true do the following ;  $  TAB5 set sum = cost[i] + cost[j] + cost[k] ;  $  TAB5 if ans is -1 do the following ;  $  TAB6 set ans = sum ;  $  TAB5 else do the following ;  $  TAB6 set ans = min of ans and sum ;  $  TAB1 print ans ;
TAB1 let n, i, d, y = signed 64bit integer with i=1, d=0, y=2 ;  $  TAB1 read n ;  $  TAB1 while n is greater than or equal to 0 do the following ;  $  TAB2 set n = n-i ;  $  TAB2 set d = d+1 ;  $  TAB2 set i = i+y ;  $  TAB2 set y = y+1 ;  $  TAB1 print d-1 ;
TAB1 l,w,r,ans= integers with ans=0 ;  $  TAB1 read l,w,r ;  $  TAB1 while r-- is true ;  $  TAB2 set ans = ans + (2 * l) + (2 * (w - 2)) ;  $  TAB2 set l = l - 4 ;  $  TAB2 set w = w - 4 ;  $  TAB1 print ans ;
TAB1 let n = int ;  $  TAB1 read n ;  $  TAB1 if n not equal to 2 ;  $  TAB2 print "1" ;  $  TAB1 else ;  $  TAB2 print "2" ;
TAB1 creat a long long integer n ;  $  TAB1 arr= array of long long integer of size 100005 ;  $  TAB1 temp = long long integer ;  $  TAB1 create a long long int result= 0 ;  $  TAB1 create a long long int repeat =0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read temp ;  $  TAB2 if arr[i] is temp ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create long long integer j = i ;  $  TAB2 if j is not equal to 0 ;  $  TAB3 if arr[j] = arr[j-1] ;  $  TAB4 set result = result + repeat ;  $  TAB4 decrement repeat ;  $  TAB4 continue ;  $  TAB3 else do the following ;  $  TAB4 set repeat to 0 ;  $  TAB2 while j<n and arr[j] = arr[i] ;  $  TAB3 add 1 to repeat ;  $  TAB3 set result to result + 1 ;  $  TAB3 increment j ;  $  TAB2 decrement repeat ;  $  TAB1 print result and a new line ;
TAB0 n,k=integers ;  $  TAB0 in the function check which takes a string s and returns a boolean ;  $  TAB1 create a boolean array f of size k+1 and set it to 0 ;  $  TAB1 for i=0 to size of s exclusive then set f[s[i] - '0'] = 1 ;  $  TAB1 for i=0 to k inclusive ;  $  TAB2 if f[i]=0 then return false ;  $  TAB1 else return true ;  $  TAB1 read n,k ;  $  TAB1 create an integer ans with ans =0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 s= string ;  $  TAB2 read s ;  $  TAB2 if check(s) then increment ans ;  $  TAB1 print ans ;
TAB1 s, v1, v2, t1, t2 are integers ;  $  TAB1 read s, v1, v2, t1, t2 ;  $  TAB1 first = integer = (2 * t1) + (v1 * s) ;  $  TAB1 second = integer = (2 * t2) + (v2 * s) ;  $  TAB1 terminate statement ;  $  TAB1 if first is less than second ;  $  TAB2 display First ;  $  TAB1 else if first is greater than second ;  $  TAB2 display Second ;  $  TAB1 else ;  $  TAB2 display Friendship ;
TAB1 a = string ;  $  TAB1 b = integer ;  $  TAB1 read a, b ;  $  TAB1 let sum be integer with sum = size of a - 1 ;  $  TAB1 for i = 0 to b exclusive ;  $  TAB2 if a[sum] != '0' ;  $  TAB3 update a[sum] to a[sum] - 1 ;  $  TAB2 else ;  $  TAB3 decrement sum ;  $  TAB1 for i = 0 to sum inclusive, print a[i] ;  $  TAB1 print newline ;
TAB0 n, k, ans are integers ;  $  TAB1 read n and k ;  $  TAB1 set k to 240 - k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if k - 5 * i is positive, increment ans, subtract 5 * i from k ;  $  TAB1 display ans ;
TAB1 n, a, b, s, t are integers ;  $  TAB1 while input n ;  $  TAB2 assign 0 to t ;  $  TAB2 r and z are both integers both set to 0 ;  $  TAB2 fir i = 0 to n exclusive ;  $  TAB3 read a and b ;  $  TAB3 add a to r ;  $  TAB3 add b to z ;  $  TAB3 set s to z - r ;  $  TAB3 set t to call max with arguments t, s ;  $  TAB2 display t ;
TAB1 let t be long long int ;  $  TAB1 read t ;  $  TAB1 while t > 0, decrement t ;  $  TAB2 let a be long long int ;  $  TAB2 read a ;  $  TAB2 let n, flag be long long int with n = 3, flag = 0 ;  $  TAB2 while 2 ;  $  TAB3 if (n-2) * 180 == n * a ;  $  TAB4 set flag to 1 ;  $  TAB4 break ;  $  TAB3 else if (n-2) * 180 > n*a ;  $  TAB4 break ;  $  TAB3 increment n ;  $  TAB2 if flag == 1 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB0 a is a long long array of size 400009 ;  $  TAB1 n is a long long ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 call sort with a, a + n ;  $  TAB1 sum is a long long set to 0 ;  $  TAB1 for i = 0 to n - 1 exclusive, add a[i] * (i + 2) to sum ;  $  TAB1 add a[n - 1] * n to sum ;  $  TAB1 output sum ;
TAB1 create set se holding ints ;  $  TAB1 create int n ;  $  TAB1 create int x ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if x equals 0, continue ;  $  TAB2 insert x into se ;  $  TAB1 print size of se ;
TAB0 create character array a1 of 20 elements set to 'v', '<', '^', '>', 'v', '<', '^', '>', 'v' ;  $  TAB0 create character array a2 of 20 elements set to 'v', '>', '^', '<', 'v', '>', '^', '<', 'v' ;  $  TAB1 create character s1, s2 ;  $  TAB1 create integer num ;  $  TAB1 while reading s1 ;  $  TAB2 read ;  $  TAB2 read s2 ;  $  TAB2 read num ;  $  TAB2 create integer tep1 ;  $  TAB2 create integer tep2 ;  $  TAB2 set tep1 to 0 ;  $  TAB2 set tep2 to 0 ;  $  TAB2 create integer ans1 ;  $  TAB2 assign 0 to ans1 ;  $  TAB2 create integer ans2 ;  $  TAB2 assign 0 to ans2 ;  $  TAB2 num %= 4 ;  $  TAB2 for i = 0 to 9 exclusive ;  $  TAB3 if a1[i] equals s1 ;  $  TAB4 if a1[i + num] equals s2, assign 1 to ans1 ;  $  TAB4 break ;  $  TAB2 for i = 0 to 9 exclusive ;  $  TAB3 if a2[i] equals s1 ;  $  TAB4 if a2[i + num] equals s2, assign 1 to ans2 ;  $  TAB4 break ;  $  TAB2 if ans1 equals 1 and ans2 equals 0 ;  $  TAB3 print "cw" ;  $  TAB2 else if ans1 equals 0 and ans2 equals 1 ;  $  TAB3 print "ccw" ;  $  TAB2 else ;  $  TAB3 print "undefined" ;
TAB1 word = string ;  $  TAB1 read word ;  $  TAB1 l = integer set to length of word ;  $  TAB1 a, b = integers set to 0 ;  $  TAB1 for i = 0 to word length exclusive ;  $  TAB2 for j = i + 1 to word length exclusive ;  $  TAB3 if index i of word = index j of word, set index j of word to 0 ;  $  TAB1 for i = 0 to word length exclusive ;  $  TAB2 if index i of word = 0, increment b by 1 ;  $  TAB1 if l - b modulo 2 = 0 ;  $  TAB2 print "CHAT WITH HER!" ;  $  TAB1 else ;  $  TAB2 print "IGNORE HIM!" ;
TAB1 let int a, b, c, x, y, z, i, j, k, l, m = 0, n ;  $  TAB1 read a, b, c ;  $  TAB1 assign a + b + c to k ;  $  TAB1 assign max(a, max(b, c)) to x ;  $  TAB1 assign min(a, min(b, c)) to y ;  $  TAB1 assign k - (x + y) to z ;  $  TAB1 assign y + z to n ;  $  TAB1 while y + z less than or equal to x, increment y ;  $  TAB1 assign (y + z) - n to m ;  $  TAB1 print m ;
TAB0 make const double eps = 1e-7 ;  $  TAB0 in function bin_search with return type int and parameters long long z, long long x, vector<int> npd ;  $  TAB1 make long long l = z, r = npd.size() - 1, mid = l ;  $  TAB1 while l is less than or equal to r ;  $  TAB2 set mid to (l + r) / 2 ;  $  TAB2 if npd[mid] is equal to x * 2, return mid ;  $  TAB2 npd[mid] > x * 2 ? r = mid - 1 : l = mid + 1 ;  $  TAB1 return mid ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make integer a ;  $  TAB2 read a ;  $  TAB2 if 360 % (180 - a) equals 0, print "YES"; else, print "NO" ;  $  TAB2 print newline ;
TAB0 create a constant integer maxn =1e+5 ;  $  TAB1 n,k=integers ;  $  TAB1 f=array of integer of size maxn ;  $  TAB1 read n,k ;  $  TAB1 create an integer cot with cot=0 ;  $  TAB1 for i=2 to n inclusive ;  $  TAB2 while n mod i=0 ;  $  TAB3 set n= n/i ;  $  TAB3 set f[cot++] = i ;  $  TAB1 if cot<k ;  $  TAB2 print -1 ;  $  TAB1 else do the following ;  $  TAB2 for i=0 to k-1 exclusive print f[i] ;  $  TAB2 create an integer sum with sum=1 ;  $  TAB2 for i=k-1 to cot exclusive then set sum=sum*f[i] ;  $  TAB2 print sum ;
TAB1 let n and k be integers ;  $  TAB1 let a be a character array of length 120 ;  $  TAB1 input n, k ;  $  TAB1 st = integer = -1 ;  $  TAB1 ed = integer = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input a[i] ;  $  TAB2 if a[i] is the character G, assign i to st ;  $  TAB2 if a[i] is the character T, assign i to ed ;  $  TAB1 for i = st to n exclusive with increment i + k ;  $  TAB2 if i equals ed ;  $  TAB3 print YES ;  $  TAB2 if a[i] is the character #, break ;  $  TAB1 for i = st to 0 inclusive with increment i - k ;  $  TAB2 if i equals ed ;  $  TAB3 print YES ;  $  TAB2 if a[i] is the character #, break ;  $  TAB1 print NO ;
TAB1 let n, i, j, p, q, a be integers ;  $  TAB1 d = double ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 set d to ((180 * 1.00) * 2.00) / ((180 * 1.00) - (1.00 * a)) ;  $  TAB2 if (d - d type casted to int) == 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 create int h = 0, e = 0, l = 0, ll = 0, o = 0, c = 0 ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is 'h' and h is 0 ;  $  TAB3 increment c ;  $  TAB3 assign 1 to h ;  $  TAB2 else if s[i] is 'e' and e is 0 and h is 1 ;  $  TAB3 increment c ;  $  TAB3 set e to 1 ;  $  TAB2 else if s[i] is 'l' and l is 0 and e is 1 ;  $  TAB3 increment c ;  $  TAB3 set l to 1 ;  $  TAB2 else if s[i] is 'l' and ll is 0 and l is 1 ;  $  TAB3 increment l ;  $  TAB3 set ll to 1 ;  $  TAB2 else if s[i] is 'o' and o is 0 and ll is 1 ;  $  TAB3 increment c ;  $  TAB3 set o to 1 ;  $  TAB2 if c is 5 then break ;  $  TAB1 if c is 5 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 let INF be const integer with INF = 0x3f3f3f3f ;  $  TAB0 let mp and mmp be map of string to long long ;  $  TAB1 let i, j, k, l, r, co be long long with co = 0 ;  $  TAB1 let n, m, t be long long integers ;  $  TAB1 read n ;  $  TAB1 let s, s1, s2 be strings ;  $  TAB1 let ss and ss1 be string arrays of size 4 ;  $  TAB1 read s2 ;  $  TAB1 for i = 0 to n ;  $  TAB2 read s ;  $  TAB2 set ss[0] to s[0] ;  $  TAB2 set ss[1] to s[1] ;  $  TAB2 set ss[2] to s[2] ;  $  TAB2 set ss[3] to \0 ;  $  TAB2 set s1 to ss ;  $  TAB2 increment the value of key s1 in mmp by 1 ;  $  TAB2 set ss[0] to s[5] ;  $  TAB2 set ss[1] to s[6] ;  $  TAB2 set ss[2] to s[7] ;  $  TAB2 set ss[3] to \0 ;  $  TAB2 set s1 to ss ;  $  TAB2 increment the value of key s1 in mp by 1 ;  $  TAB1 if mp[s2] is equal to mmp[s2] ;  $  TAB2 print out home ;  $  TAB1 else ;  $  TAB2 print out contest with newline ;
TAB0 declare function choose, which returns a long long integer and takes long long integers n and m ;  $  TAB1 ans = long long integer set to 0 ;  $  TAB1 num = long long integer set to 1 ;  $  TAB1 den = long lon integer set to 1 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 multiply num by n - i ;  $  TAB2 set num to num / i + 1 ;  $  TAB1 return num ;  $  TAB0 declare isPrime which returns a boolean and takes in an integer n ;  $  TAB1 if n <= 1 return false ;  $  TAB1 if n <= 3 return true ;  $  TAB1 if n modulo 2 is 0 or n modulo 3 is 0, return false ;  $  TAB1 for i = 5 and i * i <= n, while incrementing by 6 ;  $  TAB2 if n modulo i is 0 or n modulo i + 2 is 0, return false ;  $  TAB1 return true ;  $  TAB0 declare gcd returns a long long integer and takes long long integers a and b ;  $  TAB1 if a is 0 ;  $  TAB2 return b ;  $  TAB1 else ;  $  TAB2 return gcd of b modulo a and a ;  $  TAB1 i, j, k, n, m, t = long long integers ;  $  TAB1 a, b, c, d, ans, max1, min 2 = long long integers with ans set to 0 ;  $  TAB1 read a, b, c, d, k ;  $  TAB1 if a >= c ;  $  TAB2 set max1 to a ;  $  TAB1 else ;  $  TAB2 set max1 to c ;  $  TAB1 if b>= d ;  $  TAB2 set min2 to d ;  $  TAB1 else ;  $  TAB2 set min2 to b ;  $  TAB1 if max1 > min2 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 if max1 <= min2 ;  $  TAB3 if k > min2 or k < max1 ;  $  TAB4 print min2 - max1 + 1 ;  $  TAB3 else ;  $  TAB4 print min2 - max1 ;
TAB1 s = character array of size 25 ;  $  TAB1 input s ;  $  TAB1 len = integer = string length of s ;  $  TAB1 sum = integer = 0 ;  $  TAB1 set sum to (26 - len) * (len + 1) + (len) * len ;  $  TAB1 print sum ;
TAB1 min,ans,n,k,l,c,d,p,nl,np=integers ;  $  TAB1 k1,c1,p1 =integers ;  $  TAB1 read n,k,l,c,d,p,nl,np ;  $  TAB1 set k1=(k*l)/nl ;  $  TAB1 set c1=c*d ;  $  TAB1 set p1=p/np ;  $  TAB1 if k1<= c1 then set min=k1 else set min=c1 ;  $  TAB1 if p1<min then set min=p1 else set min=min ;  $  TAB1 set ans = min/n ;  $  TAB1 print ans ;
TAB1 n and k are integers ;  $  TAB1 input n and k ;  $  TAB1 x, y, and m are integers with m = minimum integer value ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x and y ;  $  TAB2 if y is greater than k ;  $  TAB3 set m to call max with arguments m, x - y + k ;  $  TAB2 else ;  $  TAB3 set m to call max with arguments m, x ;  $  TAB1 display m ;
TAB1 create integers n and m ;  $  TAB1 create string s ;  $  TAB1 read n, m, s ;  $  TAB1 create integers l and r ;  $  TAB1 create characters c1 and c2 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read l, r, c1, c2 ;  $  TAB2 for i = l - 1 to r exclusive ;  $  TAB3 if s[i] equals c1, set s[i] to c2 ;  $  TAB1 print s ;
TAB1 let n, m, i, j, c, ax, ay, bx, by, cx, cy be integers with c = 0 ;  $  TAB1 input n ;  $  TAB1 create integer array a of sizes n, n ;  $  TAB1 read ax, ay, bx, by, cx, cy ;  $  TAB1 if (bx - ax) * (cx - ax) is greater than 0 and (by - ay) * (cy - ay) is greater than 0 ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 while decrement n ;  $  TAB2 declare an integer a ;  $  TAB2 input a ;  $  TAB2 if a is at least 180 or a is at most 0 ;  $  TAB3 output NO ;  $  TAB3 continue ;  $  TAB2 if (360.0 / (180 - a)) - integer value of (360 / (180 - a)) is at most 0 ;  $  TAB3 output YES ;  $  TAB2 else ;  $  TAB3 output NO ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string pointer to dynamically allocated string array of size n ;  $  TAB1 create int pointer to dynamically allocated int array of size n ;  $  TAB1 create int k = n ;  $  TAB1 create int i = 0 ;  $  TAB1 while k ;  $  TAB2 decrement k ;  $  TAB2 read m[i] and s[i] ;  $  TAB2 increment i ;  $  TAB1 set i to 0 ;  $  TAB1 while n ;  $  TAB2 decrement n ;  $  TAB2 if m[i] equals 2 and s[i][0] greater than or equal to s[i][1] ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" ;  $  TAB3 print 2 ;  $  TAB3 print s[i][0] ' ' ;  $  TAB3 for j = 1 to m[i] exclusive print s[i][j] ;  $  TAB3 print newline ;  $  TAB2 increment i ;
TAB1 t, a, i are integers ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 read a ;  $  TAB2 n = float = (360 * 1.0) / (180 - a) ;  $  TAB2 c = integer = (360) / (180 - a) ;  $  TAB2 if n equals c * 1.0 ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;
TAB0 in function g that takes integer a and return integer ;  $  TAB1 if a is negative, return -a ;  $  TAB1 return a ;  $  TAB0 n, x, y, xx, yy, l are integers ;  $  TAB1 read n, x, y, xx, yy, and l ;  $  TAB1 if x is false ;  $  TAB2 if xx is false ;  $  TAB3 set l to call function g with argument y - yy ;  $  TAB2 else ;  $  TAB3 if xx equals n ;  $  TAB4 set l to call function min with arguments y + yy + n, n - y + n - yy + n ;  $  TAB3 else ;  $  TAB4 if yy is false ;  $  TAB5 set l to y + xx ;  $  TAB4 else ;  $  TAB5 set l to n - y + xx ;  $  TAB1 else ;  $  TAB2 if y is false ;  $  TAB3 if xx is false ;  $  TAB4 assign yy + x to l ;  $  TAB3 else ;  $  TAB4 if xx is equal to n ;  $  TAB5 assign yy + n - x to l ;  $  TAB4 else ;  $  TAB5 if yy is false ;  $  TAB6 set l to call function g with argument x - xx ;  $  TAB5 else ;  $  TAB6 set l to call function min with arguments x + xx + n, n - x + n - xx + n ;  $  TAB2 else ;  $  TAB3 if x equals n ;  $  TAB4 if xx is false ;  $  TAB5 set l to call function min with arguments y + yy + n, n - y + n - yy + n ;  $  TAB4 else ;  $  TAB5 if xx equals n ;  $  TAB6 set l to call function g with argument y - yy ;  $  TAB5 else ;  $  TAB6 if yy is false ;  $  TAB7 assign n - xx + y to l ;  $  TAB6 else ;  $  TAB7 assign n - xx + n - y to l ;  $  TAB3 else ;  $  TAB4 if xx is false ;  $  TAB5 assign n - yy + x to l ;  $  TAB4 else ;  $  TAB5 if xx equals n ;  $  TAB6 assign n - x + n - yy to l ;  $  TAB5 else ;  $  TAB6 if yy is false ;  $  TAB7 set l to call function min with arguments x + xx + n, n - x + n - xx + n ;  $  TAB6 else ;  $  TAB7 set l to call function g with argument xx - x ;  $  TAB1 display 1 ;
TAB1 t = long long integer ;  $  TAB1 read t ;  $  TAB1 while t is greater than 0 while decrementing by 1 ;  $  TAB2 l, r = long long integers ;  $  TAB2 read l and r ;  $  TAB2 while l or l + 1 are <= r, set l to l or l + 1 ;  $  TAB2 print l ;
TAB1 mp = map from char to char ;  $  TAB1 set mp[6] = 6 ;  $  TAB1 set mp[7] = 7 ;  $  TAB1 set mp[8] = 8 ;  $  TAB1 set mp[9] = 9 ;  $  TAB1 set mp[T] = 10 ;  $  TAB1 set mp[J] = 11 ;  $  TAB1 set mp[Q] = 12 ;  $  TAB1 set mp[K] = 13 ;  $  TAB1 set mp[A] = 14 ;  $  TAB1 let t, f, s = strings ;  $  TAB1 read t, f, s ;  $  TAB1 if f[1] is not equal to s[1] dothe following ;  $  TAB2 if f[1] is t[0] ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB1 else do the following ;  $  TAB2 if mp[f[0]] is greater than mp[s[0]] ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 n = long long integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i is 1 ;  $  TAB3 print 2 ;  $  TAB2 else ;  $  TAB3 print i * i + 1 * i - 1 ;
TAB0 into the function Minimum which takes two long long integers a and b ;  $  TAB1 if b>= a then swap a and b ;  $  TAB1 c= long long int ;  $  TAB1 for c=b until c%a is not 0, c=c + b ;  $  TAB2 do nothing ;  $  TAB1 return c ;  $  TAB1 a,b=strings ;  $  TAB1 n=long long integer ;  $  TAB1 read n,a,b ;  $  TAB1 create integers l1= length of a and l2= length of b ;  $  TAB1 create long long integer both = minimum of l1 and l2 ;  $  TAB1 create short prog[both] = 0 ;  $  TAB1 for i=0 to both exclusive ;  $  TAB2 if a[ i % l1 ] is equal to p ;  $  TAB3 if b[ i % l2 ] is equal to p ;  $  TAB4 then set prog[i]=0 ;  $  TAB3 else if b[i % l2] = 'R' ;  $  TAB4 set prog[i] = 1 ;  $  TAB3 else do the following ;  $  TAB4 set prog[i] = 2 ;  $  TAB2 else if a[i % l1] = 'R' ;  $  TAB3 if b[i % l2] = 'P' ;  $  TAB4 set prog[i] = 2 ;  $  TAB3 else if b[i % l2] = 'R' ;  $  TAB4 set prog[i] =0 ;  $  TAB3 else do the following ;  $  TAB4 set prog[i] = 1 ;  $  TAB2 else do the following ;  $  TAB3 if b[i % l2] = 'P' ;  $  TAB4 set prog[i] = 1 ;  $  TAB3 else if b[i % l2] = 'R' ;  $  TAB4 set prog[i] = 2 ;  $  TAB3 else do the following ;  $  TAB4 set prog[i] = 0 ;  $  TAB1 create integers loss1= 0, loss2=0 and rl1 and rl2 ;  $  TAB1 for i=0 to both exclusive ;  $  TAB2 if prog[i] is not 0 ;  $  TAB3 if prog[i] = 1 ;  $  TAB4 increment loss2 ;  $  TAB3 else do the following ;  $  TAB4 add 1 to loss1 ;  $  TAB1 set rl1 = n / both * loss1 ;  $  TAB1 set rl2 = n / both * loss2 ;  $  TAB1 for i=0 to n%both exclusive ;  $  TAB2 if prog[i] is 1 then increment rl2 ;  $  TAB2 if prog[i] is 2 then increment rl1 ;  $  TAB1 print rl1 and rl2 ;
TAB1 let a, b, x, y be integers ;  $  TAB1 input a, b ;  $  TAB1 let str be a string ;  $  TAB1 input str ;  $  TAB1 let m and n be characters ;  $  TAB1 while decrement b ;  $  TAB2 input x, y ;  $  TAB2 input m, n ;  $  TAB2 for i = x - 1 to y exclusive ;  $  TAB3 if str[i] equals m, set str[i] to n ;  $  TAB1 print str ;
TAB0 declare string str ;  $  TAB0 declare set<string> S ;  $  TAB1 declare string temp ;  $  TAB1 read str ;  $  TAB1 define int len = length of str ;  $  TAB1 for i = 1 to len inclusive ;  $  TAB2 set temp to str.substr(i) + str.substr(0, i) ;  $  TAB2 insert temp into S ;  $  TAB1 print S length ;
TAB1 create long int state = 0, n, m, x ;  $  TAB1 create bool magic = true ;  $  TAB1 read n ;  $  TAB1 while n ;  $  TAB2 set m to n mod 10 ;  $  TAB2 set n to n / 10 ;  $  TAB2 if m equals 1 ;  $  TAB3 set state to 0 ;  $  TAB2 else if m equals 4 and state less than 2 ;  $  TAB3 increase state by 1 ;  $  TAB2 else ;  $  TAB3 set magic to false ;  $  TAB1 if state not equal 0, set magic to false ;  $  TAB1 if magic ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 create a constant integer maxn with maxn=1000 ;  $  TAB0 c=array of character of size maxn ;  $  TAB1 n=integer ;  $  TAB1 create an integer ans with ans=0 ;  $  TAB1 read n ;  $  TAB1 while c is true read the value of c and do the following ;  $  TAB2 create an integer cnt=0 ;  $  TAB2 for i=0 to strlen is of length s exclusive ;  $  TAB3 if c[i] >= 'A' and c[i] <= 'Z' then increment cnt ;  $  TAB2 set ans = maximum of ans and cnt ;  $  TAB1 print ans ;
TAB1 create int N, K ;  $  TAB1 read N and K ;  $  TAB1 create int C ;  $  TAB1 read C ;  $  TAB1 create vector<int> arr of size N, initialized to 0 ;  $  TAB1 for c = 0 to C exclusive ;  $  TAB2 create int tmp ;  $  TAB2 read tmp ;  $  TAB2 set arr[tmp - 1] to 1 ;  $  TAB1 create int cnt = 0 ;  $  TAB1 create int res = 0 ;  $  TAB1 for i = 0 to N exclusive ;  $  TAB2 increment cnt ;  $  TAB2 if arr[i] equals 1 ;  $  TAB3 set cnt to 0 ;  $  TAB3 increment res ;  $  TAB2 else if cnt equals K ;  $  TAB3 set arr[i] to 1 ;  $  TAB3 set cnt to 0 ;  $  TAB3 increment res ;  $  TAB1 print res ;
TAB0 let maxs = iteger with value = 9999999 ;  $  TAB1 let n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 let a = array of integers of size 105 and c = 105 arrays of integers of size 105 ;  $  TAB1 read n values into array a ;  $  TAB1 for integer i=1 to m inclusive do the following ;  $  TAB2 let u, v = integers ;  $  TAB2 read u, v ;  $  TAB2 set c[u][v] = 1 ;  $  TAB2 set c[v][u] = 1 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 for integer j=i+1 to n inclusive ;  $  TAB3 for integer o = j+1 to n inclusive do the following ;  $  TAB4 if c[i][j] and c[j][o] and c[i][o] do the following ;  $  TAB5 let sum = integer with value = a[i] +a[j] + a[o] ;  $  TAB5 set maxs = min of maxs and sum ;  $  TAB1 if maxs = 9999999 ;  $  TAB2 print -1 ;  $  TAB1 else print maxs ;  $  TAB2 print maxs ;
TAB1 let n and x be integers ;  $  TAB1 input n and x ;  $  TAB1 let y be an integer ;  $  TAB1 let s be an integer set to 0 ;  $  TAB1 iterate n times ;  $  TAB2 input y ;  $  TAB2 add y to s ;  $  TAB1 assign absolute value s to s ;  $  TAB1 if s is equal to 0 ;  $  TAB2 output 0 ;  $  TAB1 if s is less than x ;  $  TAB2 output 1 ;  $  TAB1 let ans be an integer set to 0 ;  $  TAB1 while s is positive ;  $  TAB2 subtract x from s ;  $  TAB2 increment ans ;  $  TAB1 output ans ;
TAB0 let n,m,maxi = integers and a,b,cnt = arrays of integers size 10001 ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 read m ;  $  TAB1 for J = 0 to m do the following ;  $  TAB2 read b[J] ;  $  TAB2 for I = 0 to n do the following ;  $  TAB3 if b[J] modulo a[I] is 0 do the following ;  $  TAB4 increment cnt[b[J]/a[I] ;  $  TAB4 set maxi to max of maxi and b[J]/a[I] ;  $  TAB1 print cnt[maxi] ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 c= character ;  $  TAB1 create integer cnt=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read c ;  $  TAB2 if c is equal to 1 ;  $  TAB3 add 1 to cnt ;  $  TAB2 else do the following ;  $  TAB3 print cnt ;  $  TAB3 set cnt to 0 ;  $  TAB1 print cnt and new line ;
TAB1 m,n,temp,i,j = integers ;  $  TAB1 create integer vector a ;  $  TAB1 read m and n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read temp ;  $  TAB2 add temp to end of a ;  $  TAB1 sort a ;  $  TAB1 create integer min=1000000 ;  $  TAB1 for i=0 and j=m-1 to j<n ;  $  TAB2 if a[j]-a[i] < min then set min=a[j]-a[i] ;  $  TAB1 print min ;
TAB1 let v1 be a char vector ;  $  TAB1 let v2 be a char vector ;  $  TAB1 a= long long integer ;  $  TAB1 read a ;  $  TAB1 s1,s2 = strings ;  $  TAB1 read s1 and s2 ;  $  TAB1 e1,e2= integers ;  $  TAB1 set e1 of length of s1 ;  $  TAB1 set e2 to length of s2 ;  $  TAB1 let ans1 and ans2 be long long integer with values 0 ;  $  TAB1 for i=0 to e1*e2 exclusive ;  $  TAB2 if s1[i % e1] = s2[i % e2] then ;  $  TAB3 set ans1 = ans1+0 ;  $  TAB3 set ans2 = ans2 ;  $  TAB2 else if s1[i % e1] == 'S' and s2[i % e2] = 'P' ;  $  TAB3 then increment ans1 ;  $  TAB2 else if s1[i % e1] = 'P' and s2[i % e2] = 'S' ;  $  TAB3 increment ans2 ;  $  TAB2 else if s1[i % e1] = 'P' and s2[i % e2] = 'R' ;  $  TAB3 increment ans1 ;  $  TAB2 else if s1[i % e1] = 'R' and s2[i % e2] = 'P' then do the following ;  $  TAB3 increment ans2 ;  $  TAB2 else if s1[i % e1] = 'R' and s2[i % e2] = 'S' ;  $  TAB3 add 1 to ans1 ;  $  TAB2 else if s1[i % e1] = 'S' and s2[i % e2] = 'R' ;  $  TAB3 set ans2=ans2+1 ;  $  TAB1 set ans1= ans1* a / (e1 * e2 ;  $  TAB1 set ans2 = ans2* a / (e1 * e2) ;  $  TAB1 set a=a%(e1 * e2) ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 if s1[i % e1] = s2[i % e2] ;  $  TAB3 set ans1= ans1 ;  $  TAB3 do nothing ;  $  TAB2 else if s1[i % e1] = 'S' and s2[i % e2] = 'P' ;  $  TAB3 add 1 to ans1 ;  $  TAB2 else if s1[i % e1] = 'P' and s2[i % e2] = 'S' ;  $  TAB3 add 1 to ans2 ;  $  TAB2 else if s1[i % e1] = 'P' and s2[i % e2] = 'R' ;  $  TAB3 increment ans1 ;  $  TAB2 else if s1[i % e1] = 'R' and s2[i % e2] = 'P' ;  $  TAB3 increment ans2 ;  $  TAB2 else if s1[i % e1] = 'R' and s2[i % e2] = 'S' ;  $  TAB3 add 1 to ans1 ;  $  TAB2 else if s1[i % e1] = 'S' and s2[i % e2] = 'R' ;  $  TAB3 increment ans2 ;  $  TAB1 print ans2 and ans1 and new line ;
TAB1 create long long integers n, m, k, s, i, j, h with s = 0, j = 0, h = 0 ;  $  TAB1 read n,m,k ;  $  TAB1 for i=0 to k exclusive ;  $  TAB2 if j+1 <= n-j and h+1<=m-1 then ;  $  TAB3 if j+! is not equal to n-j ;  $  TAB4 set s = s + 2*(m-2 * h-2) ;  $  TAB3 else do the following ;  $  TAB4 set s =s+2 * (m - 2 * h - 2) ;  $  TAB3 if h+1 is not equal to m-h ;  $  TAB4 set s=s+2 * (n - 2 * j) ;  $  TAB3 else do the following ;  $  TAB4 assign s+2 * (n - 2 * j) to s ;  $  TAB3 set h=h+2 ;  $  TAB3 add 2 to j ;  $  TAB2 else do the following ;  $  TAB3 break ;  $  TAB1 print s ;
TAB0 x, t, a, b, da, db are integers ;  $  TAB0 sum = integer ;  $  TAB1 read x, t, a, b, da, db ;  $  TAB1 if x is 0 ;  $  TAB2 print YES ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 for j = 0 to t exclusive ;  $  TAB3 sum1 = integer = a - (da * i) ;  $  TAB3 sum2 = integer = b - (db * j) ;  $  TAB3 if sum1 is x or sum2 is x or sum1 + sum2 is x ;  $  TAB4 print YES ;  $  TAB1 print NO ;
TAB1 make integers n, x, s = 0 ;  $  TAB1 read n and x ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 make integer a ;  $  TAB2 read a ;  $  TAB2 add a to s ;  $  TAB1 set s to abs(s) ;  $  TAB1 print (s + x - 1) / x ;
TAB0 let n, a, b, c, d, e, f be integers ;  $  TAB0 in function solve ;  $  TAB1 read n, a, b, c, d, e, f ;  $  TAB1 d1 and d3 are integers with d1 = a - c, d3 = a - e ;  $  TAB1 d2 and d4 are integers with d2 = b - d, d4 = b - f ;  $  TAB1 if both d1 and d3 are less than 0 or both d1 and d3 are greater than 0 ;  $  TAB2 if both d2 and d4 are less than 0 or both d2 and d4 are less than 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB1 else ;  $  TAB2 print NO ;  $  TAB1 call function solve ;
TAB1 n = integer, a = integer array of size 100 ;  $  TAB1 input n ;  $  TAB1 ans = string = -1 ;  $  TAB1 read n values into array a ;  $  TAB1 if n is greater than 1 ;  $  TAB2 s = integer = a[n - 2] ;  $  TAB2 t = integer = a[n - 1] ;  $  TAB2 if t is 0 ;  $  TAB3 set ans to UP ;  $  TAB2 else if t is 15 ;  $  TAB3 set ans to DOWN ;  $  TAB2 else if s is less than t ;  $  TAB3 set ans to UP ;  $  TAB2 else ;  $  TAB3 set ans to DOWN ;  $  TAB1 else ;  $  TAB2 t = integer = a[n - 1] ;  $  TAB2 if t is 0 ;  $  TAB3 set ans to UP ;  $  TAB2 else if t is 15 ;  $  TAB3 set ans to DOWN ;  $  TAB1 display ans ;
TAB1 n, m = integers ;  $  TAB1 read n ;  $  TAB1 set m to n ;  $  TAB1 a = array of integers length of 6 set to {0} ;  $  TAB1 b, c = arrays of strings length of 6 ;  $  TAB1 set b[0] to "purple" ;  $  TAB1 set b[1] to "green" ;  $  TAB1 set b[2] to "blue" ;  $  TAB1 set b[3] to "orange" ;  $  TAB1 set b[4] to "red" ;  $  TAB1 set b[5] to "yellow" ;  $  TAB1 set c[0] to "Power" ;  $  TAB1 set c[1] to "Time" ;  $  TAB1 set c[2] to "Space" ;  $  TAB1 set c[3] to "Soul" ;  $  TAB1 set c[4] to "Reality" ;  $  TAB1 set c[5] to "Mind" ;  $  TAB1 while n is greater than 0 while decrementing by 1 ;  $  TAB2 s = string ;  $  TAB2 read s ;  $  TAB2 for i = 0 to 6 exclusive ;  $  TAB3 if s is b[i], increment a[i] by 1 ;  $  TAB1 print 6 - m ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 if a[i] is 0, print c[i] ;
TAB1 a=array of integer of size 3 and create integer s,d with s=100000 ;  $  TAB1 read a[0],a[1],a[2] ;  $  TAB1 sort a ;  $  TAB1 fori=1 to a[2] inclusive ;  $  TAB2 if i<=a[0] ;  $  TAB3 set d = (a[0] + a[1] + a[2]) - (3 * i) ;  $  TAB2 else if i<=a[1] ;  $  TAB3 set d=(a[1] + a[2]) - (a[0] + i) ;  $  TAB2 else if i <= a[2] ;  $  TAB3 set d=(a[2] + i) - (a[0] + a[1]) ;  $  TAB2 else do the following ;  $  TAB3 set d = (3 * i) - (a[0] + a[1] + a[2]) ;  $  TAB2 set s= min of s and d ;  $  TAB1 print s ;
TAB0 in function gcd with parameters integers b, c and return integer ;  $  TAB1 if c equals 0, return b ;  $  TAB1 return call gcd with c, b modulo c ;  $  TAB1 a = integer ;  $  TAB1 read a ;  $  TAB1 x, y, and z are all integers all set to 0 ;  $  TAB1 for i = 0 to a exclusive ;  $  TAB2 input x ;  $  TAB2 set y to call gcd with x, y ;  $  TAB1 set z to the product of a and y ;  $  TAB1 display z ;
TAB0 c, d, e, w, n, k, s, m = long long ;  $  TAB0 a, b = double ;  $  TAB0 p = long long array of 301 elements ;  $  TAB1 read n and m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if i is odd, print "#" ;  $  TAB3 if c is even and i is even ;  $  TAB4 if j does not equal m ;  $  TAB5 print "." ;  $  TAB4 else ;  $  TAB5 print "#" ;  $  TAB3 if c is odd and i is even ;  $  TAB4 if j equals 1 ;  $  TAB5 print "#" ;  $  TAB4 else ;  $  TAB5 print "." ;  $  TAB2 print newline ;  $  TAB2 if i is even, increment c ;
TAB1 let n be long integer ;  $  TAB1 read n ;  $  TAB1 create long int sum=0 ;  $  TAB1 for i=1 to n inclusive set sum=sum+i ;  $  TAB1 num=integer ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 read num ;  $  TAB2 set sum = sum-num ;  $  TAB1 read sum ;
TAB0 let vis be array of integers of size 105 ;  $  TAB1 let n, k be integers ;  $  TAB1 read n and k ;  $  TAB1 let num be integer with num = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let x be integer ;  $  TAB2 read x ;  $  TAB2 if vis[x] is equal to 0 ;  $  TAB3 set vis[x] to i + 1 ;  $  TAB3 increment num by 1 ;  $  TAB1 if num is less than k ;  $  TAB2 print NO with newline ;  $  TAB1 else ;  $  TAB2 print YES with newline ;  $  TAB2 let j be integer with j = 0 ;  $  TAB2 call sort with vis and vis + 101 ;  $  TAB2 for i = 0 to 100 inclusive ;  $  TAB3 if vis[i] is equal to zero ;  $  TAB4 if k is equal to 1 ;  $  TAB5 print vis[i] with newline ;  $  TAB4 else if k is greater than 1 ;  $  TAB5 print out vis[i] + one empty space ;  $  TAB4 else ;  $  TAB5 break ;  $  TAB4 decrement k by 1 ;
TAB1 create integers n and m ;  $  TAB1 create character array S with a length of 1100 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read S ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if S[j] is equal to '.' ;  $  TAB4 if (i + j) BITWISE AND 1 ;  $  TAB5 assign 'W' to S[j] ;  $  TAB4 else ;  $  TAB5 assign 'B' to S[j] ;  $  TAB2 print S ;
TAB1 create long long integers n and sum=0 ;  $  TAB1 while c is valid, read c and do the following ;  $  TAB2 if n%2 is equal to 0 ;  $  TAB3 set sum to n/2 ;  $  TAB2 else do the following ;  $  TAB3 set sum to (n-2)/2-n ;  $  TAB2 print sum and a new line ;
TAB1 let n, a, b be doubles ;  $  TAB1 input n, a, and b ;  $  TAB1 z = double = (n) * (b / 100.0) ;  $  TAB1 z1 = integer = z ;  $  TAB1 if z - z1 doesn't equal 0, increment z1 ;  $  TAB1 if z1 - a is positive ;  $  TAB2 display z1 - a ;  $  TAB1 else ;  $  TAB2 display 0 ;
TAB1 a, b, c, s1, s2, s3 are long longs ;  $  TAB1 read s1, s2, s3 ;  $  TAB1 set a to square root ((s1 * s3) / s2) ;  $  TAB1 set b to square root ((s1 * s2) / s3) ;  $  TAB1 set c to square root ((s3 * s2) / s1) ;  $  TAB1 sum is a long long initialized to a + b + c ;  $  TAB1 display 4 * sum ;
TAB1 let n and counter be integers ;  $  TAB1 p is an integer array of sizes 52 and 52, w and h are both integer arrays both of size 52 ;  $  TAB1 while input n ;  $  TAB2 assign 0 to counter ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 sum is an integer set to 0 ;  $  TAB3 for j = 0 to n exclusive ;  $  TAB4 read p[i][j] ;  $  TAB4 add p[i][j] to sum ;  $  TAB3 set h[i] to sum ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 sum is an integer set to 0 ;  $  TAB3 for j = 0 to n exclusive, add p[i][j] to sum ;  $  TAB3 set w[i] to sum ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 for j = 0 to n exclusive ;  $  TAB4 if w[i] is greater than h[j], increment counter ;  $  TAB2 display counter ;
TAB1 a=string ;  $  TAB1 read a ;  $  TAB1 create an integer l = size of a ;  $  TAB1 create an integer max1=0 ;  $  TAB1 for i=0 to l exclusive ;  $  TAB2 for j=i+1 to l exclusive ;  $  TAB3 create an integer m =0 ;  $  TAB3 while a[i + m] = a[j + m] then increment m ;  $  TAB3 set max1 = maximum of m and max1 ;  $  TAB1 print max1 ;
TAB0 maxn = constant integer = 1e2 + 10 ;  $  TAB0 arr = boolean array of size maxn ;  $  TAB1 n, t, ans are integers with t and ans both set to 0 ;  $  TAB1 input n ;  $  TAB1 b = boolean = false ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input arr[i] ;  $  TAB2 if arr[i] ;  $  TAB3 if t equals 1, increment ans ;  $  TAB3 set b to true, increment ans, set t to 0 ;  $  TAB2 else if b ;  $  TAB3 increment t ;  $  TAB1 display ans ;
TAB0 declare integer function paraarriba taking in character fuente and destino ;  $  TAB1 let f = integer with value fuente - a ;  $  TAB1 let d = integer with value = destino - a ;  $  TAB1 let contador = integer with value 0 ;  $  TAB1 while true do the following ;  $  TAB2 if f is d ;  $  TAB3 exit the loop ;  $  TAB2 else ;  $  TAB3 set f = f + 1 ;  $  TAB3 set f = f modulo 26 ;  $  TAB3 increment contador ;  $  TAB1 return contador ;  $  TAB0 declare integer function paraabajo taking in integers fuente and destino ;  $  TAB1 let f = integer with value fuente - a ;  $  TAB1 let d = integer with destino - a ;  $  TAB1 let contador = integer with value = 0 ;  $  TAB1 while true do the following ;  $  TAB2 if f is d ;  $  TAB3 exit the loop ;  $  TAB2 else ;  $  TAB3 set f = f - 1 ;  $  TAB3 if f is less than 0 set f = 25 ;  $  TAB3 increment contador ;  $  TAB1 return contador ;  $  TAB0 let casos = integer ;  $  TAB0 let tira = string ;  $  TAB0 let actual = character ;  $  TAB0 let saltos = integer ;  $  TAB1 read tira ;  $  TAB1 set actual = a ;  $  TAB1 set saltos = 0 ;  $  TAB1 for integer i=0 to size of tira do the following ;  $  TAB2 let a = integer with value = min of call paraarriba on actual and tira[i], and call paraabajo on actual and tira[i] ;  $  TAB2 set saltos = saltos + a ;  $  TAB2 set actual = tira[i] ;  $  TAB1 print saltos ;
TAB0 let a, b be array of char of size 1000005 ;  $  TAB1 read a ;  $  TAB1 read b ;  $  TAB1 let lena be integer with lena = strlen of a ;  $  TAB1 let lenb be integer with lenb = strlen of b ;  $  TAB1 let i, j be integers ;  $  TAB1 for i = 0 to lena exclusive ;  $  TAB2 if a[i] is not equal to '0', break ;  $  TAB1 for j = 0 to lenb exclusive ;  $  TAB2 if b[j] is not equal to '0', break ;  $  TAB1 let ok be integer with ok = 0 ;  $  TAB1 if lena - i is equal to lenb - j ;  $  TAB2 while i is less than lena and j is less than lenb ;  $  TAB3 if a[i] is greater than b[j] ;  $  TAB4 set ok to -1 ;  $  TAB4 break ;  $  TAB3 else if a[i] is less than b[j] ;  $  TAB4 set ok to 1 ;  $  TAB4 break ;  $  TAB3 increment i and j ;  $  TAB1 else if lena - i is greater than lenb - j ;  $  TAB2 set ok to -1 ;  $  TAB1 else ;  $  TAB2 set ok to 1 ;  $  TAB1 if of is equal to -1 ;  $  TAB2 print > ;  $  TAB1 else if ok is equal to 1 ;  $  TAB2 print < ;  $  TAB1 else ;  $  TAB2 print = ;
TAB1 a, b, temp are all character arrays all of size 105 ;  $  TAB1 call gets with argument a ;  $  TAB1 call gets with argument b ;  $  TAB1 j is an integer with j = 0 ;  $  TAB1 l1 is an integer with l1 = call strlen with argument a ;  $  TAB1 l2 is an integer with l2 = call strlen with argument b ;  $  TAB1 for i = l2 - 1 to 0 inclusive with decrement i and increment j, set temp[j] to b[i] ;  $  TAB1 flag is an integer with flag = 1 ;  $  TAB1 for m = 0 to l2 and l1 exclusive ;  $  TAB2 if a[m] is unequal to temp[m] ;  $  TAB3 assign 0 to flag ;  $  TAB3 break ;  $  TAB1 if flag ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB0 create array a and b of integer of size 1005 and an integer n ;  $  TAB1 while n is true read n ;  $  TAB2 read n value into array of a ;  $  TAB2 read n value into array of b ;  $  TAB2 create an integer ans with ans=0 ;  $  TAB2 for i=1 to n inclusive ;  $  TAB3 create integer aa=a[i] and bb=b[i] ;  $  TAB3 set ans to max of ans and aa+bb ;  $  TAB3 for j=i+1 to n inclusive ;  $  TAB4 set aa=aa | a[j] ;  $  TAB4 set bb=bb | b[j] ;  $  TAB4 set ans to max of ans and aa+bb ;  $  TAB2 print ans ;
TAB1 let n, x, and res be integers with res = 0 ;  $  TAB1 inputn ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 add x * i * 4 to res ;  $  TAB1 display res ;
TAB0 let maxn be const integer with maxn = 1e5 + 10 ;  $  TAB0 let arr be array of booleans of size maxn ;  $  TAB0 let s be string and ss be array of strings of size maxn ;  $  TAB0 let c be char ;  $  TAB0 let n be integer ;  $  TAB0 in function input ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read ss[i] ;  $  TAB1 read s, c ;  $  TAB0 in function low which takes char x and returns char ;  $  TAB1 if x is greater than or equal to A and x is less than or equal to Z, update x to x - 'A' + 'a' ;  $  TAB1 return x ;  $  TAB1 call input ;  $  TAB1 let w be integer with w = size of s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for wi = 0 to till wi + size of ss[i] - 1 is less than w ;  $  TAB3 let b be boolean with b = true ;  $  TAB3 for ssj = wi to till ssj is less than wi + size of ss[i] ;  $  TAB4 if low of s[ssj] is not equal to low of ss[i][ssj-wi] ;  $  TAB5 set b to false ;  $  TAB5 break ;  $  TAB3 if b is not false ;  $  TAB4 for ssj = wi to till ssj is less than wi + size of ss[i], set arr[ssj] to true ;  $  TAB1 for i = 0 to w exclusive ;  $  TAB2 if arr[i] is not zero ;  $  TAB3 if low of s[i] is equal to c ;  $  TAB4 if c is equal to 'a' ;  $  TAB5 update s[i] to s[i] + ('b' - low of s[i]) ;  $  TAB4 else ;  $  TAB5 update s[i] to s[i] + ('a' - low of s[i]) ;  $  TAB3 else ;  $  TAB4 update s[i] to s[i] + (c - low of s[i]) ;  $  TAB1 print out s with newline ;
TAB0 i, n, c are integers, a = integer array of size 128 ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] or i is positive and a[i - 1] and i is less than n - 1 and a[i + 1], increment c ;  $  TAB1 display c ;
TAB1 a is a character array of length 19 ;  $  TAB1 k is an integer with k = 0 ;  $  TAB1 input a ;  $  TAB1 for i = 0 with the condition a[i] is not equal to '\0' ;  $  TAB2 if a[i] is equal to either 4 or 7, increment k ;  $  TAB1 if k is equal to either 4 or 7 ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB0 let v be vector of long lon ;  $  TAB0 define function Power which takes integer n and with return type long long ;  $  TAB1 let ans be long long with ans = 1 ;  $  TAB1 for i = 1 to n, ans = ans * 10 ;  $  TAB1 return ans ;  $  TAB1 let l and r be integers ;  $  TAB1 for k = 1 to 10 ;  $  TAB2 for i = 0 to 1 << k exclusive ;  $  TAB3 let arr be long long array of size k + 2 ;  $  TAB3 for j = 0 to k-1, set arr[j] to 4 ;  $  TAB3 for j = 0 to k exclusive ;  $  TAB4 if i & 1<<j is not zero, set arr[j] to 7 ;  $  TAB3 let num be long long with num = 0 ;  $  TAB3 for j = 0 to k-1, add arr[j] * (Power of j) ;  $  TAB3 add num to the end of v ;  $  TAB1 sort vector v ;  $  TAB1 read l and r ;  $  TAB1 let lIdx be integer with lIdx = lower_bound of v.begin(), v.end(), l - v.begin() ;  $  TAB1 let lIdx be integer with rIdx = lower_bound of v.begin(), v.end(), r - v.begin() ;  $  TAB1 let sum be long long with sum = (v[lIdx] - l + 1) * v[lIdx] ;  $  TAB1 for i = lIdx + 1 to rIdx, add (v[i] - v[i-1]) * v[i] to sum ;  $  TAB1 add (r - v[rIdx]) * v[rIdx] to sum ;  $  TAB1 print out sum with newline ;
TAB1 let n, m, i be integers ;  $  TAB1 let ans be a long long ;  $  TAB1 input n, m ;  $  TAB1 if m is less than n, call swap with n, m ;  $  TAB1 set ans to 1 ;  $  TAB1 for i = 2 to n inclusive, multiply ans by i ;  $  TAB1 display ans ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a is a character array of sizes n and n ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, read a[i][j] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 c1, c2 are integers both set to 0 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 add (a[i][j] is equal to the character C) to c1 ;  $  TAB3 add (a[j][i] is equal to the character C) to c2 ;  $  TAB2 if c1 is at least 2, add (c1 * (c1 - 1)) / 2 to ans ;  $  TAB2 ic c2 is at least 2, add (c2 * (c2 - 1)) / 2 to ans ;  $  TAB1 display ans ;
TAB1 make strings s1 and s2 ;  $  TAB1 make integer out = 0 ;  $  TAB1 read s1 and s2 ;  $  TAB1 for i = 0 to s1 size exclusive ;  $  TAB2 if tolower(s1[i]) is greater than tolower(s2[i]) ;  $  TAB3 set out to 1 ;  $  TAB3 break ;  $  TAB2 if tolower(s1[i]) is less than tolower(s2[i]) ;  $  TAB3 set out to -1 ;  $  TAB3 break ;  $  TAB1 print out ;
TAB0 create a constant integer N=110 ;  $  TAB0 create long long integer MAX=1e8 + 5 ;  $  TAB0 a=integer array of size N, n.k.ans=integers ;  $  TAB1 read n,k ;  $  TAB1 read n values into array a ;  $  TAB1 let flag1 and flag2 be ints with flag1=flag2=1 ;  $  TAB1 for i=0 and j=n-1 until i<=j, increment i and decrement j ;  $  TAB2 if flag1 is 0 and flag2 is 0 then break ;  $  TAB2 if a[i]<=k and flag1 is 1 then increment ans ;  $  TAB2 if a[i]>k ;  $  TAB3 set flag1 to 0 ;  $  TAB3 set i to i-1 ;  $  TAB2 if a[j]<=k and flag2 is 1 and ans<n then increment ans ;  $  TAB2 if a[j]>k ;  $  TAB3 set flag2=0 ;  $  TAB3 increment j ;  $  TAB1 print ans and new line ;
TAB1 create integers length, width and radius ;  $  TAB1 input length, width and radius ;  $  TAB1 if length >= 2*radius and width>=2*radius ;  $  TAB2 print First ;  $  TAB1 else do the following ;  $  TAB2 print Second ;
TAB1 n, c are integers ;  $  TAB1 read n, c ;  $  TAB1 a is an integer array of size n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 k is an integer set to 0 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if a[i + 1] - a[i] is at most c ;  $  TAB3 increment k ;  $  TAB2 else ;  $  TAB3 set k to 0 ;  $  TAB1 display 1 + k ;
TAB1 let n and k be integers ;  $  TAB1 input n and k ;  $  TAB1 while decrement k ;  $  TAB2 if n is divisible by 10 ;  $  TAB3 divide n by 10 ;  $  TAB2 else ;  $  TAB3 decrement n ;  $  TAB1 print n ;
TAB0 create a constant integer mxn with mxn=1e5+7 ;  $  TAB1 s,d=string ;  $  TAB1 create long long integer n ;  $  TAB1 read s,d ;  $  TAB1 read n ;  $  TAB1 print s and d ;  $  TAB1 do nothing ;  $  TAB1 for i=o to n exclusive ;  $  TAB2 a,b=string ;  $  TAB2 read a,b ;  $  TAB2 if a=s ;  $  TAB3 set s=b ;  $  TAB2 else if b is not equal to s ;  $  TAB3 set d=b ;  $  TAB2 print s and d ;
TAB1 declare int n, d ;  $  TAB1 read n, d ;  $  TAB1 if n is equal to 1 ;  $  TAB2 print "0" ;  $  TAB1 else ;  $  TAB2 declare vector v containing integers ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 declare int a ;  $  TAB3 read a ;  $  TAB3 add a to v ;  $  TAB2 sort v ;  $  TAB2 define int count = 1 ;  $  TAB2 for i = 0; i + 1 less than n; increment i ;  $  TAB3 for j = i + 1; j less than n; increment j ;  $  TAB4 if v[j] - v[i] less than or equal to d, set count to max of count and j - i + 1 ;  $  TAB2 print n - count ;  $  TAB1 print newline ;
TAB1 declare int n, m, s ;  $  TAB1 declare double k ;  $  TAB1 read n, m, k ;  $  TAB1 declare string a ;  $  TAB1 declare map myMap with string keys and int values ;  $  TAB1 declare myMap iterator i ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, s ;  $  TAB2 if s * k is less than 100 ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 set myMap[a] to s * k + 1e-6 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read a ;  $  TAB2 if myMap[a] equals 0: set myMap[a] to 0 ;  $  TAB1 print length of myMap with newline ;  $  TAB1 print all key value pairs for myMap ;
TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 let ans = long long with value = 0 ;  $  TAB1 let cnt = integer with value = 0 ;  $  TAB1 let vec = vector of integers ;  $  TAB1 for integer i=0 to size of s exclusive do the following ;  $  TAB2 if s[i] is Q do the following ;  $  TAB3 for integer j=0 to size of vec exclusive set ans = ans + vec[j] ;  $  TAB3 increment cnt ;  $  TAB2 else if s[i] is A ;  $  TAB3 append cnt to vec ;  $  TAB1 print ans ;
TAB1 a,b=strings ;  $  TAB1 create an integer n with n=0 ;  $  TAB1 read a ;  $  TAB1 for i=0 to size of a exclusive ;  $  TAB2 if a[i] = 'h' and n = 0 ;  $  TAB3 set b=b+'h' ;  $  TAB3 increment n ;  $  TAB3 continue ;  $  TAB2 if a[i] = 'e' and n = 1 ;  $  TAB3 set b=b+e ;  $  TAB3 increment n ;  $  TAB3 continue ;  $  TAB2 if a[i] = 'l' and n = 2 ;  $  TAB3 b=b+'l' ;  $  TAB3 increment n ;  $  TAB3 continue ;  $  TAB2 if a[i] = 'l' and n = 3 ;  $  TAB3 b=b+'l' ;  $  TAB3 increment n ;  $  TAB3 continue ;  $  TAB2 if a[i] = 'o' and n = 4 ;  $  TAB3 set b=b+0 ;  $  TAB3 break ;  $  TAB1 if b = "hello" ;  $  TAB2 print "YES" ;  $  TAB1 else do the following ;  $  TAB2 print "NO' ;
TAB1 let cycles be an integer ;  $  TAB1 input cycles ;  $  TAB1 a is a boolean array of sizes 100 and 100 with a = 0 ;  $  TAB1 point is an integer set to 1 ;  $  TAB1 i is an integer set to 0 ;  $  TAB1 while cycles is positive ;  $  TAB2 if cycles is less than i ;  $  TAB3 set i to 0 ;  $  TAB3 increment point ;  $  TAB2 assign 1 to a[i][point] ;  $  TAB2 assign 1 to a[point][1] ;  $  TAB2 subtract i from cycles ;  $  TAB2 increment i ;  $  TAB2 if i is at least point and cycles is positive ;  $  TAB3 set i to 0 ;  $  TAB3 increment point ;  $  TAB1 display point + 1 ;  $  TAB1 for i = 0 to point inclusive ;  $  TAB2 for j = 0 to point inclusive, display a[i][j] ;  $  TAB2 display newline ;
TAB0 in function max with parameters long longs a, b and return long long ;  $  TAB1 return a if a is greater than b, otherwise return b ;  $  TAB0 in function min with parameters long longs a, b and return long long ;  $  TAB1 return a if a is less than b, otherwise return b ;  $  TAB0 in function modd with parameter long long a and return long long ;  $  TAB1 if a is less than 0LL, return a * -1LL ;  $  TAB1 return a ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a is an integer array of size n ;  $  TAB1 read n values into array a ;  $  TAB1 min, max are integers both set to a[0] ;  $  TAB1 ans is an integer set to 0 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if max is less than a[i] ;  $  TAB3 set max to a[i] ;  $  TAB3 increment ans ;  $  TAB2 if min is greater than a[i] ;  $  TAB3 set min to a[i] ;  $  TAB3 increment ans ;  $  TAB1 display ans ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let note = array of integer with size = 2 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let temp = integer ;  $  TAB2 read temp ;  $  TAB2 if temp is less than note[0] do the following ;  $  TAB3 set note[1] = i +1 ;  $  TAB3 set note[0] = temp ;  $  TAB2 else if temp is note[0] ;  $  TAB3 set note[1] = -1 ;  $  TAB1 if note[1] is -1 ;  $  TAB2 print Still Rozdil ;  $  TAB1 else ;  $  TAB2 print note[1] ;
TAB1 n, x, y are doubles ;  $  TAB1 input n, x, and y ;  $  TAB1 r is a double with r = ceiling of ((y / 100) * n) ;  $  TAB1 ans is a long with ans = r - x ;  $  TAB1 if ans is negative, set ans to 0 ;  $  TAB1 display ans ;
TAB0 in function last with parameter long long x and return integer ;  $  TAB1 return x modulo 10 ;  $  TAB1 n and k are long longs ;  $  TAB1 input n and k ;  $  TAB1 cnt is a long long with cnt = n / k ;  $  TAB1 if cnt is even ;  $  TAB2 display NO ;  $  TAB1 else ;  $  TAB2 display YES ;
TAB1 m, x, y, i, j are integers ;  $  TAB1 read m ;  $  TAB1 a is an integer array of size m ;  $  TAB1 sum and sum1 are both integers both set to 0 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read a[i] ;  $  TAB2 add a[i] to sum ;  $  TAB1 read x, y ;  $  TAB1 ctr = integer = 0 ;  $  TAB1 for i = 0 to m - 2 inclusive ;  $  TAB2 add a[i] to sum1 ;  $  TAB2 n is an integer set to sum - sum1 ;  $  TAB2 if sum1 is at least x and sum1 is at most y and n is at least x and n is at most y ;  $  TAB3 increment ctr ;  $  TAB3 break ;  $  TAB1 if ctr equals 1 ;  $  TAB2 display i + 2 ;  $  TAB1 else ;  $  TAB2 display 0 ;
TAB0 make static int mod = 1e9 + 7 ;  $  TAB1 make int n, m, array row of size 105, array col of size 105, multidimensional array table of size 105x105, minn, and flag ;  $  TAB1 while read n and m ;  $  TAB2 set flag to 0 ;  $  TAB2 set row elements to 0 ;  $  TAB2 set col elements to 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to m inclusive, read table[i][j] ;  $  TAB2 if m greater than or equal to n ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for j = 1 to m inclusive ;  $  TAB5 if table[i][j] less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 set row[i] to minn ;  $  TAB5 for j = 1 to m inclusive, subtract minn from table[i][j] ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for i = 1 to n inclusive ;  $  TAB5 if table[i][j] less than minn, set minn to table[i]j] ;  $  TAB4 if minn ;  $  TAB5 set col[j] to minn ;  $  TAB5 for i = 1 to n inclusive, subtract minn from table[i][j] ;  $  TAB2 else ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for i = 1 to n inclusive ;  $  TAB5 if table[i][j] less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 set col[j] to minn ;  $  TAB5 for i = 1 to n inclusive, subtract minn from table[i][j] ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for j = 1 to m inclusive ;  $  TAB5 if table[i][j] is less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 set row[i] to minn ;  $  TAB5 for j = 1 to m inclusive, decrease table[i][j] by minn ;  $  TAB2 set flag to 1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 if table[i][j] ;  $  TAB5 set flag to 0 ;  $  TAB5 break ;  $  TAB2 if flag ;  $  TAB3 make int tmp = 0 ;  $  TAB3 for i = 1 to n inclusive, increase tmp by row[i] ;  $  TAB3 for j = 1 to m inclusive, increase tmp by col[j] ;  $  TAB3 print tmp ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 for k = 1 to row[i] inclusive, print "row " i ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 for k = 1 to col[j] inclusive, print "col " j ;  $  TAB2 else ;  $  TAB3 print "-1\n" ;
TAB1 n, l, r, ql, qr, ret = integers with ret set to 1e9 ;  $  TAB1 read n, l, r, ql and qr ;  $  TAB1 a = vector set to n + 1 and 0 ;  $  TAB1 for i = 1 to n inclusive, read a[i] and read a[i] increased by a[i - 1] ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 j, cur = integer with j set to n - i and cur set to a[i] * l + (a[n] - a[i]) * r ;  $  TAB2 if i > j, add i - j - 1 * ql to cur ;  $  TAB2 if i < J, add j - i - 1* qr to cur ;  $  TAB2 set ret to min of ret and cur ;  $  TAB1 print ret ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 arr= array of an integer of size n and create integers i,f0,l0,n1 with f0=-1,l0=-1,n1=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] = 0 ;  $  TAB3 if f0 = -1 set f0 = i ;  $  TAB3 set l0 = i ;  $  TAB2 else do the following ;  $  TAB3 increment n1 ;  $  TAB1 if f0 = -1 ;  $  TAB2 print n-1 ;  $  TAB1 vect = integer vector ;  $  TAB1 create integers flag and count with flag=0 and count=0 ;  $  TAB1 for i=f0 to l0 inclusive ;  $  TAB2 if flag = 0 and arr[i] = 1 ;  $  TAB3 set flag=1 ;  $  TAB3 add count to the end of vect ;  $  TAB3 set count=0 ;  $  TAB2 else if flag = 1 and arr[i] = 0 ;  $  TAB3 set flag =0 ;  $  TAB3 add count to the end of vect ;  $  TAB3 set count=0 ;  $  TAB2 increment count ;  $  TAB2 if i=l0 then add count to the end of vect ;  $  TAB1 create integer j,maks,plus with maks=0 ;  $  TAB1 for i=0 to size of vect exclusive and i=i+2 ;  $  TAB2 set maks=maximum of maks, vect[i] ;  $  TAB2 set plus=0 ;  $  TAB2 for j=i+2 to size of vect exclusive and j=j+2 ;  $  TAB3 set plus = plus +(vect[j] - vect[j - 1]) ;  $  TAB3 set maks =maximum of maks and vect[i] + plus ;  $  TAB1 print n1 + maks ;
TAB0 let board = 101 arrays of characters of size = 101 ;  $  TAB1 let n, m = integers ;  $  TAB1 while (read n, m) is true do the following ;  $  TAB2 for integer i=0 to n exclusive do the following ;  $  TAB3 read a character from stdin ;  $  TAB3 for integer j=0 to m exclusive do the following ;  $  TAB4 if result of reading a character from stdin is - ;  $  TAB5 set board[i][j] = - ;  $  TAB4 else do the following ;  $  TAB5 if i is even do the following ;  $  TAB6 if j is even ;  $  TAB7 set board[i][j] = B ;  $  TAB6 else ;  $  TAB7 set board[i][j] = W ;  $  TAB5 else do the following ;  $  TAB6 if j is odd ;  $  TAB7 set board[i][j] = B ;  $  TAB6 else ;  $  TAB7 set board[i][j] = W ;  $  TAB2 for integer i=0 to n exclusive do the following ;  $  TAB3 for integer j=0 to m exclusive print board[i][j] ;  $  TAB3 print a new line ;
TAB1 n, k, i, j are integers, s is an integer with length 51 ;  $  TAB1 read n, k ;  $  TAB1 read n values into array s ;  $  TAB1 set j to k ;  $  TAB1 if s[k] is positive ;  $  TAB2 for i = k + 1 as long as s[i] equals s[k] with increment i and increment j ;  $  TAB3 terminate statement ;  $  TAB2 display j ;  $  TAB1 else ;  $  TAB2 set j to 0 ;  $  TAB2 for i = 1 to k exclusive ;  $  TAB3 if s[i] is positive, increment j ;  $  TAB2 display j ;
TAB0 let res= long long integer array of size 250 and n=long long integer ;  $  TAB0 into the function can which takes a integer argument x and returns a long long integer ;  $  TAB1 sum= long long integer with value x ;  $  TAB1 while x is true ;  $  TAB2 set sum = sum + x%10 ;  $  TAB2 set x= x/10 ;  $  TAB1 if sum is equal to n then return 1 ;  $  TAB1 co=long long integer ;  $  TAB1 while entered value of n is valid ;  $  TAB2 create long long integer temp=n ;  $  TAB2 set co=0 ;  $  TAB2 for i=0 to 245 exclusive ;  $  TAB3 if temp is less than or equal to 0 then break ;  $  TAB3 decrement temp ;  $  TAB3 if can(temp) is true then set res[co++] to temp ;  $  TAB2 if co is false ;  $  TAB3 print 0 ;  $  TAB2 else do the following ;  $  TAB3 print co and a new line ;  $  TAB3 for i=co-1 to 0 inclusive print res[i] ;
TAB0 M = constant integer = 1e6 + 5 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n doesn't equal 2 ;  $  TAB2 display 1 ;  $  TAB1 else ;  $  TAB2 display 2 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int winner ;  $  TAB1 create int player1 = 1 ;  $  TAB1 create int player2 = 2 ;  $  TAB1 create int pending = 3 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read winner ;  $  TAB2 if winner is equal to player1 ;  $  TAB3 swap pending and player2 ;  $  TAB2 else if winner is equal to player2 ;  $  TAB3 swap player1 and pending ;  $  TAB2 else ;  $  TAB3 print "NO" ;  $  TAB1 print "YES" ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create vector<string> arr of length 10 ;  $  TAB1 read to arr ;  $  TAB1 for i = 0 to 8 exclusive ;  $  TAB2 create string t = s.substr(i * 10, 10) ;  $  TAB2 for j = 0 to 10 exclusive ;  $  TAB3 if arr[j] equals t ;  $  TAB4 print j + '0' cast to char ;  $  TAB4 break ;  $  TAB1 print newline ;
TAB1 tc = integer ;  $  TAB1 read tc ;  $  TAB1 while decrement tc ;  $  TAB2 n = integer ;  $  TAB2 read n ;  $  TAB2 s = string ;  $  TAB2 read s ;  $  TAB2 ada = boolean = 0 ;  $  TAB2 for i = 0 to n / 2 exclusive ;  $  TAB3 x = integer = integer value of s[i] ;  $  TAB3 y = integer = integer value of s[(length of s) - 1 - i] ;  $  TAB3 if absolute value (x - y) is greater than 2 or absolute value (x - y) is 1, set ada to 1 ;  $  TAB2 if ada ;  $  TAB3 print NO ;  $  TAB2 else ;  $  TAB3 print YES ;
TAB1 create a long integer n and mx with mx=1000000000 ;  $  TAB1 dir=string ;  $  TAB1 read n ;  $  TAB1 read dir ;  $  TAB1 arr=array of integer if size n ;  $  TAB1 read arr[0] ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if dir[i - 1] = 'R' and dir[i] = 'L' and ((arr[i] - arr[i - 1]) / 2) < mx) then set mx = (arr[i] - arr[i - 1]) / 2 ;  $  TAB1 if mx =1000000000 set mx = -1 ;  $  TAB1 print mx ;  $  TAB1 print new line ;
TAB1 declare int n, points ;  $  TAB1 read n, points ;  $  TAB1 define int min = points, max = points, amazing = 0 ;  $  TAB1 while decrement n ;  $  TAB2 read points ;  $  TAB2 if points less than min ;  $  TAB3 assign points to min ;  $  TAB3 increment amazing ;  $  TAB2 if points greater than max ;  $  TAB3 assign points to max ;  $  TAB3 increment amazing ;  $  TAB1 print amazing ;
TAB1 n, a, b, count = integers ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n do the following ;  $  TAB2 read a, b ;  $  TAB2 set count = 0 ;  $  TAB2 while a is greaterthan 0 and b is greater than 0 do the following ;  $  TAB3 if a is greater than b do the following ;  $  TAB4 set count = count + a / b ;  $  TAB4 set a = a modulo b ;  $  TAB3 else do the following ;  $  TAB4 set count = count + a / b ;  $  TAB4 set b = b modulo a ;  $  TAB2 print count ;
TAB0 create int n, t, a ;  $  TAB1 read n, t ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 decrease t by 86400 - a ;  $  TAB2 if t is less than or equal to 0 ;  $  TAB3 print i ;
TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 print (size of s + 1) * 25 + 1 ;
TAB0 create string a ;  $  TAB0 create long long tou = -1, wei = -1, mk ;  $  TAB1 read a ;  $  TAB1 for s = 0 to a size exclusive ;  $  TAB2 if a[s] is not 'a' ;  $  TAB3 if tou is -1 then set tou to s ;  $  TAB3 set mk to 1 ;  $  TAB2 else ;  $  TAB3 if tou is not -1 ;  $  TAB4 set wei to s - 1 ;  $  TAB4 break ;  $  TAB1 if wei is -1 and mk is 1 then set wei to a size - 1 ;  $  TAB1 if mk is 0 ;  $  TAB2 set a[a size - 1] to 'z' ;  $  TAB1 else ;  $  TAB2 for s = max((long long)0, tou) to wei inclusive do set a[s] to (a[s] cast to int - 1) cast to char ;  $  TAB1 print a ;
TAB1 n, l are integers with l = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 with no condition with increment i ;  $  TAB2 subtract (i * (i + 1) / 2) from n ;  $  TAB2 if n is at least 0 ;  $  TAB3 increment l ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 display l ;
TAB1 l, r, x, y, k, i = long long ints ;  $  TAB1 while l, r, x, y, k, i values entered are valid, read l, r, x, y, k, i and do the following ;  $  TAB2 create integer flag = 0 ;  $  TAB2 for i=x to y inclusive ;  $  TAB3 if i*k >= l and i*l <= r ;  $  TAB4 then set flag to 1 ;  $  TAB4 break out of the loop ;  $  TAB2 if flag is true ;  $  TAB3 print YES ;  $  TAB2 else do the following ;  $  TAB3 print NO ;
TAB1 let n,i,j,le,to,a be ints with le=to=a=0 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 for j=1 to i inclusive set a=a+j ;  $  TAB2 if a>n then break ;  $  TAB2 add 1 to le ;  $  TAB1 print le ;
TAB1 n, m, a, ans = integers with ans set to 0 ;  $  TAB1 read n, m ;  $  TAB1 c[n] = integer ;  $  TAB1 q = queue of integers ;  $  TAB1 for i = 0 to n exclusive, read c[i] ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read a ;  $  TAB2 push a into q ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if front of q >= c[i] and size of q > 0 ;  $  TAB3 increment ans by 1 ;  $  TAB3 pop off q ;  $  TAB1 print ans ;
TAB1 declare string str ;  $  TAB1 read str ;  $  TAB1 declare set Set holding strings ;  $  TAB1 for i = size of str; i greater than or equal to 1; decrement i ;  $  TAB2 clear Set ;  $  TAB2 for j = 0; j + 1 less than or equal to size of str; increment j, insert str.substr(j, i) into Set ;  $  TAB2 if size of Set is not equal to size of str - i + i ;  $  TAB3 print i ;  $  TAB1 print "0" ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 read s ;  $  TAB1 create integer ans = 0 ;  $  TAB1 for i = 0, cur = 0 to n exlcusive ;  $  TAB2 if s[i] greater than or equal to'A' and s[i] less than or equal to 'Z' ;  $  TAB3 set ans to max of ans and incremented cur ;  $  TAB2 else if s[i] equals ' ' ;  $  TAB3 set cur to 0 ;  $  TAB1 print ans ;
TAB1 n, c, sum are integers with sum = 0 ;  $  TAB1 read n ;  $  TAB1 ara is a character array of sizes n and n ;  $  TAB1 for w = 0 to n exclusive ;  $  TAB2 set c to 0 ;  $  TAB2 for q = 0 to n exclusive ;  $  TAB3 read ara[w][q] ;  $  TAB3 if ara[w][q] is the character C, increment c ;  $  TAB2 add (c * (c - 1)) / 2 to sum ;  $  TAB1 for q = 0 to n exclusive ;  $  TAB2 set c to 0 ;  $  TAB2 for w = 0 to n exclusive ;  $  TAB3 if ara[w][q] is the character C ;  $  TAB2 add (c * (c - 1)) / 2 to sum ;  $  TAB1 output sum ;
TAB0 na, nb, k, m are integers, A and B are integer arrays both of size 100005 ;  $  TAB1 read na, nb ;  $  TAB1 read k, m ;  $  TAB1 read na values into array A ;  $  TAB1 read nb values into array B ;  $  TAB1 if A[k - 1] is less than B[nb - m] ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 create 2D boolean array arr of size 101 by 101 ;  $  TAB1 create long long integers aa and b ;  $  TAB1 read aa and b ;  $  TAB1 create long long integer array cl of size aa ;  $  TAB1 read aa values into the array cl ;  $  TAB1 for a=0 to b-1 inclusive ;  $  TAB2 p,q= long long integers ;  $  TAB2 read p and q ;  $  TAB2 set arr[p - 1][q - 1] = arr[q - 1][p - 1] = 1 ;  $  TAB1 create long long integer p = 1000000000000000 ;  $  TAB1 for a=0 to aa-1 inclusive ;  $  TAB2 for c=a+1 to aa-1 inclusive ;  $  TAB3 for d=c+1 to aa-1 inclusive ;  $  TAB4 if arr[a][c] is true and arr[c][d] is true and arr[d][a] is true and p > cl[a] + cl[c] + cl[d] then set p = cl[a]+ cl[c] + cl[d] ;  $  TAB1 if p is not equal to 1000000000000000 ;  $  TAB2 print p and new line ;  $  TAB1 else do the following ;  $  TAB2 print -1 ;
TAB1 let n = integer ;  $  TAB1 while (read n) is true do the following ;  $  TAB2 let a = array of integers with size = 40 ;  $  TAB2 let b = array of integers with size = 40 ;  $  TAB2 let sum = integers with value = 0 ;  $  TAB2 for integer i=0 to n exclusive do the following ;  $  TAB3 read a[i] ;  $  TAB3 read b[i] ;  $  TAB2 for integer j=0 to n exclusive do the following ;  $  TAB3 for integer i=0 to n exclusive do the following ;  $  TAB4 if a[j] is b[i] increment sum ;  $  TAB2 print sum ;
TAB1 declare int n, m ;  $  TAB1 read n and m ;  $  TAB1 define vector<int> a with n elements ;  $  TAB1 read n elements into a ;  $  TAB1 declare queue<int> que ;  $  TAB1 for i= 0 to m exclusive ;  $  TAB2 declare int x ;  $  TAB2 read x ;  $  TAB2 push x into que ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if que size equals 0, break ;  $  TAB2 if a[i] is less than or equal to front of que, pop que ;  $  TAB1 print m - que size ;
TAB1 let n, x, mx be integers with mx = 0 and a be array of integers of size 101 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 set a[i] to a[i-1] + x ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive, set mx to max of mx and ((j - i + 1) - (a[j] - a[i - 1]) + a[i - 1] + a[n] - a[j]) ;  $  TAB1 print out mx with newline ;
TAB1 make long long n, k ;  $  TAB1 read n, k ;  $  TAB1 make int rem = 0 ;  $  TAB1 make int i = 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 make int a ;  $  TAB2 read a ;  $  TAB2 increase rem by a ;  $  TAB2 if rem greater than or equal to 8 ;  $  TAB3 subtract 8 from k ;  $  TAB3 subtract 8 from rem ;  $  TAB2 else ;  $  TAB3 subtract rem from k ;  $  TAB3 set rem to 0 ;  $  TAB2 if k less than or equal to 0 then break ;  $  TAB1 if k greater than 0 then set i to -1 ;  $  TAB1 print i ;  $  TAB1 make int pause ;  $  TAB1 read pause ;
TAB0 declare set<int> a, b ;  $  TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare x, y ;  $  TAB2 read x, y ;  $  TAB2 insert x into a ;  $  TAB2 insert y into b ;  $  TAB1 print min of a length and b length ;
TAB0 declare long long function Mul taking in long longs a, n, m ;  $  TAB1 let r = long long with r = 0 ;  $  TAB1 while n is true do the following ;  $  TAB2 if n and hexadecimal 1 set r = (r + a) modulo m ;  $  TAB2 set a = a left shift 1 modulo m ;  $  TAB2 set n = n left shift 1 ;  $  TAB1 return r ;  $  TAB0 declare long long function Pow taking in long longs a, n, m ;  $  TAB1 let r = long long with r = 1 ;  $  TAB1 while n is true do the following ;  $  TAB2 if n and hexadecimal 1 set r = call Mul on r, a, m ;  $  TAB2 set a = call Mul on a, a, m ;  $  TAB2 set n = n left shift 1 ;  $  TAB1 return r ;  $  TAB0 declare long long function binpow taking in long longs a, n ;  $  TAB1 let res = long long with res = 1 ;  $  TAB1 while n is true do the following ;  $  TAB2 ifn and hexadecimal 1 set res = res * a ;  $  TAB2 set n = n left shift 1 ;  $  TAB2 set a = a * a ;  $  TAB1 return res ;  $  TAB0 let sz = vector of long longs ;  $  TAB0 let id = vector of long longs ;  $  TAB0 declare function create taking in long long v ;  $  TAB1 set id[v] = v ;  $  TAB1 set sz[v] = 1 ;  $  TAB0 declare long long function find taking in long long v ;  $  TAB1 let i = long long ;  $  TAB1 for i=v to id[i] inclusive set i = id[i] and set id[i] = id[id[i]] ;  $  TAB1 return i ;  $  TAB0 declare function unite taking in long longs v and w ;  $  TAB1 let i, j = long longs ;  $  TAB1 for i=v to id[i] inclusive set i = id[i] and set id[i] = id[id[i]] ;  $  TAB1 for j=w to id[j] inclusive set j = id[j] and set id[j] = id[id[j]] ;  $  TAB1 if i is j return ;  $  TAB1 if sz[i] is less than sz[j] do the following ;  $  TAB2 set id[i] = j ;  $  TAB2 set sz[j] = sz[j] + sz[i] ;  $  TAB1 else do the following ;  $  TAB2 set id[j] = i ;  $  TAB2 set sz[i] = sz[i] + sz[j] ;  $  TAB0 declare long long function convert taking in long long v ;  $  TAB1 set res = long long with value 0 ;  $  TAB1 set len = long long with value = 0 ;  $  TAB1 while v is true do the following ;  $  TAB2 set res = res inclusive or ( v & hexadecimal 1) left shift len ;  $  TAB2 set v = v / 10 ;  $  TAB2 increment len ;  $  TAB1 return res ;  $  TAB0 declare long long function func taking in string constant reference str ;  $  TAB1 let res = long long with value = 0 ;  $  TAB1 let len = long long with value = 0 ;  $  TAB1 for long long i = size of str - 1 to 0 inclusive decrementing i and incrementing len set res = res inclusive or (str[i] - 0) shift left len ;  $  TAB1 return res ;  $  TAB1 let t = long long ;  $  TAB1 read t ;  $  TAB1 let cnt = vector of long longs of value = 0 and size 3000000 ;  $  TAB1 let c = character ;  $  TAB1 let tmp = long long ;  $  TAB1 let str = string ;  $  TAB1 for long long i=0 to t exclusive do the following ;  $  TAB2 read c ;  $  TAB2 if c is + do the following ;  $  TAB3 read tmp ;  $  TAB3 increment cnt[convert(tmp)] ;  $  TAB2 else if c is - do the following ;  $  TAB3 read tmp ;  $  TAB3 decrement cnt[convert(tmp)] ;  $  TAB2 else do the following ;  $  TAB3 read str ;  $  TAB3 print cnt[func(str)] ;
TAB1 let maxSections, nuts, divis, nut2sec, boxes = integers with boxes = 0 ;  $  TAB1 read maxSections, nuts, divis, nut2sec ;  $  TAB1 while nuts is greater than 0 do the following ;  $  TAB2 increment boxes ;  $  TAB2 set nuts = nuts - (min of maxSections, divis + 1) * nut2sec ;  $  TAB2 set divis = divis - (min of maxSections and divis + 1) - 1 ;  $  TAB1 print boxes ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 if n is 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 make integer array a of size 100005 ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 if n mod 4 is greater than or equal to 2, return puts("-1"), 0 ;  $  TAB1 for int i = 1; i is less than or equal to n / 2; add 2 to i ;  $  TAB2 set a[i] to i + 1 ;  $  TAB2 set a[i + 1] to n - i + 1 ;  $  TAB2 set a[n - i + 1] to n - i ;  $  TAB2 set a[n - i] to i ;  $  TAB1 if n is odd, set a[n / 2 + 1] to n / 2 + 1 ;  $  TAB1 for i = 1 to n inclusive, print a[i] " \n"[i == n] ;
TAB1 n1, n2 are integers with n2 = 3 ;  $  TAB1 read n1 ;  $  TAB1 for i = 0 to n1 exclusive ;  $  TAB2 declare an integer m ;  $  TAB2 read m ;  $  TAB2 if (n2 is 3 and m is 3) or (n2 is 4 and m is 2) or (n2 is 5 and m is 1) ;  $  TAB3 output NO ;  $  TAB2 else ;  $  TAB3 set n2 to 6 - (n2 - m) ;  $  TAB1 output YES ;
TAB0 n, k are integers ;  $  TAB0 a is a string array of size 105 ;  $  TAB1 while input n, k ;  $  TAB2 for i = 0 to n exclusive, input a[i] ;  $  TAB2 let ans be an integer with ans = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 let m be an integer with m = 0 ;  $  TAB3 for j = 0 to the length of a[i] exclusive ;  $  TAB4 if a[i][j] equals the character 4 and a[i][j] equals the character 7, increment m ;  $  TAB3 if m is less than or equal to k, increment ans ;  $  TAB2 output ans ;
TAB1 let n, ans = integers ;  $  TAB1 read n ;  $  TAB1 for integer i=39 to 0 decrementing, do the following ;  $  TAB2 if i * (i+1) * (i+2) is less than or equal to 6*n do the following ;  $  TAB3 set ans = 1 ;  $  TAB3 exit the loop ;  $  TAB1 print ans ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare int n ;  $  TAB1 set n to size of (s + 1) * 26 - size of s ;  $  TAB1 print n ;
TAB0 a,b,k,t=long long integer ;  $  TAB1 read t ;  $  TAB1 for i=1 to t inclusive ;  $  TAB2 read a,b,k ;  $  TAB2 create an long long integer c with c=a-b ;  $  TAB2 set c=c*k/2 ;  $  TAB2 set c=c+(k mod 2)*a ;  $  TAB2 print c ;
TAB1 create int n, x ;  $  TAB1 read n ;  $  TAB1 create set s of type int ;  $  TAB1 create bool ew = 0 ;  $  TAB1 for q = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if x equals 0, set ew to 1 ;  $  TAB2 insert x into s ;  $  TAB1 create int ans = size of s ;  $  TAB1 if eq, decrement ans ;  $  TAB1 print ans ;
TAB0 declare vector<int> sides ;  $  TAB1 declare int a, b, c ;  $  TAB1 read a, b, c ;  $  TAB1 push a into sides ;  $  TAB1 push b into sides ;  $  TAB1 push c into sides ;  $  TAB1 sort sides ;  $  TAB1 assign sides[0] to a ;  $  TAB1 assign sides[1] to b ;  $  TAB1 assign sides[2] to c ;  $  TAB1 print (c - (a + b - 1) > 0 ? c - (a + b - 1) : 0) ;
TAB1 let n, p, ans = integers with p = 0 and ans = 0 ;  $  TAB1 read n ;  $  TAB1 let a, b, c = integer ;  $  TAB1 read a, b, c ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 if p is 0 do the following ;  $  TAB3 if a is less than b do the following ;  $  TAB4 set ans = ans + a ;  $  TAB4 set p = 1 ;  $  TAB3 else do the following ;  $  TAB4 set ans = ans + b ;  $  TAB4 set p = 2 ;  $  TAB2 else if p is 1 do the following ;  $  TAB3 if a is less than c do the following ;  $  TAB4 set ans = ans + a ;  $  TAB4 set p = 0 ;  $  TAB3 else do the following ;  $  TAB4 set ans = ans + c ;  $  TAB4 set p = 2 ;  $  TAB2 else if p is 2 do the following ;  $  TAB3 if b is greater than c do the following ;  $  TAB4 set ans = ans + b ;  $  TAB4 set p = 0 ;  $  TAB3 else do the following ;  $  TAB4 set ans = ans + c ;  $  TAB4 set p = 1 ;  $  TAB1 print ans ;
TAB0 create long long n, c = 1, a ;  $  TAB1 read n, a ;  $  TAB1 while 1 ;  $  TAB2 if (c * n) modulo 10 EQUALS a OR (c * n) modulo 10 EQUALS 0 ;  $  TAB3 print c ;  $  TAB2 increment c ;
TAB1 create long long integer n,sum,cnt with sum=0 and cnt=1 and a=array of long long integer of size 100005 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[1] = 0 then set a[0]='1' ;  $  TAB2 if a[i] = a[i - 1] ;  $  TAB3 set sum=sum+cnt ;  $  TAB3 increment cnt ;  $  TAB2 else do the following ;  $  TAB3 set cnt=1 ;  $  TAB1 set n=n+sum ;  $  TAB1 print n ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare map m with char keys int values ;  $  TAB1 declare int i and define int cnt = 0 ;  $  TAB1 for i = 0 to length of s ;  $  TAB2 if m contains s[i] ;  $  TAB3 increment cnt ;  $  TAB2 else ;  $  TAB3 set m[s[i]] to i ;  $  TAB1 if length of s - cnt is even ;  $  TAB2 print "CHAT WITH HER!" ;  $  TAB1 else ;  $  TAB2 print "IGNORE HIM!" ;
TAB0 maxn = constant integer set to 100 ;  $  TAB0 a = 2d array of integers set to size maxn by maxn ;  $  TAB1 is = integers set to 1 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive read a[i][j] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if a[i][j] is 1, continue ;  $  TAB3 f = integer set to 0 ;  $  TAB3 for k = 0 to n exclusive ;  $  TAB4 for t = 0 to n exclusive ;  $  TAB5 if j is k or i is t, continue ;  $  TAB5 if a[i][k] + a[t][j] is a[i][j], set f to 1 ;  $  TAB3 if f is falsey, set is to 0 ;  $  TAB1 if is is truthy ;  $  TAB2 print "Yes" ;  $  TAB1 else ;  $  TAB2 print "No" ;
TAB1 let n, x be integers ;  $  TAB1 read n, x ;  $  TAB1 arrays = integer array of size n ;  $  TAB1 read n values into array arrays ;  $  TAB1 sum_plus, sum_minus are integers both set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arrays[i] is at least 0 ;  $  TAB3 add arrays[i] to sum_plus ;  $  TAB2 else ;  $  TAB3 if arrays[i] is negative, add arrays[i] to sum_minus ;  $  TAB1 multiply sum_minus by -1 ;  $  TAB1 declare an integer dif ;  $  TAB1 if sum_minus is greater than sum_plus ;  $  TAB2 set dif to sum_minus - sum_plus ;  $  TAB1 else ;  $  TAB2 if sum_minus is less than sum_plus ;  $  TAB3 set dif to sum_plus - sum_minus ;  $  TAB2 else ;  $  TAB3 output 0 ;  $  TAB1 if dif is at most x ;  $  TAB2 output 1 ;  $  TAB1 else ;  $  TAB2 ans = integer = 0 ;  $  TAB2 while dif is positive ;  $  TAB3 subtract x from dif ;  $  TAB3 increment ans ;  $  TAB2 output ans ;
TAB0 in function check returning int and taking string s ;  $  TAB1 define int array count with 256 elements initialized to 0 ;  $  TAB1 for i = 0 to 6 exclusive do increment count[s[i]] ;  $  TAB1 make int j = 0 ;  $  TAB1 make char array of 7 items = {'0', '0', '0', '0', '0', '0'} ;  $  TAB1 add count['R'] to cnt[j incremented] ;  $  TAB1 increase cnt[j incremented] by count['O'] ;  $  TAB1 add count['Y'] to cnt[j incremented] ;  $  TAB1 add count['G'] to cnt[j incremented] ;  $  TAB1 add count['B'] to cnt[j incremented] ;  $  TAB1 increase cnt[j incremented] by count['V'] ;  $  TAB1 sort cnt [0, 6) ;  $  TAB1 make string str(cnt) ;  $  TAB1 if str is "000006" ;  $  TAB2 return 1 ;  $  TAB1 else if str is "000015" ;  $  TAB2 return 2 ;  $  TAB1 else if str is "000024" ;  $  TAB2 return 3 ;  $  TAB1 else if str is "000033" ;  $  TAB2 return 4 ;  $  TAB1 else if str is "000114" ;  $  TAB2 return 5 ;  $  TAB1 else if str is "000123" ;  $  TAB2 return 6 ;  $  TAB1 else if str is "000222" ;  $  TAB2 return 7 ;  $  TAB1 else if str is "001113" ;  $  TAB2 return 8 ;  $  TAB1 else if str is "001122" ;  $  TAB2 return 9 ;  $  TAB1 else if str is "011112" ;  $  TAB2 return 10 ;  $  TAB1 else if str is "111111" ;  $  TAB2 return 11 ;  $  TAB1 else ;  $  TAB1 make string str ;  $  TAB1 read str ;  $  TAB1 make int cnt = 0 ;  $  TAB1 make int array with length of 12 = {-1, 1, 1, 2, 2, 2, 3, 6, 5, 8, 15, 30} ;  $  TAB1 print result[check(str)] ;
TAB1 let s= string ;  $  TAB1 let n = integer ;  $  TAB1 while (read n) is true do the following ;  $  TAB2 read s ;  $  TAB2 let cnt = integer with value = 0 ;  $  TAB2 for integer i=0 to length of s exclusive do the following ;  $  TAB3 if character of s at string position i is < ;  $  TAB4 increment cnt ;  $  TAB3 else ;  $  TAB4 exit the loop ;  $  TAB2 for integer i = length of s -1 to 0 inclusive decrementing do the following ;  $  TAB3 if character of s at string position i is < ;  $  TAB4 increment cnt ;  $  TAB3 else ;  $  TAB4 exit the loop ;  $  TAB2 print cnt ;
TAB0 create map dp with keys of type long long and values of type long long ;  $  TAB1 create long long q ;  $  TAB1 read q ;  $  TAB1 while q decremented ;  $  TAB2 create long long t ;  $  TAB2 read t ;  $  TAB2 if t is 1 ;  $  TAB3 create long long x, y, w ;  $  TAB3 read x, y, w ;  $  TAB3 while x is not y ;  $  TAB4 if y is greater than x then swap x and y ;  $  TAB4 increase dp[x] by w ;  $  TAB4 divide x by itself and 2 ;  $  TAB2 else ;  $  TAB3 create long long x and y ;  $  TAB3 read x and y ;  $  TAB3 create long long ans = 0 ;  $  TAB3 while x is not y ;  $  TAB4 if y greater than x then swap x and y ;  $  TAB4 increase and by dp[x] ;  $  TAB4 divide x by itself and 2 ;  $  TAB3 print ans ;
TAB1 n, l, m, ans are integers with ans = 0 ;  $  TAB1 read n, l, m ;  $  TAB1 a, b, c, d are integers with a and b both set to 0 ;  $  TAB1 if n ;  $  TAB2 read a, b ;  $  TAB2 add a / m to ans ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 read c, d ;  $  TAB2 add (c + (a + b)) / m to ans ;  $  TAB2 assign c to a, assign d to b ;  $  TAB1 add (l - (a + b)) / m to ans ;  $  TAB1 output ans ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 a is an integer array of size n ;  $  TAB1 read n values into array a ;  $  TAB1 call sort with a, a + n ;  $  TAB1 output a[n - 1], " " ;  $  TAB1 for i = 1 to n - 1 exclusive, output a[i], " " ;  $  TAB1 output a[0] ;
TAB1 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 for i = 1 to b inclusive ;  $  TAB2 if a mod 10 == 0 ;  $  TAB3 update a to a/10 ;  $  TAB2 else ;  $  TAB3 decrement a ;  $  TAB1 print a ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 started, ended are integers both set to 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] isn't the character a and ended is false ;  $  TAB3 set started to 1 ;  $  TAB3 decrement s[i] ;  $  TAB2 else if started ;  $  TAB3 set ended to 1 ;  $  TAB1 if started is false, assign the character z to s[(size of s) - 1] ;  $  TAB1 output s ;
TAB1 create long long n, k ;  $  TAB1 read n and k ;  $  TAB1 if n is greater than or equal to k ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 if k modulo n is 0 ;  $  TAB3 print k / n ;  $  TAB2 else ;  $  TAB3 print k / n + 1 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 result = integer set to 0 ;  $  TAB1 c = character ;  $  TAB1 s = string ;  $  TAB1 ans = array of booleans with a length of 26 ;  $  TAB1 unique = a boolean set to false ;  $  TAB1 for i = 0 to 25 exclusive, set ans[i] to true ;  $  TAB1 while n decremented by 1 is > 0 ;  $  TAB2 read c and s ;  $  TAB2 if c is '!' ;  $  TAB3 if !unique ;  $  TAB4 len = integer set to length of s ;  $  TAB4 appear = array of boolians with a length of 26, set to {0} ;  $  TAB4 for i = 0 to len exclusive, set appear[s[i] - 'a'] to true ;  $  TAB4 for i = 0 to 26 exclusive ;  $  TAB5 if appear[i] is falsy, set ans[i] to false ;  $  TAB4 cnt = integer set to 0 ;  $  TAB4 for i = 0 to 26 exclusive ;  $  TAB5 if ans[i], increment cnt by 1 ;  $  TAB4 if cnt is 1, set unique to true ;  $  TAB3 else ;  $  TAB4 increment result by 1 ;  $  TAB2 else if c is '.' ;  $  TAB3 len = integer set to length of s ;  $  TAB3 appear = array of booleans set to {0} ;  $  TAB3 for i = 0 to len exclusive, set appear[s[i] - 'a' to true ;  $  TAB3 for i = 0 to 26 exclusive ;  $  TAB4 if appear[i], set ans[i] to false ;  $  TAB3 cnt = integer set to 0 ;  $  TAB3 for i = 0 to 26 exclusive ;  $  TAB4 if ans[i], increment cnt by 1 ;  $  TAB3 if cnt is 1, set unique to true ;  $  TAB2 else ;  $  TAB3 if unique is falsey ;  $  TAB4 set ans[s[0] - 'a'] to false ;  $  TAB4 cnt = integer set to 0 ;  $  TAB4 for int i = 0 to 26 exclusive ;  $  TAB5 if ans[i], increment cnt by 1 ;  $  TAB4 if cnt is 1, set unique to true ;  $  TAB3 else ;  $  TAB4 increment result by 1 ;  $  TAB1 if unique is true, decrement result by 1 ;  $  TAB1 print result ;
TAB1 n = integer ;  $  TAB1 s = long long int ;  $  TAB1 read n and s ;  $  TAB1 is s%n is equal to 0 ;  $  TAB2 print s/n ;  $  TAB1 else do the following ;  $  TAB2 print s/n+a ;
TAB1 create character array str1 with a length of 101 ;  $  TAB1 create character array str2 with a length of 101 ;  $  TAB1 read str1 ;  $  TAB1 read str2 ;  $  TAB1 create integer n = 0 ;  $  TAB1 while str1[n] not equals '\0', increment n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if str1[i] * 1 greater than 95, set str1[i] to str1[i] - 32 ;  $  TAB2 if str2[i] * 1 greater than 95, set str2[i] to str2[i] - 32 ;  $  TAB1 create integer found = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if str1[i] less than str2[i] ;  $  TAB3 print -1 ;  $  TAB3 assign 1 to found ;  $  TAB3 break ;  $  TAB2 else if str2[i] less than str1[i] ;  $  TAB3 assign 1 to found ;  $  TAB3 print 1 ;  $  TAB3 break ;  $  TAB1 if not found ;  $  TAB2 create integer sum1 = 0 ;  $  TAB2 create integer sum2 = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 add str1[i] * 1 to sum1 ;  $  TAB3 add str2[i] * 1 to sum2 ;  $  TAB2 if sum1 equals sum2, print 0 ;
TAB1 s is an integer array of sizes 10 and 10 with s = {} ;  $  TAB1 for i = 0 to 10 exclusive ;  $  TAB2 s[0][i] is assigned 1 ;  $  TAB2 s[i][0] is assigned 1 ;  $  TAB1 for i = 1 to 10 exclusive ;  $  TAB2 for j = 1 to 10 exclusive, set s[i][j] to s[i - 1][j] + s[i][j - 1] ;  $  TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 display s[n - 1][n - 1] ;
TAB0 define pow2 which takes long long integer a and b and return long long int ;  $  TAB1 if b == 0, return 1 ;  $  TAB1 if b == 1, return a ;  $  TAB1 if b == 2, return a*a ;  $  TAB1 if b & 1, return a * pow2 of a, b-1 ;  $  TAB1 return pow2 of pow2 of a, b/2 and 2 ;  $  TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let a, b be vector of integers ;  $  TAB1 let x, y, i, ans be integers with ans = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x, y ;  $  TAB2 push x to the end of a ;  $  TAB2 push y to the end of b ;  $  TAB1 let cash be integer with cast to INT_MAX ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 update cash to min of cash, b[i] ;  $  TAB2 increment ans by cash * a[i] ;  $  TAB1 print ans with newline ;
TAB1 let n, t, i be integers ;  $  TAB1 read n, t ;  $  TAB1 let path be integer array of size n+5 ;  $  TAB1 for i = 1 to n exclusive, read path[i] ;  $  TAB1 cur = integer = 1 ;  $  TAB1 while cur < t, increment cur by path[cur] ;  $  TAB1 if cur == t ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 k, n, s, p = integers ;  $  TAB1 read k, n , s, p ;  $  TAB1 papersper = integer set to n / s ;  $  TAB1 if n modulo s, increment papersper by 1 ;  $  TAB1 papersreq = integer set to papersper * k ;  $  TAB1 ans = integer set to papersreq / p ;  $  TAB1 if papersreq modulo p, increment ans by 1 ;  $  TAB1 print ans ;
TAB1 let str = string ;  $  TAB1 let n, i, s = integer with s = 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read str ;  $  TAB2 if str is Tetrahedron do the following ;  $  TAB3 set s = s + 4 ;  $  TAB2 else if str is Cube do the following ;  $  TAB3 set s = s + 6 ;  $  TAB2 else if str is Octahedron do the following ;  $  TAB3 set s = s + 8 ;  $  TAB2 else if str is Dodecahedron do the following ;  $  TAB3 set s = s + 10 ;  $  TAB2 else ;  $  TAB3 set s = s + 20 ;  $  TAB1 print s ;
TAB0 let N be a constant integer with N = 200000 + 10 ;  $  TAB0 let y, k, n be integers ;  $  TAB0 let s be a string ;  $  TAB1 input s ;  $  TAB1 let flag be a boolean set to false ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is the character a and flag, break ;  $  TAB2 if s[i] is the character a, continue ;  $  TAB2 subtract 1 from s[i] ;  $  TAB2 assign true to flag ;  $  TAB1 if not flag ;  $  TAB2 let len be an integer with len = length of s ;  $  TAB2 assign the character z to s[len - 1] ;  $  TAB1 output s ;
TAB1 declare int k, n, i, j, a, b, c, d, e, such, unsuch ;  $  TAB1 declare string s ;  $  TAB1 declare map mp with int keys and string values ;  $  TAB1 while reading n is not interrupted ;  $  TAB2 clear mp ;  $  TAB2 while n decremented is not equal to 0 and reading s, such, unsuch, a, b, c, d, e is not interrupted: insert (key) such * 100 - unsuch * 50 + a + b + c + d + e and (value) s into mp ;  $  TAB2 print last value in mp ;
TAB1 let s = set of integers ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let m = integer ;  $  TAB1 read m ;  $  TAB1 while (decrement m) is true do the following ;  $  TAB2 let cur = integer ;  $  TAB2 read cur ;  $  TAB2 insert cur into s ;  $  TAB1 read m ;  $  TAB1 while (decrement m) is true do the following ;  $  TAB2 let cur = integer ;  $  TAB2 read cur ;  $  TAB2 insert cur into s ;  $  TAB1 if size of s is n ;  $  TAB2 print I become the guy. ;  $  TAB1 else ;  $  TAB2 print Oh, my keyboard! ;
TAB1 n,k= long long integers ;  $  TAB1 read n and k ;  $  TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 call sort on s.begin and s.end ;  $  TAB1 let cnt be long long int with cnt= s[0] - 'a' + 1 ;  $  TAB1 decrement k ;  $  TAB1 create character c=s[0] ;  $  TAB1 for i=1 to length of s exclusive and k>0 ;  $  TAB2 if s[i]-c>=2 then ;  $  TAB3 set c=s[i] ;  $  TAB3 set cnt = cnt + (s[i] - 'a' + 1) ;  $  TAB3 subtract 1 from k ;  $  TAB1 if k is equal to 0 ;  $  TAB2 print cnt and new line ;  $  TAB1 else do the following ;  $  TAB2 print -1 and a new line ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let x, y = long longs ;  $  TAB1 let sum1, sumr = integer with values = 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read x, y ;  $  TAB2 if x is greater than 0 ;  $  TAB3 increment sumr ;  $  TAB2 else if x is less than 0 ;  $  TAB3 increment suml ;  $  TAB1 if suml is greater than 1 and sumr is greater than 1 ;  $  TAB2 print No ;  $  TAB1 else ;  $  TAB2 print Yes ;
TAB0 let a = array of integers with size = 302000 ;  $  TAB0 let cnt = array of integers of size = integer 20000000 ;  $  TAB0 let done = array of boolean with size = integer 20000000 ;  $  TAB0 let m = integer constant with value 15000000 ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let g = integer ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 read a[i] ;  $  TAB2 increment cnt[a[i]] ;  $  TAB2 if i is greater than 1 do the following ;  $  TAB3 set g = call __gcd on a[i] and g ;  $  TAB2 else ;  $  TAB3 set g = a[i] ;  $  TAB1 let ans = 0 ;  $  TAB1 for integer i=g+1 to m inclusive do the following ;  $  TAB2 if not done[i] do the following ;  $  TAB3 let sum = integer with value = 0 ;  $  TAB3 for integer j=1 to m inclusive increment step j + i do the following ;  $  TAB4 set sum = sum + cnt[j] ;  $  TAB4 set done[j] = true ;  $  TAB3 set ans = max of ans and sum ;  $  TAB1 if ans is 0 do the following ;  $  TAB2 write -1 to stdout ;  $  TAB1 else ;  $  TAB2 print n - ans ;
TAB1 arr is an integer array of lengths 3 and 3 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 read arr[i][j] ;  $  TAB3 arr[i][j] is assigned arr[i][j] modulo 2 ;  $  TAB1 n is an integer initialized to 5 ;  $  TAB1 ans is an integer array of lengths 5 and 5 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, assign 1 to ans[i][j] ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 for j = 1 to 3 inclusive ;  $  TAB3 if arr[i - 1][j - 1] equals 1 ;  $  TAB4 if ans[i][j] equals 1 ;  $  TAB5 set ans[i][j] to 0 ;  $  TAB4 else ;  $  TAB5 set ans[i][j] to 1 ;  $  TAB4 if ans[i + 1][j] equals 1 ;  $  TAB5 set ans[i + 1][j] to 0 ;  $  TAB4 else ;  $  TAB5 set ans[i + 1][j] to 1 ;  $  TAB4 if ans[i - 1][j] equals 1 ;  $  TAB5 set ans[i - 1][j] to 0 ;  $  TAB4 else ;  $  TAB5 set ans[i - 1][j] to 1 ;  $  TAB4 if ans[i][j + 1] equals 1 ;  $  TAB5 set ans[i][j + 1] to 0 ;  $  TAB4 else ;  $  TAB5 set ans[i][j + 1] to 1 ;  $  TAB4 if ans[i][j - 1] equals 1 ;  $  TAB5 set ans[i][j - 1] to 0 ;  $  TAB4 else ;  $  TAB5 set ans[i][j - 1] to 1 ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 for j = 1 to 3 inclusive, display ans[i][j] ;  $  TAB2 print newline ;
TAB1 declare object ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 print __builtin_popcount(n) ;
TAB0 let a = array of integers of size 10 ;  $  TAB1 let n = integer ;  $  TAB1 let s = string ;  $  TAB1 read n, s ;  $  TAB1 for integer i=0 to n exclusive increment a[s[i] - 0] ;  $  TAB1 let ok = boolean with value true ;  $  TAB1 for integer i=0 to 10 exclusive do the following ;  $  TAB2 if a[i] and i is not equal to 7 and i is not equal to 4 do the following ;  $  TAB3 set ok = false ;  $  TAB3 exit the loop ;  $  TAB1 if ok is true do the following ;  $  TAB2 let sum1, sum2 = integers with values 0 ;  $  TAB2 for integer i=0 to n / 2 exclusive sum1 = sum1 + s[i] - 0 ;  $  TAB2 for integer i=n / 2 to n exclusive sum2 = sum2 + s[i] - 0 ;  $  TAB2 if sum1 is sum2 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 declare long long x, y, m ;  $  TAB0 in function solve returning long long ;  $  TAB1 if x is greater than y: swap x and y ;  $  TAB1 if y is greater than or equal to m: return 0 ;  $  TAB1 if y is less than or equal to 0: return -1 ;  $  TAB1 define long long ans = 0 ;  $  TAB1 if x is less than 0 ;  $  TAB2 set ans to -x / y ;  $  TAB2 increase x by ans * y ;  $  TAB1 while y is less than m ;  $  TAB2 set x to x + y ;  $  TAB2 if x is greater than y: swap x and y ;  $  TAB2 increment ans ;  $  TAB1 return ans ;  $  TAB1 read x, y, m ;  $  TAB1 define long long ans = solve() ;  $  TAB1 print ans ;
TAB1 n, a, and b are integers ;  $  TAB1 read n, b, and a ;  $  TAB1 arr is an integer array of length n ;  $  TAB1 for i = 0 to (n) exclusive, read arr[i] ;  $  TAB1 call sort with arr, arr + n ;  $  TAB1 display arr[a] - arr[a - 1] ;
TAB1 let w, h = integers ;  $  TAB1 read w, h ;  $  TAB1 let Stone = two arrays of integers, size 2 ;  $  TAB1 read Stone[0][0], Stone[0][1] ;  $  TAB1 read Stone[1][0], Stone[1][1] ;  $  TAB1 while h is not equal to 0 do the following ;  $  TAB2 set w = w + h ;  $  TAB2 if h is Stone[0][1] set w= w-Stone[0][0] ;  $  TAB2 if h is Stone[1][1] set w= w-Stone[1][0] ;  $  TAB2 if w is less than 0 set w = 0 ;  $  TAB2 decrement h ;  $  TAB1 print w ;
TAB1 n, k, a, b, s are integers with s = 0 ;  $  TAB1 read n, k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, b ;  $  TAB2 add b - a + 1 to s ;  $  TAB1 ans is ani nteger set to k - (s mod k) ;  $  TAB1 if ans is k, set ans to 0 ;  $  TAB1 display ans ;
TAB0 n,m = integers ;  $  TAB0 a= array of integers of size 101 ;  $  TAB0 adj = 2d array of boolean of size 101 by 101 ;  $  TAB1 read n and m ;  $  TAB1 read n values into array i from 1 to n inclusive ;  $  TAB1 set all values of adj to false ;  $  TAB1 for i=0 to m exclusive ;  $  TAB2 a,b = integers ;  $  TAB2 read a and b ;  $  TAB2 set adj[a][b] = adj[b][a] = true ;  $  TAB1 create integer my_min = -1 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 for j=i+1 to n inclusive ;  $  TAB3 for k=j+1 to n inclusive ;  $  TAB4 if adj[i][j] and adj[j][k] and adjj[k][i] are all true ;  $  TAB5 if my_min is -1 or a[i] + a[k] is less than my_min then set my_min = a[i] + a[j] + a[k] ;  $  TAB1 print my_min and new line ;  $  TAB1 print flush ;
TAB0 mp = 2 dimensional array of integers size 1010 by 1010 ;  $  TAB1 m, n, k = integers ;  $  TAB1 read m, n, k ;  $  TAB1 set sizeof(mp) bytes starting at mp to 0 ;  $  TAB1 set integer flog to 0 ;  $  TAB1 set integer ans to 0 ;  $  TAB1 for i=1 to k inclusive do the following ;  $  TAB2 x, y = integers ;  $  TAB2 read x, y ;  $  TAB2 mp[x][y] = 1 ;  $  TAB2 if flog is 0 do the following ;  $  TAB3 if (mp[x-1][y] and mp[x-1][y-1] and mp[x][y-1]) flog = 1 ;  $  TAB3 if (mp[x+1][y] and mp[x+1][y+1] and mp[x][y+1]) flog = 1 ;  $  TAB3 if (mp[x-1][y] and mp[x-1][y+1] and mp[x][y+1]) flog = 1 ;  $  TAB3 if (mp[x+1][y] and mp[x+1][y-1] and mp[x][y-1]) flog = 1 ;  $  TAB3 if flog is true ;  $  TAB4 print i ;  $  TAB1 print 0 ;
TAB1 let n, counter1, counter2, req = integers with counter1 =0 and counter2 = 0 ;  $  TAB1 let a = array of integers with size = 101 ;  $  TAB1 read n ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is even ;  $  TAB3 set counter1 = counter1 + 1 ;  $  TAB2 else ;  $  TAB3 set counter2 = counter2 + 1 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 if counter1 is greater than counter2 do the following ;  $  TAB3 if a[i] is odd set req = i ;  $  TAB2 else do the following ;  $  TAB3 if a[i] is even set req = i ;  $  TAB1 print req ;
TAB1 create int k, r ;  $  TAB1 read k, r ;  $  TAB1 create int i = 1 ;  $  TAB1 while true ;  $  TAB2 if (i * k) % 10 is equal to 0 OR ((i * k) - r) % 10 is equal to 0 ;  $  TAB3 print i ;  $  TAB3 break ;  $  TAB2 add 1 to i ;
TAB1 s = string ;  $  TAB1 input s ;  $  TAB1 count, c are integers both set to 0 ;  $  TAB1 h = string = "hello" ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] equals h[c] ;  $  TAB3 increment c ;  $  TAB3 increment count ;  $  TAB1 if count equals 5 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 MAXN = a constant set to 100005 ;  $  TAB0 MOD = and constant set to 998244353 ;  $  TAB0 a = an array of integers with a length of MAXN ;  $  TAB0 dp = a 2 dimentional array of integers with a length of 201 ;  $  TAB0 newdp = a 2 dimentional array of integers with a length of 201 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read index i of a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i = 0 ;  $  TAB3 if index i of a = -1 ;  $  TAB4 for x = 1 to 200 inclusive, set newdp[x][0] = 1 ;  $  TAB3 else ;  $  TAB4 newdp[a[i]][0] = 1 ;  $  TAB2 else ;  $  TAB3 if index i of a = -1 ;  $  TAB4 flag0 = integer set to 0 ;  $  TAB4 flag1 = integer set to 0 ;  $  TAB4 for y = 1 to 200 inclusive ;  $  TAB5 add dp[y][1] to flag1 ;  $  TAB5 modulo flag1 by MOD ;  $  TAB4 for x = 1 to 200 inclusive ;  $  TAB5 subtract dp[x - 1][1] from flag1 ;  $  TAB5 add MOD to flag1 ;  $  TAB5 modulo flag1 by MOD ;  $  TAB5 subtract dp[x - 1][0] from flag1 ;  $  TAB5 add MOD to flag1 ;  $  TAB5 modulo flag1 by MOD ;  $  TAB5 add dp[x - 1][1] to flag0 ;  $  TAB5 modulo flag0 by MOD ;  $  TAB5 add dp[x - 1][0] to flag0 ;  $  TAB5 modulo flag0 by MOD ;  $  TAB5 add dp[x][0] to flag1 ;  $  TAB5 modulo flag1 by MOD ;  $  TAB5 set newdp[x][0] to flag0 ;  $  TAB5 set newdp[x][1] to flag1 ;  $  TAB3 else ;  $  TAB4 x = integer set to index i of a ;  $  TAB4 for y = 1 to 200 inclusive ;  $  TAB5 flag = integer set to 1 if x <= y or 0 ;  $  TAB5 add dp[y][1] to newdp[x][flag] ;  $  TAB5 modulo newdp[x][flag] by MOD ;  $  TAB5 if y <= x ;  $  TAB6 add dp[y][0] to newdp[x][flag] ;  $  TAB6 modulo newdp[x][flag] by MOD ;  $  TAB2 run memcpy with dp, newdp and 201 * 2 * 4 as arguments ;  $  TAB2 run memset with newdp, 0, and 201 * 2 * 4 as arguments ;  $  TAB1 ans = integer set to 0 ;  $  TAB1 for x = 1 to 200 inclusive ;  $  TAB2 add dp[x][1] to ans ;  $  TAB2 modulo ans by MOD ;  $  TAB1 read ans ;
TAB0 let seed = integer constant with value 131 ;  $  TAB0 let maxn = integer constant with value 100005 ;  $  TAB0 let mod = integer constant with value 1000000007 ;  $  TAB0 let n = integer ;  $  TAB0 let a = string ;  $  TAB0 let s = array of strings with size 102 ;  $  TAB0 let now = string ;  $  TAB0 let vis = array of integers of size maxn ;  $  TAB1 read n, a ;  $  TAB1 read n values into string s ;  $  TAB1 set now = a ;  $  TAB1 let cnt = integer with value 0 ;  $  TAB1 while 1 is true do the following ;  $  TAB2 let flag = integer with value 0 ;  $  TAB2 if cnt is n exit the loop ;  $  TAB2 for integer i = 1 to n inclusive do the following ;  $  TAB3 if not vis[i] and substring s[0] to s[2] of s is now dothe following ;  $  TAB4 set vis[i] = 1 ;  $  TAB4 increment cnt ;  $  TAB4 set flag = 1 ;  $  TAB4 set now = substring of s from s[5] to end of s ;  $  TAB2 if not flag exit the loop ;  $  TAB1 if now is a ;  $  TAB2 print home ;  $  TAB1 else ;  $  TAB2 print contest ;
TAB1 declare integers n, m ;  $  TAB1 read n ;  $  TAB1 set m to n / 2 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 for j = 0 to m - i exclusive, print "*" ;  $  TAB2 create integer k = i * 2 + 1 ;  $  TAB2 for j = 0 to k exclusive, print "D" ;  $  TAB2 for j = 0 to m - i exclusive, print "*" ;  $  TAB2 print newline ;  $  TAB1 for j = 0 to n exclusive, print "D" ;  $  TAB1 print newline ;  $  TAB1 for i = m - 1 to 0 inclusive, decrement i ;  $  TAB2 for j = 0 to m - i exclusive, print "*" ;  $  TAB2 create integer k = i * 2 + 1 ;  $  TAB2 for j = 0 to k exclusive, print "D" ;  $  TAB2 for j = 0 to m - i exclusive, print "*" ;  $  TAB2 print newline ;
TAB1 k,n=integers ;  $  TAB1 read k,n ;  $  TAB1 for i=1 to infinite ;  $  TAB2 if (k * i) % 10 = n or (k * i) % 10 = 0 ;  $  TAB3 print i ;  $  TAB3 break ;
TAB1 let n be int ;  $  TAB1 read n ;  $  TAB1 if n%5 is not 0 then set n=n+5-n%5 ;  $  TAB1 print ceil of n/5 ;
TAB1 TESTS = integer = 1 ;  $  TAB1 while decrement tests ;  $  TAB2 n = long long ;  $  TAB2 input n ;  $  TAB2 a = long long array of size n ;  $  TAB2 read n values into array a ;  $  TAB2 call sort with a, a + n ;  $  TAB2 ans = long long = 0 ;  $  TAB2 for i = 0 to n exclusive, add (i + 2) * a[i] to ans ;  $  TAB2 subtract a[n - 1] from ans ;  $  TAB2 display ans ;
TAB1 declare int a, b, c, d, t, i ;  $  TAB1 read a, b, and c ;  $  TAB1 set d to a * c ;  $  TAB1 for i = 1, repeat infinitely, increment i ;  $  TAB2 set t to i + c ;  $  TAB2 set t to t * b ;  $  TAB2 if t is greater than or equal to d, break ;  $  TAB1 print i ;
TAB0 create string s, t ;  $  TAB0 create int n, m ;  $  TAB0 create long long int mod ;  $  TAB0 in function add, returning long long int and accepting long long ints x and y ;  $  TAB1 return (x % mod + y % mod) % mod ;  $  TAB0 create long long int array dp of size 5001x5001 ;  $  TAB0 in function rec returning long long int and accepting ints i and j ;  $  TAB1 if dp[i][j] is not equal to -1, return dp[i][j] ;  $  TAB1 if j equals m or i equals n, return 0 ;  $  TAB1 create long long int sm = 0 ;  $  TAB1 increase sm by rec(i, j, + 1) ;  $  TAB1 if s[i] equals t[j], set sm to (sm + rec(i + 1, j + 1) + 1) % mod ;  $  TAB1 return dp[i][j] = sm ;  $  TAB1 set mod to 1e9 + 7 ;  $  TAB1 read s and t ;  $  TAB1 set n to size of s ;  $  TAB1 set m to size of t ;  $  TAB1 create long long int ans = 0 ;  $  TAB1 set elements of dp to -1 ;  $  TAB1 for i = 0 to n exclusive, set ans to (ans + rec(i, 0)) % mod ;  $  TAB1 print ans ;
TAB1 create int row, col ;  $  TAB1 read row and col ;  $  TAB1 create multidimensional char array arr with size row by col ;  $  TAB1 for i = 0 to row exclusive ;  $  TAB2 for j = 0 to col exclusive, read arr[i][j] ;  $  TAB1 for i = 0 to row exclusive ;  $  TAB2 for j = 0 to col exclusive ;  $  TAB3 if arr[i][j] is equal to '.' ;  $  TAB4 if (i + j) bitwise AND 1 ;  $  TAB5 assign 'W' to arr[i][j] ;  $  TAB4 else ;  $  TAB5 assign 'B' to arr[i][j] ;  $  TAB3 print arr[i][j] ;  $  TAB2 print newline ;
TAB1 create integers numround, misha, chris, mcount=0 and ccount=0 ;  $  TAB1 read numround ;  $  TAB1 arr = array of interger of size 100 ;  $  TAB1 for i=0 to numround exclusive ;  $  TAB2 read misha and chris ;  $  TAB2 if misha > chris ;  $  TAB3 then add 1 to mcount ;  $  TAB2 else if chris > misha ;  $  TAB3 add 1 to ccount ;  $  TAB1 if mcount > ccount ;  $  TAB2 print Mishka ;  $  TAB1 else if ccount > mcount ;  $  TAB2 print Chris and new line ;  $  TAB1 else if mcount is equal to ccount ;  $  TAB2 then print Friendship is magic!^^ and new line ;
TAB1 let a,b,c,t,l,i,k be integers with k = 0 ;  $  TAB1 let sum and d be double with sum = d = 0 ;  $  TAB1 read a and b ;  $  TAB1 for i = 1 to a inclusive ;  $  TAB2 read c ;  $  TAB2 is sum is less than or equal to ceil of c/b ;  $  TAB3 set sum to ceil of c/b ;  $  TAB3 set k to i ;  $  TAB1 print k with newline ;
TAB0 let n, m, k, l be integers ;  $  TAB1 read n, m, k, l ;  $  TAB1 if m > n ;  $  TAB2 print -1 ;  $  TAB1 if k+l <= m ;  $  TAB2 print 1 ;  $  TAB1 let a be long lon ;  $  TAB1 if (k+l) mod m == 0 ;  $  TAB2 set a to (k+l) / m ;  $  TAB1 else ;  $  TAB2 set a to (k+l) / m + 1 ;  $  TAB1 if a * m > n ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print a ;
TAB1 declare int n ;  $  TAB1 declare string s ;  $  TAB1 read n ;  $  TAB1 while n decremented is not 0 ;  $  TAB2 read s ;  $  TAB2 if s length is greater than 10 ;  $  TAB3 print first, penultimate, and last elements of s ;  $  TAB2 else ;  $  TAB3 print s ;
TAB1 distance = long long ;  $  TAB1 read distance ;  $  TAB1 blocked = long long ;  $  TAB1 set blocked to 0 ;  $  TAB1 x, y are long longs ;  $  TAB1 set x to distance ;  $  TAB1 set y to 0 ;  $  TAB1 if distance equals 0 ;  $  TAB2 set blocked to 1 ;  $  TAB1 else ;  $  TAB2 while x is positive ;  $  TAB3 if x is at most y ;  $  TAB4 decrement x ;  $  TAB4 increment y ;  $  TAB4 if x * x + y * y is greater than distance * distance, decrement y ;  $  TAB4 increment blocked ;  $  TAB3 while x is greater than y ;  $  TAB4 increment y ;  $  TAB4 if x * x + y * y is greater than distance * distance, decrement x ;  $  TAB4 increment blocked ;  $  TAB1 if distance is 0 ;  $  TAB2 output blocked ;  $  TAB1 else ;  $  TAB2 output 4 * blocked ;
TAB1 let n, m, a, b be long longs ;  $  TAB1 read n, m, a, and b ;  $  TAB1 if n modulo m is equal to 0 ;  $  TAB2 output 0 as a string ;  $  TAB1 else ;  $  TAB2 let x be a long long with x = n divided by m ;  $  TAB2 let y be a long long with y = n modulo m ;  $  TAB2 let sum be a long long with sum = call function min with arguments y * b, (m - y) * a ;  $  TAB2 output sum ;
TAB0 let v = vector of integers ;  $  TAB1 let n, x1, x2, y1, y2 = integers ;  $  TAB1 read n ;  $  TAB1 let sum = integer with value 0 ;  $  TAB1 for integer j=0 to n exclusive do the followig ;  $  TAB2 read x1, y1, x2, y2 ;  $  TAB2 let a = integer with value (x2 - x1) +1 ;  $  TAB2 let b = integer with value (y2 - y1) + 1 ;  $  TAB2 let ans = integer with value a * b ;  $  TAB2 append ans to v ;  $  TAB1 for integer j=0 to size of v exclusive set sum = sum + v[j] ;  $  TAB1 print sum ;
TAB1 create strings a1 and a2 ;  $  TAB1 create string a ;  $  TAB1 read a ;  $  TAB1 create int i = 0 ;  $  TAB1 for i = 0 to size of a exclusive ;  $  TAB2 if a[i] not equals '0', break ;  $  TAB1 for i < size of a exclusive, increase a1 by a[i] ;  $  TAB1 read a ;  $  TAB1 for i = 0 to size of a exclusive ;  $  TAB2 if a[i] not equals '0', break ;  $  TAB1 for i < size of a exclusive, increase a2 by a[i] ;  $  TAB1 if size of a1 greater than size of a2 ;  $  TAB2 print '>' ;  $  TAB1 else if size of a1 less than size of a2 ;  $  TAB2 print '<' ;  $  TAB1 else if size of a1 equals size of a2 ;  $  TAB2 if a1 greater than a2 ;  $  TAB3 print '>' ;  $  TAB2 else if a1 less than a2 ;  $  TAB3 print '<' ;  $  TAB2 else if a1 equals a2 ;  $  TAB3 print '=' ;
TAB0 let a, b, minn, maxx be integers ;  $  TAB1 read a, b ;  $  TAB1 minn = min of a, b ;  $  TAB1 maxx = max of a, b ;  $  TAB1 print minn, " ", (maxx - minn) / 2 ;
TAB1 make integer n ;  $  TAB1 make integer cnt ;  $  TAB1 make integer array a, size of 110 ;  $  TAB1 while read n ;  $  TAB2 cnt = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a[i] ;  $  TAB3 if a[i] is equal to 1 then add 1 to cnt ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a[i] is equal to 1 and a[i + 1] is equal to 0 and a[i + 2] is equal to 1 then increment cnt ;  $  TAB2 print cnt ;
TAB0 create output stream object fo for file test ;  $  TAB0 create input stream object fi for file test ;  $  TAB0 create two dimensional array a of size 4 by 4 and rs of size 5 by 5 ;  $  TAB1 for i=1 to 3 inclusive ;  $  TAB2 for j=1 to 3 inclusive ;  $  TAB3 read a[i][j] ;  $  TAB3 set r[i][j] to 1 ;  $  TAB1 for i=1 to 3 inclusive ;  $  TAB2 for j=1 to 3 inclusive ;  $  TAB3 if a[i][j] mod 2 is true ;  $  TAB4 if rs[i-1][j] is not 0 ;  $  TAB5 set rs[i-1][j] to 0 ;  $  TAB4 else do the following ;  $  TAB5 set rs[i-1][j] to 1 ;  $  TAB4 if rs[i + 1][j] is not 0 ;  $  TAB5 then set rs[i + 1][j] to 0 ;  $  TAB4 else ;  $  TAB5 set rs[i + 1][j] to 1 ;  $  TAB4 if rs[i][j - 1] is not 0 ;  $  TAB5 then set rs[i][j - 1] to 0 ;  $  TAB4 else do the following ;  $  TAB5 set rs[i][j - 1] to 1 ;  $  TAB4 if rs[i][j + 1] is not 0 ;  $  TAB5 then set rs[i][j + 1] to 0 ;  $  TAB4 else do the following ;  $  TAB5 set rs[i][j + 1] to 1 ;  $  TAB4 if rs[i][j] is not 0 ;  $  TAB5 then set rs[i][j] to 0 ;  $  TAB4 else ;  $  TAB5 set rs[i][j] to 1 ;  $  TAB1 for i=0 to 3 inclusive print rs[i][1] and rs[i][2] and rs[i][3] ;
TAB1 declare int n, i ;  $  TAB1 read n ;  $  TAB1 declare string array s of size 100 ;  $  TAB1 for i = 0 to n exclusive: read s[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if size of s[i] is greater than 10 ;  $  TAB3 print s[i][0], s[i].size() - 2, s[i][s[i].size() - 1] ;  $  TAB2 else ;  $  TAB3 print s[i] ;
TAB0 k, n, c, b, l, r, m are long long integers with k, n, c, and b set to 0 ;  $  TAB0 s = string ;  $  TAB0 in function turimi with parameters long long integers n, k and return boolean ;  $  TAB1 c, r are long long integers both set to 0 ;  $  TAB1 while n ;  $  TAB2 if n is even, increment c ;  $  TAB2 divide n by 2 ;  $  TAB1 return c is less than or equal to k ;  $  TAB1 read n, m ;  $  TAB1 a = long long integer array of size n with a = {}. b = long long integer array of size m with b = {} ;  $  TAB1 read n values into array a ;  $  TAB1 read m values into array b ;  $  TAB1 set r to 0 ;  $  TAB1 for i = 0 as long as i is less than n and r is less than m with increment i ;  $  TAB2 if a[i] is at most b[r], increment r ;  $  TAB1 output r ;
TAB1 let k, a, b, v be integers ;  $  TAB1 input k, a, b, v ;  $  TAB1 box = integer = 0 ;  $  TAB1 while a is positive ;  $  TAB2 increment box ;  $  TAB2 if b is positive ;  $  TAB3 if b is at least k - 1 ;  $  TAB4 subtract k * v from a ;  $  TAB4 subtract k - 1 from b ;  $  TAB3 else ;  $  TAB4 subtract (b + 1) * v from a ;  $  TAB4 assign 0 to b ;  $  TAB2 else ;  $  TAB3 subtract v from a ;  $  TAB1 print box ;
TAB0 let PI be const double with PI = acos of -1.0 ;  $  TAB0 let E be const double with E = exp of 1.0 ;  $  TAB0 let eps be const double with eps = 1e-30 ;  $  TAB0 let INF be const integer with INF = 0x3f3f3f3f ;  $  TAB0 let maxn be const integer with maxn = 1e3 + 10 ;  $  TAB0 let MOD be const integer with MOD = 1e9 + 7 ;  $  TAB1 let n be integer ;  $  TAB1 while input available, read n, print n & 1 ;
TAB1 n, s are integers ;  $  TAB1 input n, s ;  $  TAB1 a, b are integer arrays both of size n ;  $  TAB1 read n values into array a ;  $  TAB1 read n values into array b ;  $  TAB1 if a[0] equals 0 ;  $  TAB2 display NO ;  $  TAB1 else if a[s - 1] equals 1 ;  $  TAB2 display YES ;  $  TAB1 else if b[s - 1] equals 1 ;  $  TAB2 for i = 0 to (n - s - 1) inclusive ;  $  TAB3 if b[s + i] equals 1 and a[s + i] equals 1 ;  $  TAB4 display YES ;  $  TAB2 display NO ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB1 declare int k, n, s, p ;  $  TAB1 read k, n, s, p ;  $  TAB1 declare int res1, res2 ;  $  TAB1 if n modulo s ;  $  TAB2 set res1 to n / s + 1 ;  $  TAB1 else ;  $  TAB2 set res1 to n / s ;  $  TAB1 if (res1 * k) modulo p ;  $  TAB2 set res2 to (res1 * k) / p + 1 ;  $  TAB1 else ;  $  TAB2 set res2 to (res1 * k) / p ;  $  TAB1 print res2 ;
TAB0 t = integer ;  $  TAB1 input t ;  $  TAB1 iterate t times ;  $  TAB2 end, v, l, r are integers ;  $  TAB2 input end, v, l, r ;  $  TAB2 ans is an integer set to end / v ;  $  TAB2 ans2 is an integer set to r / v - l / v ;  $  TAB2 if l is divisible by v, add 1 to ans2 ;  $  TAB2 display ans - ans2 ;
TAB0 let s = string ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read s ;  $  TAB2 let largo = integer with value = size of s ;  $  TAB2 if largo is greater than 10 ;  $  TAB3 print s[0] and largo - 2 and s[largo - 1] ;  $  TAB2 else ;  $  TAB3 print s ;  $  TAB2 print a new line ;
TAB0 let t, i, j, tam, dif be integers ;  $  TAB0 let yes be a boolean ;  $  TAB0 let s be a string ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 read tam, s ;  $  TAB2 set yes to true ;  $  TAB2 for i = 0, j = tam - 1 as long as yes, i is less than tam / 2 with increment i, decrement j ;  $  TAB3 set dif to absolute value (s[i] - s[j]) ;  $  TAB3 if (dif equals 2 or s[i] equals s[j]) is false, set yes to false ;  $  TAB2 output YES if yes is true, otherwise output NO ;
TAB0 let a be an integer array of length 1000 + 2 ;  $  TAB0 let b be an integer array of length 1000 + 2 ;  $  TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 read n values into array b ;  $  TAB1 sum is an integer set to 0 ;  $  TAB1 x and y are integers ;  $  TAB1 w and e are integers ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 assign 0 to x ;  $  TAB3 assign 0 to y ;  $  TAB3 for t = i to j inclusive ;  $  TAB4 set x to x or a[t] ;  $  TAB4 set y to y or b[t] ;  $  TAB3 if x + y is greater than sum ;  $  TAB4 assign x + y to sum ;  $  TAB4 assign x to w ;  $  TAB4 assign y to e ;  $  TAB1 display sum ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 if n bitwise and 1 ;  $  TAB2 display 1 ;  $  TAB1 else ;  $  TAB2 display 2 ;
TAB0 create int array a of size 100 + 10 ;  $  TAB1 create int n, m ;  $  TAB1 read n and m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 create int t1, t2 ;  $  TAB2 read t1 and t2 ;  $  TAB2 set a[i] to t1 * 60 + t2 ;  $  TAB1 create int flag = 1 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i equals 1 ;  $  TAB3 if a[1] greater than or equal to m + 1 ;  $  TAB4 set flag to 0 ;  $  TAB4 print 0 " " 0 ;  $  TAB4 break ;  $  TAB2 else ;  $  TAB3 if a[i] - a[i - 1] greater than or equal to 2 * m + 2 ;  $  TAB4 create int t1 = (a[i - 1] + m + 1) / 60 ;  $  TAB4 create int t2 = (a[i - 1] + m + 1) mod 60 ;  $  TAB4 print t1 " " t2 ;  $  TAB4 set flag to 0 ;  $  TAB4 break ;  $  TAB1 if flag equals 1, print (a[n] + m + 1) / 60, " ", (a[n] + m + 1) % 60 ;
TAB1 let n, k be integers ;  $  TAB1 let total be an integer with total = 4 * 60 ;  $  TAB1 input n and k ;  $  TAB1 let arr be an integer array of size n ;  $  TAB1 for i = 0 to n exclusive, assign 5 * (i + 1) to arr[i] ;  $  TAB1 for i = 1 to n exclusive, add arr[i - 1] to arr[i] ;  $  TAB1 let start and end be integers with start = 0 and end = n - 1 ;  $  TAB1 ans is an integer initialized to -1 ;  $  TAB1 while start is less than or equal to end ;  $  TAB2 mid = integer = (start + end) / 2 ;  $  TAB2 if arr[mid] + k is at most total ;  $  TAB3 assign mid + 1 to start ;  $  TAB3 assign mid to ans ;  $  TAB2 else ;  $  TAB3 assign mid - 1 to end ;  $  TAB1 display ans + 1 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a= array of strings of size n ;  $  TAB1 read n values into the array a ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if size of a[i] is greater than 10 ;  $  TAB3 print a[i][0] and size of a[i] -2 and a[i][a[i].size() - 1] ;  $  TAB2 else do the following ;  $  TAB3 print a[i] and a new line ;
TAB1 n, x, y are integers ;  $  TAB1 read n, x, and y ;  $  TAB1 clones is an integer initialized to (n * y + 99) / 100 - x ;  $  TAB1 if clones is negative, assign 0 to clones ;  $  TAB1 display clones ;
TAB0 define fastIo ;  $  TAB1 call fastIo ;  $  TAB1 let n, m be integers ;  $  TAB1 read n, m ;  $  TAB1 let ans be vector of strings of size n+2 ;  $  TAB1 read n values into array ans ;  $  TAB1 let ch be char with ch = 'W' ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if ch == 'W' ;  $  TAB3 set ch to 'B' ;  $  TAB2 else ;  $  TAB3 set ch to 'W' ;  $  TAB2 let temp be char with temp = ch ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if ans[i][j] == '.', set ans[i][j] to temp ;  $  TAB3 if temp == 'W' ;  $  TAB4 set temp to 'B' ;  $  TAB3 else ;  $  TAB4 set temp to 'W' ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive, print ans[i][j] ;  $  TAB2 print newline ;
TAB1 create integers n,k,x,sum and A= array of integer of size 101 ;  $  TAB1 read n,k,x ;  $  TAB1 read n value into the array A ;  $  TAB1 for i=0 to n-k exclusive set sum=sum+A[i] ;  $  TAB1 print sum+k*x ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let ss be set of integers ;  $  TAB1 f = boolean = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let x be integer ;  $  TAB2 read x ;  $  TAB2 if x == 0, set f to 1 ;  $  TAB2 call insert on ss with x ;  $  TAB1 print size of ss - (1 if f is true else 0) ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let math, pr, pe be vector of integers ;  $  TAB1 let t be integer ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t ;  $  TAB2 if t is equal to 1, push i to the back of pr ;  $  TAB2 if t is equal to 2, push i to the back of math ;  $  TAB2 if t is equal to 3, push i to the back of pe ;  $  TAB1 let ans be integer with ans = min of size of pr and min of size of math and size of pe ;  $  TAB1 print out ans ;  $  TAB1 for i = 0 to ans exclusive, print out pr[i] + 1, " ", math[i] + 1, " ", pe[i] + 1 ;
TAB1 declare int t ;  $  TAB1 read t ;  $  TAB1 while t decremented ;  $  TAB2 declare int x, s, n ;  $  TAB2 read x ;  $  TAB2 if 360 mod (180 - x) equals 0 ;  $  TAB3 print "YES\n" ;  $  TAB2 else ;  $  TAB3 print "NO\n" ;
TAB0 maxn = constant integer = 1e5 + 5 ;  $  TAB0 num = integer array of size maxn with num = 0 ;  $  TAB0 n, ans are integers with ans = 1000000000 ;  $  TAB1 read n ;  $  TAB1 read n values into array num ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 cnt = integer = 0 ;  $  TAB2 for j = 1 ti n inclusive, add 2 * num[j] * (absolute value (i - j) + absolute value (j - 1) + absolute value (1 - i)) to cnt ;  $  TAB2 set ans to call min with cnt, ans ;  $  TAB1 display ans ;
TAB0 define add which takes integer a as argument and returns integer ;  $  TAB1 let sum, x be integers with sum = 0 and x = a ;  $  TAB1 while a is greater than or equal to 10 ;  $  TAB2 update sum to sum + a%10 ;  $  TAB2 set a to a/10 ;  $  TAB1 add a to sum ;  $  TAB1 add x to sum ;  $  TAB1 return sum ;  $  TAB1 let n, x, c, i be integers with c = 1 and a be array of integers of size 10000 ;  $  TAB1 read n ;  $  TAB1 k = integer with k = 0 ;  $  TAB1 if n is greater than or equal to 100000 ;  $  TAB2 set i to n - 10000 ;  $  TAB1 else ;  $  TAB2 set i to 0 ;  $  TAB1 till i is less than or equal to n inclusive ;  $  TAB2 let o be integer with o = add of i ;  $  TAB2 if n is equal to o, set a[k] to i and increment k ;  $  TAB1 print out k ;  $  TAB1 for i = 0 to k exclusive, print out a[i] ;
TAB1 create long long n, i, k, a, j, mx = -1 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read k and a ;  $  TAB2 for j = 1 to 15 exclusive ;  $  TAB3 if pow of 4 and j is greater than or equal to a, break ;  $  TAB2 set mx to max of mx and j + k ;  $  TAB1 print mx ;
TAB1 let n and e be integers with e = 0 and a be array of integers of size 32 by 2 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i][1], a[i][2] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i+1 to n exclusive ;  $  TAB3 if a[i][1] is equal to a[j][2], increment e++ ;  $  TAB3 if a[i][2] is equal to a[j][1] increment e++ ;  $  TAB1 print out e ;
TAB0 in function print, parameters int a[] and int n ;  $  TAB1 for i = 1 to n exclusive: print a[i], " " ;  $  TAB1 print newline ;  $  TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 declare int arrays eat and cost, both of size n + 1 ;  $  TAB1 for i = 1 to n inclusive, read eat[i] and cost[i] ;  $  TAB1 declare int array cost_min of size n ;  $  TAB1 set cost_min[1] to cost[1] ;  $  TAB1 define int min = cost[1] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if cost[i] is less than min ;  $  TAB3 set cost_min[i] to cost[i] ;  $  TAB3 set min to cost[i] ;  $  TAB2 else ;  $  TAB3 set cost_min[i] to min ;  $  TAB1 define int money = 0 ;  $  TAB1 for i = 1 to n inclusive, increase money by eat[i] * cost_min[i] ;  $  TAB1 print money ;
TAB1 n, k are long longs ;  $  TAB1 read n, k ;  $  TAB1 ans = long long = 0 ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 temp = long long = (k - (2 * i)) ;  $  TAB2 mul = long long = (n - i) * 3 ;  $  TAB2 if mul is at most temp ;  $  TAB3 output i ;
TAB0 create an constant long long integer mod with mod=1e9+7 ;  $  TAB1 create integers n ,ans with ans =1 ;  $  TAB1 a= array of integrer of size 100050 ;  $  TAB1 dp= array of integer of size 100050 ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 set dp[0] =1 ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 set dp[i]=1 ;  $  TAB2 if a[i]>a[i-1] then set dp[i]=dp[i-1]+1 ;  $  TAB2 set ans =max of dp[i] and ans ;  $  TAB1 print ans ;
TAB1 make int num ;  $  TAB1 read num ;  $  TAB1 make int count ;  $  TAB1 for i = 1 to num inclusive ;  $  TAB2 read count ;  $  TAB2 if 360 mod (180 - count) is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 n,x = long longs ;  $  TAB1 read n ;  $  TAB1 loop forever and do the following ;  $  TAB2 x = n modulo 10 ;  $  TAB2 if x is less than 5 do the following ;  $  TAB3 print O-| ;  $  TAB3 for i=0 to x exclusive, print O ;  $  TAB3 print - ;  $  TAB3 for i=0 to 4-x exclusive, print O ;  $  TAB3 print a new line ;  $  TAB2 else do the following ;  $  TAB3 x = x-5 ;  $  TAB3 print -O| ;  $  TAB3 for i=0 to x exclusive, print O ;  $  TAB3 print - ;  $  TAB3 for i=0 to 4-x exclusive, print O ;  $  TAB3 print a newline ;  $  TAB2 n=n/10 ;  $  TAB2 if n is 0, exit the loop ;
TAB0 let maxn = integer constant value 1005 ;  $  TAB0 let a,b = arrays of integers size maxn ;  $  TAB1 let sum, max = integers value 0 ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read a[i], b[i] ;  $  TAB2 set sum = sum -a[i] +b[i] ;  $  TAB2 if sum is greater than max set max = sum ;  $  TAB1 print max ;
TAB0 let n, k = integer ;  $  TAB0 let r, l, val = long longs ;  $  TAB1 read n, k ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 read l, r ;  $  TAB2 set val = val + r - l + 1 ;  $  TAB1 print (k - (val modulo k)) modulo k ;
TAB0 n and m are integers ;  $  TAB1 read n and m ;  $  TAB1 if n is false ;  $  TAB2 if m is positive ;  $  TAB3 display Impossible ;  $  TAB2 else ;  $  TAB3 display 0, ' ', 0 ;  $  TAB1 else if m is false ;  $  TAB2 display n, ' ', n ;  $  TAB1 else ;  $  TAB2 mini = integer = n + m - call min with arguments n, m ;  $  TAB2 max = integer = n + m - 1 ;  $  TAB2 display mini, ' ', max ;
TAB0 let n = integer ;  $  TAB0 let A = array of integers size 1000 ;  $  TAB1 read n ;  $  TAB1 read n values into array A ;  $  TAB1 let G, C = integers value 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 if A[i] is 0 do the following ;  $  TAB3 set G = (min of C and G) +1 ;  $  TAB3 set C = G ;  $  TAB2 else if A[i] is 1 do the following ;  $  TAB3 let temp = integer value G ;  $  TAB3 set G = (min of G and C)+1 ;  $  TAB3 set C = min of temp and C+1 ;  $  TAB2 else if A[i] is 2 do the following ;  $  TAB3 let temp = integer value C ;  $  TAB3 set C = (min of G and C)+1 ;  $  TAB3 set G = min of temp and G+1 ;  $  TAB2 else ;  $  TAB3 let temp = integer value G ;  $  TAB3 set G = min of C and G+1 ;  $  TAB3 set C = min of temp and C+1 ;  $  TAB1 print min of G and C ;
TAB0 let n = long long ;  $  TAB1 read n ;  $  TAB1 while 1 is true do the following ;  $  TAB2 increment n ;  $  TAB2 let a, b, c, d = characters ;  $  TAB2 set a = n modulo 10 ;  $  TAB2 set b = n / 10 modulo 10 ;  $  TAB2 set c n / 100 modulo 10 ;  $  TAB2 set d = n / 1000 modulo 10 ;  $  TAB2 if a is not equal to b and a is not equal to c and a is not equal to d and b is not equal to c and b is not equal to d and c is not equal to d do the following ;  $  TAB3 print n ;
TAB0 value is an integer array of length 101 ;  $  TAB0 in function isLucky that takes integer n and return integer ;  $  TAB1 sum = integer with sum = 0 ;  $  TAB1 while n ;  $  TAB2 if n mod 10 is equal to 4 or n mod 10 is equal to 7, increment sum ;  $  TAB2 divide n by 10 ;  $  TAB1 return sum ;  $  TAB1 n, k, count = integers with count = 0 ;  $  TAB1 input n, k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input value[i] ;  $  TAB2 if call function isLucky with argument value[i] is less than or equal to k, increment count ;  $  TAB1 output count ;
TAB1 let gcd, i, t = integers with gcd = 0 and n = array of integers size 1000 ;  $  TAB1 read t ;  $  TAB1 for integer i=0 to t exclusive do the following ;  $  TAB2 read n[i] ;  $  TAB2 set gcd = __gcd(gcd,n[i] ;  $  TAB1 print t * gcd ;
TAB1 k, a, b, v are integers ;  $  TAB1 read k, a, b, v ;  $  TAB1 full is an integer set to b / (k - 1) ;  $  TAB1 if a is at most v * k * full ;  $  TAB2 display (a + v * k - 1) / (v * k) ;  $  TAB1 else ;  $  TAB2 got = integer = v * k * full ;  $  TAB2 subtract full * (k - 1) from b ;  $  TAB2 subtract got from a ;  $  TAB2 if v * (b + 1) is at least a ;  $  TAB3 display full + 1 ;  $  TAB2 else ;  $  TAB3 subtract v * (b + 1) from a ;  $  TAB3 left = integer = (a + v - 1) / v ;  $  TAB3 display full + 1 + left ;
TAB1 t is an integer with t set to 1 ;  $  TAB1 while decrement t ;  $  TAB2 n is an integer ;  $  TAB2 read n ;  $  TAB2 if n equals 0, display O-|-OOOO ;  $  TAB2 while n ;  $  TAB3 c is an integer set to n mod 10 ;  $  TAB3 if c is less than 5 ;  $  TAB4 display O-| ;  $  TAB3 else ;  $  TAB4 display -O| ;  $  TAB4 subtract 5 from c ;  $  TAB3 for i = 0 to c exclusive, display O ;  $  TAB3 display - ;  $  TAB3 for i = 0 to 5 exclusive, display O ;  $  TAB3 output newline ;  $  TAB3 divide n by 10 ;
TAB0 let PI be const double with PI = acos of -1.0 ;  $  TAB0 maxn = const int with maxn = 1e5 + 10 ;  $  TAB1 let n, ans1, ans2, num be integers with ans1 = 0 and ans2 = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read num ;  $  TAB2 set ans1 to bitwise or of ans1 and num ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read num ;  $  TAB2 set ans2 to bitwise or of ans2 and num ;  $  TAB1 print out ans1 + ans2 ;
TAB0 long long constant integer mod= 1000000007 ;  $  TAB0 long long constant integer md=998244353l ;  $  TAB0 in the function powmod which takes two long long integers a and b and returns a long long integer ;  $  TAB1 long long integer res=1 ;  $  TAB1 a= a%mod ;  $  TAB1 assert if b>=0 ;  $  TAB1 for b=b until b is true and b= b>>1 ;  $  TAB2 if b&1 then set res = res * a %mod ;  $  TAB2 set a = a * a %mod ;  $  TAB1 return res ;  $  TAB0 construct an ifstream object in ;  $  TAB0 construct an ofstream object out ;  $  TAB0 f=array of integer of size=1005 ;  $  TAB1 print fixed and setprecision(12) ;  $  TAB1 n,k=long long integer ;  $  TAB1 read n,k ;  $  TAB1 s= string ;  $  TAB1 read s ;  $  TAB1 while k is true ;  $  TAB2 x,y =long long integer ;  $  TAB2 read x,y ;  $  TAB2 a,b=character ;  $  TAB2 read a,b ;  $  TAB2 decrement x ;  $  TAB2 decrement y ;  $  TAB2 for i=x to y inclusive ;  $  TAB3 if s[i] = a set s[i] = b ;  $  TAB2 decrement k ;  $  TAB1 print s ;
TAB0 a = integer array of size 180 ;  $  TAB0 in function pd with parameter integer a and return integer ;  $  TAB1 for i = 3 to 360 inclusive ;  $  TAB2 if 180 * (i - 2) equals i * a, return 1 ;  $  TAB1 declare an integer n ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 for j = 0 to n exclusive ;  $  TAB2 if call pd with a[j] equals 1 ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let arr be a vector array of size n ;  $  TAB1 read n values into vector arr ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if arr[i] is 0 and arr[i - 1] and arr[i + 1], set arr[i] to 1 ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to n exclusive, add arr[i] to ans ;  $  TAB1 display ans ;
TAB0 MOD = long long integer set to 1000000007 ;  $  TAB0 str = string ;  $  TAB0 declare cpow which takes an integer x ;  $  TAB1 res = long long integer set to 1 ;  $  TAB1 for i = 0 to x exclusive, set res to 2 * res modulo MOD ;  $  TAB1 return res ;  $  TAB1 read str ;  $  TAB1 N = integer set to length of str ;  $  TAB1 ans = long long integer set to 0 ;  $  TAB1 for i = N - 1 down to 0 inclusive ;  $  TAB2 set ans to 2 * ans modulo MOD ;  $  TAB2 if index i of str is '1', set ans to ans + cpow with 2 * N - 1 - i as an argument, modulo MOD ;  $  TAB1 print ans ;
TAB1 n, a, d are integers ;  $  TAB1 read n, a, d ;  $  TAB1 r = integer = 0 ;  $  TAB1 basura = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare an integer x ;  $  TAB2 input x ;  $  TAB2 add x to basura if x is at most a, otherwise add 0 to basura ;  $  TAB2 if basura is greater than d ;  $  TAB3 set basura to 0 ;  $  TAB3 increment r ;  $  TAB1 display r ;
TAB1 s = string ;  $  TAB1 n, jum are long longs with jum = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read s ;  $  TAB2 if s is "Tetrahedron" ;  $  TAB3 add 4 to jum ;  $  TAB2 else if s is "Cube" ;  $  TAB3 add 6 to jum ;  $  TAB2 else if s is "Octahedron" ;  $  TAB3 add 8 to jum ;  $  TAB2 else if s is "Dodecahedron" ;  $  TAB3 add 12 to jum ;  $  TAB2 else ;  $  TAB3 add 20 to jum ;  $  TAB1 output jum ;
TAB1 n is an integer ;  $  TAB1 read n ;  $  TAB1 arr is an integer array of size 1000 ;  $  TAB1 read n values into array arr ;  $  TAB1 l is an integer set to arr[0] ;  $  TAB1 call sort with arr + 1, arr + n ;  $  TAB1 while arr[0] is at most arr[n - 1] ;  $  TAB2 increment arr[0] ;  $  TAB2 decrement arr[n - 1] ;  $  TAB2 call sort with arr + 1, arr + n ;  $  TAB1 display arr[0] - 1 ;
TAB0 create const long long MOD = 1e9 + 7 ;  $  TAB0 in function powmod return long long and accepting long long a, long long b, long long m = MOD ;  $  TAB1 make long long r = 1 ;  $  TAB1 while b greater than 0 ;  $  TAB2 if b bitwise and 1, set r to r * a % m ;  $  TAB2 set a to a * a % m ;  $  TAB2 bitwise shift b right by itself and 1 ;  $  TAB1 return r ;  $  TAB0 in function power returning long long and having long long a and long long b as parameters ;  $  TAB1 create long long r = 1 ;  $  TAB1 while b greater than 0 ;  $  TAB2 if b bitwise and 1, set r to r * a ;  $  TAB2 set a to a * a ;  $  TAB2 bitwise shift b right by itself and 1 ;  $  TAB1 return r ;  $  TAB0 in function gcd, taking long long a and long long b and returning long long ;  $  TAB1 if not b, return a ;  $  TAB1 return gcd(b, a % b) ;  $  TAB0 in function inv, returning long long with parameters long long a, long long m = MOD ;  $  TAB1 return powmod(a, m - 2, m) ;  $  TAB0 in function lcm with long long a and long long b as parameters and return type of long long ;  $  TAB1 return (a * b) / gcd(a, b) ;  $  TAB0 create map mmap of string to long long ;  $  TAB0 in function init ;  $  TAB1 set mmap["monday"] to 0 ;  $  TAB1 set mmap["tuesday"] to 1 ;  $  TAB1 set mmap["wednesday"] to 2 ;  $  TAB1 set mmap["thursday"] to 3 ;  $  TAB1 set mmap["friday"] to 4 ;  $  TAB1 set mmap["saturday"] to 5 ;  $  TAB1 set mmap["sunday"] to 6 ;  $  TAB1 call init ;  $  TAB1 create string s1 and s2 ;  $  TAB1 read s1 and s2 ;  $  TAB1 create long longs n1 = mmap[s1] and n2 = mmap[s2] ;  $  TAB1 if ((n1 + 31) % 7 equals n2) or ((n1 + 30) % 7 equals n2) or ((n1 + 28) % 7 equals n2) ;  $  TAB2 print "YES" ;  $  TAB3 newline ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB3 newline ;
TAB0 create integer m and y with m=0 ;  $  TAB0 into the function sum which takes integer x and returns a integer ;  $  TAB1 set m=0 ;  $  TAB1 assign x to y ;  $  TAB1 while x is not 0 ;  $  TAB2 set m = m+x%10 ;  $  TAB2 set x = x/10 ;  $  TAB1 retrun m ;  $  TAB1 n,k,x,i = integers with k=0 ;  $  TAB1 read n ;  $  TAB1 a= integer array of size 100000 and j= integer with value 1 ;  $  TAB1 if n<= 100000071 ;  $  TAB2 for i= max of 1 and n-100 to n inclusive ;  $  TAB3 set x=i ;  $  TAB3 if i+ sum(x) = n ;  $  TAB4 add 1 to k ;  $  TAB4 set a[j] = i ;  $  TAB4 add 1 to j ;  $  TAB1 else do the following ;  $  TAB2 for i= max of 1 and n-100 and n inclusive ;  $  TAB3 set x=i ;  $  TAB3 if i+sum(x) is equal to n ;  $  TAB4 add 1 to k ;  $  TAB4 set a[j] to i ;  $  TAB4 set j=j+1 ;  $  TAB1 create integer p = j-1 ;  $  TAB1 print k and a new line ;  $  TAB1 for i=1 to p inclusive print a[i] and a new line ;
TAB0 create constant integer base = 180 ;  $  TAB0 create integer array res of size 199 ;  $  TAB1 create ints i, j, k, n, f, t ;  $  TAB1 create int l = 3 ;  $  TAB1 create int st = base ;  $  TAB1 while l is less than or equal to 550 ;  $  TAB2 if st mod l equals 0 then set res[st / l] to 1 ;  $  TAB2 add 1 to l ;  $  TAB2 increase st by base ;  $  TAB1 read t ;  $  TAB1 while t decremented ;  $  TAB2 read n ;  $  TAB2 set f to res[n] ;  $  TAB2 if f ;  $  TAB3 print "YES\n" ;  $  TAB2 else ;  $  TAB3 print "NO\n" ;
TAB0 let inf be const long long with inf = 0x3f3f3f3f ;  $  TAB0 let N be const integer with N = 1e6 + 10 ;  $  TAB0 let mod be const long long with mod = 998244353 ;  $  TAB0 let mp be map of string to long long ;  $  TAB0 let ml be map of string to integer ;  $  TAB0 let t, n, m, x, y, z, ans, cnt be integers, and v, h, n be array of integers of size N ;  $  TAB0 let c be map of int to int ;  $  TAB0 let s be array of char of size N ;  $  TAB0 let ex, ey be long lon ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to n exclusive, read v[i] ;  $  TAB1 sort first n elements of v ;  $  TAB1 for i.= 0 to m exclusive ;  $  TAB2 read x, y, z ;  $  TAB2 if x is equal to 1 ;  $  TAB3 if y is equal to 1000000000 ;  $  TAB4 increment ans by 1 ;  $  TAB3 else ;  $  TAB4 set element at index cnt in h to y and increment cnt by 1 ;  $  TAB1 call sort with h and h + cnt ;  $  TAB1 set t to cnt + ans ;  $  TAB1 add n to ans ;  $  TAB1 let i, j be integers with i = j = 0 ;  $  TAB1 while i is less than n ;  $  TAB2 while j is less than cnt and h[j] < v[i] ;  $  TAB3 decrement t by 1 ;  $  TAB3 increment j by 1 ;  $  TAB2 set ans to min of ans and t + i ;  $  TAB2 if ans is zero, break ;  $  TAB2 increment i by 1 ;  $  TAB1 print out ans with newline ;
TAB1 create int n, m, in, im ;  $  TAB1 read n and m ;  $  TAB1 create multidimensional char array a with a size fo n * m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive do read a[i][j] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if a[i][j] is 'B' ;  $  TAB4 set a[i][j] to 'X' ;  $  TAB4 set in to i ;  $  TAB4 set im to j ;  $  TAB4 break ;  $  TAB1 create int s = 0 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 if a[in][i] is 'B' then add 1 to s ;  $  TAB1 divide s by s and 2 ;  $  TAB1 subtract s from in ;  $  TAB1 add s to im ;  $  TAB1 print in + 1, " ", im + 1 ;
TAB1 let a, b, c, d, e, s be integers ;  $  TAB1 read a, b, c, d, e ;  $  TAB1 set s to a + b + c + d + e ;  $  TAB1 if s is greater than 0 and s mod 5 equals 0 ;  $  TAB2 output (s / 5) ;  $  TAB1 else ;  $  TAB2 output -1 ;
TAB0 arr and arr2 are both integer arrays both of size 1001, N is an integer ;  $  TAB0 in function f with parameters integers st, en and return integer ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = st to en inclusive, set ans to ans or arr[i] ;  $  TAB1 ans2 = integer = 0 ;  $  TAB1 for i = st to en inclusive, set ans2 to ans2 or arr2[i] ;  $  TAB1 return ans + ans2 ;  $  TAB1 read N ;  $  TAB1 read N values into array arr ;  $  TAB1 read N values into array arr2 ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to N exclusive ;  $  TAB2 for j = i to N exclusive, set ans to call max with ans, call f with i, j ;  $  TAB1 display ans ;
TAB1 let n, count, D be integers with count = 0 ;  $  TAB1 read n ;  $  TAB1 let P, M, PE be vector of integers ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read D ;  $  TAB2 if D == 1 ;  $  TAB3 push i to the back of P ;  $  TAB2 else if D == 2 ;  $  TAB3 push i to the back of M ;  $  TAB2 else ;  $  TAB3 push i to the back of PE ;  $  TAB1 let Psize, Msize, PEsize be integers ;  $  TAB1 set Psize to size of P ;  $  TAB1 set Msize to size of M ;  $  TAB1 set PEsize to size of PE ;  $  TAB1 set count to min of min of Psize, Msize and PEsize ;  $  TAB1 if count == 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print count ;  $  TAB2 for i = 0 to count exclusive, print P[i], " ", M[i], " ", PE[i] ;
TAB1 n, sum, p, i are integers with sum set to 0 ;  $  TAB1 x is a double ;  $  TAB1 read n, x ;  $  TAB1 iterate n times ;  $  TAB2 read p ;  $  TAB2 add p to sum ;  $  TAB1 set sum to absolute value sum ;  $  TAB1 output ceiling (sum / x) ;
TAB1 create integer n ;  $  TAB1 input n ;  $  TAB1 output n / 2 + 1 ;
TAB1 xay=integer ;  $  TAB1 read xay ;  $  TAB1 create an integer a with a=0 ;  $  TAB1 create an integer b with b=0 ;  $  TAB1 create an integer z with z=0 ;  $  TAB1 create an integer x with x=0 ;  $  TAB1 s,c = integers ;  $  TAB1 for i=0 to xay exclusive ;  $  TAB2 read a,b ;  $  TAB2 if a<b ;  $  TAB3 set z=z+abs(a-b) ;  $  TAB2 else if a>b ;  $  TAB3 set z=z-a+b ;  $  TAB2 if x<y then set x=z ;  $  TAB1 print x ;
TAB0 a = integer array of size 100 ;  $  TAB0 ra = integer array of size 100 ;  $  TAB0 n = integer ;  $  TAB1 while input n ;  $  TAB2 flg = boolean = false ;  $  TAB2 num = integer = 0 ;  $  TAB2 temp = integer = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a[i] ;  $  TAB3 if a[i] ;  $  TAB4 if temp is at least 2, add temp to num ;  $  TAB4 set temp to 0 ;  $  TAB4 set flg to true ;  $  TAB3 else ;  $  TAB4 if flg ;  $  TAB5 increment temp ;  $  TAB4 else ;  $  TAB5 increment num ;  $  TAB2 t = integer = 0 ;  $  TAB2 for j = n - 1 to 0 inclusive, set ra[t + 1] to a[j] ;  $  TAB2 flg2 = boolean = false ;  $  TAB2 num2 = integer = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if not ra[i] ;  $  TAB4 if not flg2, increment num2 ;  $  TAB3 else ;  $  TAB4 set flg2 to true ;  $  TAB2 ans = integer = n - num - num2 ;  $  TAB2 if ans is negative ;  $  TAB3 display 0 ;  $  TAB2 else ;  $  TAB3 display ans ;
TAB0 a= integer array of size 10005 ;  $  TAB0 b= integer array of size 10005 ;  $  TAB0 num,sum= integers ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 near n values into array a and b from 1 to n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if a[i] > b[i] ;  $  TAB3 increment num ;  $  TAB2 else if a[i] < b[i] ;  $  TAB3 add 1 to sum ;  $  TAB1 if num>sum ;  $  TAB2 print Mishka ;  $  TAB1 else if num < sum ;  $  TAB2 print Chris ;  $  TAB1 else if num is equal to sum ;  $  TAB2 print Friendship is magic!^^ ;
TAB0 let i, n, m = long longs ;  $  TAB0 let a = array of strings size = 111 ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 for i=1 to n inclusive do the following ;  $  TAB2 if length of a[i] is less than 11 ;  $  TAB3 print a[i] ;  $  TAB2 else ;  $  TAB3 print a[i][0] and length of a[i] - 2 and a[i][length of a[i] -1] ;
TAB1 make integers n and t ;  $  TAB1 make int sum = 0 ;  $  TAB1 make int array a with length of 100000 ;  $  TAB1 make integer flag = 0 ;  $  TAB1 read n and t ;  $  TAB1 decrement t ;  $  TAB1 if t is equal to 1, assign 1 to flag ;  $  TAB1 read n - 1 values into a ;  $  TAB1 while sum is less than t, add a[sum] to sum ;  $  TAB1 if sum is equal to t ;  $  TAB2 assign 1 to flag ;  $  TAB1 else ;  $  TAB2 assign 0 to flag ;  $  TAB1 if flag ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 create int n, i, flag, c, l, array hash with 10000 elements = {0}, and j ;  $  TAB1 create string str ;  $  TAB1 create set of strings se ;  $  TAB1 read n ;  $  TAB1 assign 0 to c ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read str ;  $  TAB2 set l to str length ;  $  TAB2 create string s ;  $  TAB2 for j = 0 to l exclusive ;  $  TAB3 if hash[str[j]] not equals 1 then set hash[str[j]] to 1 ;  $  TAB2 for j = 97 to 122 inclusive ;  $  TAB3 if hash[j] equals 1 then push j onto s ;  $  TAB2 for j = 97 to 122 inclusive do set hash[j] to 0 ;  $  TAB2 insert s into se ;  $  TAB1 print se size ;
TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 if n less than or equal to 10 OR n greater than 21 ;  $  TAB2 print 0 ;  $  TAB1 else if n equals 20 ;  $  TAB2 print 15 ;  $  TAB1 else ;  $  TAB2 print 4 ;
TAB1 declare long longs N, M, K ;  $  TAB1 while read N, M, and K ;  $  TAB2 ans is a long long with ans initialized to 0 ;  $  TAB2 set ans to call max with arguments N / (K + 1) * M, M / (K + 1) * N ;  $  TAB2 if K + 1 is greater than N, set ans to call max with arguments ans, M / (K - N + 2) ;  $  TAB2 if K + 1 is greater than M, set ans to call max with arguments ans, N / (K - M + 2) ;  $  TAB2 if K + 2 is greater than M + N, set ans to -1 ;  $  TAB2 display ans ;
TAB0 create int array mns, initialized with {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} ;  $  TAB1 create int m, d ;  $  TAB1 read m and d ;  $  TAB1 print 1 + (d + mns[m - 1] - 2) / 7 - (d - 1) / 7 ;
TAB0 maxn is a constant integer set to 5100 ;  $  TAB0 n = integer ;  $  TAB0 f = integer array of size maxn ;  $  TAB1 input n ;  $  TAB1 read n values into array f ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i is equal to f[f[f[i]]] ;  $  TAB3 output YES ;  $  TAB1 output NO ;
TAB0 a=array of integer of size 2000 ;  $  TAB0 into the function initA which takes an integer m and returns an integer ;  $  TAB1 create an integer i with i=0 ;  $  TAB1 while m>0 ;  $  TAB2 set a[i++] = m mod 10 ;  $  TAB2 set m=m/10 ;  $  TAB1 return i-1 ;  $  TAB0 into the function fact that takes an integer n ;  $  TAB1 create an integer len with len=initA(n) ;  $  TAB1 while n is true decrement n do the following ;  $  TAB2 create an integer carry with carry=0 ;  $  TAB2 for k=0 to len inclusive ;  $  TAB3 create an integer x with x=a[k]*n+carry ;  $  TAB3 set a[k]=x mod 10 ;  $  TAB3 set carry=x/10 ;  $  TAB2 while carry>0 ;  $  TAB3 set a[++len] = carry mod 10 ;  $  TAB3 set carry=carry/10 ;  $  TAB1 for k=len to 0 inclusive print a[k] ;  $  TAB1 print new line ;  $  TAB1 a,b=integers ;  $  TAB1 read a,b ;  $  TAB1 if a>b then call fact with argument b else call fact with argument a ;
TAB1 a,b = strings ;  $  TAB1 read a,b ;  $  TAB1 len = integer with len = length of a ;  $  TAB1 for i = 0 to len exclusive do the following ;  $  TAB2 if a[i] is not equal to b[i] ;  $  TAB3 print 1 ;  $  TAB2 else ;  $  TAB3 print 0 ;  $  TAB1 print a new line ;
TAB1 let m, n, v, mx, mn = integers with mx = INT_MIN and mn = INT_MAX ;  $  TAB1 read n, m ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 let k = integer ;  $  TAB2 read k ;  $  TAB2 set mx = max of mx and k ;  $  TAB2 set mn = min of mn and k ;  $  TAB1 let flag = boolean with value true ;  $  TAB1 set v = max of 2*mn and mx ;  $  TAB1 for integer i=1 to m inclusive do the following ;  $  TAB2 let k = integer ;  $  TAB2 read k ;  $  TAB2 if k is less than or equal to v set flag to false ;  $  TAB1 if not flag ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print v ;
TAB1 let n, a, k, t = long long integers ;  $  TAB1 read n, k ;  $  TAB1 while (decrement k) is true do the following ;  $  TAB2 if n modulo 10 is 0 do the following ;  $  TAB3 set n = n / 10 ;  $  TAB2 else ;  $  TAB3 set n = n - 1 ;  $  TAB1 print n ;
TAB1 make integer array x with a length of 100 ;  $  TAB1 make integer i ;  $  TAB1 make integers n and k ;  $  TAB1 read n and k ;  $  TAB1 make integer tot = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set x[i] to 2 ;  $  TAB2 increase tot by x[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if tot is k then break ;  $  TAB2 increment x[i] ;  $  TAB2 increment tot ;  $  TAB2 if i equals n - 1 then set i to -1 ;  $  TAB1 make integer ct = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if x[i] equals 2 then increment ct ;  $  TAB1 print ct ;
TAB0 n = integer ;  $  TAB0 declare void nhap ;  $  TAB1 read n ;  $  TAB0 declare void solve ;  $  TAB1 while n > 5 ;  $  TAB2 if n modulo 2 is 0 ;  $  TAB3 set n to n - 4 / 2 ;  $  TAB2 else ;  $  TAB3 set n to n - 5 / 2 ;  $  TAB1 if n is 1, print "Sheldon\n" ;  $  TAB1 if n is 2, print "Leonard\n" ;  $  TAB1 if n is 3, print "Penny\n" ;  $  TAB1 if n is 4, print "Rajesh\n" ;  $  TAB1 if n is 5, print "Howard\n" ;  $  TAB1 run nhap ;  $  TAB1 run solve ;
TAB0 arr = array of integers set to length 100005 ;  $  TAB1 n, m = integers ;  $  TAB1 read n ;  $  TAB1 cnt = long long integer set to 0 ;  $  TAB1 mn = long long integer set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 add arr[i] to mn ;  $  TAB1 read m ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 u, v = integers ;  $  TAB2 read u, v ;  $  TAB2 if u <= mn and mn <= v ;  $  TAB3 print mn ;  $  TAB2 if u >= mn ;  $  TAB3 print u ;  $  TAB1 print "-1" ;  $  TAB2 newline ;
TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 if n equals 1 ;  $  TAB2 display 1 ;  $  TAB1 else ;  $  TAB2 c, b, kt are long longs with kt = 1 ;  $  TAB2 read c, b ;  $  TAB2 decrement n ;  $  TAB2 while decrement n ;  $  TAB3 declare a long long a ;  $  TAB3 read a ;  $  TAB3 if a - b is at most c, increment kt, else set kt to 1 ;  $  TAB3 assign a to b ;  $  TAB2 display kt ;
TAB1 a, b, _a, _b are long long integers ;  $  TAB1 read _a, _b ;  $  TAB1 set a to _a ;  $  TAB1 set b to _b ;  $  TAB1 s is a long long integer of size 2 set to 0, 0 ;  $  TAB1 current is an integer set to 0 ;  $  TAB1 while a isn't b ;  $  TAB2 if a is less than b ;  $  TAB3 m = integer set to a - current ;  $  TAB3 add m to s[0] ;  $  TAB3 add _a to a ;  $  TAB3 add m to current ;  $  TAB2 else ;  $  TAB3 m = integer = b - curent ;  $  TAB3 add m to s[1] ;  $  TAB3 add _b to b ;  $  TAB3 add m to current ;  $  TAB1 m is an integer set to a - current ;  $  TAB1 if _a is greater than _b ;  $  TAB2 add m to s[0] ;  $  TAB1 else ;  $  TAB2 add m to s[1] ;  $  TAB1 if s[0] is greater than s[1] ;  $  TAB2 display Dasha ;  $  TAB1 else if s[1] is greater than s[0] ;  $  TAB2 display Masha ;  $  TAB1 else ;  $  TAB2 display Equal ;
TAB1 let n, a, b, c, d = integer ;  $  TAB1 read n ;  $  TAB1 while 1 is true do the following ;  $  TAB2 increment n ;  $  TAB2 set a = n / 1000 ;  $  TAB2 set b = n / 100 modulo 10 ;  $  TAB2 set c = n / 10 modulo 10 ;  $  TAB2 set d = n modulo 10 ;  $  TAB2 if a is not equal to b and a is not equal to c and a is not equal to d and b is not equal to c and b is not equal to d and c is not equal to d exit the loop ;  $  TAB1 print n ;
TAB0 declare long long array dp with length of 100005 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare long long array a with length of n ;  $  TAB1 declare long long array b with length of n ;  $  TAB1 declare long long array c with length of n ;  $  TAB1 read n elements in a ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 set b[i] to abs of a[i + 1] - a[i] ;  $  TAB2 if i is odd, multiply b[i] by itself and -1 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 set c[i] to abs of a[i + 1] - a[i] ;  $  TAB2 if i is even, multiply c[i] by itself and -1 ;  $  TAB1 define long long ans with value b[0] ;  $  TAB1 define long long minimum with value b[0] ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 increase b[i] by b[i - 1] ;  $  TAB2 set ans to max of ans and b[i] - minimum ;  $  TAB2 set ans to max of ans and b[i] ;  $  TAB2 set minimum to min of minimum and b[i] ;  $  TAB1 set minimum to c[0] ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 add c[i - 1] to c[i] ;  $  TAB2 set ans to max of ans and c[i] - minimum ;  $  TAB2 set ans to max of ans and c[i] ;  $  TAB2 set minimum to min of minimum and c[i] ;  $  TAB1 print ans ;
TAB0 create constant integer maxn = 1e5 + 10 ;  $  TAB0 in the function gcd which takes two integers a and b and returns their gcd ;  $  TAB1 return a if b is equal to 0 else return gcd(b, a % b) ;  $  TAB0 let mp be a map from int to bool ;  $  TAB1 clear mp ;  $  TAB1 create integer n,d,ma=0 and num=0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 x= integer ;  $  TAB2 read x ;  $  TAB2 if i is equal to 0 ;  $  TAB3 set d = x ;  $  TAB2 else do the following ;  $  TAB3 set d = gcd (d,x) ;  $  TAB2 if mp[x] is false ;  $  TAB3 then set mp[x] to true ;  $  TAB3 increment num ;  $  TAB2 set ma to max of ma and x ;  $  TAB1 if (ma/d - num)%2 is equal to 1 ;  $  TAB2 print Alice and new line ;  $  TAB1 else do the following ;  $  TAB2 print Bob and a new line ;
TAB0 let mod be const int with mod = 1e9 + 1 ;  $  TAB0 let N be const int with Nn = 1e6 + 1 ;  $  TAB1 let s be string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if i == 0 and s[i] == '9' ;  $  TAB3 set s[i] to s[i] ;  $  TAB2 else if s[i] > 52 ;  $  TAB3 set s[i] to (48 + 57 - s[i]) ;  $  TAB1 let convert be stringstream of s ;  $  TAB1 let x be unsigned long long ;  $  TAB1 read x into convert ;  $  TAB1 print x ;
TAB0 create int lessonsn, pairs, res = 0 ;  $  TAB0 create boolean array tab of size 102 ;  $  TAB1 read lessonsn ;  $  TAB1 set tab[0] to 0 ;  $  TAB1 set tab[lessonsn + 1] to 0 ;  $  TAB1 read lessonsn values into tab ;  $  TAB1 for i = 1 to lessonsn inclusive ;  $  TAB2 if tab[i] ;  $  TAB3 add 1 to res ;  $  TAB2 else if not tab[i] and (tab[i - 1] and tab[i + 1]) ;  $  TAB3 add 1 to res ;  $  TAB1 print res ;
TAB1 n, i, a are long longs with i = 0, a = 0 ;  $  TAB1 c is a character ;  $  TAB1 input n ;  $  TAB1 while i is less than n ;  $  TAB2 input c ;  $  TAB2 if c is the character 1 ;  $  TAB3 increment a ;  $  TAB2 else ;  $  TAB3 decrement a ;  $  TAB2 increment i ;  $  TAB1 display absolute value of a ;
TAB1 let n, t, num = integers ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 declare int n, ai ;  $  TAB0 declare int array cnt, size 3 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read ai ;  $  TAB2 increment cnt[ai - 1] ;  $  TAB1 print n - max element of cnt ;
TAB0 create map mp of strings to ints ;  $  TAB0 create set<string> st ;  $  TAB1 create string a, b ;  $  TAB1 create int ta, tb, tc ;  $  TAB1 set mp["^"] to 0, mp[">"] to 1, mp["v"] to 2, and mp["<"] to 3 ;  $  TAB1 while read a, b, tc ;  $  TAB2 set ta to mp[a] and tb to mp[b] ;  $  TAB2 create int flag = 0 ;  $  TAB2 if (ta + tc) mod 4 is tb then add 1 to flag ;  $  TAB2 if (ta + 4 - tc mod 4) mod 4 is tb then add 2 to flag ;  $  TAB2 if flag is 1 ;  $  TAB3 print "cw" ;  $  TAB2 else if flag is 2 ;  $  TAB3 print "ccw" ;  $  TAB2 else ;  $  TAB3 print "undefined" ;
TAB0 maxn is a constant integer set to 101000 ;  $  TAB0 mo is a constant integer set to 1e9 + 7 ;  $  TAB0 ans is a long long ;  $  TAB0 f, n, m, h are integers ;  $  TAB0 a, c, sum are all integer arrays all of size maxn, k is an integer ;  $  TAB0 b = integer array of size maxn, flag = integer, temp = integer ;  $  TAB0 s is a character array of size maxn ;  $  TAB1 T is an integer ;  $  TAB1 cas is an integer set to 1 ;  $  TAB1 while read n, m ;  $  TAB2 assign n * 2 + 1 to n ;  $  TAB2 assign 0 to ans ;  $  TAB2 read n values into array a ;  $  TAB2 display a[0], " " ;  $  TAB2 for i = 1 to n - 1 exclusive ;  $  TAB3 if m and a[i] are greater than a[i - 1] + 1 and a[i] is greater than a[i + 1] + 1 ;  $  TAB4 display a[i] - 1, " " ;  $  TAB4 decrement m ;  $  TAB3 else ;  $  TAB4 display a[i], " " ;  $  TAB2 display a[n - 1] ;
TAB1 create int n, array a with a length of 35, array b with a length of 35, and sum = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive: read a[i] and b[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if a[i] is equal to b[j], add 1 to sum ;  $  TAB1 print sum ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let arr be an integer array of length n ;  $  TAB1 read n values into array arr ;  $  TAB1 ming1 and ming2 are both integers both set to -1 ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if ming1 equals -1 or ming1 is less than arr[i + 1] - arr[i], set ming1 to arr[i + 1] - arr[i] ;  $  TAB1 for i = 0 to n - 2 exclusive ;  $  TAB2 if ming2 equals -1 or ming2 is greater than arr[i + 2] - arr[i], set ming2 to arr[i + 2] - arr[i] ;  $  TAB1 display call max with ming1, ming2 ;
TAB0 M = constant integer set to 100 + 5 ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is ':', set s[i] to ' ' ;  $  TAB1 declare ss with s, as a string stream ;  $  TAB1 h, m = integer ;  $  TAB1 ss to h to m ;  $  TAB1 if s[1] >= '0' and s[i] <= '5' ;  $  TAB2 pm = integer set to s[1] - '0' * 10 + s[0] - '0' ;  $  TAB2 if m < pm ;  $  TAB3 if h / 10 is 0 ;  $  TAB4 print "0", h, and ":" ;  $  TAB3 else ;  $  TAB4 print h and ":" ;  $  TAB3 if pm /10 is 0 ;  $  TAB4 print "0" and pm ;  $  TAB3 else ;  $  TAB4 print pm ;  $  TAB2 else ;  $  TAB3 set h to h + 1 modulo 24 ;  $  TAB3 while h modulo 10 > 5, set h to h + 1 modulo 24 ;  $  TAB3 pm = integer set to h modulo 10 * 10 + h / 10 ;  $  TAB3 if h / 10 is 0 ;  $  TAB4 print "0", h, and ":" ;  $  TAB3 else ;  $  TAB4 print h and ":" ;  $  TAB3 if pm / 10 is 0 ;  $  TAB4 print "0" ;  $  TAB3 else ;  $  TAB4 print pm ;  $  TAB1 else ;  $  TAB2 set h to h + 1 modulo 24 ;  $  TAB2 while h modulo 10 > 5, set h to h + 1 modulo 24 ;  $  TAB2 pm = integer set to h modulo 10 * 10 + h / 10 ;  $  TAB2 if h / 10 is 0 ;  $  TAB3 print "0", h, and ":" ;  $  TAB2 else ;  $  TAB3 print h and ":" ;  $  TAB2 if pm / 10 is 0 ;  $  TAB3 print "0" and pm ;  $  TAB2 else ;  $  TAB3 print pm ;
TAB1 n,i,k,p = integers with p=1 ;  $  TAB1 read n ;  $  TAB1 create integer x=n/2 ;  $  TAB1 for i=0 to x exclusive ;  $  TAB2 for j=1 to x exclusive print * ;  $  TAB2 for k=0 to p exclusive print D ;  $  TAB2 for j=i to x exclusive print * ;  $  TAB2 set p= p+2 ;  $  TAB2 print new line ;  $  TAB1 for i=0 to x inclusive ;  $  TAB2 for j=0 to i exclusive print * ;  $  TAB2 for k=0 to p exclusive prind D ;  $  TAB2 for j=0 to i exclusive print * ;  $  TAB2 set p = p -2 ;  $  TAB2 print new line ;
TAB0 let k, a, b, v be integers ;  $  TAB0 in function check with parameter integer g and return boolean ;  $  TAB1 i, t, sum are integers with t = b, sum = 0 ;  $  TAB1 for i = 0 to g exclusive ;  $  TAB2 if t is at least k - 1 ;  $  TAB3 subtract k - 1 from t ;  $  TAB3 add v * k to sum ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 if i is g, return sum is greater than or equal to a ;  $  TAB1 subtract i from g ;  $  TAB1 add (t + 1) * v to sum ;  $  TAB1 if g - 1 is 0, return sum is greater than a ;  $  TAB1 return sum + g * v is greater than or equal to a ;  $  TAB1 while read k, a, b, v ;  $  TAB2 l, r, m are integers with l = 0, r = 1000 ;  $  TAB2 while r - 1 is greater than 1 ;  $  TAB3 set m to (l + r) / 2 ;  $  TAB3 if call check with m ;  $  TAB4 set r to m ;  $  TAB3 else ;  $  TAB4 set l to m ;  $  TAB2 print r ;
TAB1 let k, r be integers ;  $  TAB1 let a be integer with a = 0 ;  $  TAB1 read k, r ;  $  TAB1 update k to k mod 10 ;  $  TAB1 for i = 1 to 10 inclusive ;  $  TAB2 increment a ;  $  TAB2 if (i * k) % 10 == r or (i * k) % 10 == 0 ;  $  TAB3 print a with newline ;  $  TAB2 else if i == 10 ;  $  TAB3 print 10 ;
TAB1 let t, a be integers ;  $  TAB1 input t ;  $  TAB1 iterate t times ;  $  TAB2 input a ;  $  TAB2 if 360 modulo (180 - a) equals 0 ;  $  TAB3 output YES ;  $  TAB4 output newline ;  $  TAB2 else ;  $  TAB3 output NO ;  $  TAB4 output newline ;
TAB0 n = integer ;  $  TAB1 while read n ;  $  TAB2 if n bitwise and 1 ;  $  TAB3 subtract 3 from n ;  $  TAB3 shift n right 1 bit ;  $  TAB3 output n + 1 ;  $  TAB3 for i = 1 to n inclusive, output "2 " ;  $  TAB3 output 3 ;  $  TAB2 else ;  $  TAB3 shift n right 1 bit ;  $  TAB3 output n ;  $  TAB3 for i = 1 to n exclusive, output "2 " ;  $  TAB3 output 2 ;
TAB1 t = integer ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 declare a double a ;  $  TAB2 read a ;  $  TAB2 set a to (180 + a) / (180 - a) + 1 ;  $  TAB2 print YES if a equals integer value of a, otherwise print NO ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 len = integer = length of s ;  $  TAB1 i = integer = 0 ;  $  TAB1 f = integer = 1 ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if s[i] isn't the character a, set f to 0 ;  $  TAB1 if f ;  $  TAB2 set s[len - 1] to the character z ;  $  TAB2 print s ;  $  TAB1 while s[i] is the character a and i is less than len, print s[i], increment i ;  $  TAB1 flag = integer = 0 ;  $  TAB1 iterate as long as i is less than n with increment i + 1 ;  $  TAB2 if s[i] is the character a, set flag to 1 ;  $  TAB2 if flag ;  $  TAB3 print s[i] ;  $  TAB2 else ;  $  TAB3 print character value of (s[i] - 1) ;  $  TAB1 print newline ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create integer k = s.length() ;  $  TAB1 create integer array a of size 10 initialized to 0 ;  $  TAB1 if s[0] equals 52 ;  $  TAB2 print "NO" ;  $  TAB1 for i = 0 to k exclusive, increment a[s[i] - '0'] ;  $  TAB1 for i = 0 to 10 exclusive ;  $  TAB2 if i is not equal to 1 and i is not equal to 4 ;  $  TAB3 if a[i] greater than 0 ;  $  TAB4 print "NO" ;  $  TAB1 create integer max_cont_4 = -5 ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 if s[i] equals 52 ;  $  TAB3 create int count = 1 ;  $  TAB3 increment i ;  $  TAB3 while i less than k and s[i] equals 52 ;  $  TAB4 increment count ;  $  TAB4 increment i ;  $  TAB3 if max_cont_4 less than count, set max_cont_4 to count ;  $  TAB1 if max_cont_4 greater than 2 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n,k,e = integers with e = 0 and a = array of integers size 100005 ;  $  TAB1 read n ;  $  TAB1 read n-1 values into array a ;  $  TAB1 call sort on a and a+n-1 ;  $  TAB1 for i = 0 to n-2 exclusive do the following ;  $  TAB2 if a[i+1] is not equal to a[i]+1 do the following ;  $  TAB3 k = i+2 ;  $  TAB3 e = 1 ;  $  TAB3 break out of the loop ;  $  TAB1 if e is 0 do the following ;  $  TAB2 if a[0] is 1 do the following ;  $  TAB3 print n ;  $  TAB2 else do the following ;  $  TAB3 print 1 ;  $  TAB1 else do the following ;  $  TAB2 print k ;
TAB1 let n, i, c = integers ;  $  TAB1 while (read n) is true ;  $  TAB2 let a = vector of integers ;  $  TAB2 for i=0 to n exclusive do the following ;  $  TAB3 read c ;  $  TAB3 append c to a ;  $  TAB2 call sort on a from beginning to end ;  $  TAB2 let cha, min = integers with min = 2000000009 ;  $  TAB2 let num = integer with value 0 ;  $  TAB2 for i=1 to n exclusive do the following ;  $  TAB3 set cha = a[i]-a[i-1] ;  $  TAB3 if cha is less than min do the following ;  $  TAB4 set min = cha ;  $  TAB4 set num = 1 ;  $  TAB3 else ;  $  TAB4 if cha is min increment num ;  $  TAB2 print min and a space and num ;  $  TAB2 remove all elements from a ;
TAB1 let str be a string ;  $  TAB1 let i, j be integers ;  $  TAB1 input str ;  $  TAB1 for i = 0 to size of str exclusive ;  $  TAB2 if str[i] isn't the character a, break ;  $  TAB1 for j = i to size of str exclusive ;  $  TAB2 if str[j] is the character a, break ;  $  TAB2 decrement str[j] ;  $  TAB1 if i equals size of str, assign the character z to str[(size of str) - 1] ;  $  TAB1 display str ;
TAB1 na, nb, k, n, m are integers, a = integer array of size 100020, b = integer array of size 100005 ;  $  TAB1 input na, nb ;  $  TAB1 input k, m ;  $  TAB1 read na values into array a ;  $  TAB1 l = integer = nb - m ;  $  TAB1 read nb values into array b ;  $  TAB1 if a[k - 1] is less than b[l] ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 declare integers k, a, b, v ;  $  TAB1 cout.precision(10) ;  $  TAB1 read k, a, b, v ;  $  TAB1 define integer ans = 0 ;  $  TAB1 while a ;  $  TAB2 define integer x = min(k - 1, b) ;  $  TAB2 set a = max(0, a - (x + 1) * v) ;  $  TAB2 subtract x from b ;  $  TAB2 add 1 to ans ;  $  TAB1 print ans ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 display I hate ;  $  TAB1 while decrement n is positive ;  $  TAB2 display that I love ;  $  TAB2 if decrement n equals 0, break ;  $  TAB2 display that I hate ;  $  TAB1 display it ;
TAB1 n is an integer ;  $  TAB1 name1, name2 are strings, s is a string array of size 2 ;  $  TAB1 read name1, name2 ;  $  TAB1 read n ;  $  TAB1 set s[0] to name1 ;  $  TAB1 set s[1] to name2 ;  $  TAB1 display name1, " ", name2 ;  $  TAB1 iterate n times ;  $  TAB2 read name1, name2 ;  $  TAB2 if s[0] is equal to name1 ;  $  TAB3 assign name2 to s[0] ;  $  TAB2 else ;  $  TAB3 assign name2 to s[1] ;  $  TAB2 display s[0], " ", s1 ;
TAB1 n = integer ;  $  TAB1 while input n ;  $  TAB2 max = long long with max = 0 ;  $  TAB2 sum = long long with sum = 0 ;  $  TAB2 let a be an integer array of length 101 ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 set sum to a[i] ;  $  TAB3 let total be a long long with total = sum ;  $  TAB3 for j = i + 1 to n exclusive ;  $  TAB4 set sum to a[j] to the power of sum ;  $  TAB4 if sum is less than total, assign sum to total ;  $  TAB3 if total is greater than max, assign total to max ;  $  TAB2 output max ;
TAB1 n, t, k, d = integers ;  $  TAB1 read n, t, k, d ;  $  TAB1 let integer c = (n + k - 1) / k ;  $  TAB1 let integer o1 = 0, o2 = d ;  $  TAB1 for i = 0 to c exclusive ;  $  TAB2 if o1 <= o2 ;  $  TAB3 set o1 to o1 + t ;  $  TAB2 else ;  $  TAB3 set o2 to o2 + t ;  $  TAB1 set o1 to max of o1 and o2 ;  $  TAB1 if o1 >= c * t ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n = integer ;  $  TAB1 input n ;  $  TAB1 a is an integer array of size 1005 ;  $  TAB1 for i = 0 to n * 2 exclusive, read a[i] ;  $  TAB1 call sort with a, a + n * 2 ;  $  TAB1 if a[n] is greater than a[n - 1] ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB0 test, x, frnd are integers ;  $  TAB1 read test ;  $  TAB1 set frnd to 3 ;  $  TAB1 for i = 1 to test inclusive ;  $  TAB2 read x ;  $  TAB2 if x is frnd, return output NO, newline, 0 ;  $  TAB2 for j = 1 to 3 inclusive ;  $  TAB3 if j isn't equal to frnd and j isn't equal to x ;  $  TAB4 set frnd to j ;  $  TAB4 break ;  $  TAB1 output YES ;
TAB1 declare int temp ;  $  TAB1 declare map c with int keys and int values ;  $  TAB1 declare map m with int keys and int values ;  $  TAB1 read temp ;  $  TAB1 increase m[1] by temp ;  $  TAB1 increase m[4] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[1] by temp ;  $  TAB1 increase m[3] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[1] by temp ;  $  TAB1 increase m[2] by temp ;  $  TAB1 read temp ;  $  TAB1 increase c[1] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[1] by temp ;  $  TAB1 increase m[2] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[2] by temp ;  $  TAB1 increase m[4] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[3] by temp ;  $  TAB1 increase m[2] by temp ;  $  TAB1 read temp ;  $  TAB1 increase c[2] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[3] by temp ;  $  TAB1 increase m[2] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[1] by temp ;  $  TAB1 increase m[3] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[3] by temp ;  $  TAB1 increase m[4] by temp ;  $  TAB1 read temp ;  $  TAB1 increase c[3] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[3] by temp ;  $  TAB1 increase m[4] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[4] by temp ;  $  TAB1 increase m[2] by temp ;  $  TAB1 read temp ;  $  TAB1 increase m[1] by temp ;  $  TAB1 increase m[4] by temp ;  $  TAB1 read temp ;  $  TAB1 increase c[4] by temp ;  $  TAB1 define int flag = 0 ;  $  TAB1 if c[1] is greater than 0 ;  $  TAB2 if m[1] is greater than 0: set flag to 1 ;  $  TAB1 if c[2] is greater than 0 ;  $  TAB2 if m[2] is greater than 0: set flag to 1 ;  $  TAB1 if c[3] is greater than 0 ;  $  TAB2 if m[3] is greater than 0: set flag to 1 ;  $  TAB1 if c[4] is greater than 0 ;  $  TAB2 if m[4] is greater than 0: set flag to 1 ;  $  TAB1 if flag equals 0 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB0 n and m are integers ;  $  TAB1 input n and m ;  $  TAB1 if n equals 0 and m is positive ;  $  TAB2 display Impossible ;  $  TAB1 mini is an integer with mini = n + m - call min with arguments n, m ;  $  TAB1 maxi is an integer with maxi = n + m - call min with arguments 1, m ;  $  TAB1 display mini," ", maxi ;
TAB0 fs = string vector ;  $  TAB0 valid = long long integer array of size 200 ;  $  TAB1 n,in = long long integers ;  $  TAB1 read n ;  $  TAB1 h,w,k = strings ;  $  TAB1 ch = char ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read h ;  $  TAB2 transform the string h to lowercase ;  $  TAB2 add h to end of fs ;  $  TAB1 read w and ch ;  $  TAB1 if ch - 'a' >=0 or 'z' - ch >=0 ;  $  TAB2 set in = ch - 'a' ;  $  TAB1 else do the following ;  $  TAB2 set in= ch= 'A' ;  $  TAB1 set k = w ;  $  TAB1 transform w to lower case ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create long long integer z = length of fs[i] ;  $  TAB2 for j=0 to length of w exclusive ;  $  TAB3 create a empty string temp ;  $  TAB3 for k=j to j+z exclusive set temp = temp + w[k] ;  $  TAB3 if temp is equal to fs [i] ;  $  TAB4 for k=j to j+z exclusive set valid[k]=1 ;  $  TAB1 create empty string res ;  $  TAB1 for i=0 to length of w exclusive ;  $  TAB2 if valid[i] is not 0 ;  $  TAB3 if k[i] >= 'a' and k[i] <= 'z' ;  $  TAB4 if k[i] - 'a' is not equal to in ;  $  TAB5 set res = res + 'a' + in ;  $  TAB4 else do the following ;  $  TAB5 if ch > 'a' and ch <= 'z' ;  $  TAB6 set res = res + 'a' ;  $  TAB5 else if ch='a' ;  $  TAB6 set res = res + 'b' ;  $  TAB5 else ch > 'A' and ch <= 'Z' ;  $  TAB6 set res = res + 'a' ;  $  TAB5 else if ch = 'A' then do the following ;  $  TAB6 set res = res + 'b' ;  $  TAB3 else do the following ;  $  TAB4 if k[i] - 'A' is not equal to in ;  $  TAB5 set res = res + 'A' + in ;  $  TAB4 else do the following ;  $  TAB5 if ch > 'A' and ch <= 'Z' ;  $  TAB6 set res =res + 'A' ;  $  TAB5 else if ch = 'A ;  $  TAB6 set res = res + 'B' ;  $  TAB5 else if ch > 'a' and ch <= 'z' ;  $  TAB6 set res = res + 'A' ;  $  TAB5 else if ch = 'a' then do the following ;  $  TAB6 set res = res + 'B' ;  $  TAB2 else do the following ;  $  TAB3 set res = res + k[i] ;  $  TAB1 print res ;
TAB1 make long long int n ;  $  TAB1 read n ;  $  TAB1 if n greater than 2 ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print n ;
TAB0 a=array of integer of size 109 ;  $  TAB1 create integer n, mx=-10e9+9,ans=0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 set mx to max of mx and a[i] ;  $  TAB1 for i=0 to n exclusive set ans=ans+mx-a[i] ;  $  TAB1 print ans ;
TAB1 i,j,k,m,n,k0,k1= integers with k0=k1=0 ;  $  TAB1 s= array of characters of size 1000 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if s[i] is 0 then increment k0 ;  $  TAB2 if s[i] is 1 then increment k1 ;  $  TAB1 if k1>0 ;  $  TAB2 then print 1 ;  $  TAB2 for i=0 to k0 print 0 ;  $  TAB2 print new line ;  $  TAB1 else do the following ;  $  TAB2 print 0 ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 javob = array of long long integer of size n ;  $  TAB1 a,b,k=long long integers ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a,b,k ;  $  TAB2 if k mod 2 =0 ;  $  TAB3 set javob[i] = (a - b) * k / 2 ;  $  TAB2 else do the following ;  $  TAB3 set javob[i] = a * (k / 2 + 1) - b * (k / 2) ;  $  TAB1 print n values of array javob ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 make integers m and d ;  $  TAB1 read m and d ;  $  TAB1 make integer nd = 30 ;  $  TAB1 if (m less than 8 AND m is odd) OR (m greater than or equal to 8 AND m is even) ;  $  TAB2 increment nd ;  $  TAB1 else if m is equal to 2 ;  $  TAB2 decrease nd by 2 ;  $  TAB1 increase nd by d - 1 ;  $  TAB1 print nd / 7 + (nd mod 7 != 0) ;
TAB1 let n, c be long longs ;  $  TAB1 input n, c ;  $  TAB1 k is a long long set to 0 ;  $  TAB1 iterate n times ;  $  TAB2 declare long longs m, p ;  $  TAB2 read m ;  $  TAB2 if k is 0 ;  $  TAB3 set p to m ;  $  TAB3 increment k ;  $  TAB2 else ;  $  TAB3 if m - p is at most c ;  $  TAB4 increment k ;  $  TAB4 set p to m ;  $  TAB3 else ;  $  TAB4 set k to 0 ;  $  TAB4 set p to m ;  $  TAB4 increment k ;  $  TAB1 display k ;
TAB1 declare string number ;  $  TAB1 read number ;  $  TAB1 declare int flag ;  $  TAB1 define int x = 0 ;  $  TAB1 for i = 0 to number length exclusive ;  $  TAB2 if number[i] equals '4' or number[i] equals '7': increment x ;  $  TAB1 declare string str ;  $  TAB1 declare ostringstream temp ;  $  TAB1 write x to temp ;  $  TAB1 set str to temp's underlying string ;  $  TAB1 for i = 0 to str length exclusive ;  $  TAB2 if str[i] equals '4' or str[i] equals '7' ;  $  TAB3 set flag to 0 ;  $  TAB2 else ;  $  TAB3 set flag to 1 ;  $  TAB3 break ;  $  TAB1 if flag equals 0 ;  $  TAB2 print "YES" ;  $  TAB1 else if flag equals 1 ;  $  TAB2 print "NO" ;
TAB0 in function mul with parameters long long x, p and return long long ;  $  TAB1 ans is a long long initialized to 1 ;  $  TAB1 while p ;  $  TAB2 if p bitwise and 1, set ans to ans * x modulo 1000000007 ;  $  TAB2 set x to x * x modulo 1000000007 ;  $  TAB2 set p to p shifted to the right 1 bit ;  $  TAB1 return ans ;  $  TAB1 declare a long long n ;  $  TAB1 input n ;  $  TAB1 if n is true ;  $  TAB2 w is a long long with w = call mul with arguments (2, n - 1) modulo 1000000007 ;  $  TAB2 display (w + 2 * w * w modulo 1000000007) modulo 1000000007 ;  $  TAB1 else ;  $  TAB2 display 1 ;
TAB1 create integers a1, a2, tmp = 0 ;  $  TAB1 read a1 and a2 ;  $  TAB1 while a2 is not equal to 0 ;  $  TAB2 multiply tmp by itself and 10 ;  $  TAB2 increase tmp by itself and a2 mod 10 ;  $  TAB2 divide a2 by itself and 10 ;  $  TAB1 print a1 + tmp ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 print (2 if n == 2; else 1) ;
TAB1 let n, flag, i, j = integer with flag = 0 ;  $  TAB1 let a = 110 arrays of character size = 110 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive read a[j][i] ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 let count = integer value = 0 ;  $  TAB2 for j=0 to n exclusive do the following ;  $  TAB3 if a[j-1][i] is o increment count ;  $  TAB3 if a[j+1][i] is o increment count ;  $  TAB3 if a[j][i-1] is o increment count ;  $  TAB3 if a[j][i+1] is o increment count ;  $  TAB3 if count is odd do the following ;  $  TAB4 set flag = 0 ;  $  TAB4 exit the loop ;  $  TAB1 if flag is 1 do the following ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 make ints m and a ;  $  TAB1 read m ;  $  TAB1 make float s ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read a ;  $  TAB2 s = 360.0 / (180.0 - a) ;  $  TAB2 if s - int cast s equals 0.0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 n and m are integers ;  $  TAB1 read n and m ;  $  TAB1 flag is a boolean set to true ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if i is even ;  $  TAB4 display # ;  $  TAB3 else ;  $  TAB4 if j equals 0 and flag ;  $  TAB5 display # ;  $  TAB4 else if j equals (m - 1) and not flag ;  $  TAB5 display # ;  $  TAB4 else ;  $  TAB5 display . ;  $  TAB2 display newline ;  $  TAB2 if i is even, set flag to not flag ;
TAB0 define const int MAXN = 5000 + 7, DELTA = 1000 * 1000 * 1000 + 7 ;  $  TAB0 declare long long array of array numberOfPartialAns, size MAXN x MAXN ;  $  TAB0 declare string s, t ;  $  TAB1 read s, t ;  $  TAB1 for i = 1 to size of s cast to int inclusive ;  $  TAB2 for j = 1 to size of t cast to int inclusive ;  $  TAB3 set numberOfPartialAns[i][j] to numberOfPartialAns[i][j - 1] ;  $  TAB3 if s[i - 1] equals t[j - 1] ;  $  TAB4 increase numberOfPartialAns[i][j] by numberOfPartialAns[i - 1][j - 1] ;  $  TAB4 set numberOfPartialAns[i][j] to numberOfPartialAns[i][j] mod DELTA ;  $  TAB4 increment numberOfPartialAns[i][j] ;  $  TAB4 set numberOfPartialAns[i][j] to numberOfPartialAns[i][j] mod DELTA ;  $  TAB1 define long long ans = 0 ;  $  TAB1 for i = 1 to size of s cast to int inclusive ;  $  TAB2 increase ans numberOfPartialAns[i][(int)t.size()] ;  $  TAB2 set ans to ans mod DELTA ;  $  TAB1 print ans ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 if n is 0 do the following ;  $  TAB2 print 1 ;  $  TAB1 let s = integer with value = integer cast of round down of n / long double cast of sqrt(2.0) ;  $  TAB1 let s = integer with value = integer cast of round down of n / (long double cast of sqrt(2.0)) + 1 ;  $  TAB1 if s * s + t * t is greater than n *n do the following ;  $  TAB2 print 8 * s ;  $  TAB1 else ;  $  TAB2 print 8 * s + 4 ;
TAB0 declare integer array t and l, both of size 100005 ;  $  TAB1 declare integer n, L, a ;  $  TAB1 read n, L, a ;  $  TAB1 read n values into t and l ;  $  TAB1 define integer ans = 0 ;  $  TAB1 for i = 1 to n exclusive do add (t[i] - t[i - 1] - l[i - 1]) / a to ans ;  $  TAB1 if n ;  $  TAB2 increase ans by t[0] / a ;  $  TAB2 increase ans by (L - t[n - 1] - l[n - 1]) / a ;  $  TAB1 else ;  $  TAB2 set ans to L / a ;  $  TAB1 print ans ;
TAB1 let t, x, y be long long integer ;  $  TAB1 read t ;  $  TAB1 let arr and ans be arrays of long long integer of size t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 let a, b, k be long long int ;  $  TAB2 read a, b, k ;  $  TAB2 if k is even ;  $  TAB3 set x to k / 2 and y to k / 2 ;  $  TAB2 else ;  $  TAB3 set x = (k/2) + 1 ;  $  TAB3 set y to k / 2 ;  $  TAB2 set ans[i] to a * x - b * y ;  $  TAB1 for i = 0 to t exclusive, print out ans[i] with newline ;
TAB1 t, s, q are integers ;  $  TAB1 read t, s, q ;  $  TAB1 ans = integer = 0 ;  $  TAB1 while s is less than t ;  $  TAB2 increment ans ;  $  TAB2 multiply s by q ;  $  TAB1 output ans ;
TAB0 let a = array if integers with size = 100050 and values = 0 ;  $  TAB1 let p, res, ui = integers with values = 0 ;  $  TAB1 let T = integer ;  $  TAB1 read T ;  $  TAB1 while (decrement T) is true read a[increment p] ;  $  TAB1 call sort on a and a + p ;  $  TAB1 for integer i =0 to p-1 inclusive do the following ;  $  TAB2 for integer k= ui to p-1 inclusive ;  $  TAB3 if a[ui] is less than or equal to a[i] ;  $  TAB4 increment ui ;  $  TAB3 else ;  $  TAB4 exit the loop ;  $  TAB2 if ui is less than p increment res and increment ui ;  $  TAB1 print res ;
TAB0 create const int N = 1e5 + 50 ;  $  TAB0 create const int oo = 1e9 ;  $  TAB0 create const int mod = 1e9 + 7 ;  $  TAB0 create string arrays a of size 2001, b of size 201, f1 of size 2001, and f2 of size 2001 ;  $  TAB1 create ints n, m ;  $  TAB1 read n, m ;  $  TAB1 read n values into a ;  $  TAB1 read n values into b ;  $  TAB1 for i = 0 while i + m is less than or equal to n ;  $  TAB2 set f1[i] to "" ;  $  TAB2 for j = 0 to m exclusive do increase f1[i] by a[i + j] ;  $  TAB1 for i = 0 while i + m less than or equal to n ;  $  TAB2 set f2[i] to "" ;  $  TAB2 for j = 0 to m exclusive do increase f2[i] by b[j].substr(i, m) ;  $  TAB1 for i = 0 while i + m is less than or equal to n ;  $  TAB2 for j = 0 while j + m is less than or equal to n ;  $  TAB3 if f1[i] equals f2[j] ;  $  TAB4 print i + 1, " ", j + 1 ;
TAB1 let f, g, m, n = integers with f = 0 g = 0 ;  $  TAB1 read m ;  $  TAB1 read n ;  $  TAB1 for integer i=1 to m inclusive do the following ;  $  TAB2 for integer j=1 to n inclusive do the following ;  $  TAB3 if i is odd ;  $  TAB4 print # ;  $  TAB3 else do the following ;  $  TAB4 if j is 1 and f is 1 do the following ;  $  TAB5 print # ;  $  TAB5 set f = 0 ;  $  TAB5 set g = 1 ;  $  TAB4 else if j is n and f is 0 and g is 0 do the following ;  $  TAB5 print # ;  $  TAB5 set f = 1 ;  $  TAB4 else ;  $  TAB5 print . ;  $  TAB2 print a new line ;  $  TAB2 set g = 0 ;
TAB1 let n, m, max, idx = integers with max = -1 ;  $  TAB1 let x = float ;  $  TAB1 read n, m ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read x ;  $  TAB2 set x = round up of x / m ;  $  TAB2 if x is greater than or equal to max do the following ;  $  TAB3 set max = x ;  $  TAB3 set idx = i ;  $  TAB1 print idx + 1 ;
TAB1 s= string ;  $  TAB1 x,sum= integers with sum=0 ;  $  TAB1 read x ;  $  TAB1 for i=0 to x exclusive ;  $  TAB2 read s ;  $  TAB2 if s is equal to Tetrahedron ;  $  TAB3 set sum to sum+4 ;  $  TAB2 else if s = Cube ;  $  TAB3 set sum = sum+4 ;  $  TAB2 elese if s = Octahedron ;  $  TAB3 set sum = sum+8 ;  $  TAB2 else if s is equal to Dodecahedron ;  $  TAB3 set sum = sum + 12 ;  $  TAB2 else if s = Icosahedron ;  $  TAB3 set sum = sum + 20 ;  $  TAB1 print sum ;
TAB0 let M be map of long long to long long ;  $  TAB0 define update which takes long long u, v, w ;  $  TAB1 while u is not equal to v ;  $  TAB2 if v is less than u, call swap of u, v ;  $  TAB2 update M[v] to M[v] + w ;  $  TAB2 update v to v/2 ;  $  TAB0 define solve which takes long long u, v as arguments and returns long long ;  $  TAB1 let res be long long with res = 0 ;  $  TAB1 while u is not equal to v ;  $  TAB2 if v is less than u, call swap of u, v ;  $  TAB2 increment res by M[v] ;  $  TAB2 update v to v/2 ;  $  TAB1 return res ;  $  TAB1 let u, v, w, q, t be long long ;  $  TAB1 read q ;  $  TAB1 while input available, read t, u, v and decrement q ;  $  TAB2 if t is equal to 2 ;  $  TAB3 print out solve of u, v ;  $  TAB2 else ;  $  TAB3 read w and call update of u, v, w ;
TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 if n mod 2 ;  $  TAB2 print (n + 1) / 2 - 1 ;  $  TAB1 else ;  $  TAB2 print (n ^ (1 << (31 - __builtin_clz(n)))) / 2 ;
TAB0 p, ans are long long vectors ;  $  TAB1 t, s, q are long longs ;  $  TAB1 read t, s, q ;  $  TAB1 ans = long long = 1 ;  $  TAB1 time = long long = 0 ;  $  TAB1 loaded = long long = s ;  $  TAB1 while true ;  $  TAB2 add q to time ;  $  TAB2 add q - 1 to loaded ;  $  TAB2 if time is at least t, break ;  $  TAB2 if time equals loaded ;  $  TAB3 set time to 0 ;  $  TAB3 increment ans ;  $  TAB1 output ans ;
TAB0 let constant double pi = 3.14159265359 ;  $  TAB0 let constant double eps = 1e-9 ;  $  TAB0 let constant int mod = 1e9 + 7 ;  $  TAB0 let constant int mod1 = 1e9 + 9 ;  $  TAB0 let constant int INF = 1e9 ;  $  TAB0 let constant long long INFLL = 2e18 ;  $  TAB0 in function sqr with return type long long and parameter long long a ;  $  TAB1 return a^2 ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 let long long start = 2 ;  $  TAB1 for i = 1 to n + 1 exclusive ;  $  TAB2 print i * sqr(i + 1) - start / i ;  $  TAB2 set start to i * (i + 1) ;
TAB1 n = integer ;  $  TAB1 c = array of chars, size 95 ;  $  TAB1 while (read n)is true, do the following ;  $  TAB2 set integer sum1 to 0 ;  $  TAB2 for i=0 to n-1 inclusive read c[i] ;  $  TAB2 for i=0 ot n-1 inclusive, do the following ;  $  TAB3 if c[i] is 1 ;  $  TAB4 increment sum1 ;  $  TAB3 else do the following ;  $  TAB4 print sum1 ;  $  TAB4 sum1 = 0 ;  $  TAB2 print sum1 ;
TAB0 arr= array of imteger of size of 120 ;  $  TAB1 create integer n and ans with ans=0 ;  $  TAB1 read n ;  $  TAB1 read n value into array of arr ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create an integer now with now=0 ;  $  TAB2 for int j=0 to i inclusive ;  $  TAB3 if arr[j] is not true then increment now ;  $  TAB2 for j=1 to n exclusive ;  $  TAB3 if arr[j] is true then increment now ;  $  TAB2 set ans to max of ans and now ;  $  TAB1 print ans ;
TAB1 make int a, b, i, j ;  $  TAB1 read a, b ;  $  TAB1 make dynamically allocated array arr of size 10000 ;  $  TAB1 make dynamically allocated array brr of size 10000 ;  $  TAB1 read a values into arr ;  $  TAB1 read a values into brr ;  $  TAB1 if arr[0] is equal to 0 ;  $  TAB2 print "NO" ;  $  TAB1 if arr[b - 1] is equal to 1 ;  $  TAB2 print "YES" ;  $  TAB1 for i = b - 1 to a - 1 inclusive ;  $  TAB2 if arr[i] equals 1 AND brr[i] equals 1 and brr[b - 1] equals 1 ;  $  TAB3 print "YES" ;  $  TAB1 print "NO" ;
TAB0 declare int N, A, sum, a, b, c, d ;  $  TAB1 read N ;  $  TAB1 set b to 3 ;  $  TAB1 for i = 1 to N inclusive ;  $  TAB2 read a ;  $  TAB2 if b is a ;  $  TAB3 print "NO\n" ;  $  TAB2 set b to 6 - a - b ;  $  TAB1 print "YES\n" ;
TAB0 create const integer MAXN = 105 ;  $  TAB0 create integer n ;  $  TAB0 create integer array a of size MAXN ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive: read a[i] ;  $  TAB1 sort a to a + n ;  $  TAB1 set n to unique(a, a + n) - a ;  $  TAB1 if a[0] print n, else print n - 1 ;
TAB1 n, l, i, d, e are long long integers with d = 0 ;  $  TAB1 s is a character array of size 200000 ;  $  TAB1 input n ;  $  TAB1 a is a string ;  $  TAB1 input a ;  $  TAB1 set l to the length of a ;  $  TAB1 for i = 0 to 1 exclusive ;  $  TAB2 if a[i] is the character 1, increment d ;  $  TAB1 set e to l - d ;  $  TAB1 display absolute value of (d - e) ;
TAB1 n,k,start =integer ;  $  TAB1 string = slogan ;  $  TAB1 read n,k,slogan ;  $  TAB1 if 2*k<=n or k=1 ;  $  TAB2 set start =0 ;  $  TAB1 else do the following ;  $  TAB2 set start =length of slogan ;  $  TAB1 if start=0 ;  $  TAB2 for i =k-1 to 0 then print Left ;  $  TAB2 for i = 0 to n inclusive ;  $  TAB3 print PRINT, slogal[i] ;  $  TAB3 if i is not equal to n-1 then print RIGHT ;  $  TAB1 else do the following ;  $  TAB2 for i=k to n exclusive then print RIGHT ;  $  TAB2 for i=n-1 to 0 inclusive ;  $  TAB3 print PRINT, slogal[i] ;  $  TAB3 if i is not equal to 0 then print LEFT ;
TAB1 let len = integer ;  $  TAB1 let str = string ;  $  TAB1 read len ;  $  TAB1 read str ;  $  TAB1 if len is 1 do the following ;  $  TAB2 if str[0] is 1 ;  $  TAB3 write Yes and new line to stdout ;  $  TAB2 else ;  $  TAB3 write No and new line to stdout ;  $  TAB1 for integer i=1 to len exclusive do the following ;  $  TAB2 if str[i] is str[i - 1] and str[i] is 1 ;  $  TAB3 write No and new line to stdout ;  $  TAB1 for integer i=2 to len exclusive do the following ;  $  TAB2 if str[i] is str[i - 1] and str[i - 1] is str[i - 2] and str[i] is 0 ;  $  TAB3 write No and new line to stdout ;  $  TAB1 if str[0] is str[1] and str[0] is 0 ;  $  TAB2 write No and new line to stdout ;  $  TAB1 if str[len -1 1] is str[len - 2] and str[len - 1] is 0 ;  $  TAB2 write No and new line to stdout ;  $  TAB1 write Yes and new line to stdout ;
TAB0 create const int N = 1e6 + 6 ;  $  TAB0 create int array a of size N ;  $  TAB1 create int n, b, d, cnt, sum ;  $  TAB1 while reading n, b, and d is not interrupted ;  $  TAB2 set sum to 0 ;  $  TAB2 set cnt to 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a[i] ;  $  TAB3 if a[i] is less than or equal to b, increase sum by a[i] ;  $  TAB3 if sum is greater than d ;  $  TAB4 set sum to 0 ;  $  TAB4 increment cnt ;  $  TAB2 print cnt ;
TAB1 let fact be boolean with fact = true ;  $  TAB1 let i, j, n be long long ;  $  TAB1 let fs, sc be char and a be array of char of size 305 by 305 ;  $  TAB1 while input available, read n ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 for j = 0 to n exclusive, read a[i][j] ;  $  TAB2 set fs = a[0][0] ;  $  TAB2 set sc = a[0][1] ;  $  TAB2 if fs == sc ;  $  TAB3 print NO ;  $  TAB2 for i = 0 to till i < n and fact ;  $  TAB3 for j = 0 to till j < n and fact ;  $  TAB4 if i == j and a[i][j] != fs ;  $  TAB5 print NO ;  $  TAB5 set fact to false ;  $  TAB5 break ;  $  TAB4 else if j == (n-i-1) and a[i][n-i-1] != fs ;  $  TAB5 print NO ;  $  TAB5 set fact to false ;  $  TAB5 break ;  $  TAB4 else if j != (n-i-1) and i != j and a[i][j] != sc ;  $  TAB5 print NO ;  $  TAB5 set fact to false ;  $  TAB5 break ;  $  TAB1 M: ;  $  TAB2 if fact is true, print YES ;
TAB0 n, m, ans are integers with ans = 1e9 ;  $  TAB0 qs is an integer array of sizes 5005 and 5005 ;  $  TAB0 s = string ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read s ;  $  TAB2 for j = 1 to m inclusive, set qs[i][j] to (s[j - 1] is equal to the character 1) ;  $  TAB1 for i = 1 to 2 * call max with n, m inclusive ;  $  TAB2 for j = 1 to 2 * call max with n, m inclusive, add qs[i - 1][j] + qs[i][j - 1] - qs[i - 1][j - 1] to qs[i][j] ;  $  TAB1 for k = 2 to call max with n, m inclusive ;  $  TAB2 cnt = integer = 0 ;  $  TAB2 for i = 0 to n exclusive with increment i + k ;  $  TAB3 for j = 0 to m exclusive with increment i + k ;  $  TAB4 one = integer = qs[i + k][j + k] - qs[i][j + k] - qs[i + k][j] + qs[i][j] ;  $  TAB4 zero = integer = k * k - one ;  $  TAB4 add call min with one, zero to cnt ;  $  TAB2 set ans to call min with ans, cnt ;  $  TAB1 output ans ;
TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 pos=integer ;  $  TAB1 for i=0 to size of s exclusive ;  $  TAB2 if s[i] is '=' then set pos to i ;  $  TAB1 create integers c1 and c2 with values 0 ;  $  TAB1 for i=0 to pos exclusive ;  $  TAB2 if s[i] is '|' then increment c1 ;  $  TAB1 for i=pos to size of s exclusive ;  $  TAB2 if s[i]= '|' then add 1 to c2 ;  $  TAB1 if c1 is equal to c2 ;  $  TAB2 print s ;  $  TAB1 else do the following ;  $  TAB2 if c1=c2+2 ;  $  TAB3 if s[1] is not equal to + ;  $  TAB4 for i=1 to size of s exclusive print s[i] ;  $  TAB4 print | and a newline ;  $  TAB3 else do the following ;  $  TAB4 for i=0 to size of s exclusive ;  $  TAB5 if i is not equal to 2 then print s[i] ;  $  TAB4 print | ;  $  TAB2 else if c1+c2 = c2 then ;  $  TAB3 print | ;  $  TAB3 for i=0 to size of s-1 exclusive print s[i] ;  $  TAB3 print new line ;  $  TAB2 else do the following ;  $  TAB3 print Impossible ;
TAB1 for i, j, k, m, n, k1, k3 = integers with k1 = 0, k2 = 0, k3 = 0 and a = array of integers size = 1004005 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read a[i] ;  $  TAB2 if a[i] is 1 increment k1 ;  $  TAB2 if a[i] is 2 increment k2 ;  $  TAB2 if a[i] is 3 increment k3 ;  $  TAB1 print min of (min of k1 +k2 and k1 + k3) and k2 + k3 ;
TAB0 arr = array of long long of length 500000 ;  $  TAB1 n,l,r,ql,qr = long long ;  $  TAB1 read n, l, r, ql, qr ;  $  TAB1 for long long i = 1 to n inclusive do the following ;  $  TAB2 x = long long ;  $  TAB2 read x ;  $  TAB2 arr[i] = x ;  $  TAB1 lft, rgt = long long vectors ;  $  TAB1 append 0 to lft ;  $  TAB1 append 0 to rgt ;  $  TAB1 for long long i = 1 to n inclusive do the following ;  $  TAB2 x = arr[i] * l ;  $  TAB2 append lft[size of lft -1] + x to lft ;  $  TAB1 for long long i = n to 1 inclusive decrementing by 1, do the following ;  $  TAB2 x = long long et x = arr[i] * r ;  $  TAB2 append rgt[size of rgt -1] + x to rgt ;  $  TAB1 ans = long long set ans to 1000000000 ;  $  TAB1 for i = 0 to n inclusive do the following ;  $  TAB2 let penalty be long long with penalty = absolute(i-(n-i)) ;  $  TAB2 set penalty = maximum of penalty -1 and long long 0 ;  $  TAB2 let keep be long long with keep = lft[i] + rgt[n-1] ;  $  TAB2 if i is greater than n-1 do the following ;  $  TAB3 keep = keep + (penalty * qr) ;  $  TAB2 else do the following ;  $  TAB3 keep = keep + (penalty * qr) ;  $  TAB2 set ans = minimum of ans and keep ;  $  TAB1 print ans ;
TAB1 n, x are integers ;  $  TAB1 input n ;  $  TAB1 iterate n times ;  $  TAB2 input x ;  $  TAB2 output YES if 360 mod (180 - x) equals 0, otherwise output NO ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 if n is 2 do the following ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create long long x1, y1, x2, y2 ;  $  TAB1 read x1, y1, x2, and y2 ;  $  TAB1 create long long Q = 1 ;  $  TAB1 create long long x1p = x2 - x1 ;  $  TAB1 create long long y1p = y2 - y1 ;  $  TAB1 for i = 0 to Q exclusive ;  $  TAB2 create long long qx1, qy1 ;  $  TAB2 read qx1 and qy1 ;  $  TAB2 create long long dx = qx1 - x1 ;  $  TAB2 create long long dy = qy1 - y1 ;  $  TAB2 create long long res = x1p * dy - dx * y1p ;  $  TAB2 if res greater than 0 ;  $  TAB3 print "LEFT\n" ;  $  TAB2 else if res equals 0 ;  $  TAB3 print "TOWARDS\n" ;  $  TAB2 else if res less than 0 ;  $  TAB3 print "RIGHT\n" ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 sum1, sum2 are integers both set to 0 ;  $  TAB1 for t = 0 to n exclusive ;  $  TAB2 x, y are integers ;  $  TAB2 read x, y ;  $  TAB2 if x is positive, increment sum1 ;  $  TAB2 if x is negative, increment sum2 ;  $  TAB1 if n equals 1 ;  $  TAB2 print Yes ;  $  TAB1 if (sum1 is at most 1 and sum2 is at least 1) or (sum1 is at least 1 and sum2 is at most 1) ;  $  TAB2 print Yes ;  $  TAB1 else ;  $  TAB2 print No ;
TAB0 let ma be map from pair of long long, long long to long lon ;  $  TAB0 let it be iterator of map from pair of long long, long long to long lon ;  $  TAB0 let q, t be integers ;  $  TAB0 let x, y, z, temp be long long ;  $  TAB0 let ans be long long ;  $  TAB1 read q ;  $  TAB1 while q is not zero, decrement q ;  $  TAB2 read t ;  $  TAB2 if t == 1 ;  $  TAB3 read z, y, x ;  $  TAB3 while z != y ;  $  TAB4 if z < y ;  $  TAB5 set temp to y, shift y right by 1 bit and increment ma[make_pair of temp, y] by x ;  $  TAB4 else ;  $  TAB5 set temp to x, shift z right by 1 bit and increment ma[make_pair of temp, z] by x ;  $  TAB2 else ;  $  TAB3 read z, y ;  $  TAB3 set ans to 0 ;  $  TAB3 while z != y ;  $  TAB4 if z is less than y ;  $  TAB5 set temp to y ;  $  TAB5 shift y to right by 1 bit ;  $  TAB5 set it to find of ma with make_pair of temp, y ;  $  TAB5 if it != end of ma, increment ans by it->second ;  $  TAB4 else ;  $  TAB5 set temp to z ;  $  TAB5 shift z to right by 1 bit ;  $  TAB5 set it to find of ma with make_pair of temp, z ;  $  TAB5 if it != end of ma, increment ans by it->second ;  $  TAB3 print ans ;
TAB1 make integers n and i ;  $  TAB1 read n ;  $  TAB1 if n less than or equals 10 or n greater than or equals 22 ;  $  TAB2 print '0' ;  $  TAB1 else if n equals 20 ;  $  TAB2 print "15" ;  $  TAB1 else ;  $  TAB2 print '4' ;
TAB0 create anonymous enum with values { C, CS, D, DS, E, F, FS, G, GS, A, B, H } ;  $  TAB0 in function FazInt with return type of int and constant string reference s as parameter ;  $  TAB1 if s is "C" return C ;  $  TAB1 if s is "C#" return CS ;  $  TAB1 if s is "D" return D ;  $  TAB1 if s is "D#" return DS ;  $  TAB1 if s is "E" return E ;  $  TAB1 if s is "F" return F ;  $  TAB1 if s is "F#" return FS ;  $  TAB1 if s is "G" return G ;  $  TAB1 if s is "G#" return GS ;  $  TAB1 if s is "A" return A ;  $  TAB1 if s is "B" return B ;  $  TAB1 if s is "H" return H ;  $  TAB0 in function Dist returning int and taking const int references a and b ;  $  TAB1 if b less than a then return 12 + (b - a) ;  $  TAB1 return b - a ;  $  TAB0 in function IsMajor that is returning bool and taking const int references a, b, and c ;  $  TAB1 return (Dist(a, b) is 4 and Dist(b, c) is 3) ;  $  TAB0 in function IsMinor that is returning bool and taking const int references a, b, and c ;  $  TAB1 return (Dist(a, b) is 3 and Dist(b, c) is 4) ;  $  TAB1 create string s ;  $  TAB1 create int array notes of length 3 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 read s ;  $  TAB2 set notes[i] to FazInt of s ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 if IsMajor(notes[0], notes[1], notes[2]) ;  $  TAB3 print "major\n" ;  $  TAB2 if IsMinor(notes[0], notes[1], notes[2]) ;  $  TAB3 print "minor\n" ;  $  TAB2 next_permutation(&notes[0], &notes[3]) ;  $  TAB1 print "strange\n" ;
TAB1 let n1, n2, k1, k2 be integers ;  $  TAB1 read n1, n2, k1, and k2 ;  $  TAB1 if n1 is greater than n2 ;  $  TAB2 display First ;  $  TAB1 else ;  $  TAB2 display Second ;
TAB1 create int t, s, x, i ;  $  TAB1 read t, s, x ;  $  TAB1 if x >= t and (x - t) mod s equals 0 or x > t + 1 and (x - t - 1) mod s equals 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 n and ans are integers, h and l are integer arrays both of soze 101 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 declare a character c ;  $  TAB3 input c ;  $  TAB3 if c is the character C, add h[i] + 1 to ans, add l[j] + 1 to ans ;  $  TAB1 output ans ;
TAB1 let n, i, j, x, z, y, s, p, q, r be integers with x = 0, z = 0, y = 0, s = 99999, p = q = r = 0 ;  $  TAB1 read n ;  $  TAB1 let a, a1, a2, a3 be array of integers of size n ;  $  TAB1 for i = 0 to n, read a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is equal to 1 ;  $  TAB3 increment x ;  $  TAB3 set a1[p] to i + 1 ;  $  TAB3 increment p ;  $  TAB2 else if a[i] is equal to 2 ;  $  TAB3 increment y ;  $  TAB3 set a2[q] to i+1 ;  $  TAB3 increment q ;  $  TAB2 else ;  $  TAB3 increment z ;  $  TAB3 set a3[r] to i+1 ;  $  TAB3 increment r ;  $  TAB1 if x is less than s, set s to x ;  $  TAB1 if y is less than s, set s to y ;  $  TAB1 if z is less than s, set s to z ;  $  TAB1 print s ;  $  TAB1 for b = 0 to s exclusive, print a1[b], " ", a2[b], " ", a3[b] ;
TAB1 make int q ;  $  TAB1 read q ;  $  TAB1 while q decremented ;  $  TAB2 make int a ;  $  TAB2 read a ;  $  TAB2 if 360 mod (180 - a) is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 le v be a vector of integers ;  $  TAB1 let t, k be integers ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 read k ;  $  TAB2 append k to the end of v ;  $  TAB1 set k to first element of v ;  $  TAB1 let l be integer with l = size of v ;  $  TAB1 if l is equal to 1 and v[0] is not equal to 15 and 0 ;  $  TAB2 print -1 with newline ;  $  TAB1 if element of v at index l-1 is equal to 15 ;  $  TAB2 print DOWN with newline ;  $  TAB1 if element of v at index l-1 is equal to 0 ;  $  TAB2 print UP with newline ;  $  TAB1 if element of v at index l-1 is equal to element of v at index l-2 ;  $  TAB2 print DOWN with newline ;  $  TAB1 else ;  $  TAB2 print UP with newline ;
TAB1 n, m, s, i, x, y are integers with s = 0 ;  $  TAB1 input x, n, m ;  $  TAB1 assign n * 60 + m to s ;  $  TAB1 for i = 0 with no condition with increment i ;  $  TAB2 set y to s mod 60 ;  $  TAB2 h is an integer set to s / 60 ;  $  TAB2 if h / 10 is 7 or h mod 10 is 7 or y / 10 is 7 or y mod 10 is 7 ;  $  TAB3 display i ;  $  TAB2 assign (s - x + 1440) mod 1440 to s ;
TAB1 n = integer, t = integer array of length 101 ;  $  TAB1 while input n ;  $  TAB2 read n values into array t ;  $  TAB2 call sort with t, t + n ;  $  TAB2 display t[n - 1] ;  $  TAB2 for i = 1 to n - 1 exclusive, display " ", t[i] ;  $  TAB2 display " ", t[0] ;
TAB1 n = m = k = long long ;  $  TAB1 read n, m, k ;  $  TAB1 let be vector of long long ;  $  TAB1 for long long i = 0 to n exclusive ;  $  TAB2 let x be long long ;  $  TAB2 read x ;  $  TAB2 push x to back of v ;  $  TAB1 sort v in reverse order ;  $  TAB1 if m is less than or equal to k ;  $  TAB2 print out 0 ;  $  TAB1 else ;  $  TAB2 let keep be long long with keep = k ;  $  TAB2 for long long i = 0 to v.size() exclusive ;  $  TAB3 increment keep by v[i] ;  $  TAB3 decrement keep ;  $  TAB3 if keep is greater than or equal to m ;  $  TAB4 print i+1 ;  $  TAB2 print -1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int j = n + 1 ;  $  TAB1 create int ans = max of 1 and (n * sqrt(2)) * 4 cast to int ;  $  TAB1 print ans ;
TAB0 inf is a constant integer set to 1000000000 ;  $  TAB0 MOD is a constant integer set to 1000000007 ;  $  TAB0 dp and sum are both integer arrays of size 1000001 each ;  $  TAB1 declare an integer n ;  $  TAB1 input n ;  $  TAB1 odd, even, ans are integers with odd and even both set to 0, ans = 1 ;  $  TAB1 assign 1 to dp[1] ;  $  TAB1 assign 1 to odd ;  $  TAB1 assign 0 to even ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 assign 1 + i / 2 to dp[i] ;  $  TAB2 if i is divisible by 2 ;  $  TAB3 set dp[i] to (dp[i] + even) modulo MOD ;  $  TAB2 else ;  $  TAB3 set dp[i] to (dp[i] + odd) modulo MOD ;  $  TAB2 set dp[i] to (dp[i] + dp[i - 2]) modulo MOD ;  $  TAB2 if i is divisible by 2 ;  $  TAB3 set even to (even + dp[i]) modulo MOD ;  $  TAB2 else ;  $  TAB3 set odd to (odd + dp[i]) modulo MOD ;  $  TAB2 set ans to (0LL + ans + dp[i] - (dp[i - 2]) + MOD) modulo MOD ;  $  TAB1 display ans ;
TAB0 create char array str and str1 of size 8 and 20 respectively ;  $  TAB0 flag=integer and ans=integer array of size 10 ;  $  TAB1 for i=0 to 8 exclusive ;  $  TAB2 read str ;  $  TAB2 for j=0 to 8 exclusive set str1[j] = str[j] and str[j + 8] = str[j ;  $  TAB2 for k=0 to 8 exclusive ;  $  TAB3 for p=k to k+7 exclusive ;  $  TAB4 if str1[p] is not equal to str[p + 1] then increment flag ;  $  TAB3 if flag=7 ;  $  TAB4 set ans[i]=1 ;  $  TAB4 set flag=0 ;  $  TAB4 continue ;  $  TAB1 for y=0 to 8 exclusive ;  $  TAB2 if ans[y] is not equal to 1 ;  $  TAB3 print NO ;  $  TAB1 print YES ;
TAB1 create long long integer n,d,i ;  $  TAB1 read n and d ;  $  TAB1 create long long integer count=0 and m=10001 and array a of size n ;  $  TAB1 read n values into the array a ;  $  TAB1 sort array a ;  $  TAB1 create long long integer index1, j and index2 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set count to 0 ;  $  TAB2 for j=n-1 to i exclusive ;  $  TAB3 if abs(a[j] - a[i]) > d then increment count ;  $  TAB2 set m to minimum of count + i and m ;  $  TAB1 print m and a new line ;
TAB1 create long long integers i and n ;  $  TAB1 read n ;  $  TAB1 if n equals 1 ;  $  TAB2 print 1 ;  $  TAB1 else if n equals 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 a, b, c, d, i, j are all integers with i and j both set to 0 ;  $  TAB1 read a, b, c, d ;  $  TAB1 while i is less than 10000 ;  $  TAB2 increment i ;  $  TAB2 if d is greater than b ;  $  TAB3 add a to b ;  $  TAB2 else if d is less than b ;  $  TAB3 add c to d ;  $  TAB2 else if d is b ;  $  TAB3 display d ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 display -1 ;
TAB0 let nn = array of integers size 100 ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let ans = integer with value = 1 ;  $  TAB1 let x, y, num = integers with num = 1 ;  $  TAB1 read x ;  $  TAB1 for intger i = 1 to n exclusive do the following ;  $  TAB2 read y ;  $  TAB2 if y is greater than or equal to x do the following ;  $  TAB3 increment num ;  $  TAB3 set ans = max of ans and num ;  $  TAB3 set x = y ;  $  TAB2 else do the following ;  $  TAB3 set num = 1 ;  $  TAB3 set x = y ;  $  TAB1 print ans ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer faces = 0 ;  $  TAB1 while n decremented ;  $  TAB2 create string s ;  $  TAB2 read s ;  $  TAB2 if s is "Cube" ;  $  TAB3 increase faces by 6 ;  $  TAB2 else if s is "Tetrahedron" ;  $  TAB3 increase faces by 4 ;  $  TAB2 else if s is "Octahedron" ;  $  TAB3 increase faces by 8 ;  $  TAB2 else if s is "Dodecahedron" ;  $  TAB3 increase faces by 12 ;  $  TAB2 else ;  $  TAB3 increase faces by 20 ;  $  TAB1 print faces ;
TAB1 make character array s of size 100005 ;  $  TAB1 make integer j = 0 ;  $  TAB1 read s ;  $  TAB1 while s[j] equals 'a', increment j ;  $  TAB1 if s[j] equals '\0' ;  $  TAB2 set s[j - 1] to 'z' ;  $  TAB2 print s ;  $  TAB1 for int i = j; s[i] is not equal to 'a' and s[i] is not equal to '\0'; increment i do decrement s[i] ;  $  TAB1 print s ;
TAB0 in function gcd with parameters long long a, long long b and return long long ;  $  TAB1 if b equals 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return call gcd with b, a modulo b ;  $  TAB1 a, b are long longs ;  $  TAB1 input a, b ;  $  TAB1 hcf is a long long ;  $  TAB1 if a is greater than b ;  $  TAB2 set hcf to call gcd with a, b ;  $  TAB1 else ;  $  TAB2 set hcf to call gcd with b, a ;  $  TAB1 product = long long = a * b ;  $  TAB1 lcm = long long = product / hcf ;  $  TAB1 a1 = long long = lcm / a ;  $  TAB1 b1 = long long = lcm / b ;  $  TAB1 if absolute value (a1 - b1) equals 1 ;  $  TAB2 display Equal ;  $  TAB1 else if a1 - b1 is greater than 1 ;  $  TAB2 display Dasha ;  $  TAB1 else ;  $  TAB2 display Masha ;
TAB0 in the function isprime which takes a long long integer x and returns an integer ;  $  TAB1 create a long long integer fact=0 ;  $  TAB1 for i=2 to square root of x inclusive ;  $  TAB2 if x mod i=0 ;  $  TAB3 increment fact ;  $  TAB3 break ;  $  TAB1 if fact=0 ;  $  TAB2 return i ;  $  TAB1 else do the following ;  $  TAB1 t=long long integer ;  $  TAB1 read t ;  $  TAB1 for i=1 to 1000 inclusive ;  $  TAB2 if isprime(t * i + 1) = 0 ;  $  TAB3 print i ;  $  TAB3 break ;
TAB1 v = integer ;  $  TAB1 read v ;  $  TAB1 if v is not equal to 2 ;  $  TAB2 print 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print 2 and a new line ;
TAB1 t=integer ;  $  TAB1 x,y= integers ;  $  TAB1 create integer c=0 ;  $  TAB1 read t ;  $  TAB1 for i=0 to t exclusive ;  $  TAB2 read x and y ;  $  TAB2 if y-x >=2 then increment c ;  $  TAB1 print c ;
TAB0 ar is an integer array of sizes 1005 and1005 ;  $  TAB1 declare integers n, m, k, x, y ;  $  TAB1 read n, m, and k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 read x and y ;  $  TAB2 assign 1 to ar[x][y] ;  $  TAB2 if ar[x - 1][y] and ar[x][y - 1] and ar[x - 1][y - 1] ;  $  TAB3 display i + 1 ;  $  TAB2 else if ar[x - 1][y] and ar[x][y + 1] and ar[x - 1][y + 1] ;  $  TAB3 display i + 1 ;  $  TAB2 else if ar[x + 1][y] and ar[x][y - 1] and ar[x + 1][y - 1] ;  $  TAB3 display i + 1 ;  $  TAB2 else if ar[x + 1][y] and ar[x][y + 1] and ar[x + 1][y + 1] ;  $  TAB3 display i + 1 ;  $  TAB1 display 0 ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 for j = 0 to n exclusive ;  $  TAB2 let a be a double ;  $  TAB2 input a ;  $  TAB2 let y be a boolean with y = false ;  $  TAB2 let h be a double with h = (360) / (180 - a) ;  $  TAB2 if h equals integer value of h ;  $  TAB3 output YES ;  $  TAB2 else ;  $  TAB3 output NO ;
TAB1 set n,v,u,val,ans,av,red = integers with values of val,ans,av,red = 0 and arr,temp = arrays of integers size 26 and values 0 ;  $  TAB1 set au,ansa = character and ch = array of characters size 100001 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read au, ch ;  $  TAB2 if red is less than 25 do the following ;  $  TAB3 if au is . do the following ;  $  TAB4 set v = length of ch ;  $  TAB4 forj=0 to v exclusive do the following ;  $  TAB5 set u = integer value conversion of ch[j] -a ;  $  TAB5 if arr[u] is 1 or arr[u] is 0 do the following ;  $  TAB6 set arr[u] = -1 ;  $  TAB6 increment red ;  $  TAB3 else if au is ! do the following ;  $  TAB4 set v = length of ch ;  $  TAB4 if av is 0 do the following ;  $  TAB5 for j=0 to v exclusive do the following ;  $  TAB6 set u = integer value conversion of ch[j] -a ;  $  TAB6 if arr[u] is 0 set arr[u] = 1 ;  $  TAB5 for k = 0 to 26 exclusive do the following ;  $  TAB6 if arr[k] is 0 do the following ;  $  TAB7 set arr[k] = -1 ;  $  TAB7 increment red ;  $  TAB5 increment av ;  $  TAB4 else do the following ;  $  TAB5 for k=0 to 26 exclusive set temp[k] = 0 ;  $  TAB5 for k=0 to v exclusive do the following ;  $  TAB6 set u = integer value conversion of ch[k] -a ;  $  TAB6 set temp[u] = 1 ;  $  TAB5 fork=0 to 26 exclusive do the following ;  $  TAB6 if arr[k] is 1 and temp[k] is 0 do the following ;  $  TAB7 set arr[k] =-1 ;  $  TAB7 increment red ;  $  TAB3 else do the following ;  $  TAB4 set u = integer value conversion of ch[0] -a ;  $  TAB4 if arr[u] is 1 or arr[u] is 0 do the following ;  $  TAB5 set arr[u] = -1 ;  $  TAB5 increment red ;  $  TAB3 if red is 25 do the following ;  $  TAB4 for k=0 to 26 exclusive do the following ;  $  TAB5 if arr[k] is not equal to -1 set ansa = character conversion of (97+k) ;  $  TAB2 else if au is ! or au is ? and ch[0] is not equal to ansa ;  $  TAB3 increment ans ;  $  TAB1 print ans ;
TAB1 let c and c1 be ints with c=c1=0 ;  $  TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 create integer l= length of s ;  $  TAB1 for i=0 to l exclusive ;  $  TAB2 if s[i]= static_cast<char>(toupper(s[i]) ;  $  TAB3 increment c ;  $  TAB2 else do the following ;  $  TAB3 increment c1++ ;  $  TAB1 if c>c1 ;  $  TAB2 for i=0 to l exclusive then set s[i] = toupper(s[i]) ;  $  TAB1 if c1>c ;  $  TAB2 for i=0 to l exclusive then set s[i] = tolower(s[i]) ;  $  TAB1 if c1 = c ;  $  TAB2 for i=0 to l exclusive then set s[i] = tolower(s[i]) ;  $  TAB1 print s ;
TAB1 let n, k be integers ;  $  TAB1 input n, k ;  $  TAB1 let c be an integer with c = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let a, s be integers with s = 0 ;  $  TAB2 input a ;  $  TAB2 while a isn't 0 ;  $  TAB3 if a mod 10 equals 7 or a mod 10 equals 4, increment s ;  $  TAB3 divide a by 10 ;  $  TAB2 if s is less than or equal to k, increment c ;  $  TAB1 output c ;
TAB1 n is an integer ;  $  TAB1 s is a string ;  $  TAB1 read n and s ;  $  TAB1 if n equals 1 ;  $  TAB2 display NO ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if s[i] isn't the same as s[i + 1] ;  $  TAB3 display YES ;  $  TAB3 display s[i], s[i + 1] ;  $  TAB1 display NO ;
TAB1 let n, min1, min2, min3, max1, max2, max3 be integers ;  $  TAB1 while read n, min1, max1, min2, max2, min3, and max3 ;  $  TAB2 assign n - (min1 + min2 + min3) to n ;  $  TAB2 if n is at most max1 - min1 ;  $  TAB3 add n to min1 ;  $  TAB2 else ;  $  TAB3 assign n - (max1 - min1) to n ;  $  TAB3 assign max1 to min1 ;  $  TAB3 if n is at most max2 - min2 ;  $  TAB4 add n to min2 ;  $  TAB3 else ;  $  TAB4 assign n - (max2 - min2) to n ;  $  TAB4 assign max2 to min2 ;  $  TAB4 add n to min3 ;  $  TAB2 display min1, " ", min2, " ", min3 ;
TAB1 let n,i,no_of_8, groups be integers with no_of_8=0 ;  $  TAB1 c=char ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read c ;  $  TAB2 if c is 8 then increment no_of_8 ;  $  TAB1 set groups=n/11 ;  $  TAB1 if no_of_8 is greater than or equal to groups ;  $  TAB2 print groups ;  $  TAB1 else do the following ;  $  TAB2 print no_of_8 and new line ;
TAB1 let n be long long int ;  $  TAB1 read n ;  $  TAB1 let sum be long long integer with sum = 0 ;  $  TAB1 update sum to (n/2) * (n/2 + 1) ;  $  TAB1 update sum to sum - ((n - n/2) * (n - n/2)) ;  $  TAB1 print sum with newline ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create int array n of size n, array b of size 4 initialized to 0, array c of size n, array d of size n, array e of size n, l = 0, m = 0, o = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment b[a[i]] ;  $  TAB2 if a[i] is equal to 1 ;  $  TAB3 assign i + 1 to c[l] ;  $  TAB3 increment l ;  $  TAB2 else if a[i] is equal to 2 ;  $  TAB3 assign i + 1 to d[m] ;  $  TAB3 increment m ;  $  TAB2 else ;  $  TAB3 assign i + 1 to e[o] ;  $  TAB3 increment o ;  $  TAB1 sort b ;  $  TAB1 create int w = b[1] ;  $  TAB1 print w ;  $  TAB1 for i = 0 to w exclusive, print c[i] " " d[i] " " e[i] ;
TAB0 s = array of characters set to length of 1000000 ;  $  TAB0 n, m, k, l, a, b, c, def, emp, num = integers with def, emp, and num set to 0. tag = array of integers set to length of 30 ;  $  TAB1 read s, k ;  $  TAB1 if k > length of s or k > 26 ;  $  TAB2 print "impossible" ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 increment tag[s[i] - 'a'] by 1 ;  $  TAB2 if tag[s[i] - 'a'] is 1, increment def by 1 ;  $  TAB1 if def >= k ;  $  TAB2 print "0" ;  $  TAB1 for i = 0 to 25 inclusive ;  $  TAB2 if tag[i] > 1, add tag[i] - 1 to num ;  $  TAB2 if tag[i] is falsey, increment emp by 1 ;  $  TAB1 if num + def < k ;  $  TAB2 print "impossible" ;  $  TAB1 else ;  $  TAB2 print k - def ;
TAB0 let n, k be integers ;  $  TAB0 let s be string ;  $  TAB1 read n, k, s ;  $  TAB1 let idx be integer with idx = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] is equal to G, set idx to i ;  $  TAB1 for i = idx to size of s, increment i by k ;  $  TAB2 if s[i] is equal to # ;  $  TAB3 break ;  $  TAB2 else if s[i] is equal to T ;  $  TAB3 print YES with newline ;  $  TAB1 for i = idx to 0 inclusive, decrement i by k ;  $  TAB2 if s[i] is equal to # ;  $  TAB3 break ;  $  TAB2 else if s[i] is equal to T ;  $  TAB3 print YES with newline ;  $  TAB1 print NO with newline ;
TAB1 let n, x, res be integers with res = 0 and cnt be integer array of size 6 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 increment cnt[x] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 decrement cnt[x] ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if cnt[i] & 1 ;  $  TAB3 print -1 ;  $  TAB4 print newline ;  $  TAB2 increment res by abs of cnt[i] ;  $  TAB1 print res/4 ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create array p of 3 elements = { 1, 2, 3 } ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer x ;  $  TAB2 create integer ind ;  $  TAB2 create integer c = 0 ;  $  TAB2 read x ;  $  TAB2 for i = 0 to 2 exclusive ;  $  TAB3 if x is p[i] ;  $  TAB4 set c to 1 ;  $  TAB4 set ind to i ;  $  TAB4 break ;  $  TAB2 if c ;  $  TAB3 if ind is 1 ;  $  TAB4 swap p[0] and p[2] ;  $  TAB3 else ;  $  TAB4 swap p[1] and p[2] ;  $  TAB2 else ;  $  TAB3 print "NO" ;  $  TAB1 print "YES" ;
TAB1 let a be integer ;  $  TAB1 read a ;  $  TAB1 if a is odd ;  $  TAB2 print 1 ;  $  TAB1 else if a is even ;  $  TAB2 print 0 ;
TAB0 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 print min of a, b + " " + (max of a, b - min of a, b)/2 ;
TAB1 n, mx = integers with mx set to 0 ;  $  TAB1 read n ;  $  TAB1 ara = array of integers with length n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read ara[i] ;  $  TAB2 if ara[i] > mx, set mx to ara[i] ;  $  TAB1 gcd = integer set to ara[0] ;  $  TAB1 for i = 1 to n exclusive, set gcd to __gcd of ara[i] and gcd ;  $  TAB1 ans = integer set to mx / gcd ;  $  TAB1 set ans to absolute value of ans - n ;  $  TAB1 if ans modulo 2 ;  $  TAB2 print "Alice" ;  $  TAB1 else ;  $  TAB2 print "Bob" ;
TAB0 INF is a constant integer with INF = integer value of 2e9 ;  $  TAB0 EPS is a constant double with EPS = double value of 1e-9 ;  $  TAB0 PI is a constant double with PI = double value of arccosine of -1.0 ;  $  TAB0 MOD is a constant long long with MOD = long long value of 1e9 + 7 ;  $  TAB1 x, y, z, k are long longs ;  $  TAB1 read x, y, z, k ;  $  TAB1 arr is a long long array of size 3 ;  $  TAB1 set arr[0] to x - 1 ;  $  TAB1 set arr[1] to y - 1 ;  $  TAB1 set arr[2] to z - 1 ;  $  TAB1 call sort with arr, arr + 3 ;  $  TAB1 mn is a long long with mn = arr[0] ;  $  TAB1 ans is a long long array of size 3 ;  $  TAB1 if mn * 3 is at least k ;  $  TAB2 set ans[0] to k / 3 ;  $  TAB2 set ans[1] to k / 3 ;  $  TAB2 set ans[2] to k / 3 ;  $  TAB2 if k modulo 3 equals 1 ;  $  TAB3 increment ans[2] ;  $  TAB2 else if k modulo 3 equals 2 ;  $  TAB3 increment ans[2] ;  $  TAB3 increment ans[1] ;  $  TAB1 else ;  $  TAB2 set ans[0] to mn ;  $  TAB2 set ans[1] to mn ;  $  TAB2 set ans[2] to mn ;  $  TAB2 now is a long long with now = k - (3 * mn) ;  $  TAB2 mn2 is a long long with m2 = call min with now / 2, arr[1] - ans[1] ;  $  TAB2 add call min with arguments now / 2, arr[1] - ans[1] to ans[1] ;  $  TAB2 subtract mn2 from now ;  $  TAB2 set mn2 to call min with arguments now, arr[2] - ans[2] ;  $  TAB2 add mn2 to ans[2] ;  $  TAB1 res is a long long set to 1 ;  $  TAB1 for i = 0 to 3 exclusive, multiply res by (ans[i] + 1) ;  $  TAB1 display res ;
TAB0 s = string ;  $  TAB0 len = integer ;  $  TAB0 let k, ans be integer ;  $  TAB1 read a ;  $  TAB1 set len to size of s ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 for j = 1+1 to len exclusive ;  $  TAB3 for k = 0 to infinity ;  $  TAB4 if i+k is greater than len or j+k is greater than len or s[i+k] is not equal to s[j+k], break ;  $  TAB3 set ans to max of ans, k ;  $  TAB1 print ans ;
TAB0 k = long long and a,b = arrays of long long size 3 ;  $  TAB1 read 3 values into array b ;  $  TAB1 read k ;  $  TAB1 for i = 0 to 3 exclusive a[i] = b[i]-1 ;  $  TAB1 call sort on a and a+3 ;  $  TAB1 if a[0] is greater than or equal to k/3 do the following ;  $  TAB2 set a[0] = k/3 ;  $  TAB2 set a[1] = (k - a[0]) / 2 ;  $  TAB2 set a[2] to the min of a[2] and k - a[0] - a[1] ;  $  TAB1 else do the following ;  $  TAB2 if a[1] is greater than or equal to (k - a[0]) / 2), do the following ;  $  TAB3 set a[1] = (k - a[0]) / 2 ;  $  TAB3 set a[2] to the min of a[2] and k - a[0] - a[1] ;  $  TAB2 else ;  $  TAB3 set a[2] to the min of a[2] and k - a[1] - a[0] ;  $  TAB1 print (a[0] + 1) * (a[1] + 1) * (a[2] + 1) ;
TAB1 str is a string set to abcdefghijklmnopqrstuvwxyz ;  $  TAB1 x, y are integers ;  $  TAB1 read x, y ;  $  TAB1 str1, str2 are strings ;  $  TAB1 for i = 0 to y exclusive, add str[i] to str1 ;  $  TAB1 j is an integer set to 0 ;  $  TAB1 for i = 0 to x exclusive ;  $  TAB2 add str[j] to str2 ;  $  TAB2 if j equals (length of str1) - 1 ;  $  TAB3 set j to 0 ;  $  TAB2 else ;  $  TAB3 increment j ;  $  TAB1 display str2 ;
TAB1 create integer a ;  $  TAB1 read a ;  $  TAB1 if a is even ;  $  TAB2 print "0\n" ;  $  TAB1 else ;  $  TAB2 print "1\n" ;
TAB0 a= integer array of size 51 ;  $  TAB0 in the function cmp which takes two integers a and b and returns a boolean ;  $  TAB1 return true if a>b else return false ;  $  TAB1 n,m,k = integers ;  $  TAB1 read n,m,k ;  $  TAB1 read n values into the array a ;  $  TAB1 sort array a ;  $  TAB1 create integers filter = 0, stock = k, i=0, flag=0 ;  $  TAB1 while m>k ;  $  TAB2 set k to k-1+a[i] ;  $  TAB2 increment i ;  $  TAB2 increment filter ;  $  TAB2 if filter>n ;  $  TAB3 set flag to 1 ;  $  TAB3 break ;  $  TAB1 if flag is equal to 0 ;  $  TAB2 print filter ;  $  TAB1 else do the following ;  $  TAB2 print -1 and a new line ;
TAB0 declare string str ;  $  TAB0 in function isPalindrome returning bool, accepting int idx and int N ;  $  TAB1 for i = 0 to N / 2 exclusive ;  $  TAB2 if str[i + idx] is not equal to str[N - 1 - i + idx], return false ;  $  TAB1 return true ;  $  TAB1 read str ;  $  TAB1 declare int n and k ;  $  TAB1 read k ;  $  TAB1 set n to str length ;  $  TAB1 define int l = n / k ;  $  TAB1 define bool possible = true ;  $  TAB1 if l * k equals n ;  $  TAB2 define int i = 0 ;  $  TAB2 while i less than n ;  $  TAB3 if not isPalindrome(i, l) ;  $  TAB4 set possible to false ;  $  TAB4 break ;  $  TAB3 increase i by l ;  $  TAB1 else ;  $  TAB2 set possible to false ;  $  TAB1 if possible ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB1 print newline ;
TAB0 create set of ints se ;  $  TAB1 create int n, p, x, t ;  $  TAB1 while reading n ;  $  TAB2 read x ;  $  TAB2 while x decremented ;  $  TAB3 read t ;  $  TAB3 insert t into se ;  $  TAB2 read p ;  $  TAB2 while p decremented ;  $  TAB3 read t ;  $  TAB3 insert t into se ;  $  TAB2 if se size is not equal to n ;  $  TAB3 print "Oh, my keyboard!" ;  $  TAB2 else ;  $  TAB3 print "I become the guy." ;  $  TAB2 clear se ;
TAB1 let n = unsigned long long ;  $  TAB1 read n ;  $  TAB1 let r = integer value 1 ;  $  TAB1 while r*5 is less than n do the following ;  $  TAB2 set n = n-(r*5) ;  $  TAB2 set r = r*2 ;  $  TAB1 let s = array of strings, values Sheldon, Leonard, Penny, Rajesh, Howard ;  $  TAB1 print s[n-1]/r] ;
TAB1 n = integer ;  $  TAB1 a, b are strings ;  $  TAB1 read n, a, b ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to n exclusive, add call min with 10 - absolute value (a[i] = b[i]), absolute value (a[i] - b[i]) to ans ;  $  TAB1 print ans ;
TAB1 let n, c, x be integers with c = 0 ;  $  TAB1 input n ;  $  TAB1 let y be an integer with y = n ;  $  TAB1 if n is at least 100 ;  $  TAB2 assign n / 100 to x ;  $  TAB2 add x to c ;  $  TAB2 assign n modulo 100 to y ;  $  TAB1 if y is at least 20 ;  $  TAB2 assign y / 20 to x ;  $  TAB2 add x to c ;  $  TAB2 assign y modulo 20 to y ;  $  TAB1 if y is at least 10 ;  $  TAB2 assign y / 10 to x ;  $  TAB2 add x to c ;  $  TAB2 assign y modulo 10 to y ;  $  TAB1 if y is at least 5 ;  $  TAB2 assign y / 5 to x ;  $  TAB2 add x to c ;  $  TAB2 assign y modulo 5 to y ;  $  TAB1 add y to c ;  $  TAB1 display c ;
TAB1 set a,c,d = integers with c,d value 99999999999 and b =array of integers size 100000 ;  $  TAB1 read a ;  $  TAB1 for i=0 to a exclusive do the following ;  $  TAB2 read b[i] ;  $  TAB2 set c = min of b[i] and c ;  $  TAB1 for i=0 to a-1 exclusive do the following ;  $  TAB2 if b[i] is c do the following ;  $  TAB3 for j= i+1 to a exclusive do the following ;  $  TAB4 if b[j] is c do the following ;  $  TAB5 set d = min of d and j-i ;  $  TAB5 if d is 1 ;  $  TAB6 print 1 ;  $  TAB1 print d ;
TAB0 declare int n, k, array a of length 1001, ans ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read k ;  $  TAB2 set a[i] to k ;  $  TAB2 sort elements 0 to a + i + 1 in a ;  $  TAB2 if ((a[0] equals k and a[1] is not equal to k) or (a[i] equals k and a[i - 1] is not equal to k)) and i is not equal to 0, increment ans ;  $  TAB1 print ans ;
TAB1 make integers m, d, flag = 0 ;  $  TAB1 read m, d ;  $  TAB1 if m is equal to 2 ;  $  TAB2 if d is equal to 1 ;  $  TAB3 print "4" ;  $  TAB2 else ;  $  TAB3 print "5" ;  $  TAB1 if m is equal to 1 OR m is equal to 3 OR m is equal to 5 OR m is equal to 7 OR m is equal to 8 OR m is equal to 10 OR m is equal to 12 ;  $  TAB2 flag = 1 ;  $  TAB1 else if m is not equal to 2 ;  $  TAB2 flag = 0 ;  $  TAB1 if flag equal 1 ;  $  TAB2 if d greater than or equal 1 and d less than or equal 5 ;  $  TAB3 print "5" ;  $  TAB2 else if d equal 6 or d equal 7 ;  $  TAB3 print "6" ;  $  TAB1 else if flag equal 0 ;  $  TAB2 if d greater than or equal 1 AND d less than or equal 6 ;  $  TAB3 print "5" ;  $  TAB2 else if d equal 7 ;  $  TAB3 print "6" ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 r = integer set to 1 ;  $  TAB1 while r * 5 < n ;  $  TAB2 subtract r * 5 from n ;  $  TAB2 multiply r by 2 ;  $  TAB1 names[] = an array of strings set to "Sheldon", "Leonard", "Penny", "Rajesh", "Howard" ;  $  TAB1 print names[(n-1) / r] ;
TAB0 maxn is a constant integer set to 32 ;  $  TAB1 declare an integer n ;  $  TAB1 read n ;  $  TAB1 a is an integer array of sizes maxn and maxn with a = {0} ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 read a[i][j] ;  $  TAB3 add a[i][j] to a[i][n] ;  $  TAB3 add a[i][j] to a[n][j] ;  $  TAB1 ans is an integer set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if a[n][j] is greater than a[i][n], increment ans ;  $  TAB1 display ans ;
TAB1 n, i, j, m, c, x, y are integers with m = 0 and c = 0 ;  $  TAB1 read n ;  $  TAB1 iterate n times ;  $  TAB2 read x, y ;  $  TAB2 if x equals y ;  $  TAB3 continue ;  $  TAB2 else if x is greater than y ;  $  TAB3 increment m ;  $  TAB2 else ;  $  TAB3 increment c ;  $  TAB1 if m is equal to c ;  $  TAB2 output Friendship is magic!^^ ;  $  TAB1 else if m is greater than c ;  $  TAB2 output Mishka ;  $  TAB1 else ;  $  TAB2 output Chris ;
TAB0 n, x = integers, a = array of integers length 4 ;  $  TAB1 read n ;  $  TAB1 while n is greater than 0 while decrementing n by 1 ;  $  TAB2 read x ;  $  TAB2 increment a[x] by 1 ;  $  TAB1 sort a + 1 and a + 4 ;  $  TAB1 print a[1] + a[2] ;
TAB1 declare integers n, k, G1, T1 ;  $  TAB1 read n and k ;  $  TAB1 declare string arr ;  $  TAB1 read arr ;  $  TAB1 define integer len = arr length ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if arr[i] is equal to 'G' ;  $  TAB3 set G1 to i ;  $  TAB2 else if arr[i] is equal to 'T' ;  $  TAB3 set T1 to i ;  $  TAB1 define integers x = G1, flag = 0 ;  $  TAB1 if G1 is equal to T1 ;  $  TAB2 print "YES" ;  $  TAB1 else if G1 is less than T1 ;  $  TAB2 while x is not equal to T1 and x is less than or equal to len - 1 and x is greater than or equal to 0 ;  $  TAB3 assign x + k to x ;  $  TAB3 if arr[x] is equal to '#', assign 1 to flag ;  $  TAB2 if x is equal to T1 and flag is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;  $  TAB1 else ;  $  TAB2 while x is not equal to T1 and x is less than or equal to len -1 and x is greater than or equal to 0 ;  $  TAB3 assign x - k to x ;  $  TAB3 if arr[x] is equal to '#', assign 1 to flag ;  $  TAB2 if x is equal to T1 and flag is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 create integers n,max,res with max=0 and res=1 ;  $  TAB1 read n ;  $  TAB1 create integer array a of size n ;  $  TAB1 read first element of arr ;  $  TAB1 for j=0 to n-1 excluisve ;  $  TAB2 read arr[j+1] ;  $  TAB2 if arr[j] < = arr[j+1] ;  $  TAB3 increment res ;  $  TAB2 else if arr[j] > arr [ j+1] ;  $  TAB3 if res> max then set max = res ;  $  TAB3 set res = 1 ;  $  TAB1 if res>max ;  $  TAB2 print res ;  $  TAB1 else do the following ;  $  TAB2 print max and a new line ;
TAB0 let n = integer ;  $  TAB0 let x = integer ;  $  TAB1 read n, x ;  $  TAB1 for integer i=0 to x exclusive do the following ;  $  TAB2 if n modulo 10 is 0 ;  $  TAB3 set n = n / 10 ;  $  TAB2 else ;  $  TAB3 decrement n ;  $  TAB1 print n ;
TAB1 let n, i = integers ;  $  TAB1 let s = string ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read s ;  $  TAB2 if length of s is greater than 10 do the following ;  $  TAB3 print s[0] and length of s - 2 and s[length of s -1] ;  $  TAB2 else do the following ;  $  TAB3 print s ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n modulo 2 is equal to 0 ;  $  TAB2 print n / 2 ;  $  TAB1 else ;  $  TAB2 print -(n + 1) / 2 ;
TAB1 array = integer array of length 26 with array = {0} ;  $  TAB1 let index and count be integers with both set to 0 ;  $  TAB1 name = string ;  $  TAB1 input name ;  $  TAB1 let n be an integer with n = the length of name ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 set index to name[i] - the character a ;  $  TAB2 increment array[index] ;  $  TAB2 if array[index] is equal to 1, increment count ;  $  TAB1 if count mod 2 doesn't equal 0 ;  $  TAB2 print IGNORE HIM! ;  $  TAB1 else ;  $  TAB2 print CHAT WITH HER! ;
TAB1 declare integer array a of size 200 ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 read n elements into a ;  $  TAB1 define integer max = 222222 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i to n exclusive ;  $  TAB3 define integers sum1 = 0, sum2 = 0, sum3 = 0 ;  $  TAB3 for k = 0 to i exclusive ;  $  TAB4 if a[k] equals 1, increment sum1 ;  $  TAB3 for k = i to j inclusive ;  $  TAB4 if a[k] equals 0, increment sum2 ;  $  TAB3 for k = j + 1 to n exclusive ;  $  TAB4 if a[k] equals 1, increment sum3 ;  $  TAB3 if sum1 + sum2 + sum3 greater than max, set max to sum1 + sum2 + sum3 ;  $  TAB1 print max ;
TAB1 k, n, s, p are doubles ;  $  TAB1 read k, n, s, and p ;  $  TAB1 ans is an integer with ans = ceiling of (k * ceiling of (n / s))) / p ;  $  TAB1 display ans ;
TAB1 y=array of long long integer of size 100 and create long long integer i, j, sum, count = 0, x, n, p ;  $  TAB1 read n ;  $  TAB1 for i=n-81 to n exclusive ;  $  TAB2 set x=i ;  $  TAB2 set sum=i ;  $  TAB2 for j=0 tio infinity ;  $  TAB3 set p=x mod 10 ;  $  TAB3 set x=x/10 ;  $  TAB3 set sum=sum+p ;  $  TAB3 if x=0 ;  $  TAB4 if sum=n ;  $  TAB5 set y[count]=i ;  $  TAB5 increment count ;  $  TAB4 break ;  $  TAB1 print count ;  $  TAB1 print count values of the array y ;
TAB1 let x, y = integer ;  $  TAB1 read x, y ;  $  TAB1 for integer i=1 to x inclusive do the following ;  $  TAB2 if i is odd do the following ;  $  TAB3 for integer j=0 to y exclusive print # ;  $  TAB3 print a new line ;  $  TAB2 else if i / 2 is odd do the following ;  $  TAB3 for integer m=1 to y exclusive print . ;  $  TAB3 print # ;  $  TAB2 else do the following ;  $  TAB3 print # ;  $  TAB3 for integer k=1 to y exclusive print . ;  $  TAB3 print a new line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 arr is an integer array of size n ;  $  TAB1 read n values into array arr ;  $  TAB1 max = integer set to 0 ;  $  TAB1 for i = 0 to long long value of n ;  $  TAB2 aux = integer = arr[i] ;  $  TAB2 can = integer = 0 ;  $  TAB2 fir j = i to n exclusive ;  $  TAB3 if arr[j] is aux, increment can ;  $  TAB2 if can is greater than max, set max to can ;  $  TAB1 display max ;
TAB0 let h = array of integers size 101 ;  $  TAB1 let n = integers ;  $  TAB1 read n ;  $  TAB1 let Li = integer ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 if i is 0 ;  $  TAB3 read Li ;  $  TAB2 else ;  $  TAB3 read h[i] ;  $  TAB1 let temp = integer with value = Li ;  $  TAB1 call sort on h+1 and h+n ;  $  TAB1 if n is 1 do the following ;  $  TAB2 print 0 ;  $  TAB1 while Li is less than or equal to h[n-1] do the following ;  $  TAB2 increment Li ;  $  TAB2 decrement h[n-1] ;  $  TAB2 for integer j=n-2 to 1 inclusive decrementing do the following ;  $  TAB3 if h[j] is greater than h[j+1] do the following ;  $  TAB4 let t = integer value = h[j] ;  $  TAB4 set h[j] = h[j+1] ;  $  TAB4 set h[j+1 = t ;  $  TAB1 print Li - temp ;
TAB0 po = integer array of size 105 ;  $  TAB0 define function check with takes two integer arguments and returns a boolean ;  $  TAB1 set all values of po to 0 ;  $  TAB1 let n,a,b,cnt be ints with cnt=0 ;  $  TAB1 read n,a,b ;  $  TAB1 for i=a to n exclusive ;  $  TAB2 if n - i - 1 <= b and check(i + 1, cnt) then set po[+cnt] = i+1 ;  $  TAB1 print cnt ;  $  TAB0 into the function check ;  $  TAB1 for i=1 to cnt inclusive ;  $  TAB2 if po[i] = q then return false ;  $  TAB1 return true ;
TAB1 let n = int ;  $  TAB1 read n ;  $  TAB1 let v = vector containing ints ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let temp = int ;  $  TAB2 read temp ;  $  TAB2 push temp into v ;  $  TAB1 let count = int = 0 ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if v[i] > v[i - 1] and v[i] > v[i + 1] ;  $  TAB3 add 1 to count ;  $  TAB2 else if v[i] < v[i - 1] and v[i] < v[i + 1] ;  $  TAB3 add 1 to count ;  $  TAB1 print count ;
TAB0 l, r, t, b are integers ;  $  TAB1 n, m, i, j are integers ;  $  TAB1 read n, m ;  $  TAB1 s = string array of length n ;  $  TAB1 read n values into array s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if s[i][j] is the character B ;  $  TAB4 assign j to l ;  $  TAB4 break ;  $  TAB2 for j = m - 1 to 0 inclusive ;  $  TAB3 if s[i][j] is the character B ;  $  TAB4 assign j to r ;  $  TAB4 break ;  $  TAB2 if l and r, break ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i][l] is the character B ;  $  TAB3 assign i to t ;  $  TAB3 break ;  $  TAB1 for i = n - 1 to -1 exclusive ;  $  TAB2 if s[i][l] is the character B ;  $  TAB3 assign i to b ;  $  TAB3 break ;  $  TAB1 print (t + b + 2) / 2, " ", (l + r + 2) / 2 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 while (decrement n) is greater than 0 do the following ;  $  TAB2 k = integer ;  $  TAB2 read k ;  $  TAB2 s = string ;  $  TAB2 read s ;  $  TAB2 if k is 2 and s[0] is greater than or equal to s[1] ;  $  TAB3 print NO ;  $  TAB2 else ;  $  TAB3 print YES and a new line and 2 and a newline and s[0] and a space and substring(1) of s ;
TAB1 n,p,b,x,y= integers with x=y=0 ;  $  TAB1 read n,b,p ;  $  TAB1 set y = n*p ;  $  TAB1 while n is not 1 ;  $  TAB2 create integer z = __lg(n) ;  $  TAB2 set z= 1<<z ;  $  TAB2 set z= z>>1 ;  $  TAB2 set x = x + z* (2*b+1) ;  $  TAB2 set n= n-z ;  $  TAB1 print x and y ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = 2d array of character with dimensions of 1000x1000 ;  $  TAB1 for i = n / 2, j = 0, k = n -1, to i >= 0, while decrementing i and k by 1, and incrementing j by 1 ;  $  TAB2 for c = j to k inclusive, set a[i][c] to 'D' ;  $  TAB1 for i = n / 2 + 1, j = 1, k = n - 2; i to n and incrementing j by 1 and decrementing k by 1 ;  $  TAB2 for c = j to k inclusive, set a[i][c] to "D" ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if a[i][j] is 'D' ;  $  TAB4 print a[i][j] ;  $  TAB3 else ;  $  TAB4 print "*" ;  $  TAB2 endline ;
TAB1 let n, k be integers ;  $  TAB1 while input available, read n, k ;  $  TAB2 while k > 0 ;  $  TAB3 let last_digit be integer with last_digit = n mod 10 ;  $  TAB3 if last_digit == 0 ;  $  TAB4 decrement k and update n to n/10 ;  $  TAB3 else ;  $  TAB4 decrement k and n ;  $  TAB2 print n ;
TAB1 let s be a string ;  $  TAB1 input s ;  $  TAB1 output 25 * ((size of s) + 1) + 1 ;
TAB0 create constant integer M = 100000 + 5 ;  $  TAB1 n,k = integers ;  $  TAB1 read n and k ;  $  TAB1 create integer ans = maximum of 3*n-k and 0 ;  $  TAB1 print ans and new line ;
TAB0 define const long long mod = 1e9 + 7 ;  $  TAB0 declare map m with key of type vector<char> and value of type int ;  $  TAB0 in function rotz that takes vector<char> v and returns vector<char> ;  $  TAB1 define char tmp = v[3] ;  $  TAB1 v[3] = v[2], v[2] = v[1], v[1] = v[0], v[0] = tmp ;  $  TAB1 return v ;  $  TAB0 in function roty that takes vector<char> v and returns vector<char> ;  $  TAB1 swap v[4] and v[0] ;  $  TAB1 swap v[4] and v[2] ;  $  TAB1 swap v[2] and v[5] ;  $  TAB1 return v ;  $  TAB0 in function rotx that takes vector<char> v and returns vector<char> ;  $  TAB1 swap v[5] and v[1] ;  $  TAB1 swap v[5] and v[3] ;  $  TAB1 swap v[3] and v[4] ;  $  TAB1 return v ;  $  TAB0 in function go return type of bool and parameter vector<char> v ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = 0 to 4 exclusive ;  $  TAB3 for k = 0 to 4 exclusive ;  $  TAB4 set v to rotz(v) ;  $  TAB4 if v in m then return true ;  $  TAB3 set v to roty(v) ;  $  TAB2 set v to rotx(v) ;  $  TAB1 return false ;  $  TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare vector<char> v ;  $  TAB1 for i = 0 to s size cast to int do push s[i] into v ;  $  TAB1 sort v ;  $  TAB1 define int cnt = 0 ;  $  TAB1 do ;  $  TAB2 if not go(v) ;  $  TAB3 set m[v] to 1 ;  $  TAB3 increment cnt ;  $  TAB1 while next_permutation(v.begin(), v.end()) ;  $  TAB1 print cnt ;
TAB1 declare map mp with key of string to value of int ;  $  TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 define int ans = 0 ;  $  TAB1 for i = 0 to s length inclusive ;  $  TAB2 define string aa = "", bb = "" ;  $  TAB2 for j = 0 to i exclusive, increase aa by s[j] ;  $  TAB2 for j = i to s length exclusive, increase bb by s[j] ;  $  TAB2 for j = 97 to 122 inclusive ;  $  TAB3 define string tem = aa ;  $  TAB3 define char c = j casted to char ;  $  TAB3 increase tem by c ;  $  TAB3 increase tem by bb ;  $  TAB3 if mp[tem] == 0 ;  $  TAB4 add 1 to ans ;  $  TAB4 set mp[tem] to 1 ;  $  TAB1 print ans ;
TAB1 let n, m, k, t, x be integers ;  $  TAB1 while read n, m, k, t ;  $  TAB2 create integer i ;  $  TAB2 for i = 1 to 10000000 exclusive ;  $  TAB3 if m is less than or equal to the k * i ;  $  TAB4 assign 1 to x ;  $  TAB4 break ;  $  TAB2 for i = 1 to 200000000 exclusive ;  $  TAB3 if i * t is greater than or equal to x * n ;  $  TAB4 output i ;  $  TAB4 break ;
TAB1 s,q= strings ;  $  TAB1 read s ;  $  TAB1 read q ;  $  TAB1 if s is equal to q ;  $  TAB2 print -1 and new line ;  $  TAB1 else do the following ;  $  TAB2 if size of s is greater than size of q ;  $  TAB3 then print size of s and a new line ;  $  TAB2 else do the following ;  $  TAB3 print size of q ;
TAB0 define constant integer N = 200000 + 7 ;  $  TAB0 declare integer array a of length N ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 define integer sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increase sum by a[i] ;  $  TAB1 define integer curr = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 increase curr by a[i] ;  $  TAB2 if 2 * curr greater than or equal to sum ;  $  TAB3 print i + 1 ;  $  TAB3 end loop ;
TAB1 n and i are long long integers ;  $  TAB1 input n ;  $  TAB1 for integer i = 0 with condition n is greater than or equal to 2, subtract 2 from n ;  $  TAB1 increment i ;  $  TAB1 output i ;
TAB1 create integer x=0 ;  $  TAB1 for i=1 to 5 inclusive ;  $  TAB2 for j=1 to 5 inclusive ;  $  TAB3 read x ;  $  TAB3 if x is equal to 1 then print absolute value of i-3 + absolute value of j-3 and a new line ;
TAB1 let n, num, Maxn, Minn, ans = integers with ans = 0 ;  $  TAB1 read n ;  $  TAB1 read num ;  $  TAB1 set Maxn = num, Minn = num ;  $  TAB1 for integer i = 1 to n exclusive do the following ;  $  TAB2 read num ;  $  TAB2 if num is greater than Maxn do the following ;  $  TAB3 set Maxn = num ;  $  TAB3 increment ans ;  $  TAB2 else if num is less than Minn do the following ;  $  TAB3 set Minn = num ;  $  TAB3 increment ans ;  $  TAB1 print ans ;
TAB0 make const int maxn = 5e5 + 1000 ;  $  TAB0 make int array a of length maxn ;  $  TAB1 make int n, k ;  $  TAB1 read n and k ;  $  TAB1 read n values into a ;  $  TAB1 make int save = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 increase save by a[i] ;  $  TAB2 if save less than or equal to 8 ;  $  TAB3 subtract save from k, set save to 0 ;  $  TAB2 else ;  $  TAB3 subtract 8 from k, subtract 8 from save ;  $  TAB2 if k less than or equal to 0 ;  $  TAB3 print i ;  $  TAB1 print -1 ;
TAB1 create integers a=0 and b=0 ;  $  TAB1 create 2D integer array arr of size 5X5 ;  $  TAB1 for i=0 to 5 exclusive ;  $  TAB2 for j=0 to 5 exclusive ;  $  TAB3 read arr[i][j] ;  $  TAB3 if arr[i][j] is 1 ;  $  TAB4 then set a=i ;  $  TAB4 set b=j ;  $  TAB4 break out of the loop ;  $  TAB1 print abs(a - 2) + abs(b - 2) ;
TAB1 n, k, r, g, b, m are long integers with m = 0 ;  $  TAB1 input n, k ;  $  TAB1 set r to n * 2 ;  $  TAB1 set g to n * 5 ;  $  TAB1 set b to n * 8 ;  $  TAB1 if r is divisible by k ;  $  TAB2 add r / k to m ;  $  TAB1 else ;  $  TAB2 add ((r / k) + 1) to m ;  $  TAB1 if g is divisible by k ;  $  TAB2 add g / k to m ;  $  TAB1 else ;  $  TAB2 add ((g / k) + 1) to m ;  $  TAB1 if b is divisible by k ;  $  TAB2 add b / k to m ;  $  TAB1 else ;  $  TAB2 add ((b / k) + 1) to m ;  $  TAB1 display m ;
TAB1 let T, n = integer ;  $  TAB1 let s = string ;  $  TAB1 read T ;  $  TAB1 for integer i=1 to T exclusive do the following ;  $  TAB2 read n, s ;  $  TAB2 let j = integer with value = 0 ;  $  TAB2 while j is less than n / 2 do the following ;  $  TAB3 if s[j] not equal to s[n - j - 1] and abs(s[j] - s[n - j - 1]) not equal to 2 do the following ;  $  TAB4 print NO ;  $  TAB4 exit the loop ;  $  TAB3 increment j ;  $  TAB2 if j is n / 2 print YES ;
TAB0 in function mod, return type int, parameters int a and int b ;  $  TAB1 return ((a mod b) + b) mod b ;  $  TAB1 make integers k, r, shovel = 1, sum ;  $  TAB1 read k and r ;  $  TAB1 set sum to k ;  $  TAB1 while sum mod 10 is not equal to 0 ;  $  TAB2 if mod(sum - r, 10) equals 0, break ;  $  TAB2 increase sum by k ;  $  TAB2 increment shovel ;  $  TAB1 print shovel ;
TAB0 in function finder returning bool and taking char c and string reference s ;  $  TAB1 define int position = find c in s ;  $  TAB1 if position equals string::npos ;  $  TAB2 return false ;  $  TAB1 else ;  $  TAB2 set s to s.substr(position + 1, length of s - (position + 1)) ;  $  TAB2 return true ;  $  TAB1 declare string s ;  $  TAB1 declare bool found ;  $  TAB1 read s ;  $  TAB1 set found to finder('h', s) ;  $  TAB1 if found equals false ;  $  TAB2 print "NO" ;  $  TAB1 set found to finder('e', s) ;  $  TAB1 if found is false ;  $  TAB2 print "NO" ;  $  TAB1 assign finder('l', s) to found ;  $  TAB1 if found is false ;  $  TAB2 print "NO" ;  $  TAB1 assign finder('l', s) to found ;  $  TAB1 if found is equal to false ;  $  TAB2 print "NO" ;  $  TAB1 assign finder('o', s) to found ;  $  TAB1 if found is equal to false ;  $  TAB2 print "NO" ;  $  TAB1 if found then print "YES" ;
TAB1 let n be an int ;  $  TAB1 read n and repeat until n is valid ;  $  TAB2 create integers tep=0 and ans=0 ;  $  TAB2 while n-- is true ;  $  TAB3 val=integer ;  $  TAB3 read val ;  $  TAB3 if val is 0 ;  $  TAB4 add 1 to ans ;  $  TAB3 else if tep is equal to val and val is not 3 ;  $  TAB4 increment ans ;  $  TAB4 set val to 0 ;  $  TAB3 else if val is 3 and tep is not 3 ;  $  TAB4 if tep is 1 ;  $  TAB5 then set val=2 ;  $  TAB4 else if tep=2 then do the following ;  $  TAB5 assign 1 to val ;  $  TAB3 set tep=val ;  $  TAB2 print ans ;
TAB0 let arr = array of integers of size 100010 ;  $  TAB1 let n, c, hitung = integers with hitung = 0 ;  $  TAB1 read n, c ;  $  TAB1 read n values into array arr ;  $  TAB1 for integer i=n to 2 inclusive decrementing do the following ;  $  TAB2 if arr[i] - arr[i-1] is greater than c ;  $  TAB3 increment hitung ;  $  TAB2 else ;  $  TAB3 print hitung + 1 ;  $  TAB1 print hitung + 1 ;
TAB0 N = integer ;  $  TAB0 S = string array of size 105 ;  $  TAB1 read n ;  $  TAB1 read N values into array S ;  $  TAB1 val = long long set to 0 ;  $  TAB1 for char i is the character a to the character z inclusive ;  $  TAB2 for char j is the character a to the character z inclusive ;  $  TAB3 temp = long long set to 0 ;  $  TAB3 for k = 0 to N exclusive ;  $  TAB4 cek = boolean set to 1 ;  $  TAB4 for m = 0 to length of S[k] exclusive ;  $  TAB5 if S[k][m] doesn't equal i and S[k][m] doesn't equal j ;  $  TAB4 if cek, add length of S[k] to temp ;  $  TAB3 set val to call max with val, temp ;  $  TAB1 output val ;
TAB0 in function w that takes integer n and return long long ;  $  TAB1 p is an integer array of length 15 ;  $  TAB1 len = integer = 0 ;  $  TAB1 while n is true ;  $  TAB2 p[increment len] is set to n mod 10 ;  $  TAB2 n is assigned n / 10 ;  $  TAB1 re = long long = 0 ;  $  TAB1 while decrement len, set re to re * 10 + 9 - p[len] ;  $  TAB1 return re ;  $  TAB1 l, r, len are integers with len = 0 ;  $  TAB1 i, max are long longs ;  $  TAB1 while input 1 and r ;  $  TAB2 for i = 1 to 1000000000 with an increment of i * 10 ;  $  TAB3 if r is less than i, break ;  $  TAB2 set max to (i shifted to the right 1 bit) - 1 ;  $  TAB2 if l is less than or equal to max and max is less than or equal to r ;  $  TAB3 display max * call function w with argument max ;  $  TAB2 else if max is less than or equal to r ;  $  TAB3 display 1 * call function w with argument 1 ;  $  TAB2 else ;  $  TAB3 display r * call function w with argument r ;
TAB1 create integers n,s,i,j with s=0 and 2D integer array a of size 10 by 10 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive set a[i][j[ to 1 ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 for j=1 to n exclusive set a[i][j] = a[i][j - 1] + a[i - 1][j] ;  $  TAB1 set s = a[n - 1][n - 1] ;  $  TAB1 print s ;
TAB1 create int a, b, array a1 of length 1001, x, k = 1, ansx = 0 ;  $  TAB1 read a and b ;  $  TAB1 for i = 1 to a inclusive, read a1[i] ;  $  TAB1 for i = 1 to b inclusive ;  $  TAB2 read x ;  $  TAB2 while k is not equal to a + 1 ;  $  TAB3 if a1[k] is less than or equal to x ;  $  TAB4 increment ansx ;  $  TAB4 increment k ;  $  TAB4 break ;  $  TAB3 increment k ;  $  TAB1 print ansx ;
TAB1 declare character char a, b ;  $  TAB1 declare long long n ;  $  TAB1 read a, b, n ;  $  TAB1 set n to n mod 4 ;  $  TAB1 define integer array x, 8 elements, initialize to 118, 60, 94, 62, 118, 60, 94, 62 ;  $  TAB1 define integer array y, 8 elements, initialize to 118, 62, 94, 60, 118, 62, 94, 60 ;  $  TAB1 define integer c1 = 0, c2 = 0 ;  $  TAB1 for i = 0 to 8 exclusive ;  $  TAB2 if x[i] equals a cast to int ;  $  TAB3 if x[i + n] equals b cast to int, set c1 to 1 ;  $  TAB3 break ;  $  TAB1 for i = 0 to 8 exclusive ;  $  TAB2 if y[i] equals a cast to int ;  $  TAB3 if y[i + n] equals b cast to int, set c2 to 1 ;  $  TAB3 break ;  $  TAB1 if c1 and c2 ;  $  TAB2 print "undefined\n" ;  $  TAB1 else if c1 ;  $  TAB2 print "cw\n" ;  $  TAB1 else if c2 ;  $  TAB2 print "ccw\n" ;
TAB0 in function gcd with parameters long longs a, b and return long long ;  $  TAB1 if a is less than b, call swap with a, b ;  $  TAB1 if b is 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return call gcd with b, a modulo b ;  $  TAB0 in function lcm with parameters long longs a, b and return long long ;  $  TAB1 return a * b / call gcd with a, b ;  $  TAB1 a, b, c are long longs ;  $  TAB1 raed a, b ;  $  TAB1 set c to call lcm with a, b ;  $  TAB1 assign c / a to a ;  $  TAB1 assign c / b to b ;  $  TAB1 if a is greater than b ;  $  TAB2 increment b ;  $  TAB1 else if a is less than b ;  $  TAB2 increment a ;  $  TAB1 if a is b ;  $  TAB2 display Equal ;  $  TAB1 else if a is greater than b ;  $  TAB2 display Dasha ;  $  TAB1 else ;  $  TAB2 display Masha ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let arr and copy be array of integers with size n+1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB3 read arr[i] ;  $  TAB3 read element at index i of copy ;  $  TAB1 let cou be integer with cou = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 if arr[i] is equal to copy[j], increment cou ;  $  TAB1 print cou with newline ;
TAB1 create int a, b, d = 1, i = 1, c ;  $  TAB1 read a and b ;  $  TAB1 assign a to c ;  $  TAB1 if a modulo 10 is not equal to 0 ;  $  TAB2 assign (a modulo 10) - b to d ;  $  TAB2 while d not equal to 0 ;  $  TAB3 increment i ;  $  TAB3 assign c * i to a ;  $  TAB3 if a modulo 10 equals 0, break ;  $  TAB3 assign (a modulo 10) - b to d ;  $  TAB1 print i ;
TAB1 make long long ints n and k ;  $  TAB1 read n and k ;  $  TAB1 if k % n is 0 ;  $  TAB2 print (k / n) ;  $  TAB1 else ;  $  TAB2 print ((k / n) + 1) ;
TAB1 let x and ans be long longs, with x = 0, ans = 0 ;  $  TAB1 input x ;  $  TAB1 while x is greater than 0 ;  $  TAB2 if x mod 2 equals 1, increment ans ;  $  TAB2 divide x by 2 and assign the quotient to x ;  $  TAB1 output ans ;
TAB1 i, links, pearls are integers with links and pearls both set to 0 ;  $  TAB1 s is a string ;  $  TAB1 input s ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] is the character - ;  $  TAB3 increment links ;  $  TAB2 else ;  $  TAB3 increment pearls ;  $  TAB1 if pearls is 0 ;  $  TAB2 output YES ;  $  TAB1 else if links is divisible by pearls ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 create constant integer INF = 0x3f3f3f3f ;  $  TAB0 create constant double eps = 1e-7 ;  $  TAB0 create long long integer mod = 1e9 + 7 ;  $  TAB0 into the function CountOne which takes a integer n and returns a integer ;  $  TAB1 ans=integer with value 0 ;  $  TAB1 while n is true ;  $  TAB2 increment ans ;  $  TAB2 n= n>>1 ;  $  TAB1 return ans ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 print CountOne(n) ;
TAB0 x, y, = arrays of integers set to length of 2010 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read x[i] ;  $  TAB1 for i = 1 to n inclusive, read y[i] ;  $  TAB1 print "Karen" ;
TAB0 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 print min of a, b, " ", (a - min of a, b) / 2 + (b - min of a, b)) / 2 ;
TAB1 n, m, and a are long longs ;  $  TAB1 while input n, m, and a, display ((n + a - 1) / a) * ((m + a - 1) / a ;
TAB1 let result be a string array set to 'first', 'second' ;  $  TAB1 x,y,r = integers ;  $  TAB1 read x,y,r ;  $  TAB1 set r to r * 2 ;  $  TAB1 print result[r > min(x,y)] ;
TAB0 let a be an integer array of size 200010 ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 sort the first n elements of a ;  $  TAB1 create integer res=1e9+7 ;  $  TAB1 for i=n/2 to n exclusive set res to minimum of res and a[i] - a[i - n / 2] ;  $  TAB1 print res ;
TAB0 let N be const integer with N = 1e5 + 5 ;  $  TAB0 let n, d be integers and x an array of integers of size N ;  $  TAB0 let ans be long long ;  $  TAB1 read n and d ;  $  TAB1 for i = 0 to n exclusive and p = 0 ;  $  TAB2 read x[i] ;  $  TAB2 while x[i] - x[p] is greater than d, increment p by 1 ;  $  TAB2 update ans to ans + (i - p - 1LL) * (i - p) / 2 ;  $  TAB1 print out ans with newline ;
TAB0 in the function to_num which takes a string s and returns an integer ;  $  TAB1 if size of s is greater than or equal to 4 ;  $  TAB2 if s.substr(s.size() - 4) = "lios" then return 0 ;  $  TAB1 if size of s >= 5 ;  $  TAB2 if s.substr(s.size() - 5) = "liala" then return 1 ;  $  TAB1 if size of s >= 3 ;  $  TAB2 if s.substr(s.size() - 3) = "etr" then return 2 ;  $  TAB1 if size of s >= 4 ;  $  TAB2 if s.substr(s.size() - 4) = "etra" then return 3 ;  $  TAB1 if size of s >=6 ;  $  TAB2 if s.substr(s.size() - 6) = "initis" then return 4 ;  $  TAB1 if size of s >= 6 ;  $  TAB2 if s.substr(s.size() - 6) = "inites" then return 5 ;  $  TAB1 return -1 ;  $  TAB0 in the function islegal which takes a integer vector ans and returns a boolean ;  $  TAB1 if ans[0] % 2 is equal to 0 ;  $  TAB2 for i=1 to size of ans exclusive ;  $  TAB3 if ans[i] % 2 is not equal to 0 then return false ;  $  TAB1 else do the following ;  $  TAB2 for i=1 to size of ans exclusive ;  $  TAB3 if ans[i] is equal to -1 then return false ;  $  TAB3 if ans[i] % 2 = 0 then return false ;  $  TAB1 return true ;  $  TAB0 in the function isok which takes an integer vector ans and returns a boolean ;  $  TAB1 create a boolean f = false ;  $  TAB1 for i=0 to size of ans exclusive ;  $  TAB2 if ans[i]/2 is equal to 0 and f is false ;  $  TAB3 set f to true ;  $  TAB3 continue ;  $  TAB2 if f is false ;  $  TAB3 if ans[i]/2 is not equal to 0 then return false ;  $  TAB2 else do the following ;  $  TAB3 if ans[i]/2 is not equal to 2 then return false ;  $  TAB1 if f is false then return false ;  $  TAB1 return true ;  $  TAB1 c=array of chars of size 100010 ;  $  TAB1 s= string ;  $  TAB1 res= vector of string ;  $  TAB1 ans = vector of integer ;  $  TAB1 create an integer pos=0 ;  $  TAB1 read c ;  $  TAB1 set s=c ;  $  TAB1 for i=0 to size of s exclusive ;  $  TAB2 if s[i] is empty ;  $  TAB3 add s.substr(pos, i - pos) to the end of res ;  $  TAB3 set pos to i+1 ;  $  TAB1 add s.substr(pos) to end of res ;  $  TAB1 for i=0 to size of res exclusive add to_num(res[i] to end of ans ;  $  TAB1 if size of ans is equal to 1 and asn[0] >=0 ;  $  TAB2 print YES ;  $  TAB1 if islegal(ans) is true ;  $  TAB2 if isok(ans)is true ;  $  TAB3 print YES ;  $  TAB2 else do the following ;  $  TAB3 print NO ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB1 create integer sum=0 ;  $  TAB1 tc=integer ;  $  TAB1 a= array of integer of size 100 ;  $  TAB1 read tc ;  $  TAB1 read tc value into array a ;  $  TAB1 create integer max= a ;  $  TAB1 for i=0 to tc exclusive ;  $  TAB2 if a[i]>max set max=a[i] ;  $  TAB1 for i=0 to tc exclusive set sum =sum+maxi-a[i] ;  $  TAB1 print sum ;
TAB1 let a, b = strings ;  $  TAB1 read a, b ;  $  TAB1 if a is b ;  $  TAB2 print a ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 x = string ;  $  TAB0 s = integer ;  $  TAB1 read x ;  $  TAB1 b = integer = 0 ;  $  TAB1 n = integer = length of x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a is an integer set to x[i] - 97 ;  $  TAB2 max is an integer ;  $  TAB2 min is an integer ;  $  TAB2 if a is greater than b ;  $  TAB3 set max to a ;  $  TAB3 set min to b ;  $  TAB2 else ;  $  TAB3 set min to a ;  $  TAB3 set max to b ;  $  TAB2 s1 is an integer set to max - min ;  $  TAB2 s2 is an integer set to 26 - max + min ;  $  TAB2 add s1 to s if s1 is less than s2, otherwise add s2 to s ;  $  TAB2 set b to x[i] - 97 ;  $  TAB1 print s ;
TAB0 let a be a long long array of size 200005 ;  $  TAB1 create an integer n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB1 call sort with arguments a, a + 2 * n ;  $  TAB1 ans = long long = (a[2 * n - 1] - a[n]) * (a[n - 1] - a[0]) ;  $  TAB1 for i = 1 to n exclusive, set ans to call min with arguments (ans, (a[2 * n - 1] - a[0]) * (a[n - 1 + i] - a[i])) ;  $  TAB1 display ans ;
TAB1 create long long integers n,m,mx,mn, cnt=0 and integer array ar of size 10000 ;  $  TAB1 create boolean ck=true ;  $  TAB1 read n,m,mn,mx ;  $  TAB1 for i=0 to m exclusive ;  $  TAB2 read ar[i] ;  $  TAB2 if ar[i] < mn or ar[i] > mx then set ck to false ;  $  TAB2 if ar[i] > mn and ar[i] < mx then increment cnt ;  $  TAB1 if ck is true and cnt <= (n - 2) ;  $  TAB2 print "Correct" ;  $  TAB1 else do the following ;  $  TAB2 print "Incorrect" ;
TAB1 let num be an integer ;  $  TAB1 input num ;  $  TAB1 ans = integer = 0 ;  $  TAB1 dif = integer = num - 10 ;  $  TAB1 if dif is at least 2 and dif is at most 10, add 4 to ans ;  $  TAB1 if dif is 10, add 11 to ans ;  $  TAB1 if dif is 11 or dif is 1, add 4 to ans ;  $  TAB1 output ans ;
TAB1 let score = integer of value 0 and arr = array of integers of size 6 ;  $  TAB1 for integer i=0 to 6 exclusive do the following ;  $  TAB2 read arr[i] ;  $  TAB2 set score = score + arr[i] ;  $  TAB1 if score is not even do the following ;  $  TAB2 print No ;  $  TAB2 return 0 ;  $  TAB1 score = score / 2 ;  $  TAB1 for integer i=0 to 6 exclusive do the following ;  $  TAB2 for integer j=i + 1 to 6 exclusive do the following ;  $  TAB3 forinteger k=j + 1 to 6 exclusive do the following ;  $  TAB4 if arr[i] + arr[j] + arr[k] is score ;  $  TAB5 print Yes ;  $  TAB5 return 0 ;  $  TAB1 print No ;  $  TAB1 return 0 ;
TAB0 N is a constant integer set to 105 ;  $  TAB0 let is be a boolean array of sizes N and N ;  $  TAB0 in function f with parameter integer x and return integer ;  $  TAB1 return (x * (x - 1) * (x - 2)) / 6 ;  $  TAB1 let k be an integer ;  $  TAB1 input k ;  $  TAB1 let n be an integer set to 1 ;  $  TAB1 while call f with n + 1 is at most k ;  $  TAB1 subtract call f with n from k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 if i isn't j, set is[i][j] to true ;  $  TAB1 let s be an integer with s = n ;  $  TAB1 while k is positive ;  $  TAB2 increment s ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if k is at least i - 1 ;  $  TAB4 subtract i - 1 from k ;  $  TAB4 assign true to is[s][i] ;  $  TAB4 assign true to is[i][s] ;  $  TAB1 display s ;  $  TAB1 for i = 1 to s inclusive ;  $  TAB2 for j = 1 to s inclusive, display is[i][j] ;  $  TAB2 display newline ;
TAB0 res = integer set to -1e9 ;  $  TAB1 n = integer ;  $  TAB1 print n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 if x < 0 ;  $  TAB3 set res to max of res and x ;  $  TAB2 else ;  $  TAB3 s = integer set to sqrt of x ;  $  TAB3 while s * s < x, increment s by 1 ;  $  TAB3 while s * s > x, decrement s by 1 ;  $  TAB3 if s * s !=x, set res to max of res and x ;  $  TAB1 print res ;
TAB1 m, n, i, j, p are integers with j = 0 ;  $  TAB1 read n and m ;  $  TAB1 a is an integer array of size m ;  $  TAB1 for i = 0 to m exclusive, read a[i] ;  $  TAB1 call sort with arguments a, a + m ;  $  TAB1 set p to a[n - 1] - a[0] ;  $  TAB1 for i = 0 to m inclusive ;  $  TAB2 set j to a[i + n - 1] - a[i] ;  $  TAB2 if p is greater than j, set p to j ;  $  TAB1 display p ;
TAB1 n, m, i, j are integers ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if ((i + 1) mod 4 equals 0) and ((i + 1) mod 2 equals 0) ;  $  TAB4 if j is 0 ;  $  TAB5 display # ;  $  TAB4 else ;  $  TAB5 display . ;  $  TAB3 else if ((i + 1) mod 4 isn't 0) and ((i + 1) mod 2 is 0) ;  $  TAB4 if j equals m - 1 ;  $  TAB5 display # ;  $  TAB4 else ;  $  TAB5 display . ;  $  TAB3 else ;  $  TAB4 display # ;  $  TAB2 display newline ;
TAB0 declare string s1, s2, a, b ;  $  TAB0 declare int n ;  $  TAB1 read s1, s2, and n ;  $  TAB1 print s1, " ", s2 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a and b ;  $  TAB2 if a equals s1, swap s1 and b ;  $  TAB2 if a equals s2, swap s2 and b ;  $  TAB2 print s1, " ", s2 ;
TAB1 s= array of characters of size 1000 ;  $  TAB1 read s ;  $  TAB1 create integer n = length of s ;  $  TAB1 if n<3 or (n=3 and strcmp(s, "127") <= 0) ;  $  TAB2 print byte and newline ;  $  TAB1 else if n<5 or (n = 5 and strcmp(s, "32767") <= 0) ;  $  TAB2 print short ;  $  TAB1 else if n<10 or (n = 10 and strcmp(s, "2147483647") <= 0) ;  $  TAB2 print int ;  $  TAB1 else if n<19 or (n = 19 and strcmp(s, "9223372036854775807") <= 0) ;  $  TAB2 print long and a new line ;  $  TAB1 else do the following ;  $  TAB2 print BigInteger ;
TAB0 declare int n ;  $  TAB0 declare int m ;  $  TAB0 declare int array a, size 200 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort a, elements 0 to n ;  $  TAB1 define int o = m ;  $  TAB1 define int dif = a[n - 1] - a[0] ;  $  TAB1 for i = 0 to n exclusive, subtract a[n - 1] - a[i] from m ;  $  TAB1 if m less than or equal to 0 ;  $  TAB2 print a[n - 1], " ", a[n - 1] + o ;  $  TAB1 else ;  $  TAB2 define int u = 0 ;  $  TAB2 if m mod n is not equal to 0, increment u ;  $  TAB2 print u + m / n + a[n - 1], " ", a[n - 1] + o ;
TAB1 declare char array s with 200006 as length ;  $  TAB1 declare int count, n, flag ;  $  TAB1 while reading n ;  $  TAB2 assign 0 to count ;  $  TAB2 fill s with 0 ;  $  TAB2 for i = 0 to n exclusive, read s[i] ;  $  TAB2 define int i = 0, j = n - 1 ;  $  TAB2 while s[i++] equals '<', increment count ;  $  TAB2 while s[i--] equals '>', increment count ;  $  TAB2 print count ;
TAB0 let q be integer ;  $  TAB0 let m be map of long long to long long ;  $  TAB0 upit = integer ;  $  TAB0 u, v, w = long long ;  $  TAB0 let sol be long long ;  $  TAB0 define dodaj ;  $  TAB1 while u is not equal to v ;  $  TAB2 is u is greater than v ;  $  TAB3 increment m[u] by w ;  $  TAB3 set u to u/2 ;  $  TAB2 else ;  $  TAB3 increment m[v] by w ;  $  TAB3 set v to v/2 ;  $  TAB0 define pokupi ;  $  TAB1 while u is not equal to v ;  $  TAB2 if u is greater than v ;  $  TAB3 increment sol by m[u] ;  $  TAB3 set u to u/2 ;  $  TAB2 else ;  $  TAB3 increment sol by m[v] ;  $  TAB3 set v to v/2 ;  $  TAB1 read q ;  $  TAB1 while q is not zero, decrement q ;  $  TAB2 read upit ;  $  TAB2 if upit is equal to 1 ;  $  TAB3 read v, u, w ;  $  TAB3 call dodaj ;  $  TAB2 else ;  $  TAB3 read v, u ;  $  TAB3 set sol to 0 ;  $  TAB3 call pokupi ;  $  TAB3 print sol ;
TAB0 in function f with parameters integers r, u and return integer ;  $  TAB1 return (u - (r mod u)) + r ;  $  TAB0 in function qwe with parameters integers n, u and return integer ;  $  TAB1 return (n / u) * u ;  $  TAB1 q, n, u, l, r are integers ;  $  TAB1 read q ;  $  TAB1 for i = 1 to q inclusive ;  $  TAB2 read n, u, l, r ;  $  TAB2 (l - 1) / u) + call max with ((call qwe with (n, u) - call f with (r, u)) / u + 1, 0 ;
TAB1 n, d = integers ;  $  TAB1 read n and d ;  $  TAB1 v = array of integers with length of 1000005 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 point = integer ;  $  TAB2 read point ;  $  TAB2 set v[i] to point ;  $  TAB1 result = long long integer set to 0 ;  $  TAB1 for right = 2, left = 0, right to n exclusive ;  $  TAB2 while v[right] - v[left] > d, increment left by 1 ;  $  TAB2 increment result by right - left * right - left - 1 / 2 ;  $  TAB1 print result ;
TAB0 n, L, a are integers ;  $  TAB1 read n, L, a ;  $  TAB1 result is an unsigned integer set to 0 ;  $  TAB1 prevbeg, prevlen are integers both set to 0 ;  $  TAB1 for currcase = 0 to n exclusive ;  $  TAB2 declare integers begin, length ;  $  TAB2 read begin, length ;  $  TAB2 if currcase isn't 0 ;  $  TAB3 breaktime = integer = begin - (prevbeg + prevlen) ;  $  TAB3 add floor (breaktime / a) to result ;  $  TAB2 else ;  $  TAB3 add floor (begin / a) to result ;  $  TAB2 assign begin to prevbeg ;  $  TAB2 assign length to prevlen ;  $  TAB1 lastbreaktime = integer = L - (prevbeg + prevlen) ;  $  TAB1 add floor (lastbreaktime / a) to result ;  $  TAB1 output result ;
TAB0 create function fast ;  $  TAB1 call fast ;  $  TAB1 let n and k be integers ;  $  TAB1 input k and n ;  $  TAB1 output 3 * k - n if (3 * k - n) is positive, otherwise output 0 ;
TAB1 n, k, t, d, s, c = integers with s and c set to 0 ;  $  TAB1 read n, k, t, d ;  $  TAB1 if t >= n ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 if n modulo t is 0 ;  $  TAB3 set s to n/t * k ;  $  TAB2 else ;  $  TAB3 set s to n / t + 1 * k ;  $  TAB2 set c to d + k ;  $  TAB2 if c >= s ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" ;
TAB1 a,x,y = integers ;  $  TAB1 for i=1 to 5 inclusive ;  $  TAB2 for j=1 to 5 inclusive ;  $  TAB3 read a ;  $  TAB3 if a is 1 ;  $  TAB4 set x=i ;  $  TAB4 set y = j ;  $  TAB1 print abs(x - 3) + abs(y - 3) ;
TAB1 create integers m,bq,qi with bq=100000 ;  $  TAB1 read m ;  $  TAB1 while m is true decement m and do the following ;  $  TAB2 read qi ;  $  TAB2 set bq = minimum of bq and qi ;  $  TAB1 n= integer ;  $  TAB1 read n ;  $  TAB1 a= vector integer array of size n ;  $  TAB1 read n values into the array a ;  $  TAB1 sort a in descending order ;  $  TAB1 create integer ans=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if i % (bq + 2) < bq then set ans= ans + a[i] ;  $  TAB1 print ans ;
TAB0 n, m = integers ;  $  TAB0 a, c = arrays of integers length of 1005 ;  $  TAB0 declare function get_ans which returns integers ;  $  TAB1 now, ans = integers set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if c[now] >= a[i] ;  $  TAB3 increment now by 1 ;  $  TAB3 increment ans by 1 ;  $  TAB2 if now is m, return ans ;  $  TAB1 return ans ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for j = 0 to m exclusive, read c[j] ;  $  TAB1 print result of get_ans ;
TAB0 declare integer array item with size of 100005 ;  $  TAB0 declare integer array status with size of 100005 ;  $  TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 define vector<long long> items of size n + 1 ;  $  TAB1 define long long sum = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read items[i] ;  $  TAB2 increase sum by items[i] ;  $  TAB1 define long long half = (sum + 1) / 2 ;  $  TAB1 define long long sum2 = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 increase sum2 by items[i] ;  $  TAB2 if sum2 greater than or equal to half ;  $  TAB3 print i ;  $  TAB3 break ;  $  TAB1 declare integer pa ;  $  TAB1 read pa ;
TAB0 create int array data of size 100005, initialized to 0 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 print n / 2 ;  $  TAB1 for i = 1 to n / 2 exclusive, print 2, " " ;  $  TAB1 if n is odd ;  $  TAB2 print 3 ;  $  TAB1 else ;  $  TAB2 print 2 ;
TAB0 let r be an array of integers size 100003 ;  $  TAB1 a,b,c,d,e,f,g,h,i,j,k,l,flag,cnt = integers and r,r2,r3 = array of integers size 1000 ;  $  TAB1 s,t = strings ;  $  TAB1 while (read s) is true do the following ;  $  TAB2 set cnt = 0 ;  $  TAB2 set sizeof(r) bytes starting at r to 0 ;  $  TAB2 for b=0 to size of s exclusive do the following ;  $  TAB3 if s[b] is 'B' ;  $  TAB4 increment r[1] ;  $  TAB3 else if s[b] is 'u' ;  $  TAB4 increment r[2] ;  $  TAB3 else if s[b] is 'l' ;  $  TAB4 increment r[3] ;  $  TAB3 else if s[b] is 'b' ;  $  TAB4 increment r[4] ;  $  TAB3 else if s[b] is 'a' ;  $  TAB4 increment r[5] ;  $  TAB3 else if s[b] is 's' ;  $  TAB4 increment r[6] ;  $  TAB3 else if s[b] is 'r' ;  $  TAB4 increment r[7] ;  $  TAB2 while (1) is true do the following until exit ;  $  TAB3 set flag = 1 ;  $  TAB3 for c=1 to 7 inclusive do the following ;  $  TAB4 if c is 1 do the following ;  $  TAB5 if r[1] is greater than or equal to 1 ;  $  TAB6 set r[1] = r[1] -1 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB4 if c is 2 do the following ;  $  TAB5 if r[2] is greater than or equal to 2 ;  $  TAB6 set r[2] = r[2] -2 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB4 if c is 3 ;  $  TAB5 if r[3] is greater than or equal to 1 ;  $  TAB6 set r[3] = r[3] -1 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB4 if c is 4 ;  $  TAB5 if r[4] is greater than or equal to 1 ;  $  TAB6 set r[4] = r[4] -1 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB4 ifc is 5 ;  $  TAB5 if r[5] is greater than or equal to 2 ;  $  TAB6 set r[5] = r[5] -2 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB4 if c is 6 ;  $  TAB5 if r[6] is greater than or equal to 1 ;  $  TAB6 set r[6] = r[6] -1 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB4 if c is 7 ;  $  TAB5 if r[7] is greater than or equal to 1 ;  $  TAB6 set r[7] = r[7] -1 ;  $  TAB5 else ;  $  TAB6 set flag = 0 ;  $  TAB3 if flag is 1 ;  $  TAB4 increment cnt ;  $  TAB3 else ;  $  TAB4 exit from loop ;  $  TAB2 print cnt ;
TAB1 create integers a, b, i, array aa of size 1000 + 5, co = 0, s = 0 ;  $  TAB1 read a and b ;  $  TAB1 for i = 0 to a exclusive ;  $  TAB2 read aa[i] ;  $  TAB2 increase s by aa[i] ;  $  TAB1 set s to abs of s ;  $  TAB1 while s greater than 0 ;  $  TAB2 subtract b from s ;  $  TAB2 increment co ;  $  TAB1 print co ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let s be a string ;  $  TAB1 input s ;  $  TAB1 let y and l be integers both set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is the character 0 ;  $  TAB3 increment l ;  $  TAB2 else ;  $  TAB3 increment y ;  $  TAB1 display absolute value of (y - 1) ;
TAB1 create int t, s, a, b, c, q, o, r ;  $  TAB1 read a, b, c ;  $  TAB1 create int array temp of size 3 initialized to { a, b, c } ;  $  TAB1 if a + b greater than c and b + c greater than a and c + a greater than b ;  $  TAB2 print 0 ;  $  TAB1 sort temp from elements 0 to 3 ;  $  TAB1 if temp[0] + temp[1] less than or equal to temp[2] then print temp[2] - (temp[0] + temp[1]) + 1 ;
TAB1 make ints n and c ;  $  TAB1 read n ;  $  TAB1 make integer f = 0 ;  $  TAB1 make array a with size of 101, initialized to 0 ;  $  TAB1 while n decrement ;  $  TAB2 read c ;  $  TAB2 increment a[c] ;  $  TAB2 set f to max of f and a[c] ;  $  TAB1 print f ;
TAB0 let s = array of characters with size = 100 ;  $  TAB1 read s ;  $  TAB1 let len = length of s ;  $  TAB1 let ans = integer with value = 0 ;  $  TAB1 for integer i=0 to len exclusive do the following ;  $  TAB2 if s[i] is a or s[i] is e or s[i] is i or s[i] is o or s[i] is u increment ans ;  $  TAB2 if s[i] is 1 or s[i] is 3 or s[i] is 5 or s[i] is 7 or s[i] is 9 increment ans ;  $  TAB1 print ans ;
TAB0 make constant integer INF = 1e9 ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make vector<bool> res with n elements ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make integer a ;  $  TAB2 read a ;  $  TAB2 if 360 mod (180 - a) ;  $  TAB3 assign false to res[i] ;  $  TAB2 else ;  $  TAB3 assign true to res[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if res[i] ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 arr is an integer array of sizes 100 and 100, count is an integer set to 0 ;  $  TAB1 n, m are integers ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive, read arr[i][j] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if arr[1][j], arr[i][1], arr[n][j], or arr[i][m] are 1, set count to 2 ;  $  TAB1 if count is 2 ;  $  TAB2 display 2 ;  $  TAB1 else ;  $  TAB2 display 4 ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make integer array a of length 7 ;  $  TAB1 make integer array b of length 7 ;  $  TAB1 make integers t1 and t2 ;  $  TAB1 fill a with 0 ;  $  TAB1 fill b with 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t1 ;  $  TAB2 increment a[t1] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t2 ;  $  TAB2 increment b[t2] ;  $  TAB1 make integers a1, a2, and count1 = 0 ;  $  TAB1 make integer flag = 0 ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if a[i] + b[i] is equal to 0, continue ;  $  TAB2 if a[i] is greater than b[i] ;  $  TAB3 set a1 to a[i] ;  $  TAB3 set a2 to b[i] ;  $  TAB2 else ;  $  TAB3 set a1 to b[i] ;  $  TAB3 set a2 to a[i] ;  $  TAB2 if (a1 - a2) is odd ;  $  TAB3 print "-1" ;  $  TAB3 set flag to 1 ;  $  TAB3 break ;  $  TAB2 increase count1 by (a1 - a2) / 2 ;  $  TAB1 if flag is equal to 0, print count1 / 2 ;
TAB2 n, k are long longs ;  $  TAB2 read n, k ;  $  TAB2 if k mod n isn't 0 ;  $  TAB3 print k / n + 1 ;  $  TAB2 else ;  $  TAB3 print k / n ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 set n = n * 2 ;  $  TAB1 let ans = boolean with value false ;  $  TAB1 let sqr = integer with value = square root of n rounded up ;  $  TAB1 for integer i=1 to sqr inclusive do the following ;  $  TAB2 let l, r, j = integers with l=1 and r = sqr ;  $  TAB2 wile l is less than or equal to r do the following ;  $  TAB3 set j = l + (r - 1) / 2 ;  $  TAB3 let integer t = i * (i + 1) + j * (j + 1) ;  $  TAB3 if t is n do the following ;  $  TAB4 set ans = true ;  $  TAB4 exit the loop ;  $  TAB3 else if t is less than n ;  $  TAB4 set l = j + 1 ;  $  TAB3 else ;  $  TAB4 set r = j - 1 ;  $  TAB2 if ans is true exit the loop ;  $  TAB1 if ans is true print YES else print NO ;
TAB0 sz, tot, pt are constant long longs with sz = 5e6 + 5, tot = 1e7 + 5, pt = 666e3 ;  $  TAB0 ara = boolean array of size sz ;  $  TAB0 in function makePrimes ;  $  TAB1 i, j, r, k are long longs with k = 1 ;  $  TAB1 for i = 0 to sz exclusive, set ara[i] to 1 ;  $  TAB1 set r to square root tot ;  $  TAB1 for i = 1 to r / 2 inclusive ;  $  TAB2 if ara[i] equals 1 ;  $  TAB3 ((2 * i + 1) * (2 * i + 1) - 1) / 2 as long as j is at most sz with increment j + (2 * i + 1), set ara[j] to 0 ;  $  TAB1 call makePrimes ;  $  TAB1 n, m, i are long longs ;  $  TAB1 read n ;  $  TAB1 for i = 1 with increment i + 1 ;  $  TAB2 x = long long = n * i + 1 ;  $  TAB2 if x is even and x isn't 2 ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 if ara[(x - 1) / 2] equals 0, break ;  $  TAB1 display i ;
TAB1 n = integer, a and b are both integer arrays both of size 102 ;  $  TAB1 k, cnt, res are all integers all set to 0 ;  $  TAB1 let vis be an integer array of size 102 with vis = 0 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input a[i] ;  $  TAB2 increment k ;  $  TAB2 if a[i] is negative, increment cnt ;  $  TAB2 if cnt is greater than 2 ;  $  TAB3 increment res ;  $  TAB3 assign k - 1 to b[res] ;  $  TAB3 assign 1 to k ;  $  TAB3 assign 1 to cnt ;  $  TAB3 assign 1 to vis[i - 1] ;  $  TAB1 assign 0 to both cnt and k ;  $  TAB1 for i = n to 1 inclusive with decrement i ;  $  TAB2 if vis[i], break ;  $  TAB2 increment k ;  $  TAB2 if a[i] is negative, increment cnt ;  $  TAB1 if cnt is true, increment res ;  $  TAB1 if res is equal to 0, increment res ;  $  TAB1 assign k to b[res] ;  $  TAB1 display res ;  $  TAB1 for i = 1 to res inclusive, display b[i] and ' ' ;  $  TAB1 display b[res] ;
TAB1 let n, k be integers ;  $  TAB1 let cont be an integer set to 0 ;  $  TAB1 read n, k ;  $  TAB1 while true ;  $  TAB2 if n is less than k and n is greater than 50 ;  $  TAB3 if k equals 0, read n, k ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 b = integer = 50 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a is an integer ;  $  TAB2 read a ;  $  TAB2 if a is positive and cont is less than k ;  $  TAB3 increment cont ;  $  TAB2 else if a equals b and cont is at least k ;  $  TAB3 increment cont ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB2 set b to a ;  $  TAB1 display cont ;
TAB1 let n = integer ;  $  TAB1 let L = unsigned long integer ;  $  TAB1 let s = string ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read s ;  $  TAB2 set L = length of s ;  $  TAB2 if L is less than 10 ;  $  TAB3 print s[0] and L - 2 and s[L - 1] ;  $  TAB2 else ;  $  TAB3 print s ;
TAB1 let n, m, c, echo be integers with c and echo both set to 0 ;  $  TAB1 let alpha be a boolean ;  $  TAB1 let str be a string ;  $  TAB1 input n and m ;  $  TAB1 iterate m - 1 times ;  $  TAB2 input str ;  $  TAB2 assign false to alpha ;  $  TAB2 iterate n - 1 times ;  $  TAB3 if str[i] is equal to the character 0 ;  $  TAB4 assign true to alpha ;  $  TAB4 increment c ;  $  TAB4 break ;  $  TAB2 set echo to call max with arguments echo, c ;  $  TAB2 if alpha is false, assign 0 to c ;  $  TAB1 display echo ;
TAB1 make int t, s, q ;  $  TAB1 read t, s, q ;  $  TAB1 make int i = 0 ;  $  TAB1 for ; s less than t; multiply s by s and q, increment i ;  $  TAB1 print i ;
TAB0 let k,sum,s be ints with sum=1 and s=0 and a be an integer array of size 3 ;  $  TAB1 read a[0], a[1], a[2], k ;  $  TAB1 create long long integer t=k/3 ;  $  TAB1 sort a and a+3 ;  $  TAB1 if a[0] + a[1] + a[2] - 3 <= k ;  $  TAB2 print a[0] * a[1] * a[2] and new line ;  $  TAB1 else do the following ;  $  TAB2 if a[0] - 1 < t ;  $  TAB3 increment s ;  $  TAB3 set sum = sum * a[0] ;  $  TAB3 set k= k - a[0] - 1 ;  $  TAB2 if s=1 ;  $  TAB3 if a[1] - 1 < k / 2 ;  $  TAB4 sum = sum * a[1] ;  $  TAB4 increment s ;  $  TAB4 k = k - a[1] - 1 ;  $  TAB2 if s=0 ;  $  TAB3 if k mod 3 is 2 ;  $  TAB4 set sum = (t + 1) * (t + 2) * (t + 2) ;  $  TAB3 else if k%3 is 1 ;  $  TAB4 set sum = (t + 1) * (t + 1) * (t + 2) ;  $  TAB3 else do the following ;  $  TAB4 set sum = (t + 1) * (t + 1) * (t + 1) ;  $  TAB2 if s is equal to 1 ;  $  TAB3 if k & 1 ;  $  TAB4 set sum = sum * (k / 2 + 1) * (k / 2 + 2) ;  $  TAB3 else do the following ;  $  TAB4 set sum = sum * (k / 2 + 1) * (k / 2 + 1) ;  $  TAB2 if s=2 then set sum=sum*(k+1) ;  $  TAB1 print sum ;
TAB0 let n = integer ;  $  TAB1 let a, b, c = strings ;  $  TAB1 read a, b, c ;  $  TAB1 print a and a space and b ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 read c ;  $  TAB2 if a is c do the following ;  $  TAB3 read a ;  $  TAB3 print a and a space and b ;  $  TAB2 else do the following ;  $  TAB3 read b ;  $  TAB3 print a and a space and b ;
TAB1 n is a long long ;  $  TAB1 read n ;  $  TAB1 cnt is a long long initialized to 1 ;  $  TAB1 while n is divisible by 3, divide n by 3 ;  $  TAB1 ans is a long long with ans = (n + 2) / 3 ;  $  TAB1 display ans ;
TAB1 n,m,sum,s = long long integers and sum = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n-1 exclusive do the following ;  $  TAB2 read m ;  $  TAB2 sum = sum + m ;  $  TAB1 s = n * (n+1) ;  $  TAB1 s = s/2 ;  $  TAB1 s = s - sum ;  $  TAB1 print s ;
TAB1 n, k, a = integers ;  $  TAB1 xx = array of integers with a length of 100005 ;  $  TAB1 while reading n and k ;  $  TAB2 b, c = integers set to 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read xx[i] ;  $  TAB3 if i is k ;  $  TAB4 set a to xx[i] ;  $  TAB4 set c to i ;  $  TAB3 if i > k and xx[i] isn't a, set b to 1 ;  $  TAB2 if b is 0 ;  $  TAB3 for i = k - 1 to 0 inclusive, decrementing i by 1 ;  $  TAB4 if xx[i] isn't a ;  $  TAB5 set b to i ;  $  TAB5 break ;  $  TAB3 print b ;  $  TAB3 ; ;  $  TAB2 else ;  $  TAB3 print "-1" ;
TAB1 n=integer ;  $  TAB1 a,b = integer ;  $  TAB1 create integers cnt1 and cnt2 with values 0 ;  $  TAB1 read n ;  $  TAB1 while n is true decrement n and do the following ;  $  TAB2 read a and b ;  $  TAB2 if a>0 then add 1 to cnt1 ;  $  TAB2 if a is less than 0 then increment cnt2 ;  $  TAB1 if cnt1<=1 or cnt2 <=1 ;  $  TAB2 print Yes and a new line ;  $  TAB1 else do the following ;  $  TAB2 print No ;
TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 for i = 0 to length of str exclusive ;  $  TAB2 create integer a = str[i] - 48 ;  $  TAB2 if a is greater than 4, set a to 9 - a ;  $  TAB2 if not a and not i, continue ;  $  TAB2 set str[i] to a + '0' ;  $  TAB1 print str ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 arr= array of integer of size n ;  $  TAB1 read n values into the array arr ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 for j=0 to n-i-1 exclusive ;  $  TAB3 if arr[j] > arr[j+1] then swap arr[j] and arr[j+1] ;  $  TAB1 if n mod 2 is 0 ;  $  TAB2 print arr[n/2-1] ;  $  TAB1 else do the following ;  $  TAB2 print arr[n/2] and new line ;
TAB1 let s be a string ;  $  TAB1 read s ;  $  TAB1 let n be a integer with n = length of s ;  $  TAB1 let asn be a boolean with value true ;  $  TAB1 create integer cnt_dit = 0 ;  $  TAB1 create integer cnt_lit = 0 ;  $  TAB1 create integer cnt_big = 0 ;  $  TAB1 if n<5 ;  $  TAB2 set ans= fales ;  $  TAB1 else do the following ;  $  TAB2 for i=0 to n inclusive ;  $  TAB3 if s[i] >= 0 and s[i] <= 9 ;  $  TAB4 incement cnt_dit ;  $  TAB3 else if s[i] >= 'A' and s[i] <= Z ;  $  TAB4 add 1 to cnt_big ;  $  TAB3 else if s[i]>= 'a' and s[i] <= 'z' ;  $  TAB4 add 1 to cnt_lit ;  $  TAB2 if cnt_dit < 1 or cnt_big < 1 or cnt_lit < 1 then set ans=false ;  $  TAB1 if ans is true ;  $  TAB2 print Correct ;  $  TAB1 else ;  $  TAB2 print Too weak ;
TAB0 let n, m be long long ;  $  TAB0 let start, endd be char ;  $  TAB0 let a, b be char array of size 80 ;  $  TAB0 define gcd which takes long long a, b as arguments and returns long long ;  $  TAB1 return a if b == 0 else gcd of b, a mod b ;  $  TAB0 define lcd which takes long long a, b as arguments and returns long long ;  $  TAB1 return a * (b / gcd of a, b) ;  $  TAB0 in solve ;  $  TAB1 let k, j be chart with k = start, j = start ;  $  TAB1 update n to n mod 4 ;  $  TAB1 for i = 0 to n exclusive, set k to a[k] ;  $  TAB1 for i = 0 to n exclusive, set j to b[j] ;  $  TAB1 if j == endd and k == endd ;  $  TAB2 print undefined ;  $  TAB1 else if k == endd ;  $  TAB2 print cw ;  $  TAB1 else ;  $  TAB2 print ccw ;  $  TAB1 set a['v'] to '<' ;  $  TAB1 set a['<'] to '^' ;  $  TAB1 set a['^'] to '>' ;  $  TAB1 set a['>'] to 'v' ;  $  TAB1 set a['v'] to '>' ;  $  TAB1 set a['>'] to '^' ;  $  TAB1 set a['^'] to '<' ;  $  TAB1 set a['<'] to 'v' ;  $  TAB1 read start, endd ;  $  TAB1 read n ;  $  TAB1 call solve ;
TAB1 make integer n1, n2(3) ;  $  TAB1 read n1 ;  $  TAB1 for i(0) to n1 exclusive ;  $  TAB2 make integer m ;  $  TAB2 read m ;  $  TAB2 if (n2 is 3 and m is 3) or (n2 is 4 and m is 2) or (n2 is 5 and m is 1) ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 set n2 to (6 - (n2 - m)) ;  $  TAB1 print "YES" ;
TAB0 make string s ;  $  TAB0 make int ans, n ;  $  TAB1 read n ;  $  TAB1 cin.ignore() ;  $  TAB1 read line into s ;  $  TAB1 make int res = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] is greater than or equal to 'A' and s[i] is less than or equal to 'Z' ;  $  TAB3 increment res ;  $  TAB2 else if s[i] is equal to ' ' ;  $  TAB3 assign max of ans and res to ans ;  $  TAB3 assign 0 to res ;  $  TAB1 assign max of ans and res to ans ;  $  TAB1 print ans ;
TAB0 in function compute ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 a = integer array of size n ;  $  TAB1 read n values into array a ;  $  TAB1 res = integer = 0 ;  $  TAB1 for i = 0 to (length of s) - 1 inclusive ;  $  TAB2 if s[i] is the character R and s[i + 1] is the character L, set res to call min with (a[i + 1] - a[i]) / 2, res if res isn't 0, otherwise set res to (a[i + 1] - a[i]) / 2 ;  $  TAB1 print -1, newline if res is 0, otherwise print res, newline ;  $  TAB1 call compute ;
TAB0 make constant integer mx = 1e5 + 10 ;  $  TAB0 make long long int sq array with mx elements ;  $  TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 read n values into sq ;  $  TAB1 make long long int ans = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make int t =0 ;  $  TAB2 make int j = i ;  $  TAB2 while sq[j] is equal to sq[i] and j is less than n ;  $  TAB3 increment j ;  $  TAB3 increment t ;  $  TAB2 add (1 + t) * t cast to long long int / 2 to ans ;  $  TAB2 set i to j - 1 ;  $  TAB1 print ans ;
TAB1 let n, a, b = long long integers with a = 0, b = 0 ;  $  TAB1 read n ;  $  TAB1 for integer i=o to n exclusive do the following ;  $  TAB2 let x = long long integer ;  $  TAB2 read x ;  $  TAB2 set a = a inclusive or x ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let x = long long integer ;  $  TAB2 read x ;  $  TAB2 set b= b inclusive or x ;  $  TAB1 print a + b ;  $  TAB1 return (6 is 000000) ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 define size_t pos = 0 ;  $  TAB1 while pos less than s length and s[pos] is not equal to 'h' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than s length and s[pos] is not equal to 'e' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than s length and s[pos] is not equal to 'l' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than s length and s[pos] is not equal to 'l' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than s length and s[pos] is not equal to 'o' do increment pos ;  $  TAB1 if pos less than length of s ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n = integer ;  $  TAB1 min1, min2, min3, max1, max2, max3 = integers ;  $  TAB1 S1, S2, S3 = integers ;  $  TAB1 read n and min1 and max1 and min2 and max2 and min3 and max3 ;  $  TAB1 if n is max1 + min2 + min3 do the following ;  $  TAB2 set S1 to max1 ;  $  TAB2 set S2 to min2 ;  $  TAB2 set S3 to min3 ;  $  TAB2 print S1 and a space and S2 and a space and S3 ;  $  TAB1 else if n is greater than max1+min2+min3 do the following ;  $  TAB2 S1= max1 ;  $  TAB2 if (n - S1 - max2) is min3 do the following ;  $  TAB3 S2 = max2 ;  $  TAB3 S3 = min3 ;  $  TAB2 else if (n - S1 - max2) is greater than min3 do the following ;  $  TAB3 S2 = max2 ;  $  TAB3 S3 = n1 - S1 - S2 ;  $  TAB2 else do the following ;  $  TAB3 S2 = n - S1 - min3 ;  $  TAB3 S3=min3 ;  $  TAB2 print S1 and a space and S2 and a space and S3 ;  $  TAB1 else ;  $  TAB2 S1 = n - min2 - min3 ;  $  TAB2 S2 = min2 ;  $  TAB2 S3 = min3 ;  $  TAB2 print S1 and a space and S2 and a space and S3 ;
TAB1 n is a long long ;  $  TAB1 input n ;  $  TAB1 num is a long long array of size n ;  $  TAB1 Min is a long long with Min = 9999999999 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input num[i] ;  $  TAB2 set Min to call min with arguments Min, num[i] ;  $  TAB1 mindiff is a long long with mindiff = 9999999999 ;  $  TAB1 Count is a long long with Count = 0 ;  $  TAB1 flg is a long long with flg = -1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if num[i] is equal to Min ;  $  TAB3 if flg is equal to 0 ;  $  TAB4 set mindiff to call min with arguments mindiff, Count ;  $  TAB4 set Count to 0 ;  $  TAB3 else ;  $  TAB4 set flg to 0 ;  $  TAB2 if flag equals 0, increment Count ;  $  TAB1 display mindiff ;
TAB0 ABC = constant integer = 1e6 + 6 ;  $  TAB0 create a function speed ;  $  TAB1 flag = boolean = true ;  $  TAB1 call speed ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 ch = character array of sizes n and n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, read ch[i][j] ;  $  TAB1 a = character array of sizes 0 and 0 ;  $  TAB1 b = character array of sizes 0 and 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if i equals j ;  $  TAB4 if ch[i][j] isn't a, set flag to false ;  $  TAB3 else if i equals n - 1 - j ;  $  TAB4 if ch[i][j] isn't a, set flag to false ;  $  TAB3 else ;  $  TAB4 if ch[i][j] equals a or ch[i][j] isn't b, set flag to false ;  $  TAB1 if flag ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB1 n,c = arrays of integers with all elements set to 0 ;  $  TAB1 str, str2 = strings ;  $  TAB1 read str, str2 ;  $  TAB1 while c is less than the length of str2, dothe following ;  $  TAB2 if str[n] is str2[c] increment n ;  $  TAB2 increment c ;  $  TAB1 print n+1 ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let arr = n arrays of integers of size n ;  $  TAB1 let row, col = array of integers of size n ;  $  TAB1 set sizeof(row) bytes starting at row to 0 ;  $  TAB1 set sizeof(col) bytes starting at col to 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to n exclusive do the following ;  $  TAB3 read arr[i][j] ;  $  TAB3 set row[i] = row[i] + arr[i][j] ;  $  TAB3 set col[j] = col[j] + arr[i][j] ;  $  TAB1 let count = integer with value 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to n exclusive ;  $  TAB3 if col[j] - row[i] is greater than 0 increment count ;  $  TAB1 print count ;
TAB1 create int n and arrays arr length 100000 and prr length 100000 ;  $  TAB1 create int ans = 0 and price = INT_MAX ;  $  TAB1 read n ;  $  TAB1 read n values into arr and prr ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 assign min of price and prr[i] to price ;  $  TAB2 increase ans by price * arr[i] ;  $  TAB1 print ans ;
TAB1 n,l,r,ql,qr = integers ;  $  TAB1 create integer min_result= INT_MAX ;  $  TAB1 read n,l,r,ql,qr ;  $  TAB1 w= integer vector of size n+1 ;  $  TAB1 set first element of w to 0 ;  $  TAB1 x=integer ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 set w[i] to x+w[i-1] ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 create integer wl = w[i] ;  $  TAB2 create integer wr= w[n]-w[i] ;  $  TAB2 create integer nl=i ;  $  TAB2 create integer nr=n-i ;  $  TAB2 create integer p = wl*l + wr*r ;  $  TAB2 create integer d = nl - nr ;  $  TAB2 create integer = absolute value of d ;  $  TAB2 create integer pen ;  $  TAB2 if ad=n ;  $  TAB3 set pen= n-1 ;  $  TAB2 else if ad>=2 ;  $  TAB3 set pen to ad-1 ;  $  TAB2 else do the following ;  $  TAB3 set pen to 0 ;  $  TAB2 if d>0 ;  $  TAB3 set p = p + pen * q1 ;  $  TAB2 else do the following ;  $  TAB3 set p = p + pen * qr ;  $  TAB2 set min_result to minimum of min_result and p ;  $  TAB1 print min_result ;
TAB1 let n = long long ;  $  TAB1 read n ;  $  TAB1 if n is 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 let a, b = strings ;  $  TAB1 read a, b ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 print a and a space and b ;  $  TAB2 let killed, newPerson = strings ;  $  TAB2 read killed, newPerson ;  $  TAB2 if a is killed ;  $  TAB3 set a = newPerson ;  $  TAB2 else ;  $  TAB3 set b = newPerson ;  $  TAB1 print a and a space and b ;
TAB0 maxn = constant integer = 205 ;  $  TAB0 t, s, q are integers ;  $  TAB0 ans = integer = 0 ;  $  TAB0 declare an integer x ;  $  TAB1 read t, s, q ;  $  TAB1 while s is less than t ;  $  TAB2 multiply s by q ;  $  TAB2 increment ans ;  $  TAB1 output ans ;
TAB1 make ints n, s, i ;  $  TAB1 read n and s ;  $  TAB1 make int arrays station1 and station2, both with length of n ;  $  TAB1 read n values into station1 ;  $  TAB1 read n values into station2 ;  $  TAB1 if station1[0] is 0 ;  $  TAB2 print "NO" ;  $  TAB2 exit with status 0 ;  $  TAB1 else if station1[s - 1] ;  $  TAB2 print "YES" ;  $  TAB2 exit with status 0 ;  $  TAB1 else if station2[s - 1] is 0 ;  $  TAB2 print "NO" ;  $  TAB2 exit with status 0 ;  $  TAB1 else ;  $  TAB2 for i = s - 1 to n exclusive ;  $  TAB3 if station1[i] BITWISE AND station2[i] ;  $  TAB4 print "YES" ;  $  TAB4 exit with status 0 ;  $  TAB2 print "NO" ;
TAB1 declare stack<char> st ;  $  TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 for i = size of s - 1 to 0 inclusive ;  $  TAB2 define char c = s[i] ;  $  TAB2 if st is not empty and top of st equals c ;  $  TAB3 pop st ;  $  TAB2 else ;  $  TAB3 push c onto st ;  $  TAB1 declare stack<char> t ;  $  TAB1 while st is not empty ;  $  TAB2 define char a = top of st ;  $  TAB2 print a ;  $  TAB2 pop st ;  $  TAB1 print newline ;
TAB1 a,b,r =integers ;  $  TAB1 read a,b,r ;  $  TAB1 set r=r*2 ;  $  TAB1 if r>a or r>b ;  $  TAB2 print Second ;  $  TAB1 else do the following ;  $  TAB2 print First ;
TAB0 let a be an integer array of size 110000 ;  $  TAB0 let b be an integer array of size 110000 ;  $  TAB0 let c be an integer array of size 110000 ;  $  TAB1 n = integer ;  $  TAB1 while input n ;  $  TAB2 ans = integer = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 input a[i] ;  $  TAB3 if a[i] is greater than a[i - 1] ;  $  TAB4 assign b[i - 1] + 1 to b[i] ;  $  TAB3 else ;  $  TAB4 assign 1 to b[i] ;  $  TAB3 assign function call max with arguments ans, b[i] to ans ;  $  TAB2 if ans is less than n, increment ans ;  $  TAB2 for i = n - 1 to 0 inclusive ;  $  TAB3 if a[i] is less than a[i + 1] ;  $  TAB4 assign c[i + 1] + 1 to c[i] ;  $  TAB3 else ;  $  TAB4 assign 1 to c[i] ;  $  TAB3 if a[i + 1] - a[i - 1] is greater than 1, set ans to call function max with arguments ans, c[i + 1] + b[i - 1] + 1 ;  $  TAB2 display ans ;
TAB1 declare doubles a1, a, b, c, d, e, f ;  $  TAB1 read a, b, c, d, e, f ;  $  TAB1 set a1 to 1 / a * b / c * d / e * f ;  $  TAB1 if c equals 0 and d is greater than 0 ;  $  TAB2 print "Ron" ;  $  TAB1 else if a == 0 and b is greater than 0 and d is greater than 0 ;  $  TAB2 print "Ron" ;  $  TAB1 else if a1 is greater than 1 ;  $  TAB2 print "Ron" ;  $  TAB1 else ;  $  TAB2 print "Hermione" ;
TAB0 let movement be an integer ;  $  TAB1 a, p are integer arrays both of size 100010, current_minimum, n, min_price are integers with min_price = 0 ;  $  TAB1 input n ;  $  TAB1 read n values into arrays a and p ;  $  TAB1 assign p[1] to current_minimum ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if p[i] is less than current_minimum, assign p[i] to current_minimum ;  $  TAB2 add a[i] * current_minimum to min_price ;  $  TAB1 print min_price ;
TAB1 s is a string ;  $  TAB1 input s ;  $  TAB1 c and count are integers with count = 0 ;  $  TAB1 for i = 0 to the length of s exclusive ;  $  TAB2 assign 1 to c ;  $  TAB2 for j = i + 1 to the length of s and s[i] equals s[j] with increment j and increment i, add 1 to c ;  $  TAB2 if c is even, increment count ;  $  TAB1 display count ;
TAB0 maxn = constant integer set to 1e7 + 5 ;  $  TAB0 n = integer ;  $  TAB0 x, y = integers ;  $  TAB0 cnt1 = integer ;  $  TAB0 cnt2 = integer ;  $  TAB1 read n ;  $  TAB1 while n is > 0 when decrementing by 1 ;  $  TAB2 read x and y ;  $  TAB2 if x <= 0 ;  $  TAB3 increment cnt1 by 1 ;  $  TAB2 else ;  $  TAB3 increment cnt2 by 1 ;  $  TAB1 if cnt1 > 1 and cnt2 > 1 ;  $  TAB2 print "No" ;  $  TAB1 else ;  $  TAB2 print "Yes" ;
TAB1 n, s = integers with s set to 0 ;  $  TAB1 read n ;  $  TAB1 while n != 0 ;  $  TAB2 if n >= 100 ;  $  TAB3 add n / 100 to s ;  $  TAB3 set n to n modulo 100 ;  $  TAB2 else if n >= 20 ;  $  TAB3 add n / 20 to s ;  $  TAB3 set n to n modulo 20 ;  $  TAB2 else if n >= 10 ;  $  TAB3 add n / 10 to s ;  $  TAB3 set n to n modulo 10 ;  $  TAB2 else if n >= 5 ;  $  TAB3 add n / 5 to s ;  $  TAB3 set n to n modulo 5 ;  $  TAB2 else if n >= 1 ;  $  TAB3 add n / 1 to s ;  $  TAB3 set n to n modulo 1 ;  $  TAB1 print s ;
TAB1 s, t, u, v are strings ;  $  TAB1 input s, t ;  $  TAB1 n, i are strings ;  $  TAB1 input n ;  $  TAB1 output s, " ", t ;  $  TAB1 iterate n times ;  $  TAB2 input u, v ;  $  TAB2 if u equals s ;  $  TAB3 assign v to s ;  $  TAB2 else ;  $  TAB3 assign v to t ;  $  TAB2 output s, " ", t ;
TAB0 let mp be map of long long to long long ;  $  TAB0 define add with long long a and w ;  $  TAB1 if find of mp with a is equal to end of mp, set mp[a] to 0 ;  $  TAB1 increment mp[a] by w ;  $  TAB0 define val with long long a and return type long long ;  $  TAB1 if find of mp with a is equal to end of mp, return 0 ;  $  TAB1 return mp[a] ;  $  TAB1 let t be integer ;  $  TAB1 read t ;  $  TAB1 while t is not zero, decrement t ;  $  TAB2 let s be integer ;  $  TAB2 read s ;  $  TAB2 if s is equal to 1 ;  $  TAB3 let u, v, w be long long ;  $  TAB3 read u, v, w ;  $  TAB3 while u is not equal to v ;  $  TAB4 if u is greater than v ;  $  TAB5 call add of u, w ;  $  TAB5 shift right u by 1 bit ;  $  TAB4 else ;  $  TAB5 call add of v, w ;  $  TAB5 shift right v by 1 bit ;  $  TAB2 else ;  $  TAB3 let u, v, ans be long long with ans = 0 ;  $  TAB3 read u, v ;  $  TAB3 while v is not equal to u ;  $  TAB4 if u is greater than v ;  $  TAB5 increment ans by val of u ;  $  TAB5 shift u right by 1 ;  $  TAB4 else ;  $  TAB5 increment ans by val of v ;  $  TAB5 shift v right by 1 bit ;  $  TAB3 print out ans with newline ;
TAB1 a, b, c, x, y, z are integers ;  $  TAB1 read a, b, c ;  $  TAB1 for i = 1 to a inclusive ;  $  TAB2 if a modulo i equals 0 ;  $  TAB3 assign i to x ;  $  TAB3 assign a / i to y ;  $  TAB3 if b modulo x equals 0 ;  $  TAB4 assign b / x to z ;  $  TAB4 if c modulo z equals 0 and c / z equals y, break ;  $  TAB3 else if b modulo y equals 0 ;  $  TAB4 assign b / y to z ;  $  TAB4 if c modulo z equals 0 and c / z equals x, break ;  $  TAB1 display (x + y + z) * 4 ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 cnt = integer = 0 ;  $  TAB1 while decrement n ;  $  TAB2 a, b are integers ;  $  TAB2 read a, b ;  $  TAB2 if b - a is at least 2, increment cnt ;  $  TAB1 output cnt ;
TAB1 n, k are integers ;  $  TAB1 read n, k ;  $  TAB1 iterate k times ;  $  TAB2 if n mod 10 isn't 0 ;  $  TAB3 decrement n ;  $  TAB2 else ;  $  TAB3 divide n by 10 ;  $  TAB1 output n ;
TAB0 n, m = integers ;  $  TAB0 s = string ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read m and s ;  $  TAB2 if m > 2 ;  $  TAB3 print "YES" ;  $  TAB3 print 2 ;  $  TAB3 print s[0] and " " ;  $  TAB3 for i = 1 to size of s exclusive, print s[i] ;  $  TAB2 else if s[0] < s[1] ;  $  TAB3 print "YES" ;  $  TAB3 print 2 ;  $  TAB3 print s[0], " ", s[1] ;  $  TAB2 else ;  $  TAB3 print "NO" ;  $  TAB2 endline ;
TAB1 n, result are long long integers, a = long long integer array of size 1000 ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 call sort with a, a + n ;  $  TAB1 set result to a[n - 1] - a[0] - n + 1 ;  $  TAB1 output result ;
TAB1 n, i, sum, cnt are integers with sum = 1, cnt = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 with condition n is positive with no increment ;  $  TAB2 increment cnt ;  $  TAB2 increment i ;  $  TAB2 add i to sum ;  $  TAB2 subtract sum from n ;  $  TAB1 display cnt ;
TAB0 make integer n ;  $  TAB0 make long long array a of size 100001 ;  $  TAB0 make long long array b of size 100001 ;  $  TAB0 make long long array dp of size 100001 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = 1 to n - 1 inclusive, set b[i] to abs of a[i] - a[i + 1] ;  $  TAB1 set dp[1] to 0 ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if i is even ;  $  TAB3 set dp[i] to dp[i - 1] + b[i - 1] ;  $  TAB2 else ;  $  TAB3 set dp[i] to dp[i - 1] - b[i - 1] ;  $  TAB1 sort elements in dp 1 through 1 + n ;  $  TAB1 print dp[n] - dp[1] ;
TAB1 let a = string ;  $  TAB1 read a ;  $  TAB1 print (size of a + 1) * 26 - size of a ;
TAB1 let q, n, i be integers ;  $  TAB1 s is a string ;  $  TAB1 input q ;  $  TAB1 for i = 0 to q exclusive ;  $  TAB2 input n ;  $  TAB2 if n equals 2 and s[0] is at least s[1] ;  $  TAB3 display NO ;  $  TAB2 else ;  $  TAB3 display YES 2, s[o], " ", substring of s from index 1 to index n ;
TAB1 create int Len, n ;  $  TAB1 create string s ;  $  TAB1 read n ;  $  TAB1 while n decremented ;  $  TAB2 read Len, s ;  $  TAB2 create bool Flag = true ;  $  TAB2 for i = 0 to Len / 2 exclusive ;  $  TAB3 create int Diff = abs of s[i] - s[Len - i - 1] ;  $  TAB3 if Diff is not equal to 0 and Diff is not equal to 2 ;  $  TAB4 set Flag to false ;  $  TAB4 print "NO" ;  $  TAB4 break ;  $  TAB2 if Flag, print "YES" ;
TAB0 let a and b be integer arrays both of size 100010 ;  $  TAB1 n = integer ;  $  TAB1 while input n ;  $  TAB2 for i = 0 to n exclusive, input a[i] and b[i] ;  $  TAB2 call function sort with arguments a, a + n ;  $  TAB2 call function sort with arguments b, b + n ;  $  TAB2 s = integer = 1 ;  $  TAB2 t = integer = 1 ;  $  TAB2 for i = 1 to n exclusive ;  $  TAB3 if a[i] isn't equal to a[i - 1], increment s ;  $  TAB3 if b[i] isn't equal to b[i - 1], increment t ;  $  TAB2 if s is less than or equal to t ;  $  TAB3 output s ;  $  TAB2 else ;  $  TAB3 output t ;
TAB1 declare long long int n ;  $  TAB1 read n ;  $  TAB1 if n greater than or equal to 0 ;  $  TAB2 print n ;  $  TAB1 else ;  $  TAB2 define long long int p = n * -1 ;  $  TAB2 define long long int digit1 = (n * -1) mod 10 ;  $  TAB2 set p to p / 10 ;  $  TAB2 define long long int digit2 = p mod 10 ;  $  TAB2 if digit1 is greater than or equal to digit2 ;  $  TAB3 print n / 10 ;  $  TAB2 else ;  $  TAB3 define long long int q = n mod 10 ;  $  TAB3 set n to n / 10 ;  $  TAB3 define long long int r = n mod 10 ;  $  TAB3 set n to n + q - r ;  $  TAB3 print n ;
TAB0 N = constant integer set to 35 ;  $  TAB1 n, i, j, count = integers, h and a = arrays of integers with length set to N ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read h[i] and a[i] ;  $  TAB1 for i = 0 to n exclusive, while setting count to 0 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if i is j, continue ;  $  TAB3 if h[i] is a[j], increase count by 1 ;  $  TAB1 print count ;
TAB1 n, i, cnt, res, a, b, c are integers with res = 0 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 assign 0 to cnt ;  $  TAB2 input a, b, c ;  $  TAB2 if a, increment cnt ;  $  TAB2 if b, increment cnt ;  $  TAB2 if c, increment cnt ;  $  TAB2 if cnt is at least 2, increment res ;  $  TAB1 print res ;
TAB0 in function comp with parameters integers a, b and return boolean ;  $  TAB1 return a is greater than b ;  $  TAB1 w, h, w1, w2, h1, h2 are integers ;  $  TAB1 read w, h, w1, w2, h1, h2 ;  $  TAB1 for x = h to 0 exclusive ;  $  TAB2 add x to w ;  $  TAB2 if x equals h1, subtract w1 from w ;  $  TAB2 if x equals h2, subtract w2 from w ;  $  TAB2 if w is negative, set w to 0 ;  $  TAB1 display w ;
TAB1 n and c are integers ;  $  TAB1 while input n and c ;  $  TAB2 a is an integer array of size 200005 ;  $  TAB2 read n values into array a ;  $  TAB2 cnt is an integer set to 1 ;  $  TAB2 for i = 1 to n exclusive ;  $  TAB3 if a[i] - a[i - 1] is at most c ;  $  TAB4 increment cnt ;  $  TAB3 else ;  $  TAB4 set cnt to 1 ;  $  TAB2 display cnt ;
TAB0 INF is a constant integer set to integer value of 2e9 ;  $  TAB0 EPS is a constant double set to double value of 1e-9 ;  $  TAB0 PI is a constant double set to double value of arccosine -1 ;  $  TAB0 MOD is a constant long long set to long long value of 1e9 + 7 ;  $  TAB0 in function gcd with parameters integers a, b and return integer ;  $  TAB1 if a is less than b, call swap with a, b ;  $  TAB1 if a is divisible by b, return b ;  $  TAB1 call gcd with a mod b, b ;  $  TAB0 in function palin with parameter string s and return boolean ;  $  TAB1 len is an integer set to length of s ;  $  TAB1 for i = 0 to len / 2 exclusive ;  $  TAB2 if s[i] isn't equal to s[len - 1 - i], return false ;  $  TAB1 return true ;  $  TAB0 create function fast_io ;  $  TAB1 s = string array of size 5, a = string, b = string ;  $  TAB1 n is an integer ;  $  TAB1 read s[0], s[1] ;  $  TAB1 display s[0], " ", s[1] ;  $  TAB1 input n ;  $  TAB1 while decrement n ;  $  TAB2 input a, b ;  $  TAB2 if s[0] is a ;  $  TAB3 assign b to s[0] ;  $  TAB2 else ;  $  TAB3 assign b to s[1] ;  $  TAB2 display s[0], " ", s[1] ;
TAB1 let n and p be integers ;  $  TAB1 input n and p ;  $  TAB1 let a be a string ;  $  TAB1 let b be an integer with b set to 97 ;  $  TAB1 for i = 0 to n exclusive, add 97 + i modulo p to a ;  $  TAB1 print a ;
TAB1 n,m = integer ;  $  TAB1 while n and m values entered are valid ;  $  TAB2 let v be an integer array of size 110 and l be an integer with value 0 ;  $  TAB2 for i=1 to n inclusive ;  $  TAB3 a,b=integer ;  $  TAB3 read a and b ;  $  TAB3 for j=a to b exclusive set v[j]=1 ;  $  TAB3 if b is equal to m set v[m]=1 ;  $  TAB2 create integer sw=0 ;  $  TAB2 for i=0 to m inclusive ;  $  TAB3 if v[i] is not equal to 1 set sw=1 ;  $  TAB2 if sw is 1 ;  $  TAB3 print NO ;  $  TAB2 else do the following ;  $  TAB3 print YES ;
TAB0 let mod = long long with value = 1000000007 ;  $  TAB0 let pi = double with value = 3.1415926535897932384626433832 ;  $  TAB0 declare long long integer function fast_exp taking in long long integers base and ex ;  $  TAB1 let res = long long integer with value = 1 ;  $  TAB1 while ex is greater than 0 do the following ;  $  TAB2 if ex is odd set res = (res * base) modulo mod ;  $  TAB2 set base = (base *base) modulo mod ;  $  TAB2 set ex = ex / 2 ;  $  TAB1 return res modulo mod ;  $  TAB0 declare long long integer function gcd taking in long long integers a and b ;  $  TAB1 if b is 0 return a ;  $  TAB1 return gcd(b, a modulo b) ;  $  TAB0 declare long long function fi taking in long longs a and b ;  $  TAB1 let o = long long with value = 1 ;  $  TAB1 for long long i=62 to 0 inclusive descending do the following ;  $  TAB2 let r = long long with value o left shift by i bits ;  $  TAB2 let k = long long with value = a and r ;  $  TAB2 if k is less than or equal to b set a = k ;  $  TAB1 return o ;  $  TAB0 declare long long function solve taking in long longs a and v ;  $  TAB1 if a is 0 return 0 ;  $  TAB1 let n = long long with value = return of call to fi on v and a ;  $  TAB1 if n is greater than a return 0 ;  $  TAB1 let o = long long with value = 1 ;  $  TAB1 let ans = long long with value = 0 ;  $  TAB1 let c = long long with value = __builtin_popcount(v) ;  $  TAB1 let w = long long with value = v ;  $  TAB1 for long long i=62 to 0 inclusive descending do the following ;  $  TAB2 let i = long long with value o left shift by i bits ;  $  TAB2 let t = long long with value = r & n ;  $  TAB2 let d = long long with value = r & v ;  $  TAB2 if t is 0 continue at top of loop ;  $  TAB2 if d is true do the following ;  $  TAB3 set w = w ^ r ;  $  TAB3 continue at top of loop ;  $  TAB2 let u = long long with value = __builtin_popcount(w) ;  $  TAB2 let first = long long with value = i - u ;  $  TAB2 set first = o left shift by first bits ;  $  TAB2 set ans = ans + first ;  $  TAB1 return ans ;  $  TAB1 let k, r = long longs ;  $  TAB1 read k, r ;  $  TAB1 for long long i=1 to 10 inclusive do the following ;  $  TAB2 let w = long long with value k * i ;  $  TAB2 if w modulo 10 is r or w modulo 10 is 0 do the folllowing ;  $  TAB3 print i ;
TAB0 let z be an integer ;  $  TAB0 let s be a string ;  $  TAB1 input s ;  $  TAB1 for a = the character a to the character z inclusive ;  $  TAB2 let c be an integer with c = 0 ;  $  TAB2 for i = 0 to the size of s exclusive ;  $  TAB3 if s[i] equals a, increment c ;  $  TAB2 if c, increment z ;  $  TAB1 if z is even ;  $  TAB2 print CHAT WITH HER! ;  $  TAB1 else ;  $  TAB2 print IGNORE HIM! ;
TAB0 create constant integer maxn= 1e5+100 ;  $  TAB0 let w and v be vector integer array of size maxn ;  $  TAB0 a= long long integer array of size maxn ;  $  TAB0 d= array of boolean of size maxn ;  $  TAB0 c= 2D long long integer array of size maxn by 5 ;  $  TAB0 n,m = long long integers ;  $  TAB0 mark= array of booleans of size maxn by 2 ;  $  TAB0 into the function dfs1 which takes a long long integer i ;  $  TAB1 set c[i][0] to 1 ;  $  TAB1 set mark[i][0] to 1 ;  $  TAB1 for y=0 to size of v[i] exclusive ;  $  TAB2 if mark[v[i][y]][0] is not true then call dfs1(v[i][y]) ;  $  TAB0 into the function dfs2 which takes a long long integer i ;  $  TAB1 set mark[i][1] = 1; ;  $  TAB1 set c[i][1] = 1 ;  $  TAB1 if a[i] = 1 then return ;  $  TAB1 for y=0 to size of w[i] exclusive ;  $  TAB2 if mark[w[i][y]][1] is false then call dfs2(w[i][y] ;  $  TAB1 read n and m ;  $  TAB1 for y=1 to n inclusive ;  $  TAB2 read a[y] ;  $  TAB2 if a[y] is 1 then add y to end of v[100000 + 1] ;  $  TAB2 if a[y] is 2 then add y to end of w[100000 + 1] ;  $  TAB1 while m is true, decrement m and do the following ;  $  TAB2 create long long integers i,j ;  $  TAB2 read i and j ;  $  TAB2 add i to end of v[i] ;  $  TAB2 add i to end of w[j] ;  $  TAB1 call dfs1 with argument 100000 + 1 ;  $  TAB1 call dfs2(100000 + 1) ;  $  TAB1 for y=0 to n inclsuive print c[y][0] && c[y][1] ;
TAB0 let MOD, maxN = integer constants with MOD = 1000000007 and maxN = 5005 ;  $  TAB0 let i, j, sum = integers with sum = 0 and dp = maxN arrays of integers of size maxN ;  $  TAB0 let s, t = string ;  $  TAB1 read s, t ;  $  TAB1 for i=1 to size of s inclusive do the following ;  $  TAB2 for j=1 to size of t inclusive do the following ;  $  TAB3 set dp[i][j] = dp[i][j-1] ;  $  TAB3 if s[i-1] is t[j-1] set dp[i][j] = dp[i][j] + dp[i-1][j-1] + 1 ;  $  TAB3 set dp[i][j] = dp[i][j] modulo MOD ;  $  TAB1 for i=1 to size of s inclusive set sum = dp[i][size of t] modulo MOS ;  $  TAB1 print sum ;
TAB1 make int n, freq = 1 ;  $  TAB1 pass ;  $  TAB1 read n ;  $  TAB1 make int ans = 0 ;  $  TAB1 make int min ;  $  TAB1 read min ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 make int temp ;  $  TAB2 read temp ;  $  TAB2 if temp is less than min ;  $  TAB3 set min to temp ;  $  TAB3 set ans to i ;  $  TAB3 set freq to 1 ;  $  TAB2 else if temp is equal to min ;  $  TAB3 add 1 to freq ;  $  TAB1 if freq is greater than 1 ;  $  TAB2 print "Still Rozdil" ;  $  TAB1 else ;  $  TAB2 print ans + 1 ;
TAB0 arr1= array of integer of size 110 ;  $  TAB0 arr2 =array of integer of size 110 ;  $  TAB1 create integr i,j,ind,count ,n with value ind=0 and count=0 ;  $  TAB1 read n ;  $  TAB1 read n values of array arr1 and arr2 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 set ind=0 ;  $  TAB2 for j=1 to n inclusive ;  $  TAB3 if i is not equal to j ;  $  TAB4 if arr2[j] = arr1[i] then set ind=1 ;  $  TAB2 if ind is false then increment count ;  $  TAB1 print count ;
TAB0 L is a constant integer set to 600 ;  $  TAB0 sum is an integer set to 1 ;  $  TAB0 a is an integer array with size 300 ;  $  TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i equals 1 ;  $  TAB3 display 2 ;  $  TAB2 else ;  $  TAB3 display long long i * (i + 1) * (i + 1) - long long (i - 1) ;
TAB0 declare int n ;  $  TAB0 define int array a of length 100005 initialized to 0 ;  $  TAB1 read n ;  $  TAB1 declare int b ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 read b ;  $  TAB2 increment a[b] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] equals 0: print i ;
TAB0 create constant integer inf = 0x3f3f3f3f ;  $  TAB0 create constant int mod = 2019 ;  $  TAB0 in the function init ;  $  TAB0 str = string ;  $  TAB0 let q and qa be integer arrays of size 105 and ans be an integer ;  $  TAB1 call init function ;  $  TAB1 read str ;  $  TAB1 for i=0 to size of str exclusive ;  $  TAB2 if i is not 0 then set q[i] to q[i-1] and set qa[i] to qa[ i-1] ;  $  TAB2 if str[i] is equal to Q ;  $  TAB3 increment q[i] and set ans = ans + qa[i] ;  $  TAB2 else if str[i] is equal to A ;  $  TAB3 set qa[i] = qa[i] + q[i] ;  $  TAB1 print ans and new line ;
TAB0 create int n, array a of size 1005 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 create int cnt = 0 ;  $  TAB1 for i = 2 to n exclusive ;  $  TAB2 if a[i] is greater than a[i - 1] and a[i] is greater than a[i + 1] ;  $  TAB3 increment cnt ;  $  TAB2 else if a[i] is less than a[i - 1] and a[i] is less than a[i + 1] ;  $  TAB3 increment cnt ;  $  TAB1 print cnt ;
TAB1 let k = string ;  $  TAB1 let r, temp, result = integers with result = 1 ;  $  TAB1 read k, r ;  $  TAB1 set temp = k[size of k - 1] - 48 ;  $  TAB1 if temp is 0 or temp - r is 0 ;  $  TAB2 print result ;  $  TAB1 else ;  $  TAB2 let i = integer with value = temp ;  $  TAB2 while temp modulo 10 is not equal to 0 and (temp - r) modulo 10 is not equal to 0 do the following ;  $  TAB3 set temp = temp + i ;  $  TAB3 increment result ;  $  TAB2 print result ;
TAB1 create long long integers n and k ;  $  TAB1 read n and k ;  $  TAB1 create long long integers i,j and array a of size n ;  $  TAB1 read n values into array i ;  $  TAB1 set i to 0 ;  $  TAB1 set j to n-1 ;  $  TAB1 create long long integer cnt=0 ;  $  TAB1 while a[i]<=k ;  $  TAB2 add 1 to cnt ;  $  TAB2 increment i ;  $  TAB1 while j>i and a[j]<=k ;  $  TAB2 increment cnt ;  $  TAB2 decrement j ;  $  TAB1 print cnt ;
TAB1 let n,k,l,max,min,n1,kl,l1 = integers and sum = integer value 0 ;  $  TAB1 let c = 40 arrays of long long size 40 initialized to 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read k, l ;  $  TAB2 set sum = 0 ;  $  TAB2 while k is not equal to 0 and l is not equal to 0 do the following ;  $  TAB3 if k is greater than l do the following ;  $  TAB4 set sum = sum + k/l ;  $  TAB4 set k = k - k / l * l ;  $  TAB3 else do the following ;  $  TAB4 set sum = sum + l / k ;  $  TAB4 set l = l - l / k * k ;  $  TAB2 print sum ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 for integer j=1 to n inclusive do the following ;  $  TAB3 if i is less than or equal to (n + 1) / 2 do the following ;  $  TAB4 if j is less than (n+1) / 2- i + 1 or j is greater than (n + 1) / 2 + i - 1 ;  $  TAB5 print * ;  $  TAB4 else ;  $  TAB5 print D ;  $  TAB3 else do the following ;  $  TAB4 if j is less than (n+1) / 2- n + i or j is greater than (n + 1) / 2 + n - i ;  $  TAB5 print * ;  $  TAB4 else ;  $  TAB5 print D ;  $  TAB2 print a new line ;
TAB1 n, l, r, ql, qr = int ;  $  TAB1 read n, l, r, ql, qr ;  $  TAB1 array arr = int[100010] ;  $  TAB1 for i = 0 to n exclusive: read arr[i] ;  $  TAB1 array sum = long long[100010] ;  $  TAB1 set sum[0] to 0 ;  $  TAB1 for i = 1 to n inclusive: set sum[i] to sum[i - 1] + arr[i - 1] ;  $  TAB1 let long long mini = 1e18 ;  $  TAB1 for j = 0 to n inclusive ;  $  TAB2 let int i = n - j ;  $  TAB2 let long long cnt = sum[i] * l + (sum[n] - sum[i]) * r ;  $  TAB2 if abs(i, j) ;  $  TAB3 if i greater than j ;  $  TAB4 increase cnt by (abs(i - j) - 1) * ql ;  $  TAB3 else ;  $  TAB4 increase cnt by (abs(i - j) - 1) * qr ;  $  TAB2 set mini to min(mini, cnt) ;  $  TAB1 print mini ;
TAB1 let x and q be integers ;  $  TAB1 input x and q ;  $  TAB1 for i = 1 with increment i + 1 ;  $  TAB2 if ((x * i) mod 10 equals 0) or ((x * i) mod 10 equals q) ;  $  TAB3 print i ;  $  TAB3 break ;
TAB1 create int n, c ;  $  TAB1 read n ;  $  TAB1 create int f = 0 ;  $  TAB1 create integer array a with 101 elements = { 0 } ;  $  TAB1 while n decremented ;  $  TAB2 read c ;  $  TAB2 increment a[c] ;  $  TAB2 set f to max of f and a[c] ;  $  TAB1 print f ;
TAB0 make const int maxn = 2e2 + 10 ;  $  TAB1 make int n, ans = 0 ;  $  TAB1 read n ;  $  TAB1 make string s ;  $  TAB1 while read s ;  $  TAB2 make int t = 0 ;  $  TAB2 for i = 0 to s size exclusive ;  $  TAB3 if s[i] less than or equal to 'Z' and s[i] greater than or equal to 'A' then increment t ;  $  TAB2 set ans to max of ans and t ;  $  TAB1 print ans ;
TAB0 n is an integer ;  $  TAB0 str is a string ;  $  TAB1 while input n ;  $  TAB2 input str ;  $  TAB2 if n is 1 ;  $  TAB3 display 1 ;  $  TAB2 else ;  $  TAB3 zero and one are both integers and are both set to 0 ;  $  TAB3 for i = 0 to n exclusive ;  $  TAB4 if str[i] is the character 0 ;  $  TAB5 increment zero ;  $  TAB4 else ;  $  TAB5 increment one ;  $  TAB4 ab is an integer with ab = call min with arguments zero, one ;  $  TAB4 subtract ab from zero ;  $  TAB4 subtract ab from one ;  $  TAB3 display zero + one ;
TAB1 n = integer ;  $  TAB1 g = two dimentional array of character, with a size of 200x200 ;  $  TAB1 set g['P']['S'] to 0 ;  $  TAB1 set g['P']['R'] to 1 ;  $  TAB1 set g['P']['P'] to -1 ;  $  TAB1 set g['S']['S'] to -1 ;  $  TAB1 set g['S']['R'] to 0 ;  $  TAB1 set g['S']['P'] to 1 ;  $  TAB1 set g['R']['S'] to 1 ;  $  TAB1 set g['R']['P'] to 0 ;  $  TAB1 set g['R']['R'] to -1 ;  $  TAB1 a, b = strings ;  $  TAB1 read n, a, and b ;  $  TAB1 cnt1, cnt2 = integers set to 0 ;  $  TAB1 m = integer set to size of a * size of b ;  $  TAB1 for i = 0 to size of a * size of b exclusive ;  $  TAB2 if a[a[i modulo size of a]][b[i modulo size of b]] is -1 ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 if g[a[i modulo size of a]][b[i modulo size of b]] ;  $  TAB4 increment cnt1 by 1 ;  $  TAB3 else ;  $  TAB4 increment cnt2 by 1 ;  $  TAB1 multiply cnt2 by n / m ;  $  TAB1 multiply cnt1 by n / m ;  $  TAB1 for i = 0 to n modulo m exclusive ;  $  TAB2 if g[a[i modulo size of a]][b[i modulo size of b]] is -1 ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 if g[a[i modulo size of a]][b[i modulo size of b]] ;  $  TAB4 increment cnt1 by 1 ;  $  TAB3 else ;  $  TAB4 increment cnt2 by 1 ;  $  TAB1 print cnt2, ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 D = integer set to n + 2 - 1 / 2 ;  $  TAB1 D1, D2 = integers, with D1 set to D - 1, and D2 set to D - 1 ;  $  TAB1 for i = 0 to D exclusive ;  $  TAB2 for t = 0 to n exclusive ;  $  TAB3 if t >= D1 and t <= D2 ;  $  TAB4 print "D" ;  $  TAB3 else ;  $  TAB4 print "*" ;  $  TAB2 endline ;  $  TAB2 decrement D1 by 1 ;  $  TAB2 increment D2 by 1 ;  $  TAB1 increment D1 by 2 ;  $  TAB1 decrement D2 by 2 ;  $  TAB1 for i = D to n exclusive ;  $  TAB2 for t = 0 to n exclusive ;  $  TAB3 if t >= D1 and t <= D2 ;  $  TAB4 print "D" ;  $  TAB3 else ;  $  TAB4 print "*" ;  $  TAB2 endline ;  $  TAB2 increment D1 by 1 ;  $  TAB2 decrement D2 by 1 ;
TAB1 let n be integer ;  $  TAB1 let a be integer array of size 1000 ;  $  TAB1 let b be integer array of size 1000 ;  $  TAB1 read n-1 entries of arr ;  $  TAB1 let flag be integer array of size 6 with flag = {0} ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment flag[a[i]] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 increment flag[b[i]] ;  $  TAB1 let sum be integer with sum = 0 ;  $  TAB1 fo i = 1 to 6 exclusive ;  $  TAB2 if flag[i] is odd ;  $  TAB3 print -1 ;  $  TAB2 let s1, s2 = integers = 0 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if a[j] == 1, increment s1 ;  $  TAB3 if b[j] == 1, increment s2 ;  $  TAB2 if s1 < flag[i]/2, increment sum by flag[i]/2 - s1 ;  $  TAB2 if s2 < flag[i]/2, increment sum by flag[i] / 2 - s2 ;  $  TAB1 print sum/2 ;
TAB1 make integers n and k ;  $  TAB1 read n, k ;  $  TAB1 if 3 * n greater than or equal to k ;  $  TAB2 print (n * 3 - k) ;  $  TAB1 else ;  $  TAB2 print 0 ;  $  TAB1 print newline ;
TAB1 first, second = strings ;  $  TAB1 read first and second ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 killed, victim = strings ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 print first, ' ', second ;  $  TAB2 read killed ;  $  TAB2 if killed is first ;  $  TAB3 read first ;  $  TAB2 else ;  $  TAB3 read second ;  $  TAB1 print first, ' ', second ;
TAB0 dayOfMonth = integer array set to 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ;  $  TAB1 day, month are integers ;  $  TAB1 sum = integer ;  $  TAB1 ans = integer = 1 ;  $  TAB1 read month, day ;  $  TAB1 set sum to dayOfMonth[month - 1] ;  $  TAB1 subtract (8 - day) from sum ;  $  TAB1 while sum is at least 7 ;  $  TAB2 increment ans ;  $  TAB2 subtract 7 from sum ;  $  TAB1 if sum is positive, increment ans ;  $  TAB1 display ans ;
TAB0 define const int INF = -1e9 ;  $  TAB0 declare int array dp of length 4400 ;  $  TAB0 declare int array a of length 3 ;  $  TAB1 declare int n ;  $  TAB1 while reading n is not interrupted ;  $  TAB2 read a[0], a[1], a[2] ;  $  TAB2 for i = 0 to 4400 exclusive: set dp[i] to INF ;  $  TAB2 set dp[0] to 0 ;  $  TAB2 for i = 0 to 3 exclusive ;  $  TAB3 for v = a[i] to n inclusive ;  $  TAB4 if dp[v - a[i]] does not equal INF: set dp[v] to max of dp[v] and dp[v - a[i]] + 1 ;  $  TAB2 print dp[n] ;
TAB1 c = string, a = array of strings length 10 ;  $  TAB1 read c ;  $  TAB1 for k = 0 to 10 exclusive, read a[k] ;  $  TAB1 for i = 0 to 8 exclusive ;  $  TAB2 b = string set to the substring of c of i * 10 and 10 ;  $  TAB2 for l = 0 to 10 exclusive ;  $  TAB3 if b is a[l] print l ;  $  TAB1 endline ;
TAB1 T, a, i are integers ;  $  TAB1 read T ;  $  TAB1 while decrement T ;  $  TAB2 read a ;  $  TAB2 for i = 3 to 500 inclusive ;  $  TAB3 if ((i - 2) * 180) / i equals a and ((i - 2) * 180) mod i equals 0 ;  $  TAB4 print YES ;  $  TAB4 break ;  $  TAB2 if i is greater than 500, print NO ;
TAB0 make const int maxn = 1e3 + 5 ;  $  TAB0 make int array arr of size maxn ;  $  TAB0 make int array hash1 of size maxn ;  $  TAB1 make integer n ;  $  TAB1 while reading n is not interrupted ;  $  TAB2 set hash1's elements to 0 ;  $  TAB2 make int ans = -1 bitwise shift left 30 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read arr[i] ;  $  TAB3 increment hash1[arr[i]] ;  $  TAB3 if ans less than hash1[arr[i]], set ans to hash1[arr[i]] ;  $  TAB2 print ans ;
TAB1 create int a, b ;  $  TAB1 read a, b ;  $  TAB1 create int b1 = 0 ;  $  TAB1 while b is greater than 0 ;  $  TAB2 create int d = b mod 10 ;  $  TAB2 set b1 to b1 * 10 + d ;  $  TAB2 set b to b / 10 ;  $  TAB1 print a + b1 ;
TAB1 create int n ;  $  TAB1 create string s ;  $  TAB1 create int ans = 0 ;  $  TAB1 create int num ;  $  TAB1 while read s ;  $  TAB2 set num to 0 ;  $  TAB2 for i = 0 to s length exclusive ;  $  TAB3 if isupper of s[i] then increment num ;  $  TAB2 set ans to max of ans and num ;  $  TAB1 print ans ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int result = 0 ;  $  TAB1 while n decremented is not 0 ;  $  TAB2 create ints i, j, x1, y1, x2, y2 ;  $  TAB2 read x1, y1, x2, y2 ;  $  TAB2 for i = x1 to x2 inclusive ;  $  TAB3 for j = y1 to y2 inclusive: increment result ;  $  TAB1 print result ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 output n / 2 + 1 ;
TAB1 let k, a, v, b, ans, i, j, count be integers with count = 0 ;  $  TAB1 read k, a, b, v ;  $  TAB1 while a > 0 ;  $  TAB2 set j t o 1 ;  $  TAB2 if b > 0 ;  $  TAB3 while j < k and b > 0 ;  $  TAB4 increment j ;  $  TAB4 decrement b ;  $  TAB2 decrement a by j*v ;  $  TAB2 increment count ;  $  TAB1 print count ;
TAB1 n=integer ;  $  TAB1 while n is valid read n and do the following ;  $  TAB2 let p be an integer with p=n ;  $  TAB2 a= array of integer of size 30 ;  $  TAB2 set a[0]=5 ;  $  TAB2 i=integer ;  $  TAB2 for i=1 to 30 exclusive set a[i] = 2 * a[i - 1] ;  $  TAB2 create integer k=0 ;  $  TAB2 for i=0 to 30 exclusive ;  $  TAB3 set k=k+a[i] ;  $  TAB3 if k>=p then break ;  $  TAB2 create integer v=0 ;  $  TAB2 create integer y=0 ;  $  TAB2 if k=p then set v=5 ;  $  TAB2 if k>p ;  $  TAB3 then set k=k-a[i] ;  $  TAB3 set y=p-k ;  $  TAB3 create integer u = y/pow(2.0,i) ;  $  TAB3 set v=u ;  $  TAB3 if power of 2.0 to i is not 1 then set v= u + 1 and increment u ;  $  TAB2 if v is 1 ;  $  TAB3 print Sheldon ;  $  TAB2 if v is 2 ;  $  TAB3 print Leonard ;  $  TAB2 if v is 3 ;  $  TAB3 print Penny ;  $  TAB2 if v is equal to 4 ;  $  TAB3 print Rajesh ;  $  TAB2 if v is 5 ;  $  TAB3 print Howard ;
TAB0 h= array of integer of size 111111 ;  $  TAB1 n=integer ;  $  TAB1 create long long integer x,y ;  $  TAB1 read n ;  $  TAB1 while n is true and decrement n ;  $  TAB2 read x,y ;  $  TAB2 create an long long integer cunt with cunt=0 ;  $  TAB2 for infinite ;  $  TAB3 if x<=0 or y<=0 then break ;  $  TAB3 if x<y ;  $  TAB4 set cunt=cunt+y/x ;  $  TAB4 set y=y mod x ;  $  TAB3 else do the following ;  $  TAB4 set cunt =cunt+x/y ;  $  TAB4 set x=x mod y ;  $  TAB2 print cunt ;
TAB1 let n, a be integers ;  $  TAB1 let v, u be integer vectors ;  $  TAB1 input n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input a ;  $  TAB2 append a to v ;  $  TAB1 call sort with beginning of v, end of v ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 while v[i] equals v[i + 1] and i is less than size of v, increment i ;  $  TAB2 if v[i] isn't 0, append v[i] to u ;  $  TAB1 print size of u ;
TAB0 let n, m be integers ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i is even ;  $  TAB3 if i isn't divisible by 4 ;  $  TAB4 for y = 1 to m exclusive, display . ;  $  TAB4 display # ;  $  TAB3 else ;  $  TAB4 display # ;  $  TAB4 for y = 1 to m exclusive, display . ;  $  TAB2 else ;  $  TAB3 for y = 0 to m exclusive, display # ;  $  TAB2 print newline ;
TAB1 let k, r = integer ;  $  TAB1 read k, r ;  $  TAB1 if k modulo 10 is 0 or k modulo 10 is r do the following ;  $  TAB2 print 1 ;  $  TAB1 for integer i=2 to 10 inclusive do the following ;  $  TAB2 if k * i modulo 10 is 0 or k * i modulo 10 is r do the following ;  $  TAB3 print i ;
TAB0 create set ss containign strings ;  $  TAB1 create string s ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s ;  $  TAB2 sort s ;  $  TAB2 erase first unique element in s ;  $  TAB2 insert s into ss ;  $  TAB1 print ss size ;  $  TAB1 return 0 XOR 0 ;
TAB1 n = integer, a = array of integers length 101 ;  $  TAB1 while reading n ;  $  TAB2 max = integer set to 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a[i] ;  $  TAB3 if a[i] > max, set max to a[i] ;  $  TAB2 cnt = integer set to 0 ;  $  TAB2 for i = 0 to n exclusive, add max - a[i] to cnt ;  $  TAB2 print cnt ;
TAB1 n, f, d are long long integers ;  $  TAB1 input n ;  $  TAB1 c is an integer with c = 0 ;  $  TAB1 declare long long integer g ;  $  TAB1 assign 10 to g ;  $  TAB1 while (n / g) isn't equal to 0 ;  $  TAB2 set f to the remainder of n divided by g ;  $  TAB2 set d to f / (g / 10) ;  $  TAB2 if d is equal to either 4 or 7, increment c ;  $  TAB2 set g to the product of g and 10 ;  $  TAB1 set f to the remainder of n divided by g ;  $  TAB1 set d to f / (g / 10) ;  $  TAB1 if d is equal to either 4 or 7, increment c ;  $  TAB1 if c is equal to either 4 or 7 ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB0 declare long long ans ;  $  TAB0 in function maxsum, return type long long, parameters long long p array, long long n ;  $  TAB1 define long long tmp = 0 ;  $  TAB1 for long long i = 0 to n exclusive ;  $  TAB2 set ans to max of ans and tmp ;  $  TAB2 increase tmp by p[i] ;  $  TAB2 if tmp less than 0, set tmp to 0 ;  $  TAB2 set ans to max of ans and tmp ;  $  TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 declare long long array a with a length of n ;  $  TAB1 for long long i = 0 to n exclusive, read a[i] ;  $  TAB1 declare long long b array with n as length ;  $  TAB1 declare long long c array with n as length ;  $  TAB1 for long long i = 0 to n - 1 exclusive ;  $  TAB2 set b[i] to abs of a[i] - a[i + 1] * (if i is even, 1; else, -1) ;  $  TAB2 set c[i] to abs of a[i] - a[i + 1] * (if i + 1 is even, 1; else, -1) ;  $  TAB1 maxsum(b, n - 1) ;  $  TAB1 maxsum(c, n - 1) ;  $  TAB1 print ans ;
TAB1 n=long long integer ;  $  TAB1 read n ;  $  TAB1 i= long long integer ;  $  TAB1 v= long long integer vector ;  $  TAB1 create a long long integer sum with sum=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 a= long long integer ;  $  TAB2 read a ;  $  TAB2 set sum=sum+a ;  $  TAB2 add a to the end of v ;  $  TAB1 x= long long integer ;  $  TAB1 create a long long integer summ with summ=0 ;  $  TAB1 if sum mod 2 = 0 ;  $  TAB2 set x=sum/2 ;  $  TAB1 else do the following ;  $  TAB2 set x = sum / 2 + 1 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set summ = summ + v[i] ;  $  TAB2 if summ >= x ;  $  TAB3 print i+1 ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 while n is not equal to 0 do the following ;  $  TAB2 if n modulo 1000 is 144 ;  $  TAB3 set n = n / 1000 ;  $  TAB2 else if n modulo 100 is 14 do the following ;  $  TAB3 set n / 100 ;  $  TAB2 else if n modulo 10 is 1 do the following ;  $  TAB3 set n = n / 10 ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB1 print YES ;
TAB1 declare int x, nx, n ;  $  TAB1 read x ;  $  TAB1 set n to x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 add 1 to x ;  $  TAB2 set nx to x ;  $  TAB2 define integer l = nx mod 10 ;  $  TAB2 set nx to nx / 10 ;  $  TAB2 define integer l2 = nx mod 10 ;  $  TAB2 set nx to nx / 10 ;  $  TAB2 define integer l3 = nx mod 10 ;  $  TAB2 set nx to nx / 10 ;  $  TAB2 define integer l4 = nx mod 10 ;  $  TAB2 if l not equal to l2 and l not equal to l3 and l not equal to l4 nad l2 not equal to l3 and l3 not equal to l4 and l3 not equal to l4, break ;  $  TAB1 print x ;
TAB0 define char array color of size 6 = {'R', 'O', 'Y', 'G', 'B', 'V'} ;  $  TAB0 declare vector<int> v ;  $  TAB0 declare int array tedad of size 300 ;  $  TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to s length do increment tedad[s[i]] ;  $  TAB1 declare vector<int> v ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 if tedad[color[i]] then push tedad[color[i]] onto v ;  $  TAB1 sort v ;  $  TAB1 if v size is 1 ;  $  TAB2 print 1 ;  $  TAB1 else if v size is 2 ;  $  TAB2 if v[0] is 1 ;  $  TAB3 print 1 ;  $  TAB2 else ;  $  TAB3 print 2 ;  $  TAB1 else if v size is 3 ;  $  TAB2 if v[0] is 1 ;  $  TAB3 if v[1] is 1 ;  $  TAB4 print 2 ;  $  TAB3 else ;  $  TAB4 print 3 ;  $  TAB2 else ;  $  TAB3 print 6 ;  $  TAB1 else if v size is 4 ;  $  TAB2 if v[3] is 3 ;  $  TAB3 print 5 ;  $  TAB2 else if v[3] is 2 ;  $  TAB3 print 8 ;  $  TAB1 else if v size is 5 ;  $  TAB2 print 15 ;  $  TAB1 else if v size is 6 ;  $  TAB2 print 30 ;
TAB1 n = long long ;  $  TAB1 input n ;  $  TAB1 let count be an integer with count = 0 ;  $  TAB1 while n is unequal to 0 ;  $  TAB2 if n modulo 10 equals 4 or n modulo 10 equals 7, increment count ;  $  TAB2 divide n by 10 ;  $  TAB1 if count is equal to 4 or count is equal to 7 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 inp1, inp2, res are strings ;  $  TAB1 read inp1, inp2 ;  $  TAB1 i is an integer with i set to 0 ;  $  TAB1 while inp[i] isn't null ;  $  TAB2 if inp1[i] doesn't equal inp2[i] ;  $  TAB3 display 1 ;  $  TAB2 else ;  $  TAB3 display 0 ;  $  TAB2 increment i ;  $  TAB1 print newline ;
TAB0 N = constant integer = 200010 ;  $  TAB0 n, t, ans, maxn are long longs ;  $  TAB0 m, ms are long long arrays of size N ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read m[i] ;  $  TAB2 for j = 1 to m[i] inclusive, read t, set ms[i] to call max with ms[i], t ;  $  TAB2 set maxn to call max with maxn, ms[i] ;  $  TAB1 for i = 1 to n inclusive, add m[i] * (maxn - ms[i]) to ans ;  $  TAB1 print ans ;
TAB1 a, b, s = integers ;  $  TAB1 read a, b and s ;  $  TAB1 d = integer set to absolute value of a + absolute value of b ;  $  TAB1 if d <= s and d ^ s & 1 is 0, print "Yes\n" if true and "No\n" if false ;
TAB1 let a, b, c, d be integers ;  $  TAB1 let x, y be integers ;  $  TAB1 read x ;  $  TAB1 set y to x ;  $  TAB1 if y >= 1987 and y < 2013 ;  $  TAB2 print 2013 ;  $  TAB2 ; ;  $  TAB1 if y < 1987 or y >= 2013 ;  $  TAB2 while true ;  $  TAB3 increment y and x ;  $  TAB3 set a to (y/1000) mod 10 ;  $  TAB3 set b to (y/100) mod 10 ;  $  TAB3 if a == b continue ;  $  TAB3 update c to (y/10) mod 10 ;  $  TAB3 if a == c or b == c, continue ;  $  TAB3 update d to y mod 10 ;  $  TAB3 if a == d or b == d or c == d, continue ;  $  TAB3 print x ;  $  TAB3 break ;
TAB1 n = t = count = ok = integers with count = ok = 0 ;  $  TAB1 read n, t ;  $  TAB1 let arr be array of integers of size n-1 ;  $  TAB1 read n-1 entries of arr ;  $  TAB1 for i = 0 to n-1 exclusive ;  $  TAB2 increment i by arr[i] ;  $  TAB2 if i == t-1 ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB1 create int n, x, d, p, counter = 0 ;  $  TAB1 create integer array a with 201 elements ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 assign 1 to a[i] ;  $  TAB2 assign 0 to a[0] ;  $  TAB1 read p ;  $  TAB1 while p decremented ;  $  TAB2 read x ;  $  TAB2 assign 0 to a[x] ;  $  TAB1 read d ;  $  TAB1 while d decremented ;  $  TAB2 read x ;  $  TAB2 assign 0 to a[x] ;  $  TAB1 for i = 0 to n inclusive do add a[i] to counter ;  $  TAB1 if counter equals 0 ;  $  TAB2 print "I become the guy." ;  $  TAB1 else ;  $  TAB2 print "Oh, my keyboard!" ;
TAB1 n, p, maxx are integers with maxx = 0 ;  $  TAB1 v is an integer vector ;  $  TAB1 read n ;  $  TAB1 iterate n times ;  $  TAB2 read p ;  $  TAB2 append p to v ;  $  TAB1 for i = 0 to size of v exclusive ;  $  TAB2 cnt = integer set to 0 ;  $  TAB2 for j = 0 to size of v exclusive ;  $  TAB3 if v[i] equals v[j], increment cnt ;  $  TAB2 if cnt is greater than maxx, set maxx to cnt ;  $  TAB1 print maxx ;
TAB1 n, m, a, b = long long integers ;  $  TAB1 while n, m, a and b are being read ;  $  TAB2 if n modulo m is 0 ;  $  TAB3 print 0 ;  $  TAB2 else ;  $  TAB3 if n > m ;  $  TAB4 print the min between n/m + 1 * m -n * a, and n modulo m * b ;  $  TAB3 else ;  $  TAB4 print the min between m -n * a and n modulo m * b ;
TAB1 let t1, t2, x1, x2, t0, res_x, res_y be long lon ;  $  TAB1 read t1, t2, x1, x2, t0 ;  $  TAB1 let t, ct be double with ct = 1e99 ;  $  TAB1 while x1 is greater than or equal to 0 and x2 is greater than or equal to 0 ;  $  TAB2 set t to (t1*x1 + t2*x2*1.0) / (x1 + x2) ;  $  TAB2 if t is less than t0 ;  $  TAB3 decrement x1 ;  $  TAB3 continue ;  $  TAB2 if t is less than ct ;  $  TAB3 set ct to t ;  $  TAB3 set res_x to x1 ;  $  TAB3 set res_y to x2 ;  $  TAB2 decrement x2 ;  $  TAB1 print out res_x, ' ', res_y with newline ;
TAB1 let n, s, x, y, and = integers with ans = -1 ;  $  TAB1 read n, s ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read x, y ;  $  TAB2 if ( s * 100 is greater than or equal to x * 100 + y set ans = max of ans and (100 -y) modulo 100 ;  $  TAB1 print ans ;
TAB1 t = long long ;  $  TAB1 raed t ;  $  TAB1 while decrement t ;  $  TAB2 n, x, y, d are long longs ;  $  TAB2 read n, x, y, d ;  $  TAB2 step = long long = 1e12 ;  $  TAB2 if y is greater than x ;  $  TAB3 if (y - x) mod d is 0 ;  $  TAB4 step_f = long long = (y - x) / d ;  $  TAB4 set step to step_f ;  $  TAB3 else ;  $  TAB4 step1 = long long = 1e12 ;  $  TAB4 step2 = long long = 1e12 ;  $  TAB4 if ((y - 1) mod d) is 0 ;  $  TAB5 step_f = long long = (y - 1) / d ;  $  TAB5 step_b = long long = ((x - 1) / d) if ((x - 1) mod d is 0), otherwise step_b = long long = (((x - 1) / d) + 1) ;  $  TAB5 set step1 to step_b + step_f ;  $  TAB4 if (n - y) is divisible by d ;  $  TAB5 step_f = long long = (n - y) / d ;  $  TAB5 step_b = long long = ((n - x) / d) if ((n - x) mod d is 0), otherwise step_b = long long = (((n - x) / d) + 1) ;  $  TAB5 set step 2 to step_b + step_f ;  $  TAB4 set step to call min with step1, step2 ;  $  TAB2 else if x is greater than y ;  $  TAB3 if (x - y) is divisible by d ;  $  TAB4 step_f = long long = (x - y) / d ;  $  TAB4 set step to step_f ;  $  TAB3 else ;  $  TAB4 step1 = long long = 1e12 ;  $  TAB4 step2 = long long = 1e12 ;  $  TAB4 if ((y - 1) mod d) is 0 ;  $  TAB5 step_f = long long = (y - 1) / d ;  $  TAB5 step_b = long long = ((x - 1) / d) if ((x - 1) mod d is 0), otherwise step_b = long long = (((x - 1) / d) + 1) ;  $  TAB5 set step1 to step_b + step_f ;  $  TAB4 if (n - y) is divisible by d ;  $  TAB5 step_f = long long = (n - y) / d ;  $  TAB5 step_b = long long = ((n - x) / d) if ((n - x) mod d is 0), otherwise step_b = long long = (((n - x) / d) + 1) ;  $  TAB5 set step2 to step_b + step_f ;  $  TAB4 set step to call min with step1, step2 ;  $  TAB2 else ;  $  TAB3 set step to 0 ;  $  TAB2 if step is 1e12 ;  $  TAB3 display - 1 ;  $  TAB2 else ;  $  TAB3 display step ;
TAB1 create integer array cnt = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2} of size 10 ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 print cnt[s[0] - '0'] * cnt[s[1] - '0'] and a new line ;
TAB1 create int n ;  $  TAB1 create int ind ;  $  TAB1 read n ;  $  TAB1 create int array a of size 110 ;  $  TAB1 create int chot = 0 and nechot = 0 ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is even ;  $  TAB3 increment chot ;  $  TAB2 else ;  $  TAB3 increment nechot ;  $  TAB1 if chot is greater than nechot ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a[i] is odd ;  $  TAB4 create int ai = a[i] ;  $  TAB4 for i = 0 to n exclusive ;  $  TAB5 if a[i] is not equal to ai ;  $  TAB6 increment ind ;  $  TAB5 else ;  $  TAB6 break ;  $  TAB1 else ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a[i] is even ;  $  TAB4 create int ai = a[i] ;  $  TAB4 for i = 0 to n exclusive ;  $  TAB5 if a[i] is not equal to ai ;  $  TAB6 increment ind ;  $  TAB5 else ;  $  TAB6 break ;  $  TAB1 print ind + 1 ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make integers a, b, and c ;  $  TAB1 make integer count = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, b, and c ;  $  TAB2 if a + b + c is greater than or equal to 2 then add 1 to count ;  $  TAB1 print count ;
TAB0 In the function fiver which takes an integer n and return an integer ;  $  TAB1 let cnt be an integer with cnt =0 ;  $  TAB1 for i =1 to n inclusive set cnt to cnt+(i*5) ;  $  TAB1 return cnt ;  $  TAB1 n,k,i=integers ;  $  TAB1 read n,k ;  $  TAB1 let time be an integer with time =240-k ;  $  TAB1 for i =n to 1 inclusive ;  $  TAB2 if time>= fiver(i) then break ;  $  TAB1 print i and new line ;
TAB1 create two dimensional integer array M and N of size 3,3 each ;  $  TAB1 create empty strings s0,s1,s2 ;  $  TAB1 for i =0 to 3 exclusive ;  $  TAB2 for j=0 to 3 exclusive ;  $  TAB3 read M[i][j] ;  $  TAB3 set N[i][j]=M[i][j] ;  $  TAB1 for i=0 to 3 exclusive ;  $  TAB2 for j=0 to 3 exclusive ;  $  TAB3 if M[i][j]>0 ;  $  TAB4 if (i-1>=0) then set N[i-1][j]=N[i - 1][j]+M[i][j] ;  $  TAB4 if (j + 1 < 3) then set N[i][j + 1] =N[i][j + 1] + M[i][j] ;  $  TAB4 if (i + 1 < 3) then set N[i + 1][j] =N[i + 1][j] + M[i][j] ;  $  TAB4 if (j - 1 >= 0) then set N[i][j - 1] =N[i][j - 1] + M[i][j] ;  $  TAB1 for j=0 to 3 exclusive ;  $  TAB2 if N[0][j]%2 =0 ;  $  TAB3 set s0=s0+1 ;  $  TAB2 else do the following ;  $  TAB3 set s0=s0+0 ;  $  TAB1 for j=0 to 3 exclusive ;  $  TAB2 if N[1][j] mod 2=0 ;  $  TAB3 set s1=s1+1 ;  $  TAB2 else do the following ;  $  TAB3 set s1=s1+0 ;  $  TAB1 for j=0 to 3 exclusive ;  $  TAB2 if N[2][j]%2=0 ;  $  TAB3 set s2=s2+1 ;  $  TAB2 else do the following ;  $  TAB3 set s2=s2+0 ;  $  TAB1 print s0 ;  $  TAB1 print s1 ;  $  TAB1 print s2 ;
TAB0 in function MAX with parameters long longs a, b and return long long ;  $  TAB1 if a is greater than b, return a ;  $  TAB1 return b ;  $  TAB0 in function MIN with parameters long longs a, b and return long long ;  $  TAB1 if a is less than b, return a ;  $  TAB1 return b ;  $  TAB1 let n and k be integers ;  $  TAB1 input n and k ;  $  TAB1 c1 = integer = n * 2 ;  $  TAB1 c2 = integer = n * 5 ;  $  TAB1 c3 = integer = n * 8 ;  $  TAB1 saida = integer = 0 ;  $  TAB1 add ceiling (c1 / double value of k) to saida ;  $  TAB1 add ceiling (c2 / double value of k) to saida ;  $  TAB1 add ceiling (c3 / double value of k) to saida ;  $  TAB1 output saida ;
TAB0 N, INF, MOD are constant integers all set to 0 ;  $  TAB0 n, L, a, t, l, last are integers with last = 0 ;  $  TAB0 ans = long long ;  $  TAB1 read n, L, a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t, l ;  $  TAB2 add call max with 0, (t - last) / a to ans ;  $  TAB2 set last to t + 1 ;  $  TAB1 add call max with 0, (L - last) / a to ans ;  $  TAB1 output ans ;
TAB0 v is an integer array of lengths 50 and 50 ;  $  TAB1 n and a are integers ;  $  TAB1 ans is an integer set to 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, read v[i][j] ;  $  TAB1 col and row are integers ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 set row to 0 ;  $  TAB3 set col to 0 ;  $  TAB3 for k = 0 to n exclusive ;  $  TAB4 add v[k][j] to col ;  $  TAB4 add v[i][k] to row ;  $  TAB3 if col is greater than row, increment ans ;  $  TAB1 display ans ;
TAB1 let x be string ;  $  TAB1 read x ;  $  TAB1 for i = 0 to size of x ;  $  TAB2 if (x[i] - '0' is greater than (9 - (x[i] - '0')) ;  $  TAB3 if (9 - (x[i] - '0')) == 0 ;  $  TAB4 if (i != 0 && (i != x.size() - 1 || x.size() != 1)), update x[i] to '9' - (x[i] - '0') ;  $  TAB3 else ;  $  TAB4 update x[i] to '9' - (x[i] - '0') ;  $  TAB1 print x ;
TAB0 let n, a, b, c, d, sum, l1, l2 be integers ;  $  TAB1 read n, a, b, c, d, sum, l1, l2 ;  $  TAB1 if a is equal to 0 ;  $  TAB2 assign b to l1 ;  $  TAB1 else if a is equal to n ;  $  TAB2 assign 3 * n - b to l1 ;  $  TAB1 else if b is equal to 0 ;  $  TAB2 assign 4 * n - a to l1 ;  $  TAB1 else if b is equal to n ;  $  TAB2 assign n + a to l1 ;  $  TAB1 if c is equal to 0 ;  $  TAB2 assign d to l2 ;  $  TAB1 else if c is equal to n ;  $  TAB2 assign 3 * n - d to l2 ;  $  TAB1 else if d is equal to 0 ;  $  TAB2 assign 4 * n - c to l2 ;  $  TAB1 else if d is equal to n ;  $  TAB2 assign n + c to l2 ;  $  TAB1 display call min with arguments absolute value of (l1 - l2), 4 * n - absolute value of (l1 - l2) ;
TAB0 ara = array of long long integers with a length of 105 ;  $  TAB1 i, t, test, rslt = long long integers with test set to 1 ;  $  TAB1 n, s, d = long long integers ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read ara[i] ;  $  TAB1 read s and d ;  $  TAB1 if s > d, swap s and d ;  $  TAB1 mid = long long integer set to 0 ;  $  TAB1 bg = long long integer set to 0 ;  $  TAB1 ed = long long integer set to 0 ;  $  TAB1 for i = s to d exclusive, add ara[i] to mid ;  $  TAB1 for i = 1 to s exclusive, add ara[i] to bg ;  $  TAB1 for i = d to n inclusive, add ara[i] to ed ;  $  TAB1 print minimum of mid or bg + ed ;
TAB1 create int n, k, i ,c, x, p, array a of 500 elements, ans ;  $  TAB1 set a's elements to 0 ;  $  TAB1 set ans to 0 ;  $  TAB1 read n and k ;  $  TAB1 read c ;  $  TAB1 for i = 0 to c exclusive ;  $  TAB2 read x ;  $  TAB2 set a[x] to 1 ;  $  TAB1 set p to 0 ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 if a[i] ;  $  TAB3 increment ans ;  $  TAB3 set p to 0 ;  $  TAB2 else ;  $  TAB3 increment p ;  $  TAB2 if p equal sk ;  $  TAB3 increment ans ;  $  TAB3 set p to 0 ;  $  TAB1 print ans ;
TAB1 let n, i, j, k , count be integers with count = 0 and a be array of integers of size 100 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for j = 0 to n exclusive ;  $  TAB2 if a[j] is equal to 1 ;  $  TAB3 set a[j] to -1 ;  $  TAB3 increment count ;  $  TAB2 else ;  $  TAB3 set a[j] to 1 ;  $  TAB1 let sum be integer with sum = 0 ;  $  TAB1 let max be integer with max = -2 ;  $  TAB1 for k = 0 to n exclusive ;  $  TAB2 increment sum by a[k] ;  $  TAB2 if sum is greater than max, set max to sum ;  $  TAB2 if sum is less than 0, set sum to 0 ;  $  TAB1 print out count + max ;
TAB1 a, b, r are integers ;  $  TAB1 read a, b, and r ;  $  TAB1 multiply r by 2 ;  $  TAB1 if r is greater than a or r is greater than b ;  $  TAB2 display Second ;  $  TAB1 else ;  $  TAB2 display First ;
TAB0 define gcd which takes long long a, b as arguments and return long long ;  $  TAB1 return a if b == 0 else gcd of b, a mod b ;  $  TAB0 define lcm which takes long long a, b as arguments and return long long ;  $  TAB1 return a * (b / gcd of a, b) ;  $  TAB0 let q be const integer with q = 1e9 + 7 ;  $  TAB0 let ans be long long with ans = 0 ;  $  TAB0 let v be vector of integers ;  $  TAB1 let n, f, iv, l be long lon ;  $  TAB1 read n, f, iv, l ;  $  TAB1 increment l by iv ;  $  TAB1 update ans to l / f ;  $  TAB1 if l % f, increment ans ;  $  TAB1 if ans * f > n ;  $  TAB2 print -1 with newline ;  $  TAB1 else ;  $  TAB2 print out ans with newline ;
TAB1 make integers a and b ;  $  TAB1 while reading a and b ;  $  TAB2 make integers z, m, n, and cnt = 0 ;  $  TAB2 set z to max of a and b ;  $  TAB2 set n to min of a and b ;  $  TAB2 set m to (z-n) / 2 ;  $  TAB2 print n, " ", m ;
TAB1 arr = integer array of size 101 ;  $  TAB1 n, a, count are integers with count = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input arr[i] ;  $  TAB2 if arr[i] equals 1, increment count ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] is 1 and arr[i + 1] is 0 and arr[i + 2] is 1, increment count ;  $  TAB1 print count ;
TAB1 make ints n and k ;  $  TAB1 read n and k ;  $  TAB1 make ints x, i = 0 ;  $  TAB1 make int prevC = 0 ;  $  TAB1 while n decremented ;  $  TAB2 increment i ;  $  TAB2 read x ;  $  TAB2 add prevC to x ;  $  TAB2 if x greater than 8 ;  $  TAB3 set prevC to x - 8 ;  $  TAB3 set x to 8 ;  $  TAB2 else ;  $  TAB3 set prevC to 0 ;  $  TAB2 subtract x from k ;  $  TAB2 if k less than or equal to 0 then break ;  $  TAB1 if k greater than 0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print i ;
TAB0 let a = 105 arrays of integer size 105 and b, c, i, n, f, g, k, x, y, j = integer ;  $  TAB0 let s = 105 arrays of strings size 105 ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive do the following ;  $  TAB2 for j=1 to n inclusive set s[i][j] = * ;  $  TAB2 set x = n / 2 + 1 ;  $  TAB2 set y = 2 ;  $  TAB1 for i=1 to n inclusive do the following ;  $  TAB2 if i is less than or equal to n / 2 + 1 do the following ;  $  TAB3 for j=x to n-x+1 inclusive set s[i][j] = D ;  $  TAB3 decrement x ;  $  TAB2 if i is greater than n / 2 + 1 do the following ;  $  TAB3 for j=y to n-y+1 inclusive set s[i][j] = D ;  $  TAB3 increment y ;  $  TAB1 for i=1 to n inclusive do the following ;  $  TAB2 for j=1 to n inclusive print s[i][j] ;  $  TAB2 print a new line ;
TAB1 f = string ;  $  TAB1 read f ;  $  TAB1 one, zero, test are integers all set to 0 ;  $  TAB1 l = integer = size of f ;  $  TAB1 for i = 0 to l exclusive ;  $  TAB2 if f[i] is the character 1, set test to 1 ;  $  TAB2 if test equals 1 and f[i] is the character 0, increment zero ;  $  TAB1 if zezo is at least 6 ;  $  TAB2 display yes ;  $  TAB1 else ;  $  TAB2 display no ;
TAB1 n, k = integers ;  $  TAB1 ara = string ;  $  TAB1 read n, k ;  $  TAB1 read ara ;  $  TAB1 let gh be integer with gh = find of ara with 'G', 0 ;  $  TAB1 let target be integer with target = find of ara with 'T', 0 ;  $  TAB1 m = integer ;  $  TAB1 if gh < target ;  $  TAB2 set m to 1 ;  $  TAB1 else ;  $  TAB2 set m to -1 ;  $  TAB1 let i be integer with i = gh ;  $  TAB1 while true ;  $  TAB2 if ara[i] == '#' ;  $  TAB3 print NO ;  $  TAB2 else if ara[i] == 'T' ;  $  TAB3 print YES ;  $  TAB2 update i to i+m*k ;  $  TAB2 if gh < target and i > target, break ;  $  TAB2 if gh > target and i < target, break ;  $  TAB1 print NO ;
TAB1 n, k = integers ;  $  TAB1 read n ;  $  TAB1 read k ;  $  TAB1 best = integer = 0 ;  $  TAB1 iterate n times ;  $  TAB2 x, y are integers ;  $  TAB2 read x, y ;  $  TAB2 add (y - x + 1) to best ;  $  TAB1 display (k - best mod k) mod k ;
TAB0 create a constant integer maxn =1000000 + 10 ;  $  TAB0 b=array of character of size maxn ;  $  TAB0 a= array of integer of size maxn ;  $  TAB0 ccc=array of integer of size 20 ;  $  TAB1 n=integer ;  $  TAB1 set all elementsof a to 0 ;  $  TAB1 p,q=integers ;  $  TAB1 check=integer ;  $  TAB1 read n ;  $  TAB1 read p ;  $  TAB1 for i=1 to p inclusive ;  $  TAB2 read check ;  $  TAB2 set a[check] = 1 ;  $  TAB1 read q ;  $  TAB1 for i=1 to q inclusive ;  $  TAB2 read check ;  $  TAB2 set a[check] = 1 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if a[i] = 0 ;  $  TAB3 print Oh, my keyboard! ;  $  TAB3 break ;  $  TAB2 else if i = n ;  $  TAB3 print I become the guy. ;
TAB1 n, i, ar, sum, a, c are integers with sum = 0, a = 0, c = 0, ar is an array of size 105 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read ar[i] ;  $  TAB1 call sort with ar, ar + n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB1 divide sum by 2 ;  $  TAB1 while a is at most sum ;  $  TAB2 increment c ;  $  TAB2 add ar[n - c] to a ;  $  TAB1 display c ;
TAB1 let n, k = integer ;  $  TAB1 read n, k ;  $  TAB1 if k / n is 2 ;  $  TAB2 print n - (k modulo n) ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 create integer x = n/2 ;  $  TAB1 let ch be vector of char array of size n ;  $  TAB1 create integers t=1 and r=1 ;  $  TAB1 set ch[x] = 'D' ;  $  TAB1 for i=0 to n exclusive print ch[i] ;  $  TAB1 print new line ;  $  TAB1 for i=0 to x exclusive ;  $  TAB2 set ch[x+t] = D ;  $  TAB2 set ch[x - r] = 'D' ;  $  TAB2 for i=0 to n exclusive print ch[i] ;  $  TAB2 print a new line ;  $  TAB2 increment t ;  $  TAB2 add 1 to r ;  $  TAB1 set t to 0 ;  $  TAB1 assign n-1 to r ;  $  TAB1 for i=0 to x exclusive ;  $  TAB2 ch[t] = * ;  $  TAB2 set ch[r] to * ;  $  TAB2 print n values of ch ;  $  TAB2 print a newline ;  $  TAB2 increment t ;  $  TAB2 decrement r ;
TAB0 s = string ;  $  TAB0 q = queue of characters with length of 27 ;  $  TAB1 n, cnt, i, j = integers with cnt and i set to 0 ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 if n > size of s ;  $  TAB2 print "NO" ;  $  TAB1 if n is 1 ;  $  TAB2 print "YES" ;  $  TAB2 for k = 0 to size of s, print s[k] ;  $  TAB2 endline ;  $  TAB1 push s[0] into q[0] ;  $  TAB1 for i = 1 to size of s ;  $  TAB2 for j = 0 to cnt inclusive ;  $  TAB3 if s[i] to front of q[j] ;  $  TAB2 if j > cnt, increment cnt by 1 ;  $  TAB2 push s[i] into q[cnt] ;  $  TAB2 if cnt is n - 1, break ;  $  TAB1 if cnt < n - 1 ;  $  TAB2 print "NO" ;  $  TAB1 for j = i + 1 to size of s exclusive, push s[j] into q[cnt] ;  $  TAB1 print "YES" ;  $  TAB1 for i = 0 to cnt inclusive ;  $  TAB2 while q[i] isn't empty ;  $  TAB3 print front of q[i] ;  $  TAB3 pop off q[i] ;  $  TAB2 endline ;
TAB1 let k, a, b, v, box be integers with box = 0 ;  $  TAB1 read k, a, b, v ;  $  TAB1 while 1 ;  $  TAB2 section = integer = 1 ;  $  TAB2 if b is at least k - 1 ;  $  TAB3 set section to k ;  $  TAB3 subtract k - 1 from b ;  $  TAB2 else ;  $  TAB3 assign b + 1 to section ;  $  TAB3 assign 0 to b ;  $  TAB2 subtract section * v from a ;  $  TAB2 increment box ;  $  TAB2 if a is at most 0, break ;  $  TAB1 print box ;
TAB1 n and x are integers ;  $  TAB1 line is a string ;  $  TAB1 input n ;  $  TAB1 while decrement n ;  $  TAB2 input x ;  $  TAB2 if x is 2 ;  $  TAB3 if line[0] is greater than or equal to line[1] ;  $  TAB4 display NO ;  $  TAB3 else ;  $  TAB4 display YES 2, line[0], ' ', line[1] ;  $  TAB2 else ;  $  TAB3 display YES 2, line[0], ' ' ;  $  TAB3 fir i = 1 to the size of line exclusive, display line[i] ;  $  TAB3 print newline ;
TAB1 create integers m, n ;  $  TAB1 read m and n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create boolean judge = 1 ;  $  TAB1 create int t1 = s.find('T'), g1 = s.find('G') ;  $  TAB1 create int mid = abs of t1 - t2 ;  $  TAB1 if mid mod n not equal to 0 ;  $  TAB2 set judge to false ;  $  TAB1 else ;  $  TAB2 create integers i, j ;  $  TAB2 if t1 greater than g1 ;  $  TAB3 set i to g1 ;  $  TAB3 set j to t1 ;  $  TAB2 else ;  $  TAB3 set i to t1 ;  $  TAB3 set j to g1 ;  $  TAB2 if i not equal to -1 ;  $  TAB3 for ; i less than or equal to j; add n to i ;  $  TAB4 if s[i] equals '#' ;  $  TAB5 set judge to false ;  $  TAB5 break ;  $  TAB1 if judge ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n, m are integers ;  $  TAB1 read n, m ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 l, r are integers ;  $  TAB1 c1, c2 are characters ;  $  TAB1 while decrement m ;  $  TAB2 read l, r ;  $  TAB2 read c1, c2 ;  $  TAB2 for i = l - 1 to r - 1 inclusive, set s[i] to c2 if s[i] equals c2, otherwise set s[i] to s[i] ;  $  TAB1 output s ;
TAB0 create long long int n, flag = 0 ;  $  TAB1 read n ;  $  TAB1 while n ;  $  TAB2 create int x = (n mod 10), y = (n mod 100), z = (n mod 1000) ;  $  TAB2 if z is equal to 144 ;  $  TAB3 divide n by itself and 1000 ;  $  TAB2 else if y is equal to 14 ;  $  TAB3 divide n by itself and 100 ;  $  TAB2 else if x equals 1 ;  $  TAB3 divide n by itself and 10 ;  $  TAB2 else ;  $  TAB3 print "NO\n" ;  $  TAB1 print "YES\n" ;
TAB0 make string array S with a length of 4 ;  $  TAB0 make integers I, J, K ;  $  TAB0 in function jarak, returning int and accepting int x and int y ;  $  TAB1 if y greater than x ;  $  TAB2 return y - x ;  $  TAB1 else ;  $  TAB2 return (y + 12) - x ;  $  TAB1 make map A of string to int ;  $  TAB1 set A["C"] to 1 ;  $  TAB1 set A["C#"] to 2 ;  $  TAB1 set A["D"] to 3 ;  $  TAB1 set A["D#"] to 4 ;  $  TAB1 set A["E"] to 5 ;  $  TAB1 set A["F"] to 6 ;  $  TAB1 set A["F#"] to 7 ;  $  TAB1 set A["G"] to 8 ;  $  TAB1 set A["G#"] to 9 ;  $  TAB1 set A["A"] to 10 ;  $  TAB1 set A["B"] to 11 ;  $  TAB1 set A["H"] to 12 ;  $  TAB1 read S[1], S[2], S[3] ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 for j = 1 to 3 inclusive ;  $  TAB3 for k = 1 to 3 inclusive ;  $  TAB4 if i is not equal to j and i is not equal to k and j is not equal to k ;  $  TAB5 assign A[S[i]] to I ;  $  TAB5 assign A[S[j]] to J ;  $  TAB5 assign A[S[k]] to K ;  $  TAB5 if jarak(I, K) equals 7 ;  $  TAB6 if jarak(I, J) equals 4 and jarak(J, K) equals 3 ;  $  TAB7 print "major" ;  $  TAB6 else if jarak(I, J) equals 3 and jarak(J, K) equals 4 ;  $  TAB7 print "minor" ;  $  TAB1 print "strange" ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 create an integer sm with sm=0 ;  $  TAB1 while n is true and decrement n ;  $  TAB2 a= integer ;  $  TAB2 read a ;  $  TAB2 set sm=sm+a ;  $  TAB1 m=integer ;  $  TAB1 read m ;  $  TAB1 while m is true and decrement m ;  $  TAB2 l,r = integer ;  $  TAB2 read l,r ;  $  TAB2 if r<sm then continue ;  $  TAB2 set sm as maximum of sm,l ;  $  TAB2 print sm ;  $  TAB1 print -1 ;
TAB0 declare isPrime, which returns a boolean and takes an integer n ;  $  TAB1 for i = 2 to n - 1 exclusive ;  $  TAB2 if n modulo i is 0, return false ;  $  TAB1 return true ;  $  TAB0 declare findNextPrime, which returns an integer and takes an integer n ;  $  TAB1 increment n by 1 ;  $  TAB1 while true ;  $  TAB2 if isPrime of n is true ;  $  TAB3 return n ;  $  TAB2 else ;  $  TAB3 increment n by 1 ;  $  TAB1 declare n and m ;  $  TAB1 read n and m ;  $  TAB1 n0 = integer set to findNextPrime of n ;  $  TAB1 if n0 is m ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 in solve function ;  $  TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare vector<int> v ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare integer x ;  $  TAB2 read x ;  $  TAB2 append x to v ;  $  TAB1 sort v ;  $  TAB1 let int i = 0 ;  $  TAB1 let int j = n - 1 ;  $  TAB1 let int ans = 0 ;  $  TAB1 while 2 * v[i] < v[j] ;  $  TAB2 if 2 * v[i + 1] >= v[j] ;  $  TAB3 increment i ;  $  TAB3 increment ans ;  $  TAB2 else if 2 * v[i] >= v[j - 1] ;  $  TAB3 decrement j ;  $  TAB3 increment ans ;  $  TAB2 else ;  $  TAB3 increase ans by 2 ;  $  TAB3 increment i ;  $  TAB3 decrement j ;  $  TAB1 print ans ;  $  TAB0 in solve2 function ;  $  TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 let long long mx = 0 ;  $  TAB1 declare long long array a of length n ;  $  TAB1 read n values to array a ;  $  TAB1 for len = 1 to 100 inclusive ;  $  TAB2 for i = 0 to i + len - 1 exclusive ;  $  TAB3 let long long k = a[i] ;  $  TAB3 for j = i + 1 to i exclusive do k ^= a[j] ;  $  TAB3 if k > mx then mx = k ;  $  TAB1 print mx ;  $  TAB1 call solve2 ;
TAB0 let b, c, word, ans, temp = integers with temp = 1 ;  $  TAB1 read b, c ;  $  TAB1 for integer a=0 to b exclusive do the following ;  $  TAB2 read word ;  $  TAB2 if word - temp is greater than c ;  $  TAB3 set ans = 1 ;  $  TAB2 else ;  $  TAB3 increment ans ;  $  TAB2 set temp = word ;  $  TAB1 print ans ;
TAB1 n, a, b = integers with a set to 0 ;  $  TAB1 read n ;  $  TAB1 set b to n + 1 / 3 ;  $  TAB1 while b >= 12 ;  $  TAB2 increment a by 1 ;  $  TAB2 decrement b by 12 ;  $  TAB1 print a, " ", b ;
TAB1 k, a, b, v are integers ;  $  TAB1 while read k, a, b, v ;  $  TAB2 nums = integer set to b / (k - 1) ;  $  TAB2 total = integer set to 0 ;  $  TAB2 if nums * k * v is at least a ;  $  TAB3 set total to ceiling ((double value of a) / (k * v)) ;  $  TAB2 else ;  $  TAB3 assign nums to total ;  $  TAB3 ab = integer set to b - nums * (k - 1) ;  $  TAB3 s = integer set to a - nums * k * v ;  $  TAB3 if (ab + 1) * v is at least s ;  $  TAB4 increment total ;  $  TAB3 else ;  $  TAB4 increment total ;  $  TAB4 add ceiling ((s - (ab + 1) * v) / double value of v) to total ;  $  TAB2 output total ;
TAB1 create strings a and b ;  $  TAB1 read a and b ;  $  TAB1 create int c = 1 ;  $  TAB1 for i = 0 to length of a exclusive ;  $  TAB2 if tolower(a[i]) not equal tolower(b[i]) ;  $  TAB3 if tolower(a[i]) less than tolower(b[i]) ;  $  TAB4 print "-1" ;  $  TAB4 c = 0 ;  $  TAB4 break ;  $  TAB3 else ;  $  TAB4 print "1" ;  $  TAB4 c = 0 ;  $  TAB4 break ;  $  TAB1 if c, print "0" ;
TAB1 n, i, j, m = integers, a = 2D array of integers, size 2010x3 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read m ;  $  TAB2 set a[i][0] to m ;  $  TAB2 set a[i][1] to i ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 if a[i][0] < a[j][0] ;  $  TAB4 tmp = integer set to a[i][0] ;  $  TAB4 set a[i][0] to a[j][0] ;  $  TAB4 set a[j][0] to temp ;  $  TAB4 set temp to a[i][1] ;  $  TAB4 set a[i][1] to a[j][1] ;  $  TAB4 set a[j][1] to temp ;  $  TAB3 if a[i][0] is a[j][0] ;  $  TAB4 if a[i][1] > a[j][1] ;  $  TAB5 temp = integer set to a[i][0] ;  $  TAB5 set a[i][0] to a[j][0] ;  $  TAB5 set a[j][0] to temp ;  $  TAB5 set temp to a[i][1] ;  $  TAB5 set a[i][1] to a[j][1] ;  $  TAB5 set a[j][1] to temp ;  $  TAB1 set a[0][2] to 1 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if a[i][0] is a[i - 1][0] ;  $  TAB3 set a[i][2] to a[i - 1][2] ;  $  TAB2 else ;  $  TAB3 set a[i][2] to i + 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 if a[i][1] > a[j][1] ;  $  TAB4 temp = integer set to a[i][1] ;  $  TAB4 set a[i][1] to a[j][1] ;  $  TAB4 set a[j][1] to temp ;  $  TAB4 set temp to a[i][0] ;  $  TAB4 set a[i][0] to a[j][0] ;  $  TAB4 set a[j][0] to temp ;  $  TAB4 set temp to a[i][2] ;  $  TAB4 set a[i][2] to a[j][2] ;  $  TAB4 set a[j][2] to temp ;  $  TAB1 print a[0][2] ;  $  TAB1 for i = 1 to n exlusive, print " ", a[i][2] ;  $  TAB1 endline ;
TAB1 s, n, d, c, B are integers with B = 0 ;  $  TAB1 read s, n, d, c ;  $  TAB1 while n is positive ;  $  TAB2 if s is greater than d and d isn't 0 ;  $  TAB3 subtract (d + 1) * c from n ;  $  TAB3 set d to 0 ;  $  TAB2 else if d - s + 1 is at least 0 ;  $  TAB3 subtract s - 1 from d ;  $  TAB3 subtract s * c from n ;  $  TAB2 else ;  $  TAB3 subtract (d + 1) * c from n ;  $  TAB3 if d is positive, decrement d ;  $  TAB2 increment B ;  $  TAB1 print B ;
TAB1 let a and b be integers ;  $  TAB1 input a and b ;  $  TAB1 if a is greater than b, call swap with a, b ;  $  TAB1 display a, " ", (b - a) / 2 ;
TAB0 inf = constant integer = 0x3f3f3f3f ;  $  TAB1 n, k, sum are integers ;  $  TAB1 a = integer array of size 110 ;  $  TAB1 read n, k ;  $  TAB1 j = integer ;  $  TAB1 read n values into array a ;  $  TAB1 call sort with a + 1, a + n + 1 ;  $  TAB1 ans = integer = -1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = i + 1 to n inclusive ;  $  TAB3 if a[j] - a[i] is greater than k ;  $  TAB4 set sum to j - i ;  $  TAB4 break ;  $  TAB2 if j equals n + 1, set sum to n - i + 1 ;  $  TAB2 set ans to call max with ans, sum ;  $  TAB1 print n - ans ;
TAB1 make character array b of size 100 ;  $  TAB1 make integers a, j, sum = 0 ;  $  TAB1 read a ;  $  TAB1 for j = 0 to a exclusive ;  $  TAB2 read b ;  $  TAB2 if strcmp of b and "Tetrahedron" equals 0 then set sum to sum + 4 ;  $  TAB2 if strcmp of b and "Cube" equals 0 then set sum to sum + 6 ;  $  TAB2 if strcmp of b and "Octahedron" equals 0 then set sum to sum + 8 ;  $  TAB2 if strcmp of b and "Dodecahedron" equals 0 then set sum to sum + 12 ;  $  TAB2 if strcmp of b and "Icosahedron" equals 0 then set sum to sum + 20 ;  $  TAB1 print sum ;
TAB0 make constant long double pi = 3.1415926535 ;  $  TAB1 make long long integer n ;  $  TAB1 read n ;  $  TAB1 make vector a holding long long ints with a size of n and initialized to 0 ;  $  TAB1 make vector b holding long long ints with a size of n and initialized to 0 ;  $  TAB1 make maps mpb and mpa, both with a key type of long long int and value type of long long int ;  $  TAB1 for long long int i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment mpa[a[i]] ;  $  TAB1 for long long int i = 0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 increment mpb[b[i]] ;  $  TAB2 increment mpa[b[i]] ;  $  TAB1 make long long int ans = 0 ;  $  TAB1 for long long int i = 1 to 5 inclusive ;  $  TAB2 if mpa[i] mod 2 is not equal to 0 ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 add abs of mpa[i] / 2 - mpb[i] to ans ;  $  TAB1 print ans / 2 ;
TAB1 make integer n ;  $  TAB1 make double array a of size 180 ;  $  TAB1 read n ;  $  TAB1 read n values into a ;  $  TAB1 for f = 0 to n exclusive ;  $  TAB2 make boolean y = false ;  $  TAB2 for i = 3 to 1000 exclusive ;  $  TAB3 if ((i cast to double) - 2) * 180) / (i cast to double) equals a[f], set y to true ;  $  TAB2 if y equals true ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB0 in function gcd returning int, taking int a and int b ;  $  TAB1 if b equals 0: return a ;  $  TAB1 return gcd(b, a modulo b) ;  $  TAB1 create int n ;  $  TAB1 while reading n is not interrupted ;  $  TAB2 create int ans ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 create int t ;  $  TAB3 read t ;  $  TAB3 if i equals 0 ;  $  TAB4 set ans to t ;  $  TAB3 else ;  $  TAB4 set ans to gcd(ans, t) ;  $  TAB2 print ans * n ;
TAB0 declare so, which takes in integer x and returns a string ;  $  TAB1 st = string set to "" ;  $  TAB1 while x > 0 ;  $  TAB2 set st to char of x modulo 10 + 48 + st ;  $  TAB2 divide x by 10 ;  $  TAB1 return st ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 st = string ;  $  TAB1 d = integer ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read st ;  $  TAB2 if length of st > 10 ;  $  TAB3 set d to length of st - 2 ;  $  TAB3 st replace 1, d, and so of d ;  $  TAB2 print st ;
TAB1 let n be a long long ;  $  TAB1 input n ;  $  TAB1 if n equals 2 ;  $  TAB2 output 2 ;  $  TAB1 else ;  $  TAB2 output 1 ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 if n less than or equal to 10 OR n greater than or equal to 22 ;  $  TAB2 print '0' ;  $  TAB1 else if n greater than or equal to 11 AND n less than 20 ;  $  TAB2 print '4' ;  $  TAB1 else if n equals 20 ;  $  TAB2 print "15" ;  $  TAB1 else if n equals 21 ;  $  TAB2 print '4' ;
TAB1 let a, b = integers ;  $  TAB1 read a, b ;  $  TAB1 if a is less than b do the following ;  $  TAB2 let x = integer with value = a ;  $  TAB2 set a = b ;  $  TAB2 set b = x ;  $  TAB1 print b and space and (a - b) / 2 ;
TAB0 in function gcd with parameters integers a, b and return integer ;  $  TAB1 if b is equal to 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return call function gcd with arguments b, a modulo b ;  $  TAB1 n = integer, a = integer array of size 100010 ;  $  TAB1 while input n ;  $  TAB2 read n values into array a ;  $  TAB2 declare an integer dif ;  $  TAB2 if n is not equal to 1, assign a[n - 1] - a[n - 2] to dif ;  $  TAB2 if n is equal to 1 ;  $  TAB3 if a[n - 1] is equal to 15 ;  $  TAB4 print DOWN ;  $  TAB3 else if a[n - 1] is equal to 0 ;  $  TAB4 print UP ;  $  TAB3 else ;  $  TAB4 print -1 ;  $  TAB2 else if dif is positive ;  $  TAB3 if a[n - 1] is equal to 15 ;  $  TAB4 print DOWN ;  $  TAB3 else ;  $  TAB4 print UP ;  $  TAB2 else ;  $  TAB3 if a[n - 1] is equal to 0 ;  $  TAB4 print UP ;  $  TAB3 else ;  $  TAB4 print DOWN ;  $  TAB2 print newline ;
TAB0 arr is an integer array of sizes 4 and 4 ;  $  TAB0 light is a boolean array of sizes 4 and 4 ;  $  TAB1 for i = 1 to 4 exclusive ;  $  TAB2 for j = 1 to 4 exclusive, read arr[i][j] ;  $  TAB1 for i = 1 to 4 exclusive ;  $  TAB2 for j = 1 to 4 exclusive ;  $  TAB3 if arr[i][j] bitwise and 1 ;  $  TAB4 set light[i][j] to not light[i][j] ;  $  TAB4 if i - 1 is at least 1, set light[i - 1][j] to not light[i - 1][j] ;  $  TAB4 if i + 1 is at most 3, set light[i + 1][j] to not light[i + 1][j] ;  $  TAB4 if j - 1 is at least 1, set light[i][j - 1] to not light[i][j - 1] ;  $  TAB4 if j + 1 is at most 3, set light[i][j + 1] to not light[i][j + 1] ;  $  TAB1 for i = 1 to 4 exclusive ;  $  TAB2 for j = 1 to 4 exclusive ;  $  TAB3 if light[i][j] ;  $  TAB4 display 0 ;  $  TAB3 else ;  $  TAB4 display 1 ;  $  TAB2 print newline ;
TAB0 let j1 = array of integers with size = 300 ;  $  TAB1 let s1 = string ;  $  TAB1 let yy = array of characters with values A, E, O, U, I, Y ;  $  TAB1 let i, j, n, k, ans = integers with k = 0 and ans = -1 ;  $  TAB1 read s1 ;  $  TAB1 set n = size of s1 ;  $  TAB1 set s1[n] = P ;  $  TAB1 for i=0 to n inclusive do the following ;  $  TAB2 increment j1[k] ;  $  TAB2 if j1[k] is greater than ans set ans = j1[k] ;  $  TAB2 for j=0 to 6 exclusive do the following ;  $  TAB3 if s1[i] is yy[j] do the following ;  $  TAB4 increment k ;  $  TAB4 exit the loop ;  $  TAB1 print ans ;
TAB0 in function gcd that takes in long long a, long long b, and return long long ;  $  TAB1 if b isn't equal to 0 ;  $  TAB2 return function gcd with arguments b, a mod b ;  $  TAB1 else ;  $  TAB2 return a ;  $  TAB1 let n, i, and j be integers ;  $  TAB1 input n ;  $  TAB1 let p, q, b, m, x be long longs ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read p, q, b ;  $  TAB2 set m to q / call function gcd with arguments p, q ;  $  TAB2 set x to call function gcd with arguments m, b ;  $  TAB2 while x isn't 1 ;  $  TAB3 set m to m divided by x ;  $  TAB3 set x to call function gcd with arguments m, x ;  $  TAB2 if m equals 1 ;  $  TAB3 print Finite ;  $  TAB2 else ;  $  TAB3 print Infinite ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 declare string str ;  $  TAB1 read str ;  $  TAB1 define int array a of length 26, all elements set to 0 ;  $  TAB1 for i = 0 to n exclusive: set a[str[i] - 'a'] to 1 ;  $  TAB1 define int sum = 0 ;  $  TAB1 for i = 0 to 26 exclusive: increase sum by a[i] ;  $  TAB1 if sum == 1 or n == 1 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 define int i = 0 ;  $  TAB2 while str[i] == str[i + 1]: increment i ;  $  TAB2 print "YES" ;  $  TAB2 print str[i] and str[1 + i] ;
TAB1 let n, x, i, s be ints with s = 0 ;  $  TAB1 let q be set<int> ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if x, insert x into q ;  $  TAB1 print q size ;
TAB1 T, s, q, d are doubles ;  $  TAB1 c = long long = 0 ;  $  TAB1 read T, s, q ;  $  TAB1 set d to s ;  $  TAB1 while d is less than T ;  $  TAB2 multiply d by q ;  $  TAB2 increment c ;  $  TAB1 output c ;
TAB0 INF is a constant long long integer with INF = 2000000000000000000LL ;  $  TAB0 MOD is a constant integer with MOD = 10000007 ;  $  TAB0 a is an integer array of length 1000006 ;  $  TAB1 k and d are integers ;  $  TAB1 input k, d ;  $  TAB1 if d equals 0 ;  $  TAB2 if k equals 1 ;  $  TAB3 print 0 ;  $  TAB4 print newline ;  $  TAB3 end statement ;  $  TAB2 else ;  $  TAB3 print No solution ;  $  TAB4 print newline ;  $  TAB3 end statement ;  $  TAB1 else ;  $  TAB2 output d ;  $  TAB2 for i = 0 to k - 1 exclusive, output 0 ;  $  TAB2 output newline ;  $  TAB2 end statement ;
TAB0 arr is an integer array of length 10000 ;  $  TAB1 let n, a, b, res be integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, b ;  $  TAB2 assign 0 to res ;  $  TAB2 while a and b both aren't 0 ;  $  TAB3 if a is greater than b ;  $  TAB4 add a / b to res ;  $  TAB4 set a to a mod b ;  $  TAB3 else ;  $  TAB4 add b / a to res ;  $  TAB4 set b to b mod a ;  $  TAB2 display res ;
TAB1 let k, n, s, p be integers ;  $  TAB1 read k, n, s, p ;  $  TAB1 assign n the ceiling of 1.0 * n / s ;  $  TAB1 k is assigned the product of k and n ;  $  TAB1 assign p the ceiling of 1.0 * k / p ;  $  TAB1 output p ;
TAB1 create a integer n ,m and a=array of integer of size 1001 with a=0 ;  $  TAB1 read n,m ;  $  TAB1 for i=0 , tmp to m exclusive ;  $  TAB2 read tmp ;  $  TAB2 decrement tmp ;  $  TAB2 increment a[tmp] ;  $  TAB1 create an integer res with res=1e9 ;  $  TAB1 for i=0 to n exclusive set res= minimum of res and a[i] ;  $  TAB1 print res ;
TAB0 c, ct are character arrays both of sizes 101, 101 ;  $  TAB0 n, m, i, j are integers ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive, read c[i][j] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i isn't even ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 if j mod 2 isn't 0 ;  $  TAB5 assign the character B to ct[i][j] ;  $  TAB4 else ;  $  TAB5 assign the character W to ct[i][j] ;  $  TAB2 else ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 if j mod 2 isn't 0 ;  $  TAB5 assign the character W to ct[i][j] ;  $  TAB4 else ;  $  TAB5 assign the character B to ct[i][j] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if c[i][j] is the character ., set c[i][j] to ct[i][j] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive, print c[i][j] ;  $  TAB2 print newline ;
TAB1 declare integers n, k, g, t ;  $  TAB1 declare string s ;  $  TAB1 read n, k ;  $  TAB1 read s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] equals 'G', assign i to g ;  $  TAB2 if s[i] equals 'T', assign i to t ;  $  TAB1 if g less than t ;  $  TAB2 define int i = g ;  $  TAB2 while i less than n ;  $  TAB3 if s[i] equals '#' ;  $  TAB4 print "NO" ;  $  TAB3 if if s[i] equals 'T' ;  $  TAB4 print "YES" ;  $  TAB3 increase i by k ;  $  TAB1 else ;  $  TAB2 define int i = g ;  $  TAB2 while i greater than -1 ;  $  TAB3 if s[i] equals '#' ;  $  TAB4 print "NO" ;  $  TAB3 if s[i] equals 'T' ;  $  TAB4 print "YES" ;  $  TAB3 subtract k from i ;  $  TAB1 print "NO" ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 print 2 if n == 2 else print 1 ;
TAB0 s is a string array set to NO, YES ;  $  TAB0 n, t are integers ;  $  TAB0 u = double ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read u ;  $  TAB2 assign 0 to t ;  $  TAB2 for j = 3 to 50000 inclusive ;  $  TAB3 if u * j equals (j - 2) * 180, assign 1 to t ;  $  TAB2 print s[t] ;
TAB1 declare long long x, y ;  $  TAB1 read x, y ;  $  TAB1 define long long a = absolute of x + absolute of y ;  $  TAB1 if x is greater than 0 and y is greater than 0: "0 ", a, " ", a, " 0" ;  $  TAB1 if x is less than 0 and y is greater than 0: print -a " 0 0 ", a ;  $  TAB1 if x is greater than 0 and y is less than 0: print "0 ", -a, " ", a, " 0" ;  $  TAB1 if x is less than 0 and y is less than 0: print -a, " 0 0 ", -a ;
TAB1 let s be string ;  $  TAB1 read s ;  $  TAB1 let c be int = 0 ;  $  TAB1 let c2 be int = 0 ;  $  TAB1 if s[0] equals '0' ;  $  TAB2 increase c by 2 ;  $  TAB1 else if s[0] equals '1' ;  $  TAB2 increase c by 7 ;  $  TAB1 else if s[0] equals '2' ;  $  TAB2 increase c by 2 ;  $  TAB1 else if s[0] equals '3' ;  $  TAB2 increase c by 3 ;  $  TAB1 else if s[0] equals '4' ;  $  TAB2 increase c by 3 ;  $  TAB1 else if s[0] equals '5' ;  $  TAB2 increase c by 4 ;  $  TAB1 else if s[0] equals '6' ;  $  TAB2 increase c by 2 ;  $  TAB1 else if s[0] equals '7' ;  $  TAB2 increase c by 5 ;  $  TAB1 else if s[0] equals '8' ;  $  TAB2 increase c by 1 ;  $  TAB1 else if s[0] equals '9' ;  $  TAB2 increase c by 2 ;  $  TAB1 if s[1] equals '0' ;  $  TAB2 increase c2 by 2 ;  $  TAB1 else if s[1] equals '1' ;  $  TAB2 increase c2 by 7 ;  $  TAB1 else if s[1] equals '2' ;  $  TAB2 increase c2 by 2 ;  $  TAB1 else if s[1] equals '3' ;  $  TAB2 increase c2 by 3 ;  $  TAB1 else if s[1] equals '4' ;  $  TAB2 increase c2 by 3 ;  $  TAB1 else if s[1] equals '5' ;  $  TAB2 increase c2 by 4 ;  $  TAB1 else if s[1] equals '6' ;  $  TAB2 increase c2 by 2 ;  $  TAB1 else if s[1] equals '7' ;  $  TAB2 increase c2 by 5 ;  $  TAB1 else if s[1] equals '8' ;  $  TAB2 increase c2 by 1 ;  $  TAB1 else if s[1] equals '9' ;  $  TAB2 increase c2 by 2 ;  $  TAB1 print c * c2 ;
TAB1 b, sum, a, sum2, sum3 and sum4 = long long integers with b, sum, sum2, sum3, and sum4 set to 0 ;  $  TAB1 w = string ;  $  TAB1 read a ;  $  TAB1 for i = 0 to a - 1 / 2 exclusive ;  $  TAB2 increment b by 1 ;  $  TAB2 for w = 0 to 1 exclusive ;  $  TAB3 for q = a - i * 2 + 1 / 2 to 0, by decrementing q by 1, print "*" ;  $  TAB3 for q = 1 + i * 2 to 0, while decrementing q by 1 print "D" ;  $  TAB3 for q = a - i * 2 + 1 / 2 to 0 while decrementing q by 1, print "*" ;  $  TAB3 endline ;  $  TAB1 for i = 0 to a exclusive, print "D" ;  $  TAB1 endline ;  $  TAB1 for i = 0 to a - 1 / 2 exclusive ;  $  TAB2 increment b by 1 ;  $  TAB2 for w = 0 to 1 exclusive ;  $  TAB3 for q = a - 1 + a - b * 2 / 2, to 0 while decrementing q by 1 print "*" ;  $  TAB3 for q = 1 a - b * 2, to 0 while decrementing q by 1, print "D" ;  $  TAB3 for q = a - 1 + a + a - b * 2 / 2, to 0 while decrementing q by q, print "*" ;  $  TAB3 endline ;
TAB1 n, a, cnt, max = integers with max set to 0 ;  $  TAB1 read n ;  $  TAB1 sub = vector of integers ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 push_back a in sub ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set cnt to 1 ;  $  TAB2 for j = i to n - 1 exclusive ;  $  TAB3 if sub[j] <= sub[j + 1] ;  $  TAB4 increment cnt by 1 ;  $  TAB3 else ;  $  TAB4 break ;  $  TAB2 if cnt > max, set max to cnt ;  $  TAB1 print max ;
TAB0 visited = boolean array of size 100001 ;  $  TAB0 parent = array of integer of size 100001 ;  $  TAB0 into the function initialize which take integer n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set visited[i] = 0 ;  $  TAB2 set parent[i] = i ;  $  TAB0 into the function sum which takes a integer n and return a long long integer ;  $  TAB1 create long long integer ans= n ;  $  TAB1 while n is not equal to 0 ;  $  TAB2 set ans = ans + n % 10 ;  $  TAB2 set n=n/10 ;  $  TAB1 return ans ;  $  TAB0 into the function max which takes x and y and return the maximum value of them ;  $  TAB1 return x is x>y else return y ;  $  TAB1 n=long long int ;  $  TAB1 read n ;  $  TAB1 x=long long int with x= n - n %10 ;  $  TAB1 a= long long int vector ;  $  TAB1 for i= max(n-82, 0) to n exclusive ;  $  TAB2 if sum(i) is n then add i to the end of a ;  $  TAB1 sort a ;  $  TAB1 print size of a ;  $  TAB1 print all elements of a ;
TAB0 m, n , Max, Min, sum = integers, with a being an array of intetegers set to length of 105 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort a and a + n ;  $  TAB1 for i = 0 to n - 1 exclusive, increment sum by a[n - 1] - a[i] ;  $  TAB1 set Max to a[n - 1] + m ;  $  TAB1 if a[n - 1] - a[0] >= m ;  $  TAB2 set Min to a[n - 1] ;  $  TAB1 else ;  $  TAB2 if m <= sum ;  $  TAB3 set Min to a[n - 1] ;  $  TAB2 else ;  $  TAB3 decrement m by sum ;  $  TAB3 if m modulo n is 0 ;  $  TAB4 set Min to a[n - 1] + m / n ;  $  TAB3 else ;  $  TAB4 set Min to a[n - 1] + m / n + 1 ;  $  TAB1 print Min, " ", Max ;
TAB0 let a, b integer arrays of size 110, and v1, v2, v3 be integer arrays of size 10 ;  $  TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment v1[a[i]] ;  $  TAB2 increment v[a[i]] ;  $  TAB1 for i = 0 to n ;  $  TAB2 read b[i] ;  $  TAB2 increment v2[b[i]] ;  $  TAB2 increment v[b[i]] ;  $  TAB1 let sum be integer with sum = 0 ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if v[i] is odd ;  $  TAB3 print -1 ;  $  TAB2 else if j == (n-i-1) and a[i][n-i-1] != fs ;  $  TAB3 increment sum by abs of v[i]/2 - v1[i] ;  $  TAB1 print sum / 2 ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 declare vector<string> cap, chill, rat, wo, men ;  $  TAB1 declare string x, y ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x and y ;  $  TAB2 if y equals "captain" ;  $  TAB3 append x to cap ;  $  TAB2 else if y equals "woman" or y equals "child" ;  $  TAB3 append x to wo ;  $  TAB2 else if y equals "man" ;  $  TAB3 append x to men ;  $  TAB2 else if y equals "rat" ;  $  TAB3 append x to rat ;  $  TAB1 define int s1 = rat size, s2 = wo size, s3 = men size, s4 = cap size ;  $  TAB1 print every element in rat ;  $  TAB1 print every element in wo ;  $  TAB1 print every element in men ;  $  TAB1 print every element in cap ;
TAB1 make int i, n, k ;  $  TAB1 read n, k ;  $  TAB1 for i = 0 to i less than k exclusive ;  $  TAB2 if n modulo 10 not equal 0 ;  $  TAB3 set n to n - 1 ;  $  TAB2 else ;  $  TAB3 set n to n /10 ;  $  TAB1 print n ;
TAB0 in the function gcd which is inline in nature and that takes two long long integers a and b and returns a long long integer ;  $  TAB1 if a is equal to 0 then return b ;  $  TAB1 return gcd(b % a, a) ;  $  TAB0 in the function power which is inline in nature that takes three long long integers a,n,m and returns a long long integer ;  $  TAB1 if n is equal to 0 then return 1 ;  $  TAB1 create long long integer p = power (a, n/2, m) ;  $  TAB1 set p = (p*p) % m ;  $  TAB1 if n%2 is true ;  $  TAB2 return (p * a) % m ;  $  TAB1 else do the following ;  $  TAB2 return p ;  $  TAB0 create constant long long integer MOD = 1000000007 ;  $  TAB0 create constant int INF = 0x3f3f3f3f ;  $  TAB0 create constant long long LL_INF = 0x3f3f3f3f3f3f3f3f; ;  $  TAB1 let x.s,y,mx be long long ints ;  $  TAB1 read s and x ;  $  TAB1 create long long integer j=1 ;  $  TAB1 set y = s - x ;  $  TAB1 if y%2 is not 0 ;  $  TAB2 print 0 and new line ;  $  TAB1 set y = y/2 ;  $  TAB1 create long long integer ans =1 ;  $  TAB1 set mx to max of x and s ;  $  TAB1 while j<=x ;  $  TAB2 if j & x ;  $  TAB3 if y & j ;  $  TAB4 print 0 and new line ;  $  TAB3 else do the following ;  $  TAB4 set ans = ans * 2 ;  $  TAB2 set j = j << 1 ;  $  TAB1 if x is equal to s then set ans to ans -2 ;  $  TAB1 print ans and a new line ;
TAB1 n, m, mini, maxi are long longs ;  $  TAB1 read n, m, mini, maxi ;  $  TAB1 arr = long long array of size m + 1 ;  $  TAB1 read m values into array arr ;  $  TAB1 call sort with arr + 1, arr + m + 1 ;  $  TAB1 if arr[1] is less than mini or arr[m] is greater than maxi ;  $  TAB2 output Incorrect ;  $  TAB1 if arr[1] equals mini and arr[m] equals maxi ;  $  TAB2 output Correct ;  $  TAB1 else if arr[1] equals mini or arr[m] equals maxi ;  $  TAB2 output Correct ;  $  TAB1 else ;  $  TAB2 if n - m equals 1LL ;  $  TAB3 output Incorrect ;  $  TAB2 else ;  $  TAB3 output Correct ;
TAB1 make long long n ;  $  TAB1 read n ;  $  TAB1 make array of long longs a with a size of n ;  $  TAB1 make array of long long b with size of 101 ;  $  TAB1 fill b with 0 ;  $  TAB1 for long long int i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment b[a[i]] ;  $  TAB1 make long long m = 0 ;  $  TAB1 for long long int i = 0 to 101 exclusive do set m to max of m and b[i] ;  $  TAB1 print m ;
TAB1 a1, a2, a3 are integers ;  $  TAB1 read a1, a2, a3 ;  $  TAB1 a is a float with a = a1 to the power of 0.5 ;  $  TAB1 b is a float with b = a2 to the power of 0.5 ;  $  TAB1 c is a float with c = a3 to the power of 0.5 ;  $  TAB1 d is a float with d = a * b * c ;  $  TAB1 display 4 * (d / a1 + d / a2 + d / a3) ;
TAB1 let a, b = long integers ;  $  TAB1 read a ;  $  TAB1 if a is 1 ;  $  TAB2 print 1 ;  $  TAB1 else if a is 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 declare an integer n ;  $  TAB1 input n ;  $  TAB1 declare an integer num ;  $  TAB1 declare integers sum, maxNum with sum = 0, maxNum = 0 ;  $  TAB1 fir i = 0 to n exclusive ;  $  TAB2 input num ;  $  TAB2 if maxNum is less than num, set maxNum to num ;  $  TAB2 add num to sum ;  $  TAB1 k = integer = 2 * sum / n + 1 ;  $  TAB1 if k is less than maxNum, display maxNum, else, display k ;
TAB1 n, m are integers ;  $  TAB1 read n, m ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 while decrement m ;  $  TAB2 l, r, i are integers ;  $  TAB2 c1, c2 are characters ;  $  TAB2 s1 = string = "" ;  $  TAB2 read l, r, c1, c2 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if s[i] equals c1 and i is at least l - 1 and i is at most r - 1 ;  $  TAB4 add c2 to s1 ;  $  TAB3 else ;  $  TAB4 add s[i] to s1 ;  $  TAB2 set s to s1 ;  $  TAB1 print s ;
TAB1 create long long integer array of size 3 ;  $  TAB1 read 3 values into the array arr ;  $  TAB1 sort array arr ;  $  TAB1 set arr[2] = arr[2] - arr[0] - arr[1] ;  $  TAB1 if arr[2] > = 0 ;  $  TAB2 print arr[2] + 1 and a newline ;  $  TAB1 else do the following ;  $  TAB2 print 0 ;  $  TAB3 print new line ;
TAB1 let a, x, t be integers ;  $  TAB1 read t ;  $  TAB1 while t != 0 ;  $  TAB2 read a ;  $  TAB2 if 360 mod (180 - a) == 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB2 decrement t ;
TAB1 let n = long long integer ;  $  TAB1 let arr = array of long long integers of size 100005 ;  $  TAB1 let temp = long long integers ;  $  TAB1 let result = long long integer with value = 0 ;  $  TAB1 let repeat = long long integer with value = 0 ;  $  TAB1 read n ;  $  TAB1 forlong long integer i=0 to n exclusive do the following ;  $  TAB2 read temp ;  $  TAB2 set arr[i] = temp ;  $  TAB1 for long long integer i=0 to n exclusive do the following ;  $  TAB2 let j = long long integer with value = i ;  $  TAB2 if j is not equal to 0 do the following ;  $  TAB3 if arr[j] is arr[j - 1] do the following ;  $  TAB4 set result = result + repeat ;  $  TAB4 decrement repeat ;  $  TAB4 continue from the top of the loop ;  $  TAB3 else ;  $  TAB4 set repeat = 0 ;  $  TAB2 while j is less than n and arr[j] is arr[i] do the following ;  $  TAB3 increment repeat ;  $  TAB3 increment result ;  $  TAB3 increment j ;  $  TAB2 decrement repeat ;  $  TAB1 print result ;
TAB0 in function gcd with parameters long long a, b and return long long ;  $  TAB1 return b is equal to 0 if 0 is equal to either a or call function gcd with arguments b, a mod b ;  $  TAB0 in function lcm with parameters long long a, b and return lcm ;  $  TAB1 return a * b / call function gcd with arguments a, b ;  $  TAB0 in function gr with parameters integers a, b and return boolean ;  $  TAB1 return a is greater than b ;  $  TAB1 l, r are long longs ;  $  TAB1 input l and r ;  $  TAB1 a = long long = 1 ;  $  TAB1 while a is less than or equal to r, assign a * 10 to a ;  $  TAB1 mx = long long = call function min with arguments (call function max with arguments a / 2, 1), r ;  $  TAB1 display mx * (a - mx - 1) ;
TAB0 declare function solve ;  $  TAB1 let integer n, k ;  $  TAB1 read n, k ;  $  TAB1 let ans = integer with ans = 0 ;  $  TAB1 let x = integer ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read x ;  $  TAB2 if x modulo k is 0 ;  $  TAB3 set ans = ans + x / k ;  $  TAB2 else ;  $  TAB3 ans = ans + x / k + 1 ;  $  TAB1 if ans modulo 2 is 0 ;  $  TAB2 print ans / 2 ;  $  TAB1 else ;  $  TAB2 print ans / 2 + 1 ;  $  TAB1 call function solve ;
TAB0 in the function gum which takes an integer x and returns a integer ;  $  TAB1 let s be an int with s=0 ;  $  TAB1 let k be a double with k=0 ;  $  TAB1 d=integer ;  $  TAB1 while x is not 0 ;  $  TAB2 set d to x mod 10 ;  $  TAB2 if d is 0 ;  $  TAB3 set x=x/10 ;  $  TAB3 then continue ;  $  TAB2 else do the following ;  $  TAB3 set s=s + (int)d + 10^k ;  $  TAB3 set x = x/10 ;  $  TAB2 add 1 to k ;  $  TAB1 return s ;  $  TAB1 x,y = double ;  $  TAB1 create a pair from int to int p of size 10000 ;  $  TAB1 s= character array of size 20 ;  $  TAB1 create boolean q = false ;  $  TAB1 create integer sum=0 ;  $  TAB1 create unsigned long long integer t ;  $  TAB1 create integer c and integer array a,b of size 100008 ;  $  TAB1 i,j,m,n = integers ;  $  TAB1 d,L,v1,v2 = double ;  $  TAB1 read s ;  $  TAB1 if s[0]= h or s[0]=a ;  $  TAB2 if s[1]=1 or s[1]=8 ;  $  TAB3 then print 3 ;  $  TAB2 else do the following ;  $  TAB3 print 5 ;  $  TAB1 else if s[1]=1 or s[1]=8 ;  $  TAB2 print 5 and new line ;  $  TAB1 else do the following ;  $  TAB2 print 8 and new line ;
TAB0 let maxn = integer constant with value 1000 ;  $  TAB1 let n, a, b = integers ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read a, b ;  $  TAB2 let sum = integer with value 0 ;  $  TAB2 while a is not equal to 0 and b is not equal to zero do the following ;  $  TAB3 if a is greater than b dothe following ;  $  TAB4 set sum = sum + a / b ;  $  TAB4 set a = a modulo b ;  $  TAB3 else do the following ;  $  TAB4 set sum = sum + b / a ;  $  TAB4 set b = b modulo a ;  $  TAB2 print sum ;
TAB1 let n, count, i, j = integers ;  $  TAB1 set count = 0 ;  $  TAB1 read n ;  $  TAB1 let line = array of integers size n and values = 0 ;  $  TAB1 read n values into array line ;  $  TAB1 let max = integer value = 0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if line[i] is greater than line[max] set max = i ;  $  TAB1 for i=max-1 to 0 inclusive decrementing do the following ;  $  TAB2 let temp = integer value = line[i] ;  $  TAB2 set line[i] = line[i+1] ;  $  TAB2 set line[i+1] = temp ;  $  TAB2 increment count ;  $  TAB1 let min = integer value = 0 ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 if line[i] is greater than or equal to line[min] set min = i ;  $  TAB1 print count + n - min -1 ;
TAB1 declare long long n, a, b, c, i, j, k ;  $  TAB1 read n, a, b, c ;  $  TAB1 define long long MIN = 9999999999 ;  $  TAB1 if n is evenly divisible by 4 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 for i = 0 to 4 inclusive ;  $  TAB3 for j = 0 to 4 inclusive ;  $  TAB4 for k = 0 to 4 inclusive ;  $  TAB5 if (n + i + j * 2 + k * 3) is evenly divisible by 4: set MIN to min(MIN, i * a + j * b + c * k) ;  $  TAB1 print MIN ;
TAB1 n, a, b, totalpass, ftpass are all integers with totalpass and ftpass both set to 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, b ;  $  TAB2 subtract a from totalpass ;  $  TAB2 add b to totalpass ;  $  TAB2 if totalpass is greater than ftpass, assign totalpass to ftpass ;  $  TAB1 display ftpass ;
TAB0 in function number with parameter character x and return integer ;  $  TAB1 n is an integer ;  $  TAB1 if x is the character 0 ;  $  TAB2 set n to 2 ;  $  TAB1 else if x is the character 1 ;  $  TAB2 set n to 7 ;  $  TAB1 else if x is the character 2 ;  $  TAB2 set n to 2 ;  $  TAB1 else if x is the character 3 ;  $  TAB2 set n to 3 ;  $  TAB1 else if x is the character 4 ;  $  TAB2 set n to 3 ;  $  TAB1 else if x is the character 5 ;  $  TAB2 set n to 4 ;  $  TAB1 else if x is the character 6 ;  $  TAB2 set n to 2 ;  $  TAB1 else if x is the character 7 ;  $  TAB2 set n to 5 ;  $  TAB1 else if x is the character 8 ;  $  TAB2 set n to 1 ;  $  TAB1 else if x is the character 9 ;  $  TAB2 set n to 2 ;  $  TAB1 return n ;  $  TAB1 s is a string ;  $  TAB1 ans is an integer set to 0 ;  $  TAB1 read s ;  $  TAB1 set ans to call number with s[0] * call number with s[1] ;  $  TAB1 display ans ;
TAB1 create integers price and r ;  $  TAB1 read price and r ;  $  TAB1 create integer counter= 1 ;  $  TAB1 while (price * counter) - r) % 10 is not 0 and (price * counter) % 10 is not 0 increment counter ;  $  TAB1 print counter and a new line ;
TAB0 N is a constant integer with N = 1000 ;  $  TAB0 n, x, z, sum are integers ;  $  TAB1 read n, x, z ;  $  TAB1 multiply z by n ;  $  TAB1 while n isn't 1 ;  $  TAB2 add ((x * 2) + 1) * (n / 2) to sum ;  $  TAB2 if n is even ;  $  TAB3 divide n by 2 ;  $  TAB2 else ;  $  TAB3 set n to (n + 2) / 2 ;  $  TAB1 display sum, " ", z ;
TAB1 r,c=integers with r=c=8 ;  $  TAB1 aux= string ;  $  TAB1 for i=0 to r inclusive ;  $  TAB2 read aux ;  $  TAB2 if aux is not equal to WBWBWBWB and aux is not equal to BWBWBWBW ;  $  TAB3 print NO ;  $  TAB4 print new line ;  $  TAB1 print YES ;  $  TAB2 print new line ;
TAB1 a,b = strings ;  $  TAB1 read a and b ;  $  TAB1 create integer x=0 ;  $  TAB1 for i=0 to size of a exclusive ;  $  TAB2 if a[i] is equal to b[i] then continue ;  $  TAB2 if a[i] is equal to 8 ;  $  TAB3 if b[i] is equal to ( ;  $  TAB4 decrement x ;  $  TAB3 else do the following ;  $  TAB4 increment x ;  $  TAB2 else if a[i] is equal to ( ;  $  TAB3 if b[i] is equal to [ ;  $  TAB4 subtract 1 from x ;  $  TAB3 else do the following ;  $  TAB4 add 1 to x ;  $  TAB2 else do the following ;  $  TAB3 if b[i] is equal to ( ;  $  TAB4 add 1 to x ;  $  TAB3 else do the following ;  $  TAB4 decrement x ;  $  TAB1 if x is 0 then print TIE else if x>0 print TEAM 1 WINS else print TEAM 2 WINS and new line ;
TAB0 let mp be a map of pair of long long and long long to long long ;  $  TAB0 define depth which takes long long x and return long long ;  $  TAB1 let ans be long long with ans = 0 ;  $  TAB1 while x is not equal to 0 ;  $  TAB2 set x to x/2 ;  $  TAB2 increment ans ;  $  TAB1 return ans ;  $  TAB0 define increase which takes long long a, b, c and returns long lon ;  $  TAB1 let x and y be long long with x = a and y = b ;  $  TAB1 let ans be long long with ans = 0 ;  $  TAB1 while x is not equal to y ;  $  TAB2 if depth of x is less than depth of y ;  $  TAB3 increment ans by mp[{y/2, y}] ;  $  TAB3 set mp[{y/2, y}] to mp[{y/2, y}] + c ;  $  TAB3 set y to y/2 ;  $  TAB2 else ;  $  TAB3 update ans to ans + mp[{x/2, x}] ;  $  TAB3 increment mp[{x/2, x}] by c ;  $  TAB3 set x to x/2 ;  $  TAB1 return ans ;  $  TAB1 q = long long ;  $  TAB1 read q ;  $  TAB1 a = b = c = d = long long ;  $  TAB1 while q is not zero, decrement q ;  $  TAB2 read a,b,c ;  $  TAB2 if a is equal to 1 ;  $  TAB3 read d ;  $  TAB3 call increase of c, b, d ;  $  TAB2 else ;  $  TAB3 let ans be long long with ans = increase of c, b, 0 ;  $  TAB3 print ans with newline ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare set words containing long longs ;  $  TAB1 for i = 0 to n exlcusive ;  $  TAB2 declare string s ;  $  TAB2 read s ;  $  TAB2 define vector<bool> b with length of 26 ;  $  TAB2 for j = 0 to s size exclusive do set b[s[j] - 'a'] to true ;  $  TAB2 define long long hash = 0, p = 1 ;  $  TAB2 for int j = 0; j less than 26; increment j, p <<= 1 do add b[j] * p to hash ;  $  TAB2 insert hash into words ;  $  TAB1 print words size ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare characters d, o ;  $  TAB1 declare multidimensional array a of size n*n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, read a[i][j] ;  $  TAB1 set d to a[0][0] ;  $  TAB1 set o to a[0][1] ;  $  TAB1 define int flag = 0 ;  $  TAB1 if d equals o, set flag to 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if (i equals j) or (i + j equals (n - 1)) ;  $  TAB4 if a[i][j] not equal to d ;  $  TAB5 set flag to 1 ;  $  TAB5 break ;  $  TAB3 else ;  $  TAB4 if a[i][j] not equal to o ;  $  TAB5 set flag to 1 ;  $  TAB5 break ;  $  TAB2 if flag equals 1, break ;  $  TAB1 if flag equals 0 ;  $  TAB2 print "YES" ;  $  TAB3 newline ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB3 newline ;
TAB1 n = integer ;  $  TAB1 k =integer ;  $  TAB1 read n and k ;  $  TAB1 lasttime= integer ;  $  TAB1 set lasttime to 240-k ;  $  TAB1 create integer ans=1 ;  $  TAB1 while lasttime >=0 and ans<=n+1 ;  $  TAB2 set lasttime = lasttime - abs*5 ;  $  TAB2 increment ans ;  $  TAB1 print ans-2 ;
TAB0 create constant integer N = 1e5 + 7 ;  $  TAB0 create long long arrays a and dp, both of size N ;  $  TAB0 create set<long long> x and y ;  $  TAB1 create integer aux ;  $  TAB1 read aux ;  $  TAB1 for i = 1 to aux inclusive, read a[i] ;  $  TAB1 if aux equals 2 ;  $  TAB2 print abs of a[1] - a[2] ;  $  TAB1 for i = 1 to aux exclusive ;  $  TAB2 create long long x = abs of a[i] - a[i + 1] ;  $  TAB2 if i bitwise and 1 ;  $  TAB3 set dp[i] to dp[i - 1] + x ;  $  TAB2 else ;  $  TAB3 set dp[i] to dp[i - 1] - x ;  $  TAB1 insert dp[1] into x ;  $  TAB1 insert dp[2] into y ;  $  TAB1 create long long result = max of dp[1] and dp[2] ;  $  TAB1 set result to max of result and abs of a[2] - a[3] ;  $  TAB1 for i = 3 to aux exclusive ;  $  TAB2 set result to max of result and dp[i] ;  $  TAB2 set result to max of result and dp[i] - first element of y ;  $  TAB2 set result to max of result and -(dp[i] - last element of x) ;  $  TAB2 if i bitwise and 1 ;  $  TAB3 insert dp[i] into x ;  $  TAB2 else ;  $  TAB3 insert dp[i] into y ;  $  TAB1 print result ;
TAB0 let n0, n1, b0, b1 be integers ;  $  TAB0 let a, b be integer arrays both of size 100010 ;  $  TAB1 read n0, n1, b0, b1 ;  $  TAB1 read n0 values into array a ;  $  TAB1 read n1 values into array b ;  $  TAB1 output YES if a[b0 - 1] is less than b[n1 - b1], otherwise output NO ;
TAB0 p is an integer array of size 100, n = integer, ans = integer, ans1 = integer, ans2 = integer, now = integer ;  $  TAB0 in function moveb and return integer ;  $  TAB1 assign 1 to now ;  $  TAB1 for i = 1 to n / 2 inclusive ;  $  TAB2 add absolute value of (p[i] - now) to ans1 ;  $  TAB2 add 2 to now ;  $  TAB1 return ans1 ;  $  TAB0 in function movew and return integer ;  $  TAB1 assign n to now ;  $  TAB1 for i = n / 2 to 1 inclusive with decrement i ;  $  TAB2 set ans2 to absolute value of (p[i] - now) ;  $  TAB2 subtract 2 from now ;  $  TAB1 return ans2 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n / 2 inclusive, input p[i] ;  $  TAB1 call sort on p + 1, p + (n / 2) + 1 ;  $  TAB1 set ans to call min on call moveb, call movew ;  $  TAB1 display ans ;
TAB1 let n, i, j, k, a, b, c, s, t, x, y, z be long long integer ;  $  TAB1 let p, q be char ;  $  TAB1 read p, q, n ;  $  TAB1 if n is even ;  $  TAB2 print undefined ;  $  TAB1 else ;  $  TAB2 if p == '^' and q == '>' ;  $  TAB3 if n mod 4 == 1 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == '>' and q == '^' ;  $  TAB3 if n mod 4 == 3 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == '^' and q == '<' ;  $  TAB3 if n mod 4 == 3 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == '<' and q == '^' ;  $  TAB3 if n mod 4 == 1 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == '>' and q == 'v' ;  $  TAB3 if n mod 4 == 1 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == 'v' and q == '>' ;  $  TAB3 if n mod 4 == 3 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == 'v' and q == '<' ;  $  TAB3 is n mod 4 == 1 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;  $  TAB2 else if p == '<' and q == 'v' ;  $  TAB3 if n mod 4 == 3 ;  $  TAB4 print cw ;  $  TAB3 else ;  $  TAB4 print ccw ;
TAB0 declare integer function check taking in long long n ;  $  TAB1 let count = integer with value = 0 ;  $  TAB1 if n is greater than 0 set n = -n ;  $  TAB1 while n is true do the following ;  $  TAB2 if n modulo 10 is 8 increment count ;  $  TAB2 set n = n / 10 ;  $  TAB1 return count ;  $  TAB1 let a = long long ;  $  TAB1 let count, f = integers with f = 0 ;  $  TAB1 read a ;  $  TAB1 set f = 0 ;  $  TAB1 while (true) is true do the following ;  $  TAB2 increment a ;  $  TAB2 increment f ;  $  TAB2 set count = result of calling check on a ;  $  TAB2 if count is greater than or equal to 1 exit the loop ;  $  TAB1 print f ;
TAB1 create character array s with a size of 100 ;  $  TAB1 create integers k, i = 0, cnt = 0 ;  $  TAB1 read s and k ;  $  TAB1 while s[i] is not equal to null character do add 1 to i ;  $  TAB1 for i = i - 1; i greater than or equal to 0; decrement i ;  $  TAB2 while s[i] greater than 48 ;  $  TAB3 decrement s[i] ;  $  TAB3 increment cnt ;  $  TAB3 if cnt is equal to k then goto L ;  $  TAB2 if s[i] is equal to 48 ;  $  TAB3 set s[i] to null character ;  $  TAB3 increment cnt ;  $  TAB2 if cnt is equal to k then goto L ;  $  TAB0 L label ;  $  TAB1 print s ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer array ara of size n + 1, i ;  $  TAB1 read n values into ara ;  $  TAB1 create integers a = 1, b = 2 ;  $  TAB1 create boolean c = false ;  $  TAB1 for i = 0 to n exlcusive ;  $  TAB2 if ara[i] is a or ara[i] is b ;  $  TAB3 set b to 6 - a - b ;  $  TAB3 set a to ara[i] ;  $  TAB2 else ;  $  TAB3 set c to true ;  $  TAB3 break ;  $  TAB1 if c ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 c = character ;  $  TAB1 n, i, t, e = integers set to 0 ;  $  TAB1 while reading c ;  $  TAB2 if c is 'n' ;  $  TAB3 increment n by 1 ;  $  TAB2 else if c is 'i' ;  $  TAB3 increment i by 1 ;  $  TAB2 else if c is 't' ;  $  TAB3 increment t by 1 ;  $  TAB2 else if c is 'e' ;  $  TAB3 increment e by 1 ;  $  TAB1 cont = integer set to 0 ;  $  TAB1 for k = i to k to 0, decrementing k by 1 ;  $  TAB2 if n >= 2 * k + 1 and t >= k and e >= 3 * k, increment cont by 1 ;  $  TAB1 print cont ;
TAB1 n,m = integers ;  $  TAB1 read n and m ;  $  TAB1 for i=0 to n ;  $  TAB2 print . if i&3 is equal to 0 else print # ;  $  TAB2 for j=0 to m-2 exclusive print . if i&1=1 else print # ;  $  TAB2 print . if i&3=3 else print # ;
TAB1 let n and k be integers ;  $  TAB1 read n and k ;  $  TAB1 let a1, a2, a3 be integers ;  $  TAB1 if (8 * n) % k is equal to 0 ;  $  TAB2 set a1 to (8*n) / k ;  $  TAB1 else ;  $  TAB2 set a1 to (8*n) / k + 1 ;  $  TAB1 if (5 * n) % k is equal to 0 ;  $  TAB2 set a2 to (5*n) / k ;  $  TAB1 else ;  $  TAB2 set a2 to (5*n) / k + 1 ;  $  TAB1 if (2*n) % k is equal to 0 ;  $  TAB2 set a3 to (2*n) / k ;  $  TAB1 else ;  $  TAB2 set a3 to (2*n) / k + 1 ;  $  TAB1 let sum be integer ;  $  TAB1 set sum to a1 + a2 + a3 ;  $  TAB1 print out sum with newline ;
TAB1 make int n and m ;  $  TAB1 read n and m ;  $  TAB1 if n is equal to 2 ;  $  TAB2 if m is equal to 1 ;  $  TAB3 print 4 ;  $  TAB2 else ;  $  TAB3 print 5 ;  $  TAB1 else if n is equal to 4 or n is equal to 6 or n is equal to 9 or n is equal to 11 ;  $  TAB2 if m is greater than or equal to 1 and m is less than or equal to 6 ;  $  TAB3 print 5 ;  $  TAB2 else ;  $  TAB3 print 6 ;  $  TAB1 else ;  $  TAB2 if m is greater than or equal to 1 and m is less than or equal to 5 ;  $  TAB3 print 5 ;  $  TAB2 else ;  $  TAB3 print 6 ;
TAB1 create string x = "hello" ;  $  TAB1 create int now = 0 ;  $  TAB1 create string s ;  $  TAB1 create boolean ok = false ;  $  TAB1 read s ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is equal to x[now] ;  $  TAB3 increment now ;  $  TAB3 if now is equal to 5 then set ok to true ;  $  TAB1 if ok ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n is an integer ;  $  TAB1 a is a long long array of size 100001 ;  $  TAB1 read n ;  $  TAB1 ans is an integer set to maximum integer value ;  $  TAB1 read a[0] ;  $  TAB1 m is a long long set to a[0] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 set m to call min with arguments m, a[i] ;  $  TAB1 ind is an integer ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if m equals a[i] ;  $  TAB3 set ind to i ;  $  TAB3 break ;  $  TAB1 for i = ind + 1 to n exclusive ;  $  TAB2 if a[ind] equals a[i] ;  $  TAB3 set ans to call min with arguments i - ind, ans ;  $  TAB3 set ind to i ;  $  TAB1 display ans ;
TAB1 n, size are integers ;  $  TAB1 result, pResult are booleans ;  $  TAB1 values = integer array set to -1, 1 ;  $  TAB1 b = string ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set result to true ;  $  TAB2 read size ;  $  TAB2 read b ;  $  TAB2 for j = 0 as long as j is less than size / 2 and result with increment j + 1 ;  $  TAB3 set pResult to false ;  $  TAB3 for k = 0 as long as k is less than 2 and not pResult with increment k + 1 ;  $  TAB4 for u = 0 as long as u is less than 2 and not pResult with increment u + 1 ;  $  TAB5 if b[j] + values[k] equals b[size - j - 1] + values[u], set pResult to true ;  $  TAB3 set result to pResult ;  $  TAB2 if result ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;
TAB1 create int n ;  $  TAB1 create string s ;  $  TAB1 read n and s ;  $  TAB1 create vector a holding int ;  $  TAB1 create int x ;  $  TAB1 create int m = 1 << 30 ;  $  TAB1 create bool f = false ;  $  TAB1 while n decremented ;  $  TAB2 read x ;  $  TAB2 push x onto a ;  $  TAB1 for i = 0 to a size exclusive ;  $  TAB2 if s[i] equals 'R' and s[i + 1] equals 'L' ;  $  TAB3 set m to min of a[i + 1] - a[i] and m ;  $  TAB3 set f to true ;  $  TAB1 if not f ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print m / 2 ;
TAB1 let n, m, s be long longs ;  $  TAB1 input n, m ;  $  TAB1 assign n + (n - 1) / (m - 1) to s ;  $  TAB1 print s ;
TAB1 z = integer ;  $  TAB1 x = integer ;  $  TAB1 read z and x ;  $  TAB1 create integer y = 0 ;  $  TAB1 while x is not equal to 0 do the following ;  $  TAB2 set y to y*10 ;  $  TAB2 set y = y + x%10 ;  $  TAB2 x = x/10 ;  $  TAB1 print z+y and new line ;
TAB0 create string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if i not equal 0 ;  $  TAB3 if s[i] greater than or equal to '5' ;  $  TAB4 print '9' - s[i] ;  $  TAB3 else ;  $  TAB4 print s[i] ;  $  TAB2 else if s[i] greater than or equal '5' and s[i] not equal '9' ;  $  TAB3 print '9' - s[i] ;  $  TAB2 else ;  $  TAB3 print s[i] ;  $  TAB1 print newline ;
TAB1 create int x, t, a, b, da, db ;  $  TAB1 read x, t, a, b, da, db ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 for j = 0 to t exclusive ;  $  TAB3 create int p and q ;  $  TAB3 assign a - i * da to p ;  $  TAB3 assign b -j * db to q ;  $  TAB3 if (p greater than -1 and q greater than -1) and (p + q equals x or p equals x or q equals x or x equals 0) ;  $  TAB4 print "YES" ;  $  TAB1 print "NO" ;
TAB1 let n, d, s = long longs ;  $  TAB1 read n ;  $  TAB1 let a = n arrays of long longs with size 4 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to 4 exclusive read a[i][j] ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 set d = a[i][0] / a[i][3] ;  $  TAB2 set s = d / a[i][1] * a[i][2] ;  $  TAB2 print s + d ;
TAB1 a and b are integers ;  $  TAB1 input a and b ;  $  TAB1 if absolute value (a - b) is at most 1 and (a isn't equal to 0 or b isn't equal to 0) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 let n, k be unsigned long ;  $  TAB1 read n, k ;  $  TAB1 while k > 0, decrement k ;  $  TAB2 if n mod 10 == 0 ;  $  TAB3 update n to n/10 ;  $  TAB2 else ;  $  TAB3 decrement n ;  $  TAB1 print n ;
TAB0 let a,x,y be integer array of size 105 each ;  $  TAB1 n,m,l,r= integers with l=0 ;  $  TAB1 read n and m ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read x[i] and y[i] ;  $  TAB2 if i is equal to 1 and x[i] is not equal to 0 ;  $  TAB3 print NO and new line ;  $  TAB2 if i is equal to 1 ;  $  TAB3 set r=y[i] ;  $  TAB2 else if x[i] <= r ;  $  TAB3 then set r to max of r and y[i] ;  $  TAB1 if r>=m ;  $  TAB2 print YES ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB1 make long lon n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n / 2 ;  $  TAB1 else ;  $  TAB2 print -(n + 1) / 2 ;
TAB1 create int t, s, q, ans = 0 ;  $  TAB1 read t, s, q ;  $  TAB1 while s less than t ;  $  TAB2 multiply s by itself and q ;  $  TAB2 add 1 to ans ;  $  TAB1 print ans ;
TAB1 let N, K = integer ;  $  TAB1 read N, K ;  $  TAB1 let C = integer ;  $  TAB1 read C ;  $  TAB1 let hld = array of integers with size = 368 ;  $  TAB1 set hld[0] = 0 ;  $  TAB1 let num = integer with value = 0 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 read hld[i] ;  $  TAB2 let j = integer with value = 1 ;  $  TAB2 while hld[i] - j * K is greater than hld[i - 1] dothe following ;  $  TAB3 increment num ;  $  TAB3 increment j ;  $  TAB1 let x = integer with value = 1 ;  $  TAB1 while hld[C] + x * K is less than or equal to N dothe following ;  $  TAB2 increment num ;  $  TAB2 increment x ;  $  TAB1 print num + C ;
TAB1 let n, ans, f, ans2 be integers with f = 0 and ans2 = INT_MAX ;  $  TAB1 read n ;  $  TAB1 arr = array of integers of size n+2 ;  $  TAB1 s = string ;  $  TAB1 read s, a, b, c ;  $  TAB1 read n values into array arr ;  $  TAB1 for i = 0 to size of s - 1 exclusive ;  $  TAB2 if s[i] == 'R' and s[i+1] == 'L' ;  $  TAB3 set ans to (arr[i] + arr[i-1]) / 2 - arr[i] ;  $  TAB3 if ans < ans2, update ans2 to ans ;  $  TAB3 set f to 1 ;  $  TAB1 if f == 0, update ans2 to -1 ;  $  TAB1 print ans2 ;
TAB1 a, z are integers ;  $  TAB1 b = integer array of size 4 ;  $  TAB1 input a ;  $  TAB1 c = integer = 0 ;  $  TAB1 d = integer = 0 ;  $  TAB1 while d isn't 6 ;  $  TAB2 increment a ;  $  TAB2 assign a to d ;  $  TAB2 for i = 0 to 4 exclusive ;  $  TAB3 set b[i] to d mod 10 ;  $  TAB3 divide d by 10 ;  $  TAB2 for i = 0 to 3 exclusive ;  $  TAB3 for j = i + 1 to 4 exclusive ;  $  TAB4 if b[i] isn't b[j], increment d ;  $  TAB2 if d equals 6 ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 continue ;  $  TAB1 print a ;
TAB0 maxn is a constant integer with maxn = 1100 ;  $  TAB0 a is an integer array with two dimensions both of size maxn, b is an integer array of size maxn ;  $  TAB0 s is a string array of size 110 ;  $  TAB1 declare variable n ;  $  TAB1 while input n ;  $  TAB2 for i = 0 to n exclusive, input s[i] ;  $  TAB2 top and flag are both integers and are both set to 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 for j = 0 to n exclusive ;  $  TAB4 if s[i][j] is equal to the character . ;  $  TAB5 increment top ;  $  TAB5 break ;  $  TAB2 if top is equal to n ;  $  TAB3 assign 1 to flag ;  $  TAB3 for i = 0 to n exclusive ;  $  TAB4 for j = 0 to n exclusive ;  $  TAB5 if s[i][j] is equal to the character . ;  $  TAB6 display i + 1, " ", and j + 1 ;  $  TAB6 break ;  $  TAB2 assign 0 to top ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 for i = 0 to n exclusive ;  $  TAB4 if s[i][j] is equal to the character . ;  $  TAB5 increment top ;  $  TAB5 break ;  $  TAB2 if top is equal to n and flag is false ;  $  TAB3 assign 1 to flag ;  $  TAB3 for j = 0 to n exclusive ;  $  TAB4 for i = 0 to n exclusive ;  $  TAB5 if s[i][j] is equal to the character . ;  $  TAB6 display i + 1, " ", and j + 1 ;  $  TAB6 break ;  $  TAB2 if not flag, puts -1 ;
TAB1 n,k,l,c,d,p,nl,np,x,y,z,res=integers with x=y=z=res=0 ;  $  TAB1 read n,k,l,c,d,p,nl,np ;  $  TAB1 set x = (k * l) / nl ;  $  TAB1 set y = (c * d) ;  $  TAB1 set z = p/np ;  $  TAB1 set res to minimum of x and y ;  $  TAB1 set res to minimum of res and z ;  $  TAB1 set res = res/n ;  $  TAB1 print res ;
TAB1 a, first, ok, on, last are integers with first = 0, ok = 990999, on = -99999 ;  $  TAB1 input a ;  $  TAB1 let arr be an integer array of length a + 1 ;  $  TAB1 for i = 0 to a exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if i is at least 1, set on to call max with on, arr[i] - arr[i - 1] ;  $  TAB1 for i = 0 to a - 2 exclusive ;  $  TAB2 if a equals 3 ;  $  TAB3 set first to arr[i + 2] - arr[0] ;  $  TAB2 else if i equals a - 3 ;  $  TAB3 set first to arr[i + 1] - arr[i - 1] ;  $  TAB2 else ;  $  TAB3 set first to call max with (arr[i + 2] - arr[i]), (arr[i + 3] - arr[i + 2]) ;  $  TAB2 set ok to call max with first, on ;  $  TAB2 if i equals 0 ;  $  TAB3 set last to ok ;  $  TAB2 else ;  $  TAB3 set last to call min with last, ok ;  $  TAB1 display last ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = string ;  $  TAB1 read a ;  $  TAB1 p = integer array of size n ;  $  TAB1 r = integer = -1 ;  $  TAB1 read n values into array p ;  $  TAB1 ans = integer = (10 to the power of 9) + 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is the character R, set r to i ;  $  TAB2 if a[i] is the character L or r is at least 0 ;  $  TAB3 if p[i] - p[r] is less than ans, set ans to p[i] - p[r] ;  $  TAB3 set r to -1 ;  $  TAB1 if ans isn't (10 to the power of 9) + 1 ;  $  TAB2 print ans / 2 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB0 create int arrays a and b, both with 1008 elements ;  $  TAB1 create ints n, m, ans = 0 ;  $  TAB1 read n and m ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for j = 1 to m inclusive, read b[j] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if b[j] less than a[i] and b[j] not equal to 0 ;  $  TAB4 break ;  $  TAB3 else if a[i] less than or equal to b[j] and b[j] not equal to 0 ;  $  TAB4 set b[j] to 0 ;  $  TAB4 increment ans ;  $  TAB4 break ;  $  TAB1 print ans ;
TAB1 let x = character ;  $  TAB1 let s, s1 = strings ;  $  TAB1 read x ;  $  TAB1 read s ;  $  TAB1 set s1 = qwertyuiopasdfghjkl;zxcvbnm,./ ;  $  TAB1 for integer i=0 to size of s do the following ;  $  TAB2 if x is R or x is r do the following ;  $  TAB3 if s[i] is q ;  $  TAB4 set s[i] = / ;  $  TAB3 else do the following ;  $  TAB4 for integer j=0 to size of s1 do the following ;  $  TAB5 if s[i] is s1[j] ;  $  TAB6 set s[i] = s1[j-1] ;  $  TAB6 exit the loop ;  $  TAB2 else do the following ;  $  TAB3 if s[i] is / ;  $  TAB4 set s[i] = q ;  $  TAB3 else do the following ;  $  TAB4 for integer j=0 to size of s1 do the following ;  $  TAB5 if s[i] is s1[j] ;  $  TAB6 set s[i] = s1[j-1] ;  $  TAB6 exit the loop ;  $  TAB1 print s ;
TAB0 s = string ;  $  TAB1 k = integer ;  $  TAB1 read s, and k ;  $  TAB1 cnt, ans = integers set to 0 ;  $  TAB1 sort begining of s and end of s ;  $  TAB1 for i = 0 to not the size of s inclusive ;  $  TAB2 if s[i] != s[i + 1], increment cnt by 1 ;  $  TAB2 increment ans by 1 ;  $  TAB1 if ans < k ;  $  TAB2 print "impossible" ;  $  TAB1 else ;  $  TAB2 if cnt >= k ;  $  TAB3 print 0 ;  $  TAB2 else ;  $  TAB3 print k - cnt ;
TAB1 let l, r, a = integers ;  $  TAB1 read l, r, a ;  $  TAB1 let val, rem = integers with val = 0 ;  $  TAB1 if a is 0 ;  $  TAB1 let add1, addr = integers with values = 0 ;  $  TAB1 if l is less than or equal to r do the following ;  $  TAB2 set l = l + a ;  $  TAB2 set add1 = 1 ;  $  TAB1 else do the following ;  $  TAB2 set r = r + a ;  $  TAB2 set addr = 1 ;  $  TAB1 let greater, lesser = integers with values = 0 ;  $  TAB1 if l is less than r do the following ;  $  TAB2 if addr is 1 do the following ;  $  TAB3 set val = 2 * l ;  $  TAB3 set rem = r - l ;  $  TAB3 if rem is odd ;  $  TAB4 set val = val + rem -1 ;  $  TAB3 else ;  $  TAB4 set val = val + rem ;  $  TAB2 else ;  $  TAB3 set val = 2 * l ;  $  TAB1 else do the following ;  $  TAB2 if add1 is 1 do the following ;  $  TAB3 set val = 2 * r ;  $  TAB3 set val = l - r ;  $  TAB3 if rem is odd ;  $  TAB4 set val = val + rem - 1 ;  $  TAB3 else ;  $  TAB4 set val = val + rem ;  $  TAB2 else ;  $  TAB3 set val = 2 * r ;  $  TAB1 print val ;  $  TAB1 print new line to stdout ;
TAB0 declare long long integer function maxSubArraySum taking in long long integer array a and long long integer size ;  $  TAB1 let max_so_far, max_ending_here = long long integers with max_so_far = integer minimum value and max_ending_here = 0 ;  $  TAB1 for long long integer i=0 to size exclusive do the following ;  $  TAB2 set max_ending_here = max_ending_here + a[i] ;  $  TAB2 if max_so_far is less than max_ending_here set max_so_far = max_ending_here ;  $  TAB2 if max_so_far is less than 0 set max_ending_here = 0 ;  $  TAB1 return max_so_far ;  $  TAB1 let n = long long integer ;  $  TAB1 read n ;  $  TAB1 let ar, f, s = arrays of long long integers with size of a = n, f = n-1 and s = n-1 ;  $  TAB1 read n values into array ar ;  $  TAB1 for long long integer i=0 to n-1 exclusive do the following ;  $  TAB2 let long long integer x = abs(ar[i] - ar[i + 1]) ;  $  TAB2 set f[i] = x ;  $  TAB2 let long long integer on = pow(-1, i) ;  $  TAB2 set f[i] = f[i] * on ;  $  TAB1 for long long integer i=0 to n - 1 exclusive do the following ;  $  TAB2 let long long integer x = abs(ar[i] - ar[i + 1]) ;  $  TAB2 set s[i] = x ;  $  TAB2 let long long integer on = pow(-1, i) ;  $  TAB2 set s[i] = s[i] * on ;  $  TAB1 let long long integer m1 = result of call maxSubArraySum on f, n - 1 ;  $  TAB1 let long long integer m1 = result of call maxSubArraySum on s, n - 1 ;  $  TAB1 print max of m1, m2 ;
TAB0 in inline function read, return type int ;  $  TAB1 create integers x = 0 and ff = 1 ;  $  TAB1 create character c = getchar() ;  $  TAB1 while c less than '0' OR c greater than '9' ;  $  TAB2 if c equals '-', set ff to -1 ;  $  TAB2 set c to getchar() ;  $  TAB1 while c is greater than or equal to '0' and c is less than or equal to '9' ;  $  TAB2 set x to (x << 1) + (x << 3) + (c ^ 48) ;  $  TAB2 set c to getchar() ;  $  TAB1 return x * ff ;  $  TAB0 in inline function in, return type int ;  $  TAB1 create int ff ;  $  TAB1 read ff ;  $  TAB1 return ff ;  $  TAB1 create integer array b of size 102 ;  $  TAB1 fill b with 0 ;  $  TAB1 create int n, x, k = 0 ;  $  TAB1 set n to in() ;  $  TAB1 while n decremented ;  $  TAB2 set x to in() ;  $  TAB2 pass ;  $  TAB2 set k to max of k and increment b[x] ;  $  TAB1 print k ;
TAB0 str is a character array of size 1010 ;  $  TAB1 k, i, j are integers ;  $  TAB1 let flag be an integer ;  $  TAB1 input str, k ;  $  TAB1 assign 0 to flag ;  $  TAB1 assign call strlen with str to len ;  $  TAB1 if len is divisible by k ;  $  TAB2 output NO ;  $  TAB1 else ;  $  TAB2 cnt is an integer set to len / k ;  $  TAB2 for i = 0 to len exclusive with increment i + cnt ;  $  TAB3 for j = 0 to cnt / 2 exclusive ;  $  TAB4 if str[i + j] is unequal to str[cnt + i - j - 1] ;  $  TAB5 assign 1 to flag ;  $  TAB5 break ;  $  TAB3 if flag, break ;  $  TAB2 if flag ;  $  TAB3 output NO ;  $  TAB2 else ;  $  TAB3 output YES ;
TAB1 make string str ;  $  TAB1 read str ;  $  TAB1 make integer len = length of str ;  $  TAB1 if len is less than 7 ;  $  TAB2 print "no\n" ;  $  TAB1 else ;  $  TAB2 make integers c = 0 and flag = 0 ;  $  TAB2 for i = len - 1; i greater than or equal to 0; decrement i ;  $  TAB3 if c is equal to 6 ;  $  TAB4 if str.at(i) is equal to '1' ;  $  TAB5 flag = 1 ;  $  TAB5 break ;  $  TAB4 else ;  $  TAB5 continue ;  $  TAB3 if str.at(i) is equal to '0' and i is not equal to 0 and c is less than 6, add 1 to c ;  $  TAB2 if flag is equal to 1 ;  $  TAB3 print "yes\n" ;  $  TAB2 else ;  $  TAB3 print "no\n" ;
TAB1 a, b, c, i, j = int ;  $  TAB1 x, y = double ;  $  TAB1 read a, b, and c ;  $  TAB1 i = a * c ;  $  TAB1 j = b * c ;  $  TAB1 x = i - j ;  $  TAB1 y = ceil x / b * 1.00 ;  $  TAB1 print y ;
TAB1 n = int ;  $  TAB1 read n ;  $  TAB1 arr = string of length n + 1 ;  $  TAB1 for i = 0 to n inclusive, read line to arr[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 l = int = arr[i] length ;  $  TAB2 if l is greater than 10 ;  $  TAB3 print arr[i].at(0), l - 2, arr[i].at(l - 1) ;  $  TAB2 else ;  $  TAB3 print arr[i] ;
TAB1 let c, sum, i be integers with sum = 0 ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 input c ;  $  TAB2 sum is assigned sum + c ;  $  TAB1 if sum mod 5 equals 0 and sum is greater than 0 ;  $  TAB2 output sum / 5 ;  $  TAB1 else ;  $  TAB2 output -1 ;
TAB1 n is a long long integer initialized to 100000 ;  $  TAB1 sum is a long long array of size n with sum[n] = 0 ;  $  TAB1 assign 1 to sum[1] ;  $  TAB1 for long long i = 2 to n inclusive, set sum[i] to sum[i - 1] + i ;  $  TAB1 a and temp are long longs ;  $  TAB1 input a ;  $  TAB1 for long long i = 1 to a - 1 inclusive ;  $  TAB2 input temp ;  $  TAB2 subtract temp from sum[a] ;  $  TAB1 display sum[a] ;
TAB1 p, i, s, e = short integers with s set to 0 ;  $  TAB1 read p ;  $  TAB1 for x = 1 to p exclusive ;  $  TAB2 set e to 1 ;  $  TAB2 for i = 1 to p -2 inclusive ;  $  TAB3 set e to e * x modulo p ;  $  TAB3 if !e-1, break ;  $  TAB2 if i is p -1 ;  $  TAB3 set e to e * x modulo p ;  $  TAB3 add !e -1 to s ;  $  TAB1 print s ;
TAB1 n= integers ;  $  TAB1 read n ;  $  TAB1 arr = array of interger of size n ;  $  TAB1 read n values into the array arr ;  $  TAB1 create an integer cnt with cnt = 0 ;  $  TAB1 create an integer val with val=0 ;  $  TAB1 create an integer ans with ans=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if val< arr[i] ;  $  TAB3 increment cnt ;  $  TAB2 else do the following ;  $  TAB3 set cnt=1 ;  $  TAB2 set val=arr[i] ;  $  TAB2 set ans to maximum of ans and cnt ;  $  TAB1 print ans ;
TAB0 f is an integer array of size 1005 ;  $  TAB0 g is an integer array of size 1005 ;  $  TAB0 in function find with parameter integer x and return integer ;  $  TAB1 return f[x] if f[x] equals x, otherwise return call find with f[x] ;  $  TAB0 in function clear ;  $  TAB1 for i = 0 to 1005 exclusive, set f[i] to i ;  $  TAB1 call memset with g, 0, call sizeof with g ;  $  TAB1 call clear ;  $  TAB1 n, m, k are integers ;  $  TAB1 read n, m, k ;  $  TAB1 i and j are integers ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 declare an integer gov ;  $  TAB2 read gov ;  $  TAB2 assign 1 to g[gov] ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 x and y are integers ;  $  TAB2 read x, y ;  $  TAB2 if g[x] equals 1 ;  $  TAB3 assign x to f[call find with y] ;  $  TAB2 else if g[y] equals 1 ;  $  TAB3 assign y to f[call find with x] ;  $  TAB2 else ;  $  TAB3 if g[call find with x] equals 1 ;  $  TAB4 set f[call find with y] to f[call find with x] ;  $  TAB3 else if g[call find with y] equals 1 ;  $  TAB4 set f[find call with x] to f[find call with y] ;  $  TAB3 else ;  $  TAB4 set f[find call with y] to f[find call with x] ;  $  TAB1 ans is an integer set to 0 ;  $  TAB1 maxx is an integer set to 0 ;  $  TAB1 temp is an integer ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 assign 1 to temp ;  $  TAB2 if g[i] ;  $  TAB3 for j = 1 to n inclusive ;  $  TAB4 if i isn't equal to j and not g[j] and f[call find with j] equals i, increment temp ;  $  TAB3 add temp * (temp - 1) / 2 to ans ;  $  TAB3 set maxx to call max with maxx, temp ;  $  TAB1 cnt is an integer set to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if not g[i] and not g[f[call find with i]], increment cnt ;  $  TAB1 add maxx * cnt to ans ;  $  TAB1 add cnt * (cnt - 1) / 2 to ans ;  $  TAB1 subtract m from ans ;  $  TAB1 display ans ;
TAB1 let ch and c be strings ;  $  TAB1 n,count,m,i,fin = integers with count=0, m=-1, and fin=1000 ;  $  TAB1 read n ;  $  TAB1 decrement n ;  $  TAB1 read ch ;  $  TAB1 while n-- is true ;  $  TAB2 read c ;  $  TAB2 for i=0 to size of c exclusive ;  $  TAB3 if c[i] is equal to ch[i] ;  $  TAB4 increment count ;  $  TAB3 else ;  $  TAB4 break ;  $  TAB2 set fin to minimum of fin and count ;  $  TAB2 set count to 0 ;  $  TAB2 call erase function on c ;  $  TAB1 print fin and new line ;
TAB1 t = integer ;  $  TAB1 print t ;  $  TAB1 while t is greater than 0 while decrementing by 1 ;  $  TAB2 a, b, k = long long integers ;  $  TAB2 read a, b and k ;  $  TAB2 ans = long long integer set to a - b ;  $  TAB2 set ans to ans * k / 2 ;  $  TAB2 if k modulo 2 is 1, increment ans by a ;  $  TAB2 print ans ;
TAB1 n, m are integers ;  $  TAB1 a = integer array of size 105 ;  $  TAB1 while input n, m ;  $  TAB2 read n values into array a ;  $  TAB2 call sort with a + 1, a + n + 1 ;  $  TAB2 cnt1 = integer = 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = i to n inclusive ;  $  TAB4 if a[j] - a[i] is at most m, set cnt1 to call max with cnt1, j - i + 1 ;  $  TAB2 print n - cnt1 ;
TAB1 let n, k = long longs ;  $  TAB1 read n, k ;  $  TAB1 let x = long long with value (n / 2) / (1+k) ;  $  TAB1 print x and a space and n - (x) * (1+k) ;
TAB1 a = integer ;  $  TAB1 read a ;  $  TAB1 arr= array of integer of size n ;  $  TAB1 read n values into array arr ;  $  TAB1 ans=integer with value 0 ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 create integer sum=0 ;  $  TAB2 if arr[i] is 1 then add 1 to sum ;  $  TAB2 create integer e = arr[i] ;  $  TAB2 while i<a and arr[i]=e ;  $  TAB3 add 1 to i ;  $  TAB3 set e = e + 1 ;  $  TAB3 increment sum ;  $  TAB2 if e=1001 then increment sum ;  $  TAB2 set ans to maximum of ans and sum-2 ;  $  TAB2 decrement i ;  $  TAB1 print ans and new line ;
TAB1 n,k= integers ;  $  TAB1 read n and k ;  $  TAB1 create integer arya and bran with arya=0 and bran=0 ;  $  TAB1 create integer s=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 t=integer ;  $  TAB2 read t ;  $  TAB2 if t+arya >= 8 ;  $  TAB3 set bran = bran + 8 ;  $  TAB3 set aray = arya + t - 8 ;  $  TAB3 add 1 to s ;  $  TAB2 else do the following ;  $  TAB3 set bran = bran + t + arya ;  $  TAB3 set arya to 0 ;  $  TAB3 add 1 to s ;  $  TAB2 if bran >= k ;  $  TAB3 print s and a new lien ;  $  TAB1 if bran < k print -1 and new line ;
TAB0 let v = vector of integers ;  $  TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 forinteger i=0 to length of s exclusive do the following ;  $  TAB2 if s[i] is r ;  $  TAB3 print i+1 ;  $  TAB2 else ;  $  TAB3 append i+1 to v ;  $  TAB1 forinteger i= size of v - 1 to 0 inclusive decrementing print v[i] ;
TAB1 n, i, count are integers with count = 0, f is an integer array of size 5001 ;  $  TAB1 read n ;  $  TAB1 read n values into array f ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if f[f[f[i]]] is equal to i, add 1 to count ;  $  TAB1 if count is positive ;  $  TAB2 output YES ;  $  TAB1 else ;  $  TAB2 output NO ;
TAB0 let n, m, k, sum = integer and a = array of integers of size 550 ;  $  TAB0 declare boolean function cmp taking in integers a1 and b1 ;  $  TAB1 return a1 is greater than b1 ;  $  TAB1 read n, m, k ;  $  TAB1 set sizeof(a) bytes starting at a to 0 ;  $  TAB1 read n values into array a ;  $  TAB1 call sort on a + 1 and a +1+n and function cmp ;  $  TAB1 if m is less than or equal to k do the following ;  $  TAB2 print 0 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 set sum = 0 ;  $  TAB2 for integer j=1 to i inclusive do the following ;  $  TAB3 if j is less than or equal to k set sum = sum + a[j] ;  $  TAB3 if j is greater than k and a[j] is not equal to 0 set sum = sum + a[j] - 1 ;  $  TAB2 if k - i is greater than0 set sum = sum + k - i ;  $  TAB2 if sum i greater than or equal to m do the following ;  $  TAB3 print i ;  $  TAB1 print -1 ;
TAB1 create integer n and count=0 ;  $  TAB1 read n ;  $  TAB1 arr= integer array of size n ;  $  TAB1 create integers sum1, sum2 and i with values 0 ;  $  TAB1 for i=i to n ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] >= 0 ;  $  TAB3 then set sum1 = sum1 + arr[i] ;  $  TAB2 else do the following ;  $  TAB3 set sum2 = sum2 + arr[i] ;  $  TAB1 if sum2 is 0 ;  $  TAB2 then print sum1 and new line ;  $  TAB1 else do the following ;  $  TAB2 for i=sum2 to sum1 inclusive increment count ;  $  TAB2 print count-1 and new line ;
TAB1 m, d are integers ;  $  TAB1 read m, d ;  $  TAB1 if m is 1 or m is 3 or m is 5 or m is 7 or m is 8 or m is 10 or m is 12 ;  $  TAB2 set d to 31 - (8 - d) ;  $  TAB2 set d to 1 if (d / 7 + ((d mod 7)) is true, otherwise set d to 0 ;  $  TAB1 else if m is 2 ;  $  TAB2 set d to 28 - (8 - d) ;  $  TAB2 set d to 1 if (d / 7 + ((d mod 7)) is true, otherwise set d to 0 ;  $  TAB1 else ;  $  TAB2 set d to 30 - (8 - d) ;  $  TAB2 set d to 1 if (d / 7 + (d mod 7)) is true, otherwise set d to 0 ;  $  TAB1 print increment d ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 declare string s1, s2, captain ;  $  TAB1 declare vector<string> rat, woman, man ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s1 and s2 ;  $  TAB2 if s2 equals "rat" ;  $  TAB3 append s1 to rat ;  $  TAB2 else if s2 equals "woman" or s2 equals "child" ;  $  TAB3 append s1 to woman ;  $  TAB2 else if s2 equals "man" ;  $  TAB3 append s1 to man ;  $  TAB2 else ;  $  TAB3 set captain to s1 ;  $  TAB1 print every element of rat ;  $  TAB1 print every element of woman ;  $  TAB1 print every element of man ;  $  TAB1 print captain ;
TAB0 define integer function get which takes in integer x as an argument. ;  $  TAB1 i = integer set to 0 ;  $  TAB1 while x is greater than 0 do the following ;  $  TAB2 x = x-5 ;  $  TAB2 increment i ;  $  TAB1 return the value of i ;  $  TAB1 x = integer ;  $  TAB1 read x ;  $  TAB1 print get(x) ;
TAB1 a, b, j are integers ;  $  TAB1 str is a character array of size 101 ;  $  TAB1 read a, b ;  $  TAB1 read str ;  $  TAB1 if a / 2 is less than b ;  $  TAB2 for b to a exclusive with increment b, display RIGHT ;  $  TAB1 else if a isn't b ;  $  TAB2 for b to 1 exclusive with decrement b, display LEFT ;  $  TAB1 else ;  $  TAB2 terminate statement ;  $  TAB1 if b is 1 ;  $  TAB2 for j = 0 to a exclusive ;  $  TAB3 display PRINT , str[j] ;  $  TAB3 increment j ;  $  TAB3 if j is less than a, display RIGHT ;  $  TAB1 else ;  $  TAB2 for j = a - 1 to 0 inclusive with no increment ;  $  TAB3 display PRINT , str[j] ;  $  TAB3 decrement j ;  $  TAB3 if j is at least 0, display LEFT ;
TAB1 n, a, b, i, c, j, m, o, p are integers with c set to 0 ;  $  TAB1 read n ;  $  TAB1 iterate n times ;  $  TAB2 read a, b ;  $  TAB2 if b - a is at least 2, increment c ;  $  TAB1 display c ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 declare stack<char> a ;  $  TAB1 for i = 0 to size of s ;  $  TAB2 if a is not empty and top of a equals s[i] ;  $  TAB3 pop a ;  $  TAB2 else ;  $  TAB3 push s[i] onto a ;  $  TAB1 set s to "" ;  $  TAB1 while a is not empty ;  $  TAB2 increase s by top of a ;  $  TAB2 pop a ;  $  TAB1 for i = size of s - 1 to 0 inclusive: print s[i] ;  $  TAB1 print newline ;
TAB1 let a, b = integers ;  $  TAB1 while (read a, b) is true do the following ;  $  TAB2 let t = integer ;  $  TAB2 set t = a ;  $  TAB2 if b is greater than a set t = b ;  $  TAB2 let i = integer ;  $  TAB2 let k = integer with value = 1 ;  $  TAB2 for i=0 to t inclusive set k = k * i ;  $  TAB2 print k ;
TAB1 n, d, min are integers with min = 1000 ;  $  TAB1 a = integer array of length 105 ;  $  TAB1 read n, d ;  $  TAB1 read n values into array a ;  $  TAB1 call sort with a, a + n ;  $  TAB1 ans = integer = 1, max = integer = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 if a[j] - a[i] is at most d ;  $  TAB4 increment ans ;  $  TAB3 else ;  $  TAB4 break ;  $  TAB2 if max is less than ans, set max to ans ;  $  TAB2 set ans to 1 ;  $  TAB1 print n - max ;
TAB1 let T be integer ;  $  TAB1 read T ;  $  TAB1 let n be integer ;  $  TAB1 s = string ;  $  TAB1 for 0 to T exclusive ;  $  TAB2 read n, s ;  $  TAB2 let ok be boolean with ok = true ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 let k be integer with k = abs of s[i] - s[n-i-1] ;  $  TAB3 if k is greater than 2 or k is odd ;  $  TAB4 set ok to false ;  $  TAB4 break ;  $  TAB2 if ok is true, print YES else print NO ;
TAB1 declare string s ;  $  TAB1 read a ;  $  TAB1 define int p = 0 ;  $  TAB1 for i = 0 to size of a exclusive ;  $  TAB2 if a[i] equals '4' or a[i] equals '7': increment p ;  $  TAB1 if p equals 4 or p equals 7 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 create string keyboard = "qwertyuiopasdfghjkl;zxcvbnm,./" ;  $  TAB0 let in,out be strings ;  $  TAB0 rl=char ;  $  TAB1 read rl and in ;  $  TAB1 create integer i=0 ;  $  TAB1 create char c=1 ;  $  TAB1 while c is not null ;  $  TAB2 set c=in[i] ;  $  TAB2 for j=0 to 30 exclusive ;  $  TAB3 if c=keyboard[j] ;  $  TAB4 if rl is R ;  $  TAB5 then set out = out + keyboard[j-1] ;  $  TAB4 else if rl is L then do the following ;  $  TAB5 set out = out + keyboard[j+1] ;  $  TAB2 add 1 to i ;  $  TAB1 print out ;
TAB1 a, b, sum, i are long long integers with sum = 1 ;  $  TAB1 read a, b ;  $  TAB1 if a is less than b ;  $  TAB2 for i = 1 to a inclusive, multiply sum by i ;  $  TAB1 else ;  $  TAB2 for i = 1 to b inclusive, multiply sum by i ;  $  TAB1 print sum ;
TAB1 L,p,q=integers ;  $  TAB1 read L,p,q ;  $  TAB1 create float time=L/(p+q) ;  $  TAB1 print p*time ;
TAB1 let n, i, j, x = integers ;  $  TAB1 read n ;  $  TAB1 let a = n arrays of integers size n ;  $  TAB1 let x = (n - 1) / 2 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive ;  $  TAB3 if fabs(i - x) + fabs(j - x) is less than or equal to x ;  $  TAB4 set a[i][j] = D ;  $  TAB3 else ;  $  TAB4 set a[i][j] = * ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 for j=0 to n exclusive print a[i][j] ;  $  TAB2 print a new line ;
TAB1 create string x, y ;  $  TAB1 create int t, z ;  $  TAB1 read t ;  $  TAB1 while t decremented is not 0 ;  $  TAB2 read x ;  $  TAB2 z = size of x ;  $  TAB2 if z is less than or equal to 10, print x; else print x[0], z - 2, x[z - 1] ;
TAB1 make int S, T, Q, ti = 0 ;  $  TAB1 read T, S, Q ;  $  TAB1 while S less than T ;  $  TAB2 multiply S by itself and Q ;  $  TAB2 increment ti ;  $  TAB1 print ti ;
TAB0 ar = integer array of length 100005 ;  $  TAB1 n is a long long ;  $  TAB1 input n ;  $  TAB1 ans is a long long with ans = 1 ;  $  TAB1 while n mod 3 equals 0, divide n by 3 ;  $  TAB1 add (n / 3ll) to ans ;  $  TAB1 display ans ;
TAB0 in the function search which takes an integer array A and integers l,u,target and returns an integer ;  $  TAB1 for i=1 to u exclusive ;  $  TAB2 if A[i] = target then return i ;  $  TAB1 return -1 ;  $  TAB1 n, C= integers ;  $  TAB1 read n and C ;  $  TAB1 R= array of integers of size n ;  $  TAB1 read n values into array R ;  $  TAB1 B= array of integer of size C ;  $  TAB1 Create integer curr_size =0 ;  $  TAB1 Create integer ans =0 ;  $  TAB1 for i =0 to n exclusive ;  $  TAB2 create integer idx= search(B,0,curr_size, R[i]) ;  $  TAB2 if idx is not -1 then continue ;  $  TAB2 add 1 to ans ;  $  TAB2 if curr_size is less than C ;  $  TAB3 set B[curr_size] = R[i] ;  $  TAB3 increment curr_size ;  $  TAB2 else do the following ;  $  TAB3 set idx to 0 ;  $  TAB3 create integer d= search(R,i+1,n, B[idx]) ;  $  TAB3 if d is not -1 ;  $  TAB4 for j=1 to C exclusive ;  $  TAB5 create integer curr_d = search(R, i+1, n , B[j]) ;  $  TAB5 if curr_d is equal to -1 ;  $  TAB6 set d to curr_d ;  $  TAB6 set idx to j ;  $  TAB6 break ;  $  TAB5 else do the following ;  $  TAB6 if curr_d is greater than d ;  $  TAB7 assign curr_d to d ;  $  TAB7 set idx= j ;  $  TAB3 set B[idx] = R[i] ;  $  TAB1 print ans ;
TAB0 declare signed 64 bit integer function solve which takes in signed 64 bit integer parameters s, a, b, c ;  $  TAB1 let k = signed 64 bit integer value = s / c ;  $  TAB1 return (a + b) * (k / a) + ( k modulo a) ;  $  TAB1 let t, s, a, b, c = signed 64 bit integers ;  $  TAB1 read t ;  $  TAB1 for signed 64 bit integer i=0 to t exclusive do the following ;  $  TAB2 read s, a, b, c ;  $  TAB2 print call solve on signed 64 bit integers s, a, b, c ;
TAB1 n, d, k are integers ;  $  TAB1 read n, d ;  $  TAB1 arr = integer array of size 101 ;  $  TAB1 read n values into array arr ;  $  TAB1 call sort with arr + 1, arr + n + 1 ;  $  TAB1 ans = integer set to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = i to n inclusive ;  $  TAB3 if arr[j] - arr[i] is at most d and j - i + 1 is greater than ans, set ans to j - i + 1 ;  $  TAB1 print n - ans ;
TAB0 arr1 = array of integers = {118, 60, 94, 62, 118, 60, 94} ;  $  TAB0 arr2 = array of integers ={118, 62, 94, 60, 118, 62, 94} ;  $  TAB1 let a, b be char ;  $  TAB1 let n be integer ;  $  TAB1 read a, b, n ;  $  TAB1 update n to n mod 4 ;  $  TAB1 let flag1, flag2 be boolean with flag1 = flag2 = false ;  $  TAB1 for i = 0 to 7 exclusive ;  $  TAB2 if arr1[i] == a ;  $  TAB3 if arr1[i+n] == b, set flag1 to true ;  $  TAB3 break ;  $  TAB1 for i = 0 to 7 exclusive ;  $  TAB2 if arr2[i] == a ;  $  TAB3 if arr2[i+n] == b, set flag2 to true ;  $  TAB3 break ;  $  TAB1 if (flag1 and flag2) or (!flag1 and !flag2) ;  $  TAB2 print out undefined ;  $  TAB1 else if flag1 is true ;  $  TAB2 print cw ;  $  TAB1 else ;  $  TAB2 print ccw ;
TAB1 let n, t be integers ;  $  TAB1 let arr be an integer array of size 30005 ;  $  TAB1 input n, t ;  $  TAB1 read n - 1 values into array arr ;  $  TAB1 let i be an integer set to 1 ;  $  TAB1 while i is less than t, add arr[i] to i ;  $  TAB1 print YES if i equals t, otherwise print NO ;
TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 make int q ;  $  TAB1 read q ;  $  TAB1 make set<int> df ;  $  TAB1 for i = 0 to q exclusive ;  $  TAB2 make int x ;  $  TAB2 read x ;  $  TAB2 insert x into df ;  $  TAB1 read q ;  $  TAB1 for i = 0 to q exclusive ;  $  TAB2 make int x ;  $  TAB2 read x ;  $  TAB2 insert x into df ;  $  TAB1 if size of df is n ;  $  TAB2 print "I become the guy.\n" ;  $  TAB1 else ;  $  TAB2 print "Oh, my keyboard!\n" ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 if n is odd ;  $  TAB2 print "Ehab" and newline ;  $  TAB1 else ;  $  TAB2 print "Mahmoud" and newline ;
TAB0 let a be an integer array of length 1000 ;  $  TAB1 let n and num be integers ;  $  TAB1 while input n ;  $  TAB2 call memset with a, 0, call sizeof with a ;  $  TAB2 iterate n times ;  $  TAB3 read num ;  $  TAB3 increment a[num] ;  $  TAB2 ans is an integer set to 0 ;  $  TAB2 iterate 600 times ;  $  TAB3 if a[i] is positive, increment ans ;  $  TAB2 display ans ;
TAB0 n, k, l, r, sum are long longs with sum set to 0 ;  $  TAB1 read n, k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read l, r ;  $  TAB2 add (r - 1) + 1 to sum ;  $  TAB1 display (k - sum modulo k) modulo k ;
TAB1 let k, r, sum be integers with sum = 1 ;  $  TAB1 read k, r ;  $  TAB1 while true ;  $  TAB2 if (sum * k) % 10 == r || (sum * k) % 10 == 0 ;  $  TAB3 print sum with newline ;  $  TAB3 break ;  $  TAB2 increment sum ;
TAB0 n,x,y = integers and a,b = arrays of integers size 100 and c = array of integer size 500 ;  $  TAB1 read n ;  $  TAB1 j = integer with j=1 ;  $  TAB1 for i = 1 to n*n inclusive do the following ;  $  TAB2 read x,y ;  $  TAB2 if a[x] is 0 and b[y] is 0 do the following ;  $  TAB3 a[x] = 1 ;  $  TAB3 b[y] = 1 ;  $  TAB3 c[j] = 1 ;  $  TAB3 increment j ;  $  TAB1 print c[1] ;  $  TAB1 for i = 2 to j exclusive print a space and c[i] ;  $  TAB1 print a new line ;
TAB0 flag = long long with flag = 0 ;  $  TAB0 let a be string ;  $  TAB0 define check with takes long long i and k ;  $  TAB1 for long long j = i to i + k exclusive ;  $  TAB2 if s[j] != s[2 * i + k - 1 - j] ;  $  TAB3 set flag = 1 ;  $  TAB1 read s ;  $  TAB1 let n, k be long long integer with n = length of s ;  $  TAB1 read k ;  $  TAB1 if n mod k != 0 ;  $  TAB2 print NO with newline ;  $  TAB1 for long long i = 0 to n exclusive with increment of n/k, call check with i and n/k ;  $  TAB1 if flag is equal to 1 ;  $  TAB2 print NO with newline ;  $  TAB1 else ;  $  TAB2 print YES with newline ;
TAB1 let n, t be integers ;  $  TAB1 read n, t ;  $  TAB1 let v be vector of integers of size n ;  $  TAB1 for i = 0 to n exclusive, read v[i] ;  $  TAB1 let i be integer with i = -1 ;  $  TAB1 while t is greater than 0 ;  $  TAB2 increment i ;  $  TAB2 update t to t - (86400 - v[i]) ;  $  TAB1 print out i+1 with new line ;
TAB1 nuts, divis, maxsec, capacity, boxes are integers with boxes = 0 ;  $  TAB1 read nuts, divis, maxsec, capacity ;  $  TAB1 while nuts is positive ;  $  TAB2 increment boxes ;  $  TAB2 subtract (call min with maxsec, divis + 1) * capacity from nuts ;  $  TAB2 subtract (call min with maxsec, divis + 1) - 1 from divis ;  $  TAB1 display boxes ;
TAB1 n = integer ;  $  TAB1 s = string ;  $  TAB1 read n ;  $  TAB1 read s ;  $  TAB1 p, m = integer ;  $  TAB1 set p to 0 ;  $  TAB1 set m to 0 ;  $  TAB1 while m != length of s ;  $  TAB2 if length of s is 2 ;  $  TAB3 if length of s != s[1] ;  $  TAB4 erase 0 to 2 of s ;  $  TAB4 break ;  $  TAB3 else ;  $  TAB4 break ;  $  TAB2 if s[p] != s[m] ;  $  TAB3 erase from p to 2 of s ;  $  TAB3 set m to max of p and 1 ;  $  TAB3 set p to max of 0 and --p ;  $  TAB2 else ;  $  TAB3 add 1 to p ;  $  TAB3 add 1 to m ;  $  TAB1 print length of s ;
TAB0 create int array arr with 150 elements ;  $  TAB1 fill arr with 0 ;  $  TAB1 create int n, p, q ;  $  TAB1 read n, p ;  $  TAB1 for i = 1 to p inclusive ;  $  TAB2 create int a ;  $  TAB2 read a ;  $  TAB2 set arr[a] to 1 ;  $  TAB1 read q ;  $  TAB1 for i = 1 to q inclusive ;  $  TAB2 create int a ;  $  TAB2 read a ;  $  TAB2 set arr[a] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if arr[i] equals 0 ;  $  TAB3 print "Oh, my keyboard!" ;  $  TAB1 print "I become the guy." ;
TAB0 INF is a constant integer with INF = 0x3f3f3f3f ;  $  TAB0 let PI be a constant double with PI = the arccosine of -1.0 ;  $  TAB1 let a and b be strings ;  $  TAB1 read a, b ;  $  TAB1 difA is an integer with difA = 0 ;  $  TAB1 difB is an integer with difB = 0 ;  $  TAB1 for i = the integer value 0 to the integer length of a exclusive ;  $  TAB2 if a[i] is unequal to b[i] ;  $  TAB3 if a[i] is equal to the character 4, increment difA ;  $  TAB3 if a[i] is equal to the character 7, increment difB ;  $  TAB1 if difA is greater than difB ;  $  TAB2 output difA ;  $  TAB1 else ;  $  TAB2 output difB ;
TAB1 n, ans, x, len, i are integers with ans and x both set to 0 ;  $  TAB1 str is a character array of length 110 ;  $  TAB1 input n ;  $  TAB1 input str ;  $  TAB1 set len to string length of str ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if str[i] is the character 8, increment x ;  $  TAB1 divide len by 11 ;  $  TAB1 if len is greater than x ;  $  TAB2 assign x to ans ;  $  TAB1 else ;  $  TAB2 assign len to ans ;  $  TAB1 display ans ;
TAB1 len, pos, i are long longs ;  $  TAB1 s is a character array of size 1000 ;  $  TAB1 while input len, pos ;  $  TAB2 input s ;  $  TAB2 if pos is greater than len / 2 ;  $  TAB3 if pos isn't len ;  $  TAB4 for i = 0 to (len - pos) exclusive, display RIGHT ;  $  TAB3 display PRINT , s[len - 1] ;  $  TAB3 for i = len - 2 to 0 inclusive, display LEFT, PRINT , s[i] ;  $  TAB2 else ;  $  TAB3 if pos isn't 1 ;  $  TAB4 for i = 1 to pos exclusive, display LEFT ;  $  TAB3 display PRINT ,s[0] ;  $  TAB3 for i = 1 to len exclusive, display RIGHT, PRINT ", s[i] ;
TAB1 let a, b, i, j = integers with i = 0 and k = array of integers with size = 4 ;  $  TAB1 let ch = array of characters with size = 6 ;  $  TAB1 read ch ;  $  TAB1 set a = (ch[0] -48) * 10 + ch[1] -48 ;  $  TAB1 set b = (ch[3] -48) * 10 + ch[4] -48 ;  $  TAB1 set k[0] = a / 10 ;  $  TAB1 set k[1] = a % 10 ;  $  TAB1 set k[2] = b / 10 ;  $  TAB1 set k[3] = b % 10 ;  $  TAB1 if k[0] is k[3] and k[1] is k[2] print 0 ;  $  TAB1 while k[0] is not equal to k[3] or k[1] is not equal to k[2] do the following ;  $  TAB2 increment i ;  $  TAB2 increment b ;  $  TAB2 ifb is greater than or equal to 60 do the following ;  $  TAB3 set b = 0 ;  $  TAB3 if a is 23 ;  $  TAB4 set a = 0 ;  $  TAB3 else if a is less than 23 ;  $  TAB4 incrementa ;  $  TAB2 set k[0] = a / 10 ;  $  TAB2 set k[1] = a % 10 ;  $  TAB2 set k[2] = b / 10 ;  $  TAB2 set k[3] = b % 10 ;  $  TAB2 if k[0] is k[3] and k[1] is k[2] do the folllowing ;  $  TAB3 print i ;  $  TAB3 exit the loop ;
TAB0 define f which takes integer c and cc as arguments and returns int ;  $  TAB1 if c > cc ;  $  TAB2 return cc ;  $  TAB1 else ;  $  TAB2 return c ;  $  TAB0 let n, i, j2, j3, k, r be integers with j2 = j3 = r = 0 ;  $  TAB0 let t1, t2, t3 be integer arrays of size 5001 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read Colours[i] ;  $  TAB2 read k ;  $  TAB2 if k == 1 ;  $  TAB3 update t1[r] to i + 1 ;  $  TAB3 increment r ;  $  TAB2 else if k == 2 ;  $  TAB3 t2[j2] = i + 1 ;  $  TAB3 increment j2 ;  $  TAB2 else if k == 3 ;  $  TAB3 t3[j3] = i + 1 ;  $  TAB3 increment j3 ;  $  TAB1 set k to f of f of r, j2 and j3 ;  $  TAB1 print k ;  $  TAB1 for i = 0 to k exclusive, print t1[i], " ", t2[i], " ", t3[i] ;
TAB1 t, a are integers ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 read a ;  $  TAB2 if 360 / (180 - a) equals ceiling ((float value of 360) / (180 - a)) ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;
TAB1 let q, e be integers ;  $  TAB1 read q ;  $  TAB1 for e = 0 to q exclusive ;  $  TAB2 n, x, y, d, k, p are long long integers with k and p both set to 10000000000 ;  $  TAB2 read n, x, y, d ;  $  TAB2 if absolute value (y - x) is divisible by d ;  $  TAB3 display absolute value (y - x) / d ;  $  TAB2 else ;  $  TAB3 if (y - 1) is divisible by d ;  $  TAB4 set k to (x - 1) / d + (y - 1) / d ;  $  TAB4 if (x - 1) isn't divisible by d, increment k ;  $  TAB3 if (n - y) isn't divisible by d ;  $  TAB4 set p to (n - x) / d + (n - y) / d ;  $  TAB4 if (n - x) isn't divisible by d, increment p ;  $  TAB3 if k or p aren't 10000000000 ;  $  TAB4 if k is less than p ;  $  TAB5 display k ;  $  TAB4 else ;  $  TAB5 display p ;  $  TAB3 else ;  $  TAB4 display -1 ;
TAB0 in function solve ;  $  TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 make vector<int> a of size 6, filled with 0 ;  $  TAB1 make vector<int> b of size 6, filled with 0 ;  $  TAB1 make integer x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 add 1 to a[x] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 increment b[x] ;  $  TAB1 make int exchanges = 0 ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 make integer avg = (a[i] + b[i]) / 2 ;  $  TAB2 if 2 * avg is not equal to a[i] + b[i] ;  $  TAB3 print -1 ;  $  TAB3 return ;  $  TAB2 if a[i] greater than avg, increase exchanges by a[i] - avg ;  $  TAB1 print exchanges ;  $  TAB1 invoke solve ;
TAB1 n and s are integers with s set to 0 ;  $  TAB1 c is an integer set to 0 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n + 1 inclusive ;  $  TAB2 add i to s ;  $  TAB2 add s to c ;  $  TAB2 if c is greater than n ;  $  TAB3 display i - 1 ;  $  TAB3 break ;
TAB1 let str = string ;  $  TAB1 read into str until new line ;  $  TAB1 let i, count, dis1, dis2, dis3, d = integers ;  $  TAB1 set dis1 = absolute value of(97 - integer cast of str[0]) ;  $  TAB1 set dis2 = absolute value of(122 - integer cast of str[0] + 1) ;  $  TAB1 set count = min of dis1 and dis2 ;  $  TAB1 for i=1 to size of str exclusive do the following ;  $  TAB2 let a = integer of value integer cast of str[i] ;  $  TAB2 let b = integer of value integer cast of str[i - 1] ;  $  TAB2 set dis1 = absolute value of b-a ;  $  TAB2 set dis2 = absolute value of(97 - a) + absolute value of(97 - b + 26) ;  $  TAB2 set dis3 = absolute value of(97 - b) + absolute value of(97 - a + 26) ;  $  TAB2 set d = min of dis2 and dis3 ;  $  TAB2 set count = count + min of dis1 and d ;  $  TAB1 print count ;
TAB1 pos = integer = 0 ;  $  TAB1 given = string ;  $  TAB1 num = string vector of size 10 ;  $  TAB1 read given ;  $  TAB1 read 10 values into array num ;  $  TAB1 while pos is less than 71 ;  $  TAB2 for i = 0 to 10 exclusive ;  $  TAB3 if substring of given from pos to 10 equals num[i] ;  $  TAB4 output i ;  $  TAB4 set i to 10 ;  $  TAB2 add 10 to pos ;  $  TAB1 output newline ;
TAB0 M = map of pair<int, int>, bool ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 V = vector of string ;  $  TAB1 row,col = vectors of integers ;  $  TAB1 resize V to n ;  $  TAB1 create long long integer ans=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read V[i] ;  $  TAB2 create integers cnt = 0 ;  $  TAB2 for j=0 to size of V[i] exclusive ;  $  TAB3 if V[i][j] is equal to C then increment cnt ;  $  TAB2 add cnt to end of row ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create integer cnt= 0 ;  $  TAB2 for j=0 to n exclusive ;  $  TAB3 if V[j][i] is equal to C then increment cnt ;  $  TAB2 add cnt to end of col ;  $  TAB1 for i=0 to size of row exclusive set ans = ans + (row[i] * (row[i] - 1)) / 2 ;  $  TAB1 for i=0 to size of col exclusive set ans = ans + (col[i] * (col[i] - 1)) / 2 ;  $  TAB1 print ans and new line ;
TAB0 in function max return type long long, parameters long long a and long long b ;  $  TAB1 return (if a greater than b, a; else, b) ;  $  TAB0 in function min with return type long long and parameters long long a and long long b ;  $  TAB1 return (if a is less than b, a; else, b) ;  $  TAB1 make long long t = 1 ;  $  TAB1 read t ;  $  TAB1 while t decremented ;  $  TAB2 make long long x ;  $  TAB2 read x ;  $  TAB2 assign 180 - x to x ;  $  TAB2 if 360 mod x ;  $  TAB3 print "NO\n" ;  $  TAB2 else ;  $  TAB3 print "YES\n" ;
TAB1 n, i, j, k, m, s, and p are long longs with j, k, and p set to 0 ;  $  TAB1 read n, k ;  $  TAB1 l and r are both long long arrays both of size n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read l[i], r[i] ;  $  TAB2 add r[i] - l[i] + 1 to p ;  $  TAB1 set s to p mod k ;  $  TAB1 set m to k - s ;  $  TAB1 display m mod k ;  $  TAB1 display newline ;
TAB0 INF is a constant integer set to 0x3f3f3f3f ;  $  TAB0 mod is a constant integer set to 1e9 + 7 ;  $  TAB0 N is a constant integer set to 1e5 + 5 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 sum is an integer set to 0 ;  $  TAB1 tmp is an integer set to 1 ;  $  TAB1 while tmp is at most n ;  $  TAB2 multiply tmp by 2 ;  $  TAB2 increment sum ;  $  TAB1 print sum ;
TAB1 let n, k be integers ;  $  TAB1 input n, k ;  $  TAB1 let x, y be integers ;  $  TAB1 let res be an integer set to 0 ;  $  TAB1 while decrement n ;  $  TAB2 read x, y ;  $  TAB2 add y - x + 1 to res ;  $  TAB1 if res is divisible by k ;  $  TAB2 display 0 ;  $  TAB1 else ;  $  TAB2 display k - res modulo k ;
TAB0 eps = constant long double = 1e-11 ;  $  TAB0 pi = constant long double = arccosine of -1.0 ;  $  TAB0 n = integer, a = integer array of size 1000 ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 out = integer = 0 ;  $  TAB1 for i = 1 to n - 2 inclusive ;  $  TAB2 if a[i - 1] is less than a[i] and a[i + 1] is less than a[i] ;  $  TAB3 increment out ;  $  TAB2 else if a[i - 1] is greater than a[i] and a[i + 1] is greater than a[i] ;  $  TAB3 increment out ;  $  TAB1 display out ;
TAB0 let na, nb, m, k = integers ;  $  TAB0 let A = array of integers with size = 100100 ;  $  TAB0 let B = array of integers with size = 100100 ;  $  TAB1 read na, nb ;  $  TAB1 read k, m ;  $  TAB1 read na values into array A ;  $  TAB1 rea dnb values into array B ;  $  TAB1 if A[k -1] is less than B[nb - m] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 Print NO ;
TAB0 declare boolean function beat which takes char parameters a and b ;  $  TAB1 if a is R and b is S return true ;  $  TAB1 if a is S and b is P return true ;  $  TAB1 if a is P and b is R return true ;  $  TAB1 return false ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let a,b = strings ;  $  TAB1 read a, b ;  $  TAB1 let sa, sb = integers value = 0 ;  $  TAB1 for integer i=0 to size of a * size of b exclusive do the following ;  $  TAB2 if beat(a[i modulo size of a], b[i modulo size of b]) increment sb ;  $  TAB2 if beat(b[i modulo size of b], a[i modulo size of a]) increment sa ;  $  TAB1 set sa = sa * ( n / (size of a * size of b)) ;  $  TAB1 set sb = sb * ( n / (size of a * size of b)) ;  $  TAB1 for integer i=0 to n modulo (size of a * size of b) exclusive do the following ;  $  TAB2 if beat(a[i modulo size of a], b[i modulo size of b]) increment sb ;  $  TAB2 if beat(b[i modulo size of b], a[i modulo size of a]) increment sa ;  $  TAB1 print sa and a space and sb ;
TAB1 let k, i, j = long long integers ;  $  TAB1 read k ;  $  TAB1 let a = array of long long integers size = 12 ;  $  TAB1 read 12n values into array a ;  $  TAB1 call sort on a and a + 12 ;  $  TAB1 if k is 0 do the following ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 for i=11 to 0 inclusive decrementing do the following ;  $  TAB3 set k = a[i] ;  $  TAB3 if k is less than or equal to 0 exit the loop ;  $  TAB2 if i is -1 do the following ;  $  TAB3 print i ;  $  TAB2 else ;  $  TAB3 print 12 - i ;
TAB1 let n be an integer ;  $  TAB1 while input n ;  $  TAB2 let x be an integer with x = n * square root of double value of 2 ;  $  TAB2 if n equals 0 ;  $  TAB3 output 1 ;  $  TAB2 else ;  $  TAB3 output x * 4 ;
TAB0 A and B are integer arrays both of sizes 5 and 5 ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 for j = 1 to 3 inclusive, read A[i][j] ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 for j = 1 to 3 inclusive ;  $  TAB3 add A[i][j] to B[i + 1][j] ;  $  TAB3 add A[i][j] to B[i][j] ;  $  TAB3 add A[i][j] to B[i - 1][j] ;  $  TAB3 add A[i][j] to B[i][j + 1] ;  $  TAB3 add A[i][j] to B[i][j - 1] ;  $  TAB1 for i = 1 to 3 inclusive ;  $  TAB2 for j = 1 to 3 exclusive ;  $  TAB3 if B[i][j] is even ;  $  TAB4 display 1 ;  $  TAB3 else ;  $  TAB4 display 0 ;  $  TAB2 print newline ;
TAB1 x, y, z are integers ;  $  TAB1 read x, y, z ;  $  TAB1 display 4 * (square root (x * y / z) + square root (x * z / y) + square root (z * y / x)) ;
TAB1 declare long long n, k ;  $  TAB1 read n, k ;  $  TAB1 define long long num1 = 0, num2 = 0, num3 = n ;  $  TAB1 define long long div = k + 1 ;  $  TAB1 if n / 2 < div ;  $  TAB2 print 0, " ", 0, " ", n ;  $  TAB1 define long long maxcnt = n / 2 ;  $  TAB1 define long long ans = maxcnt / div ;  $  TAB1 set num1 = ans ;  $  TAB1 set num2 = ans * k ;  $  TAB1 set num3 = n - num1 - num2 ;  $  TAB1 print num1, " ", num2, " ", num3 ;
TAB0 a, b are long arrays both of size 100006, c = long ;  $  TAB1 n, x are longs ;  $  TAB1 while input n, x ;  $  TAB2 s = integer set to 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if x is divisible by i ;  $  TAB4 if x / i is at most n, increment s ;  $  TAB2 print s ;
TAB1 let m, a, b, c be integers ;  $  TAB1 read m ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 read a ;  $  TAB2 if a >= 180 or a <= 0 ;  $  TAB3 print NO with newline ;  $  TAB3 continue ;  $  TAB2 if (360 / (180 - a) - int of (360 / (180 - a))) <= 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB0 let maxn be a constant integer with maxn = 105 ;  $  TAB1 declare integers n and k ;  $  TAB1 a is an integer array of length maxn ;  $  TAB1 input n, k ;  $  TAB1 for i = 0 to n exclusive, input a[i] ;  $  TAB1 sum = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 m = integer = a[i] ;  $  TAB2 t = integer = 0 ;  $  TAB2 while m isn't equal to 0 ;  $  TAB3 if m modulo 10 is equal to either 4 or 7, increment t ;  $  TAB3 assign m / 10 to m ;  $  TAB2 if t is less than or equal to k, increment sum ;  $  TAB1 display sum ;
TAB1 n, m = integers ;  $  TAB1 read n and m ;  $  TAB1 if m > n * n + 1 / 2, set m to m modulo n * n + 1 / 2 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i > m, break ;  $  TAB2 decrement m by i ;  $  TAB1 print m ;
TAB1 let n,i,count be ints with count=0 ;  $  TAB1 input n ;  $  TAB1 for i=0 to infinite ;  $  TAB2 if n>=100 ;  $  TAB3 set n=n-100 ;  $  TAB3 increment count ;  $  TAB3 if n equals to 0 then break ;  $  TAB2 else if n>=20 ;  $  TAB3 set n=n-20 ;  $  TAB3 add 1 to count ;  $  TAB3 if n=0 then break ;  $  TAB2 else if n>=10 then do the following ;  $  TAB3 set n=n-10 ;  $  TAB3 increment count ;  $  TAB3 if n=0 then break ;  $  TAB2 else if n>=5 ;  $  TAB3 set n=n-5 ;  $  TAB3 increment count ;  $  TAB3 if n=0 then break ;  $  TAB2 else if n>=1 then do the following ;  $  TAB3 set n to n-1 ;  $  TAB3 increase count by 1 ;  $  TAB3 if n=0 then break ;  $  TAB1 print count ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 a = integer ;  $  TAB1 v= vector integer ;  $  TAB1 for i=0 to n ;  $  TAB2 read a ;  $  TAB2 add a to the end of v ;  $  TAB1 create integer ans = INT_MAX and f=0 ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 if s[i] is equal to R and s[i+1] is equal to L ;  $  TAB3 set ans to minimum of ans and v[i + 1] - v[i]) / 2 ;  $  TAB3 set f to 1 ;  $  TAB1 if f is 0 ;  $  TAB2 print -1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print ans and a new line ;
TAB1 let v be an integer ;  $  TAB1 input v ;  $  TAB1 if v equals 2 ;  $  TAB2 output 2 ;  $  TAB1 else ;  $  TAB2 output 1 ;
TAB1 let n and p be integers ;  $  TAB1 let a0 be an integer with a0 = the character a - 1 ;  $  TAB1 input n, p ;  $  TAB1 a is a string ;  $  TAB1 input a ;  $  TAB1 i is an integer ;  $  TAB1 for i = the size of a - 1 to 0 inclusively ;  $  TAB2 now is a character with now = a[i] + 1 ;  $  TAB2 if i - 1 is greater than or equal to 0 and now equals a[i - 1], now is assigned now + 1 ;  $  TAB2 if i - 2 is greater than or equal to 0 and now equals a[i - 2], now is assigned now + 1 ;  $  TAB2 if i - 1 is greater than or equal to 0 and now equals a[i - 1], now is assigned now + 1 ;  $  TAB2 if now - a0 is greater than p, continue ;  $  TAB2 assign now to a[i] ;  $  TAB2 increment i ;  $  TAB2 break ;  $  TAB1 for i to the size of a exclusively ;  $  TAB2 declare an integer j ;  $  TAB2 for j = 1 to p inclusively ;  $  TAB3 if i - 1 is greater than or equal to 0 and a0 + j equals a[i - 2], continue ;  $  TAB3 if i - 2 is greater than or equal to 0 and a0 + j equals a[i - 2], continue ;  $  TAB3 assign a0 + j to a[i] ;  $  TAB3 break ;  $  TAB2 if j equals p + 1 ;  $  TAB3 set i to -1 ;  $  TAB3 break ;  $  TAB1 if i equals -1 ;  $  TAB2 print NO ;  $  TAB1 else ;  $  TAB2 output a ;
TAB0 M is a constant long long set to 998244353 ;  $  TAB0 oo is a constant long long set to 1e13 ;  $  TAB1 n, x, y are long longs ;  $  TAB1 s is a string ;  $  TAB1 read n, x, y, s ;  $  TAB1 co, o are long longs both set to 0 ;  $  TAB1 add the character 1 to s ;  $  TAB1 for i = 0 to n + 1 exclusive ;  $  TAB2 if s[i] is the character 1 and o equals 1, increment co, set o to 0 ;  $  TAB2 if s[i] is the character 0, set o to 1 ;  $  TAB1 if co equals 0, return print 0, newline, 0 ;  $  TAB1 if co equals 1, return print y, newline, 0 ;  $  TAB1 if x * (co - 1) + y is at most y * co ;  $  TAB2 print x * (co - 1) + y ;  $  TAB1 else ;  $  TAB2 print y * co ;
TAB0 let one, zero be integers ;  $  TAB1 let t be integer ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 let a be integer ;  $  TAB2 read a ;  $  TAB2 if (360 % (180 - a) == 0) ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 create string s ;  $  TAB1 create integer n, x = 1, y = 1 ;  $  TAB1 read n ;  $  TAB1 while n decremented is not 0 ;  $  TAB2 read s ;  $  TAB2 if s equals "ULDR": increment x and y, else if s equals "UR" or s equals "DL" increment x, else increment y ;  $  TAB1 print 1LL * x * y ;
TAB1 create string str ;  $  TAB1 read str ;  $  TAB1 for i = 0 to str size exclusive ;  $  TAB2 if str[i] greater than '>', set str[i] to (9 - (str[i] - '0')) + '0' ;  $  TAB1 if str[0] is equal to '0', set str[0] to '9' ;  $  TAB1 print str ;
TAB0 declare set<char> a ;  $  TAB0 declare map<string, int> m ;  $  TAB1 declare int n ;  $  TAB1 declare string x ;  $  TAB1 declare string y ;  $  TAB1 clear m ;  $  TAB1 read n ;  $  TAB1 define int ans = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 clear a ;  $  TAB2 clear y ;  $  TAB2 read x ;  $  TAB2 for i = 0 to x size exclusive do insert x[i] into a ;  $  TAB2 set<char>::iterator it = a.begin(); it is not equal to a.end(); increment it) do increase y by *it ;  $  TAB2 if not m[y] then increment ans ;  $  TAB2 set m[y] to 1 ;  $  TAB1 print ans ;
TAB1 declare long longs n, m, a, b ;  $  TAB1 read n, m, a, b ;  $  TAB1 if n modulo m == 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 let long long x = n / m ;  $  TAB2 let long long y = n / m + 1 ;  $  TAB2 print min((y * m - n) * a, (n - m * x) * b) ;
TAB1 p,b,t,x = integers ;  $  TAB1 read p,b,t ;  $  TAB1 create integer match=0 ;  $  TAB1 set x=p ;  $  TAB1 if x is equal to 1 ;  $  TAB2 print 0 and t ;  $  TAB1 while true ;  $  TAB2 if p/2= 1 and p mod 2 is 0 then break ;  $  TAB2 set match = match + p/2 ;  $  TAB2 set p = p/2 + p%2 ;  $  TAB1 add 1 to match ;  $  TAB1 print match + (2 * match * b) and x*t ;
TAB1 n, h, a, b, k are long longs ;  $  TAB1 read n, h, a, b, k ;  $  TAB1 for i = 1 to k inclusive ;  $  TAB2 declare integers t1, f1, t2, f2 ;  $  TAB2 read t1, f1, t2, f2 ;  $  TAB2 if t1 is the same as t2 ;  $  TAB3 display absolute value (f1 - f2) ;  $  TAB3 continue ;  $  TAB2 if both f1 and f2 are less than a ;  $  TAB3 display absolute value (t1 - t2) + absolute value (a - f1) + absolute value (a - f2) ;  $  TAB3 continue ;  $  TAB2 if both f1 and f2 are greater than b ;  $  TAB3 display absolute value (t1 - t2) + absolute value (b - f1) + absolute value (b - f2) ;  $  TAB3 continue ;  $  TAB2 display absolute value (t1 - t2) + absolute value (f1 - f2) ;
TAB0 create a constant integer maxn = 107 ;  $  TAB0 let mp be a map of string, int ;  $  TAB0 in the function init ;  $  TAB1 set mp["L"] = 1 ;  $  TAB1 set mp["XL"] = 2 ;  $  TAB1 set mp["XXL"] = 3 ;  $  TAB1 set mp["XXXL"] = 4 ;  $  TAB1 set mp["S"] = 5 ;  $  TAB1 set mp["XS"] = 6 ;  $  TAB1 set mp["XXS"] = 7 ;  $  TAB1 set mp["XXXS"] = 8 ;  $  TAB1 set mp["M"] = 9 ;  $  TAB0 let a and b be integer array of sizes 10 ;  $  TAB1 call init function ;  $  TAB1 n= integer ;  $  TAB1 s = string ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive read s and increment a[mp[s]] ;  $  TAB1 for i=1 to n inclusive read s and increment b[mp[s]] ;  $  TAB1 for i=1 to 9 inclusive ;  $  TAB2 if b[i] > = a[i] ;  $  TAB3 set b[i] = b[i] - a[i] and set a[i]=0 ;  $  TAB2 else do the following ;  $  TAB3 set a[i] = a[i] - b[i] and set assign 0 to b[i] ;  $  TAB1 create integer ans =0 ;  $  TAB1 for i =1 to 9 inclusive set asn=ans + b[i] ;  $  TAB1 print ans ;
TAB0 arr = array of integers set to length 5000010 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i + i] ;  $  TAB1 set arr[0] to arr[1] ;  $  TAB1 set arr[n + 1] to arr[n] ;  $  TAB1 set ans to 0 ;  $  TAB1 strange = boolean set to false ;  $  TAB1 start = integer set to -1 ;  $  TAB1 lef = integer set to -1 ;  $  TAB1 end = integer set to -1 ;  $  TAB1 right = integer set to -1 ;  $  TAB1 mid = integer set to -1 ;  $  TAB1 length = integer set to end - start + 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if arr[i - 1] isn't arr[i] and arr[1 + 1] isn't arr[i] ;  $  TAB3 if not strange ;  $  TAB4 set strange to true ;  $  TAB4 set start to i ;  $  TAB4 set left to arr[i - 1] ;  $  TAB2 else ;  $  TAB3 if strange is true ;  $  TAB4 set end to i - 1 ;  $  TAB4 set right to arr[i] ;  $  TAB4 set length to end - start + 1 ;  $  TAB4 set ans = max of ans and length + 1 / 2 ;  $  TAB4 set mid to length / 2 + start - 1 ;  $  TAB4 for j = start to mid inclusive, set arr[j] to left ;  $  TAB4 for j = mid + 1 to end inclusive, set arr[j] to right ;  $  TAB4 set strange to false ;  $  TAB1 print ans ;  $  TAB1 for i = 1 to n - 1 inclusive, print arr[i] ;  $  TAB1 print arr[n] ;
TAB1 let n, b, d, a = integer ;  $  TAB1 read n, b, d ;  $  TAB1 let ans = integer with value = 0 ;  $  TAB1 let cap = integer with value = 0 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 read a ;  $  TAB2 if a is less than b go to the top of the loop ;  $  TAB2 set cap = cap + a ;  $  TAB2 if cap is less than d do the following ;  $  TAB3 increment ans ;  $  TAB3 set cap = 0 ;  $  TAB1 ans ;
TAB1 make unsigned long t ;  $  TAB1 read t ;  $  TAB1 make vector<int> vec ;  $  TAB1 make vector<int> ones ;  $  TAB1 make vector<int> twos ;  $  TAB1 make vector<int> threes ;  $  TAB1 make int x ;  $  TAB1 make unsigned long sum = 0 ;  $  TAB1 make int one = 0, two = 0, three = 0 ;  $  TAB1 for unsigned long i = 0 to t exclusive ;  $  TAB2 read x ;  $  TAB2 if x is equal to 1 ;  $  TAB3 increment one ;  $  TAB3 push i + 1 onto ones ;  $  TAB2 else if x equal 2 ;  $  TAB3 increment two ;  $  TAB3 push i + 1 onto twos ;  $  TAB2 else ;  $  TAB3 increment three ;  $  TAB3 push i + 1 onto threes ;  $  TAB2 push x onto vec ;  $  TAB1 make int temp = one ;  $  TAB1 if temp is greater than two, set temp to two ;  $  TAB1 if temp is greater than three, set temp to three ;  $  TAB1 print temp ;  $  TAB1 for int l = 0 to temp exclusive, print ones[l], " ", twos[l], " ", threes[l] ;
TAB0 let l1, l2, r1, r2, w be long long ;  $  TAB1 read l1, r1, l2, r2, w ;  $  TAB1 if l1 is greater than r2 or r1 is greater than l2 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 if w is greater than or equal to max of l1, l2 and w is less than or equal to min of r1, r2 ;  $  TAB3 print min of r1, r2 - max of l1,l2 ;  $  TAB2 else ;  $  TAB3 print min of r1, r2 - max of l1,l2 + 1 ;
TAB0 declare int n, t, array a of size 105, ans ;  $  TAB1 read n and t ;  $  TAB1 for i = 1 to n inclusive: read a[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 increase ans by 86400 - a[i] ;  $  TAB2 if ans >= t ;  $  TAB3 print i ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 card = integer = n - 10 ;  $  TAB1 if card is at least 2 and card is at most 9 ;  $  TAB2 display 4 ;  $  TAB1 else if card equals 10 ;  $  TAB2 display 15 ;  $  TAB1 else if card equals 1 or card equals 11 ;  $  TAB2 display 4 ;  $  TAB1 else ;  $  TAB2 display 0 ;
TAB1 create int n, sum = 0 ;  $  TAB1 read n ;  $  TAB1 create string s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s ;  $  TAB2 if s[0] is 'T' ;  $  TAB3 increase sum by 4 ;  $  TAB3 continue ;  $  TAB2 if s[0] is 'C' ;  $  TAB3 increase sum by 6 ;  $  TAB3 continue ;  $  TAB2 if s[0] is 'O' ;  $  TAB3 increase sum by 8 ;  $  TAB3 continue ;  $  TAB2 if s[0] is 'D' ;  $  TAB3 increase sum by 12 ;  $  TAB3 continue ;  $  TAB2 if s[0] is 'I' ;  $  TAB3 increase sum by 20 ;  $  TAB3 continue ;  $  TAB1 print sum ;
TAB1 let t = integer ;  $  TAB1 read t ;  $  TAB1 while (decrement t) is true do the following ;  $  TAB2 let n = integer ;  $  TAB2 let str = string ;  $  TAB2 read n, str ;  $  TAB2 let i, j, r = integers with i = 0, j = n-1 ;  $  TAB2 let fl = boolean with value = true ;  $  TAB2 while i is less than j do the following ;  $  TAB3 set r = abs(str[i] - str[j] ;  $  TAB3 if r is 1 or r is greater than 2 set fl = 0 ;  $  TAB3 increment i ;  $  TAB3 decrement j ;  $  TAB2 if fl is true write YES to stdout else write NO to stdout ;
TAB1 let n, x, a, b, c = long longs ;  $  TAB1 read n ;  $  TAB1 for integer i=1 to infinity do the following ;  $  TAB2 if (i * i + 1) / 2 is greater than n dothe following ;  $  TAB3 set x = i ;  $  TAB3 exit the loop ;  $  TAB1 for integer i=1 to x inclusive ;  $  TAB2 set a = i * (i+1) / 2 ;  $  TAB2 set b = (n - a) * 2 ;  $  TAB2 set c= square root of b ;  $  TAB2 if c * (c+1) is b and (b / 2) +a is n and a and b do the following ;  $  TAB3 print YES ;  $  TAB1 print NO ;
TAB1 let n, m, i, k, j = integers ;  $  TAB1 read n, m ;  $  TAB1 for k=1 to n inclusive do the following ;  $  TAB2 if k is odd ;  $  TAB3 for j=1 to m inclusive print # ;  $  TAB2 if k is even do the following ;  $  TAB3 if k modulo 4 is 0 do the following ;  $  TAB4 print # ;  $  TAB4 for j=1 to m exclusive print . ;  $  TAB3 else ;  $  TAB4 for j=1 to m exclusive print . ;  $  TAB4 print # ;  $  TAB2 print new line ;
TAB1 n, a are integers ;  $  TAB1 read a, n ;  $  TAB1 sum = integer = 0 ;  $  TAB1 while n isn't 0 ;  $  TAB2 k = integer = n mod 10 ;  $  TAB2 sum = sum * 10 + k ;  $  TAB2 divide n by 10 ;  $  TAB1 print sum + a ;
TAB1 create int n, m ;  $  TAB1 create int price = 9000000 ;  $  TAB1 create multidimensional int array a 110x110 = { 0 }, b array of size 110 = { 0 } ;  $  TAB1 read n, m ;  $  TAB1 for i = 1 to n inclusive, read b[i] ;  $  TAB1 create int x, y ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read x and y ;  $  TAB2 set a[x][y] to 1 ;  $  TAB2 set a[y][x] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = i + 1 to n inclusive ;  $  TAB3 for k = j + 1 to n inclusive ;  $  TAB4 if a[i][j] and a[i][k] and a[j][k], set price to min of price and b[i] + b[j] + b[k] ;  $  TAB1 if price equals 9000000 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print price ;
TAB1 let arr be an array of boolean, size 101 set to false ;  $  TAB1 n = integer ;  $  TAB1 r, l, a, b = integers ;  $  TAB1 read n ;  $  TAB1 decrement n ;  $  TAB1 read r, l ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 read a, b ;  $  TAB2 for i=a to b exclusive arr[i] = true ;  $  TAB1 set integer cnt = 0 ;  $  TAB1 for i=r to l exclusive do the following ;  $  TAB2 if arr[i] is false, increment cnt ;  $  TAB1 print cnt ;
TAB0 declare boolean function palindrom taking in integer k ;  $  TAB1 let n = integer with value log10(k) +1 ;  $  TAB1 let dig = array of integers size n and i = integer with value 0 ;  $  TAB1 while (K is greater than 0) is true do the following ;  $  TAB2 set dig [increment i] = k modulo 10 ;  $  TAB2 set k = k / 10 ;  $  TAB1 let ans = boolean with value true ;  $  TAB1 for integer i=0 to n / 2 inclusive set ans = ans & dig[i] is dig[n - i - 1] ;  $  TAB1 return ans ;  $  TAB1 let p, q = integers ;  $  TAB1 read p, q ;  $  TAB1 let prime = array of boolean size 2000000 ;  $  TAB1 set sizeof(prime) bytes starting at prime to 0 ;  $  TAB1 let sqLIM = integer with value sqrt(2000000) ;  $  TAB1 for integer i=2 to sqLIM inclusive dothe following ;  $  TAB2 if not prime[i] go to start of loop ;  $  TAB2 for integer j=i*i to 2000000 exclusive increment step i set prime[j] = false ;  $  TAB1 set prime[1] = false ;  $  TAB1 let pr, pal, ans = integers with value 0 ;  $  TAB1 for integer i=1 to 2000000 do the following ;  $  TAB2 if palindrom[i] is true increment pal ;  $  TAB2 if prime[i] is true increment pr ;  $  TAB2 if p * pal is greater than or equal to q * pr set ans = i ;  $  TAB1 print ans ;  $  TAB1 read p ;
TAB1 let n, b, d, total, count = long long integers with total = 0 and count = 0 ;  $  TAB1 read n, b, d ;  $  TAB1 let oranges_size = array of long long integers with size = n ;  $  TAB1 read n values into array oranges_size ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 if oranges_size[i] is less than or equal to b do the following ;  $  TAB3 set total = total + oranges_size[i] ;  $  TAB3 if total is greater than d do the following ;  $  TAB4 set total = 0 ;  $  TAB4 increment count ;  $  TAB1 print count ;
TAB1 let a be an integer ;  $  TAB1 input a ;  $  TAB1 if a - 10 is at most 0 or a - 10 is greater than 11 ;  $  TAB2 display 0 ;  $  TAB1 else if (a - 10 is at least 1 and a - 10 is at most 9) or a - 10 equals 11 ;  $  TAB2 display 4 ;  $  TAB1 else ;  $  TAB2 display 15 ;
TAB1 make ints m, d, s, t, h ;  $  TAB1 make array of ints a with size of 12, initialized with 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ;  $  TAB1 read m and d ;  $  TAB1 set t to a[m - 1] ;  $  TAB1 set h to 7 - d ;  $  TAB1 if (t - h - 1) mod 7 is equal to 0 ;  $  TAB2 set s to (t - h - 1) / 7 ;  $  TAB1 else ;  $  TAB2 set s to ((t - h - 1) / 7) + 1 ;  $  TAB1 print s + 1 ;
TAB0 in function gcd returning int and taking int a, int b ;  $  TAB1 if b equals 0 ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return gcd(b, a % b) ;  $  TAB0 in function base returning int and taking int n, int a ;  $  TAB1 define int res = 0 ;  $  TAB1 while n is not equal to 0 ;  $  TAB2 set res to res + n % a ;  $  TAB2 set n to n / a ;  $  TAB1 return res ;  $  TAB1 let int n, d, ans = 0, a, b ;  $  TAB1 read n ;  $  TAB1 for i = 2 to n - 1 inclusive: set ans to ans + base(n, i) ;  $  TAB1 set d to n - 2 ;  $  TAB1 set a to ans / gcd(ans, d) ;  $  TAB1 set b to d / gcd(ans, d) ;  $  TAB1 print a "/" b ;
TAB0 s= string ;  $  TAB1 read s ;  $  TAB1 create integer n and cnt with c= size of s and cnt=0 ;  $  TAB1 for i=0 to n/2 exclusive ;  $  TAB2 if s[i] is not equal to s[n-i-1] then increment cnt ;  $  TAB1 if cnt = 1 or cnt && n % 2 is false ;  $  TAB2 print YES ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB1 let v be long long ;  $  TAB1 while input available, read v ;  $  TAB2 if v == 2 ;  $  TAB3 print v ;  $  TAB2 else ;  $  TAB3 print "1" ;
TAB1 let x, t, a, b, c, d be integers ;  $  TAB1 let e be boolean with e = false ;  $  TAB1 let s be integer with s = 0 ;  $  TAB1 read x, t, a, b, c, d ;  $  TAB1 if x == 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 for i = 0 to t exclusive ;  $  TAB3 set s to a - c*i ;  $  TAB3 if s == x ;  $  TAB4 set e to true ;  $  TAB4 break ;  $  TAB3 for k = 0 to t exclusive ;  $  TAB4 set s to (a - c*i) + (b - d*k) ;  $  TAB4 if s == x ;  $  TAB5 set e to true ;  $  TAB5 break ;  $  TAB4 else ;  $  TAB5 set s to b - d*k ;  $  TAB5 if s == x ;  $  TAB6 set e to true ;  $  TAB6 break ;  $  TAB2 if e == false ;  $  TAB3 print NO ;  $  TAB2 else ;  $  TAB3 print YES ;
TAB1 m,n,s = integers ;  $  TAB1 read m and n ;  $  TAB1 set s = n/2 * m ;  $  TAB1 if n%2 is equal to 1 then set s = s + m/2 ;  $  TAB1 print s and a new line ;
TAB1 let N, qx, qy, kx, ky, dx, dy be integers ;  $  TAB1 read N ;  $  TAB1 read qx and qy ;  $  TAB1 read kx and ky ;  $  TAB1 read dx and dy ;  $  TAB1 if qx is greater than kx and qy is greater than ky ;  $  TAB2 if qx is greater than dx and qy is greater than dy ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;  $  TAB1 else if qx is less than kx and qy is greater than ky ;  $  TAB2 if qx is less than dx and qy is greater than dy ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;  $  TAB1 else if qx is less than kx and qy is less than ky ;  $  TAB2 if qx is less than dx and qy is less than dy ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;  $  TAB1 else ;  $  TAB2 if qx is greater than dx and qy is less than dy ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let cnt = integer with value = 1 ;  $  TAB1 let z = boolean with value = true ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 for integer i=1 to (n - cnt) / 2 inclusive print * ;  $  TAB2 for integer i=1 to cnt inclusive print D ;  $  TAB2 for integer i=1 to (n - cnt) / 2 inclusive print * ;  $  TAB2 if cnt is n set z = 0 ;  $  TAB2 if z ;  $  TAB3 set cnt = cnt + 2 ;  $  TAB2 else ;  $  TAB3 set cnt = cnt -2 ;  $  TAB2 print a new line ;
TAB1 create int n, k ;  $  TAB1 create char array s, size 111 ;  $  TAB1 while reading n and k ;  $  TAB2 read s ;  $  TAB2 create int x, y ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if s[i] equals 'G', assign i to x ;  $  TAB3 if s[i] equals 'T', assign i to y ;  $  TAB2 create int a = 1 ;  $  TAB2 create int flag = 0 ;  $  TAB2 if x less than y ;  $  TAB3 while true ;  $  TAB4 if s[x + k * a] equals 'T' ;  $  TAB5 assign 1 to flag ;  $  TAB5 break ;  $  TAB4 if s[x + k * a] equals '#', break ;  $  TAB4 if x + k * a greater than or equal to n, break ;  $  TAB4 increment a ;  $  TAB2 else ;  $  TAB3 while true ;  $  TAB4 if s[x - k * a] equals 'T' ;  $  TAB5 assign 1 to flag ;  $  TAB5 break ;  $  TAB4 if s[x - k * a] is equal to '#', break ;  $  TAB4 if x - k * a is less than 0, break ;  $  TAB4 increment a ;  $  TAB2 if flag equals 1 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 n = long long = integer value of length of s ;  $  TAB1 x = long long = 0 ;  $  TAB1 xx = long long = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is the character o ;  $  TAB3 add 1 to x ;  $  TAB2 else if s[i] is the character - ;  $  TAB3 add 1 to xx ;  $  TAB1 if x is 0 ;  $  TAB2 display YES ;  $  TAB3 display newline ;  $  TAB1 else if xx is divisible by x ;  $  TAB2 display YES ;  $  TAB3 display newline ;  $  TAB1 else ;  $  TAB2 display NO ;  $  TAB3 display newline ;
TAB1 n, k = integers ;  $  TAB1 read n and k ;  $  TAB1 ptr, cnt = integers set to 0, a, b = arrays of integers with a length n and b length k ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to k exclusive, read b[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if ptr >= k ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 if b[ptr] >= a[i] ;  $  TAB4 increment ptr by 1 ;  $  TAB4 increment cnt by 1 ;  $  TAB1 print cnt ;
TAB1 n,m,k,i=integers ;  $  TAB1 a=array of integer of size of 100 ;  $  TAB1 while entered value of n,m,k are valid read n,m,k and do the following ;  $  TAB2 read n value into array of a ;  $  TAB2 sort array a ;  $  TAB2 for i=n to k<m and i>=1 set k = k + a[i-1] -1 ;  $  TAB2 if k<m ;  $  TAB3 print -1 ;  $  TAB2 else do the following ;  $  TAB3 print n-i ;
TAB0 create constant int N = 2e5 + 5 ;  $  TAB0 create string s ;  $  TAB0 create queue<string> q ;  $  TAB0 create map mp of string to int ;  $  TAB0 in function bfs taking string s ;  $  TAB1 mp[s] = true ;  $  TAB1 push s onto q ;  $  TAB1 while q is not empty ;  $  TAB2 create string u = front of q, v1, v2, v3 ;  $  TAB2 pop q ;  $  TAB2 v1 = v2 = v3 = u ;  $  TAB2 v1[0] = u[3], v1[1] = u[0], v1[2] = u[1], v1[3] = u[2] ;  $  TAB2 v2[0] = u[4], v2[5] = u[0], v2[2] = u[5], v2[4] = u[2] ;  $  TAB2 v3[5] = u[1], v3[3] = u[5], v3[4] = u[3], v3[1] = u[4] ;  $  TAB2 if not mp[v1] then mp[v1] = true, push v1 onto q ;  $  TAB2 if not mp[v2] then mp[v2] = true, push v2 onto q ;  $  TAB2 if not mp[v3] then mp[v3] = true, push v3 onto q ;  $  TAB1 read s ;  $  TAB1 create int res = 0 ;  $  TAB1 sort s ;  $  TAB1 do ;  $  TAB2 if mp[s] then continue ;  $  TAB2 add 1 to res ;  $  TAB2 call bfs on s ;  $  TAB1 while next_permutation(s.begin(), s.end()) ;  $  TAB1 print res ;
TAB1 k,r = integers ;  $  TAB1 while entered values of k and r are valid, read k and r and do the following ;  $  TAB2 create integers cnt = 1 and z=0 ;  $  TAB2 set z = k ;  $  TAB2 while true ;  $  TAB3 if z%10 = r or z%10 = 0 ;  $  TAB4 break ;  $  TAB3 else do the following ;  $  TAB4 add 1 to cnt ;  $  TAB4 set z = k * cnt ;  $  TAB2 print cnt and a new line ;
TAB1 let n, c, t, sum be long longs with sum set to 0 ;  $  TAB1 read n ;  $  TAB1 read c ;  $  TAB1 read t ;  $  TAB1 increment sum ;  $  TAB1 set a to t ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 read t ;  $  TAB2 if t - a is at most c ;  $  TAB3 increment sum ;  $  TAB2 else if t - a is greater than c ;  $  TAB3 set sum to 1 ;  $  TAB2 set a to t ;  $  TAB1 display sum ;
TAB1 let p1, p2, m1, m2 be double ;  $  TAB1 read p1, p2, m1, m2 ;  $  TAB1 let ans1 and ans2 be integers ;  $  TAB1 set ans1 to max of ((3.0 * p1) / 10.0) and (p1 - (p1 / 250) * m1) ;  $  TAB1 set ans2 to max of ((3.0 * p2) / 10.0) and (p2 - (p2 * m2) / 250.0) ;  $  TAB1 if ans1 is equal to ans2 ;  $  TAB2 print Tie ;  $  TAB1 else if ans1 > ans2 ;  $  TAB2 print Misha ;  $  TAB1 else ;  $  TAB2 print out Vasya ;
TAB1 create integers n and m ;  $  TAB1 read n and m ;  $  TAB1 create integer now = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create integer x ;  $  TAB2 read x ;  $  TAB2 increase now by x ;  $  TAB1 set now to abs(now) ;  $  TAB1 if now is equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else if now is less than or equal to m ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 if now mod m is equal to 0 ;  $  TAB3 print now / m ;  $  TAB2 else ;  $  TAB3 print 1 + (now / m) ;
TAB0 MX is a constant integer with MX = 5000 + 10 ;  $  TAB0 s is a character array of size MX ;  $  TAB1 input s ;  $  TAB1 n = integer = string length of s ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a and b are both integers both set to 0 ;  $  TAB2 for j = i to n exclusive ;  $  TAB3 if s[j] is the character ( ;  $  TAB4 increment a ;  $  TAB3 else if s[j] is the character ) ;  $  TAB4 decrement a ;  $  TAB3 else ;  $  TAB4 increment b ;  $  TAB3 while b is positive and b is greater than a ;  $  TAB4 decrement b ;  $  TAB4 increment a ;  $  TAB3 if a is negative, break ;  $  TAB3 if (j - i + 1) mod 2 equals 0 and b is at least a, increment ans ;  $  TAB1 display ans ;
TAB1 x is an integer array of size 2000 ;  $  TAB1 n is an integer ;  $  TAB1 read n ;  $  TAB1 i is an integer ;  $  TAB1 for i = 0 to n exclusive, read x[i] ;  $  TAB1 a, b, k are integers ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 set a to x[i] ;  $  TAB2 set b to x[i + 1] ;  $  TAB2 if a is less than b ;  $  TAB3 for k = 0 to i exclusive ;  $  TAB4 if (a is at most x[k] and b is at least x[k]) and (a is at most x[k + 1] and b is at least x[k + 1]) ;  $  TAB4 else ;  $  TAB5 if (a is at least x[k] or b is at most x[k]) and (a is at least x[k + 1] or b is at most x[k + 1]) ;  $  TAB5 else ;  $  TAB6 display yes ;  $  TAB2 else ;  $  TAB3 for k = 0 to i exclusive ;  $  TAB4 if (a is at least x[k] and b is at most x[k]) and (a is at least x[k + 1] and b is at most x[k + 1]) ;  $  TAB4 else ;  $  TAB5 if (a is at most x[k] or b is at least x[k]) and (a is at most x[k + 1] or b is at least x[k + 1]) ;  $  TAB5 else ;  $  TAB6 display yes ;  $  TAB1 display no ;
TAB1 n, p, q, sum are integers with sum = 0 ;  $  TAB1 read n ;  $  TAB1 iterate n times ;  $  TAB2 read p, q ;  $  TAB2 if p is at most q ;  $  TAB3 if q - p is at least 2, increment sum ;  $  TAB1 display sum ;
TAB1 t, s, sum, r are integers with r = 0 ;  $  TAB1 read t ;  $  TAB1 a and b are characters both of size t ;  $  TAB1 read t values into array a ;  $  TAB1 read t values into array b ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 set s to absolute value of a[i] - b[i] ;  $  TAB2 if a[i] is greater than b[i] ;  $  TAB3 set sum to (b[i] + 10) - a[i] ;  $  TAB2 else ;  $  TAB3 set sum to (a[i] + 10) - b[i] ;  $  TAB2 if s is at most sum ;  $  TAB3 add r + s to r ;  $  TAB2 else ;  $  TAB3 add r + sum to r ;  $  TAB1 output r ;
TAB0 P = constant integer = 1000003 ;  $  TAB0 in function superpow with parameters long longs a, b and return long long ;  $  TAB1 ans = long long = 1 ;  $  TAB1 while b ;  $  TAB2 if b bitwise and 1, set ans to (ans * a) mod P ;  $  TAB2 set b to b shifted right 1 bit ;  $  TAB2 set a to (a * a) mod P ;  $  TAB1 return ans ;  $  TAB0 n = integer ;  $  TAB1 read n ;  $  TAB1 print call superpow with 3, n - 1 if n isn't 0, otherwise print 1 ;
TAB0 in function character with parameters integers i, j and return character ;  $  TAB1 if i is even ;  $  TAB2 if j is even ;  $  TAB3 return the character B ;  $  TAB2 else ;  $  TAB3 return the character W ;  $  TAB1 else ;  $  TAB2 if j is even ;  $  TAB3 return the character W ;  $  TAB2 else ;  $  TAB3 return the character B ;  $  TAB1 let n, m be integers ;  $  TAB1 input n, m ;  $  TAB1 let i, j, k be integers ;  $  TAB1 let s be a string array of size n ;  $  TAB1 read n values into array s ;  $  TAB1 declare a character z ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 assign call character with i, j to z ;  $  TAB3 if s[i][j] is the character ., assign z to s[i][j] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 print s[i] ;  $  TAB2 print newline ;
TAB0 n = integer ;  $  TAB1 read n ;  $  TAB1 print n / 2 + 1 ;
TAB0 let a be a 2 dimensional character array and set each dimension to 55 ;  $  TAB0 let b = integer array of length 26 ;  $  TAB1 let x,y,i,s,j = integers and s = 0 ;  $  TAB1 read x and y ;  $  TAB1 for i = 0 to x exclusive read a[i] ;  $  TAB1 for i = 0 to x-1 exclusive do the following ;  $  TAB2 forj = 0 to y-1 exclusive do the following ;  $  TAB3 set sizeof(b) bytes starting at b to 0 ;  $  TAB3 increment b[a[i][j]-'a'] ;  $  TAB3 increment b[a[i+1][j]-'a'] ;  $  TAB3 increment b[a[i][j+1]-'a'] ;  $  TAB3 increment b[a[i+1][j+1]-'a'] ;  $  TAB3 if b['f'-'a'] is 1 and b[0] is 1 and b['c'-'a'] is 1 and b['e'-'a'] is 1 then increment s ;  $  TAB1 print s ;
TAB1 let t and a be integers ;  $  TAB1 input t ;  $  TAB1 while decrement t ;  $  TAB2 input a ;  $  TAB2 if 360 mod (180 - a) equals 0 ;  $  TAB3 output YES ;  $  TAB2 else ;  $  TAB3 output NO ;
TAB0 C = constant integer = 1005 ;  $  TAB0 n, a are integers ;  $  TAB0 s = string array of size C ;  $  TAB0 v = integer vector ;  $  TAB1 read n ;  $  TAB1 read n values into array s ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 assign 0 to a ;  $  TAB2 for j = 1 to size of s[i] inclusive ;  $  TAB3 pom = integer = s[i][j] - the character a ;  $  TAB3 if a bitwise and (1 shifted left by pom bytes) equals 0, add 1 shifted left by pom bytes to a ;  $  TAB2 blep = boolean = false ;  $  TAB2 for j = 0 to size of v exclusive ;  $  TAB3 if v[j] equals a, set blep to true ;  $  TAB2 if blep is false, append a to v ;  $  TAB1 output size of v ;
TAB1 let n be a string ;  $  TAB1 input n ;  $  TAB1 s is an integer array with s = length of n ;  $  TAB1 p = integer = (s + 1) * 26 - s ;  $  TAB1 output p ;
TAB1 create integers n and num ;  $  TAB1 create boolean res = true ;  $  TAB1 read num ;  $  TAB1 create pair<int, int> match ;  $  TAB1 set match.first to 1 ;  $  TAB1 set match.second to 2 ;  $  TAB1 for i = 0 to num exclusive ;  $  TAB2 read n ;  $  TAB2 if n is not match.first and n is not match.second then set res to false ;  $  TAB2 if match.first is 1 and match.second is 2 ;  $  TAB3 if n is match.first ;  $  TAB4 set match.second to 3 ;  $  TAB3 else if n is match.second ;  $  TAB4 set match.first to 3 ;  $  TAB2 else if match.first is 1 and match.second is 3 ;  $  TAB3 if n is match.first ;  $  TAB4 set match.second to 2 ;  $  TAB3 else if n is match.second ;  $  TAB4 set match.first to 2 ;  $  TAB2 else if match.first is 2 and match.second is 1 ;  $  TAB3 if n is match.first ;  $  TAB4 set match.second to 3 ;  $  TAB3 else if n is match.second ;  $  TAB4 set match.first to 3 ;  $  TAB2 else if match.first is 2 and match.second is 3 ;  $  TAB3 if n is match.first ;  $  TAB4 set match.second to 1 ;  $  TAB3 else if n is match.second ;  $  TAB4 set match.first to 1 ;  $  TAB2 else if match.first is 3 and match.second is 1 ;  $  TAB3 if n is match.first ;  $  TAB4 set match.second to 2 ;  $  TAB3 else if n is match.second ;  $  TAB4 set match.first to 2 ;  $  TAB2 else if match.first is 3 and match.second is 2 ;  $  TAB3 if n is match.first ;  $  TAB4 set match.second to 1 ;  $  TAB3 else if n is match.second ;  $  TAB4 set match.first to 1 ;  $  TAB1 if res ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 in function gcd with parameters integers a, b and return integer ;  $  TAB1 if a is equal to 0 ;  $  TAB2 return b ;  $  TAB1 else ;  $  TAB2 return call gcd with arguments b mod a, a ;  $  TAB1 let a, b, st be integers ;  $  TAB1 while read a, b, and st ;  $  TAB2 x = integer = 0, st_taken = integer ;  $  TAB2 while st is not equal to 0 ;  $  TAB3 assign call gcd with arguments a, st to st_taken ;  $  TAB3 assign st - st_taken to st ;  $  TAB3 increment x ;  $  TAB3 swap a and b ;  $  TAB2 if x mod 2 is equal to 1 ;  $  TAB3 display 0 ;  $  TAB2 else ;  $  TAB3 display 1 ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 define int c = 1, k = 0 ;  $  TAB1 define int i = 0 ;  $  TAB1 define int n = size of s, flag = 0 ;  $  TAB1 while i less than n ;  $  TAB2 if s[i] equals s[i + 1]: increment c ;  $  TAB2 if s[i] is not equal to s[i + 1] ;  $  TAB3 if c is even: increment k ;  $  TAB3 set c to 1 ;  $  TAB2 increment i ;  $  TAB1 print k ;
TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 for integer i=1 to size of s inclusive ;  $  TAB2 if s[i-1] is r print i ;  $  TAB1 for integer i=size of s to 1 inclusive decrementing ;  $  TAB2 if s[i-1] is 1 print i ;
TAB0 create integers n, c, minx = 1000, maxn = 0, ans ;  $  TAB1 read n and c ;  $  TAB1 maxn = minx = c ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 read c ;  $  TAB2 if c > maxn, add 1 to ans, maxn = c ;  $  TAB2 if c < minx, add 1 to ans, minx = c ;  $  TAB1 print ans ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 spect = integer set to 3 ;  $  TAB1 win = integer set to 0 ;  $  TAB1 b = boolean set to 1 ;  $  TAB1 while decrement n ;  $  TAB2 input win ;  $  TAB2 if win is equal to specet ;  $  TAB3 assign false to b ;  $  TAB3 print NO ;  $  TAB3 break ;  $  TAB2 if spect + win equals 4 ;  $  TAB3 assign 2 to spect ;  $  TAB2 else if spect + win equals 3 ;  $  TAB3 assign 3 to spect ;  $  TAB2 else ;  $  TAB3 assign 1 to spect ;  $  TAB1 if b, print YES ;
TAB0 let a be array of integers of size 102000 ;  $  TAB0 let b be an array of integers of size 102000 ;  $  TAB0 let dp be 2D array of integers of size 100 by 100 ;  $  TAB0 let mymap be a map of int to int ;  $  TAB0 let a be string ;  $  TAB0 let ans be integer with ans = 0x3f3f3f3f ;  $  TAB0 let n be integer ;  $  TAB0 let k be integer ;  $  TAB0 let vis be array of integers with size 100 ;  $  TAB0 define dfs which takes integer start, num, sum and char last as arguments ;  $  TAB1 if num is greater than k return ;  $  TAB1 if num is equal to k ;  $  TAB2 set ans to min of ans and sum ;  $  TAB2 return ;  $  TAB1 for i = start to n inclusive ;  $  TAB2 if not vis[i] and (s[i] - last) >= 2 ;  $  TAB3 set vis[i] to 1 ;  $  TAB3 call dfs with i+1, num+1, sum + s[i] - 'a' + 1, s[i] parameters ;  $  TAB3 set v[i] to 0 ;  $  TAB1 read n an dk ;  $  TAB1 read s ;  $  TAB1 sort s ;  $  TAB1 prepend # to s ;  $  TAB1 call dfs with 1, 0, 0, 0 ;  $  TAB1 if ans is equal to 0x3f3f3f3f ;  $  TAB2 print out -1 ;  $  TAB1 else ;  $  TAB2 print out ans ;
TAB1 k, a, b, v, ans, mn are long longs with ans = 0 ;  $  TAB1 read k, a, b, v ;  $  TAB1 while true ;  $  TAB2 increment ans ;  $  TAB2 assign call min with k, b + 1 to mn ;  $  TAB2 subtract mn - 1 from b ;  $  TAB2 subtract mn * v from a ;  $  TAB2 if a is at most 0, break ;  $  TAB1 print ans ;
TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 ans is an integer with ans = -1000000000 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 a is an integer ;  $  TAB2 read a ;  $  TAB2 if a is negative ;  $  TAB3 set ans to call max with arguments ans, a ;  $  TAB3 continue ;  $  TAB2 g is a double with g = square root of a ;  $  TAB2 c is an integer with c = integer g * integer g ;  $  TAB2 if c is not a, set ans to call max with arguments ans, a ;  $  TAB1 display ans ;
TAB0 let s = string value zzzzzzzzzzz ;  $  TAB1 let a, b = strings ;  $  TAB1 read a, b ;  $  TAB1 for i=0 to size of a exclusive ;  $  TAB2 for j=0 to size of b exclusive set s = min of s and a.substr(0, i + 1) + b.substr(0, j + 1) ;  $  TAB1 print s ;
TAB1 let n be long long integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let s, a, b, c be long long int ;  $  TAB2 read s, a, b, c ;  $  TAB2 let m be integer with m = s / c ;  $  TAB2 let k be integer with k = m divided by a ;  $  TAB2 print out m + (k * b) with newline ;
TAB1 let Q, l, r, d, x be integers ;  $  TAB1 input Q ;  $  TAB1 while decrement Q ;  $  TAB2 input l, r, and d ;  $  TAB2 if l / d is greater than or equal to 2 or (l / d equals 1 and l mod d is not 0) ;  $  TAB3 assign d to x ;  $  TAB2 else ;  $  TAB3 assign d * call floor with argument (r / d) + d to x ;  $  TAB2 display x ;
TAB1 A is an integer array with A = 4, 7, 47, 74, 447, 474, 477, 744, 747, 774, 777 ;  $  TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 d is an integer with d = 0 ;  $  TAB1 for i = 0 to 11 exclusive ;  $  TAB2 if n mod A[i] equals 0 ;  $  TAB3 increment d ;  $  TAB3 break ;  $  TAB1 if d equals 0 ;  $  TAB2 display NO ;  $  TAB1 else ;  $  TAB2 display YES ;
TAB1 n, p are integers ;  $  TAB1 read n, p ;  $  TAB1 let a be a string ;  $  TAB1 let b be an integer set to 97 ;  $  TAB1 for i = 0 to n exclusive, add 97 + i modulo p to a ;  $  TAB1 display a ;
TAB1 n,k = integers ;  $  TAB1 read n and k ;  $  TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 a= integer array of size 55 ;  $  TAB1 for i=0 to n set a[i] = s[i] - 'a' +1 ;  $  TAB1 sort array a ;  $  TAB1 create integer sum = a[0] ;  $  TAB1 create integer t and assign a[0] to it ;  $  TAB1 create integer count=1 ;  $  TAB1 for i=1 to n and count<k ;  $  TAB2 if a[i] <= t + 1 ;  $  TAB3 then continue ;  $  TAB2 else do the following ;  $  TAB3 set sum = sum + a[i] ;  $  TAB3 increment count ;  $  TAB3 assign a[i] to t ;  $  TAB1 if count is not equal to k ;  $  TAB2 then print -1 and new line ;  $  TAB1 else do the following ;  $  TAB2 print sum ;
TAB1 x1,x2,x3 = integers ;  $  TAB1 read x1,x2,x3 ;  $  TAB1 print maximum of x1,x2,x3 - minimum of x1,x2,x3 and new line ;
TAB0 create map m, int to int ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int ans = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create int t ;  $  TAB2 read t ;  $  TAB2 add 1 to m[t] ;  $  TAB2 set ans to max of ans and m[t] ;  $  TAB1 print ans ;
TAB0 define convert which takes in long long val as argument ;  $  TAB1 let res be integer with res = 0 ;  $  TAB1 set integer i to 0 and increment it by 1 till val is greater than 0 ;  $  TAB2 if (val % 10) & 1, set ret t= ret | (1 << i) ;  $  TAB2 update val to val divided by 10 ;  $  TAB1 return ret ;  $  TAB1 let type be char ;  $  TAB1 let t be integer ;  $  TAB1 let val be long long ;  $  TAB1 let mp be map of integer to integer ;  $  TAB1 read t ;  $  TAB1 while t is greater than 0, decrement t by 1 ;  $  TAB2 read type and val ;  $  TAB2 if type is equal to + ;  $  TAB3 increment entry at convert of val in mp by 1 ;  $  TAB2 else if type is equal to - ;  $  TAB3 decrement entry at convert of val in mp by 1 ;  $  TAB2 else ;  $  TAB3 print out entry at convert of val in mp with newline ;
TAB0 let ans be long long with ans = 1 ;  $  TAB0 let a, b be integers ;  $  TAB1 read a and b ;  $  TAB1 for i = 2 to min of a, b inclusive, set ans to ans * i ;  $  TAB1 print out ans with newline ;
TAB0 create an integer array value of size 101 = {0} ;  $  TAB1 create integers n,sum_positive,sum_negative with sum_positive = sum_negative = 0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read value[i] ;  $  TAB2 if value[i] > 0 ;  $  TAB3 set sum_positive = sum_positive + value[i] ;  $  TAB2 else do the following ;  $  TAB3 set sum_negative = sum_negative + value[i] ;  $  TAB1 print difference of sum_positive and sum_negative and a newline ;
TAB0 n, i, ans are integers ;  $  TAB0 a = boolean array of size 105 ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] equals 1 or (a[i - 1] equals 1 and a[i] equals 0 and a[i + 1] equals 1), increment ans ;  $  TAB1 print ans ;
TAB1 let x be a string ;  $  TAB1 input x ;  $  TAB1 let l be an integer with l = 0 ;  $  TAB1 let p be an integer with p = 0 ;  $  TAB1 for i = 0 to size of x exclusive ;  $  TAB2 if x[i] is the character o ;  $  TAB3 increment p ;  $  TAB2 else ;  $  TAB3 increment l ;  $  TAB1 if p is equal to 0 ;  $  TAB2 print YES ;  $  TAB1 if l is divisible by p ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 maps = integer vector array of size 100000 ;  $  TAB0 a = integer array of size 100000 with a = 0 ;  $  TAB0 inf is a cinstant integer set to 1e9 ;  $  TAB1 n, m, i, ans are integers with ans = inf ;  $  TAB1 read n, m ;  $  TAB1 read n values into array a ;  $  TAB1 for e = 0 to m exclusive ;  $  TAB2 x, y, z are integers ;  $  TAB2 read x, y ;  $  TAB2 for i = 0 to size of maps[y] exclusive ;  $  TAB3 set z to maps[y][i] ;  $  TAB3 for j = 0 to size of maps[z] ;  $  TAB4 if maps[z][j] is x, set ans to call min with ans, a[x] + a[y] + a[z] ;  $  TAB2 append y to maps[x] ;  $  TAB2 append x to maps[y] ;  $  TAB1 if ans equals inf ;  $  TAB2 display -1 ;  $  TAB1 else ;  $  TAB2 display ans ;
TAB0 in function reverse with parameter integer x and return long long ;  $  TAB1 ans = long long = 0 ;  $  TAB1 while x ;  $  TAB2 multiply ans by 10 ;  $  TAB2 add x mod 10 to ans ;  $  TAB2 divide x by 10 ;  $  TAB1 return ans ;  $  TAB1 a, b are integers ;  $  TAB1 read a, b ;  $  TAB1 print a + call reverse with b ;
TAB1 make int n, vol = 0, res = 0 ;  $  TAB1 make string s, s1 ;  $  TAB1 read n, s ;  $  TAB1 while size of s is less than n ;  $  TAB2 read s1 ;  $  TAB2 assign s + ' ' + s1 to s ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 if i equals n or s[i] equals ' ' ;  $  TAB3 if vol is greater than res then assign vol to res ;  $  TAB3 assign 0 to vol ;  $  TAB2 else if s[i] is greater than or equal to 'A' and s[i] is less than or equal to 'Z' ;  $  TAB3 add 1 to vol ;  $  TAB1 print res ;
TAB1 create long long n = 0 ;  $  TAB1 read n ;  $  TAB1 create long long x = n, y = 0, count = 0 ;  $  TAB1 if n is less than 40000001 ;  $  TAB2 if n equals 0 ;  $  TAB3 print 1 ;  $  TAB2 else ;  $  TAB3 while x greater than 0 ;  $  TAB4 increment count ;  $  TAB4 increment y ;  $  TAB4 if x^2 + y^2 is greater than n^2 then decrement x ;  $  TAB4 if x^2 + y^2 is greater than n^2 then decrement y ;  $  TAB3 print count * 4 ;
TAB0 maxn is a constant integer set to 105 ;  $  TAB0 n = integer ;  $  TAB0 sum = integer = 0 ;  $  TAB0 a = integer ;  $  TAB0 b = integer ;  $  TAB0 c = integer ;  $  TAB0 d = integer ;  $  TAB0 cnt is an integer array of sizes maxn and maxn ;  $  TAB1 input n ;  $  TAB1 call memset with cnt, 0, call sizeof with cnt ;  $  TAB1 while decrement n ;  $  TAB2 read a, b, c, d ;  $  TAB2 for i = a to c inclusive ;  $  TAB3 for j = b to d inclusive, increment cnt[i][j] ;  $  TAB1 iterate 100 times ;  $  TAB2 for j = 1 to 100, add cnt[i][j] to sum ;  $  TAB1 display sum ;
TAB1 a = char array of size 30 ;  $  TAB1 read a ;  $  TAB1 len = integer = strlen of a ;  $  TAB1 print 26 * (len + 1) = len ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let ch, bi, bk = integers with values 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let x = integer ;  $  TAB2 read x ;  $  TAB2 if i modulo 3 is 0 set ch = ch + x ;  $  TAB2 if i modulo 3 is 1 set bi = bi + x ;  $  TAB2 if i modulo 3 is 2 set bk = bk + x ;  $  TAB1 if ch is greater than bi and ch is greater than bk ;  $  TAB2 print chest ;  $  TAB1 else if bi is greater than bk ;  $  TAB2 print biceps ;  $  TAB1 else ;  $  TAB2 print back ;
TAB0 let n, m, ans, k be integers with ans = 0 ;  $  TAB1 read m ;  $  TAB1 let q be vector of integers of size m ;  $  TAB1 for i = 0 to m exclusive, read q[i] ;  $  TAB1 sort q ;  $  TAB1 set k to first element of q ;  $  TAB1 read n ;  $  TAB1 let a and be vector of integers of size n ;  $  TAB1 for i = 0 to n, read a[i] ;  $  TAB1 sort a ;  $  TAB1 set s[0] to a[0] ;  $  TAB1 for i = 1 to n exclusive, set s[i] to s[i-1] + a[i] ;  $  TAB1 let kk be integer with kk = k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 update ans to ans + a[i] ;  $  TAB2 decrement kk ;  $  TAB2 if kk is equal to 0 ;  $  TAB3 set kk to k ;  $  TAB3 increment i by 2 ;  $  TAB1 print ans ;
TAB1 n, m, j, rs are integers with j and rs both set to 0 ;  $  TAB1 input n, m ;  $  TAB1 c = integer array of size n, money = integer array of size m ;  $  TAB1 read n values into array c ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 input money[i] ;  $  TAB2 iterate as long as j is less than n ;  $  TAB3 if money[i] is less than c[j] ;  $  TAB4 increment j ;  $  TAB3 else ;  $  TAB4 increment rs ;  $  TAB4 increment j ;  $  TAB4 break ;  $  TAB1 output rs ;
TAB0 make integers n and s ;  $  TAB0 make integer arrays a, b, and f all with a size of 1003 ;  $  TAB0 in function solve, return type string ;  $  TAB1 if a[1] is equal to 0 then return "NO" ;  $  TAB1 make integer last = 0 ;  $  TAB1 for i = 1 cast to int to n cast to int inclusive ;  $  TAB2 if a[i] and b[i] then set last to i ;  $  TAB1 if a[s] ;  $  TAB2 return "YES" ;  $  TAB1 else if last and last is greater than or equal to s and b[s] ;  $  TAB2 return "YES" ;  $  TAB1 else ;  $  TAB2 return "NO" ;  $  TAB1 read n and s ;  $  TAB1 for i = 1 cast to int to n cast to int inclusive do read a[i] ;  $  TAB1 for i = 1 cast to int to n cast to int inclusive do read b[i] ;  $  TAB1 print solve() ;
TAB0 in function isprime return type boolean, taking int j ;  $  TAB1 for i = 2 to j exclusive ;  $  TAB2 if not(j mod i) then return 0 ;  $  TAB1 return 1 ;  $  TAB1 make int i = 1, n ;  $  TAB1 read n ;  $  TAB1 while 1 ;  $  TAB2 if not isprime(n * i + 1) ;  $  TAB3 print i ;  $  TAB2 increment i ;
TAB0 x=array of integer of size 10005 ;  $  TAB1 n,m,z,ans=integer ;  $  TAB1 while n,m,z are valid read their values and do the following ;  $  TAB2 set all values of x to 0 ;  $  TAB2 set ans=0 ;  $  TAB2 for i=n ,i=i+n to z inclusive and set x[i]=1 ;  $  TAB2 for i=m to z inclusive ;  $  TAB3 if x[i]=1 then increment ans ;  $  TAB2 print ans ;
TAB1 i, n = integers ;  $  TAB1 xx = array of integers with a length of 101 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read xx[i] ;  $  TAB1 sort xx and xx + n ;  $  TAB1 swap xx[0] and xx[n -1] ;  $  TAB1 print xx[0] ;  $  TAB1 for i = 1 to n exclusive, print " ", xx[i] ;  $  TAB1 endline ;
TAB0 let MOD be a constant integer with MOD = 1e9 + 7 ;  $  TAB1 declare an integer N ;  $  TAB1 input N ;  $  TAB1 state is an integer array of size 2 with state = 0, 0 ;  $  TAB1 for i = 0 to N exclusive, set state[i modulo 2] to (state[i modulo 2] + state[(i + 1] modulo 2] + 1) modulo MOD ;  $  TAB1 display (state[0] + state[1]) modulo MOD ;
TAB0 a is a long long array of size 100000 ;  $  TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB1 call sort with a, a + n * 2 ;  $  TAB1 display NO if a[n - 1] equals a[n], otherwise display YES ;
TAB0 let n, a, b, c be unsigned long long ;  $  TAB1 read n, a, b, c ;  $  TAB1 if a <= b - c ;  $  TAB2 print out n/a with newline ;  $  TAB1 else ;  $  TAB2 let ans be unsigned long long with ans = 0 ;  $  TAB2 if n > c, set ans to (n-c) / (b-c) ;  $  TAB2 increment ans by (n - ans * (b-c)) / a ;  $  TAB2 print ans ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 while n ;  $  TAB2 d = integer ;  $  TAB2 read d ;  $  TAB2 if 360 mod (180 - d) equals 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB2 decrement n ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let l be an integer array of length n ;  $  TAB1 let a1, b1, b2, and ans all be integers set to 0, let a2 be an integer set to 101, let x be an integer ;  $  TAB1 iterate n times ;  $  TAB2 x is an integer ;  $  TAB2 read x ;  $  TAB2 assign x to l[i] ;  $  TAB2 if a2 is at least x ;  $  TAB3 assign x to a2 ;  $  TAB3 assign i to b2 ;  $  TAB2 if a1 is less than x ;  $  TAB3 assign x to a1 ;  $  TAB3 assign i to b1 ;  $  TAB1 if b1 is less than b2 ;  $  TAB2 set ans to b1 + n - 1 - b2 ;  $  TAB2 display ans ;  $  TAB1 else if b1 is greater than b2 ;  $  TAB2 set ans to b1 + n - 2 - b2 ;  $  TAB2 display ans ;
TAB1 n is an integer ;  $  TAB1 read n ;  $  TAB1 counter is an integer array of size n + 1 ;  $  TAB1 for i = 0 to n inclusive, set counter[i] to 0 ;  $  TAB1 xs is an integer array of size 2 * n ;  $  TAB1 count is an integer with count = 0 ;  $  TAB1 maxcount is an integer with maxcount = 0 ;  $  TAB1 for i = 0 to 2 * n exclusive ;  $  TAB2 read xs[i] ;  $  TAB2 if counter[xs[i]] + 1 equals 0 ;  $  TAB3 increment count ;  $  TAB2 else ;  $  TAB3 decrement count ;  $  TAB2 set maxcount to call max with arguments count, maxcount ;  $  TAB1 display maxcount ;
TAB0 n = long long integer ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print n/2 ;  $  TAB1 else ;  $  TAB2 print n/2 - n ;
TAB0 in the function gcd which takes two integer a and b and returns an integer ;  $  TAB1 if b=0 ;  $  TAB2 return a ;  $  TAB1 else do the folloing ;  $  TAB2 return gcd of b and mod of a,b ;  $  TAB1 s,s1,s2=string ;  $  TAB1 read s1,s2 ;  $  TAB1 print s1 and s2 ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 while n is true and decrement n ;  $  TAB2 read s ;  $  TAB2 if s=s1 ;  $  TAB3 read s1 ;  $  TAB2 else do the following ;  $  TAB3 read s2 ;  $  TAB2 print s1 and s2 ;
TAB1 declare int x and define int cup = 0, medal = 0 ;  $  TAB1 define int i = 3 ;  $  TAB1 while i decremented is not 0 ;  $  TAB2 read x ;  $  TAB2 increase cup by x ;  $  TAB1 set i to 3 ;  $  TAB1 while i decremented is not 0 ;  $  TAB2 read x ;  $  TAB2 increase medal by x ;  $  TAB1 declare int total ;  $  TAB1 read total ;  $  TAB1 declare int cupboard, medalboard ;  $  TAB1 if cup modulo 5 equals 0 ;  $  TAB2 set cupboard to cup / 5 ;  $  TAB1 else ;  $  TAB2 set cupboard to cup / 5 + 1 ;  $  TAB1 if medal modulo 10 equals 0 ;  $  TAB2 set medalboard to medal / 10 ;  $  TAB1 else ;  $  TAB2 set medalboard to medal / 10 + 1 ;  $  TAB1 if cupboard + medalboard less than or equal to total ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 arr= array of integer of size n ;  $  TAB1 create integer count=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] is equal to 1 then increment count ;  $  TAB1 print count and new line ;  $  TAB1 for i =0 to n exclusive ;  $  TAB2 if arr[i] = 1 ;  $  TAB3 if i>0 then print arr[i-1] ;  $  TAB1 print arr[n-1] and new line ;
TAB1 declare string ch ;  $  TAB1 read ch ;  $  TAB1 if ch[0] >= 'a' and ch[0] <= 'z' then set ch[0] to ch[0] - 32 ;  $  TAB1 print ch ;
TAB1 let n, x, c be integers with c = 0 ;  $  TAB1 input n, x ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if x is divisible by i and x / i is at most n, increment c ;  $  TAB1 print c ;
TAB0 let maxn = integer constant with value = 5001 ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 print n modulo 2 ;
TAB0 let a be an array of integers size 1005 ;  $  TAB1 n, i = integers ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 call sort on a and a + n ;  $  TAB1 if n is even ;  $  TAB2 print a[n/2] ;  $  TAB1 else ;  $  TAB2 print a[n/2-1] ;
TAB0 let arr be integer array of size 50 by 50 and n be an integer ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive read arr[i][j] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive ;  $  TAB3 b= boolean with value false ;  $  TAB3 if arr[i][j] is 1 then continue ;  $  TAB3 for x=0 to n exclusive ;  $  TAB4 for y= 0 to n exclusive ;  $  TAB5 if arr[i][j] = arr[i][x] + arr[y][j] then set b= true ;  $  TAB3 if b is not true ;  $  TAB4 print No and new line ;  $  TAB1 print Yes and a new line ;
TAB1 t = integer ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 n, rem are integers ;  $  TAB2 input n ;  $  TAB2 assign 180 - n to n ;  $  TAB2 if n equals 0 ;  $  TAB3 display NO ;  $  TAB2 else ;  $  TAB3 assign 360 mod n to rem ;  $  TAB3 if rem equals 0 ;  $  TAB4 display YES ;  $  TAB3 else ;  $  TAB4 display NO ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 arr =array of integer of size n ;  $  TAB1 read i values into the array arr ;  $  TAB1 create a long long integer c=0 ,a=0 and p=arr[0] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if arr[i] = p ;  $  TAB3 increment c ;  $  TAB2 else do the following ;  $  TAB3 set p=arr[i] ;  $  TAB3 set a= a + (c * (c + 1)) / 2 - c ;  $  TAB3 set c=1 ;  $  TAB2 if i = n - 1 then set a= a + (c * (c + 1)) / 2 - c ;  $  TAB1 print a+n ;
TAB0 let INF = integer constant with value = hexadecimal 3f3f3f3f ;  $  TAB0 let a = 105 arrays of long longs size 105 ;  $  TAB1 let i, j, k, l, co = long longs with k = 1 and co = 0 ;  $  TAB1 let n, m, t, d, x1, y1, x2, y2, w = long longs ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read x1, y1, x2, y2 ;  $  TAB2 for l = y1 to y2 inclusive ;  $  TAB3 for j = x1 to x2 inclusive increment a[l][j] ;  $  TAB1 for i=1 to 100 inclusive ;  $  TAB2 for j=1 to 100 inclusive set co = co + a[i][j] ;  $  TAB1 print co ;
TAB1 inicio, fin, num, aux, max are long longs ;  $  TAB1 input inicio, fin ;  $  TAB1 assign 1 to aux ;  $  TAB1 while aux is less than or equal to inicio, set aux to aux * 10 ;  $  TAB1 set max to inicio * (aux - inicio - 1) ;  $  TAB1 set aux to 1 ;  $  TAB1 while aux is less than or equal to fin, set aux to aux * 10 ;  $  TAB1 if max is less than fin * (aux - fin - 1), set max to fin * (aux - fin - 1) ;  $  TAB1 assign 4 to n ;  $  TAB1 assign 9 to aux ;  $  TAB1 while num is less than or equal to fin ;  $  TAB2 if inicio is less than or equal to num and max is less than num * (aux - num), set max to num * (aux - num) ;  $  TAB2 set num to num * 10 + 9 ;  $  TAB2 set aux to aux * 10 + 9 ;  $  TAB1 output max ;
TAB0 N = constant integer set to 333333 ;  $  TAB0 len, res, t, e = long long integers. a and s = arrays of long long integers, a with a length of 5 and s with a length of N ;  $  TAB1 for i = 0 to 3 exclusive, read a[i] ;  $  TAB1 read len ;  $  TAB1 set s[o] to 1 ;  $  TAB1 for i = 1 to len inclusive, set s[i] to s[i -1] + i + 1 ;  $  TAB1 set res = 0 ;  $  TAB1 for i = 0 to len inclusive, set res to res + s[i] ;  $  TAB1 set t = 0 ;  $  TAB1 for i = 0 to 3 exclusive, and j and k are truthy, ;  $  TAB2 set j to i + 1 modulo 3 ;  $  TAB2 set k i + 2 modulo 3 ;  $  TAB2 for x = 0 to len inclusive ;  $  TAB3 set e to minimum of lex - x and a[i] + x - a[j] - a[k] ;  $  TAB3 if e < 0, continue ;  $  TAB3 set t to t + s[e] ;  $  TAB1 set res to res - t ;  $  TAB1 print res ;
TAB1 create integer n,m and i=1 ;  $  TAB1 read n and m ;  $  TAB1 repeat the following ;  $  TAB2 set m= m-i ;  $  TAB2 increment i ;  $  TAB2 if i>n then set i=1 ;  $  TAB1 while m>= i go back to do statement ;  $  TAB1 print m and new line ;
TAB1 a, b, c are integers with c set to 0 ;  $  TAB1 read a, b ;  $  TAB1 while b ;  $  TAB2 d is an integer set to b modulo 10 ;  $  TAB2 set c to c * 10 + d ;  $  TAB2 divide b by 10 ;  $  TAB1 display a + c ;
TAB1 fri, sec are integers ;  $  TAB1 s, v1, v2, t1, t2 are integers ;  $  TAB1 while read s, v1, v2, t1, t2 ;  $  TAB2 set fri to s * v1 + 2 * t1 ;  $  TAB2 set sec to s * v2 + 2 * t2 ;  $  TAB2 if fri is less than sec ;  $  TAB3 display First ;  $  TAB2 else if fri is greater than sec ;  $  TAB3 display Second ;  $  TAB2 else ;  $  TAB3 display Friendship ;
TAB0 declare judge which returns an integer, and takes in integer i ;  $  TAB1 ans = integer set to 0 ;  $  TAB1 while i is not 0 ;  $  TAB2 increment ans by i modulo 10 ;  $  TAB2 divide i by 10 ;  $  TAB1 return ans ;  $  TAB0 set num to array of integers with a length of 100000 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 cont = integer set to 0 ;  $  TAB1 for i = max of 1 and n - 100 to n inclusive ;  $  TAB2 ans = integer set to 0 ;  $  TAB2 set ans to i + judge of i ;  $  TAB2 if ans is n, set num[cont++] to i ;  $  TAB1 if cont is 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print cont ;  $  TAB2 for i = 0 to cont exclusive, print num[i] ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = array of integers of size n ;  $  TAB1 readn values into array a ;  $  TAB1 call sort on a and a + n ;  $  TAB1 if n is even ;  $  TAB2 print a[n/2-1] ;  $  TAB1 else ;  $  TAB2 print a[n/2] ;
TAB1 create integer t ;  $  TAB1 read t ;  $  TAB1 for j = 0 to t exclusive ;  $  TAB2 create integer h = 0 ;  $  TAB2 create integer n ;  $  TAB2 read n ;  $  TAB2 create string c = "abcdefghijklmnopqrstuvwxyz" ;  $  TAB2 create string s ;  $  TAB2 read s ;  $  TAB2 for i = 0 to s length / 2 exclusive ;  $  TAB3 create integer g = 0 ;  $  TAB3 create integers i1 and i2 ;  $  TAB3 for k = 0 to 26 exclusive ;  $  TAB4 if s[i] equals c[k] ;  $  TAB5 set i1 to k ;  $  TAB5 break ;  $  TAB3 for k = 0 to 26 exclusive ;  $  TAB4 if s[s length - 1 - i] equals c[k] ;  $  TAB5 set i2 to k ;  $  TAB5 break ;  $  TAB3 if c[i1 - 1] equals c[i2 - 1] and i1 greater than 0 and i2 greater than 0, increment g ;  $  TAB3 if c[i1 + 1] equals c[i2 - 1] and i2 greater 0, increment g ;  $  TAB3 if c[i1 - 1] equals c[i2 + 1] and i1 greater than 0, increment g ;  $  TAB3 if c[i1 + 1] equals c[i2 + 1], increment g ;  $  TAB3 if g == 0 ;  $  TAB4 print "NO" ;  $  TAB4 increment h ;  $  TAB4 break ;  $  TAB2 if h equals 0, print "YES" ;
TAB1 a is an integer array of length 101 ;  $  TAB1 n is an integer ;  $  TAB1 while read n ;  $  TAB2 i is an integer ;  $  TAB2 for i = 0 to n exclusive, input a[i] ;  $  TAB2 call sort with a, a + n ;  $  TAB2 display a[n - 1], ' ' ;  $  TAB2 for i = 1 to n - 1 exclusive, display a[i], ' ' ;  $  TAB2 display a[0] ;
TAB1 a and b are integers ;  $  TAB1 input a and b ;  $  TAB1 if absolute value (a - 1) is at most 1 and (a isn't 0 or b isn't 0) ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 let fa = array of integers size 202002 ;  $  TAB0 let sum = array of integers size 202002 ;  $  TAB0 let c = array of integers size 202002 ;  $  TAB0 declare integer function max which takes in integers a and b ;  $  TAB1 if a is greater than b ;  $  TAB2 return a ;  $  TAB1 else ;  $  TAB2 return b ;  $  TAB0 declare integer function findfa which takes in integer x ;  $  TAB1 if fa[x] is x ;  $  TAB2 return x ;  $  TAB1 else ;  $  TAB2 return findfa(fa[x] ;  $  TAB0 declare function U which takes in integers x and y ;  $  TAB1 let rx = integer with value findfa(x) ;  $  TAB1 let ry = integer with value findfa(y) ;  $  TAB1 if rx is not equal to ry do the following ;  $  TAB2 set fa[rx] = ry ;  $  TAB2 set sum[ry] = sum[ry] + sum[rx] ;  $  TAB0 let vis = array of booleans of size 202002 ;  $  TAB0 let vec = vector of integers ;  $  TAB1 let n, m, k = integers ;  $  TAB1 read n, m, k ;  $  TAB1 remove all elements of vec ;  $  TAB1 for integer i=0 to n inclusive do the following ;  $  TAB2 set fa[i] = i ;  $  TAB2 set sum[i] = 1 ;  $  TAB1 read k values into array c ;  $  TAB1 let x, y = integers ;  $  TAB1 for integer i=0 to m exclusive do the following ;  $  TAB2 read x, y ;  $  TAB2 call U on x and y ;  $  TAB1 set sizeof(vis) bytes starting at vis to 0 ;  $  TAB1 for integer i=0 to k exclusive vis[ call findfa on c[i]] = 1 ;  $  TAB1 let MAX = integer with value -1 ;  $  TAB1 let ans = long long with value 0 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 if fa[i] is 1 do the following ;  $  TAB3 if vis[i] is 1 ;  $  TAB4 set MAX = max of MAX and sum[i] ;  $  TAB3 else do the following ;  $  TAB4 append sum[i] to vec ;  $  TAB3 set ans = ans + sum[i} * (sum[i]-1) / 2 ;  $  TAB1 let len = integer with len = size of vec ;  $  TAB1 for integer i=0 to len do the following ;  $  TAB2 for integer j=i+1 to len set ans = ans + vec[i] * vec[j] ;  $  TAB2 set ans = ans + vec[i] * MAX ;  $  TAB1 set ans = ans - m ;  $  TAB1 if ans is greater than 0 ;  $  TAB2 print ans ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB0 define esVocal_o_n which takes char i and returns boolean ;  $  TAB1 if i == 'a' or i == 'e' or i == 'i' or i == 'o' or i == 'u' or i == 'n' ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB1 let s be string ;  $  TAB1 call getline of cin, s ;  $  TAB1 let n be long long with n = size of s ;  $  TAB1 let cumple be boolean with cumple = true ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if not esVocal_o_n(s[i]) ;  $  TAB3 if not esVocal_o_n(s[i+1]) and i + 1 < n ;  $  TAB4 set cumple to false ;  $  TAB4 break ;  $  TAB3 if s[i+1] == 'n' ;  $  TAB4 set cumple to false ;  $  TAB4 break ;  $  TAB1 if not esVocal_o_n(s[n-1]), set cumple to false ;  $  TAB1 if cumple ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 inf is a constant integer set to 0x3f3f3f3f ;  $  TAB0 T, n, x, y, d, ans are integers ;  $  TAB1 input T ;  $  TAB1 while decrement T ;  $  TAB2 read n, x, y, d ;  $  TAB2 set ans to inf ;  $  TAB2 if absolute value (y - x) modulo d equals 0 ;  $  TAB3 set ans to absolute value (y - x) / d ;  $  TAB2 else ;  $  TAB3 if (y - 1) is divisible by d, set ans to call min with ans, (x - 1) / d + 1 + (y - 1) / d ;  $  TAB3 if (n - y) is divisible by d, set ans to call min with ans, (n - x) / d + 1 + (n - y) / d ;  $  TAB2 if ans equals inf, set ans to -1 ;  $  TAB2 display ans ;
TAB0 mm= array of long long integer of size 100100 ;  $  TAB0 nn=array of long long integer of size 100100 ;  $  TAB1 n,m=long long integer ;  $  TAB1 read m ;  $  TAB1 read n values into the array mm ;  $  TAB1 sort mm array ;  $  TAB1 read n ;  $  TAB1 create a long long integer tot with tot=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read nn[i] ;  $  TAB2 set tot=tot+nn[i] ;  $  TAB1 sort nn array ;  $  TAB1 create an integer j with j=n-1 ;  $  TAB1 create an integer t with t=mm[0] ;  $  TAB1 if t>=n ;  $  TAB2 print tot ;  $  TAB1 create a long long integer ww with ww=0 ;  $  TAB1 while j>=0 ;  $  TAB2 for i=0 to t exclusive ;  $  TAB3 if j<0 then break ;  $  TAB3 set ww=ww+nn[j] ;  $  TAB3 decrement j ;  $  TAB2 set j=j-2 ;  $  TAB1 print ww ;
TAB1 let n, x, y, z, l be integers ;  $  TAB1 read n ;  $  TAB1 let arr be an integer array of size n ;  $  TAB1 read x ;  $  TAB1 for i = 0 to x exclusive ;  $  TAB2 read z ;  $  TAB2 set arr[z] to 1 ;  $  TAB1 read y ;  $  TAB1 for i = 0 to y exclusive ;  $  TAB2 read l ;  $  TAB2 set arr[l] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if arr[i] ins't 1 ;  $  TAB3 output Oh, my keyboard! ;  $  TAB1 output I become the guy. ;
TAB0 create string a ;  $  TAB0 create int jsq, ok ;  $  TAB1 read a ;  $  TAB1 for i = 0 to a size exclusive ;  $  TAB2 if a[i] equals '1' and i less than a size - 6 then set ok to 1 ;  $  TAB2 if ok and a[i] equals '0' then increment jsq ;  $  TAB1 if jsq greater than or equal to 6 ;  $  TAB2 print "yes" ;  $  TAB1 else ;  $  TAB2 print "no ;
TAB0 create char array a of 1005 elements ;  $  TAB0 in function judge returning int, taking int c and int n ;  $  TAB1 create int flag = n - 1 ;  $  TAB1 for i = c to n exclusive ;  $  TAB2 if a[i] does not equal a[flag - i + c], return 0 ;  $  TAB1 return 1 ;  $  TAB1 while reading a is not interrupted ;  $  TAB2 create int n ;  $  TAB2 read n ;  $  TAB2 create int s = length of a ;  $  TAB2 if n greater than s ;  $  TAB3 print "NO" ;  $  TAB3 continue ;  $  TAB2 if s mod n not equals 0 ;  $  TAB3 print "NO" ;  $  TAB3 continue ;  $  TAB2 create int pl = s / n ;  $  TAB2 create int ans = 0 ;  $  TAB2 create int h = 0 ;  $  TAB2 for i = 0 to s exclusive ;  $  TAB3 increase h by pl ;  $  TAB3 create int x = judge(i, h) ;  $  TAB3 if not x ;  $  TAB4 ans = 1 ;  $  TAB4 break ;  $  TAB3 i = h ;  $  TAB2 if ans ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" ;
TAB0 n,k,res=long long integer ;  $  TAB1 read n.k ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 a=long long integer ;  $  TAB2 read a ;  $  TAB2 if k % a =0 and a > res then set res=a ;  $  TAB1 print k/res ;
TAB1 n, a, b, c, maxi are integers with maxi = 0 ;  $  TAB1 read n, a, b, and c ;  $  TAB1 for x = 0 with condition a * x is less than n and increment x ;  $  TAB2 for y = 0 with condition ((y * b) + (a * x)) is less than n and increment y ;  $  TAB3 z = integer = (n - a * x - b * y) / c ;  $  TAB3 if a * x + b * y + c * z equals n ;  $  TAB4 if x + y + z is greater than maxi, maxi is assigned x + y + z ;  $  TAB1 display maxi ;
TAB0 create bool ab=0 ;  $  TAB1 create integers n,s,i,z,x,c,v,q,w,j ;  $  TAB1 input n ;  $  TAB1 input z,x ;  $  TAB1 read c,v ;  $  TAB1 read q,w ;  $  TAB1 if q>z and c>z and w>x and v>x then set ab to 1 ;  $  TAB1 if q>z and c>z and w<x and v<x then set ab to 1 ;  $  TAB1 if q<z and c<z and w>x and v>x then set ab to 1 ;  $  TAB1 if q<z and c<z and w<x and v<x then set ab to 1 ;  $  TAB1 if ab is 1 ;  $  TAB2 print YES and a new line ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB1 n= long long integer ;  $  TAB1 read n ;  $  TAB1 for i=2 to n+2 exclusive ;  $  TAB2 let factor be an integer with factor= i * i * (i-1) ;  $  TAB2 factor= factor - i ;  $  TAB2 if i>2 set factor=factor+2 ;  $  TAB2 print factor ;
TAB1 let n, cnt be long longs with cnt = 0 ;  $  TAB1 input n ;  $  TAB1 while n and 1 ;  $  TAB2 if n mod 2 is true, increment cnt ;  $  TAB2 shift 1 one bit to the right ;  $  TAB1 output cnt ;
TAB0 hur is a character array of size 200005 ;  $  TAB0 arr is an integer array of size 200005 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 read n values into array hur ;  $  TAB1 read n values into array arr ;  $  TAB1 ans = integer = maximum possible integer value ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if hur[i] is the character R and hur[i + 1] is the character L, set ans to call min with ans, arr[i + 1] - arr[i] ;  $  TAB1 if ans equals the maximum possible integer value ;  $  TAB2 output -1 ;  $  TAB1 else ;  $  TAB2 output ans / 2 ;
TAB0 num = integer array of size 110 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 call memset with num, 0, call sizeof with n ;  $  TAB1 maxx = integer = 0 ;  $  TAB1 while decrement n ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 increment num[x] ;  $  TAB2 set maxx to call max with maxx, num[x] ;  $  TAB1 display maxx ;
TAB1 t, s, x, i are integers ;  $  TAB1 read t, s, x ;  $  TAB1 if t equals x ;  $  TAB2 display YES ;  $  TAB1 for i = 1 to 1000000000 exclusive ;  $  TAB2 if t + s * i equals x or t + s * i + 1 equals x ;  $  TAB3 display YES ;  $  TAB3 break ;  $  TAB2 else if t + s * i is greater than x ;  $  TAB3 display NO ;  $  TAB3 break ;
TAB0 let po be vector of char ;  $  TAB0 let ans be map of char to int ;  $  TAB1 let ans['a'] = ans['e'] = ans['i'] = ans['o'] = ans['u'] = ans['y'] = 1 ;  $  TAB1 pos = string ;  $  TAB1 read pos ;  $  TAB1 call transform of begin of pos, end of pos, begin of pos, ::toLower ;  $  TAB1 for i = 0 to size of pos exclusive ;  $  TAB2 if ans[pos[i]] is not zero ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 push . to the back of po ;  $  TAB3 push pos[i] to the back of po ;  $  TAB1 for i = 0 to size of po, print po[i] ;  $  TAB1 print newline ;
TAB1 let n, a, b be integers ;  $  TAB1 let s be a string ;  $  TAB1 let ans be an integer ;  $  TAB1 read n, a, b, s ;  $  TAB1 if s[a - 1] is equal to s[b - 1] ;  $  TAB2 set ans to 0 ;  $  TAB1 else ;  $  TAB2 set ans to 1 ;  $  TAB1 display ans ;
TAB0 N = constant integer = 0 ;  $  TAB0 a, b are long longs ;  $  TAB0 s = string ;  $  TAB0 v = integer vector ;  $  TAB1 read s ;  $  TAB1 n = integer = length of s ;  $  TAB1 res = string = "" ;  $  TAB1 flag = boolean = false ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is the character a or flag ;  $  TAB3 add s[i] to res ;  $  TAB3 continue ;  $  TAB2 set flag to true ;  $  TAB2 while i is less than n and s[i] isn't the character a ;  $  TAB3 add s[i] - 1 to res ;  $  TAB3 increment i ;  $  TAB2 if i isn't n, decrement i ;  $  TAB1 if not flag, set res[n - 1] to the character z ;  $  TAB1 display res ;
TAB0 inf = constant integer = the integer 1e9 ;  $  TAB0 mod = constant integer = inf + 7 ;  $  TAB0 eps = constant double = 1e-9 ;  $  TAB0 pi = constant double = arccosine of -1.0 ;  $  TAB0 days is a constant integer array with days = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ;  $  TAB0 a is an integer array of length 111 ;  $  TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 for i = 0 to n exclusive, input a[i] ;  $  TAB1 res = integer = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 maxx = integer = a[i] ;  $  TAB2 ans = integer = a[i] ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 maxx is assigned bitwise or a[j] ;  $  TAB3 if ans is less than maxx, assign maxx to ans ;  $  TAB2 set res to call function max with arguments ans, res ;  $  TAB1 display res ;
TAB1 let u, l be integers with u = 0 and l = 0 ;  $  TAB1 let s be string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if element i of s >= 65 and element i of s <= 90, increment u by 1 ;  $  TAB2 if element i of s >= 97 and element i of s <= 122, increment l++ ;  $  TAB1 if u is greater than l ;  $  TAB2 call transform with s.begin(), s.end() s.begin() and ::toupper ;  $  TAB1 else ;  $  TAB2 call transform with s.begin(), s.end() s.begin() and ::tolower ;  $  TAB1 print out s with endline ;
TAB0 dx = integer array of size 4 with dx = 0, 0, -1, 1 ;  $  TAB0 dy = integer array of size 4 with dy = 1, -1, 0, 0 ;  $  TAB1 s, v1, v2, t1, t2 are integers ;  $  TAB1 read s, v1, v2, t1, t2 ;  $  TAB1 d1 is an integer set to v1 * s + 2 * t1 ;  $  TAB1 d2 is an integer set to v2 * s + 2 * t2 ;  $  TAB1 if d1 equals d2 ;  $  TAB2 display Friendship ;  $  TAB1 else if d1 is less than d2 ;  $  TAB2 display First ;  $  TAB1 else ;  $  TAB2 display Second ;
TAB0 n, x, y, z, p, q, ans, i, a, b, e=long long integer ;  $  TAB0 mp = map of <pair<long long int, long long int>, long long int> ;  $  TAB0 lol = pair<long long int, long long int> ;  $  TAB0 declare function lca which returns a long long integer ;  $  TAB0 declare function brainfuck ;  $  TAB0 declare function finder ;  $  TAB1 read n ;  $  TAB1 while n is true, decrement n and do the following ;  $  TAB2 read z ;  $  TAB2 if z=1 ;  $  TAB3 read a,b,z ;  $  TAB3 set p=a and q=b ;  $  TAB3 set x= lca() ;  $  TAB3 call brainfuck function ;  $  TAB2 else do the following ;  $  TAB3 set ans=0 ;  $  TAB3 read a,b ;  $  TAB3 set p=a and q=b ;  $  TAB3 set x = lca ;  $  TAB3 call finder function ;  $  TAB3 print ans ;  $  TAB0 in the function lca which returns a long long integer ;  $  TAB1 if log2(p) < log2(q) then swap values of p and q ;  $  TAB1 create long long integer log_=1 ;  $  TAB1 set y = log2(p) ;  $  TAB1 set x = log2(q) ;  $  TAB1 while (1 < <(log_ + 1)) <= y increment log_ ;  $  TAB1 for i=log_ to 0 inclusive ;  $  TAB2 if y - (1 << i) >= x ;  $  TAB3 set y=y - (1 << i) ;  $  TAB3 set p = p>> (1 << i) ;  $  TAB1 if p=q then return p ;  $  TAB1 for i=log_ to 0 inclusive ;  $  TAB2 if (p >> (1 << i)) > 1 and (p >> (1 << i)) is not equal to (q >> (1 << i)) ;  $  TAB3 set p = p >> (1 << i) ;  $  TAB3 q = q >> (1 << i) ;  $  TAB1 return p/2 ;  $  TAB0 in the function brainfuck ;  $  TAB1 set e=a ;  $  TAB1 while(a > x) and (a >>= 1) and (a > 0) do the following ;  $  TAB2 set lol.first = e ;  $  TAB2 set lol.second = a ;  $  TAB2 set e=a ;  $  TAB2 if mp.find(lol) is not equal to mp.end() ;  $  TAB3 set mp[lol] = mp[lol]+ z ;  $  TAB2 else do the following ;  $  TAB3 set mp[lol] = z ;  $  TAB1 set e=a ;  $  TAB1 while (b > x) and (b >>= 1) and (b > 0) then do the following ;  $  TAB2 set lol.first = e ;  $  TAB2 set lol.second = b ;  $  TAB2 set e=b ;  $  TAB2 if mp.find(lol) is not equal to mp.end() ;  $  TAB3 set mp[lol] = mp[lol] + z ;  $  TAB2 else do the following ;  $  TAB3 set mp[lol] = z ;  $  TAB0 in the function finder ;  $  TAB1 set e=a ;  $  TAB1 while (a > x) and (a >>= 1) and (a > 0) do the following ;  $  TAB2 set lol.first = e ;  $  TAB2 set lol.second = a ;  $  TAB2 set e=a ;  $  TAB2 if mp.find(lol) is not equal to mp.end() set ans =ans +mp[lol] ;  $  TAB1 set e=b ;  $  TAB1 while (b > x) and (b >>= 1) and (b > 0) ;  $  TAB2 set lol.first = e ;  $  TAB2 set lol.second = b ;  $  TAB2 set e=b ;  $  TAB2 if mp.find(lol) is not equal to mp.end() set ans =ans+mp[lol] ;
TAB0 make string s ;  $  TAB0 in function ok with return type boolean and parameter string t ;  $  TAB1 make int msk = 0 ;  $  TAB1 for i = 0 to (cast t size to int) exclusive ;  $  TAB2 if isupper(t[i]) then set msk to msk bitwise or 1 ;  $  TAB2 if islower(t[i]) then set msk to msk bitwise or1 ;  $  TAB2 if isdigit(t[i]) then set msk to msk bitwise or 1 ;  $  TAB1 return msk is equal to 7 ;  $  TAB1 make integer t ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 read s ;  $  TAB2 if ok(s) ;  $  TAB3 print s ;  $  TAB3 continue ;  $  TAB2 make boolean fnd = false ;  $  TAB2 for i = 0 to (cast s size to int) exclusive ;  $  TAB3 make string t = s ;  $  TAB3 set t[i] to '1' ;  $  TAB3 if ok(t) ;  $  TAB4 print t ;  $  TAB4 set fnd to true ;  $  TAB4 break ;  $  TAB3 set t[i] to 'a' ;  $  TAB3 if ok(t) ;  $  TAB4 print t ;  $  TAB4 set fnd to true ;  $  TAB4 break ;  $  TAB3 set t[i] to 'A' ;  $  TAB3 if ok(t) ;  $  TAB4 print t ;  $  TAB4 set fnd to true ;  $  TAB4 break ;  $  TAB2 if fnd then continue ;  $  TAB2 if isupper(s[2]) ;  $  TAB3 set s[0] to 'a' ;  $  TAB3 set s[1] to '1' ;  $  TAB3 print s ;  $  TAB3 continue ;  $  TAB2 if islower(s[2]) ;  $  TAB3 set s[0] to 'A' ;  $  TAB3 set s[1] to '1' ;  $  TAB3 print s ;  $  TAB3 continue ;  $  TAB2 if isdigit(s[2]) ;  $  TAB3 set s[0] to 'a' ;  $  TAB3 set s[1] to 'A' ;  $  TAB3 print s ;  $  TAB3 continue ;
TAB1 n,m=integers ;  $  TAB1 read n,m ;  $  TAB1 create an integer v with v=0 ;  $  TAB1 x= array of integer of size 100 ;  $  TAB1 arr = array of integer of size 100 ;  $  TAB1 create a boolean ans with ans= true ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i]>v then set v = arr[i] ;  $  TAB1 sort arr ;  $  TAB1 for i=0 to m exclusive ;  $  TAB2 read x[i] ;  $  TAB2 if x[i]<= v then set ans = false ;  $  TAB1 create an integer cnt with cnt=0 ;  $  TAB1 if ans = true ;  $  TAB2 if arr[0]*2 > v ;  $  TAB3 set v=2*arr[0] ;  $  TAB3 for i=0 to m exclusive ;  $  TAB4 if x[i]<=v then set ans=false ;  $  TAB1 if ans is true ;  $  TAB2 print v ;  $  TAB1 else do the following ;  $  TAB2 print -1 ;
TAB1 make strings s1 and s2 ;  $  TAB1 read s1 and s2 ;  $  TAB1 for i = 0 to s1 size exclusive do set s1[i] to tolower(s1[i]) converted to char ;  $  TAB1 for i = 0 to s2 size exclusive do set s2[i] to tolower(s2[i]) converted to character ;  $  TAB1 if s1 is equal to s2 ;  $  TAB2 print "0" ;  $  TAB1 else if s1 less than s2 ;  $  TAB2 print "-1" ;  $  TAB1 else ;  $  TAB2 print "1" ;
TAB1 let n, k be integers ;  $  TAB1 read n, k ;  $  TAB1 let str be string ;  $  TAB1 read str ;  $  TAB1 let s be integer with s = find of begin of str, end of str, 'G' - begin of str ;  $  TAB1 let e be integer with s = find of begin of str, end of str, 'T' - begin of str ;  $  TAB1 if s > e, call swap of s, e ;  $  TAB1 let res of boolean with res = false ;  $  TAB1 while s <= e, increment s by k ;  $  TAB2 if s == e, update res to true ;  $  TAB2 if str[s] == '#', break ;  $  TAB1 print YES if res is true else NO ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 declare integers a, b, c ;  $  TAB1 define integer cnt = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a, b, c ;  $  TAB2 if a + b + c is greater than 2 then increase cnt by 1 ;  $  TAB1 print cnt ;
TAB1 terminate statement ;  $  TAB1 i, j, k, l, z, x, c, v, b, n, m are long long integers with b = 0, m = 0, a = integer array of size 120 ;  $  TAB1 declare a string s ;  $  TAB1 input s ;  $  TAB1 set l to the size of s ;  $  TAB1 for i = 1 to l exclusive with b = 1 ;  $  TAB2 if s[i - 1] is equal to s[i] ;  $  TAB3 increment b ;  $  TAB2 else ;  $  TAB3 if b is even, increment m ;  $  TAB3 assign 1 to b ;  $  TAB1 if b is even, increment m ;  $  TAB1 display m ;
TAB1 create integer s,v1,v2,t1,t2,ans1 and ans2 with ans1 =0 and ans2 =0 ;  $  TAB1 read s,v1,v2,t1,t2 ;  $  TAB1 set ans1=v1*s ;  $  TAB1 set ans2=v2*s ;  $  TAB1 set ans1 =ans1+t1=t2 ;  $  TAB1 set ans2= ans2 +t1+t2 ;  $  TAB1 if ans1> ans2 ;  $  TAB2 print Second ;  $  TAB1 else if ans1< ans2 ;  $  TAB2 print First ;  $  TAB1 else if ans1=ans2 ;  $  TAB2 print Friendship ;
TAB0 let l, r, a, b, c, ans be integers ;  $  TAB1 read l, r, a ;  $  TAB1 set b to min of l and r ;  $  TAB1 set c to max of l and r ;  $  TAB1 for i = 0 to a inclusive, set ans to max of ans and min of b+i, c+a-i ;  $  TAB1 print out ans * 2 with newline ;
TAB0 win = array of integers length 205 ;  $  TAB1 n, m, mx, ind, and ans = integers, with mx set to -1 and ind set to 0 ;  $  TAB1 read n ;  $  TAB1 read m ;  $  TAB1 arr = array of long long integers with length n + 1 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 read arr[j] ;  $  TAB3 if mx < arr[j] ;  $  TAB4 set mx to arr[j] ;  $  TAB4 set ind to j ;  $  TAB2 increment win[ind] by 1 ;  $  TAB2 set mx to -1 ;  $  TAB1 set ans to *max_element of win and win + 205 ;  $  TAB1 for i = 0 to 205 exclusive ;  $  TAB2 if win[i] is ans ;  $  TAB3 print i + 1 ;  $  TAB3 break ;
TAB0 n, sum are integers with sum = 0 ;  $  TAB0 str = string ;  $  TAB1 input n ;  $  TAB1 while decrement n ;  $  TAB2 input str ;  $  TAB2 if str equals Tetrahedron ;  $  TAB3 add 4 to sum ;  $  TAB2 else if str equals Cube ;  $  TAB3 add 6 to sum ;  $  TAB2 else if str equals Octahedron ;  $  TAB3 add 8 to sum ;  $  TAB2 else if str equals Dodecahedron ;  $  TAB3 add 12 to sum ;  $  TAB2 else if str equals Icosahedron ;  $  TAB3 add 20 to sum ;  $  TAB1 output sum ;
TAB1 m, n, i, min are integers, a is an integer array of size 50 ;  $  TAB1 read n and m ;  $  TAB1 for i - 0 to m exclusive, read a[i] ;  $  TAB1 call sort with arguments a, a + m ;  $  TAB1 set i to 0 ;  $  TAB1 set min to a[0] + a[0 + n - 1] ;  $  TAB1 while i + n is at most m ;  $  TAB2 if (a[i + n - 1] - a[i] is less than min, set min to a[i + n - 1] - a[i] ;  $  TAB2 increment i ;  $  TAB1 display min ;
TAB0 let s, t = strings ;  $  TAB0 let l1, l2 = integers ;  $  TAB0 let p = 10001 arrays of integers of size 26 ;  $  TAB1 while (read s, t) is true do the following ;  $  TAB2 set l1 = size of s ;  $  TAB2 set l2 = size of t ;  $  TAB2 set sizeof(p) bytes starting at p to 0 ;  $  TAB2 for integer i=0 to 26 exclusive set p[l1][i] to -1 ;  $  TAB2 for integer j=l1 to 1 inclusive decrementing ;  $  TAB3 for integer i=0 to 26 exclusive ;  $  TAB4 if s[j] is i + a ;  $  TAB5 set p[j-1][i] = j ;  $  TAB4 else ;  $  TAB5 set p[j-1][i] = p[j][i] ;  $  TAB2 let ans, l = integers where ans = 1, l = -2 ;  $  TAB2 for integer i=0 to l2 exclusive do the following ;  $  TAB3 if l2 is -2 do the following ;  $  TAB4 if s[0] is t[i] ;  $  TAB5 set l = 0 ;  $  TAB4 else ;  $  TAB5 set l = p[0][t[i]-a] ;  $  TAB4 if l is -1 do the following ;  $  TAB5 set ans = -1 ;  $  TAB5 exit the loop ;  $  TAB3 else do the following ;  $  TAB4 set l = p[l][t[i] - a] ;  $  TAB4 if l is -1 do the following ;  $  TAB5 increment ans ;  $  TAB5 set l = -2 ;  $  TAB5 decrement i ;  $  TAB2 print ans ;
TAB0 declare a function solve ;  $  TAB1 let a, b = strings ;  $  TAB1 let n = integer ;  $  TAB1 read a, b ;  $  TAB1 read n ;  $  TAB1 print a and a space and b ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let murdered = string ;  $  TAB2 let newvictim = string ;  $  TAB2 read murdered, newvictim ;  $  TAB2 if a is murdered ;  $  TAB3 set a = newvictim ;  $  TAB2 else ;  $  TAB3 set b = newvictim ;  $  TAB2 print a and a space and b ;  $  TAB1 call solve ;
TAB1 create int i, j, k, l, m, n, cnt = 0, t = 0, len = 0, ans = 0 ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to s size exclusive ;  $  TAB2 for j = i + 1 to s size exclusive ;  $  TAB3 assign 0 to len ;  $  TAB3 while s[i + len] equals s[j + len], increment len ;  $  TAB3 if len greater than ans, set ans to len ;  $  TAB1 print ans ;
TAB1 t = integer ;  $  TAB1 read t ;  $  TAB1 s = integer vector ;  $  TAB1 counter = integer = 0 ;  $  TAB1 while decrement t ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 append x to s ;  $  TAB1 flag is a boolean set to 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] equals 1 ;  $  TAB3 increment counter ;  $  TAB3 assign 1 to flag ;  $  TAB2 if s[i] is 0 and s[i + 1] is 1 and flag is 1, increment counter ;  $  TAB2 if s[i] is 0 and s[i + 1] is 0, assign 0 to flag ;  $  TAB1 print counter ;
TAB1 declare long longs a, b ;  $  TAB1 input a and b ;  $  TAB1 if a is positive ;  $  TAB2 if b is positive ;  $  TAB3 display 0, ' ', a + b, ' '. a + b, ' ', 0 ;  $  TAB2 else ;  $  TAB3 display 0, ' ', b - a, ' ', a - b, ' ', 0 ;  $  TAB1 else ;  $  TAB2 if b is positive ;  $  TAB3 display a - b, ' ', 0, ' ', 0, ' ', b - a ;  $  TAB2 else ;  $  TAB3 display a + b, ' ', 0, ' ', 0, ' ', a + b ;
TAB0 in function cmmdc with parameters integers a, b and return integer ;  $  TAB1 r is an integer set to a modulo b ;  $  TAB1 while r ;  $  TAB2 set a to b ;  $  TAB2 set b to r ;  $  TAB2 set r to a modulo b ;  $  TAB1 return b ;  $  TAB0 n, a, x, i are integers ;  $  TAB1 read n ;  $  TAB1 read a ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 read x ;  $  TAB2 set a to call cmmdc with a, x ;  $  TAB1 display a * n ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if '9' - s[i] is less than s[i] - '0' ;  $  TAB3 if i greater than 0 OR s[i] not equal to '9', set s[i] to '0' + '9' - s[i] ;  $  TAB1 print s ;
TAB0 make integer array a with a size of 400000 ;  $  TAB1 make integer t ;  $  TAB1 read t ;  $  TAB1 for i = 1 to t inclusive ;  $  TAB2 read a[i] ;  $  TAB2 if 360 mod (180 - a[i]) equals 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB0 create integers n, i, array a length 1111111, ans = 0, array d length 1111111 ;  $  TAB1 read n ;  $  TAB1 read n elements into a ;  $  TAB1 assign 1 to d[1] ;  $  TAB1 for i = 2 to n exclusive, assign d[i / 2] * 2 to d[i] ;  $  TAB1 for i = 0; i + 1 < n; i++ ;  $  TAB2 add a[i] to a[i + d[n - i - 1]] ;  $  TAB2 add a[i] to ans ;  $  TAB2 print ans ;
TAB1 arr is a boolean array of size 105 with bool = 0 ;  $  TAB1 n, m, i, j, and counter are all integers with m, i, j, and counter = 0 ;  $  TAB1 read n ;  $  TAB1 read m ;  $  TAB1 k and p are integers ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read k ;  $  TAB2 for j = 1 to k inclusive ;  $  TAB3 read p ;  $  TAB3 assign 1 to arr[p] ;  $  TAB1 for i = 0 to 105 exclusive ;  $  TAB2 if arr[i] equals true, increment counter ;  $  TAB1 if counter equals m ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB1 s, s1, s2 = strings ;  $  TAB1 n, i = integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read s ;  $  TAB2 increment s1 by s ;  $  TAB1 set s2 to s1 ;  $  TAB1 reverse beginning of s2 and end of s2 ;  $  TAB1 if s2 is s1 print "YES", otherwise print "NO" ;
TAB1 declare integer n ;  $  TAB1 declare string a ;  $  TAB1 declare string b ;  $  TAB1 read a and b ;  $  TAB1 declare map mp of strings to ints ;  $  TAB1 set mp["monday"] to 1 ;  $  TAB1 set mp["tuesday"] to 2 ;  $  TAB1 set mp["wednesdya"] to 3 ;  $  TAB1 set mp["thursday"] to 4 ;  $  TAB1 set mp["friday"] to 5 ;  $  TAB1 set mp["saturday"] to 6 ;  $  TAB1 set mp["sunday"] to 0 ;  $  TAB1 define int p1 = mp[a] ;  $  TAB1 define int p2 = mp[b] ;  $  TAB1 if (p1 + 30) mod 7 is p2 ;  $  TAB2 print "YES" ;  $  TAB1 if (p1 + 28) mod 7 is p2 ;  $  TAB2 print "YES" ;  $  TAB1 if (p1 + 31) mod 7 is p2 ;  $  TAB2 print "YES" ;  $  TAB1 print "NO" ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 count and x are integers both set to 0 ;  $  TAB1 for i = (size of s) - 1 to 0 inclusive ;  $  TAB2 if s[i] is the character 0, increment count ;  $  TAB2 if s[i] is the character 1 and count is at least 6, set x to 1 ;  $  TAB1 if x equals 1 ;  $  TAB2 print yes ;  $  TAB1 else ;  $  TAB2 print no ;
TAB1 let n, s, h, m be integers with a be array of integers of size 1000 ;  $  TAB1 read n, s ;  $  TAB1 let time be integers with time = 0 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read h, m ;  $  TAB2 set t to h * 60 + m ;  $  TAB2 set a[i] to t ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if (a[i+1] - a[i]) is greater than or equal to 2*s+2 ;  $  TAB3 set time to a[i] + s + 1 ;  $  TAB3 break ;  $  TAB1 if time is equal to 0, set time to a[n] + s + 1 ;  $  TAB1 if (a[1] - a[0]) is greater than or equal to (s+1), set time to 0 ;  $  TAB1 let t_h be integer with t_h = time/60 ;  $  TAB1 let t_m be integer with t_m = time mod 60 ;  $  TAB1 print out t_h, " ", t_m with newline ;
TAB1 n, x, ans are integers with ans = 0 ;  $  TAB1 input n, x ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if x is divisible by i ;  $  TAB3 if x / i is at most n, increment ans ;  $  TAB1 output ans ;
TAB0 declare multidimensional char array a, size 109 by 109 ;  $  TAB1 declare int i, j, n, m ;  $  TAB1 define int bl = 0, wh = 0 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i mod 2 equals 0 ;  $  TAB3 assign 1 to bl ;  $  TAB2 else ;  $  TAB3 assign 1 to wh ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if a[i][j] equals '.' ;  $  TAB4 if bl equals 1 ;  $  TAB5 assign 'B' to a[i][j] ;  $  TAB5 assign 0 to bl and 1 to wh ;  $  TAB4 else ;  $  TAB5 assign 'W' to a[i][j] ;  $  TAB5 assign 1 to bl and 0 to wh ;  $  TAB3 else ;  $  TAB4 if bl equals 1 ;  $  TAB5 assign 0 to bl and 1 to wh ;  $  TAB4 else ;  $  TAB5 assign 1 to bl and 0 to wh ;  $  TAB2 assign 0 to bl and 0 to wh ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive, print a[i][j] ;  $  TAB2 print newline ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n equal 0 ;  $  TAB2 print 0 ;  $  TAB1 else if n equal 2 ;  $  TAB2 print 2 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int array a with a size of n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if 360 % (180 - a[i]) is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 a is a string array of size 2 ;  $  TAB1 s is a string ;  $  TAB1 read s ;  $  TAB1 set a[0] to s ;  $  TAB1 display s, " " ;  $  TAB1 read s ;  $  TAB1 set a[1] to s ;  $  TAB1 display s ;  $  TAB1 n = integer ;  $  TAB1 input n ;  $  TAB1 u, o are strings ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read u, o ;  $  TAB2 if u equals a[0], set a[0] to o ;  $  TAB2 if u equals a[1], set a[1] to o ;  $  TAB2 dislay a[0], " " ;  $  TAB2 display a[1] ;
TAB1 create int k, n, temp, ans = 0 ;  $  TAB1 read k and n ;  $  TAB1 set k to k mod 10 ;  $  TAB1 if k is equal to 0 ;  $  TAB2 set ans to 1 ;  $  TAB1 else ;  $  TAB2 for i = 1 to 11 exclusive ;  $  TAB3 set temp to k * i ;  $  TAB3 set temp to temp modulo 10 ;  $  TAB3 if temp is equal to 0 or temp is equal to n ;  $  TAB4 set ans to i ;  $  TAB4 break ;  $  TAB1 print ans ;
TAB0 mod = static integer = 1e9 + 7 ;  $  TAB1 n, m are integers, row, col are integer arrays both of size 105, table is an integer array of sizes 105 and 105, minn and flag are integers ;  $  TAB1 while read n, m ;  $  TAB2 tmp = integer = 0 ;  $  TAB2 call memset with row, 0, call sizeof with row ;  $  TAB2 call memset with col, 0, call sizeof with col ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to m inclusive, read table[i][j] ;  $  TAB2 if m is at least n ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 set min to 0x3f3f3f3f ;  $  TAB4 for j = 1 to m inclusive ;  $  TAB5 if table[i][j] is less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 add minn to tmp ;  $  TAB5 set row[i] to minn ;  $  TAB5 for j = 1 to m inclusive, subtract minn from table[i][j] ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for i = 1 to n inclusive ;  $  TAB5 if table[i][j] is less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 add minn to tmp ;  $  TAB5 set col[j] to minn ;  $  TAB5 for i = 1 to n inclusive, subtract minn from table[i][j] ;  $  TAB2 else ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for i = 1 to n inclusive ;  $  TAB5 if table[i][j] is less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 add minn to tmp ;  $  TAB5 set col[j] to minn ;  $  TAB5 for i = 1 to n inclusive, subtract minn from table[i][j] ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 set minn to 0x3f3f3f3f ;  $  TAB4 for j = 1 to m inclusive ;  $  TAB5 if table[i][j] is less than minn, set minn to table[i][j] ;  $  TAB4 if minn ;  $  TAB5 add minn to tmp ;  $  TAB5 set row[i] to minn ;  $  TAB5 iterate m times, subtract minn from table[i][j] ;  $  TAB2 set flag to 1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 if table[i][j] ;  $  TAB5 set flag to 0 ;  $  TAB5 break ;  $  TAB2 if flag ;  $  TAB3 print tmp ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 for k = 1 to row[i] inclusive, print "row ", i ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 for j = 1 to col[j] inclusive, print "col ", j ;  $  TAB2 else ;  $  TAB3 print -1 ;
TAB0 let M be const integer with M = 2e5 + 5 ;  $  TAB0 let inf be const integer with inf = 1e9 + 5 ;  $  TAB1 n = integer ;  $  TAB1 v = vector of integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 let t be integer ;  $  TAB2 read t ;  $  TAB2 push t to back of v ;  $  TAB1 sort v ;  $  TAB1 print out v[n/2] with newline ;
TAB1 a,b,diff,same = integers ;  $  TAB1 read a and b ;  $  TAB1 if a<b ;  $  TAB2 set diff = a ;  $  TAB1 else do the following ;  $  TAB2 set diff = b ;  $  TAB1 set a to a-diff ;  $  TAB1 set b= b-diff ;  $  TAB1 if a<b ;  $  TAB2 set same to b/2 ;  $  TAB1 else do the following ;  $  TAB2 assign a/2 to same ;  $  TAB1 print diff and same and a new line ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create booleans poss1 = true, poss2 = true ;  $  TAB1 create integers poss1_p1, poss1_p2, poss1_spec, poss2_p1, poss2_p2, poss2_spec ;  $  TAB1 assign 1 to poss1_p1 ;  $  TAB1 assign 2 to poss1_p2 ;  $  TAB1 assign 3 to poss1_spec ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create int winner ;  $  TAB2 read winner ;  $  TAB2 if poss1 ;  $  TAB3 if winner is poss1_spec then set poss1 to false ;  $  TAB3 create int temp = poss1_spec ;  $  TAB3 set poss1_spec to (if poss1_p1 is winner then poss1_p2; else, poss1_p1) ;  $  TAB3 if poss1_spec is poss1_p1 ;  $  TAB4 set poss1_p1 to temp ;  $  TAB3 else ;  $  TAB4 set poss1_p2 to temp ;  $  TAB1 if not poss1 ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 a, b, c are doubles ;  $  TAB1 read a, b, c ;  $  TAB1 display (square root (a * b / c) + square root (c * a / b) + square root (c * b / a)) * 4 ;
TAB1 create int n ;  $  TAB1 create char multidimensional array mp of size 110x110 ;  $  TAB1 read n ;  $  TAB1 set elements of mp to '*' ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive, read mp[j][i] ;  $  TAB1 create bool flag = true ;  $  TAB1 for i = 1 to n inclusive and flag ;  $  TAB2 create int cnt = 0 ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 if mp[j - 1][i] equals 'o', increment cnt ;  $  TAB3 if mp[j + 1][i] equals 'o', increment cnt ;  $  TAB3 if mp[j][i - 1] equals 'o', increment cnt ;  $  TAB3 if mp[j][i + 1] equals 'o', increment cnt ;  $  TAB3 if cnt is odd ;  $  TAB4 set flag to false ;  $  TAB4 break ;  $  TAB1 print "YES" if flag, else "NO" ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create integer b, a = s.size() ;  $  TAB1 if a is equal to 1 ;  $  TAB2 print "51" ;  $  TAB1 else ;  $  TAB2 set b to 51 + (25 * (a - 1)) ;  $  TAB2 print b ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 if n mod 2 ;  $  TAB2 print (n - 1) / 2 ;  $  TAB1 else ;  $  TAB2 print (n - (1 << (31 - __builtin_clz(n)))) / 2 ;
TAB1 create int n, x, t = 0, out = 0, k = 0 ;  $  TAB1 read n and x ;  $  TAB1 create integer array z of size n ;  $  TAB1 while k less than n ;  $  TAB2 read z[k] ;  $  TAB2 increase t by z[k] ;  $  TAB2 add 1 to k ;  $  TAB1 if t greater than 0 ;  $  TAB2 while t greater than 0 ;  $  TAB3 if t - x greater than or equal to 0 ;  $  TAB4 subtract x from t ;  $  TAB4 increment out ;  $  TAB3 else ;  $  TAB4 decrement x ;  $  TAB1 else if t less than 0 ;  $  TAB2 while t is less than 0 ;  $  TAB3 if t + x less than or equals 0 ;  $  TAB4 increase t by x ;  $  TAB4 increment out ;  $  TAB3 else ;  $  TAB4 decrement x ;  $  TAB1 print out ;
TAB0 a.b= integers ;  $  TAB0 create integer res=0 ;  $  TAB0 q=integer ;  $  TAB0 t=integer ;  $  TAB1 read t ;  $  TAB1 while t is true decrement t and do the following ;  $  TAB2 read a and b ;  $  TAB2 set res=0 ;  $  TAB2 while true do the following ;  $  TAB3 if a=b or a=0 or b=0 ;  $  TAB4 increment res ;  $  TAB4 break out of the while loop ;  $  TAB3 if a>b then swap a and b ;  $  TAB3 if b/a = 1 ;  $  TAB4 then set b= b-a ;  $  TAB4 increment res ;  $  TAB3 else do the following ;  $  TAB4 set q= b/a-1 ;  $  TAB4 set res= res + q ;  $  TAB4 set b = b-q*a ;  $  TAB2 print res ;  $  TAB2 print new line ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 print n mod 2 with newline ;
TAB0 used is an integer array of size 100005 ;  $  TAB1 n = integer ;  $  TAB1 input n ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 let x be an integer ;  $  TAB2 input x ;  $  TAB2 assign 1 to used[x] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if used[i] is false, display i ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n is at most 10 or n is greater than 21 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 ans = integer = 0 ;  $  TAB2 tmp = integer = n - 10 ;  $  TAB2 if tmp equals 10 ;  $  TAB3 set ans to 15 ;  $  TAB2 else ;  $  TAB3 set ans to 4 ;  $  TAB2 print ans ;
TAB0 let maxn be const int with maxn = 1e4 + 10 ;  $  TAB0 let mp be map from string to int ;  $  TAB0 let a, b, c be strings ;  $  TAB1 set mp["C"] to 1 ;  $  TAB1 set mp["C#"] to 2 ;  $  TAB1 set mp["D"] to 3 ;  $  TAB1 set mp["D#"] to 4 ;  $  TAB1 set mp["E"] to 5 ;  $  TAB1 set mp["F"] to 6 ;  $  TAB1 set mp["F#"] to 7 ;  $  TAB1 set mp["G"] to 8 ;  $  TAB1 set mp["G#"] to 9 ;  $  TAB1 set mp["A"] to 10 ;  $  TAB1 set mp["B"] to 11 ;  $  TAB1 set mp["H"] to 12 ;  $  TAB1 read a, b, c ;  $  TAB1 if mp[a] > mp[b], call swap of a, b ;  $  TAB1 if mp[a] > mp[c], call swap of a, c ;  $  TAB1 if mp[b] > mp[c], call swap of b, c ;  $  TAB1 for i = 1 to 100 inclusive ;  $  TAB2 if (mp[b] - mp[a] == 4 and mp[c] - mp[b] == 3 ;  $  TAB3 print major ;  $  TAB2 else if mp[b] - mp[a] == 3 and mp[c] - mp[b] == 4 ;  $  TAB3 print minor ;  $  TAB2 else ;  $  TAB3 update mp[a] to mp[a] + 12 ;  $  TAB3 let tem be string with tem = a ;  $  TAB3 set a to b ;  $  TAB3 set b to c ;  $  TAB3 set c to tem ;  $  TAB1 print strange ;
TAB1 n, b, p, B, P are integers ;  $  TAB1 read n, b, p ;  $  TAB1 set B to 0 ;  $  TAB1 set P to 0 ;  $  TAB1 set P to n * p ;  $  TAB1 while n is greater than 1 ;  $  TAB2 r is an integer with r = n mod 2 ;  $  TAB2 divide n by 2 ;  $  TAB2 set B to n * (2 * b + 1) ;  $  TAB2 add r to n ;  $  TAB1 display B, " ", P ;
TAB1 let n, c, t, sum = integers with sum = 0 ;  $  TAB1 read n ;  $  TAB1 read c ;  $  TAB1 read t ;  $  TAB1 increment sum ;  $  TAB1 let a = integr with value t ;  $  TAB1 for integer i=1 to n exclusive do the following ;  $  TAB2 read t ;  $  TAB2 if t - a is less than or equal to c ;  $  TAB3 increment sum ;  $  TAB2 else if t - a is greater than c ;  $  TAB3 set sum = 1 ;  $  TAB2 set a = t ;  $  TAB1 print sum ;
TAB0 mx, arr, arr2 = arrays of long long integers with mx has length of 1011, and arr and arr2 have length of 1001 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 for i = 0 to n exclusive, read arr2[i] ;  $  TAB1 ans = long long integer set to -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 add = long long integer set to arr[i] ;  $  TAB2 add2 = long long integer set to arr2[i] ;  $  TAB2 for j = i + 1 to n exclusive ;  $  TAB3 set add to add or arr[j] ;  $  TAB3 set add2 to add2 or arr2[j] ;  $  TAB3 set mx[i] to max of mx[i] or add + add2 ;  $  TAB3 set ans to max of ans or mx[i] ;  $  TAB2 set mx[i] to max of mx[i] or add + add2 ;  $  TAB2 set ans to max of ans or mx[i] ;  $  TAB1 print ans ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let counter be integer with counter = 0 ;  $  TAB1 let b be integer with b = 0 ;  $  TAB1 let max be integer with max = 0 ;  $  TAB1 let x be integer ;  $  TAB1 while n is greater 0, decrement n by 1 ;  $  TAB2 read x ;  $  TAB2 if x is greater than or equal to b ;  $  TAB3 increment counter by 1 ;  $  TAB3 if counter is greater than or equal to max, set max to counter ;  $  TAB2 else ;  $  TAB3 set counter to 1 ;  $  TAB2 set b to x ;  $  TAB1 print max with newline ;
TAB1 create long long int n ;  $  TAB1 read n ;  $  TAB1 if n is even ;  $  TAB2 print (n / 2) ;  $  TAB1 else ;  $  TAB2 print -((n / 2) + 1) ;
TAB0 a=array of integer of size 105 ;  $  TAB1 n,m= integers ;  $  TAB1 read n,m ;  $  TAB1 let k be an integer with k =0 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 for j =0 to x exclusive ;  $  TAB3 t= integer ;  $  TAB3 read t ;  $  TAB3 set a[t] to 1 ;  $  TAB1 for i =1 to m inclusive ;  $  TAB2 if a[i] is not equal to 1 ;  $  TAB3 set k to 1 ;  $  TAB3 break ;  $  TAB1 if k is 0 ;  $  TAB2 print YES ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB1 n and k are integers ;  $  TAB1 read n and k ;  $  TAB1 s is a string ;  $  TAB1 alfa is a character vector of size 26 ;  $  TAB1 for i = 0 to integer value 26 exclusive, set alfa[i] to character value ((integer value of character a) + i) ;  $  TAB1 cont = integer = 0 ;  $  TAB1 for i = 0 to integer value n exclusive ;  $  TAB2 add alfa[cont] to s ;  $  TAB2 increment cont ;  $  TAB2 if cont equals 26 or cont equals k, set cont to 0 ;  $  TAB1 display s ;
TAB0 let inf be const int with inf = 0x3f3f3f3f ;  $  TAB0 let maxn be const int with maxn = 110 ;  $  TAB0 define max which takes integers a and b as arguments and returns int ;  $  TAB1 if a is greater than b, return a else return b ;  $  TAB0 define min which takes integers a and b as arguments and returns int ;  $  TAB1 if a is greater than b, return b else return a ;  $  TAB0 a = array of integers of size maxn ;  $  TAB1 let i, n be integers ;  $  TAB1 while input is available, read n ;  $  TAB2 set a[0] to 0 and a[n+1] to 1001 ;  $  TAB2 for i = 1 to n inclusive, read a[i] ;  $  TAB2 let l be integer ;  $  TAB2 let maxi be integer with maxi = 1 ;  $  TAB2 for l = 0 to n inclusive ;  $  TAB3 let pos be integer with pos = 1 ;  $  TAB3 while l is less than or equal to n and a[l] + 1 is equal to a[l+1], increment l ;  $  TAB3 if l - pos + 1 is greater than maxi, set maxi to l - pos + 1 ;  $  TAB2 if maxi is equal to 1 ;  $  TAB3 print out 0 with newline ;  $  TAB2 else ;  $  TAB3 print maxi - 2 with newline ;
TAB1 let a, b be integers ;  $  TAB1 read a, b ;  $  TAB1 let min be integer ;  $  TAB1 let max be integer ;  $  TAB1 if a < b ;  $  TAB2 set min to a ;  $  TAB2 set max to b ;  $  TAB1 else ;  $  TAB2 set min to b ;  $  TAB2 set max to a ;  $  TAB1 print min, " " ;  $  TAB1 print (max - min) / 2 ;
TAB1 let i, n, x, s, max be integers with s and max both initialized to 0 ;  $  TAB1 input n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input x ;  $  TAB2 if x is greater than max, max = x ;  $  TAB2 add x to s ;  $  TAB1 display n * max - s ;
TAB0 let q and a be long long integer arrays of size 100100 each ;  $  TAB1 n,m= long long ints ;  $  TAB1 read m ;  $  TAB1 read m values into array q ;  $  TAB1 sort q array ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 sort a ;  $  TAB1 now= long long integer with value 0 ;  $  TAB1 create long long integer sum=0 ;  $  TAB1 create boolean flag =0 ;  $  TAB1 for i=n-1 to 0 inclusive ;  $  TAB2 if now is equal to q[0] ;  $  TAB3 if flag is true ;  $  TAB4 set now=0 ;  $  TAB3 else do the following ;  $  TAB4 set flag to 1 ;  $  TAB2 else do the following ;  $  TAB3 increment now ;  $  TAB3 set sum=sum+a[i] ;  $  TAB3 assign 0 to flag ;  $  TAB1 print sum ;
TAB0 str = string ;  $  TAB0 in function check with parameters integers x, y and return boolean ;  $  TAB1 i and j are integers with i = x, j = y ;  $  TAB1 while i is less than j ;  $  TAB2 if str[i] equals str[j] ;  $  TAB3 increment i ;  $  TAB3 decrement j ;  $  TAB2 else ;  $  TAB3 return false ;  $  TAB1 return true ;  $  TAB1 k = integer ;  $  TAB1 input str, k ;  $  TAB1 len is an integer set to size of str ;  $  TAB1 if len isn't divisible by k ;  $  TAB2 output NO ;  $  TAB1 assign len / k to k ;  $  TAB1 assign 0 to i ;  $  TAB1 while i is less than len ;  $  TAB2 if not call check with i, i + k - 1 ;  $  TAB3 output NO ;  $  TAB2 add k to i ;  $  TAB1 output YES ;
TAB0 let mod = long long constant with value 100 ;  $  TAB0 declare long long function re taking in long longs a, n ;  $  TAB1 let ans = long long with value 1 ;  $  TAB1 while N > 0 is true do the following ;  $  TAB2 if n and 1 set ans = (ans * a) modulo mod ;  $  TAB2 set a = (a * a) modulo mod ;  $  TAB2 set n = n * 2 ;  $  TAB1 return ans ;  $  TAB1 let n = long long ;  $  TAB1 while read n is true print 25 ;
TAB1 let k, a, b, v be integers ;  $  TAB1 read k, a, b, v ;  $  TAB1 let cnt be integer with cnt = 0 ;  $  TAB1 while true ;  $  TAB2 increment cnt ;  $  TAB2 let box be integer with box = min of k-1, b ;  $  TAB2 set b to b-box ;  $  TAB2 let nuts be integer with nuts = (box+1) * v ;  $  TAB2 update a to a - nuts ;  $  TAB2 if a is less than or equal to 0, break ;  $  TAB1 print cnt ;
TAB1 FoundCard = integer ;  $  TAB1 MaxNum = integer ;  $  TAB1 numbers = integer ;  $  TAB1 sum = integer = 0 ;  $  TAB1 read FoundCard, MaxNum ;  $  TAB1 iterate FoundCard times ;  $  TAB2 read numbers ;  $  TAB2 add numbers to sum ;  $  TAB1 if sum is negative, multiply sum by -1 ;  $  TAB1 if sum is divisible by MaxNum ;  $  TAB2 divide sum by MaxNum ;  $  TAB1 else ;  $  TAB2 set sum to (sum / MaxNum) + 1 ;  $  TAB1 display sum ;
TAB0 define charToInt which takes char c1 as argument and returns int ;  $  TAB1 p1 = integer ;  $  TAB1 if int of c1 == 94 ;  $  TAB2 set p1 to 1 ;  $  TAB1 else if int of c1 == 62 ;  $  TAB2 p1 = 2 ;  $  TAB1 else if int of c1 == 118 ;  $  TAB2 update p1 to 3 ;  $  TAB1 else if int of c1 == 60 ;  $  TAB2 set p1 to 4 ;  $  TAB1 return p1 ;  $  TAB1 let c1, c2 be char ;  $  TAB1 read c1 ;  $  TAB1 read c2 ;  $  TAB1 let r be long long ;  $  TAB1 read r ;  $  TAB1 n = integer = r % 4 ;  $  TAB1 let p1, p2 be integers with p1 = charToInt of c1, p2 = charToInt of c2 ;  $  TAB1 let s1, s2 be integers with s1 = p1, s2 = p1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s1 < 4 ;  $  TAB3 increment s1 ;  $  TAB2 else ;  $  TAB3 set s1 to 1 ;  $  TAB2 if s2 > 1 ;  $  TAB3 decrement s2 ;  $  TAB2 else ;  $  TAB3 set s2 to 4 ;  $  TAB1 if s1 == p2 and s2 == p2 ;  $  TAB2 print undefined ;  $  TAB1 else if s1 == p2 ;  $  TAB2 print cw ;  $  TAB1 else ;  $  TAB2 print ccw ;
TAB0 in function ra with parameters integers x1, y1, x2, y2, x3, y3 and return boolean ;  $  TAB1 d1 is an integer set to (absolute value (x1 - x2)) * (absolute value (x1 - x2)) + (absolute value (y1 - y2)) * (absolute value (y1 - y2)) ;  $  TAB1 d2 is an integer set to (absolute value (x1 - x3)) * (absolute value (x1 - x3)) + (absolute value (y1 - y3)) * (absolute value (y1 - y3)) ;  $  TAB1 d3 is an integer set to (absolute value (x3 - x2)) * (absolute value (x3 - x2)) + (absolute value (y3 - y2)) * (absolute value (y3 - y2)) ;  $  TAB1 if d1, d2, and d3 are all equal to 0, return false ;  $  TAB1 if d1 + d2 equals d3 or d1 + d3 equals d2 or d2 + d3 equals d1, return true ;  $  TAB1 return false ;  $  TAB1 n, x1, x2, x3, y1, y2, y3 are integers ;  $  TAB1 read x1, y1, x2, y2, x3, y3 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display RIGHT ;  $  TAB1 increment x1 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 subtract 2 from x1 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 increment x1 ;  $  TAB1 increment y1 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 subtract 2 from y1 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 increment y1 ;  $  TAB1 increment x2 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 subtract 2 from x2 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 increment x2 ;  $  TAB1 increment y2 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 subtract 2 from y2 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 increment y2 ;  $  TAB1 increment x3 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 subtract 2 from x3 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 increment x3 ;  $  TAB1 increment y3 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 subtract 2 from y3 ;  $  TAB1 if call ra with x1, y1, x2, y2, x3, y3 ;  $  TAB2 display ALMOST ;  $  TAB1 display NEITHER ;
TAB1 let n, i, a, b, x, y be integers ;  $  TAB1 while input n ;  $  TAB2 assign 0 to x ;  $  TAB2 assign 0 to y ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read a, b ;  $  TAB3 if a is greater than b ;  $  TAB4 increment x ;  $  TAB3 else if a is less than b ;  $  TAB4 increment y ;  $  TAB2 if x is greater than y ;  $  TAB3 display Mishka ;  $  TAB2 else if x is less than y ;  $  TAB3 display Chris ;  $  TAB2 else ;  $  TAB3 display Friendship is magic!^^ ;
TAB1 create int array c of length 4 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create int a ;  $  TAB2 read a ;  $  TAB2 increment c[a] ;  $  TAB1 create int sum = c[1] + c[2] + c[3] ;  $  TAB1 create int ma = max of c[1], c[2], and c[3] ;  $  TAB1 print sum - ma ;
TAB1 f = integer vector ;  $  TAB1 s = integer vector ;  $  TAB1 h = integer vector ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 t = integer ;  $  TAB2 read t ;  $  TAB2 if t equals 1 ;  $  TAB3 append (i + 1) to f ;  $  TAB2 else if t equals 2 ;  $  TAB3 append (i + 1) to s ;  $  TAB2 else ;  $  TAB3 append (i + 1) to h ;  $  TAB1 r = integer = call min with size of f, call min with size of s, size of h ;  $  TAB1 print r ;  $  TAB1 for i = 0 to r exclusive, print f[i], " ", s[i], " ", h[i] ;
TAB1 n, d, i = long long ;  $  TAB1 read n, d ;  $  TAB1 let a be array of long long of size n and count, m be long long with count = 0, m = 10001 ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort of a, a+n ;  $  TAB1 let index1, j, index2 be long long ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set count to 0 ;  $  TAB2 for j = n-1 to till j is greater than i, decrement j ;  $  TAB3 if a[j] - a[i] is greater than d, increment count ;  $  TAB2 set m to min of count + i, m ;  $  TAB1 print m ;
TAB1 make long long T, S, q ;  $  TAB1 read T, S, and q ;  $  TAB1 make int ans = 0 ;  $  TAB1 while S less than T ;  $  TAB2 add 1 to ans ;  $  TAB2 assign S * q to S ;  $  TAB1 print ans ;
TAB0 maxn = constant integer = 100 ;  $  TAB0 INF = constant integer = 0x3f3f3f3f ;  $  TAB0 MOD = constant integer = 998244353 ;  $  TAB0 n = integer, a and b are integer arrays both of size 105, numa and numb are integer arrays both of size 6, ans = integer = 0 ;  $  TAB1 call memset with numa, 0, call sizeof with numa ;  $  TAB1 call memset with numb, 0, call sizeof with numb ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment numa[a[i]] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 increment numb[b[i]] ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if (numa[i] + numb[i]) mod 2 equals 1 ;  $  TAB3 set ans to -1 ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 add absolute value (numb[i] + numa[i]) / 2 - call min with numb[i], numa[i] to ans ;  $  TAB1 print -1 if ans equals -1, otherwise print ans / 2 ;
TAB0 N, A, B, val are doubles ;  $  TAB1 input N, A, and B ;  $  TAB1 assign N / (A + B) * A to val ;  $  TAB1 display val ;
TAB0 in function abs with parameters long integers x, y and return long integer ;  $  TAB1 if x is at least y ;  $  TAB2 return x - y ;  $  TAB1 else ;  $  TAB2 return y - x ;  $  TAB1 n, h, a, b, k, i, ta, fa, tb, fb, banyak are long integers ;  $  TAB1 read n, h, a, b, k ;  $  TAB1 for i = 0 to k exclusive ;  $  TAB2 set banyak to 0 ;  $  TAB2 read ta, fa, tb, fb ;  $  TAB2 if ta is tb ;  $  TAB3 display absolute value (fa, fb) ;  $  TAB2 else ;  $  TAB3 if fa is greater than b ;  $  TAB4 add fa - b to banyak ;  $  TAB4 add absolute value (b, fb) to banyak ;  $  TAB3 else if fa is less than a ;  $  TAB4 add a - fa to banyak ;  $  TAB4 add absolute value (a, fb) to banyak ;  $  TAB3 else ;  $  TAB4 add absolute value (fa, fb) to banyak ;  $  TAB3 add absolute value (ta, tb) to banyak ;  $  TAB3 display banyak ;
TAB0 create long long integer MOD = 1000000009 ;  $  TAB0 into the function pw which takes two long long integers a and b and returns a long long integer ;  $  TAB1 if b is 0 then return 1 ;  $  TAB1 if b is 1 then return a % MOD ;  $  TAB1 if b%2 is true ;  $  TAB2 create long long rs= pw(a,b-1) ;  $  TAB2 return (rs * a) % MOD ;  $  TAB1 create long long integer rs= pw(a,b/2) ;  $  TAB1 return (rs * rs) % MOD ;  $  TAB0 sm = long long integer vector ;  $  TAB0 into the function solve which takes a and b ;  $  TAB1 if b is 0 then return 0 ;  $  TAB1 for i=0 to 35 exclusive ;  $  TAB2 create long long integer ba = (1LL << i) & b ;  $  TAB2 if ba is equal to 0 then continue ;  $  TAB2 return sm[i] + solve(a, b - (1LL << i)) * pw(a, (1LL << i))) % MOD ;  $  TAB1 n,a,b,k = long long integers ;  $  TAB1 read n,a,b,k ;  $  TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 create long long integers X and Y with values 1 ;  $  TAB1 for i=o to k exclusive ;  $  TAB2 set X = X * b ;  $  TAB2 set X = X % MOD ;  $  TAB1 for i=0 to k exclusive ;  $  TAB2 set Y = Y * a ;  $  TAB2 set Y = Y % MOD ;  $  TAB1 set X = X * pw(Y, MOD - 2) ;  $  TAB1 set X = X % MOD ;  $  TAB1 add 1 to the end of sm ;  $  TAB1 for i=0 to 40 exclusive ;  $  TAB2 add sm.back() + sm.back() * pw(X, (1LL << i) to end of sm ;  $  TAB2 set sm.back() = sm.back() % MOD ;  $  TAB1 create long long integer st = solve(X, (n + 1) / k) ;  $  TAB1 create long long integer ans=0 ;  $  TAB1 for i=0 to k exclusive ;  $  TAB2 create long long integer rs = (pw(b, i) * pw(a, n - i)) % MOD ;  $  TAB2 if s[i] is '-' then set rs = rs * -1 ;  $  TAB2 set rs = rs * st ;  $  TAB2 set ans = ans + rs ;  $  TAB2 set ans = ans % MOD ;  $  TAB1 if ans is less than 0 then set ans = ans + MOD ;  $  TAB1 print ans ;
TAB1 create long long n, sum = 0 ;  $  TAB1 read n ;  $  TAB1 create int array arr size n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if i is greater than 0, add arr[i - 1] to arr[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] greater than arr[n - 1] / 2 AND arr[n - 1] modulo 2 == 0 ;  $  TAB3 return print i + 1, 0 ;  $  TAB2 else if arr[i] greater than arr[n - 1] / 2 ;  $  TAB3 return print i + 1, 0 ;
TAB1 i, j, k are integers ;  $  TAB1 s = character array of size 100010 ;  $  TAB1 while call gets with s ;  $  TAB2 len = integer = string length of s ;  $  TAB2 for i = 0 to len exclusive ;  $  TAB3 if s[i] isn't the character a, break ;  $  TAB2 for j = i to len exclusive ;  $  TAB3 if s[j] is the character a, break ;  $  TAB3 decrement s[j] ;  $  TAB2 if i equals len, set s[len - 1] to the character z ;  $  TAB2 display s ;
TAB1 create long longs x1, x2, y1, y2, n ;  $  TAB1 read x1, x2, y1, y2 ;  $  TAB1 read n ;  $  TAB1 create int t = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create long longs a, b, c ;  $  TAB2 read a, b, c ;  $  TAB2 if (a * x1 + b * y1 + c) GREATER THAN 0 AND (a * x2 + b * y2 + c) LESS THAN 0, increment t ;  $  TAB2 if (a * x1 + b * y1 + c) LESS THAN 0 AND (a * x2 + b * y2 + c) GREATER THAN 0, increment t ;  $  TAB1 print t ;
TAB0 n,a,b=integers ;  $  TAB0 create a boolean so with so=true ;  $  TAB1 read n,a ;  $  TAB1 res=array of boolean of size n ;  $  TAB1 for i=0 to n exclusive set res[i] = false ;  $  TAB1 for i=0 to a exclusive ;  $  TAB2 temp=integer ;  $  TAB2 read temp ;  $  TAB2 set res[temp - 1] = true ;  $  TAB1 read b ;  $  TAB1 for i=0 to b exclusive ;  $  TAB2 temp=integer ;  $  TAB2 read temp ;  $  TAB2 set res[temp - 1] = true ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if res[i] = false ;  $  TAB3 set so =false ;  $  TAB3 break ;  $  TAB1 if so is true ;  $  TAB2 print "I become the guy." ;  $  TAB1 else do the following ;  $  TAB2 print "Oh, my keyboard!" ;
TAB0 create boolean array full of size 101 ;  $  TAB1 n=integer ;  $  TAB1 x,y=integer ;  $  TAB1 read n,x,y ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 u,v=integer ;  $  TAB2 read u and v ;  $  TAB2 for i=u to v exclusive set full[i] to 1 ;  $  TAB1 create integer res=0 ;  $  TAB1 for i=x to y exclusive set res=res + !full[i] ;  $  TAB1 print res and new line ;
TAB1 let x, hour, minit = integer ;  $  TAB1 read x, hour, minit ;  $  TAB1 if hour is 0 set hour = 24 ;  $  TAB1 let cnt = integer with value 0 ;  $  TAB1 while 1 is true do the following ;  $  TAB2 if hour modulo 10 is 7 or minit modulo 10 is 7 exit the loop ;  $  TAB2 set minit = minit - x ;  $  TAB2 if minit is less than 0 do the following ;  $  TAB3 set hour - hour -1 ;  $  TAB3 set = 60 + minit ;  $  TAB2 if hour is less than or equal to 0 set hour = 24 ;  $  TAB2 increment cnt ;  $  TAB1 print cnt ;
TAB1 n,m,lmin,cmin,lmax,cmax= integers with lmin=cmin=lmax=cmax=0 ;  $  TAB1 create integers k=0 and x=0 ;  $  TAB1 read n and m ;  $  TAB1 s= string array of size 55 ;  $  TAB1 read n values into the string s ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive ;  $  TAB3 if s[i][j] is equal to * ;  $  TAB4 if k=0 or i<lmin then ;  $  TAB5 set lmit to i ;  $  TAB5 increment k ;  $  TAB3 if s[i][j] = * ;  $  TAB4 if i>=lmax then set lmax=i ;  $  TAB3 if s[i][j] is * ;  $  TAB4 if j<cmin or x=0 ;  $  TAB5 then set cmin=j ;  $  TAB5 add 1 to x ;  $  TAB3 if s[i][j] = * ;  $  TAB4 if j>=cman then set cman=j ;  $  TAB1 for i=lmin to lmax inclusive ;  $  TAB2 for j=cmin to cmax inclusive print s[i][j] ;  $  TAB2 print a new line ;
TAB0 c,d = char ;  $  TAB0 create long long integers n,x,y ;  $  TAB0 m = map from char to long long int ;  $  TAB0 M = map from long long int to char ;  $  TAB0 in the function solve ;  $  TAB1 read c, d and n ;  $  TAB1 if n%2 is equal to 0 ;  $  TAB2 print undefined and a new line ;  $  TAB2 return ;  $  TAB1 do nothing ;  $  TAB1 set x= n % 4 ;  $  TAB1 set y = (m[c] + x) % 4 ;  $  TAB1 if M[y] = d ;  $  TAB2 print cw and a new line ;  $  TAB2 return ;  $  TAB1 do nothing ;  $  TAB1 set y = (m[c] - x + 4) % 4 ;  $  TAB1 if M[y] is equal to d ;  $  TAB2 print ccw and a new line ;  $  TAB2 return ;  $  TAB1 do nothing ;  $  TAB2 print undefined ;  $  TAB2 return ;  $  TAB1 do nothing ;  $  TAB0 in the function prep ;  $  TAB1 set m['^'] = 0 and set m['>'] = 1 and set m['v'] = 2 and m['<'] = 3 ;  $  TAB1 M[0] = '^', M[1] = '>', M[2] = 'v', M[3] = '<' ;  $  TAB1 create integer t = 1 ;  $  TAB1 call prep function ;  $  TAB1 print fixed and setprecision(12) ;  $  TAB1 while t is true, decrement t call solve function ;
TAB1 make string str ;  $  TAB1 read str ;  $  TAB1 make int index = 0 ;  $  TAB1 make vector<char> v ;  $  TAB1 reserve 5 elements in v ;  $  TAB1 if str length greater than or equal to 5 ;  $  TAB2 for i = 0 to str length exclusive ;  $  TAB3 if str[i] is 'h' ;  $  TAB4 push 'h' onto v ;  $  TAB4 set index to i + 1 ;  $  TAB4 break ;  $  TAB2 for i = 0 to str length exclusive ;  $  TAB3 if str[i] is 'e' ;  $  TAB4 push 'e' onto v ;  $  TAB4 set index to i + 1 ;  $  TAB4 break ;  $  TAB2 make int cnt = 1 ;  $  TAB2 for i = 0 to str length exclusive ;  $  TAB3 if str[i] is 'l' ;  $  TAB4 push 'l' onto v ;  $  TAB4 increment cnt ;  $  TAB2 for i = 0 to str length exclusive ;  $  TAB3 if str[i] is 'o' ;  $  TAB4 push str[i] onto v ;  $  TAB4 break ;  $  TAB1 if v[0] is 'h' and v[1] is 'e' and v[2] is 'l' and v[3] is 'l' and v[4] is 'o' ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 let n be integer ;  $  TAB1 let soma be integer with soma=0 ;  $  TAB1 let a1,b1,a2,b2,a3,b3,n1,n2,n3 be integers ;  $  TAB1 read n,a1,b1,a2,b2,a3,b3 ;  $  TAB1 set soma=a1+a2+a3 ;  $  TAB1 set n1 to 0 ;  $  TAB1 set n2=0 ;  $  TAB1 set n3 to 0 ;  $  TAB1 if soma=n ;  $  TAB2 set n1=a1 ;  $  TAB2 assign a2 to n2 ;  $  TAB2 set n3 to a3 ;  $  TAB1 else if n-soma <= b1-a1 ;  $  TAB2 set n1 to a1+n-soma ;  $  TAB2 set n2 to a2 ;  $  TAB2 assign a3 to n3 ;  $  TAB1 else if n-soma is greater than b1-a1 ;  $  TAB2 set soma=b1+a2+a3 ;  $  TAB2 if n-soma<=b2-a2 ;  $  TAB3 set n1 to b1 ;  $  TAB3 n2= a2+n-soma ;  $  TAB3 n3=a3 ;  $  TAB2 else do the following ;  $  TAB3 soma = b1 + b2 + a3; ;  $  TAB3 set n1 = b1 ;  $  TAB3 n2 = b2 ;  $  TAB3 n3 = a3 + n - soma ;  $  TAB1 print n1,n2,n3 ;
TAB1 k and n are long longs ;  $  TAB1 read n and k ;  $  TAB1 if (n / k) is even ;  $  TAB2 display NO ;  $  TAB1 else ;  $  TAB2 display YES ;
TAB0 let s be a string ;  $  TAB0 let a and b be integers ;  $  TAB0 let len be an integer ;  $  TAB1 input s ;  $  TAB1 n is an integer set to length of s ;  $  TAB1 w is an integer array of size n + 10 ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 if s[i] is the character ( ;  $  TAB3 increment a ;  $  TAB2 else if s[i] is the character # ;  $  TAB3 assign 1 to w[len + 1] ;  $  TAB3 decrement a ;  $  TAB2 else if s[i] is the character ) ;  $  TAB3 decrement a ;  $  TAB2 if a is negative ;  $  TAB3 display -1 ;  $  TAB1 for i = length of s - 1 to 0 inclusive ;  $  TAB2 if s[i] is the character ) ;  $  TAB3 increment b ;  $  TAB2 else if s[i] is the character ( ;  $  TAB3 decrement b ;  $  TAB2 else if s[i] is the character # ;  $  TAB3 break ;  $  TAB2 if b is negative ;  $  TAB3 display -1 ;  $  TAB1 add a to w[len] ;  $  TAB1 for i = 1 to len inclusive, display w[i] ;
TAB0 in function isPalindrome returning bool, accepting string s ;  $  TAB1 define string sCopy = s ;  $  TAB1 reverse s ;  $  TAB1 if s equals sCopy ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB1 declare string s ;  $  TAB1 declare int k ;  $  TAB1 read s ;  $  TAB1 read k ;  $  TAB1 define int n = size of s ;  $  TAB1 define int check = 0 ;  $  TAB1 if n mod k equals 0 ;  $  TAB2 define int len = n / k ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 define string word = s.substr(i, len) ;  $  TAB3 if isPalindrome(word), increment check ;  $  TAB3 increase i by len - 1 ;  $  TAB2 if check equals k ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;  $  TAB1 print "NO" ;
TAB1 let ant, bnt, n be integers with ant = bnt = 0 and a, b be array of integers of size 110 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a[i] and b[i] ;  $  TAB2 if a[i] and bitwise and 1i, increment ant ;  $  TAB2 if b[i] and bitwise and 1, increment bnt ;  $  TAB1 if ant is even and bnt is even ;  $  TAB2 print out 0 ;  $  TAB1 else if ant + bnt is odd ;  $  TAB2 print out -1 ;  $  TAB1 else ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if a[i] bitwise and 1 and b[i] is even, print 1 and return 0 ;  $  TAB3 if b[i] bitwise and 1 and b[i] is even, print 1 and return 0 ;  $  TAB2 print out -1 with newline ;
TAB1 s and t are strings ;  $  TAB1 input s and t ;  $  TAB1 pos is an integer set to 0 ;  $  TAB1 for i = 0 to length of t exclusive ;  $  TAB2 if t[i] equals s[pos], increment pos ;  $  TAB1 display pos + 1 ;
TAB0 list1 and list2 are both integer arrays of size 1000010 each ;  $  TAB1 n, k, lastZero are integers with lastZero = -1 ;  $  TAB1 read n, k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read list1[i] ;  $  TAB2 if list1[i] equals 0, assign i to lastZero ;  $  TAB1 for i = 0 to k exclusive, read list2[i] ;  $  TAB1 if k is greater than 1 ;  $  TAB2 display Yes ;  $  TAB1 else ;  $  TAB2 set list1[lastZero] to list2[0] ;  $  TAB2 band is a boolean set to 0 ;  $  TAB2 for i = 1 to n exclusive ;  $  TAB3 if list1[i] is at most list1[i - 1] ;  $  TAB4 assign 1 to band ;  $  TAB4 break ;  $  TAB2 if band is true ;  $  TAB3 display Yes ;  $  TAB2 else ;  $  TAB3 display No ;
TAB0 let N, INF = integer constants with N = 60 and INF = 1000000007 ;  $  TAB0 let n, ans, d = integers ;  $  TAB1 read n ;  $  TAB1 let k, t = integers with k = n / 2 and t = -1 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to k exclusive print * ;  $  TAB2 for integer j=0 to n - k - k exclusive print D ;  $  TAB2 for integer j=0 to k exclusive print * ;  $  TAB2 print a new line ;  $  TAB2 if i is n / 2 set t = 1 ;  $  TAB2 set k = k +t ;
TAB0 create integer array points of 103 ;  $  TAB1 n,d = integers ;  $  TAB1 read n and d ;  $  TAB1 read n values into the array points ;  $  TAB1 create integer result = 101 ;  $  TAB1 sort points array ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create integer j = i ;  $  TAB2 while j<n ;  $  TAB3 if points[j] - points[i] > d then break ;  $  TAB3 set result to minimum of result and n-j-i+1 ;  $  TAB3 increment j ;  $  TAB1 print result and a new line ;
TAB1 make int n, m, i, j, c = 0, f = 0, ix = 0, jy = 0 ;  $  TAB1 read n and m ;  $  TAB1 create multidimensional character array a of size n + 1 by m + 1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 read a[i][j] ;  $  TAB3 if a[i][j] equals 'B' and f equals 0 and c equals 0 ;  $  TAB4 assign 1 to f ;  $  TAB4 assign 1 to c ;  $  TAB4 assign i to ix ;  $  TAB4 assign j to jy ;  $  TAB3 if f equals 1 and a[i][j] is equal to 'B', add 1 to c ;  $  TAB2 assign 0 to f ;  $  TAB1 print ix + c / 2, " ", jy + c / 2 ;
TAB0 maxn = constant integer set to 100000 ;  $  TAB0 a, b = arrays of integers with length of maxn, n, r, and ans = integers with r set to 1 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, print a[i] ;  $  TAB1 sort a + 1 and a + 1 + n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 while r <= n and a[r] <= a[i], increment r by 1 ;  $  TAB2 if r <= n, increment ans and r by 1 ;  $  TAB1 print ans ;
TAB0 k, a, b, v, cnt are integers ;  $  TAB1 read k, a, b, v, cnt ;  $  TAB1 while a is positive and b isn't 0 ;  $  TAB2 if b is less than k - 1 ;  $  TAB3 subtract (b + 1) * b from a ;  $  TAB3 set b to 0 ;  $  TAB2 else ;  $  TAB3 subtract k * v from a ;  $  TAB3 subtract k - 1 from b ;  $  TAB2 increment cnt ;  $  TAB1 while a is positive ;  $  TAB2 subtract v from a ;  $  TAB2 increment cnt ;  $  TAB1 output cnt ;
TAB1 let x be integer ;  $  TAB1 read x ;  $  TAB1 if x == 1 ;  $  TAB2 call puts of "-1" ;  $  TAB1 else ;  $  TAB2 print x, " ", x ;
TAB1 let n be an integer ;  $  TAB1 read n ;  $  TAB1 v is an integer vector of size n, 0 ;  $  TAB1 set v[0] to -1 ;  $  TAB1 for i = 1 to n inclusive, read v[i] ;  $  TAB1 min, min_index, and sum are all integers with min_index and sum both set to 0 and min set to 0x7fffffff ;  $  TAB1 for x = 1 to n inclusive ;  $  TAB2 set sum to 0 ;  $  TAB2 for i = 1 to n inclusive, add 2 * v[i] * (absolute value (i - x) + i - 1 + x - 1) to sum ;  $  TAB2 if sum is less than min ;  $  TAB3 set min to sum ;  $  TAB3 set min_index to x ;  $  TAB1 display min ;
TAB0 let pi = double constant with value = acos(-1) ;  $  TAB0 let MODPRIMA = long long constant with value cast to long long = 1000000007 ;  $  TAB0 let MAXX = long long constant with value cast to long long = 1000000000000000000 ;  $  TAB0 let MINN = long long constant with value cast to long long = -1000000000000000000 ;  $  TAB0 let EPS = double constant with value = 1000000000 ;  $  TAB0 let N, feet, inch = integers ;  $  TAB1 read N ;  $  TAB1 set feet = N / 36 ;  $  TAB1 set N = N - 36 * feet ;  $  TAB1 set inch = N / 3 ;  $  TAB1 if N modulo 3 is 2 increment inch ;  $  TAB1 if inch is greater than 12 do the following ;  $  TAB2 increment feet ;  $  TAB2 set inch = inch -12 ;  $  TAB1 print feet and a space and inch ;
TAB1 create int a ;  $  TAB1 read a ;  $  TAB1 if a mod 2 is equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make integer res = 0 ;  $  TAB1 for i = 0 to 4 exlcusive ;  $  TAB2 for j = 1 to 13 inclusive ;  $  TAB3 if i is 0 and j is 12 then continue ;  $  TAB3 if j is 1 ;  $  TAB4 if 11 + 10 is n then increment res ;  $  TAB3 if min of j and 10 + 10 is n then increment res ;  $  TAB1 print res ;
TAB1 cin.exceptions(cin.failbit) ;  $  TAB1 create int n, a, b, c, count = 0 ;  $  TAB1 read n ;  $  TAB1 while n decremented ;  $  TAB2 read a, b, and c ;  $  TAB2 if a + b + c is greater than or equal to 2 then add 1 to count ;  $  TAB1 print count ;
TAB1 n is a float ;  $  TAB1 input n ;  $  TAB1 l is a float with l = n / 5.0 ;  $  TAB1 if l - integer value of l is equal to 0 ;  $  TAB2 display l ;  $  TAB1 display integer value of l + 1 ;
TAB1 declare int n, points ;  $  TAB1 read n, points ;  $  TAB1 define int min = points, max = points, amazing = 0 ;  $  TAB1 while decrement n ;  $  TAB2 read points ;  $  TAB2 if points is less than min ;  $  TAB3 set min to points ;  $  TAB3 increment amazing ;  $  TAB2 if points is greater than max ;  $  TAB3 set max to points ;  $  TAB3 increment amazing ;  $  TAB1 print amazing ;
TAB1 let n, a, b, sum, num be integers with sum = num = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a, b ;  $  TAB2 if a is greater than b, increment sum ;  $  TAB2 if b is greater than a, increment num ;  $  TAB1 if sum is greater than num, print Mishka ;  $  TAB1 if sum is equal to num, print Friendship is magic!^^ ;  $  TAB1 if sum is less than num, print Chris ;
TAB0 create string array s initialized with {"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "B", "H"} ;  $  TAB0 create multidimensional integer array d of size 20 x 20 ;  $  TAB0 create map mp of string to int ;  $  TAB0 in function check with return type int and parameters int x, int y, int z ;  $  TAB1 if d[x][y] is 4 and d[y][z] is 3 then return 1 ;  $  TAB1 if d[x][y] is 3 and d[y][z] is 4 then return 2 ;  $  TAB1 return 3 ;  $  TAB1 for i = 0 to 12 exclusive ;  $  TAB2 for j = 0 to 12 exclusive ;  $  TAB3 if j greater than or equal to i ;  $  TAB4 set d[i][j] to j - i ;  $  TAB3 else ;  $  TAB4 set d[i][j] to j + 12 - i ;  $  TAB1 for i = 0 to 12 exclusive do insert pair<string, int>(s[i], i) into mp ;  $  TAB1 create strings X, Y, Z ;  $  TAB1 create ints a, b, c ;  $  TAB1 read X, Y, Z ;  $  TAB1 set a to mp[X] ;  $  TAB1 set b to mp[Y] ;  $  TAB1 set c to mp[Z] ;  $  TAB1 if check(a, b, c) is 1 ;  $  TAB2 print "major" ;  $  TAB1 if check(a, b, c) is 2 ;  $  TAB2 print "minor" ;  $  TAB1 if check(a, c, b) is 1 ;  $  TAB2 print "major" ;  $  TAB1 if check(a, c, b) is 2 ;  $  TAB2 print "minor" ;  $  TAB1 if check(b, a, c) is 1 ;  $  TAB2 print "major" ;  $  TAB1 if check(b, a, c) is 2 ;  $  TAB2 print "minor" ;  $  TAB1 if check(b, c, a) is 1 ;  $  TAB2 print "major" ;  $  TAB1 if check(b, c, a) is 2 ;  $  TAB2 print "minor" ;  $  TAB1 if check(c, a, b) is 1 ;  $  TAB2 print "major" ;  $  TAB1 if check(c, a, b) is 2 ;  $  TAB2 print "minor" ;  $  TAB1 if check(c, b, a) is 1 ;  $  TAB2 print "major" ;  $  TAB1 if check(c, b, a) is 2 ;  $  TAB2 print "minor" ;  $  TAB1 print "strange" ;
TAB0 let adj be integer vector of size 101 ;  $  TAB0 let dis be int with dis=0 ;  $  TAB0 create boolean array vis of size 101 ;  $  TAB0 let n be int ;  $  TAB0 in the function gcd which takes two integers a and b and returns an integer ;  $  TAB1 if b=0 ;  $  TAB2 then return a ;  $  TAB1 else do the following ;  $  TAB2 call gcd on b and a mod b ;  $  TAB0 in the function lcm which takes two integers a and b and returns an integer ;  $  TAB1 return (a * b) / gcd(a, b) ;  $  TAB0 create integer vector ans ;  $  TAB0 in the function dfs which takes a integer ;  $  TAB1 set vis[start] to true ;  $  TAB1 create integer size = size of adj[start] ;  $  TAB1 increment dis ;  $  TAB1 for i=0 to size inclusive ;  $  TAB2 create int v=adj[start][i] ;  $  TAB2 if vis[v] is false then call dfs on v ;  $  TAB0 let masuk be an integer array of size 101 ;  $  TAB0 in the function lakukan ;  $  TAB1 set dis=0 ;  $  TAB1 for int i=1 to n inclusive ;  $  TAB2 if vis[i] is false ;  $  TAB3 set dis to 0 ;  $  TAB3 call dfs on i ;  $  TAB3 Add dis to the end of ans ;  $  TAB1 create integer size= ans.size -1 ;  $  TAB1 for i=0 to size inclusive ;  $  TAB2 if ans[i]%2 is 0 then set ans[i] to ans[i]/2 ;  $  TAB1 create integer hasil=1 ;  $  TAB1 for i=0 to size inclusive set hasil=lcm of hasil and ans[i] ;  $  TAB1 print hasil ;  $  TAB1 read n ;  $  TAB1 set all content of masuk to 0 ;  $  TAB1 set all content of vis to false ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 x=integer ;  $  TAB2 read x ;  $  TAB2 increment masuk[x] ;  $  TAB2 add x to end of adj[i] ;  $  TAB1 create boolean bisa=true ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if masuk[i] is not 1 then set bisa=false ;  $  TAB1 if bisa = false ;  $  TAB2 then print -1 and new line ;  $  TAB1 else do the following ;  $  TAB2 call lakukan ;
TAB1 n, arr, s, t, min, min2 are integers with arr = array of size 100, min = 0, min2 = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 read s, t ;  $  TAB1 if s is greater than t ;  $  TAB2 declare an integer temp ;  $  TAB2 set temp to s ;  $  TAB2 set s to t ;  $  TAB2 set t to temp ;  $  TAB1 for i = 0 to t - s exclusive, add arr[s + i - 1] to min ;  $  TAB1 for i = 0 to n - t inclusive, add arr[t + i - 1] to min2 ;  $  TAB1 for i = 0 to s - 1 exclusive, add arr[i] to min2 ;  $  TAB1 if min is less than min2 ;  $  TAB2 display min ;  $  TAB1 else ;  $  TAB2 display min2 ;
TAB1 let n,c,m be ints with c=1 and m=0 ;  $  TAB1 read n ;  $  TAB1 arr= array of integer of size n ;  $  TAB1 read arr[0] ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] > arr[i-1] ;  $  TAB3 add 1 to c ;  $  TAB2 else do the following ;  $  TAB3 if m<c then assign c to m ;  $  TAB3 set c=1 ;  $  TAB1 print maximum of m and c ;
TAB1 k, i = long long integers ;  $  TAB1 read k ;  $  TAB1 A = array of long long integers length 12 ;  $  TAB1 for i = 0 to 12 exclusive, read A[i] ;  $  TAB1 if k is 0 ;  $  TAB2 print 0 ;  $  TAB2 exit of 0 ;  $  TAB1 sort A, A + 12, and greater function ;  $  TAB1 sum = long long integer set to 0 ;  $  TAB1 for i = 0 to 12 exclusive ;  $  TAB2 set sum to sum + A[i] ;  $  TAB2 if sum >= k, break ;  $  TAB1 if i is 12 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print i + 1 ;
TAB0 declare boolean ok ;  $  TAB1 declare integer n, m, i, arrays a and b both with lengths of 10 ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to m exclusive, read b[i] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if a[i] is equal to b[j] ;  $  TAB4 if ok, print " " ;  $  TAB4 print a[i] ;  $  TAB4 if ok equals false, assign true to ok ;  $  TAB1 print newline ;
TAB1 let n be a long long ;  $  TAB1 input n ;  $  TAB1 let c be a long long with c = 0 ;  $  TAB1 add n / 100 to c ;  $  TAB1 set n to n modulo 100 ;  $  TAB1 add n / 20 to c ;  $  TAB1 set n to n modulo 20 ;  $  TAB1 add n / 10 to c ;  $  TAB1 set n to n modulo 10 ;  $  TAB1 add n / 5 to c ;  $  TAB1 set n to n modulo 5 ;  $  TAB1 add n to c ;  $  TAB1 display c ;
TAB1 n, c = integers ;  $  TAB1 s = string ;  $  TAB1 read n and s ;  $  TAB1 o, z = integers ;  $  TAB1 set o and z to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if index i of s is '1' ;  $  TAB3 increment o by 1 ;  $  TAB2 else ;  $  TAB3 increment z by 1 ;  $  TAB1 print n - 2 * min of o and z ;
TAB0 N = constant long long integer = 107 ;  $  TAB0 a, b are long long integer arrays both of size N, ax, bx, cnt are long long integer arrays all of size 7 ;  $  TAB1 n, m, i, j, u, v, ansx, ans are long long integers with ansx = 1, ans = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive, read a[i], increment ax[a[i]] ;  $  TAB1 for i = 1 to n inclusive, read b[i], increment bx[b[i]] ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if (ax[i] + bx[i]) mod 2 is 1 ;  $  TAB3 set ansx to 0 ;  $  TAB2 else ;  $  TAB3 set cnt[i] to (ax[i] + bx[i]) / 2 ;  $  TAB1 if not ansx ;  $  TAB2 display -1 ;  $  TAB1 for i = 1 to 5 inclusive, add absolute value (cnt[i] - ax[i]) to ans ;  $  TAB1 display ans / 2 ;
TAB1 create string s = "hello" ;  $  TAB1 create string t ;  $  TAB1 read t ;  $  TAB1 create int l, i, j, a = 0, b = 0 ;  $  TAB1 l = size of t ;  $  TAB1 for i = 0 to l exlcusive ;  $  TAB2 if t[i] equals s[a] ;  $  TAB3 increment a ;  $  TAB3 increment b ;  $  TAB1 if b equals 5 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 declare integer n ;  $  TAB1 read n ;  $  TAB1 let integer count = 0 ;  $  TAB1 while n > 1 ;  $  TAB2 if n & 1 then increment count ;  $  TAB2 n = n / 2 ;  $  TAB1 print count + 1 ;
TAB0 M is a constant integer set to 50 + 5 ;  $  TAB1 a, b, c are integers ;  $  TAB1 read a, b, c ;  $  TAB1 t1 is an integer set to c * a - c * b ;  $  TAB1 t is an integer set to t1 / b + (t1 mod b isn't 0) ;  $  TAB1 display t ;
TAB1 n, x are integers ;  $  TAB1 read n, x ;  $  TAB1 cnt = integer = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if x is divisible by i and x / i is at most n ;  $  TAB1 display cnt ;
TAB0 create int n, f array of length 601, x, s = 0 ;  $  TAB1 read n ;  $  TAB1 set elements of f to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 if x != 0 and f[x] == 0 ;  $  TAB3 set f[x] to 1 ;  $  TAB3 increment s ;  $  TAB1 print s ;
TAB0 let n = integer ;  $  TAB0 let a = array of integers size 3 ;  $  TAB0 let N = integer constant with value 1000005 ;  $  TAB1 let x = integer ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read x ;  $  TAB2 increment a[x] ;  $  TAB1 let m = integer with value = 0 ;  $  TAB1 for j=1 to 3 inclusive set m = max of m and a[j] ;  $  TAB1 print n-m ;
TAB1 a, b, c, d, i, j, k, n, t = integers ;  $  TAB1 ch = 2d array of characters, dimentions 105x105 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive, read ch[i][j] ;  $  TAB1 set i = 0 ;  $  TAB1 for j = 0 to n + 1 inclusive, set ch[i][j] to 'a' ;  $  TAB1 set i to n + 1 ;  $  TAB1 for j = 0 to n + 1 inclusive, set ch[i][j] to 'a' ;  $  TAB1 set i to 0 ;  $  TAB1 for j = 0 to n + 1 inclusive, set ch[j][i] to 'a' ;  $  TAB1 set i to n + 1 ;  $  TAB1 for j = 0 to n + 1 inclusive, set ch[j][i] to 'a' ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 set t to 0 ;  $  TAB3 if ch[i][j + 1] is 'o', add 1 to t ;  $  TAB3 if ch[i][j - 1] is 'o' add 1 to t ;  $  TAB3 if ch[i + 1][j] is 'o' add 1 to t ;  $  TAB3 if ch[i - 1][j] is 'o' add 1 to t ;  $  TAB3 if t modulo 2 isn't 0 ;  $  TAB4 print "NO" ;  $  TAB1 print "YES" ;  $  TAB1 for i = 0 to n + 1 inclusive ;  $  TAB2 for j = 0 to n + 1 inclusive, print ch[i][j] ;  $  TAB2 endline ;  $  TAB1 print "YES" ;
TAB1 let y, n, x, i, dis, sum = long long integers with dis = 0 and sum = 0 ;  $  TAB1 read n, x ;  $  TAB1 set sum = x ;  $  TAB1 let c = character ;  $  TAB1 while(decrement n) is true do the following ;  $  TAB2 read c, y ;  $  TAB2 if c is - do the following ;  $  TAB3 if sum is greater than or equal to y ;  $  TAB4 set sum = sum - y ;  $  TAB3 else ;  $  TAB4 increment dis ;  $  TAB2 else if c is + ;  $  TAB3 set sum = sum + y ;  $  TAB1 print sum and a space and dis ;
TAB1 create int a, b, c = 0 ;  $  TAB1 read a and b ;  $  TAB1 while b ;  $  TAB2 create int d = b mod 10 ;  $  TAB2 set c to c * 10 + d ;  $  TAB2 set b to b / 10 ;  $  TAB1 print a + c ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 let x, y = integer arrays of size n and a, b = integers = 0 ;  $  TAB1 let sw = boolean and set sw to true ;  $  TAB1 fori = 0 to n*2 exclusive do the following ;  $  TAB2 if sw is true do the following ;  $  TAB3 read x[a] ;  $  TAB3 increment a ;  $  TAB3 set sw to false ;  $  TAB2 else do the following ;  $  TAB3 read y[b] ;  $  TAB3 increment b ;  $  TAB3 set sw to true ;  $  TAB1 let cont = integer and set cont to 0 ;  $  TAB1 for i = 0 to n exclusive do the following ;  $  TAB2 upper, lower, right, left = boolean and upper=lower=right=left=false ;  $  TAB2 for j = 0 to n exclusive do the following ;  $  TAB3 if x is not equal to j do the following ;  $  TAB4 if x[i] is less than x[j] and y[i] is y[j], right = true ;  $  TAB4 if x[i] is greater than x[j] and y[i] is y[j], left = true ;  $  TAB4 if x[i] is x[j] and y[i] is greater than y[j], lower = true ;  $  TAB4 if x[i] is x[j] and y[i] is less than y[j], upper = true ;  $  TAB2 if upper and lower and right and left, increment cont ;  $  TAB1 print cont ;
TAB1 n = integer ;  $  TAB1 s = string ;  $  TAB1 input n, s ;  $  TAB1 one and zero are both integers both set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is the character 0 ;  $  TAB3 increment zero ;  $  TAB2 else ;  $  TAB3 increment one ;  $  TAB1 if one isn't 0, display 1 ;  $  TAB1 for i = 0 to zero exclusive, display 0 ;  $  TAB1 display newline ;
TAB1 rnum, cnt0, cnt1 are integers all set to 0 ;  $  TAB1 input rnum ;  $  TAB1 pro = integer array of sizes rnum and 3, sum = integer array of size rnum ;  $  TAB1 for i = 0 to rnum exclusive ;  $  TAB2 set cnt1 to cnt0 to 0 ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 read pro[i][j] ;  $  TAB3 if pro[i][j] equals 1 ;  $  TAB4 increment cnt1 ;  $  TAB3 else ;  $  TAB4 increment cnt0 ;  $  TAB2 if cnt1 is greater than cnt0 ;  $  TAB3 set sum[i] to 1 ;  $  TAB2 else ;  $  TAB3 set sum[i] to 0 ;  $  TAB1 set cnt1 to cnt0 to 0 ;  $  TAB1 for i = 0 to rnum exclusive ;  $  TAB2 if sum[i] equals 1, increment cnt1 ;  $  TAB1 print cnt1 ;
TAB1 declare int y ;  $  TAB1 read y ;  $  TAB1 while true ;  $  TAB2 increase y by 1 ;  $  TAB2 define int a = y / 1000 ;  $  TAB2 define int b = y / 100 mod 10 ;  $  TAB2 define int c = y / 10 mod 10 ;  $  TAB2 define int d = y mod 10 ;  $  TAB2 if a not equal to b and a not equal to c and a not equal to d and b not equal to c and b not equal to d and c not equal to d, break ;  $  TAB1 print y ;
TAB0 s = string ;  $  TAB0 declare pd which returns an integer ;  $  TAB1 if length of s < 5, return 0 ;  $  TAB1 x, y, z = integers set to 0 ;  $  TAB1 for i = 0 to length of s ;  $  TAB2 if s[i] <= 'Z' and s[i] >= 'A', set x to 1 ;  $  TAB2 if s[i] <= 'z' and s[i] >= 'a', set y to 1 ;  $  TAB2 if s[i] <= '9' and s[i] >= '0', set z to 1 ;  $  TAB1 return x, y and z ;  $  TAB1 read s ;  $  TAB1 if pd returns true ;  $  TAB2 print "Correct" ;  $  TAB1 else ;  $  TAB2 print "Too weak" ;
TAB0 declare function File ;  $  TAB1 call freopen on output.txt and w and stdout ;  $  TAB1 call freopen on input.txt and r and stdin ;  $  TAB0 declare function fast ;  $  TAB0 let pi = double constant with value = 2 * acos(0.0) ;  $  TAB0 let nn = integer constant with value = 10005 ;  $  TAB0 let oo = integer constant with value = hexadecimal 3f3f3f3f ;  $  TAB1 call fast ;  $  TAB1 let n, m, k, ans = integers with ans = 0 ;  $  TAB1 rea dn, m, k ;  $  TAB1 let arr = array of integers with size n ;  $  TAB1 read n values into array arr ;  $  TAB1 call sort on arr and arr + n ;  $  TAB1 for integer i=n-1 to 0 and k less than m inclusive descending do the following ;  $  TAB2 set k = k + arr[i] ;  $  TAB2 decrement k ;  $  TAB2 increment ans ;  $  TAB1 if k is less than m ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB1 make character array s1 and s2, both of size 10 ;  $  TAB1 make integers a and b ;  $  TAB1 read s1 and s2 ;  $  TAB1 if s1[0] is equal to 'm', set a to 1 ;  $  TAB1 if s1[0] is equal to 't' and s1[1] is equal to 'u', set a to 2 ;  $  TAB1 if s1[0] is equal to 'w', set a to 3 ;  $  TAB1 if s1[0] is equal to 't' AND s1[1] is equal to 'h', assign 4 to a ;  $  TAB1 if s1[0] is equal to 'f', assign 5 to a ;  $  TAB1 if s1[0] is equal to 's' and s1[1] is equal to 'a', set a to 6 ;  $  TAB1 if s1[0] is equal to 's' and s1[1] is equal to 'u', set a to 7 ;  $  TAB1 if s1[0] is equal to 'm', assign 1 to b ;  $  TAB1 if s2[0] is equal to 't' and s2[1] is equal to 'u', set b to 2 ;  $  TAB1 if s2[0] is equal to 'w', assign 3 to b ;  $  TAB1 if s2[0] is equal to 't' and s2[1] is equal to 'h', set b to 4 ;  $  TAB1 if s2[0] is equal to 'f', set b to 5 ;  $  TAB1 if s2[0] is equal to 's' and s2[1] is equal to 'a', set b to 6 ;  $  TAB1 if s2[0] is equal to 's' and s2[1] is equal to 'u', set b to 7 ;  $  TAB1 if a greater than b, increase b by 7 ;  $  TAB1 make integer flag = 0 ;  $  TAB1 if (b - a) is equal to 2 OR (b - a) is equal to 3 OR a is equal to b, set flag to 1 ;  $  TAB1 if flag is equal to 1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 create set of ints amulets ;  $  TAB0 create set of ints taken ;  $  TAB1 create int N ;  $  TAB1 read N ;  $  TAB1 for i = 0 to N exclusive ;  $  TAB2 if i is greater than 0 ;  $  TAB3 create string starstar ;  $  TAB3 read starstar ;  $  TAB2 create int A, B ;  $  TAB2 read A and B ;  $  TAB2 create int num = A * 100 + B mod 10 * 10 + B / 10 ;  $  TAB2 if not taken.count(num) ;  $  TAB3 insert num into amulets ;  $  TAB3 for j = 0 to 4 exclusive ;  $  TAB4 insert num into taken ;  $  TAB4 set num to (num / 1000) + (num * 10 mod 10000) ;  $  TAB1 print amulets size ;
TAB0 n, a, b are integers ;  $  TAB0 s is a string ;  $  TAB1 read n, a, b, s ;  $  TAB1 if s[b - 1] is equal to s[a - 1] ;  $  TAB2 display 0 ;  $  TAB1 else ;  $  TAB2 display 1 ;
TAB0 let s80 be string ;  $  TAB0 let s be array of strings of size 10 ;  $  TAB0 define cp which takes string s, integer l and r as arguments and returns string ;  $  TAB1 let res be string with res = "" ;  $  TAB1 for i = 1 to r exclusive, update res to res + s[i] ;  $  TAB1 return res ;  $  TAB1 read s80 ;  $  TAB1 for i = 0 to i exclusive, read s[i] ;  $  TAB1 for i = 0 to till i+10 is less than or equal to length of s80, increment i by 10 ;  $  TAB2 for j = 0 to 10 exclusive ;  $  TAB3 if cp of s80, i, i+10 is equal to s[j] ;  $  TAB4 print j ;  $  TAB4 break ;  $  TAB1 print newline ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let index be an integer set to 0 ;  $  TAB1 let arr be an integer vector ;  $  TAB1 let x be an integer ;  $  TAB1 input x ;  $  TAB1 append x to arr ;  $  TAB1 assign 0 to index ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 input x ;  $  TAB2 append x to arr ;  $  TAB2 if arr[index] is at least arr[i], assign i to index ;  $  TAB1 let val be an integer set to arr[index] ;  $  TAB1 let count be an integer set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] equals val, increment count ;  $  TAB1 if count equals 1 ;  $  TAB2 output index + 1 ;  $  TAB1 else ;  $  TAB2 output Still Rodzil ;
TAB1 v = long long integer ;  $  TAB1 read v ;  $  TAB1 if v is less than or equal to 2 ;  $  TAB2 print v and a new line ;  $  TAB1 else do the following ;  $  TAB2 print 1 and a new line ;
TAB1 x, count = integers set to 0 ;  $  TAB1 read x ;  $  TAB1 multiply x by 2 ;  $  TAB1 while x is divisible by 2, add x modulo 2 to count ;  $  TAB1 print count ;
TAB1 create integer n,i, temp, cnt, res with cnt=-1 and res=0 ;  $  TAB1 a= int vector ;  $  TAB1 read n ;  $  TAB1 add 0 to the end of a ;  $  TAB1 add 0 to the end of a ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read temp ;  $  TAB2 add temp to the end of a ;  $  TAB1 add 1001 to end of a ;  $  TAB1 for i=2 to n+2 inclusive ;  $  TAB2 if a[i] is equal to a[i-1] +1 ;  $  TAB3 add 1 to cnt ;  $  TAB2 else do the following ;  $  TAB3 if cnt>res then set res=cnt ;  $  TAB3 set cnt=-1 ;  $  TAB1 if cnt>res then set res=cnt ;  $  TAB1 print res and new line ;
TAB1 let s be a string ;  $  TAB1 input s ;  $  TAB1 sz is an integer set to size of s ;  $  TAB1 display (sz + 1) * 25 + 1 ;
TAB1 k, a, b, v, i are integers ;  $  TAB1 read k, a, b, v ;  $  TAB1 for i = 1 as long as a is positive with increment i ;  $  TAB2 if b equals 0 ;  $  TAB3 subtract v from a ;  $  TAB3 continue ;  $  TAB2 if k is greater than b + 1 ;  $  TAB3 subtract v * (b + 1) from a ;  $  TAB3 set b to 0 ;  $  TAB3 continue ;  $  TAB2 subtract k * v from a ;  $  TAB2 subtract k - 1 from b ;  $  TAB1 subtract 1 from i ;  $  TAB1 display i ;
TAB1 capacity, a, b, passenger are integers with capacity = 0 and passenger = 0 ;  $  TAB1 stop is an integer ;  $  TAB1 read stop ;  $  TAB1 while decrement stop ;  $  TAB2 read a and b ;  $  TAB2 add (b - a) to passenger ;  $  TAB2 if capacity is less than passenger, assign passenger to capacity ;  $  TAB1 display capacity ;
TAB1 p1, p2, p3, p4, a, b are integers ;  $  TAB1 read p1, p2, p3, p4, a, b ;  $  TAB1 num is an integer set to 0 ;  $  TAB1 for i = a to b inclusive ;  $  TAB2 if i mod p1 mod p2 mod p3 mod p4 equals i, increment num ;  $  TAB1 display num ;
TAB0 declare string function restorePass taking in string binaryCode and string array binaryChar ;  $  TAB1 let binaryCode = string and binaryChar = array of strings size [10] ;  $  TAB1 read string binaryCode ;  $  TAB1 read 10 strings into binaryChar ;  $  TAB1 print call restorePass on binaryCode and binaryChar ;  $  TAB0 declare string function restorePass taking in string binaryCode and string array binaryChar ;  $  TAB1 let binaryResult = string with value = null ;  $  TAB1 for integer i=0 to length of binaryCode exclusive increment step 10 do the following ;  $  TAB2 let sub = string with value = substring from binaryCode[i] to binaryCode[i+ 10] ;  $  TAB2 for integer j=0 to 10 exclusive do the following ;  $  TAB3 if binaryChar[j] is sub do the following ;  $  TAB4 let ss = stringstream ;  $  TAB4 read j into ss ;  $  TAB4 set binaryResult = binaryResult + str of ss ;  $  TAB1 return binaryResult ;
TAB0 arr = integer array of length 101 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 x = integer ;  $  TAB2 read x ;  $  TAB2 increment arr[x] ;  $  TAB1 mx = integer = 0 ;  $  TAB1 for i = 1 to 101 exclusive, set mx to call max with mx, arr[i] ;  $  TAB1 print mx ;
TAB1 set flag = boolean ;  $  TAB1 set n,i = integers ;  $  TAB1 set str = string ;  $  TAB1 set a = array of integers size 5, b = array of integers size 100005 ;  $  TAB1 set ans = integer ;  $  TAB1 set sizeof(a) bytes starting at a to 0 ;  $  TAB1 read str ;  $  TAB1 n = length of str ;  $  TAB1 set flag to false ;  $  TAB1 for i = 0 to n exclusive, do the following ;  $  TAB2 if str[i] is # do the following ;  $  TAB3 increment a[1] ;  $  TAB3 if a[3]+a[1] is greater than a[2] or i is 0 set flag = true ;  $  TAB3 set and = a[2]-a[3]+1 ;  $  TAB2 else if str[i] is ( do the following ;  $  TAB3 increment a[2] ;  $  TAB3 if i is n-1 or a[3]+a[1] is greater than a[2], set flag = true ;  $  TAB2 else do the following ;  $  TAB3 increment a[3] ;  $  TAB3 if a[3]+a[1] is greater than a[2] or i is 0 set flag = true ;  $  TAB1 if ans is greater than a[2]-a[3]+1 set flag =true ;  $  TAB1 if flag is true ;  $  TAB2 print -1 ;  $  TAB1 for i=1 to a[1] exclusive print 1 ;  $  TAB1 print a[2]-a[3]-a[1]+1 ;
TAB1 n,m=integer ;  $  TAB1 read n and m ;  $  TAB1 create an array of ints nums of size m ;  $  TAB1 read m values into array nums ;  $  TAB1 sort nums array ;  $  TAB1 create new int min=INT_MAX ;  $  TAB1 decrement n ;  $  TAB1 for i=0 to m-n exclusive ;  $  TAB2 if nums[i + n] - nums[i] < min then set min = nums[i + n] - nums[i] ;  $  TAB1 print min and new line ;
TAB0 a = string array of size 10 ;  $  TAB0 book= boolean array of size 10 ;  $  TAB0 c= map from string to int ;  $  TAB0 into the function Init ;  $  TAB1 set a[1] = Power ;  $  TAB1 set a[2] = Time ;  $  TAB1 set a[3] = Space ;  $  TAB1 set a[4] = Soul ;  $  TAB1 set a[5] = Reality ;  $  TAB1 assign Mind to a[6] ;  $  TAB1 set c["purple"] =1 ;  $  TAB1 set c["green"] = ;  $  TAB1 set c["blue"] = 3 ;  $  TAB1 set c["orange"] = 4 ;  $  TAB1 set c["red"] = 5 ;  $  TAB1 set c["yellow"] = 6 ;  $  TAB1 call Init function ;  $  TAB1 set all values of book to 0 ;  $  TAB1 n= integer ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 temp= string ;  $  TAB2 read temp ;  $  TAB2 set book[c[temp]] = true ;  $  TAB1 print 6-n ;  $  TAB1 for i=1 to 6 inclusive ;  $  TAB2 if book[i] is false then print a[i] ;
TAB0 create function fast_io ;  $  TAB0 INF = constant integer = integer value of 2e9 ;  $  TAB0 EPS = constant double = double value of 1e-9 ;  $  TAB0 PI = constant double = double value of arccosine of -1 ;  $  TAB0 MOD = constant long long = long long value of 1e9 + 7 ;  $  TAB0 N = constant integer = 1e5 + 5 ;  $  TAB1 n, m, a, b are integers ;  $  TAB1 s = string ;  $  TAB1 read n, m ;  $  TAB1 read s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is the character G, set a to i ;  $  TAB2 if s[i] is the character T, set b to i ;  $  TAB1 if b is greater than a and (b - a) mod m equals 0 ;  $  TAB2 for i = a as long as i is at most b with increment i + m ;  $  TAB3 if s[i] is the character # ;  $  TAB4 print NO ;  $  TAB4 break ;  $  TAB3 if i equals b, print YES ;  $  TAB1 else if a is greater than b and (a - b) mod m equals 0 ;  $  TAB2 for i = a as long as i is at least b with increment i - m ;  $  TAB3 if s[i] is the character # ;  $  TAB4 print NO ;  $  TAB4 break ;  $  TAB3 if i equals b, print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 let num be a string ;  $  TAB1 let n,count_8,count_no be ints with count_8=count_no=0 ;  $  TAB1 read n ;  $  TAB1 read num ;  $  TAB1 set count_no=n/11 ;  $  TAB1 for i=0 to length of num ;  $  TAB2 if num[i] = 8 then increment count_8 ;  $  TAB1 if count_8>= count_no then print count_no else print count_8 ;
TAB0 let Hash be a map from string to int ;  $  TAB0 let N be integer ;  $  TAB1 read N ;  $  TAB1 for register integer i = 1 to N inclusive ;  $  TAB2 let s be string ;  $  TAB2 read s ;  $  TAB2 increment value of key s in Hash by 1 ;  $  TAB1 let Ans be integer with Ans = 0 ;  $  TAB1 for register integer i = 1 to N inclusive ;  $  TAB2 let s be string ;  $  TAB2 read s ;  $  TAB2 if value of key s in Hash is not zero ;  $  TAB3 decrement value of key s by 1 ;  $  TAB2 else ;  $  TAB3 increment Ans by 1 ;  $  TAB1 print out Ans with endline ;
TAB1 board = 2d character array of size 101 by 101 ;  $  TAB1 n,m=integers ;  $  TAB1 read n,m ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive read board[j][i] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive ;  $  TAB3 if board[j][i] = '.' ;  $  TAB4 if (j + i) mod 2 = 0 ;  $  TAB5 set board[j][i] = 'B' ;  $  TAB4 else do the following ;  $  TAB5 set board[j][i] = 'W' ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive print board[j][i] ;  $  TAB2 print new line ;
TAB1 s = string ;  $  TAB1 c = integer = 0 ;  $  TAB1 input s ;  $  TAB1 i = 0 to the length of s inclusive ;  $  TAB2 if s[i] is the character 4 or s[i] is the character 7, increment c ;  $  TAB1 if c is equal to either 4 or 7 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create int n, s, ans ;  $  TAB1 read n, s ;  $  TAB1 ans = s / n ;  $  TAB1 if s mod n, increment ans ;  $  TAB1 print ans ;
TAB0 in function solve returning string and taking long d ;  $  TAB1 make float k = 100000, p = 0 ;  $  TAB1 for i = 3 to k exclusive ;  $  TAB2 set p to (i - 2) * 180 ;  $  TAB2 divide p by itself and i ;  $  TAB2 if p is d then return "YES" ;  $  TAB1 return "NO" ;  $  TAB1 make long n, degree = 0, val = 0 ;  $  TAB1 read n ;  $  TAB1 for long i = 0 to n exclusive ;  $  TAB2 read degree ;  $  TAB2 print solve(degree) ;
TAB0 a is a long long integer array of size 100000 ;  $  TAB1 b, d, x, y, z, c, e, p, i, j, k, f are long long integers with c = 0, e = 0, i = 1, k = 50, f = 0 ;  $  TAB1 read x ;  $  TAB1 for i = 1 to x inclusive, read a[i] ;  $  TAB1 read b, d ;  $  TAB1 if d is less than b ;  $  TAB2 set p to d ;  $  TAB2 set d to b ;  $  TAB2 set b to p ;  $  TAB1 set y to b ;  $  TAB1 set z to d ;  $  TAB1 for i = b to d exclusive, add a[i] to c ;  $  TAB1 for i = d to x inclusive, add a[i] to e ;  $  TAB1 for i = 1 to b exclusive, add a[i] to e ;  $  TAB1 if c is greater than e ;  $  TAB2 display e ;  $  TAB1 else ;  $  TAB2 display c ;
TAB0 l, r, a, ans = integers ;  $  TAB1 read l, r, and a ;  $  TAB1 if l is 0 and a is truthy, increment l by 1, decrement a by 1 ;  $  TAB1 if r is 0 and a is truthy, increment r by 1, decrement a by 1 ;  $  TAB1 while l isn't 0 and r isn't 0 ;  $  TAB2 decrement l by 1, r by 1, and increment ans by 2 ;  $  TAB2 if l is 0 and a is truthy, increment l by 1, and decrement a by 1 ;  $  TAB2 if r is 0 and a is truthy, increment l by 1, and decrement a by 1 ;  $  TAB1 print ans ;
TAB1 n = integer ;  $  TAB1 segment = double = 0.0 ;  $  TAB1 length = integer = 0 ;  $  TAB1 read n ;  $  TAB1 a and b are both integer arrays both of size 101 ;  $  TAB1 for i = 1 to n inclusive, read a[i], b[i] ;  $  TAB1 set segment to double(a[1]) - 0.5 ;  $  TAB1 for i = 1 to b[1] - a[1] inclusive ;  $  TAB2 add 1 to segment ;  $  TAB2 for j = 2 to n inclusive ;  $  TAB3 if segment is greater than double(a[j]) and segment is less than double(b[j]) ;  $  TAB4 increment length ;  $  TAB4 break ;  $  TAB1 display b[1] - a[1] - length ;
TAB1 n, k = integers ;  $  TAB1 read n, k ;  $  TAB1 let s = array of characters size 101 ;  $  TAB1 read s ;  $  TAB1 if k is greater than n/2 do the following ;  $  TAB2 for integer i=k to n exclusive print RIGHT ;  $  TAB2 for integer i=n-1 to 0 exclusive and decrementing, do the following ;  $  TAB3 print PRINT s[i] ;  $  TAB3 print LEFT ;  $  TAB2 print PRINT ;  $  TAB1 else do the following ;  $  TAB2 for integer i=k to 0 exclusive and decrementing, print LEFT ;  $  TAB2 for i=0 to n-1 exclusive do the following ;  $  TAB3 print PRINT s[i] ;  $  TAB3 print RIGHT ;  $  TAB2 print PRINT s[n-1] ;
TAB0 let num of array of integers of size 5001 ;  $  TAB1 let n, flag be integers with flag = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n, read element i of num ;  $  TAB1 for i = 1 to n ;  $  TAB2 if i is equal to num[num[num[i]]] ;  $  TAB3 set flag to 1 ;  $  TAB3 break out of for loop ;  $  TAB1 if flag is not zero ;  $  TAB2 print out YES ;  $  TAB1 else ;  $  TAB2 print out NO ;
TAB1 n,k=integers ;  $  TAB1 while n and k is true read n and k and do the following ;  $  TAB2 create integer a = n*2/k+0 if n*2%k=0 else a = n*2/k+1 ;  $  TAB2 create integer a = n*5/k+0 if n*5%k=0 else a = n*5/k+1 ;  $  TAB2 create integer a = n*8/k+0 if n*8%k=0 else a = n*8/k+1 ;  $  TAB2 read a+b+c ;
TAB1 create int s, t, x ;  $  TAB1 while reading s, t, x is not stopped ;  $  TAB2 if x is less than s + t ;  $  TAB3 if x equals s ;  $  TAB4 print "YES" ;  $  TAB3 else ;  $  TAB4 print "NO" ;  $  TAB2 else ;  $  TAB3 if (x - s) mod t equals 0 or (x - s - 1) mod t equals 0 ;  $  TAB4 print "YES" ;  $  TAB3 else ;  $  TAB4 print "NO" ;
TAB1 make int n, ans = 0, mod = 0, k, cou = 0 ;  $  TAB1 read n and k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make int a ;  $  TAB2 read a ;  $  TAB2 add mod to a ;  $  TAB2 assign 0 to mod ;  $  TAB2 if ans less than k then increment cou ;  $  TAB2 add min(8, a) to ans ;  $  TAB2 add max(0, a - 8) to mod ;  $  TAB1 if ans is greater than or equal to k ;  $  TAB2 print cou ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB0 in function absi that takes integer n and return integer ;  $  TAB1 if n is less than 0, return -1 * n ;  $  TAB1 return n ;  $  TAB0 in function abs1 that takes long long integer n and return long long integer ;  $  TAB1 if n is less than 0, return -1 * n ;  $  TAB1 return n ;  $  TAB1 i, count are integers with count = 0 ;  $  TAB1 str = string ;  $  TAB1 input string ;  $  TAB1 n is an integer with n = the size of str ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 r1 = string = substring of str from index n - 1 - i to i + 1 ;  $  TAB2 r2 = string = substring of str from index 0 to n - i - 1 ;  $  TAB2 increment count ;  $  TAB2 if r1 + r2 equals str, break ;  $  TAB1 display count ;
TAB1 let t be an integer ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 n = integer ;  $  TAB2 read n ;  $  TAB2 sides = float = float value of 360 / (180 - n) ;  $  TAB2 sidesI = integer = integer value of sides ;  $  TAB2 if sides equals sidesI ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 declare integer T ;  $  TAB1 declare string x ;  $  TAB1 read T ;  $  TAB1 while T decremented ;  $  TAB2 read x ;  $  TAB2 if x length greater than 10 ;  $  TAB3 print x[0], x length - 2, x end ;  $  TAB2 else ;  $  TAB3 print x ;
TAB0 let n, i be integers and a be array of integers of size 100005 ;  $  TAB1 while input available, read n ;  $  TAB2 let num be long with num = 0 ;  $  TAB2 let ao be long with ao = 0 ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 call sort with a, a+n ;  $  TAB2 for i = 0 to n-1 exclusive ;  $  TAB3 if a[i] is equal to a[i+1[ and a[i] is not equal to 0, increment num ;  $  TAB3 if a[i] is equal to 0, increment ao ;  $  TAB2 if a[i] is equal to 0, increment ao ;  $  TAB2 print n - num - ao ;
TAB0 create int array c of size 5 and multidimensional array a of size 5 by 5005 ;  $  TAB1 create int n and int x ;  $  TAB1 while read n ;  $  TAB2 fill c with 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 read x ;  $  TAB3 a[x][++c[x]] = i ;  $  TAB2 for i = 1 to 3 inclusive do set n to min of n and c[i] ;  $  TAB2 print n ;  $  TAB2 for i = 1 to n inclusive do print a[1][i], " ", a[2][i], " ", a[3][i] ;
TAB1 create int i, N, k, a ;  $  TAB1 read N and k ;  $  TAB1 for i = 1 to k inclusive ;  $  TAB2 set a to N mod 10 ;  $  TAB2 if a not equal to 0 ;  $  TAB3 set N to N - 1 ;  $  TAB2 else ;  $  TAB3 set N to N / 10 ;  $  TAB1 print N ;
TAB1 i and counter are integers both set to 0 ;  $  TAB1 arr is a string ;  $  TAB1 read arr ;  $  TAB1 for i = 0 to (size of arr) - 1 exclusive ;  $  TAB2 if arr[i] is the character 1 and arr[i + 1] is the character 0 ;  $  TAB3 assign ' ' to arr[i + 1] ;  $  TAB3 increment counter ;  $  TAB3 break ;  $  TAB1 if counter is 0 ;  $  TAB2 if arr[0] is the character 0 ;  $  TAB3 assign ' ' to arr[0] ;  $  TAB2 else ;  $  TAB3 assign ' ' to arr[(size of arr) - 1] ;  $  TAB1 for i = 0 to size of arr exclusive ;  $  TAB2 if arr[i] isn't ' ', display arr[i] ;  $  TAB1 display newline ;
TAB1 let input and insertion be strings ;  $  TAB1 let unique and inputLength be integers with inputLength = 0 ;  $  TAB1 read input, unique ;  $  TAB1 set inputLength to length of input ;  $  TAB1 if inputLength is less than unique ;  $  TAB2 output impossible ;  $  TAB1 else ;  $  TAB2 inputs = set of strings ;  $  TAB2 for i = 0 to inputLength exclusive ;  $  TAB3 set insertion to input[i] ;  $  TAB3 insert insertion into inputs ;  $  TAB2 if unique is greater than size of inputs ;  $  TAB3 output unique - size of inputs ;  $  TAB2 else ;  $  TAB3 output 0 ;
TAB0 maxn is a constant integer set to 1e5 + 7 ;  $  TAB0 a = integer array of size maxn ;  $  TAB0 b = integer array of size maxn ;  $  TAB0 c = integer array of size maxn ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 read n values into array a ;  $  TAB1 for i = 1 to n exclusive, set b[i] to absolute value (a[i] - a[i + 1]) ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if i mod 2 ;  $  TAB3 set c[i] to b[i] ;  $  TAB2 else ;  $  TAB3 set c[i] to (-1) * b[i] ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if i mod 2 ;  $  TAB3 set a[i] to (-1) * b[i] ;  $  TAB2 else ;  $  TAB3 set a[i] to b[i] ;  $  TAB1 suma, sumb are long longs both set to 0 ;  $  TAB1 ansa and ansb are long longs both set to -0x3f3f3f3f ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 add c[i] to suma ;  $  TAB2 set ansa to call max with ansa, suma ;  $  TAB2 if suma is negative, set suma to 0 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 add a[i] to sumb ;  $  TAB2 set ansb to call max with ansb, sumb ;  $  TAB2 if sumb is negative, set sumb to 0 ;  $  TAB1 display call max with ansa, ansb ;
TAB0 make integer array z with length 1005 ;  $  TAB1 make string s ;  $  TAB1 make int n ;  $  TAB1 while read n ;  $  TAB2 read character ;  $  TAB2 read line into s ;  $  TAB2 make int sum = 0 and d = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if s[i] equals ' ' ;  $  TAB4 set z[d] to sum ;  $  TAB4 set sum to 0 ;  $  TAB4 increment d ;  $  TAB3 else ;  $  TAB4 if s[i] greater than or equal to 'A' and s[i] less than or equal to 'Z' then increment sum ;  $  TAB2 set z[d] to sum ;  $  TAB2 increment d ;  $  TAB2 make int max = z[0] ;  $  TAB2 for i = 0 to d exclujsive ;  $  TAB3 if z[i] greater than max then set max to z[i] ;  $  TAB2 print max ;
TAB1 v= integer ;  $  TAB1 read v ;  $  TAB1 print (v == 2) + 1 ;
TAB1 a, n, x, i, tt are integers with tt = 0 ;  $  TAB1 read n, x ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 add a to tt ;  $  TAB1 set tt to absolute value tt ;  $  TAB1 if tt is divisible by x ;  $  TAB2 divide tt by x ;  $  TAB1 else ;  $  TAB2 assign (tt - tt mod x) / x + 1 to tt ;  $  TAB1 display tt ;
TAB1 declare integer n initialized to 0 ;  $  TAB1 declare integer m initialized to 0 ;  $  TAB1 declare integer x initialized to 0 ;  $  TAB1 declare integer y initialized to 0 ;  $  TAB1 a is an integer array of size 100000 ;  $  TAB1 b is an integer array of size 100000 ;  $  TAB1 input n ;  $  TAB1 input m ;  $  TAB1 input x ;  $  TAB1 input y ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 for i = 0 to m exclusive, read b[i] ;  $  TAB1 declare integer count initialized to 0 ;  $  TAB1 declare integer index initialized to 0 ;  $  TAB1 declare boolean isStop initialized to false ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 for j = intex to n exclusive ;  $  TAB3 if a[index] - x is greater than b[i], break ;  $  TAB3 if a[n - 1] + y is less than b[i], assign true to isStop ;  $  TAB3 if a[j] - x is at most b[i] and b[i] is at most a[j] + y ;  $  TAB4 assign j + 1 to a[count] ;  $  TAB4 assign i + 1 to b[count] ;  $  TAB4 increment count ;  $  TAB4 assign j + 1 to index ;  $  TAB4 break ;  $  TAB3 else if b[i] is less than a[j] - x ;  $  TAB4 break ;  $  TAB2 if isStop, break ;  $  TAB1 display count ;  $  TAB1 for i = 0 to count exclusive, display a[i], " ", b[i] ;
TAB0 n is an integer ;  $  TAB0 a is an integer array of sizes 35 and 35 ;  $  TAB0 in function getColumn with parameters integer x, integer y and return integer ;  $  TAB1 let c be an integer with c = 0 ;  $  TAB1 for i = 0 to n exclusive, add a[i][y] to c ;  $  TAB1 return c ;  $  TAB0 in function getRow with parameters integer x, integer y and return integer ;  $  TAB1 let r be an integer with r = 0 ;  $  TAB1 for i = 0 to n exclusive, add a[x][i] to r ;  $  TAB1 return r ;  $  TAB1 input n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to n exclusive, read a[i][j] ;  $  TAB1 ans is an integer set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to j exclusive ;  $  TAB3 if call getColumn with arguments i, j is greater than call getRow with arguments i, j, increment ans ;  $  TAB1 display ans ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 define character ch = s[0] ;  $  TAB1 define integer ans = 26 ;  $  TAB1 increase ans by s's size * 25 ;  $  TAB1 print ans ;
TAB0 make const int maxn = 200000 + 5 ;  $  TAB0 make int array zw of size maxn bitwise shift left by 2 ;  $  TAB0 make pair<int, int> array G of length maxn ;  $  TAB0 make integer array ans of size maxn ;  $  TAB0 make integer array a of size maxn ;  $  TAB0 make integer array b of size 30 ;  $  TAB1 make integers n and m ;  $  TAB1 make strings s, ss, and sss ;  $  TAB1 while reading n and m ;  $  TAB2 for i = 1 to n exclusive, read a[i] ;  $  TAB2 make integer pos = 1 ;  $  TAB2 while pos is less than m, increase pos by a[pos] ;  $  TAB2 if pos not equal to m ;  $  TAB3 print "NO" ;  $  TAB2 else ;  $  TAB3 print "YES" ;
TAB1 declare int t, n ;  $  TAB1 read t ;  $  TAB1 declare string s ;  $  TAB1 while t decreased by 1 is not equal to 0 ;  $  TAB2 read s ;  $  TAB2 set n to size of s ;  $  TAB2 if n is less than or equal to 10 ;  $  TAB3 print s ;  $  TAB2 else ;  $  TAB3 print s[0], n - 2, s[n - 1] ;
TAB0 create long long n, array dia of size 10010, m, ans = 0, mis = 100000, k, need = 0 ;  $  TAB1 read n, m, k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read dia[n] ;  $  TAB2 if mis greater than dia[i] and i is odd: set mis to dia[i] ;  $  TAB1 set need to n / 2 + 1 ;  $  TAB1 if n is even or need is greater than m ;  $  TAB2 pass ;  $  TAB1 else ;  $  TAB2 set ans to m / need * k ;  $  TAB2 set ans to min(mis, ans) ;  $  TAB1 print ans ;
TAB1 let l, r, a = integers ;  $  TAB1 read l, r, a ;  $  TAB1 let ans = integer ;  $  TAB1 let s = integer with value = a - abs(l - r) ;  $  TAB1 if s is greater than or equal to 0 do the following ;  $  TAB2 set ans = (max of l and r) + s / 2 ;  $  TAB1 else ;  $  TAB2 set ans = (max of l and r) + s ;  $  TAB1 print ans * 2 ;
TAB1 m, n, i are integers ;  $  TAB1 input m and n ;  $  TAB1 for i = 0 with the condition m is less than or equal to n ;  $  TAB2 assign m * 3 to m ;  $  TAB2 assign n * 2 to n ;  $  TAB1 display i ;
TAB0 N is a constant integer set to 1e5 + 10 ;  $  TAB0 mod is a constant integer set to 1e7 + 9 ;  $  TAB0 a and b are integer arrays both of size N ;  $  TAB1 n and k are integers ;  $  TAB1 read n and k ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = 1 to k inclusive, read b[i] ;  $  TAB1 call sort with arguments b + 1, b + 1 + k ;  $  TAB1 call reverse with arguments b + 1, b + 1 + k ;  $  TAB1 cnt is an integer initialized to 1 ;  $  TAB1 flag is a boolean initialized to false ;  $  TAB1 for integer i = 1 to n inclusive ;  $  TAB2 if a[i] is 0, set a[i] to b[increment cnt] ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 if a[i] is less than a[i - 1], set flag to true ;  $  TAB2 if flag, break ;  $  TAB1 if flag ;  $  TAB2 display Yes ;  $  TAB1 else ;  $  TAB2 display No ;
TAB1 n, m, k, a are integers with a set to 1 ;  $  TAB1 read n ;  $  TAB1 let k be an integer set to 0 ;  $  TAB1 while decrement n ;  $  TAB2 read m ;  $  TAB2 while m is divisible by 2, divide m by 2 ;  $  TAB2 while m is divisible by 3, divide m by 3 ;  $  TAB2 if k is not 0 and m is not k, set a to 0 ;  $  TAB2 set k to m ;  $  TAB1 if a equals 1 ;  $  TAB2 display Yes ;  $  TAB1 else ;  $  TAB2 display No ;
TAB1 a, b, c, d are strings ;  $  TAB1 n is an integer ;  $  TAB1 read a, b, n ;  $  TAB1 display a, ' ', b ;  $  TAB1 while decrement n ;  $  TAB2 display c, d ;  $  TAB2 if a is c ;  $  TAB3 set a to d ;  $  TAB2 else ;  $  TAB3 set b to d ;  $  TAB2 display a, ' ', b ;
TAB1 n, m are integers ;  $  TAB1 read n, m ;  $  TAB1 d = string array of size n ;  $  TAB1 read n values into array d ;  $  TAB1 declare an integer k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set k to 0 ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if d[i][j] is the character B, increment k ;  $  TAB2 if k is positive ;  $  TAB3 p = integer = 0 ;  $  TAB3 for j = 0 to m exclusive ;  $  TAB4 if d[i][j] equals the character B, increment p ;  $  TAB4 if p equals (k / 2) + 1 ;  $  TAB5 output i + k / 2 + 1, " ", j + 1 ;
TAB0 arr= array of Boolean of size 305 ;  $  TAB1 mod, items=integers ;  $  TAB1 let win be integer with win = -2 ;  $  TAB1 y=integer ;  $  TAB1 read mod and items ;  $  TAB1 for a1=0 to items exclusive ;  $  TAB2 read y ;  $  TAB2 if arr[y%mod] is true and win=-2 then set win to a1 ;  $  TAB2 set arr[y%mod] to true ;  $  TAB1 print win+1 ;
TAB1 l2r=array of integer of size 100000 ;  $  TAB1 n,er,el,ql,qr=integers ;  $  TAB1 read n,el,er,ql,qr ;  $  TAB1 read n values into the array l2r ;  $  TAB1 for i=0 to n exclusive then set l2r[i] =l2r[i]+l2r[i-1] ;  $  TAB1 create long long integer sum =l2r[n-1] ;  $  TAB1 create long long integer mn = min of sum * er + (n - 1) * qr or sum * el + (n - 1) * ql ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 create long long integer tmp =l2r[i]*el ;  $  TAB2 let diff be an integer with diff =(n-i-1)-(i+1) ;  $  TAB2 set tmp =temp+ (sum - l2r[i]) * er ;  $  TAB2 if diff<=-1 ;  $  TAB3 set tmp =temp+ (-diff - 1) * ql ;  $  TAB2 else if diff>1 ;  $  TAB3 set tmp=temp+(diff - 1) * qr ;  $  TAB2 set mn=min of mn or tmp ;  $  TAB1 print mn ;  $  TAB1 do nothing ;
TAB1 n = integer, a = integer array of length 100 ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 mx, ans are integers with mx = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i to n exclusive ;  $  TAB3 assign 0 to ans ;  $  TAB3 for k = 0 to n exclusive ;  $  TAB4 if k is at least i and k is at most j ;  $  TAB5 add 1 - a[k] to ans ;  $  TAB4 else ;  $  TAB5 add a[k] to ans ;  $  TAB3 assign call max with mx, ans to mx ;  $  TAB1 print mx ;
TAB1 let ct and x be integers ;  $  TAB1 input ct and x ;  $  TAB1 let vet be an integer array of size ct ;  $  TAB1 for i = 0 to ct exclusive, set vet[i] to 2 ;  $  TAB1 let j be an integer set to 0 ;  $  TAB1 let aux be an integer set to 0 ;  $  TAB1 if ct * 2 equals x ;  $  TAB2 output ct ;  $  TAB1 while ct * 2 + aux isn't equal to x ;  $  TAB2 if j is at least ct, subtract ct from j ;  $  TAB2 if ct * 2 + aux is less than x ;  $  TAB3 increment vet[j] ;  $  TAB3 increment aux ;  $  TAB3 increment j ;  $  TAB2 else if ct * 2 + aux is greater than x and vet[j] is greater than 2 ;  $  TAB3 decrement vet[j] ;  $  TAB3 decrement aux ;  $  TAB3 decrement j ;  $  TAB2 else ;  $  TAB3 increment j ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to ct exclusive ;  $  TAB2 if vet[i] equals 2, increment ans ;  $  TAB1 output ans ;
TAB0 let n,l,r,am,bm,ma,t be integers and a,b be integer array of size 1005 each ;  $  TAB1 read n ;  $  TAB1 set am to 0 ;  $  TAB1 assign 0 to bm ;  $  TAB1 set t=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if a[i]> t ;  $  TAB3 set am=i ;  $  TAB3 set t=a[i] ;  $  TAB1 set t=0 ;  $  TAB1 for i =0 to n exclusive ;  $  TAB2 read b[i] ;  $  TAB2 if b[i]>t ;  $  TAB3 set bm=i ;  $  TAB3 set t=b[i] ;  $  TAB1 set l to minimum of am and bm ;  $  TAB1 set r to max of am and bm ;  $  TAB1 set am=0 ;  $  TAB1 set bm=0 ;  $  TAB1 for i=1 to r inclusive ;  $  TAB2 set am = am | a[i]` ;  $  TAB2 set bm= bm | b[i] ;  $  TAB1 set ma = am + bm ;  $  TAB1 while l>0 or r<n-1 ;  $  TAB2 create integer ha and hb with ha=0 and hb=0 ;  $  TAB2 if l>0 ;  $  TAB3 set ha = am | a[l - 1] ;  $  TAB3 set hb = bm | b[l - 1] ;  $  TAB3 if (ha + hb > ma) set ma = ha + hb ;  $  TAB3 decrement l ;  $  TAB2 if r < n - 1 ;  $  TAB3 set ha = am | a[r + 1] ;  $  TAB3 set hb = bm | b[r + 1] ;  $  TAB3 if (ha + hb > ma) set ma = ha + hb ;  $  TAB3 increment r ;  $  TAB2 if l >= 0 ;  $  TAB3 set ha = ha | a[l] ;  $  TAB3 set hb = hb | b[l] ;  $  TAB3 if (ha + hb > ma) set ma = ha + hb ;  $  TAB2 set am = ha ;  $  TAB2 set bm = hb ;  $  TAB1 print ma ;
TAB1 arr = array of integers with length of 5 ;  $  TAB1 sum = integer set to 0 ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 read index i of arr ;  $  TAB2 increase sum by index i of arr ;  $  TAB1 if sum is 0 ;  $  TAB2 print -1 ;  $  TAB1 if sum modulo 5 = 0 ;  $  TAB2 print sum / 5 ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB1 create an integer no ,max ,t with max =0 and t=1 ;  $  TAB1 arr = array of integer of size 100001 ;  $  TAB1 read no ;  $  TAB1 read no values into the array arr ;  $  TAB1 for i=1 to no exclusive ;  $  TAB2 if arr[i]>arr[i-1] ;  $  TAB3 increment t ;  $  TAB2 else do the following ;  $  TAB3 if t>max then set max=t ;  $  TAB3 set t=1 ;  $  TAB1 if t>max then set max=t ;  $  TAB1 print max and new line ;
TAB0 declare integer function fun taking in integers x and y ;  $  TAB1 let a, b, c = integers with c=1 ;  $  TAB1 set a = max of x and y ;  $  TAB1 set b = min of x and y ;  $  TAB1 while c is not equal to 0 do the following ;  $  TAB2 set c = a modulo b ;  $  TAB2 set a = b ;  $  TAB2 set b = c ;  $  TAB1 return x * y / a ;  $  TAB1 let n, m, s, ans = integrs ;  $  TAB1 while ( read n, m, s) is true do the following ;  $  TAB2 set ans = 0 ;  $  TAB2 let a = integer with value result of call to fun passing in n, m ;  $  TAB2 let b = integer with value a ;  $  TAB2 while b is less than or equal to s do the following ;  $  TAB3 increment ans ;  $  TAB3 set b = b +a ;  $  TAB2 print ans ;
TAB0 create set<int> se ;  $  TAB1 crease int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create int x ;  $  TAB2 read x ;  $  TAB2 if x, insert x into se ;  $  TAB1 print size of se ;
TAB0 let MOD be static const integer with MOD = 1e9 + 7 ;  $  TAB0 let N be static const integer with N = 1 << 17 ;  $  TAB0 define gcd which takes long long x, y and return long long ;  $  TAB1 return x if y == 0 else gcd of y, x mod y ;  $  TAB0 in function solve ;  $  TAB1 n = integer ;  $  TAB1 row = integer array of size 128 ;  $  TAB1 read na ;  $  TAB1 let ans be integer with ans = 0 ;  $  TAB1 for i = 0, __b = n to till i < __b ;  $  TAB2 let c be integer with c = 0 ;  $  TAB2 s = string ;  $  TAB2 read s ;  $  TAB2 for j = 0, __b = n to till j < __b ;  $  TAB3 if s[j] == 'C', increment c and row[j] ;  $  TAB2 update ans to ans + c * (c-1) / 2 ;  $  TAB1 for i = 0, __b = n to till i < __b, update ans to ans + row[i] * (row[i] - 1)/2 ;  $  TAB1 print ans ;  $  TAB1 set precision of cout to 20 ;  $  TAB1 call solve ;
TAB1 let a, b be integers ;  $  TAB1 while input available, read a, b, and print min of a and b, " ", (max of a and b - min of a and b) / 2 ;
TAB0 a = integer array of size 2000 ;  $  TAB1 n, p, x, i, j, count are integers with count = 0 ;  $  TAB1 read n ;  $  TAB1 read p ;  $  TAB1 for i = 0 to p exclusive ;  $  TAB2 read j ;  $  TAB2 set a[j] to 1 ;  $  TAB1 read x ;  $  TAB1 for i = 0 to x exclusive ;  $  TAB2 read j ;  $  TAB2 set a[j] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] equals 0, set count to 1 ;  $  TAB1 if count equals 1 ;  $  TAB2 print Oh, my keyboard! ;  $  TAB1 else ;  $  TAB2 print I become the guy. ;
TAB1 n, m, l, r are integers ;  $  TAB1 c1, c2 are characters ;  $  TAB1 read n, m ;  $  TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read l, r, c1, c2 ;  $  TAB2 for j = l - 1 to r exclusive ;  $  TAB3 if s[j] equals c1, set s[j] to c2 ;  $  TAB1 output s ;
TAB0 mp = map from long long to long long ;  $  TAB0 define PD which takes long long a and b ;  $  TAB1 if find of mp with a == end of mp, set mp[a] to 0 ;  $  TAB1 increment mp[a] by b ;  $  TAB1 n, s, u, v, w, d = long long with d = 0 ;  $  TAB1 read n ;  $  TAB1 while n > 0, decrement n ;  $  TAB2 read s, u, v ;  $  TAB2 if s == 1 ;  $  TAB3 read w ;  $  TAB3 while true ;  $  TAB4 if u == v ;  $  TAB5 break ;  $  TAB4 else if u > v ;  $  TAB5 call PD of u, w ;  $  TAB5 update u to u/2 ;  $  TAB4 else if u < v ;  $  TAB5 call PD of v, w ;  $  TAB5 update v to v/2 ;  $  TAB2 else if s == 2 ;  $  TAB3 while true ;  $  TAB4 if u == v ;  $  TAB5 break ;  $  TAB4 else if u > v ;  $  TAB5 increment d by mp[u] ;  $  TAB5 update u to u/2 ;  $  TAB4 else if u < v ;  $  TAB5 increment d by mp[v] ;  $  TAB5 update v to v/2 ;  $  TAB3 print d ;  $  TAB3 set d to 0 ;
TAB0 in function cari with parameters integer mulai, string a, char b and return unteger ;  $  TAB1 len = integer = length of a ;  $  TAB1 for i = mulai to len exclusive ;  $  TAB2 if a[i] equals b, return i ;  $  TAB1 return -1 ;  $  TAB1 a = string ;  $  TAB1 input a ;  $  TAB1 searchres = integer ;  $  TAB1 set searchres to call cari with 0, a, the character h ;  $  TAB1 if searchres equals -1 ;  $  TAB2 output NO ;  $  TAB1 set searchres to call cari with searchres, a, the character e ;  $  TAB1 if searchres equals -1 ;  $  TAB2 output NO ;  $  TAB1 set searchres to call cari with searchres, a, the character l ;  $  TAB1 if searchres equals -1 ;  $  TAB2 output NO ;  $  TAB1 set searchres to call cari with searchres + 1, a, the character l ;  $  TAB1 if searchres equals -1 ;  $  TAB2 output NO ;  $  TAB1 set searchres to call cari with searchres, a, the character o ;  $  TAB1 if searchres equals -1 ;  $  TAB2 output NO ;  $  TAB1 output YES ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 let a be an vector integer array of size n ;  $  TAB1 read n values into array a ;  $  TAB1 let res be an int with res=0 ;  $  TAB1 create integer head=0 ;  $  TAB1 for i=1 to n exclusive ;  $  TAB2 if a[i] is equal to a[i-1] ;  $  TAB3 create integer tar=i-1 ;  $  TAB3 set res= max of res and tar-head ;  $  TAB3 create integer len = (tar-head)/2 ;  $  TAB3 for j=head to head+len inclusive set a[j] = a[head] ;  $  TAB3 for j=head+len+1 to i exclusive assign a[i] to a[j] ;  $  TAB3 set head to i ;  $  TAB1 create integer tar=n-1 ;  $  TAB1 set res to max of res and tar-head ;  $  TAB1 create integer len=(tar-head)/2 ;  $  TAB1 for j=head to head+len inclusive set a[j]=a[head] ;  $  TAB1 for j=head+len+1 to n exclusive set a[j]=a[n-1] ;  $  TAB1 print res/2 and new line ;  $  TAB1 for i=0 to n exclusive print a[i] and new line if i+1 is equal to n else print a[i] and " " ;
TAB0 n, m, k are integers ;  $  TAB1 read n, m, and k ;  $  TAB1 p = integer = (k - 1) / 2 ;  $  TAB1 ans = integer = p / m + 1 ;  $  TAB1 ans1 = integer = p mod m + 1 ;  $  TAB1 if k is odd ;  $  TAB2 display ans, " ", ans1, " L" ;  $  TAB1 else ;  $  TAB2 display ans, " ", ans2, " R" ;
TAB0 a = array of unsigned long long size 2000000 ;  $  TAB0 b = array of unsigned long long size 2000000 ;  $  TAB0 n = integer ;  $  TAB0 declare boolean function judge with integer n as an argument ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if a[i] is a[i+1] return true ;  $  TAB1 return false ;  $  TAB1 while (read n) is true do the following ;  $  TAB2 set sizeof(a) bytes starting at a to 0 ;  $  TAB2 for i=0 to n exclusive do the following ;  $  TAB3 read a[i] ;  $  TAB3 inceement b[a[i]] ;  $  TAB2 call sort on a and a + n ;  $  TAB2 set ans = integer value 0 ;  $  TAB2 for i=1 to 2000000 exclusive do the following ;  $  TAB3 set b[i] = b[i-1]/2 ;  $  TAB3 set b[i-1] = b[i-1] modulo 2 ;  $  TAB3 set ans = ans + b[i-1] ;  $  TAB2 print ans ;
TAB0 let v = array of integers size 110 ;  $  TAB0 let n, m, k, sum, x = integers ;  $  TAB1 read n, m ;  $  TAB1 set sizeof(v) bytes starting at v to 0 ;  $  TAB1 for integer i=0 to m exclusive do the following ;  $  TAB2 set k = 1 ;  $  TAB2 set sum = -1 ;  $  TAB2 for integer i=1 to n inclusive do the following ;  $  TAB3 read x ;  $  TAB3 if sum is less than x do the following ;  $  TAB4 set sum = x ;  $  TAB4 set k = i ;  $  TAB2 increment v[k] ;  $  TAB1 let Max = integer with value = 0 ;  $  TAB1 set ans = integer with value = 1 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 if v[i] is greater than Max do the following ;  $  TAB3 set Max = v[i] ;  $  TAB3 set ans = i ;  $  TAB1 print ans ;
TAB0 create long long array arr of length 1000000 ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create long long sum = 0 ;  $  TAB1 for long long i = 1 to n inclusive ;  $  TAB2 read arr[i] ;  $  TAB2 increase sum by arr[i] ;  $  TAB1 create long long ans = 0 ;  $  TAB1 if sum is even ;  $  TAB2 divide sum by 2 ;  $  TAB1 else ;  $  TAB2 assign sum / 2 + 1 to sum ;  $  TAB1 for long long i = 1 to n inclusive ;  $  TAB2 if ans greater than or equal to sum ;  $  TAB3 print i ;  $  TAB2 increase ans by arr[i] ;  $  TAB2 if ans greater than or equal to sum ;  $  TAB3 print i ;
TAB0 create set<string> st ;  $  TAB0 create string s ;  $  TAB0 create int answer = 0 ;  $  TAB0 create multidimensional int array p of size 3 by 6, initialized with {{1, 5, 2, 3, 0, 4}, {3, 1, 0, 5, 4, 2}, {0, 2, 4, 1, 3, 5}} ;  $  TAB0 in function permut, accepting a string reference s and int type ;  $  TAB1 create string new_s = s ;  $  TAB1 for i = 0 to 6 exclusive do set s[i] to new_s[p[type][i]] ;  $  TAB0 null statement ;  $  TAB1 read s ;  $  TAB1 sort s ;  $  TAB1 do ;  $  TAB2 if st.find(s) is equal to st.end() ;  $  TAB3 add 1 to answer ;  $  TAB3 create string t = s ;  $  TAB3 for i = 0 to 4 exclusive ;  $  TAB4 call permut with t and 0 ;  $  TAB4 for j = 0 to 4 exclusive ;  $  TAB5 call permut with t and 1 ;  $  TAB5 for k = 0 to 4 exclusive ;  $  TAB6 call permut with t and 2 ;  $  TAB6 insert t into st ;  $  TAB5 null statement ;  $  TAB4 null statement ;  $  TAB3 null statement ;  $  TAB2 null statement ;  $  TAB1 while next_permutation(s.begin(), s.end()) ;  $  TAB1 print answer ;
TAB1 create int n, sum ;  $  TAB1 read n ;  $  TAB1 for i = 1 to 1000 inclusive ;  $  TAB2 create int k = 0 ;  $  TAB2 set sum to n * i + 1 ;  $  TAB2 for j = 2 to sum exclusive ;  $  TAB3 if sum modulo j is 0 ;  $  TAB4 set k to 1 ;  $  TAB4 break ;  $  TAB2 if k equals 1 ;  $  TAB3 print i ;  $  TAB3 break ;
TAB1 define int array num of size 4 = 0 ;  $  TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare int tmp ;  $  TAB2 read tmp ;  $  TAB2 increment num[tmp] ;  $  TAB1 if num[1] greater than or equal to num[2] and num[1] greater than or equal to num[3] ;  $  TAB2 print num[2] + num[3] ;  $  TAB1 else if num[2] greater than or equal to num[1] and num[2] greater than or equal to num[3] ;  $  TAB2 print num[1] + num[3] ;  $  TAB1 else ;  $  TAB2 print num[1] + num[2] ;
TAB1 let a, b be integers ;  $  TAB1 let m be an integer with m = 0 ;  $  TAB1 input b, a ;  $  TAB1 while a isn't 0 ;  $  TAB2 set m to m * 10 + a mod 10 ;  $  TAB2 divide a by 10 ;  $  TAB1 display m + b ;
TAB1 let k, r = integer ;  $  TAB1 read k, r ;  $  TAB1 for integer i=1 to infinity do the following ;  $  TAB2 if i *k modulo 10 is 0 or (i * k -r) modulo 10 is 0 do the following ;  $  TAB3 print i ;  $  TAB3 exit the loop ;
TAB1 make int n, k ;  $  TAB1 read n, k ;  $  TAB1 make int arya = 0, bran = 0 ;  $  TAB1 make int mnd = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make int today ;  $  TAB2 read today ;  $  TAB2 if today + arya is greater than or equal to 8 ;  $  TAB3 increase bran by 8 ;  $  TAB3 increase arya by today - 8 ;  $  TAB3 increment mnd ;  $  TAB2 else ;  $  TAB3 increase bran by today + arya ;  $  TAB3 set arya to 0 ;  $  TAB3 increment mnd ;  $  TAB2 if bran is greater than or equal to k ;  $  TAB3 print mnd ;  $  TAB1 if bran less than k then print -1 ;
TAB1 create long long integers n, i = 0, diff, row, col ;  $  TAB1 read n ;  $  TAB1 for i = 1; while i * i is less than or equal to n; increment i ;  $  TAB2 n modulo i equals 0 ;  $  TAB3 if abs of i - n / i is less than diff ;  $  TAB4 set row to i ;  $  TAB4 set col to n / i ;  $  TAB4 set diff to abs of i - n / i ;  $  TAB1 print row, " ", col ;
TAB1 create integers n,i,x,y,m=10000 and s=0 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read x and y ;  $  TAB2 set m to minimum of m and y ;  $  TAB2 set s to s+ m * x ;  $  TAB1 print s and new line ;
TAB1 n = integer ;  $  TAB1 while input available, read n ;  $  TAB2 ans_a = ans_b = integer array of size 6 ;  $  TAB2 set all elements of ans_a to 0 ;  $  TAB2 set all elements of ans_b to 0 ;  $  TAB2 let k, i be integers ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read k ;  $  TAB3 increment ans_a[k] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 read k ;  $  TAB3 increment ans_b[k] ;  $  TAB2 cnt = integer = 0 ;  $  TAB2 flag = boolean = true ;  $  TAB2 for i = 1 to t inclusive ;  $  TAB3 if (ans_a[i] + ans_b[i]) is odd ;  $  TAB4 set flag to false ;  $  TAB4 break ;  $  TAB3 update cnt to cnt + abs of (ans_a[i] -ans_b[i]) / 2 ;  $  TAB2 if flag is false ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print cnt/2 ;
TAB1 make int a, b, cnt, x, y ;  $  TAB1 read a and b ;  $  TAB1 if a greater than b ;  $  TAB2 assign (a - b) / 2 to x ;  $  TAB2 print b " " x ;  $  TAB1 else ;  $  TAB2 assign (b - a) / 2 to y ;  $  TAB2 print a " " y ;
TAB1 n = long long integer ;  $  TAB1 read n ;  $  TAB1 create long long integers firstdata, seconddata, saved = 0 ;  $  TAB1 create long long integer result = n ;  $  TAB1 read firstdata ;  $  TAB1 for i=0 to n-1 exclusive ;  $  TAB2 read seconddata ;  $  TAB2 if firstdata is not equal to seconddata ;  $  TAB3 set saved to 0 ;  $  TAB3 assign seconddata to firstdata ;  $  TAB3 continue ;  $  TAB2 else do the following ;  $  TAB3 increment saved ;  $  TAB3 set result to result + saved ;  $  TAB3 set firstdata to seconddata ;  $  TAB1 print result and a new line ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 create integer tmp = minimum of i+1 and n-i ;  $  TAB2 create integer a = tmp * 2 - 1 ;  $  TAB2 create integer b = (n-a) / 2 ;  $  TAB2 print * b times ;  $  TAB2 print D a times ;  $  TAB2 print * b times ;  $  TAB2 print new line ;
TAB1 n = string ;  $  TAB1 read n ;  $  TAB1 j = integer ;  $  TAB1 create boolean ok= true ;  $  TAB1 for j=0 to size of n exclusive ;  $  TAB2 if n[j] is equal to 1 ;  $  TAB3 if j+1 < size of n and n[j + 1] == '4' ;  $  TAB4 if j+2 < size of n and n[j + 2] == '4' then increment j ;  $  TAB4 increment j ;  $  TAB2 else do the following ;  $  TAB3 set ok= false ;  $  TAB1 if ok is true ;  $  TAB2 print YES ;  $  TAB1 else do the following ;  $  TAB2 print NO ;  $  TAB1 print a new line ;
TAB1 let duration = integer constant with value = 86400 ;  $  TAB1 let n, t = integer ;  $  TAB1 while (read n, t) is true ;  $  TAB2 let a = vector of integers with size = n+1 and values = 0 ;  $  TAB2 read n values into vector a ;  $  TAB2 let answ = integer with value = 0 ;  $  TAB2 while t is greater than 0 dothe following ;  $  TAB3 set t = t - (duration - a[answ]) ;  $  TAB3 increment answ ;  $  TAB2 print answ ;
TAB1 let n be an integer ;  $  TAB1 while input n, output n / 2 + 1 ;
TAB1 let n be an integer ;  $  TAB1 while input n, display n / 2 + 1 ;
TAB0 “define function mul which takes in long longs x and p as arguments”. ;  $  TAB1 ans = long long with ans = 1 ;  $  TAB1 while p is true ;  $  TAB2 if (p bitwise and 1) set ans = ans * x mod 1000000007 ;  $  TAB2 set x = x squared mod 1000000007 ;  $  TAB2 p = p left shift 1 ;  $  TAB1 return ans as a long long ;  $  TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 if n is true ;  $  TAB2 w = long long with w = mul(2, n-1) ;  $  TAB2 print (w + 2 * w * w % 1000000007) % 1000000007 ;  $  TAB1 else ;  $  TAB2 print 1 ;
TAB0 inf is a constant integer with inf = (1 shifted 30 bits left) - 1 ;  $  TAB1 n, l, r, Ql, Qr, ans are integers with ans = inf ;  $  TAB1 L and R are both booleans and are both set to false ;  $  TAB1 read n, l, r, Ql, Qr ;  $  TAB1 a is an integer array of size n + 1 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input a[i] ;  $  TAB2 add a[i - 1] to a[i] ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 sum1 = integer = a[i], sum2 = integer = a[n] - a[i], x = integer = i, y = integer = n - i ;  $  TAB2 if x is less than y ;  $  TAB3 d is an integer with d = call max with arguments 0, y - x - 1 ;  $  TAB3 set ans to call min with arguments ans, sum1 * l + sum2 * r + d * Qr ;  $  TAB2 if x is at least y ;  $  TAB3 d is an integer set to call max with arguments 0, x - y - 1 ;  $  TAB3 set ans to call min with arguments ans, sum1 * l + sum2 * r + d * Ql ;  $  TAB1 display ANS ;
TAB1 n is an integer ;  $  TAB1 s is a string ;  $  TAB1 read n and s ;  $  TAB1 ans and d are both integers both set to 0 ;  $  TAB1 for i = 0 to size s exclusive ;  $  TAB2 if s[i] is the character 1 ;  $  TAB3 increment d ;  $  TAB2 else ;  $  TAB3 if d is not 0, set ans to ans + d, set d to 0 ;  $  TAB3 multiply ans by 10 ;  $  TAB1 if d is not 0, add d to ans ;  $  TAB1 display ans ;
TAB1 let n, m = integer ;  $  TAB1 read n, m ;  $  TAB1 for integer i=1 to infinity with increment step i+1 modulo n+1 do the following ;  $  TAB2 if m is greater than or equal to i do the following ;  $  TAB3 set m = m - i ;  $  TAB2 else ;  $  TAB3 exit the loop ;  $  TAB1 print m ;
TAB1 n, k are unsigned long longs ;  $  TAB1 input n and k ;  $  TAB1 if (n / k) modulo 2 ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB1 n and b are integers with b = 0 ;  $  TAB1 input n ;  $  TAB1 set n to n * 2 ;  $  TAB1 while set n to n / 2, add n mod 2 to b ;  $  TAB1 output b ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let arr be a long long integer array of size 2 * n ;  $  TAB1 for i = 0 to 2 * n exclusive, read a[i] ;  $  TAB1 call sort with arguments arr, arr + 2 * n ;  $  TAB1 X = long long integer = arr[n - 1] - arr[0] ;  $  TAB1 Y = long long integer = arr[2 * n - 1] - arr[n] ;  $  TAB1 ans = long long integer = X * Y ;  $  TAB1 for i = 1 to n exclusive, set ans to call min with arguments ans, (arr[2 * n - 1] - arr[0]) * (arr[i + n - 1] - arr[i]) ;  $  TAB1 display ans ;
TAB1 n= integer ;  $  TAB1 read n ;  $  TAB1 let arr be an array of integers of size n+1 ;  $  TAB1 call fill on arr, arr+n+1, -1 ;  $  TAB1 num=integer ;  $  TAB1 let count and mx be ints with count=mx=0 ;  $  TAB1 for i=1 to 2*n inclusive ;  $  TAB2 read num ;  $  TAB2 if arr[num] is -1 ;  $  TAB3 set arr[num] to 0 ;  $  TAB3 add 1 to count ;  $  TAB2 else if arr[num] is 0 ;  $  TAB3 then set arr[num] to 1 ;  $  TAB3 subtract 1 from count ;  $  TAB2 set mx to max of mx and count ;  $  TAB1 print mx ;
TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 a is an integer array of length 100 ;  $  TAB1 call memset with a, 0, call sizeof with a ;  $  TAB1 read n values into array a ;  $  TAB1 declare an integer temp ;  $  TAB1 declare an integer ans set to -1 ;  $  TAB1 for i = 0 to n + 1 inclusive ;  $  TAB2 assign 0 to temp ;  $  TAB2 for j = 1 as long as j is at most i and j is at most n with increment j ;  $  TAB3 if a[j] is 0, increment temp ;  $  TAB2 for j = i to n inclusive ;  $  TAB3 if a[j] is 1, increment temp ;  $  TAB2 set ans to call max with ans, temp ;  $  TAB1 output ans ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 v length n = vector of integers ;  $  TAB1 for i = 0 to n exclusive, read v[i] ;  $  TAB1 c length 3 = vector of integers ;  $  TAB1 for j = 0 to 3 exclusive ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if v[i] isn't j + 1, increment cnt[j] by 1 ;  $  TAB1 print minimum of cnt[0] and minimum of cnt[1] and cnt[2] ;
TAB1 make int n, p, q ;  $  TAB1 read n ;  $  TAB1 read p ;  $  TAB1 make int array P of size p ;  $  TAB1 read p values into P ;  $  TAB1 read q ;  $  TAB1 make int array Q of size q ;  $  TAB1 read q values into Q ;  $  TAB1 make int array check of size n + 1, initialized with 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for y = 0 to q exclusive ;  $  TAB3 if Q[y] is i then set check[i] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for x = 0 to p exclusive ;  $  TAB3 if P[x] is i then set check[i[ to 1 ;  $  TAB1 make int f = 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if check[i] is 0 ;  $  TAB3 set f to 0 ;  $  TAB3 break ;  $  TAB1 if f is 0 ;  $  TAB2 print "Oh, my keyboard!" ;  $  TAB1 else ;  $  TAB2 print "I become the guy." ;  $  TAB3 print newline ;
TAB1 let x = integer value 0 ;  $  TAB1 for integer i = 1 to 5 inclusive do the following ;  $  TAB2 for integer j=1 to 5 inclusive do the following ;  $  TAB3 read x ;  $  TAB3 if x is 1 print abs(i-3) + abs(j-3) ;
TAB1 a, b, s = integers ;  $  TAB1 read a, b, s ;  $  TAB1 ans = integer set to s - absolute value of a - absolute value of b ;  $  TAB1 if ans >= 0 and ans modulo 2 is 0 ;  $  TAB2 print "Yes" ;  $  TAB1 else ;  $  TAB2 print "No: ;
TAB0 let n = integer ;  $  TAB0 let ar = vector of integers ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let e1 = integer ;  $  TAB2 read e1 ;  $  TAB2 append e1 to ar ;  $  TAB1 let ans = integer with value = 0 ;  $  TAB1 for integer i=1 to n-1 exclusive do the following ;  $  TAB2 if ar[i] is greater than ar[i-1] and ar[i] is greater than ar[i + 1] increment ans ;  $  TAB2 if ar[i] is less than ar[i-1] and ar[i] is less than ar[i + 1] increment ans ;  $  TAB1 print ans ;
TAB0 let input1, input2, sementara be char and basis be char array of size 10 ;  $  TAB0 let rotasi, a be integers ;  $  TAB0 let c1, c2 be boolean with c1 = c2 = false ;  $  TAB1 read input1, input2, rotasi ;  $  TAB1 set basis[1] to 'v' ;  $  TAB1 set basis[2] to '<' ;  $  TAB1 set basis[3] to '^' ;  $  TAB1 set basis[4] to '>' ;  $  TAB1 set basis[5] to 'v' ;  $  TAB1 set basis[6] to '<' ;  $  TAB1 set basis[7] to '^' ;  $  TAB1 set basis[8] to '>' ;  $  TAB1 update rotasi to rotasi mod 4 ;  $  TAB1 for x = 1 to 4 inclusive ;  $  TAB2 if input1 == basis[x] ;  $  TAB3 set a to x ;  $  TAB3 break ;  $  TAB1 if a + ratosi > 8 ;  $  TAB2 update sementara to basis[a + ratasi - 8] ;  $  TAB1 else ;  $  TAB2 update sementara to basis[a + ratasi] ;  $  TAB1 if sementara == input2, set c1 to true ;  $  TAB1 if a - rotasi < 1 ;  $  TAB2 update sementara to basis[8 + a - rotasi] ;  $  TAB1 else ;  $  TAB2 update sementara to basis[a - rotasi] ;  $  TAB1 if sementara == input2, set c2 to true ;  $  TAB1 if c1 == true and c2 == true ;  $  TAB2 print undefined ;  $  TAB1 else if c2 == true ;  $  TAB2 print ccw ;  $  TAB1 else if c1 == true ;  $  TAB2 print cq ;
TAB1 make string s ;  $  TAB1 read s ;  $  TAB1 make size_t pos = 0 ;  $  TAB1 while pos less than length of s and s[pos] not equal to 'h' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than length of s and s[pos] not equal to 'e' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than length of s and s[pos] not equal to 'l' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than length of s and s[pos] not equal to 'l' do increment pos ;  $  TAB1 increment pos ;  $  TAB1 while pos less than length of s and s[pos] not equal to 'o' do increment pos ;  $  TAB1 if pos is less than s length ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 i = integer ;  $  TAB1 for i = 0 as long as i is less than size of str and str[i] is the character a with increment i + 1 ;  $  TAB1 for j = 1 to size of str exclusive ;  $  TAB2 if str[j] is the character a, break ;  $  TAB2 decrement str[j] ;  $  TAB1 if i equals size of str, set str[(size of str) - 1] to the character z ;  $  TAB1 print str ;
TAB1 let n, k = long longs ;  $  TAB1 read n, k ;  $  TAB1 let d, c, rem = long longs with d = n / (2 * (k+1)), c = k * d, rem = n - (d+c) ;  $  TAB1 print d and a space and c and a space and rem ;
TAB0 declare long long n ;  $  TAB1 read n ;  $  TAB1 let long long x = 3 ;  $  TAB1 while n modulo x equals 0 do set x to x * 3 ;  $  TAB1 print n / x + 1 ;
TAB0 let n, k, a be integers ;  $  TAB1 read n ;  $  TAB1 let ans be integer with ans = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read k, a ;  $  TAB2 if 1 == a, increment k ;  $  TAB2 while a != 1 ;  $  TAB3 if a % 4 != 0 ;  $  TAB4 update a to a/4 + 1 ;  $  TAB3 else ;  $  TAB4 a = a/4 ;  $  TAB3 increment k ;  $  TAB2 set ans to k if k > ans else ans ;  $  TAB1 print ans ;
TAB1 n, m, k = long long integers ;  $  TAB1 read n, m, k ;  $  TAB1 a with n = long long vector ;  $  TAB1 mn = long long integer set to 1e9 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 if i modulo 2 is 0, set mn to minimum of mn and a[i] ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 print 0 ;  $  TAB1 print minimum of m / n / 2 + 1 * k and mn ;
TAB0 create constant integer INF = 1e9 ;  $  TAB0 create constant integer mod = 1e9+7 ;  $  TAB0 create constant integer MAX = 2e5+5 ;  $  TAB0 into the function build ;  $  TAB1 return ;  $  TAB0 s=string ;  $  TAB0 l=integer ;  $  TAB0 into the function Init ;  $  TAB1 read s ;  $  TAB1 l= length of s ;  $  TAB1 return ;  $  TAB0 flag1,flag2,flag3=boolean ;  $  TAB0 into the function sol ;  $  TAB1 for i=0 to l exclusive ;  $  TAB2 if s[i] >= 'A' and s[i] <= 'Z' ;  $  TAB3 set flag1 =1 ;  $  TAB2 else if s[i] >= 'a' and s[i] <= 'z' ;  $  TAB3 set flag2=1 ;  $  TAB2 else if s[i] >= '0' and s[i] <= '9' ;  $  TAB3 set flag3=1 ;  $  TAB1 if flag1 and flag2 and flag3 and l >= 5 ;  $  TAB2 print Correct ;  $  TAB1 else do the following ;  $  TAB2 print Too weak ;  $  TAB1 return ;  $  TAB1 call Init function ;  $  TAB1 call build function ;  $  TAB1 call sol function ;
TAB0 create integer array A of size 100 X 100 ;  $  TAB0 create integer array B of size 26000 ;  $  TAB0 create vector integer array NEB of size 27000 ;  $  TAB0 let yy be integer with yy=0 ;  $  TAB0 create integer arrays vis,low,malow,tim,F of sizes 27000 each ;  $  TAB0 create integer t=1 ;  $  TAB0 create integer uu=0 ;  $  TAB0 create integer vector check ;  $  TAB0 in the function dfs which takes a integer s ;  $  TAB1 set low[s] = t ;  $  TAB1 set vis[s] = 1 ;  $  TAB1 set tim[s] =t ;  $  TAB1 add 1 to t ;  $  TAB1 create integer pp=0 ;  $  TAB1 for i=0 to NEB[s].size exclusive ;  $  TAB2 create integer l = NEB[s][i] ;  $  TAB2 if F[s] is not equal to 1 ;  $  TAB3 if vis[l] is equal to 1 ;  $  TAB4 set low[s] to minimum of low[s] and tim[l] ;  $  TAB3 else do the following ;  $  TAB4 add 1 to pp ;  $  TAB4 set F[l] =s ;  $  TAB4 call dfs with argument l ;  $  TAB4 create integer u=s ;  $  TAB4 set low[u] = minimum of low[u] and low[l] ;  $  TAB4 set malow[w] to maximum of malow[u] and low[l] ;  $  TAB1 create integer u = s ;  $  TAB1 is s=yy and pp>1 ;  $  TAB2 set uu=1 ;  $  TAB2 add s to the end of check ;  $  TAB1 else if ss is not equal to yy and malow[u] >= tim[u] ;  $  TAB2 set uu to 1 ;  $  TAB2 add s to end of check ;  $  TAB1 n,m = integers ;  $  TAB1 read n and m ;  $  TAB1 create integer no=0 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 for j=1 to m inclusive ;  $  TAB3 c= char ;  $  TAB3 read c ;  $  TAB3 if c is equal to # ;  $  TAB4 increment no ;  $  TAB4 set A[i][j] to 1 ;  $  TAB4 set B[(m + 1) * i + j] = 1 ;  $  TAB4 set yy = (m + 1) * i + j ;  $  TAB1 create integer array of size 4 P = {-1, 1, (0 - m - 1), m + 1}{-1, 1, (0 - m - 1), m + 1} ;  $  TAB1 for i=1 to 2700 exclusive ;  $  TAB2 for j=0 to 4 exclusive ;  $  TAB3 if i + P[j] >= 0 and B[i + P[j]] = 1 then add i+P[j] to the end of NEB[i] ;  $  TAB1 call dfs on yy ;  $  TAB1 if no<3 ;  $  TAB2 then print -1 ;  $  TAB1 else do the following ;  $  TAB2 if uu is 1 ;  $  TAB3 print 1 and new line ;  $  TAB2 else do the following ;  $  TAB3 print 2 ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let m be an integer with m = (n / 2) ;  $  TAB1 let x be an integer with x = ((2 * n) - m) ;  $  TAB1 display x ;
TAB1 create int n, num = 1 ;  $  TAB1 read n ;  $  TAB1 fori = 1 to n exclusive, set num to num * 3 modulo 1000003 ;  $  TAB1 print num ;
TAB1 T = integer ;  $  TAB1 read T ;  $  TAB1 n, d are integers ;  $  TAB1 flag = boolean ;  $  TAB1 s = string ;  $  TAB1 while decrement T ;  $  TAB2 read n ;  $  TAB2 read s ;  $  TAB2 set flag to true ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 set d to s[i] - s[n - i - 1] ;  $  TAB3 if (d equals 0 or d equals 2 or d equals -2) is false ;  $  TAB4 set flag to false ;  $  TAB4 break ;  $  TAB2 if flag ;  $  TAB3 display YES ;  $  TAB2 else ;  $  TAB3 display NO ;
TAB1 n, m, a, b, x, y, flag are integers with flag = 0 ;  $  TAB1 read n, m ;  $  TAB1 c = character array of sizes n and m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j =0 to m exclusive ;  $  TAB3 read c[i][j] ;  $  TAB3 if c[i][j] is the character B and flag equals 0 ;  $  TAB4 set a to i ;  $  TAB4 set b to j ;  $  TAB4 set x to i ;  $  TAB4 set y to j ;  $  TAB4 set flag to 1 ;  $  TAB3 if c[i][j] is the character B and flag isn't 0 ;  $  TAB4 set x to i ;  $  TAB4 set y to j ;  $  TAB1 d = integer = (a + x) / 2, f = integer = (b + y) / 2 ;  $  TAB1 increment d ;  $  TAB1 increment f ;  $  TAB1 output d, " ", f ;
TAB1 let Hy, Ay, Dy be integers ;  $  TAB1 let Hm, Am, Dm be integers ;  $  TAB1 let Hs, As, Ds be integers ;  $  TAB1 read Hy, Ay, and Dy ;  $  TAB1 read Hm, Am, and Dm ;  $  TAB1 read Hs, As, and Ds ;  $  TAB1 let resp be an integer with resp = the maximum supported integer value ;  $  TAB1 let mas be an integer with mas = call max with arguments Hm + Dm - Ay + 1, 1 ;  $  TAB1 let maxi be an integer with maxi = call max with arguments Am - Dy, 1 ;  $  TAB1 let A, D, H be integers ;  $  TAB1 for i = 0 to 1000 inclusive ;  $  TAB2 for j = 0 to 1000 inclusive ;  $  TAB3 if (Ay + i) - (Dm) is at most 0, continue ;  $  TAB3 let P be an integer with P = 0 ;  $  TAB3 let r be an integer with r = Hm / ((Ay + i) - Dm) ;  $  TAB3 if Hm modulo ((Ay + i) - (Dm)) doesn't equal 0, increment r ;  $  TAB3 add (As * i) to P ;  $  TAB3 add (Ds * j) to P ;  $  TAB3 add call max (r * call max(Am - Dy - j, 0) - Hy + 1, 0) * Hs to P ;  $  TAB3 if P is less than resp ;  $  TAB4 assign P to resp ;  $  TAB4 assign i to A ;  $  TAB4 assign j to D ;  $  TAB4 assign (r * (Am - Dy)) to H ;  $  TAB1 if resp is negative ;  $  TAB2 display 0 ;  $  TAB1 display resp ;
TAB1 str1 and str2 are strings ;  $  TAB1 input str1 and str2 ;  $  TAB1 i is an integer set to 1 ;  $  TAB1 while str1[i] is less than str2[0], increment i ;  $  TAB1 display substring of str1 from index 0 to index i, str2[0] ;
TAB1 a, b are integers ;  $  TAB1 while read a, b ;  $  TAB2 x and y are integers with x = call min with a, b, y = 0 ;  $  TAB2 subtract x from a, subtract x from b ;  $  TAB2 set y to a / 2 + b / 2 ;  $  TAB2 output x, ' ', y ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 if n equals 20 ;  $  TAB2 print 15 ;  $  TAB1 else if n is greater than 10 and n is at most 21 ;  $  TAB2 print 4 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 if n == 0 ;  $  TAB2 print 1 ;  $  TAB1 let j be integer with j = n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if 1LL * i * i + 1LL * j * j <= 1LL * n * n, continue ;  $  TAB2 decrement j ;  $  TAB1 print (n+j) * 4 ;
TAB1 create int n, array a with a size of 100 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 create int mx = 0, ans ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = i to n exclusive ;  $  TAB3 assign 0 to ans ;  $  TAB3 for k = 0 to n exclsuvie ;  $  TAB4 if k greater than or equal to i and k less than or equal to j ;  $  TAB5 increase ans by not a[k] ;  $  TAB4 else ;  $  TAB5 increase ans by a[k] ;  $  TAB3 assign max(mx, ans) to mx ;  $  TAB1 print mx ;
TAB0 in function ord with parameter character x and return integer ;  $  TAB1 if x is the character ^ ;  $  TAB1 else if x is the character > ;  $  TAB2 return 1 ;  $  TAB1 else if x is the character v ;  $  TAB2 return 2 ;  $  TAB1 else if x is the character < ;  $  TAB2 return 3 ;  $  TAB1 return -1 ;  $  TAB1 let x and y be characters ;  $  TAB1 input x and y ;  $  TAB1 p = integer = call ord with x, q = integer = call ord with y, n = integer ;  $  TAB1 input n ;  $  TAB1 set n to n mod 4 ;  $  TAB1 cw and ccw are booleans both set to false ;  $  TAB1 if (p + n) mod 4 equals q, assign true to cw ;  $  TAB1 if (p + 8 - n) mod 4 equals q, assign true to ccw ;  $  TAB1 if cw and ccw ;  $  TAB2 output "undefined" ;  $  TAB1 else if cw ;  $  TAB2 output "cw" ;  $  TAB1 else if ccw ;  $  TAB2 output "ccw" ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let s be a string of length n ;  $  TAB1 read n values into array s ;  $  TAB1 let k be an integer set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if (s[i])[0] is the character I ;  $  TAB3 add 20 to k ;  $  TAB2 else if (s[i])[0] is the character D ;  $  TAB3 add 12 to k ;  $  TAB2 else if (s[i])[0] is the character O ;  $  TAB3 add 8 to k ;  $  TAB2 else if (s[i])[0] is the character C ;  $  TAB3 add 6 to k ;  $  TAB2 else ;  $  TAB3 add 4 to k ;  $  TAB1 print k ;
TAB1 n and m are integers ;  $  TAB1 read n and m ;  $  TAB1 a is an integer array of size 105 ;  $  TAB1 call memset with arguments a, 0, call sizeof with argument a ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare an integer x1 ;  $  TAB2 read x1 ;  $  TAB2 declare an integer y1 ;  $  TAB2 for j = 1 to x1 inclusive ;  $  TAB3 read y1 ;  $  TAB3 assign 1 to a[y1] ;  $  TAB1 judge is an integer set to 1 ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 if a[i] equals 0 ;  $  TAB3 set judge to 0 ;  $  TAB3 display NO ;  $  TAB3 break ;  $  TAB1 if judge, display YES ;
TAB0 create a constant integer N with N=110 ;  $  TAB0 a=array of integer of size N ;  $  TAB1 set all content of a to 0 ;  $  TAB1 n,d,i,j=integers ;  $  TAB1 read n,d ;  $  TAB1 read n values into array a ;  $  TAB1 sort array a ;  $  TAB1 create an integer count1=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=i to n exclusive ;  $  TAB3 if a[j] - a[i] <= d then set count1 = maximum of count1 and j - i + 1 ;  $  TAB1 print n - count1 ;
TAB1 let r, b = integers ;  $  TAB1 read r, b ;  $  TAB1 let mn = integer with value = min of r and b ;  $  TAB1 let mx = integer with value = max of r and b ;  $  TAB1 print mn and a space and (ma - mn) / 2 ;
TAB1 let n be a long long integer ;  $  TAB1 input n ;  $  TAB1 display 2 - (n modulo 2) ;
TAB0 a ,b = array of integer of size 101 ;  $  TAB1 create integer n,s,h1,m1,tt,flag,total,ans,i with flag=0,ans=0 and i=1 ;  $  TAB1 read n,s ;  $  TAB1 read n values into the array a and b ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set total = a[i] * 60 + b[i] ;  $  TAB2 if i=0 ;  $  TAB3 if s+1<=total ;  $  TAB4 print 0, " " and 0 ;  $  TAB2 if tt + 2 * s + 2 <= total ;  $  TAB3 set ans = tt + s + 1 ;  $  TAB3 print ans/60 ," " and ans mod 60 ;  $  TAB2 set tt=total ;  $  TAB1 set tt=tt+s+1 ;  $  TAB1 print tt/60, " ",tt mod 60 ;
TAB1 make int n ;  $  TAB1 read n ;  $  TAB1 while n decrement ;  $  TAB2 make int a ;  $  TAB2 read a ;  $  TAB2 if 360 modulo (180 - a) is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 n, m, a1, and a2 = integers ;  $  TAB1 read n and m ;  $  TAB1 a = array of integers with length 105, b = 2d array of integers, 105x105 with values set to 0 ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 while m > 0 while decrementing by 1 ;  $  TAB2 read a1 and a2 ;  $  TAB2 set b[a1][a2] to 1 ;  $  TAB1 minnum, num, kk = integers, with minnum set to 3000000, and kk set to 0 ;  $  TAB1 for i = 1 to n - 2 inclusive ;  $  TAB2 for j = i + 1 to n - 1 inclusive ;  $  TAB3 if b[i][j] is 1 or b[j][i] is 1 ;  $  TAB4 for k = j + 1 to n inclusive ;  $  TAB5 if b[i][k] is 1 or b[k][i] is 1, and b[j][k] is 1 or b[k][j] is 1 ;  $  TAB6 set num to a[i] + a[j] + a[k] ;  $  TAB6 set kk to 1 ;  $  TAB6 if num < minnum, set minnum to num ;  $  TAB1 if kk is 1 ;  $  TAB2 print minnum ;  $  TAB1 else ;  $  TAB2 print -1 ;
TAB0 create char arrays of size 5 each cw = {'v', '<', '^', '>'} and ccw = {'v', '>', '^', '<'} ;  $  TAB0 x,y = characters ;  $  TAB0 num,cws,ccws = ints ;  $  TAB1 read x, y and num ;  $  TAB1 for i=0 to 4 exclusive ;  $  TAB2 if x is equal to cw[i] then set cws=i ;  $  TAB2 if x is equal to ccw[i] then set ccws= i ;  $  TAB1 if y = cw[(num + cws) % 4] and y = ccw[(num + ccws) % 4 ;  $  TAB2 print undefined ;  $  TAB1 else if y = cw[(num + cws) % 4] ;  $  TAB2 print cw and a new line ;  $  TAB1 else if y = ccw[(num + ccws) % 4] ;  $  TAB2 print ccw ;  $  TAB1 else do the following ;  $  TAB2 print undefined ;
TAB1 make int n, k, t = 0, c = 0, x ;  $  TAB1 read n, k ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 assign x + t to x ;  $  TAB2 assign 0 to t ;  $  TAB2 if x less than or equal to 8 ;  $  TAB3 assign c + x to c ;  $  TAB2 else ;  $  TAB3 assign x - 8 to t ;  $  TAB3 assign c + 8 to c ;  $  TAB2 if c greater than or equal to k ;  $  TAB3 print i + 1 ;  $  TAB1 print -1 ;
TAB0 void find_it which takes an integer n ;  $  TAB1 req = integer set to n / 2 ;  $  TAB1 print req + 1 ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 run find_it with argument n ;
TAB0 define file which takes no arguments ;  $  TAB1 freopen of input.txt, r, stdin ;  $  TAB1 call freopen with output.txt, w, stdout ;  $  TAB0 define run ;  $  TAB1 let testCases, length be integers ;  $  TAB1 let falseLine be string ;  $  TAB1 read testcases ;  $  TAB1 call getline with cin and falseLine ;  $  TAB1 let str1 be array of strings of size testCases ;  $  TAB1 call getline with cin and first element of str1 ;  $  TAB1 set length to size of str1[0] ;  $  TAB1 let answer be integer with ans = 0 ;  $  TAB1 let breakFlag be bool with breakFlag = true ;  $  TAB1 for i = 1 to testCases ;  $  TAB2 set breakFlag to true ;  $  TAB2 call getline with cin and str1[i] ;  $  TAB2 while breakFlag is true ;  $  TAB3 if value of compare on str1[0] with 0, length, str1[i], 0, length is equal to 0 ;  $  TAB4 set answer to length ;  $  TAB4 set breakFlag to false ;  $  TAB3 else ;  $  TAB4 decrement length ;  $  TAB1 print out answer ;  $  TAB1 call run ;
TAB1 n, x, sum, a are integers with sum = 0 ;  $  TAB1 read n, x ;  $  TAB1 iterate n times ;  $  TAB2 read a ;  $  TAB2 add a to sum ;  $  TAB1 l = integer = absolute value (sum - 0) ;  $  TAB1 if l is divisible by x ;  $  TAB2 display 1 / x ;  $  TAB1 else ;  $  TAB2 display (1 / x) + 1 ;
TAB1 let n, c, and = integer with ans = 1 ;  $  TAB1 read n, c ;  $  TAB1 let a = array of integers of size n ;  $  TAB1 read n values into a ;  $  TAB1 for integer i=1 to n exclusive do the following ;  $  TAB2 if a[i[ - a[i-1] is less than or equal to c ;  $  TAB3 increment ans ;  $  TAB2 else ;  $  TAB3 set ans = 1 ;  $  TAB1 print ans ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a, b, acnt, bcnt, abcnt are integers with acnt = 0, bcnt = 0, abcnt = 0 ;  $  TAB1 iterate n times ;  $  TAB2 read a, b ;  $  TAB2 if a isn't even, increment acnt ;  $  TAB2 if b isn't even, increment bcnt ;  $  TAB2 if (a is even and b mod 2 equals 1) or (a mod 2 equals 1 and b is even), increment abcnt ;  $  TAB1 if (acnt + bcnt) isn't even ;  $  TAB2 output -1 ;  $  TAB1 else if both acnt and bcnt are even ;  $  TAB2 output 0 ;  $  TAB1 else ;  $  TAB2 if abnct is 0 ;  $  TAB3 output -1 ;  $  TAB2 else ;  $  TAB3 output 1 ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make list of strings L1 ;  $  TAB1 while n decrements ;  $  TAB2 make strings s and s1 ;  $  TAB2 read s and s1 ;  $  TAB2 add s1 to s ;  $  TAB2 swap s[2] and s[3] ;  $  TAB2 add s to itself ;  $  TAB2 push s onto L1 ;  $  TAB2 make characters c1 and c2 ;  $  TAB2 read c1 and c2 ;  $  TAB1 make iterator to list<string> p = L1.begin(), p1 ;  $  TAB1 for p; p is not equal to L1.end(); increment p ;  $  TAB2 set p1 to p ;  $  TAB2 increment p1 ;  $  TAB2 for p1; p1 is not equal to L1.end(); ;  $  TAB3 make string s2 = *p1, s3 = *p ;  $  TAB3 for i = 0 to 4 exclusive ;  $  TAB4 if s3.substr(0, 4) equals s2.susbtr(i , 4) ;  $  TAB5 L1.erase(p1 incremented) ;  $  TAB5 goto line1 ;  $  TAB3 increment p1 ;  $  TAB2 line1:; ;  $  TAB1 print L1 size ;
TAB0 declare an integer n ;  $  TAB0 declare a string t ;  $  TAB0 declare an integer k ;  $  TAB0 declare an integer ans_len ;  $  TAB0 declare a character array str of size 20 * 100010 ;  $  TAB0 declare an integer array chars of size 80 * 100010 ;  $  TAB0 in function push_up with parameter integer rt ;  $  TAB1 set chars[rt] to chars[rt shift bits left 1] + chars[r1 shift bits left 1 bitwise or 1] ;  $  TAB0 in function update with parameters integers L, R, left, right, rt ;  $  TAB1 if chars[rt] is at least right - left + 1 ;  $  TAB1 if left equals right ;  $  TAB2 assign 1 to chars[rt] ;  $  TAB2 assign t[left - L] to str[left] ;  $  TAB2 return ;  $  TAB1 if L is greater than right or R is less than left, return ;  $  TAB1 mid = integer = (left + right) shift bits left 1 ;  $  TAB1 if mid is at least R ;  $  TAB2 call update with arguments L, R, left, mid, rt shift bits left 1 ;  $  TAB1 else if mid is less than L ;  $  TAB2 call update with arguments L, R, mid + 1, right, rt shift bits left 1 bitwise or 1 ;  $  TAB1 else ;  $  TAB2 call update with arguments L, R, left, mid, rt shift bits left 1 ;  $  TAB2 call update with arguments L, R, mid + 1, right, rt shift bits left 1 bitwise or 1 ;  $  TAB1 call push_up with argument rt ;  $  TAB1 declare an integer pos ;  $  TAB1 declare an integer endpos ;  $  TAB1 input n ;  $  TAB1 assign 0 to ans_len ;  $  TAB1 for i = 1 to 2000010 exclusive, assign the character a to str[i] ;  $  TAB1 call memset with arguments chars, 0, call sizeof with argument chars ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input t and k ;  $  TAB2 for j = 1 to k inclusive ;  $  TAB3 input pos ;  $  TAB3 set endpos to pos + (the length of t) - 1 ;  $  TAB3 call update with arguments pos, endpos, 1, 2000010, 1 ;  $  TAB3 if j is equal to k ;  $  TAB4 if endpos is greater than ans_len, assign endpos to ans_len ;  $  TAB1 for i = 1 to ans_len inclusive, display str[i] ;  $  TAB1 print newline ;
TAB0 let inf be const int with inf = 2147483647 ;  $  TAB0 let MAX be const int with MAX = 1e5 + 10 ;  $  TAB0 let mod be const int with mode = 1e9 + 7 ;  $  TAB0 let n, m, ans, ma, mb be integers ;  $  TAB0 let h and book be array of integers of size MAX ;  $  TAB0 define Init ;  $  TAB1 set ma to 0 ;  $  TAB1 set mb to 0 ;  $  TAB1 set ans to 0 ;  $  TAB1 set all entries in book to 0 ;  $  TAB1 call Init ;  $  TAB1 read n and m ;  $  TAB1 for i = 1 to n, read h[i] ;  $  TAB1 call sort with h + 1 and h+n+1 ;  $  TAB1 let a, b, c be integers ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 read a, b, c ;  $  TAB2 if a is greater than 1, continue ;  $  TAB2 if b is equal to 1e9 ;  $  TAB3 increment ans by 1 ;  $  TAB3 continue ;  $  TAB2 let temp be integer with temp = (upper_bound of h+1, h+n+1, b) - h - 1 ;  $  TAB2 while element at index temp in book is not zero, decrement temp by 1 ;  $  TAB2 if temp is greater than or equal to 0, set book[temp] to 1 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if book[i] is not zero, add 1 to ans ;  $  TAB1 print out ans with newline ;
TAB1 create multidimensional char array wb of size 10x10 ;  $  TAB1 for i = 1 to 8 inclusive ;  $  TAB2 for j = 1 to 8 inclusive, read wb[i][j] ;  $  TAB1 create int judge = 1 ;  $  TAB1 for i = 1 to 8 inclusive ;  $  TAB2 for j = 1 to 7 inclusive ;  $  TAB3 if wb[i][j] equals wb[i][j + 1], set judge to 0 ;  $  TAB1 if judge equals 1 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 let a be an array of integers size 105 ;  $  TAB1 set integer sum1 to 0 ;  $  TAB1 set integer sum2 to 0 ;  $  TAB1 set integer cnt to 0 ;  $  TAB1 for i=0 to n exclusive do the following ;  $  TAB2 read a[i] ;  $  TAB2 sum = sum + a[i] ;  $  TAB1 call sort on a and a + n ;  $  TAB1 if n is 1 ;  $  TAB2 print 1 ;  $  TAB1 else do the following ;  $  TAB2 for i=n-1 to 0 decrementing i, do the following ;  $  TAB3 sum1 = sum1 - a[i] ;  $  TAB3 sum2 = sum2 + a[i] ;  $  TAB3 if sum2 is greater than or equal to sum1 ;  $  TAB4 increment cnt ;  $  TAB3 else ;  $  TAB4 exit the loop ;  $  TAB2 print cnt+1 ;
TAB1 s = string ;  $  TAB1 read s ;  $  TAB1 cont = integer = 0 ;  $  TAB1 tc = char = the character a ;  $  TAB1 for i = 0 to length of s exclusive ;  $  TAB2 a and b are integers ;  $  TAB2 assign tc to a ;  $  TAB2 assign s[i] to b ;  $  TAB2 if absolute value (a - b) is greater than 13 ;  $  TAB3 add 26 - absolute value (a - b) to cont ;  $  TAB2 else ;  $  TAB3 add absolute value (a - b) to cont ;  $  TAB2 set tc to s[i] ;  $  TAB1 print cont ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 define string m = "000" ;  $  TAB1 if s length is less than or equal to 6 ;  $  TAB2 print "no" ;  $  TAB1 else ;  $  TAB2 define int count = 0 ;  $  TAB2 define int flag = 0 ;  $  TAB2 define int flag_1 = 0 ;  $  TAB2 reverse s ;  $  TAB2 for i = 0 to s length exclusive ;  $  TAB3 if s[i] equals 48 then increment count ;  $  TAB3 if count equals 6 ;  $  TAB4 set flag_1 to i ;  $  TAB4 break ;  $  TAB2 for i = flag_1 to length of s exclusive ;  $  TAB3 if s[i] equals 49 and count equals 6 then set flag to 1 ;  $  TAB2 if flag is equal to 1 ;  $  TAB3 print "yes" ;  $  TAB2 else ;  $  TAB3 print "no" ;
TAB0 let maxn = integer constant with value 501000 ;  $  TAB0 let a = array of integers of size maxn ;  $  TAB0 let b = array of integers of size maxn ;  $  TAB1 let n1, n2 = integers ;  $  TAB1 let k, m = integers ;  $  TAB1 read n1, n2, k, m = integers ;  $  TAB1 read n1 values into array a ;  $  TAB1 read n2 values into array b ;  $  TAB1 call sort on a +1 and a + n1 + 1 ;  $  TAB1 call sort on b + 1 and b + n2 + 1 and greater function ;  $  TAB1 if a[k] is less than b[m] ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 declare an integer n ;  $  TAB1 input n ;  $  TAB1 resp1 and resp2 are both integers both set to 0 ;  $  TAB1 iterate n times ;  $  TAB2 declare an integer x ;  $  TAB2 input x ;  $  TAB2 set resp1 to resp1 or x ;  $  TAB1 iterate n times ;  $  TAB2 declare an integer x ;  $  TAB2 input x ;  $  TAB2 set resp2 to resp2 or x ;  $  TAB1 display resp1 + resp2 ;
TAB0 create const int TAM = 1e3 + 3 ;  $  TAB0 create int n ;  $  TAB0 create int array arr of length 105 ;  $  TAB0 in function gcd, returning int and having int a and int b as parameters ;  $  TAB1 if a is greater than b, swap a and b ;  $  TAB1 if not a, return b ;  $  TAB1 return gcd(b mod a, a) ;  $  TAB0 in function dvs ;  $  TAB1 create int val = arr[0] ;  $  TAB1 for i = 1 to n exclusive, set val to gcd of val and arr[i] ;  $  TAB1 for i = 0 to n exclusive, set arr[i] to arr[i] / val ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read arr[i] ;  $  TAB1 sort arr from element 0 to n ;  $  TAB1 dvs() ;  $  TAB1 if arr[n - 1] - n is odd ;  $  TAB2 print "Alice\n" ;  $  TAB1 else ;  $  TAB2 print "Bob\n" ;
TAB1 create long long n, t, a, temp = 1, i ;  $  TAB1 create vector v holding long long ;  $  TAB1 read n and t ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 read a ;  $  TAB2 push a into v ;  $  TAB1 while temp is less than or equal to n ;  $  TAB2 if temp is t ;  $  TAB3 print "YES" ;  $  TAB2 if temp is greater than t then break ;  $  TAB2 set temp to temp + v[temp - 1] ;  $  TAB1 print "NO" ;
TAB0 let s = string ;  $  TAB0 let s1, s2 = integers and l, r arrays of integers size 1000001 ;  $  TAB0 declare function enter ;  $  TAB1 read s ;  $  TAB0 declare function solve ;  $  TAB1 for integer i=0 to length of s exclusive do the following ;  $  TAB2 if s[i] is 1 increment s1 and set l[s1] = i + 1 ;  $  TAB2 if s[i] is r increment s2 and set r[s2] = i + 1 ;  $  TAB1 for integer i=1 to s2 inclusive print r[i] and a new line ;  $  TAB1 for integer i=s1 to 1 inclusive decrementing print l[i] and a new line ;  $  TAB1 call enter ;  $  TAB1 call solve ;
TAB1 w, h, u1, d1, u2, d2, w1 are integers ;  $  TAB1 read w, h ;  $  TAB1 read u1, d1 ;  $  TAB1 read u2, d2 ;  $  TAB1 assign w + h to w1 ;  $  TAB1 if (h equals d1) and (w1 is greater than u1) ;  $  TAB2 set w1 to w1 - u1 ;  $  TAB1 else if (h equals d1) and (w1 is less than u1) ;  $  TAB2 set w1 to 0 ;  $  TAB1 else if (h equals d2) and (w1 is greater than u2) ;  $  TAB2 set w1 to w1 - u2 ;  $  TAB1 else if (h equals d2) and (w1 < u2) ;  $  TAB2 set w1 to 0 ;  $  TAB1 decrement h ;  $  TAB1 while h is positive ;  $  TAB2 add h to w1 ;  $  TAB2 if (h equals d1) and (w1 is at least u1) ;  $  TAB3 subtract u1 from w1 ;  $  TAB2 else if (h equals d1) and (w1 is less than u1) ;  $  TAB3 set w1 to 0 ;  $  TAB2 else if (h equals d2) and (w1 is at least u2) ;  $  TAB3 subtract u2 from w1 ;  $  TAB2 else if (h equals d2) and (w1 is less than u2) ;  $  TAB3 set w1 to 0 ;  $  TAB2 decrement h ;  $  TAB1 display w1 ;
TAB1 a,b,c=integer ;  $  TAB1 while a,b,c entered are valid ;  $  TAB2 while c is true decrement c do the following ;  $  TAB3 if a>b ;  $  TAB4 set a=a^b ;  $  TAB4 set b=b^a ;  $  TAB4 set a=a^b ;  $  TAB3 increment a ;  $  TAB2 if a>b ;  $  TAB3 set a=a^b ;  $  TAB3 set b=b^a ;  $  TAB3 set a=a^b ;  $  TAB2 print a*2 ;
TAB1 matrix = integer ;  $  TAB1 diamond = string set to "D" ;  $  TAB1 up, down = strings set to "" ;  $  TAB1 read matrix ;  $  TAB1 if matrix is 0, return 0 ;  $  TAB1 for counter = 0 to matrix / 2 exclusive, increment up by "*" ;  $  TAB1 once = boolean set to true ;  $  TAB1 while true ;  $  TAB2 if up isn't "" ;  $  TAB3 read up, diamond, up ;  $  TAB3 increment diamond by "DD" ;  $  TAB3 erase 0 and 1 of up ;  $  TAB2 else ;  $  TAB3 if once is truthy, print up, diamond, up ;  $  TAB3 set once to false ;  $  TAB3 increment down by "*" ;  $  TAB3 erase 0 and 2 of diamond ;  $  TAB3 erase 0 and 2 of up ;  $  TAB3 if diamond is "", break ;  $  TAB3 print down, diamond, down ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 print home and newline if n&1 is 0 else print contest ;
TAB1 s=string ;  $  TAB1 create a long long integer c with c=26 ;  $  TAB1 read s ;  $  TAB1 create integer len= size of s ;  $  TAB1 set c=c +25 * len ;  $  TAB1 print c ;
TAB1 let n, num = integers ;  $  TAB1 let v = vector of integers ;  $  TAB1 read n, num ;  $  TAB1 forinteger i=0 to n exclusive do the following ;  $  TAB2 let a = integer ;  $  TAB2 read a ;  $  TAB2 append a to v ;  $  TAB1 call sort on beginning of v and end of v ;  $  TAB1 let sz, temp = integers with sz = size of v and temp = num ;  $  TAB1 if num is greater than v[sz] return (print 0 \n 0) ;  $  TAB1 ifnum is v[sz] return ( print 1 \n 0) ;  $  TAB1 while v[sz] is greater than or equal to temp do the following ;  $  TAB2 decrement v[sz] ;  $  TAB2 increment temp ;  $  TAB2 call sort on beginning of v and end of v ;  $  TAB1 print temp - num ;
TAB1 declare integers n, a, b, c, s1, s2 ;  $  TAB1 read a, b, and c ;  $  TAB1 assign a + b + c to s1 ;  $  TAB1 read a, b, and c ;  $  TAB1 assign a + b + c to s2 ;  $  TAB1 read n ;  $  TAB1 subtract (s1 / 5) from n ;  $  TAB1 set s1 to s1 mod 5 ;  $  TAB1 if s1, decrement n ;  $  TAB1 subtract (s2 / 10) from n ;  $  TAB1 set s2 to s2 mod 10 ;  $  TAB1 if s2, decrement n ;  $  TAB1 if n is at least 0 ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB0 sz and p = long long constant integers with sz set to 1e5 + 5, and p set to 998244353 ;  $  TAB0 a and c = arrays of integers with length sz ;  $  TAB1 n, m, i, j = integers ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive, read c[i] ;  $  TAB1 for i = 0 to m exclusive, read a[i] ;  $  TAB1 ans = integer set to 0 ;  $  TAB1 set j to 0 ;  $  TAB1 for i = 0, while i < n and j < m, ;  $  TAB2 if c[i] <= a[j] ;  $  TAB3 increment ans by 1 ;  $  TAB3 increment j by 1 ;  $  TAB1 print ans ;
TAB1 declare string s ;  $  TAB1 declare int n, k ;  $  TAB1 read n and k ;  $  TAB1 read s ;  $  TAB1 define int array a of length 26, all elements set to 0 ;  $  TAB1 for t = 0 to n exclusive: increment a[s[t] - 'a'] ;  $  TAB1 define int flag = 0 ;  $  TAB1 for t = 0 to 26 exclusive ;  $  TAB2 if a[t] > k: set flag to 1 ;  $  TAB1 if flag ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB1 n, k are integers ;  $  TAB1 str is a string ;  $  TAB1 read n, k ;  $  TAB1 read str ;  $  TAB1 tmp is an integer initialized to k ;  $  TAB1 mid is an integer initialized to n / 2 ;  $  TAB1 if n mod 2 is 1, increment mid ;  $  TAB1 dir is an integer initialized to 1 ;  $  TAB1 end is an integer initialized to n ;  $  TAB1 numPrinted is an integer initialized to 0 ;  $  TAB1 if tmp is less than mid ;  $  TAB2 set dir to -1 ;  $  TAB2 set end to 1 ;  $  TAB1 if n is even and tmp equals mid ;  $  TAB2 set dir to -1 ;  $  TAB2 set end to 1 ;  $  TAB1 if tmp equals 1 ;  $  TAB2 set end to 1 ;  $  TAB2 set dir to -1 ;  $  TAB1 if tmp equals n ;  $  TAB2 set end to n ;  $  TAB2 set dir to 1 ;  $  TAB1 while tmp isn't end ;  $  TAB2 if tmp is greater than end ;  $  TAB3 display LEFT ;  $  TAB2 else ;  $  TAB3 display RIGHT ;  $  TAB2 add dir to tmp ;  $  TAB1 if end equals 1 ;  $  TAB2 set end to n ;  $  TAB1 else ;  $  TAB2 set end to 1 ;  $  TAB1 while tmp isn't end ;  $  TAB2 display PRINT, str[tmp - 1] ;  $  TAB2 if tmp is greater than end ;  $  TAB3 display LEFT ;  $  TAB2 else ;  $  TAB3 display RIGHT ;  $  TAB2 subtract dir from tmp ;  $  TAB1 display PRINT, str[tmp - 1] ;
TAB1 i, n, c, ans are integers with ans set to 0 ;  $  TAB1 a, b are strings ;  $  TAB1 read n ;  $  TAB1 read a, b ;  $  TAB1 set c to size of a ;  $  TAB1 for i = 0 to c exclusive, add call min with(10 - absolute value (a[i] - b[i]), absolute value (a[i] - b[i]) to ans ;  $  TAB1 display ans ;
TAB1 declare doubles k, n, s, p ;  $  TAB1 read k, n, s, p ;  $  TAB1 sheetsPerPerson is a double with sheetsPerPerson = ceiling with argument (n / s) ;  $  TAB1 totalSheets is a double with totalSheets = sheetsPerPerson * k ;  $  TAB1 pack is a double with pack = ceiling with argument (totalSheets / p) ;  $  TAB1 display fixed, pack cast as long long ;
TAB0 let N, K, and, val = integers with ans = 2000000000 ;  $  TAB1 read N ;  $  TAB1 for integer i=1 to N inclusive do the following ;  $  TAB2 read K ;  $  TAB2 if K is less than ans do the following ;  $  TAB3 set ans = K ;  $  TAB3 set val = I ;  $  TAB2 else if K is less than ans do the following ;  $  TAB3 set val = 0 ;  $  TAB1 if val is 0 ;  $  TAB2 print Still Rozdil ;  $  TAB1 else ;  $  TAB2 print val ;
TAB0 let INF be const long long with INF = 9223372036854775807LL ;  $  TAB0 let PI be const long double with PI = acos of -1 ;  $  TAB0 let MAX_N be const integer with MAX_N = 1e+6 ;  $  TAB0 let ALPH be const integer with ALPH = 26 ;  $  TAB0 let alph be const string with alph = "abcdefghijklmnopqrstuvwxyz" ;  $  TAB0 define count which takes integer pos, string s and integer xd as arguments ;  $  TAB1 let l be integer with l = size of s ;  $  TAB1 while pos is less than l ;  $  TAB2 if element at index pos in s is equal to '|' ;  $  TAB3 increment xd ;  $  TAB3 increment pos ;  $  TAB2 else ;  $  TAB3 break ;  $  TAB1 increment pos ;  $  TAB0 define print which takes integer a, b, and c as argument ;  $  TAB1 for i = 0 to a exclusive, print out | ;  $  TAB1 print + ;  $  TAB1 for i = 0 to b exclusive, print | ;  $  TAB1 print = ;  $  TAB1 for i = 0 to c exclusive, print | ;  $  TAB1 print out newline ;  $  TAB0 define check which takes integer a, b, c as arguments ;  $  TAB1 if a is less than or equal to 0 or b is less than or equal to 0 or c is less than or equal to 0, return false ;  $  TAB1 return a + b is equal to c ;  $  TAB0 define solve ;  $  TAB1 let s be string ;  $  TAB1 read s ;  $  TAB1 let l be integer with l = size of s ;  $  TAB1 let a, b, c be integers ;  $  TAB1 set a = b = c = 0 ;  $  TAB1 let pos be integer with pos = 0 ;  $  TAB1 call count with pos, s, a ;  $  TAB1 call count with pos, s, b ;  $  TAB1 call count with pos, s, c ;  $  TAB1 if a + b is equal to c ;  $  TAB2 call print with a, b, c ;  $  TAB1 else ;  $  TAB2 if check of a + 1, b - 1, c is not equal to 0 ;  $  TAB3 call print of a + 1, b - 1, c ;  $  TAB3 return ;  $  TAB2 if check of a + 1, b, c - 1 is not equal to 0 ;  $  TAB3 cal print of a + 1, b, c-1 ;  $  TAB3 return ;  $  TAB2 if check of a-1, b+1, c is not equal to 0 ;  $  TAB3 call print of a-1, b+1, c ;  $  TAB3 return ;  $  TAB2 if check of a, b+1, c-1 is not equal to 0 ;  $  TAB3 call print of a, b+1, c-1 ;  $  TAB3 return ;  $  TAB2 if check of a-1, b, c+1 is not equal to 0 ;  $  TAB3 call print of a-1, b, c+1 ;  $  TAB3 return ;  $  TAB2 if check of a, b-1, c+1 is not equal to 0 ;  $  TAB3 call print of a, b-1, c+1 ;  $  TAB3 return ;  $  TAB2 print out Impossible with newline ;  $  TAB1 let t be integer with t = 1 ;  $  TAB1 while t is greater than zero, decrement t and call solve ;
TAB0 let arr = array of integers of size 4 ;  $  TAB1 let diff, i = integers ;  $  TAB1 read n values into arr ;  $  TAB1 call sort arr and arr + 3 ;  $  TAB1 set diff = arr[2] - arr[0] + arr[1] ;  $  TAB1 if diff is greater than or equal to 0 ;  $  TAB2 print diff ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 if n less than or equal to 10 OR n greater than or equal to 22 ;  $  TAB2 print 0 ;  $  TAB1 else if n is 21 or n less than 20 ;  $  TAB2 print 4 ;  $  TAB1 else if n is 20 ;  $  TAB2 print 15 ;
TAB1 x = integer ;  $  TAB1 input x ;  $  TAB1 a = integer = 0 ;  $  TAB1 iterate the following ;  $  TAB2 if x is equal to 0, break ;  $  TAB2 set a to a + x mod 2 ;  $  TAB2 set x to x / 2 ;  $  TAB1 output a ;
TAB0 let a = array of integers of size 1000010 ;  $  TAB0 let inf = integer constant with value hexadecimal 3f3f3f3f ;  $  TAB1 let n = integer ;  $  TAB1 while (read n) is true do the following ;  $  TAB2 let a, b = arrays of integers of size 310 ;  $  TAB2 read a[0] ;  $  TAB2 let m = integer of value 0 ;  $  TAB2 for integer i=1 to n exclusive do the following ;  $  TAB3 read a[i] ;  $  TAB3 set b[i] = a[i] - a[i-1] ;  $  TAB3 if b[i] is greater than m set m = b[i] ;  $  TAB2 let mi = integer with mi = inf ;  $  TAB2 for integer i=1 to n exclusive do the following ;  $  TAB3 set b[i] = b[i] + b[i+1] ;  $  TAB3 if b[i] is less than mi set mi = b[i] ;  $  TAB2 if mi is greater than m ;  $  TAB3 print mi ;  $  TAB2 else ;  $  TAB3 print m ;
TAB0 in function even, return type of boolean, parameter int number ;  $  TAB1 if number mod 2 equals 0 ;  $  TAB2 return true ;  $  TAB1 else ;  $  TAB2 return false ;  $  TAB1 create int x, y, differentSocks, sameSocks, remainings ;  $  TAB1 read x and y ;  $  TAB1 if x less than y ;  $  TAB2 assign x to differentSocks ;  $  TAB2 assign y - x to remainings ;  $  TAB2 if even(remainings) ;  $  TAB3 assign remainings / 2 to sameSocks ;  $  TAB2 else ;  $  TAB3 assign (remainings - 1) / 2 to sameSocks ;  $  TAB1 else if x greater than y ;  $  TAB2 assign y to differentSocks ;  $  TAB2 assign x - y to remainings ;  $  TAB2 if even(remainings) ;  $  TAB3 assign remainings / 2 to sameSocks ;  $  TAB2 else ;  $  TAB3 assign (remainings - 1) / 2 to sameSocks ;  $  TAB1 else ;  $  TAB2 assign x to differentSocks ;  $  TAB2 assign 0 to sameSocks ;  $  TAB1 print differentSocks " " sameSocks ;
TAB0 create integer arrays alr, ar, br, all with a size of 6 and initialized to 0 ;  $  TAB1 create integers n and a ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 increment ar[a] ;  $  TAB2 increment alr[a] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 increment br[a] ;  $  TAB2 increment alr[a] ;  $  TAB1 create long long ans = 0 ;  $  TAB1 for i = 1 to 6 exclusive ;  $  TAB2 if alr[i] mod 2 is not equal to 0 then set ans to -2 ;  $  TAB1 if ans is not equal to -2 ;  $  TAB2 for i = 1 to 6 exclusive do add abs(alr[i] / 2 - ar[i]) to ans ;  $  TAB1 print ans / 2 ;
TAB1 let n, x, y, a be long long with x and y = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 set x to bitwise or of x and a ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 set y to bitwise or of y and a ;  $  TAB1 print out x + y ;
TAB1 let i, j, k, rest, n be long long integers ;  $  TAB1 let ch, ch1 be characters ;  $  TAB1 read n, k ;  $  TAB1 assign n - k to rest ;  $  TAB1 assign the character a to ch ;  $  TAB1 iterate k times ;  $  TAB2 print ch ;  $  TAB2 add 1 to ch ;  $  TAB1 assign the character a to ch1 ;  $  TAB1 for i = 0, j = 0 as long as i is less than rest with increment i, increment j ;  $  TAB2 print ch1 ;  $  TAB2 add 1 to ch1 ;  $  TAB2 if j equals k ;  $  TAB3 assign the character a to ch1 ;  $  TAB3 assign 0 to j ;  $  TAB1 print newline ;
TAB0 mod = constant long long = 998244353 ;  $  TAB0 maxn = constant integer = 2e5 ;  $  TAB1 t = integer ;  $  TAB1 n, a, b, c are long longs ;  $  TAB1 read n ;  $  TAB1 read a, b, c ;  $  TAB1 one, two are long longs with one = a, two = b - c ;  $  TAB1 sum1 = long long = n / one, yu1 = long long = n mod 1, ci = long long ;  $  TAB1 while yu1 / b is positive ;  $  TAB2 set ci to (yu1 - c) / 2 ;  $  TAB2 set yu1 to yu1 - ci * two ;  $  TAB2 add ci to sum1 ;  $  TAB1 yu2 = long long = n, sum2 and ans are long longs both set to 0 ;  $  TAB1 while yu2 / b is positive ;  $  TAB2 set ci to (yu2 - c) / two ;  $  TAB2 set yu2 to yu2 - ci * two ;  $  TAB2 add ci to sum2 ;  $  TAB1 add yu2 / one to sum2 ;  $  TAB1 set yu2 to yu2 mod one ;  $  TAB1 set ans to call max with ans, sum2 ;  $  TAB1 set ans to call max with sum1, ans ;  $  TAB1 print ans ;
TAB0 in function gcd with parameters long longs a, b and return long long ;  $  TAB1 return a if b equals 0, otherwise return call gcd with b, a mod b ;  $  TAB0 in function lcm with parameters long long a, b and return long long ;  $  TAB1 return a * (b / call gcd with a, b) ;  $  TAB1 a, b are long longs ;  $  TAB1 read a, b ;  $  TAB1 time = long long = 0 ;  $  TAB1 ta, tb are long longs both set to 0 ;  $  TAB1 l = long long = call lcm with a, b ;  $  TAB1 while time is less than1 ;  $  TAB2 da = long long = a - (time mod a) ;  $  TAB2 db = long long = b - (time mod b) ;  $  TAB2 if da is less than tb ;  $  TAB3 add da to ta ;  $  TAB3 add da to time ;  $  TAB2 else if db is less than da ;  $  TAB3 add db to tb ;  $  TAB3 add db to time ;  $  TAB2 else ;  $  TAB3 if a is less than b ;  $  TAB4 add da to time ;  $  TAB4 add da to tb ;  $  TAB3 else ;  $  TAB4 add da to time ;  $  TAB4 add da to ta ;  $  TAB1 if ta is less than tb, output Masha and terminate statement, if ta equals tb, output Equal and terminate statement, else output Dasha ;
TAB1 let t = integer ;  $  TAB1 read t ;  $  TAB1 while (decrement t) is true do the following ;  $  TAB2 let n,r,s = integers where s=0 ;  $  TAB2 read n, r ;  $  TAB2 for integer i=1 to n exclusive read x, s = s + x ;  $  TAB2 print ((r - s) % n + n) % n + 1 ;
TAB1 TESTS is an integer set to 1 ;  $  TAB1 while decrement TESTS ;  $  TAB2 n, k are long longs ;  $  TAB2 read n, k ;  $  TAB2 v is a long long integer vector ;  $  TAB2 c is a long long set to 0 ;  $  TAB2 iterate n times ;  $  TAB3 declare a long long x ;  $  TAB3 input x ;  $  TAB3 append x to v ;  $  TAB2 for long long i = 0 to n exclusive ;  $  TAB3 if v[i] is positive and v[i] is at least v[k - 1], increment c ;  $  TAB2 display c ;
TAB0 create string a, b ;  $  TAB0 create int n ;  $  TAB1 read a and b ;  $  TAB1 read n ;  $  TAB1 print a ' ' b ;  $  TAB1 create string resa = a, resb = b ;  $  TAB1 while n decremented is not 0 ;  $  TAB2 read a and b ;  $  TAB2 if a equals resa ;  $  TAB3 print b ' ' resb ;  $  TAB3 resa = b ;  $  TAB2 else ;  $  TAB3 print resa ' ' b ;  $  TAB3 resb = b ;
TAB0 in function solve ;  $  TAB1 n, i, j, x are long longs ;  $  TAB1 read n, x ;  $  TAB1 sum and temp are long longs with sum = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read temp ;  $  TAB2 add temp to sum ;  $  TAB1 ans = long long ;  $  TAB1 if absolute value (sum) mod x equals 0 ;  $  TAB2 set ans to absolute value (sum) / x ;  $  TAB1 else ;  $  TAB2 set ans to absolute value (sum) / x + 1 ;  $  TAB1 display ans ;  $  TAB1 t = long long = 1 ;  $  TAB1 while decrement t, call solve ;
TAB1 a and b are long longs ;  $  TAB1 input a and b ;  $  TAB1 for long long i = 1 to 7 exclusive ;  $  TAB2 assign 3 * a to a ;  $  TAB2 assign 2 * b to b ;  $  TAB2 if a is less than b ;  $  TAB3 display i ;  $  TAB3 break ;
TAB0 in function cl that takes integer a and return integer ;  $  TAB1 ans = integer = 0 ;  $  TAB1 while a ;  $  TAB2 if a modulo 10 is equal to either 4 or 7, increment ans ;  $  TAB2 assign a / 10 to a ;  $  TAB1 return ans ;  $  TAB1 n, k are integers ;  $  TAB1 input n, k ;  $  TAB1 cnt = integer = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare integer a ;  $  TAB2 input a ;  $  TAB2 if call function cl with argument a is less than or equal to k, increment cnt ;  $  TAB1 display cnt ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 let x be a pair from int to int with size 1000 ;  $  TAB1 let a and b be integers with a=b=0 ;  $  TAB1 read n values into array x.first and x.second ;  $  TAB1 create integers a1,a2,a3,a4 ;  $  TAB1 set a1=a2=a3=a4=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to n exclusive ;  $  TAB3 if x[i].first > x[j].first and x[i].second = x[j].second ;  $  TAB4 if a1=0 then add 1 to a ;  $  TAB4 set a1 to a1+1 ;  $  TAB3 else if x[i].first < x[j].first and x[i].second = x[j].second ;  $  TAB4 if a2=0 then increment a ;  $  TAB4 increment a2 ;  $  TAB3 else if x[i].first = x[j].first and x[i].second < x[j].second ;  $  TAB4 if a3= 0 then add 1 to a ;  $  TAB4 add 1 to a3 ;  $  TAB3 if x[i].first = x[j].first and x[i].second > x[j].second ;  $  TAB4 if a4 is 0 then add 1 to a ;  $  TAB4 add 1 to a4 ;  $  TAB2 if a=4, then add 1 to b ;  $  TAB2 set a=a1=a2=a3=a4=0 ;  $  TAB1 print b ;
TAB0 n, k = integer ;  $  TAB1 read n and k ;  $  TAB1 set k to 240 - k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if i * 5 > k ;  $  TAB3 print i - 1 ;  $  TAB2 subtract i * 5 from k ;  $  TAB1 print n ;
TAB1 x1, x2, x3 = integers ;  $  TAB1 read x1, x2, x3 ;  $  TAB1 set sum = integer, value = sqrt((x1 * x3) / x2) + sqrt((x2 * x1) / x3) + sqrt((x3 * x2) / x1) ;  $  TAB1 set sum = sum * 4 ;  $  TAB1 print sum ;
TAB1 create long long int c, n, N = 1 ;  $  TAB1 read n ;  $  TAB1 read c ;  $  TAB1 create dynamically allocated int array t of size n ;  $  TAB1 read n values into t ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if t[i] - t[i - 1] <= c ;  $  TAB3 increment N ;  $  TAB2 else ;  $  TAB3 N = 1 ;  $  TAB1 print N ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 let r, l = vectors in integers ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 if s[i] is R ;  $  TAB3 append i to r ;  $  TAB2 else ;  $  TAB3 append i to l ;  $  TAB1 let v = array of integers of size n ;  $  TAB1 read n values into array v ;  $  TAB1 let k1, k2, min = integers with min = maximum value of integer ;  $  TAB1 while k1 is less than size of r and k2 is less than size of l do the following ;  $  TAB2 if r[k1] is less than l[k2] do the following ;  $  TAB3 letnum = (v[l[k2]] - v[r[k1]]) / 2 ;  $  TAB3 if num is less than min set min = num ;  $  TAB3 increment k1 ;  $  TAB2 else ;  $  TAB3 increment k2 ;  $  TAB1 if min is INT_MAXX ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print min ;
TAB1 n, m, a, d, i, j, r, x, y are long longs with r = 0 ;  $  TAB1 read n, m, a, d ;  $  TAB1 v = long long vector of size m + 1 ;  $  TAB1 for i = 1 to m inclusive, read v[i] ;  $  TAB1 set i to j to 1 ;  $  TAB1 set x to (d / a) + 1 ;  $  TAB1 while i is at most m and j is at most n ;  $  TAB2 set y to j * a ;  $  TAB2 if v[i] is greater than y ;  $  TAB3 set y to ((call min with n * a, v[i]) - y) / a ;  $  TAB3 set y to (y / x) + 1 ;  $  TAB3 add y to r, add x * y to j ;  $  TAB3 set y to (j - x) * a + d + 1 ;  $  TAB3 while i is at most m and v[i] is less than y, increment i ;  $  TAB2 else ;  $  TAB3 increment r ;  $  TAB3 set y to v[i] + d ;  $  TAB3 while i is at most m and v[i] is at most y, increment i ;  $  TAB3 set j to (y / a) + 1 ;  $  TAB1 while i is at most m ;  $  TAB2 increment r ;  $  TAB2 set y to v[i] + d ;  $  TAB2 while i is at most m and v[i] is at most y, increment i ;  $  TAB1 if j is at most n ;  $  TAB2 assign n - j to j ;  $  TAB2 add (j / x) + 1 to r ;  $  TAB1 display r ;
TAB1 create long long t, s, q, load, count = 1 ;  $  TAB1 read t, s, q ;  $  TAB1 set load to s * q ;  $  TAB1 while load is less than t ;  $  TAB2 set load to load * q ;  $  TAB2 increment count ;  $  TAB1 print count ;
TAB1 table = string ;  $  TAB1 let has = map from char to int ;  $  TAB1 while (read table) is true do the following ;  $  TAB2 clear has to size 0 ;  $  TAB2 for i = 0 to size of table exclusive, increment has[table[i]] ;  $  TAB2 let flag = boolean with flag = false ;  $  TAB2 hand = string ;  $  TAB2 for i = 1 to 5 inclusive do the following ;  $  TAB3 read hand ;  $  TAB3 for i = 0 to 2 exclusive ;  $  TAB4 if has[hand[i]] is not equal to 0 set flag to true ;  $  TAB2 if flag is true ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 let a, b = integers ;  $  TAB1 read a, b ;  $  TAB1 let c = integer wwith value = 0 ;  $  TAB1 while b is true do the following ;  $  TAB2 set c = c * 10 + b modulo 10 ;  $  TAB2 set b = b / 10 ;  $  TAB1 print a + c ;
TAB1 n,m,l,r = integers ;  $  TAB1 s = string ;  $  TAB1 c1,c2 = chars ;  $  TAB1 read n and m ;  $  TAB1 read s ;  $  TAB1 for i=0 until i is not equal to m ;  $  TAB2 read l,r,c1,c2 ;  $  TAB2 decrement l ;  $  TAB2 for i=l until i is not equal to r ;  $  TAB3 if s[i] = c1 then assign c2 to s[i] ;  $  TAB1 print s and new line ;
TAB1 create set sett holding ints ;  $  TAB1 create int year ;  $  TAB1 while read year ;  $  TAB2 while true ;  $  TAB3 increment year ;  $  TAB3 create int x = year mod 10 ;  $  TAB3 create int y = year / 10 ;  $  TAB3 create int z = y mod 10 ;  $  TAB3 create int a = y / 10 ;  $  TAB3 create int b = a mod 10 ;  $  TAB3 create int c = a / 10 ;  $  TAB3 create int d = c mod 10 ;  $  TAB3 create int e = c / 10 ;  $  TAB3 insert d into sett ;  $  TAB3 insert b into sett ;  $  TAB3 insert z into sett ;  $  TAB3 insert x into sett ;  $  TAB3 if d not equals b and d not equals z and d not equals x and b not equals z and b not equals x and z not equals x then break ;  $  TAB2 print year ;
TAB1 make long long n, k, s, i ;  $  TAB1 while reading n and k ;  $  TAB2 assign k / n to i ;  $  TAB2 assign k modulo n to s ;  $  TAB2 if s greater than 0 then assign i + 1 to i ;  $  TAB2 print i ;
TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 create integer n = number of 'o' present in string s ;  $  TAB1 if n is greater than 0 ;  $  TAB2 print YES if size of s mod n is 0 else print NO ;  $  TAB1 else do the following ;  $  TAB2 print YES ;
TAB1 x, t, a, b, da, db= imntegers ;  $  TAB1 read x, t, a, b, da, db ;  $  TAB1 create an integr l with l=b ;  $  TAB1 create an integer flag =0 ;  $  TAB1 if x=0 set flag=1 ;  $  TAB1 for i=0 to t exclusive ;  $  TAB2 set b=l ;  $  TAB2 for j=0 to t exclusive ;  $  TAB3 if x = a + b or x = a or x = b ;  $  TAB4 set flag=1 ;  $  TAB4 break ;  $  TAB3 set b=b-db ;  $  TAB2 set a=a-da ;  $  TAB1 if flag=1 ;  $  TAB2 print YES ;  $  TAB1 else do the following ;  $  TAB2 print NO ;
TAB0 create constant integer maxn = 105 ;  $  TAB0 v= integer array of size maxn ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 read n values into the array v from 1 to n ;  $  TAB1 create integer act1 = 1 ;  $  TAB1 create integer act2 = 2 ;  $  TAB1 create integer spect = 3 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if v[i] is equal to spect ;  $  TAB3 print NO ;  $  TAB4 print new line ;  $  TAB2 if act1 is equal to v[i] ;  $  TAB3 swap values of act2 and spect ;  $  TAB2 else if act2 is equal to v[i] ;  $  TAB3 swap values of act1 and spect ;  $  TAB1 print YES ;  $  TAB2 print new line ;
TAB0 let arr = array of integers of size 100005 and has = integer ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 if i is 1 do the following ;  $  TAB3 read arr[1] ;  $  TAB3 set has = 1 ;  $  TAB2 else do the following ;  $  TAB3 read arr[i] ;  $  TAB3 if arr[i] is less than arr[has] set has = i ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 if i is not equal to has do the following ;  $  TAB3 if arr[i] is arr[has] do the following ;  $  TAB4 print Still Rozdil ;  $  TAB4 exit the program with status 0 ;  $  TAB1 print has ;
TAB0 p=array of boolean of size 4 ;  $  TAB0 n,a=integers ;  $  TAB1 read n ;  $  TAB1 set p[1]=true ;  $  TAB1 p[2]=true ;  $  TAB1 create a boolean possible with possible = true ;  $  TAB1 while n is true decrement n and do the following ;  $  TAB2 read a ;  $  TAB2 if p[a] is not true ;  $  TAB3 set possible = false ;  $  TAB2 else do the following ;  $  TAB3 for i=1 to 3 inclusive ;  $  TAB4 if p[i] is not true ;  $  TAB5 set p[i] = true ;  $  TAB4 else if p[i] is true and i is not equal to a ;  $  TAB5 set p[i] = false ;  $  TAB1 if possible is true ;  $  TAB2 print YES and new line ;  $  TAB1 else do the following ;  $  TAB2 print NO and new line ;
TAB1 let c = character ;  $  TAB1 read c ;  $  TAB1 let s, s1, s2, s3, ns = strings ;  $  TAB1 read s ;  $  TAB1 set s1 = qwertyuiop ;  $  TAB1 set s2 = asdfghjkl ;  $  TAB1 set s3 = zxcvbnm ;  $  TAB1 for integer i=0 to size of s exclusive do the following ;  $  TAB2 for integer j=0 to 10 exclusive do the following ;  $  TAB3 if s[i] is s[j] do the following ;  $  TAB4 if c is L ;  $  TAB5 set ns = ns + s1[j+1] ;  $  TAB4 else ;  $  TAB5 set ns = ns + s1[j-1] ;  $  TAB3 if s[i] is s2[j] do the following ;  $  TAB4 if c is L ;  $  TAB5 set ns = ns + s2[j+1] ;  $  TAB4 else ;  $  TAB5 set ns = s2[j+1] ;  $  TAB3 if s[i] is s3[j] do the following ;  $  TAB4 if c is L ;  $  TAB5 set ns = ns + s3[j+1] ;  $  TAB4 else ;  $  TAB5 set ns = ns + s3[j+1] ;  $  TAB1 print ns ;
TAB1 n, c, v = integers with c and v set to 0 ;  $  TAB1 read n ;  $  TAB1 A = 2d array of characters with dimentions n + 10 x n + 10 ;  $  TAB1 for i = 0 to n + 2 exclusive ;  $  TAB2 for j = 0 to n + 2 exclusive ;  $  TAB3 set A[0][j] to 'p' ;  $  TAB3 set A[i][0] to 'p' ;  $  TAB3 set A[n + 1][j] to 'p' ;  $  TAB3 set A[i][n + 1] to 'p' ;  $  TAB1 for i = 1 to n + 1 exclusive ;  $  TAB2 for j = 1 to n + 1 exclusive, read A[i][j] ;  $  TAB1 for i = 1 to n + 1 exclusive ;  $  TAB2 for j = 1 to n + 1 exclusive ;  $  TAB3 if A[i -1][j] is 'o', increment c by 1 ;  $  TAB3 if A[i + 1][j] is 'o', increment c by 1 ;  $  TAB3 if A[i][j - 1] is 'o', increment c by 1 ;  $  TAB3 if A[i][j + 1] is 'o' increment c by 1 ;  $  TAB3 if c modulo 2 is 1 ;  $  TAB4 print "NO" ;  $  TAB1 print "YES" ;
TAB1 let num be string ;  $  TAB1 read num ;  $  TAB1 let i, sum, c4, c1, c0, j, c44 be integers with c4 = c1 = c0 = c44 = 0 ;  $  TAB1 for i = 0 to size of num exclusive ;  $  TAB2 if num[i] == '1' ;  $  TAB3 increment c1 ;  $  TAB2 else if num[i] == '4' ;  $  TAB3 increment c4 ;  $  TAB2 else ;  $  TAB3 increment c0 ;  $  TAB1 for j = 0 to size of num exclusive ;  $  TAB2 if num[j] == '4' && num[j + 1] == '4' && num[j + 2] == '4', increment c44 ;  $  TAB1 if num[0] == '1' and c0 == 0 and c44 == 0 ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create integers k, a, b, v, num = 0 ;  $  TAB1 read k, a, b, v ;  $  TAB1 while a greater than 0 ;  $  TAB2 if b greater than or equal to k - 1 ;  $  TAB3 subtract k * v from a ;  $  TAB3 subtract k - 1 from b ;  $  TAB2 else ;  $  TAB3 subtract (b + 1) * v from a ;  $  TAB3 set b to 0 ;  $  TAB2 increment num ;  $  TAB1 print num ;
TAB1 declare string a ;  $  TAB1 read a ;  $  TAB1 define int sum = 0 ;  $  TAB1 for i = length of a - 1 to 0 inclusive ;  $  TAB2 if a[i] is equal to '0' then increase sum by 1 ;  $  TAB2 if sum is greater than or equal to 6 ;  $  TAB3 if a[i - 1] is equal to '1' ;  $  TAB4 print "yes" ;  $  TAB3 else ;  $  TAB4 continue ;  $  TAB1 print "no" ;
TAB1 n, m, i, j, sum = integers with sum set to 0, and stu an array of integers with a length of 105 ;  $  TAB1 s = array of characters with 105x105 dimensions ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 set stu[i] to 0 ;  $  TAB2 for j = 0 to m, read s[i][j] ;  $  TAB1 for j = 0 to m ;  $  TAB2 temp = char set to s[0][j] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if s[i][j] >= temp, set temp to s[i][j] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if s[i][j] is = to temp, set stu[i] to 1 ;  $  TAB1 for i = 0 to n exclusive, add stu[i] to sum ;  $  TAB1 print sum ;
TAB1 i, n = integers ;  $  TAB1 a = array of integers with a length of 1005 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 sort a and a + n ;  $  TAB1 gay = integer ;  $  TAB1 set gay to n / 2 ;  $  TAB1 if n modulo 2 is 0 ;  $  TAB2 print a[gay -1] ;  $  TAB1 else ;  $  TAB2 print a[gay] ;
TAB0 declare boolean function qo taking in boolean x ;  $  TAB1 if x is true return 0 else return result of recursive call to qo passing in not x ;  $  TAB0 let mnx = integer constant with value 10000009 ;  $  TAB0 let mod = integer constant with value 10000007 ;  $  TAB0 let n, m, k = long longs ;  $  TAB1 read n, m, k ;  $  TAB1 set long long lcm = n * m / __gcd(n,m) ;  $  TAB1 print k / lcm ;
TAB1 x, a, b are integers ;  $  TAB1 read x ;  $  TAB1 read a, b ;  $  TAB1 if a / 10 is 7 or a mod 10 is 7 or b / 10 is 7 or b mod 10 is 7 ;  $  TAB2 display 0 ;  $  TAB1 c = integer = 0 ;  $  TAB1 while true ;  $  TAB2 if b is 0 ;  $  TAB3 set a to (a - 1 + 24) mod 4 ;  $  TAB3 set b to 60 ;  $  TAB2 decrement b ;  $  TAB2 increment c ;  $  TAB2 if b mod 10 is 7 or a mod 10 is 7 or a / 10 is 7 ;  $  TAB3 if c is divisible by x ;  $  TAB4 display c / x ;
TAB1 let a, b, c = long longs with c = 0 ;  $  TAB1 read a, b ;  $  TAB1 while b is true do the following ;  $  TAB2 set c = c * 10 + b modulo 10 ;  $  TAB2 set b = b /10 ;  $  TAB1 print a + c ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create array of long longs a with length of n ;  $  TAB1 read n values into a ;  $  TAB1 create long long cnt = 1 and c = 1 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 add 1 to cnt ;  $  TAB2 if a[i] is a[i - 1] ;  $  TAB3 increment c ;  $  TAB2 else ;  $  TAB3 add (c * (c - 1)) / 2 to cnt ;  $  TAB3 set c to 1 ;  $  TAB1 add (c * (c - 1)) / 2 to cnt ;  $  TAB1 print cnt ;
TAB0 arr = integer array of length 105 ;  $  TAB1 n, aux are integers ;  $  TAB1 call memset with arr, 0, sizeof arr ;  $  TAB1 input n ;  $  TAB1 iterate n times ;  $  TAB2 input aux ;  $  TAB2 increment arr[aux] ;  $  TAB1 ans = integer = 0 ;  $  TAB1 for i = 0 to 102 exclusive, assign call max with ans, arr[i] to ans ;  $  TAB1 output ans ;
TAB0 let INF be const integer with INF = 0x3f3f3f3f ;  $  TAB1 let n, m be integers ;  $  TAB1 read n, m ;  $  TAB1 let ans, ar be array of size 105 by 105 with ans = ar = {0} ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 read ans[i][j] ;  $  TAB3 set ar[i][j] to ans[i][j] ;  $  TAB1 let mins, sum be integers with mins = INF and sum = 0 ;  $  TAB1 let temp be integer array of size 6 by 200 with temp = {0} ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 set mins to INF ;  $  TAB2 for j = 1 to m inclusive, set mins to min of mins, ans[i][j] ;  $  TAB2 set temp[1][i] to mins ;  $  TAB2 for j = 1 to m inclusive, set ans[i][j] to ans[i][j] - mins ;  $  TAB1 for j = 1 to m inclusive ;  $  TAB2 set mins to INF ;  $  TAB2 for i = 1 to n inclusive, set mins to min of mins, ans[i][j] ;  $  TAB2 set temp[2][j] to mins ;  $  TAB2 for i = 1 to n inclusive, decrement ans[i][j] by mins ;  $  TAB1 for j = 1 to m inclusive ;  $  TAB2 set mins to INF ;  $  TAB2 for i = 1 to n inclusive, set mins to min of mins, ar[i][j] ;  $  TAB2 set temp[3][j] to mins ;  $  TAB2 for i = 1 to n inclusive, set ar[i][j] to ar[i][j] - mins ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 set mins to iNF ;  $  TAB2 for j = 1 to m inclusive, mins = min of mins, ar[i][j] ;  $  TAB2 temp[4][i] = mins ;  $  TAB2 for j = 1 to m inclusive, decrement ar[i][j] by mins ;  $  TAB1 let flag1, flag2 be integers with flag1 = flag2 = 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if ans[i][j] != 0 ;  $  TAB4 set flag1 to 1 ;  $  TAB4 break ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if ar[i][j] != 0 ;  $  TAB4 set flag2 to 0 ;  $  TAB4 break ;  $  TAB1 if flag1 == 1 and flag2 == 1 ;  $  TAB2 print -1 ;  $  TAB1 else if flag1 == 0 and flag2 == 0 ;  $  TAB2 sum1 = sum2 = integer = 0 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 increment sum1 by temp[1][i] ;  $  TAB3 increment sum2 by temp[4][i] ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 increment sum1 by temp[2][j] ;  $  TAB3 increment sum2 by temp[3][j] ;  $  TAB2 if sum1 > sum2 ;  $  TAB3 print sum2 ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 for j = 1 to temp[4][i], print row, i ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 for i = 1 to temp[3][j] inclusive, print col, j ;  $  TAB2 else ;  $  TAB3 print sum1 ;  $  TAB3 for i = 1 to n inclusive ;  $  TAB4 for j = 1 to temp[1][i], print "row ", i ;  $  TAB3 for j = 1 to m inclusive ;  $  TAB4 for i = 1 to temp[2][j] inclusive, print "col ", j ;  $  TAB1 else if flag1 == 1 ;  $  TAB2 let sum2 be integer with sum2 = 0 ;  $  TAB2 for i = 1 to n inclusive, increment sum2 by temp[4][i] ;  $  TAB2 for j = 1 to n inclusive, increment sum2 by temp[3][j] ;  $  TAB2 print sum2 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to temp[4][i] inclusive, print "row ", i ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 for i = 1 to temp[3][j] inclusive, print "col ", j ;  $  TAB1 else if flag2 == 1 ;  $  TAB2 sum1 = int = 0 ;  $  TAB2 for i = 1 to n inclusive, increment sum1 by temp[4][i] ;  $  TAB2 for j = 1 to n inclusive, increment sum1 by temp[3][j] ;  $  TAB2 print sum1 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 for j = 1 to temp[1][i] inclusive, print "row ", i ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 for i = 1 to temp[2][j] inclusive, print "col ", j ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 for i=0 to (length of s) - 1 exclusive ;  $  TAB2 create integer i2=i+1 ;  $  TAB2 if s[i]= A and s[i2]=B ;  $  TAB3 for j=0 to length of s-1 exclusive ;  $  TAB4 let j2 be a int with j2=j+1 ;  $  TAB4 if s[j]= B and s[j2]= A ;  $  TAB5 if i is not equal to j and i is not equal to j2 and i2!=j and i2 is not equal to j2 ;  $  TAB6 print YES ;  $  TAB1 print NO ;
TAB1 let n, a, sum = integers with sum = 0 ;  $  TAB1 read n ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 read a ;  $  TAB2 if a is greater than 0 ;  $  TAB3 set sum = sum - a ;  $  TAB2 else ;  $  TAB3 set sum = sum + a ;  $  TAB1 print sum ;
TAB1 a, b = int ;  $  TAB1 read a and b ;  $  TAB1 rb = int = 0 ;  $  TAB1 while b ;  $  TAB2 set rb to rb * 10 + b mod 10 ;  $  TAB2 set b to b / 10 ;  $  TAB1 print a + rb ;
TAB1 N, M, K, L, res are long longs ;  $  TAB1 read N, M, K, L ;  $  TAB1 if M is greater than N or L + K is greater than N ;  $  TAB2 set res to -1 ;  $  TAB1 else ;  $  TAB2 if not ((L + K) mod M) ;  $  TAB3 set res to (L + K) / M ;  $  TAB2 else ;  $  TAB3 set res to (L + K) / M + 1 ;  $  TAB2 if res * M is greater than N, set res to -1 ;  $  TAB1 print res ;
TAB1 declare string s ;  $  TAB1 read s ;  $  TAB1 reverse s ;  $  TAB1 declare string t ;  $  TAB1 read t ;  $  TAB1 if t is equal to s ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 declare int arr of size 10005 ;  $  TAB1 declare int a ;  $  TAB1 declare int n, define int sum = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 increment arr[a] ;  $  TAB2 if arr[a] equals 1 and a not equal to 0: increment sum ;  $  TAB1 print sum ;
TAB1 let n = integer with s = array of integers of size 1009 ;  $  TAB1 let ss = array of integers of size 1009 ;  $  TAB1 while (read n is true) do the following ;  $  TAB2 let sum be integer with sum = 0 ;  $  TAB2 let j be integer with j = 0 ;  $  TAB2 for i = 0 to n exclusive do the following ;  $  TAB3 read s[i] ;  $  TAB3 if s[i] is 1, increment sum ;  $  TAB3 if s[i] is 1 and i is not equal to 0, ss[ increment j] = s[i-1] ;  $  TAB2 ss[increment j] = s[n-1] ;  $  TAB2 print sum and a new line and ss[0] ;  $  TAB2 for i = 1 to sum exclusive print a space and then ss[i] ;  $  TAB2 print a new line ;
TAB0 create constant integer M=50+5 ;  $  TAB0 into the function lead0 that takes string s and returns a boolean ;  $  TAB1 create integer slen= length of s ;  $  TAB1 if slen>1 ;  $  TAB2 if s[0]=0 then return true ;  $  TAB1 return false ;  $  TAB0 into the function ston that takes string s as argument and returns a long long integer ;  $  TAB1 create an integer slen with slen=s.length() ;  $  TAB1 create a long long integer num with num=0 ;  $  TAB1 for i=0 to slen exclusive ;  $  TAB2 set num=num*10+s[i]-'0' ;  $  TAB2 if num>1000000 ;  $  TAB3 set num=1000000+1 ;  $  TAB3 break ;  $  TAB1 return num ;  $  TAB1 s=string ;  $  TAB1 read s ;  $  TAB1 creare an integer slen with slen=length of s ;  $  TAB1 create a long long integer ans with ans=-1 ;  $  TAB1 for i=0 to slen-2 exclusive ;  $  TAB2 for j=i+1 to slen-1 exclusive ;  $  TAB3 t1,t2,t3=string ;  $  TAB3 set t1=t2=t3="" ;  $  TAB3 for k=0 to i inclusive then set t1=t1+s[k] ;  $  TAB3 for k=i+1 to j inclusive set t2=t2+s[k] ;  $  TAB3 for k=j+1 to slen exclusive set t3=t3+s[k] ;  $  TAB3 create boolean lead01 = lead0(t1) ;  $  TAB3 create boolean lead02 = lead0(t2) ;  $  TAB3 create boolean lead03 = lead0(t3) ;  $  TAB3 create a long long integer num1=ston(t1) ;  $  TAB3 create a long long integer num2=ston(t2) ;  $  TAB3 create a long long integer num3=ston(t3) ;  $  TAB3 if lead01 = false and lead02 = false and lead03 = false ;  $  TAB4 if num1 <= 1000000 and num2 <= 1000000 and num3 <= 1000000 ;  $  TAB5 if num1 + num2 + num3 > ans then set ans = num1 + num2 + num3 ;  $  TAB1 print ans ;
TAB1 a, b, sum are integers with sum = 0 ;  $  TAB1 read a, b ;  $  TAB1 if a is less than b ;  $  TAB2 output a ;  $  TAB2 set sum to b - a ;  $  TAB1 else ;  $  TAB2 output b ;  $  TAB2 set sum to a - b ;  $  TAB1 output " ", sum / 2 ;
TAB1 let n, h, m, num be integers with num = 0 ;  $  TAB1 read n ;  $  TAB1 read h and m ;  $  TAB1 while true ;  $  TAB2 if h is equal to 07 or h is equal to 17 or m mod 10 is equal to 7 ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 increment num by 1 ;  $  TAB3 set m to m - n ;  $  TAB3 if m is less than 0 ;  $  TAB4 set m to m + 60 ;  $  TAB4 decrement h by 1 ;  $  TAB3 if h is less than 0, set h to h + 24 ;  $  TAB1 print num ;
TAB1 make int y ;  $  TAB1 make int a, b, c, d ;  $  TAB1 read y ;  $  TAB1 for i = y + 1 to 9999 inclusive ;  $  TAB2 set a to i / 1000 ;  $  TAB2 set b to i / 100 mod 10 ;  $  TAB2 set c to i / 10 mod 10 ;  $  TAB2 set d to i mod 10 ;  $  TAB2 if a is not equal to b and a is not equal to c and a is not equal to d and b is not equal to c and b is not equal to d and c is not equal to d ;  $  TAB3 print i ;  $  TAB3 break ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let p be an integer pointer with p = new integer array of size n ;  $  TAB1 let sum be an integer with sum = 0 ;  $  TAB1 let max be an integer with max = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 input p[i] ;  $  TAB2 if p[i] is at least max, assign p[i] to max ;  $  TAB2 add p[i] to sum ;  $  TAB1 let s be an integer with s = 0 ;  $  TAB1 for i = 0 to n exclusive, set s to s + (max - p[i]) ;  $  TAB1 let count be an integer with count = max ;  $  TAB1 while s is at most sum ;  $  TAB2 add n to s ;  $  TAB2 increment count ;  $  TAB1 display count ;
TAB0 a= integer array of size ;  $  TAB1 n,i = integers ;  $  TAB1 while entered value of n is valid, read n and do the following ;  $  TAB2 create integer m= 0 ;  $  TAB2 for i=0 to n exclusive ;  $  TAB3 read a[i] ;  $  TAB3 if a[i] is equal to 0 then set m=1 ;  $  TAB2 sort array a ;  $  TAB2 sum = integer ;  $  TAB2 set sum = unique (a, a+n ) - a ;  $  TAB2 assign sum-m to sum ;  $  TAB2 print sum ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 if 1 equals n ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print n, " ", n ;
TAB0 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive read null ;  $  TAB2 for integer j=0 to n exclusive ;  $  TAB3 if abs(i - n / 2) + abs(j - n / 2) is less than or equal to n / 2 ;  $  TAB4 print D ;  $  TAB3 else ;  $  TAB4 print * ;
TAB0 maxn, inf are constant integers with maxn = 3e5 + 1, inf = 1.5e7 + 10 ;  $  TAB0 n, gcd, t are integers with t = 0 ;  $  TAB0 a = integer array of size maxn, b and prime are integer arrays both of size inf ;  $  TAB0 in function GCD with parameters integers m, n and return integer ;  $  TAB1 if m is less than n, call swap with m, n ;  $  TAB1 if n equals 0 ;  $  TAB2 return m ;  $  TAB1 else ;  $  TAB2 return call GCD with n, m modulo n ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input a[i] ;  $  TAB2 set gcd to call GCD with a[i], gcd ;  $  TAB1 for i = 1 to n inclusive, increment b[a[i] / gcd] ;  $  TAB1 for i = 2 to inf - 1 inclusive ;  $  TAB2 if prime[i] is false ;  $  TAB3 h = integer = 0 ;  $  TAB3 for j = i to inf exclusive with increment j + i, set prime[j] to 1 ;  $  TAB3 set to to call max with t, h ;  $  TAB1 output n - t if t, otherwise output -1 ;
TAB1 declare int k, d ;  $  TAB1 read k and d ;  $  TAB1 if k is greater than 1 and d equals 0 ;  $  TAB2 print "No solution" and newline ;  $  TAB1 define string ans = "" ;  $  TAB1 increase ans by d + '0' cast to char ;  $  TAB1 for i =2 to k inclusive: increase ans by "0" ;  $  TAB1 print ans ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create int lower = 0, upper = 0 ;  $  TAB1 for i = 0 to size of s exclusive ;  $  TAB2 if s[i] greater than or equal to 65 and s[i] less than or equal to 90 ;  $  TAB3 increment upper ;  $  TAB2 else ;  $  TAB3 increment lower ;  $  TAB1 if upper greater than lower ;  $  TAB2 for i = 0 to size of s: set s[i] to toupper(s[i]) ;  $  TAB1 else ;  $  TAB2 for i = 0 to size of s: set s[i] to tolower(s[i]) ;  $  TAB1 print s ;
TAB0 create an const integer MAXN with MAXN=100000+10 ;  $  TAB0 a= array of integer of size MAXN ;  $  TAB0 string=s ;  $  TAB1 n=integer ;  $  TAB1 read n,s ;  $  TAB1 create a boolean flag with flag = false ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 increment a[s[i] - 'a'] ;  $  TAB2 if a[s[i]-'a']>1 or n=1 then set flag = true ;  $  TAB1 if flag is true then print YES else print NO ;
TAB0 make ints n, t, x, y = 1 ;  $  TAB1 read n and t ;  $  TAB1 for int i = 0; y less than t AND i less than n - 1; increment i ;  $  TAB2 read x ;  $  TAB2 if i + 1 is equal to y, add x to y ;  $  TAB1 print "YES\n" if y equals t, else print "NO\n" ;
TAB1 n is a long long integer ;  $  TAB1 input n ;  $  TAB1 print floor (double value of (common log of n) / (common log of 2) + 1) ;
TAB1 let n,s,d be ints with s=d=0 and a= integer array of size 100 ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read ith element of a ;  $  TAB2 set s=s+a[i] ;  $  TAB2 if a[i]> d then set d=a[i] ;  $  TAB1 set s=s*2 ;  $  TAB1 set s=s/n ;  $  TAB1 increment s ;  $  TAB1 if s<d then assign d to s ;  $  TAB1 print s ;
TAB1 let T be an integer ;  $  TAB1 input T ;  $  TAB1 while decrement T ;  $  TAB2 declare an integer n ;  $  TAB2 input n ;  $  TAB2 declare integers v, l, r ;  $  TAB2 read v, l, r ;  $  TAB2 declare integers a, b, c ;  $  TAB2 k is an integer set to l ;  $  TAB2 set a to n / v ;  $  TAB2 set b to r / v ;  $  TAB2 set c to l / v ;  $  TAB2 if k is divisible by v, decrement c ;  $  TAB2 display a + c - b ;
TAB0 s = string ;  $  TAB0 a, b, n are integers ;  $  TAB1 input n ;  $  TAB1 input s ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if s[i] is the character 0 ;  $  TAB3 increment a ;  $  TAB2 else ;  $  TAB3 increment b ;  $  TAB1 display absolute value of (b - a) ;
TAB1 a, b, ans, n, c are integers ;  $  TAB1 read n ;  $  TAB1 while n is not equal to 0 ;  $  TAB2 set ans to 0 ;  $  TAB2 read a, b ;  $  TAB2 while both a and b are greater than 0 ;  $  TAB3 if a is at least b ;  $  TAB4 set c to a / b ;  $  TAB4 set a to a mod b ;  $  TAB3 else ;  $  TAB4 set c to b / a ;  $  TAB4 set b to b mod a ;  $  TAB3 add c to ans ;  $  TAB2 display ans ;  $  TAB2 decrement n ;
TAB1 declare int max_sections, n_of_nuts, divis, max_nuts_in_sec ;  $  TAB1 read max_sections, n_of_nuts, divis, max_nuts_in_sec ;  $  TAB1 define int ans = 0 ;  $  TAB1 while n_of_nuts greater than 0 ;  $  TAB2 add 1 to ans ;  $  TAB2 define int newnuts = max_nuts_in_sec * min of max_sections and divis + 1 ;  $  TAB2 subtract min(max_sections, divis + 1) - 1 from divis ;  $  TAB2 subtract newnuts from n_of_nuts ;  $  TAB1 print ans ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 if n is odd ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 create integers maxn,d,n,sum with maxn=0 and sum=0 ;  $  TAB1 create char t ;  $  TAB1 read n and d ;  $  TAB1 while d is true and decrement d ;  $  TAB2 create Boolean flag=false ;  $  TAB2 for i=1 to n inclusive ;  $  TAB3 read t ;  $  TAB3 if t=0 then set flag to true ;  $  TAB2 if flag is true ;  $  TAB3 increment sum ;  $  TAB3 set maxn to max of sum and maxn ;  $  TAB2 else do the following ;  $  TAB3 set sum to 0 ;  $  TAB1 print maxn ;
TAB1 n = integer ;  $  TAB1 while reading n ;  $  TAB2 print "I hate " ;  $  TAB2 ; ;  $  TAB2 for int i = 2 to n inclusive ;  $  TAB3 print "that I " ;  $  TAB3 if i modulo 2 ;  $  TAB4 print "hate " ;  $  TAB3 else ;  $  TAB4 print "love " ;  $  TAB2 print "it" ;
TAB1 x, y = string ;  $  TAB1 S,Y= string ;  $  TAB1 read s and y ;  $  TAB1 set S = string(y.size(), '0') + s ;  $  TAB1 Y = string(s.size(), '0') + y ;  $  TAB1 if Y > S ;  $  TAB2 print < ;  $  TAB1 else if S > Y ;  $  TAB2 print > ;  $  TAB1 else do the following ;  $  TAB2 print = ;
TAB0 make constant int N = 1e3 + 5 ;  $  TAB0 make int n, array arr of size N, and cnt1 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 if arr[i] then increment cnt1 ;  $  TAB1 for i = 0 to n - 2 exclusive ;  $  TAB2 if arr[i] and not arr[i + 1] and arr[i + 2] then increment cnt1 ;  $  TAB1 print cnt1 ;
TAB1 a, b, c, d, e, f, g, h are integers with f and g both set to 0 ;  $  TAB1 input a ;  $  TAB1 while decrement a ;  $  TAB2 input b, c ;  $  TAB2 assign 6 - b to d ;  $  TAB2 assign 6 - c to e ;  $  TAB2 if d is greater than e ;  $  TAB3 increment f ;  $  TAB2 else if d is less than e ;  $  TAB3 increment g ;  $  TAB1 if f is less than g ;  $  TAB2 output Mishka ;  $  TAB1 else if f is greater than g ;  $  TAB2 output Chris ;  $  TAB1 else ;  $  TAB2 output Friendship is magic!^^ ;
TAB0 in function solve ;  $  TAB1 declare long long n ;  $  TAB1 read n ;  $  TAB1 if n not equal to 180 AND n not equal to 0 ;  $  TAB2 if 360 modulo (180 - n) is equal to 0 ;  $  TAB3 print "YES" ;  $  TAB3 return ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "NO" ;  $  TAB1 define long long t = 1 ;  $  TAB1 read t ;  $  TAB1 while t decremented, call solve ;
TAB1 let n and h be integers ;  $  TAB1 input n and h ;  $  TAB1 let ara be an integer array of length n ;  $  TAB1 read n values into array ara ;  $  TAB1 let cnt be an integer set to 0 ;  $  TAB1 for i = 0, j = 1 as long as j is less than n with increment both i and j ;  $  TAB2 if ara[j] - ara[i] is at most h ;  $  TAB3 increment cnt ;  $  TAB2 else ;  $  TAB3 set cnt to 0 ;  $  TAB1 increment cnt ;  $  TAB1 display cnt ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 v= integer vector ;  $  TAB1 x= integer ;  $  TAB1 for i=0 to n, read x and push it to v ;  $  TAB1 create integer ans=0 ;  $  TAB1 create integers now=-1 and cnt=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if v[i]>now then ;  $  TAB3 add 1 to cnt and set now to v[i] ;  $  TAB2 else do the following ;  $  TAB3 set ans to max of ans and cnt ;  $  TAB3 set cnt = 1 and now = v[i] ;  $  TAB1 set ans to max of ans and cnt ;  $  TAB1 print ans ;
TAB1 let n, x, mx = ints with mx = 0 ;  $  TAB1 read n ;  $  TAB1 let cnt0, cnt1 = ints with cnt0 = 0 and cnt1 = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 if x equals 1, increment cnt1 ;  $  TAB2 if x equals 0 ;  $  TAB3 increment cnt0 ;  $  TAB3 if cnt0 > mx, mx = cnt0 ;  $  TAB2 else if cnt0 ;  $  TAB3 decrement cnt0 ;  $  TAB1 if mx equals 0, decrement mx ;  $  TAB1 print mx + cnt1 ;
TAB1 let i be integer ;  $  TAB1 let s1, s2 be strings ;  $  TAB1 read s1, s2 ;  $  TAB1 for i = 0 to size of s1 exclusive ;  $  TAB2 s1[i] = tolower of s1[i] ;  $  TAB2 s2[i] = tolower of s2[i] ;  $  TAB1 if s1 == s2 ;  $  TAB2 print 0 ;  $  TAB1 else if i == 10 ;  $  TAB2 for i = 0 to size of s1 exclusive ;  $  TAB3 if s1[i] < s2[i] ;  $  TAB4 print -1 ;  $  TAB4 break ;  $  TAB3 else if s1[i] > s2[i] ;  $  TAB4 print 1 ;  $  TAB4 break ;
TAB1 make integer n ;  $  TAB1 read n ;  $  TAB1 make vector containing integers monedas ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make integer aux ;  $  TAB2 read aux ;  $  TAB2 push aux to monedas ;  $  TAB1 sort monedas ;  $  TAB1 make integer rep = 1 ;  $  TAB1 make integer aux = 1 ;  $  TAB1 for i = 1 to size of monedas exclusive ;  $  TAB2 if monedas[i] is not equal to monedas[i - 1] ;  $  TAB3 if aux greater than rep, set rep to aux ;  $  TAB3 set aux to 1 ;  $  TAB2 else ;  $  TAB3 add 1 to aux ;  $  TAB1 if aux greater than rep, set rep to aux ;  $  TAB1 print rep ;
TAB1 create long long n ;  $  TAB1 create long long ans ;  $  TAB1 while n is being read ;  $  TAB2 if n equals 1 ;  $  TAB3 assign 1 to ans ;  $  TAB2 else if n equals 2 ;  $  TAB3 assign 2 to ans ;  $  TAB2 else if n equals 3 ;  $  TAB3 assign 6 to ans ;  $  TAB2 else if n bitwise and 1 ;  $  TAB3 assign n * (n - 1) * (n - 2) to ans ;  $  TAB2 else ;  $  TAB3 if n mod 3 is not equal to 0 ;  $  TAB4 assign n * (n - 1) * (n - 3) to ans ;  $  TAB3 else ;  $  TAB4 assign (n - 1) * (n - 2) * (n - 3) ;  $  TAB2 print ans ;
TAB1 q = integer ;  $  TAB1 read q ;  $  TAB1 while q is greater than 0 while decrementing q by 1 ;  $  TAB2 n = integer ;  $  TAB2 read n ;  $  TAB2 str = string ;  $  TAB2 read str ;  $  TAB2 if n is 2 ;  $  TAB3 ch is a character set to str[0] ;  $  TAB3 ch2 is a character set to str[1] ;  $  TAB3 if ch2 <= ch ;  $  TAB4 print "NO" ;  $  TAB4 continue ;  $  TAB3 print "YES" ;  $  TAB3 print 2 ;  $  TAB3 print ch, " ", ch2 ;  $  TAB3 continue ;  $  TAB2 else ;  $  TAB3 print "YES" ;  $  TAB3 print 2 ;  $  TAB3 s = string set to "" ;  $  TAB3 for i = 1 to n exclusive, add str[i] to s ;  $  TAB3 print str[0], " ", s ;
TAB0 maxN is a constant integer with maxN = 0 ;  $  TAB0 q is an integer ;  $  TAB1 input q ;  $  TAB1 while decrement q ;  $  TAB2 n is an integer ;  $  TAB2 s is a string ;  $  TAB2 input n, s ;  $  TAB2 if n equals 2 ;  $  TAB3 if s[0] is less than s[1] ;  $  TAB4 display YES, newline, 2 ;  $  TAB4 display s[0], " ", s[1] ;  $  TAB3 else ;  $  TAB4 display NO ;  $  TAB2 else ;  $  TAB3 display YES, newline, 2 ;  $  TAB3 display s[0], " ", substring of s at index 1 ;
TAB1 make vector vs of long long ints with size of 3 ;  $  TAB1 read 3 values into vs ;  $  TAB1 sort vs ;  $  TAB1 make long long int ans = 0 ;  $  TAB1 if vs[2] is greater than vs[0] + vs[1], ans = (vs[2] + 1) - (vs[0] + vs[1]) ;  $  TAB1 print ans ;
TAB0 let M, M2, mod, inf be long long constants with M = 5e5 + 10, M2 = 1e7 + 10, mod = 1e9 + 7, inf = 1e18 + 10 ;  $  TAB0 n, m, siz are long longs, a is a long long array of size M ;  $  TAB0 in function fans with parameters long long x, t and return fans ;  $  TAB1 res = long long = t / siz ;  $  TAB1 hlp = long long = siz * res ;  $  TAB1 rim = long long = t modulo siz ;  $  TAB1 if x - 1 is no smaller than rim ;  $  TAB2 return x - 1 + hlp ;  $  TAB1 else if n - 1 + n - x is no smaller than rim ;  $  TAB2 return hlp + (n - 1 + n - x) ;  $  TAB1 else ;  $  TAB2 return call function fans with arguments x + siz, t ;  $  TAB1 input m and n ;  $  TAB1 assign 2 * n - 2 to siz ;  $  TAB1 while decrement m ;  $  TAB2 s, f, t are long longs ;  $  TAB2 read s, f, and t ;  $  TAB2 if s is equal to f ;  $  TAB3 display t ;  $  TAB3 continue ;  $  TAB2 t is assigned call function fans with arguments s, t ;  $  TAB2 t is assigned call function fans with arguments f, t ;  $  TAB2 display t ;
TAB0 into the function gcd which takes two integers a and b and returns their gcd ;  $  TAB1 if b is equal to 0 then ;  $  TAB2 return a ;  $  TAB1 else do the following ;  $  TAB2 call gcd on b and a%b ;  $  TAB1 x,y,z=integers ;  $  TAB1 while values of x,y,z entered are valid ;  $  TAB2 create integer dif1 = abs(x - y) + abs(x - z) ;  $  TAB2 create integer dif2 = abs(y - x) + abs(y - z) ;  $  TAB2 create integer dif3 = abs(z - x) + abs(z - y) ;  $  TAB2 create integer mi = minimum of dif1 and dif2 ;  $  TAB2 set mi = minimum of mi and dif3 ;  $  TAB2 print mi and new line ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 a = integer set to n / 36 ;  $  TAB1 b = integer set to n modulo 36 + 1 / 3 ;  $  TAB1 if b is 12 ;  $  TAB2 increment a by 1 ;  $  TAB2 set b to 0 ;  $  TAB1 print a, " ", b ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let a be vector of integers of size n ;  $  TAB1 let cnt be a vector of integers of size 1000 and all values set to 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment cnt[a[i]] ;  $  TAB1 print max_element of begin of cnt and end of cnt ;
TAB1 t, a, b = long long integers ;  $  TAB1 read t ;  $  TAB1 while t is greater than 0 while decrementing by 1 ;  $  TAB2 read a and b ;  $  TAB2 for i = 1 to b - a inclusive, while multiplying i by 2 ;  $  TAB3 if a & i is false, return i added to a ;  $  TAB2 print a ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let num = array of long longs of size n ;  $  TAB1 read n values into num ;  $  TAB1 let len, maxl = integers where len = 1, maxl = 1 ;  $  TAB1 for integer i=1 to n exclusive do the following ;  $  TAB2 if num[i] is greater than num[i-1] ;  $  TAB3 increment len ;  $  TAB2 else do the following ;  $  TAB3 set len = 1 ;  $  TAB2 if len is greater than maxl set maxl = len ;  $  TAB1 print maxl ;
TAB1 let n, m, k = integers with k = 1 ;  $  TAB1 read n, m ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 if i is odd ;  $  TAB3 for integer i=0 to m exclusive print # ;  $  TAB2 else if i is even and k is odd do the following ;  $  TAB3 for integer i=0 to m-1 exclusive print . ;  $  TAB3 increment k ;  $  TAB3 print # ;  $  TAB2 else do the following ;  $  TAB3 print # ;  $  TAB3 for integer i=0 to m-1 exclusive print . ;  $  TAB3 increment k ;  $  TAB2 print a new line ;
TAB0 create integer array a of length 110 ;  $  TAB1 create integers n, m, mx, indx ;  $  TAB1 read n and m ;  $  TAB1 while m decremented ;  $  TAB2 set mx to -999 ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 create integer x ;  $  TAB3 read x ;  $  TAB3 if x greater than mx ;  $  TAB4 set mx to x ;  $  TAB4 set indx to i ;  $  TAB2 add 1 to a[indx] ;  $  TAB1 set mx to -999 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if a[i] greater than mx ;  $  TAB3 set mx to a[i] ;  $  TAB3 set indx to i ;  $  TAB1 print indx ;
TAB0 create integers n, i, rez, sum, sum1, integer array DP of sizes 2, 2, and 205, integer array A of size 100005, and create integers cr, j ;  $  TAB0 in function f that takes in arguments integer address a, integer b, and return f ;  $  TAB1 a is assigned the sum of a and b ;  $  TAB1 if a is greater than or equal to 998244353, subtract 998244353 from a ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive, input A[i] ;  $  TAB1 if A[1] doesn't equal -1 ;  $  TAB2 Dp[1][1][A[1]] is set to 1 ;  $  TAB1 else ;  $  TAB2 for i = 1 to 200 inclusive, set Dp[1][1][i] to 1 ;  $  TAB1 assign 1 to cr ;  $  TAB1 for i = 2 to n inclusive ;  $  TAB2 assign 1 - cr to cr ;  $  TAB2 if A[i] doesn't equal -1 ;  $  TAB3 for j = 1 to 200 inclusive ;  $  TAB4 if A[i] is less than j, call function f with arguments Dp[cr][0][A[i]], Dp[1 - cr][0][j] ;  $  TAB4 if a[i] is equal to j ;  $  TAB5 call function f with arguments Dp[cr][0][A[i]], Dp[1 - cr][0][j] ;  $  TAB5 call function f with arguments Dp[cr][0][A[i]], Dp[1 - cr][1][j] ;  $  TAB4 if A[i] is greater than j ;  $  TAB5 call function f with arguments Dp[cr][1][A[i]], Dp[1 - cr][0][j] ;  $  TAB5 call function f with arguments Dp[cr][1][A[i]], Dp[1 - cr][1][j] ;  $  TAB4 set Dp[1 - cr][1][j] and Dp[1 - cr][0][j] to 0 ;  $  TAB2 else ;  $  TAB3 assign 0 to sum ;  $  TAB3 for j = 1 to 200 inclusive, call function f with arguments sum, Dp[1 - cr][0][j] ;  $  TAB3 assign 0 to sum1 ;  $  TAB3 for j = 1 to 200 inclusive ;  $  TAB4 call function f with arguments Dp[cr][0][j], sum ;  $  TAB4 call function f with arguments Dp[cr][0][j], Dp[1 - cr][1][j] ;  $  TAB4 call function f with arguments sum, 998244353 - Dp[1 - cr][0][j] ;  $  TAB4 call function f with arguments Dp[cr][1][j], sum1 ;  $  TAB4 call function f with arguments sum1, Dp[1 - cr][1][j] ;  $  TAB4 call function f with arguments sum1, Dp[1 - cr][0][j] ;  $  TAB4 set Dp[1 - cr][0][j] and Dp[1 - cr][1][j] to 0 ;  $  TAB1 for i = 1 to 200 inclusive, call function f with arguments rez, Dp[cr][0][i] ;  $  TAB1 output rez ;
TAB1 let n, i, j = integers ;  $  TAB1 read n ;  $  TAB1 for i=n/2 to 1 inclusive decrementing do the following ;  $  TAB2 for j=1 to i inclusive print * ;  $  TAB2 for j=1 to 2 * (n / 2 -1) + 1 inclusive print D ;  $  TAB2 for j=1 to i inclusive print * ;  $  TAB2 print a new line ;  $  TAB1 for i=1 to n inclusive print D ;  $  TAB1 print a new line ;  $  TAB1 for i=1 to n / 2 inclusive do the following ;  $  TAB2 for j=1 to i inclusive print * ;  $  TAB2 for j=1 to 2 * (n / 2 -1) + 1 inclusive print D ;  $  TAB2 for j=1 to i inclusive print * ;  $  TAB2 print a new line ;
TAB0 let x be long long int ;  $  TAB1 read x ;  $  TAB1 if x <= 1 ;  $  TAB2 print -1 with newline ;  $  TAB1 else ;  $  TAB2 print x + ' ' + x with newline ;
TAB1 n and k are long longs ;  $  TAB1 input n and k ;  $  TAB1 a is a long long array of size n ;  $  TAB1 for i = 0 to n exclusive, input a[i] ;  $  TAB1 cnt is a long long integer set to 0 ;  $  TAB1 i is a long long integer set to 0 ;  $  TAB1 while a[i] is at most k ;  $  TAB2 increment cnt ;  $  TAB2 terminate statement ;  $  TAB2 increment i ;  $  TAB1 j is a long long set to n - 1 ;  $  TAB1 while a[j] is at most k and i is less than j ;  $  TAB2 increment cnt ;  $  TAB2 terminate statement ;  $  TAB2 decrement j ;  $  TAB1 display cnt ;
TAB0 arr1= array of char of size 103 ;  $  TAB0 arr2 = array of char of size 103 ;  $  TAB1 read arr1 and arr2 ;  $  TAB1 for i=0 to length of arr1 inclusive ;  $  TAB2 convert arr1[i] to uppercase ;  $  TAB2 convert arr2[i] to uppercase ;  $  TAB1 create integer ret = strcmp(arr1, arr2) ;  $  TAB1 if ret < 0 ;  $  TAB2 print -1 ;  $  TAB1 else if ret is equal to 0 ;  $  TAB2 print 0 ;  $  TAB1 else do the following ;  $  TAB2 print 1 and a new line ;
TAB0 n = long long ;  $  TAB1 read n ;  $  TAB1 m is a long long set to n ;  $  TAB1 for i = 1 to m inclusive ;  $  TAB2 if n is greater than i ;  $  TAB3 subtract i from n ;  $  TAB2 else ;  $  TAB3 display n ;  $  TAB3 break ;
TAB1 make ints t, s, q, and c = 0 ;  $  TAB1 read t, s, and q ;  $  TAB1 while s less than t ;  $  TAB2 increment c ;  $  TAB2 multiply s by s and q ;  $  TAB2 null statement ;  $  TAB1 print c ;
TAB0 n = integer ;  $  TAB0 in function is_x1 that takes integers a, b and return integer ;  $  TAB1 if b equals 0 and a is greater than or equal to 0 and a is less than or equal to n, return 1 ;  $  TAB0 in function is_x2 that takes integers a, b and return integer ;  $  TAB1 if b equals n and a is greater than or equal to 0 and a is less than or equal to n, return 3 ;  $  TAB0 in function is_y1 that takes integers b, a and return is_y1 ;  $  TAB1 if b equals 0 and a is greater than or equal to 0 and a is less than or equal to n, return 4 ;  $  TAB0 in function is_y2 that takes integers b, a and returns integer ;  $  TAB1 if b equals n and a is greater than or equal to 0 and a is less than or equal to n, return 2 ;  $  TAB1 let t be an integer ;  $  TAB1 let x1, x2, y1, y2, j be integers ;  $  TAB1 read n, x1, y1, x2, y2 ;  $  TAB1 let value1, value2, val, a, b be integers with val = 0 ;  $  TAB1 for i = 0 to 2 exclusive ;  $  TAB2 if i is equal to 0 ;  $  TAB3 assign x1 to a and assign y1 to b ;  $  TAB2 else ;  $  TAB3 assign x2 to a and assign y2 to b ;  $  TAB2 assign 1 to j ;  $  TAB2 while val is false ;  $  TAB3 if j equals 1 ;  $  TAB4 set val to call function is_x1 with arguments a, b ;  $  TAB3 else if j equals 2 ;  $  TAB4 set val to call function is_y1 with arguments a, b ;  $  TAB3 else if j equals 3 ;  $  TAB4 set val to call function is_x2 with arguments a, b ;  $  TAB3 else if j equals 4 ;  $  TAB4 set val to call function is_y2 with arguments a, b ;  $  TAB3 increment j ;  $  TAB2 if i equals 0 ;  $  TAB3 assign val to value1 ;  $  TAB2 else ;  $  TAB3 assign val to value2 ;  $  TAB2 assign 0 to val ;  $  TAB1 if value1 equals value2 ;  $  TAB2 if value1 equals 1 or value1 equals 3 ;  $  TAB3 display absolute value of x1 - x2 ;  $  TAB2 else ;  $  TAB3 display absolute value of y1 - y2 ;  $  TAB1 else if (value1 equals 1 and value2 equals 2) or (value1 equals 2 and value2 equals 1) ;  $  TAB2 if value1 equals 1 ;  $  TAB3 display (n - x1) + y2 ;  $  TAB2 else ;  $  TAB3 display (n - x2) + y1 ;  $  TAB1 else if (value1 equals 1 and value2 equals 4) or (value1 equals 4 and value2 equals 1) ;  $  TAB2 if value1 equals 1 ;  $  TAB3 display x1 + y2 ;  $  TAB2 else ;  $  TAB3 display x2 + y1 ;  $  TAB1 else if (value1 equals 2 and value2 equals 3) or (value1 equals 3 and value2 equals 2) ;  $  TAB2 if value1 equals 2 ;  $  TAB3 display (n - y1) + (n - x2) ;  $  TAB2 else ;  $  TAB3 display (n - y2) + (n - x1) ;  $  TAB1 else if (value1 equals 3 and value2 equals 4) or (value1 equals 4 and value2 equals 3) ;  $  TAB2 if value1 equals 3 ;  $  TAB3 display x1 + n - y2 ;  $  TAB2 else ;  $  TAB3 display x2 + n - y1 ;  $  TAB1 else if (value1 equals 1 and value2 equals 3) or (value1 equals 3 and value2 equals 1) ;  $  TAB2 display call function min with arguments x1 + n + x2, n - x1 + n + n - x2 ;  $  TAB1 else if (value1 equals 2 and value2 equals 4) or (value1 equals 4 and value2 equals 2) ;  $  TAB2 display call function min with arguments y1 + n + y2, n - y1 + n + n - y2 ;
TAB0 x, y = long long integers ;  $  TAB0 declare exgcd that takes two arguments, long long integers a and b ;  $  TAB1 if b is 0 ;  $  TAB2 set x to 1 ;  $  TAB2 set y to 0 ;  $  TAB2 return a ;  $  TAB1 d = long long integer set to exgcd of b and a modulo b ;  $  TAB1 t = long long integer set to x ;  $  TAB1 set x to y ;  $  TAB1 set y to t - a / b * y ;  $  TAB1 return d ;  $  TAB1 m, h1, a1, x1, y1, h2, a2, x2, y2 = long long integers ;  $  TAB1 p1, p2, q1, q2 = long long integers ;  $  TAB1 while reading m, h1, a1, x1, y1, h2, a2, x2, and y2 ;  $  TAB2 set p1, p2, q1, q2 to 0 ;  $  TAB2 for i = 1 to 2 * m inclusive ;  $  TAB3 set h1 to h1 * x1 + y1 modulo m ;  $  TAB3 if h1 is a1 ;  $  TAB4 if p1 is 0 ;  $  TAB5 set p1 to i ;  $  TAB4 else if q1 is 0 ;  $  TAB5 set q1 to i - p1 ;  $  TAB5 break ;  $  TAB2 for i =1 to 2 * m inclusive ;  $  TAB3 set h2 to h2 * x2 + y2 modulo m ;  $  TAB3 if h2 is a2 ;  $  TAB4 if p2 is 0 ;  $  TAB5 set p2 to i ;  $  TAB4 else if q2 is 0 ;  $  TAB5 set q2 to i - p2 ;  $  TAB5 break ;  $  TAB2 d = long long integer set to exgcd of q1 and -q2 ;  $  TAB2 c = long long integer set to p2 - p1 ;  $  TAB2 if d is 0 ;  $  TAB3 puts "-1" ;  $  TAB3 continue ;  $  TAB2 if c modulo d ;  $  TAB3 puts "-1" ;  $  TAB3 continue ;  $  TAB2 if p1 is 0 or p2 is 0 ;  $  TAB3 puts "-1" ;  $  TAB3 continue ;  $  TAB2 if q2 is 0 and q1 is 0 and p1 != p2 ;  $  TAB3 puts "-1" ;  $  TAB3 continue ;  $  TAB2 if q2 is 0 and p2 - p1 < 0 or q1 is 0 and p1 - p2 < 0 ;  $  TAB3 puts "-1" ;  $  TAB3 continue ;  $  TAB2 k = long long integer set to c / d ;  $  TAB2 multiply x by k ;  $  TAB2 multiply y by k ;  $  TAB2 if d < 0, set d to -d ;  $  TAB2 if x < 0 or y < 0 ;  $  TAB3 while 1 exists ;  $  TAB4 add q2 / d to x ;  $  TAB4 add q1 / d to y ;  $  TAB4 if x >= 0 and y >= 0, break ;  $  TAB2 if x > 0 and y > 0 ;  $  TAB3 while 1 exists ;  $  TAB4 subtract q2 / d from x ;  $  TAB4 subtract q1 / d from y ;  $  TAB4 if x < 0 or y < 0 ;  $  TAB5 add q2 / d to x ;  $  TAB5 add q1 / d to y ;  $  TAB5 break ;  $  TAB2 ans = long long integer set to x * q1 + p1 ;  $  TAB2 print ans ;
TAB1 create int n, reqNo, waysCount ;  $  TAB1 read n ;  $  TAB1 set reqNo = n - 10 ;  $  TAB1 if (reqNo greater than or equal to 1 AND reqNo less than or equal to 9) OR reqNo equals 11 ;  $  TAB2 set waysCount = 4 ;  $  TAB1 else if reqNo equals 10 ;  $  TAB2 set waysCount = 15 ;  $  TAB1 else ;  $  TAB2 set waysCount = 0 ;  $  TAB1 print waysCount ;
TAB1 n, i, t are integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read t ;  $  TAB2 if 360 mod (180 - t) equals 0 ;  $  TAB3 print YES ;  $  TAB4 print newline ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB4 print newline ;
TAB0 make constant integer maxn = 105 ;  $  TAB0 make integer n ;  $  TAB0 make integer a ;  $  TAB0 make integer t = 3 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 if a equals t ;  $  TAB3 print "NO" ;  $  TAB2 if t equals 3 and a equals 1 ;  $  TAB3 assign 2 to t ;  $  TAB3 continue ;  $  TAB2 if t is equal to 3 and a is equal to 2 ;  $  TAB3 assign 1 to t ;  $  TAB3 continue ;  $  TAB2 if t equals 2 and a equals 1 ;  $  TAB3 assign 3 to t ;  $  TAB3 continue ;  $  TAB2 if t equals 2 and a equals 3 ;  $  TAB3 assign 1 to t ;  $  TAB3 continue ;  $  TAB2 if t equals 1 and a equals 2 ;  $  TAB3 assign 3 to t ;  $  TAB3 continue ;  $  TAB2 if t is equal to 1 and a is equal to 3 ;  $  TAB3 assign 2 to t ;  $  TAB3 continue ;  $  TAB1 print "YES" ;
TAB1 display Karen ;
TAB0 let maxn be const integer with maxn = 100005 ;  $  TAB1 let l, r, a be integers ;  $  TAB1 read l, r, a ;  $  TAB1 while a is greater than 0 ;  $  TAB2 if l is less than r ;  $  TAB3 increment l ;  $  TAB2 else ;  $  TAB3 increment r ;  $  TAB2 decrement a ;  $  TAB1 print min of l, r multiplied by 2 ;
TAB1 let k, r be integers ;  $  TAB1 read k, r ;  $  TAB1 let flag be integer ;  $  TAB1 for i = 1 to 1000 inclusive ;  $  TAB2 set flag to k * i ;  $  TAB2 if flag mod 10 is r or flag mod 10 is zero ;  $  TAB3 print out i with newline ;  $  TAB2 set flag to k ;
TAB0 let n, m, i, j, k, mi, ma be integers ;  $  TAB0 let a be integer array of size 10000 ;  $  TAB0 let s be string ;  $  TAB1 read n, m, mi, ma ;  $  TAB1 for I = 1 to m inclusive, read a[i] ;  $  TAB1 call sort with a+1, a+m+1 ;  $  TAB1 if ma > a[m], increment j ;  $  TAB1 if mi < a[1], increment j ;  $  TAB1 if ma < a[m] or mi > a[1] ;  $  TAB2 print Incorrect ;  $  TAB1 if n-m >= j ;  $  TAB2 print Correct ;  $  TAB1 else ;  $  TAB2 print Incorrect ;
TAB0 let s be a string ;  $  TAB1 input s ;  $  TAB1 let l be an integer with l = the length of s ;  $  TAB1 for i = 0 to l exclusive ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 for k = 0 to 3 exclusive ;  $  TAB4 for p = 0 to 3 exclusive ;  $  TAB5 if j is unequal to k and j is unequal to p and k is unequal to p ;  $  TAB6 c1 = character = the character A + j ;  $  TAB6 c2 = character = the character A + k ;  $  TAB6 c3 = character = the character A + p ;  $  TAB6 if s[i] equals c1 and s[i + 1] equals c2 and s[i + 2] equals c3 ;  $  TAB7 display Yes ;  $  TAB1 display No ;
TAB0 a is an integer array of size 200010 ;  $  TAB1 declare an integer n ;  $  TAB1 declare an integer t ;  $  TAB1 while input n ;  $  TAB2 for i = 0 to n exclusive, input a[i] ;  $  TAB2 call sort with arguments a, a + n ;  $  TAB2 m = integer = (n - 2) / 2, minn = maximum supported integer ;  $  TAB2 for i = 0 to m inclusive, set minn to call min with arguments minn, a[i + m + 1] - a[i] ;  $  TAB2 display minn ;
TAB1 n.m = integers ;  $  TAB1 read n and m ;  $  TAB1 txt = string ;  $  TAB1 read txt ;  $  TAB1 for i=0 to m exclusive ;  $  TAB2 create integers st, en ;  $  TAB2 create chars old and update ;  $  TAB2 read st, en, old, update ;  $  TAB2 for j= st-1 to en exclusive ;  $  TAB3 if txt[j] is equal to old then set txt[j] to update ;  $  TAB1 print txt ;
TAB1 n=long long integer and a=array of long long integer of size 100010 ;  $  TAB1 read n ;  $  TAB1 create long long int mn=1999999999 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 set mn to minimum of mn and a[i] ;  $  TAB1 let pos and ans be ints with pos=0and ans=1999999999 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if a[i] is equal to mn ;  $  TAB3 if i-pos< ans and pos is true then set ans to i-pos ;  $  TAB3 assign i to pos ;  $  TAB1 print ans ;
TAB1 let n, b, d, a, sum, cc = long integers with sum = and cc = 0 ;  $  TAB1 let c = array of long integers size 100001 ;  $  TAB1 read n, b, d ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 read c[i] ;  $  TAB2 if c[i] is less than or equal to b set sum = sum + c[i] ;  $  TAB2 if sum is greater than d do the following ;  $  TAB3 set sum = 0 ;  $  TAB3 increment cc ;  $  TAB1 print cc ;
TAB1 t, s, q are integers ;  $  TAB1 res, p are integers with res = 1 ;  $  TAB1 read t, s, q ;  $  TAB1 set p to s ;  $  TAB1 add p * (q - 1) to p ;  $  TAB1 while p is less than t ;  $  TAB2 increment res ;  $  TAB2 add p * (q - 1) to p ;  $  TAB1 output res ;
TAB1 let T, N, R, sum, temp = integers ;  $  TAB1 read T ;  $  TAB1 let ans = array of integers of size T ;  $  TAB1 for integer i=0 to T exclusive do the following ;  $  TAB2 read N, R ;  $  TAB2 set sum = 0 ;  $  TAB2 for integer j=0 to N exclusive do the following ;  $  TAB3 read temp ;  $  TAB3 set sum = sum + temp ;  $  TAB2 set sum = sum modulo N ;  $  TAB2 set ans[i] = (N + R -sum) modulo N+1 ;  $  TAB1 for integer i=0 to T exclusive print ans[i] ;
TAB0 M is a constant long long set to 1e5 ;  $  TAB0 MOD is a constant long long set to 998244353 ;  $  TAB0 PI is a constant double set to 3.14159265358979323846 ;  $  TAB1 a, b are strings ;  $  TAB1 read a, b ;  $  TAB1 i and ans are both long longs both set to 0 ;  $  TAB1 while i is less than length of a ;  $  TAB2 c = long long = 0 ;  $  TAB2 for long long j = 0 to length of b exclusive ;  $  TAB3 if i + j is at least length of a, break ;  $  TAB3 if a[i + j] equals b[j], increment c ;  $  TAB2 increment i ;  $  TAB2 set ans to call max with ans, c ;  $  TAB1 set i to 0 ;  $  TAB1 while i is less than length of b ;  $  TAB2 c = long long = 0 ;  $  TAB2 for long long j = 0 to length of a exclusive ;  $  TAB3 if i + j is at least length of b, break ;  $  TAB3 if b[i + j] equals a[j], increment c ;  $  TAB2 increment i ;  $  TAB2 set ans to call max with ans, c ;  $  TAB1 display (length of b) - ans ;
TAB0 define const int MAXN = 128 ;  $  TAB0 declare int n, m, multidimensional array with length MAXN x MAXN, array b with length MAXN ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 define pos = -1, x = -1 ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 read a[i][j] ;  $  TAB3 if a[i][j] greater than x ;  $  TAB4 set pos to j ;  $  TAB4 set x to a[i][j] ;  $  TAB2 increment b[pos] ;  $  TAB1 define int pos = -1, x = -1 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if b[i] greater than x ;  $  TAB3 set pos to i ;  $  TAB3 set x to b[i] ;  $  TAB1 increment pos ;  $  TAB1 print pos ;  $  TAB1 return false ;
TAB1 make ints l, r, n, m ;  $  TAB1 make characters c1 and c2 ;  $  TAB1 make string s ;  $  TAB1 read n and m ;  $  TAB1 read s ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read l, r, c1, c2 ;  $  TAB2 for j = l to r inclusive ;  $  TAB3 if s.at(j - 1) equals c1 then set s.at(j - 1) to c2 ;  $  TAB1 print s ;
TAB1 n = long long integer ;  $  TAB1 read n ;  $  TAB1 a with n = long long vector ;  $  TAB1 i = long long integer ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 pi, ml = long long integers set to 0 ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if a[i] <= a[i - 1] ;  $  TAB3 d = long long integer set to i - pi ;  $  TAB3 set ml to max of d and ml ;  $  TAB3 set pi to i ;  $  TAB1 f = long long integer set to i - pi ;  $  TAB1 set ml to max of f and ml ;  $  TAB1 print ml ;
TAB1 let n, l = integer with n = 0 and l = 0 ;  $  TAB1 let str = string ;  $  TAB1 while ( read n) is true do the following ;  $  TAB2 for integer i=0 to n exclusive do the following ;  $  TAB3 read str ;  $  TAB3 set l = length of string ;  $  TAB3 if l is less than or equal to 10 ;  $  TAB4 print str ;  $  TAB3 else ;  $  TAB4 print str[0] and l - 2 and str[l - 1] ;
TAB1 str= array of char of size 105 by 105 ;  $  TAB1 n,m,i,j = integers ;  $  TAB1 read n and m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j=0 to m exclusive read str[i][j] ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if i&1 is true ;  $  TAB3 for j=0 to m exclusive ;  $  TAB4 if str[i][j] is equal to '-' then continue ;  $  TAB4 if j&1 is true ;  $  TAB5 set str[i][j] = 'B' ;  $  TAB4 else do the following ;  $  TAB5 set str[i][j] = 'W' ;  $  TAB2 else do the following ;  $  TAB3 for j=0 to m exclusive ;  $  TAB4 if str[i][j] = '-' then continue ;  $  TAB4 if j&1 is true ;  $  TAB5 set str[i][j] = 'W' ;  $  TAB4 else do the following ;  $  TAB5 set str[i][j] = 'B' ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 for j=0 to m exclusive ;  $  TAB3 print str[i][j] ;  $  TAB3 if j=m-1 then print a new line ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 let arr be int array of size 1000100 ;  $  TAB1 ans = integer = 0 ;  $  TAB1 min = integer = 2147483647 ;  $  TAB1 let pos be integer with pos = 0 ;  $  TAB1 read first n entries of arr ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] < min ;  $  TAB3 set min to arr[i] ;  $  TAB3 update pos to i ;  $  TAB1 let count be integer with count = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if arr[i] == min, increment count ;  $  TAB1 if count > 1 ;  $  TAB2 print "Still Rozdil" ;  $  TAB1 else ;  $  TAB2 print pos + 1 ;
TAB0 a is a long long integer array of length 20 ;  $  TAB0 b is a long long integer array of length 20 ;  $  TAB1 n is a long long integer ;  $  TAB1 input n ;  $  TAB1 output n / 2 + 1 ;
TAB1 let m = integer ;  $  TAB1 while (read m) is true do the following ;  $  TAB2 let k = integer of value 0 and c = array of integers of value 0, size 101 ;  $  TAB2 for integer i=1 to m+1 exclusive do the following ;  $  TAB3 read c[i] ;  $  TAB3 set c[i] = c[i] + c[i-1] ;  $  TAB2 let x, y = integers ;  $  TAB2 read x, y ;  $  TAB2 for integer i=1 to m+1 exclusive do the following ;  $  TAB3 if c[i] is greater than y or c[m] - c[i] is less than x exit the loop ;  $  TAB3 if c[i] is greater than or equal to x and c[m] - c[i] is less than or equal to y do the following ;  $  TAB4 set k = i+1 ;  $  TAB4 exit the loop ;  $  TAB2 print k ;
TAB1 n, i, p, q, count are integers with count set to 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read p, q ;  $  TAB2 if q - p is at least 2, increment count ;  $  TAB1 display count ;
TAB0 create a constant long double PI=3.141592653589793238L ;  $  TAB0 create a constant long long N=100005 ;  $  TAB1 s=array of character s of size 6 ;  $  TAB1 read 6 values into the array s ;  $  TAB1 create integer ar of size 6 with value 0 ;  $  TAB1 for i=0 to 6 exclusive ;  $  TAB2 if s[i] = 'R' then increment ar[0] ;  $  TAB2 if s[i] = 'O' then increment ar[1] ;  $  TAB2 if s[i] = 'Y' then increment ar[2] ;  $  TAB2 if s[i] = 'G' rhen increment ar[3] ;  $  TAB2 if s[i] ='B' then increment ar[4] ;  $  TAB2 if s[i] = 'V' then increment ar[5] ;  $  TAB1 sort array of ar ;  $  TAB1 if ar[5] = 6 or ar[5] = 5 ;  $  TAB2 print 1 and new line ;  $  TAB1 else if ar[5] = 4 ;  $  TAB2 print 2 and new line ;  $  TAB1 else if ar[5] = 3 and ar[4] = 1 ;  $  TAB2 print 5 and new line ;  $  TAB1 else if ar[5] = 3 and ar[4] = 2 ;  $  TAB2 print 3 and new line ;  $  TAB1 else if ar[5] = 3 and ar[4] = 3 ;  $  TAB2 print 2 and new line ;  $  TAB1 else if ar[5] = 2 and ar[4] = 1 ;  $  TAB2 print 15 and new line ;  $  TAB1 else if ar[5] = 2 and ar[4] = 2 and ar[3] = 2 ;  $  TAB2 print 6 and new line ;  $  TAB1 else if ar[5] = 2 and ar[4] = 2 ;  $  TAB2 print 8 and new line ;  $  TAB1 else if ar[5] = 1 ;  $  TAB2 print 30 and new line ;
TAB1 declare string cA, cB ;  $  TAB1 declare int n ;  $  TAB1 read cA, cB, n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 print cA, " ", cB ;  $  TAB2 declare string a, b ;  $  TAB2 read a and b ;  $  TAB2 if a equals cA ;  $  TAB3 swap cA with b ;  $  TAB2 else ;  $  TAB3 swap cB with b ;  $  TAB1 print cA, " ", cB ;
TAB0 in the function max with takes two long long int a and b and returns a long long integer ;  $  TAB1 return a if a>b else return b ;  $  TAB0 in the function min which takes two long long ints a and b and returns one of them ;  $  TAB1 return a if a<b else return b ;  $  TAB0 in the function modd which takes a long long integer a and returns a long long int ;  $  TAB1 if a<0LL then return a* -1LL ;  $  TAB1 return a ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 a,b= integer array of size n each ;  $  TAB1 read n values into the array a and b ;  $  TAB1 create integers rem and ans with rem=ans=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 set rem= rem- a[i] ;  $  TAB2 set rem= rem+ b[i] ;  $  TAB2 set ans to max of ans and rem ;  $  TAB1 print ans and new line ;
TAB1 n, k, x = integers ;  $  TAB1 v = integer ;  $  TAB1 read n, k, x ;  $  TAB1 set total to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read v ;  $  TAB2 if n - i < k ;  $  TAB3 add min of x and v to total ;  $  TAB2 else ;  $  TAB3 add v to total ;  $  TAB1 print total ;
TAB1 w,h,u1,d1,u2,d2 = integers ;  $  TAB1 read w ;  $  TAB1 read h ;  $  TAB1 read u1 ;  $  TAB1 read d1 ;  $  TAB1 read u2 ;  $  TAB1 read d2 ;  $  TAB1 create integer k=w ;  $  TAB1 for i=h to 0 exclusive ;  $  TAB2 set k= k+i ;  $  TAB2 if i is equal to d1 ;  $  TAB3 set k to k-u1 ;  $  TAB3 if k<0 then set k=0 ;  $  TAB2 else if i is equal to d2 ;  $  TAB3 set k to k-u2 ;  $  TAB3 if k is less than 0 then assign 0 to k ;  $  TAB1 print k ;
TAB1 let v be a vector of long long int ;  $  TAB1 let n, a, sum be long long integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read a ;  $  TAB2 add a to the back of v ;  $  TAB1 sort v ;  $  TAB1 set sum to v[v.size() - 1] - v[0] + 1 ;  $  TAB1 print out sum - v.size() ;
TAB1 create int n, m, x, y, flag = 1 ;  $  TAB1 read n and m ;  $  TAB1 create multidimensional char array mat of length n + 1 x m + 1 ;  $  TAB1 read n values into mat ;  $  TAB1 for i = 0 to n exclusive and flag ;  $  TAB2 for j = 0 to m exclusive ;  $  TAB3 if mat[i][j] is 'B' ;  $  TAB4 set x to i ;  $  TAB4 set y to j ;  $  TAB4 set flag to 0 ;  $  TAB4 break ;  $  TAB1 set flag to 1 ;  $  TAB1 for i = n - 1 to 0 inclusive and flag ;  $  TAB2 for j = m - 1 to 0 inclusive ;  $  TAB3 if mat[i][j] is 'B' ;  $  TAB4 increase x by i ;  $  TAB4 increase y by j ;  $  TAB4 set flag to 0 ;  $  TAB4 break ;  $  TAB1 divide x by itself and 2 ;  $  TAB1 divide y by itself and 2 ;  $  TAB1 print x + 1, " ", y + 1 ;
TAB1 declare int n, m, k t, x ;  $  TAB1 while reading n, m, k, and t is not interrupted ;  $  TAB2 declare int i ;  $  TAB2 for i = 1 to 10000000 exclusive ;  $  TAB3 if m is less than or equal to k * i ;  $  TAB4 set x to i ;  $  TAB4 break ;  $  TAB2 for i = 1 to 200000000 exclusive ;  $  TAB3 if i * t is greater than or equal to x * n ;  $  TAB4 print i ;  $  TAB4 break ;
TAB0 wz is an integer of length 202 ;  $  TAB1 let day be an integer ;  $  TAB1 for i = 0 to 202 exclusive, set wz[i] to 0 ;  $  TAB1 let n and m be integers ;  $  TAB1 input n and m ;  $  TAB1 for i = 0 to n exclusive, set wz[i] to 1 ;  $  TAB1 for i = 1 to 202 inclusive ;  $  TAB2 if wz[i - 1] equals 0 ;  $  TAB3 display i - 1 ;  $  TAB3 break ;  $  TAB2 if i is divisible by m ;  $  TAB3 set wz[n] to 1 ;  $  TAB3 increment n ;
TAB0 let a, b, c, d, e, tp, f, g, h, pi , qi, pas be long long and p, q be array of long long of size 100 ;  $  TAB0 let m be map of pair of long long and long long to long long ;  $  TAB1 read a ;  $  TAB1 for b = 1 to a inclusive ;  $  TAB2 read tp ;  $  TAB2 if tp is equal to 1 ;  $  TAB3 read c, d, e ;  $  TAB3 set pi to 0 ;  $  TAB3 while c is greater than 0 ;  $  TAB4 increment pi ;  $  TAB4 set p[pi] to c mod 2 ;  $  TAB4 set c to c/2 ;  $  TAB3 set c to d ;  $  TAB3 for d = 1 to pi/2 inclusive, call swap of p[d], p[pi - d + 1] ;  $  TAB3 set d to c ;  $  TAB3 set qi to 0 ;  $  TAB3 while d is greater than 0 ;  $  TAB4 increment qi ;  $  TAB4 set q[qi] to d mod 2 ;  $  TAB4 set d to d/2 ;  $  TAB3 for d = 1 to qi/2 inclusive, call swap of q[d], q[qi-d+1] ;  $  TAB3 set c to 0 ;  $  TAB3 set f to 0 ;  $  TAB3 for d = 1 to min of pi, qi inclusive ;  $  TAB4 if p[d] is equal to q[d] ;  $  TAB5 set g to c ;  $  TAB5 if p[d] is equal to 0 ;  $  TAB6 set c to c * 2 ;  $  TAB5 else ;  $  TAB6 set c to c * 2 + 1 ;  $  TAB4 else ;  $  TAB5 break ;  $  TAB3 set f to d ;  $  TAB3 set h to c ;  $  TAB3 for d = f to pi inclusive ;  $  TAB4 set q to c ;  $  TAB4 if p[d] is equal to 0 ;  $  TAB5 set c to c*2 ;  $  TAB4 else ;  $  TAB5 set c to c*2 + 1 ;  $  TAB4 increment m[make_pair of g, c] by e ;  $  TAB3 set c to h ;  $  TAB3 for d = f to qi inclusive ;  $  TAB4 set g to c ;  $  TAB4 if q[d] is equal to 0 ;  $  TAB5 update c to c*2 ;  $  TAB4 else ;  $  TAB5 update c to c*2 _ 1 ;  $  TAB4 increment m[make_pair of g, c] by e ;  $  TAB2 else ;  $  TAB3 read c, d ;  $  TAB3 set pas to 0 ;  $  TAB3 set pi to 0 ;  $  TAB3 while c is greater than 0 ;  $  TAB4 increment pi ;  $  TAB4 update p[pi] to c mod 2 ;  $  TAB4 update c to c/2 ;  $  TAB3 set c to d ;  $  TAB3 for d = 1 to pi/2 inclusive, call swap of p[d], p[pi-d+1] ;  $  TAB3 set d to c ;  $  TAB3 set qi to 0 ;  $  TAB3 while d is greater than 0 ;  $  TAB4 increment qi ;  $  TAB4 update q[qi] to d mod 2 ;  $  TAB4 update d to d/2 ;  $  TAB3 for d = 1 to qi/2 inclusive, call swap of q[d], q[qi-d+1] ;  $  TAB3 set c to 0 ;  $  TAB3 set f to 0 ;  $  TAB3 for d = 1 to min of pi, qi ;  $  TAB4 if p[d] is equal to q[d] ;  $  TAB5 set g to c ;  $  TAB5 if p[d] is equal to 0 ;  $  TAB6 update c to c*2 ;  $  TAB5 else ;  $  TAB6 update c to c*2 + 1 ;  $  TAB4 else ;  $  TAB5 break ;  $  TAB3 set f to d ;  $  TAB3 set h to c ;  $  TAB3 for d = f to pi inclusive ;  $  TAB4 set g to c ;  $  TAB4 if p[d] is equal to 0 ;  $  TAB5 update c to c*2 ;  $  TAB4 else ;  $  TAB5 update c to c*2 + 1 ;  $  TAB4 update pas to pas + m[make_pair of g, c] ;  $  TAB3 set c to h ;  $  TAB3 for d = f to qi inclusive ;  $  TAB4 set g to c ;  $  TAB4 if q[d] is equal to 0 ;  $  TAB5 update c to c*2 ;  $  TAB4 else ;  $  TAB5 update c to c*2 + 1 ;  $  TAB4 increment pas by m[make_pair of g, c] ;  $  TAB3 print out pas with newline ;
TAB1 let n be integer ;  $  TAB1 read n ;  $  TAB1 if n is odd ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB1 let str = string ;  $  TAB1 read str ;  $  TAB1 let len = int = size of str ;  $  TAB1 for every element in str ;  $  TAB2 if str[i] equals 'r', print i + 1 ;  $  TAB1 for every element int str backwards ;  $  TAB2 if str[i] equals ' ;
TAB1 n,x = long long integer ;  $  TAB1 read n and x ;  $  TAB1 create long long int dis=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 a= character ;  $  TAB2 d= long long integer ;  $  TAB2 read a and d ;  $  TAB2 if a= + then set x= x + d ;  $  TAB2 if a = - ;  $  TAB3 if d>x ;  $  TAB4 then increment dis ;  $  TAB3 else do the following ;  $  TAB4 set x= x- d ;  $  TAB1 print x and dis and new line ;
TAB1 n, k, t, i are integers ;  $  TAB1 a is an integer array of size 15 ;  $  TAB1 set a[0] to 0 ;  $  TAB1 read n, k ;  $  TAB1 if 5 * (1 + n) * n / 2 is at most 240 - k ;  $  TAB2 display n ;  $  TAB1 assign 240 to t ;  $  TAB1 for i = 1 to 1 + n exclusive ;  $  TAB2 set a[i] to i * 5 + a[i - 1] ;  $  TAB2 if a[i] is greater than t - k, break ;  $  TAB1 display i - 1 ;
TAB0 create constant integer inf = 0x3f3f3f3f ;  $  TAB0 create constant integer maxn =110 ;  $  TAB0 in the function max which takes a and b integers and returns their max value ;  $  TAB1 return a if a>b else return b ;  $  TAB0 in the function min which takes two integers a and b and returns a integer ;  $  TAB1 return b if a>b else return a ;  $  TAB0 create an integer array a of size maxn ;  $  TAB1 i,n= integers ;  $  TAB1 while entered value of n is valid ;  $  TAB2 read n values into the array a ;  $  TAB2 l = integer ;  $  TAB2 maxi = integer with value 1 ;  $  TAB2 for l=0 to n-1 exclusive ;  $  TAB3 create integer pos=l ;  $  TAB3 while l<n-1 and a[l]+1 = a[l+1] increment l ;  $  TAB3 if l - pos + 1 > maxi then set maxi = l - pos + 1 ;  $  TAB2 create integer cnt1=1 ;  $  TAB2 if a[0] is 1 ;  $  TAB3 for i=0 to maxi-1 exclusive ;  $  TAB4 if a[i]+1 is not equal to a[i+1] ;  $  TAB5 then break ;  $  TAB4 else do the following ;  $  TAB5 add 1 to cnt1 ;  $  TAB2 create integer cnt2=1 ;  $  TAB2 if a[n-1] is equal to 1000 ;  $  TAB3 for i=0 to maxi-1 exclusive ;  $  TAB4 if a[n - 1 - i] - 1 is not equal to a[n - 1 - i - 1] ;  $  TAB5 break ;  $  TAB4 else do the following ;  $  TAB5 add 1 to cnt2 ;  $  TAB2 if cnt1 = maxi or cnt2=maxi ;  $  TAB3 print maxi-1 and new line ;  $  TAB2 else do the following ;  $  TAB3 print maxi - 2 ;
TAB1 n,m,t = integers with t=0 ;  $  TAB1 read n and m ;  $  TAB1 while n is true ;  $  TAB2 increment t ;  $  TAB2 if t%m is 0 then increment n ;  $  TAB2 decrement n ;  $  TAB1 print t ;
TAB0 declare integer function judge taking in integer i ;  $  TAB1 let ans = integer with value = 0 ;  $  TAB1 while i is not equal to 0 do the following ;  $  TAB2 set ans = ans + i modulo 10 ;  $  TAB2 set i = i /10 ;  $  TAB1 return ans ;  $  TAB0 let num = array of integers with size = 100000 ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let cont = integer with value = 0 ;  $  TAB1 for integer i=max of 1, n-100 to n inclusive do the following ;  $  TAB2 let ans = integer with value = 0 ;  $  TAB2 set ans = i + judge[i] ;  $  TAB2 if ans is n set num[increment cont] = i ;  $  TAB1 if cont is 0 do the following ;  $  TAB2 print 0 ;  $  TAB2 print a new line ;  $  TAB1 else do the following ;  $  TAB2 print cont ;  $  TAB2 for integer i=0 to cont exclusive print num[i] ;
TAB1 make integers k, m, n1, n2 ;  $  TAB1 read n1, n2, k, and m ;  $  TAB1 make vector<int> a of size n1 ;  $  TAB1 for i = 0 to a size exclusive, read a[i] ;  $  TAB1 make vector<int> b of size n2 ;  $  TAB1 for i = 0 to b size exclusive, read b[i] ;  $  TAB1 if a[k - 1] less than b[n2 - m] ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB1 let n be a long long integer ;  $  TAB1 input n ;  $  TAB1 let x be a long long integer with x = 0 ;  $  TAB1 while n is greater than or equal to 1 ;  $  TAB2 if n is even ;  $  TAB3 divide n by 2 ;  $  TAB2 else ;  $  TAB3 increment x ;  $  TAB3 decrement n ;  $  TAB1 output x ;
TAB1 let n be integer and a be array of integers with a = array of 2,7,2,3,3,4,2,5,1,2 ;  $  TAB1 while there is input, set it to n and print out a[n/10] * a[n%10] ;
TAB1 let n, x = integer ;  $  TAB1 while ( read n, x) is true do the following ;  $  TAB2 let cnt = integer with value = 0 ;  $  TAB2 for integer i=1 to n inclusive do the following ;  $  TAB3 let quo = integer with value x / i ;  $  TAB3 if quo is less than or equal to n and quo * i is x increment cnt ;  $  TAB2 print cnt ;
TAB1 num = string ;  $  TAB1 read num ;  $  TAB1 r0, r1 = strings, r0 set to "O-" and r1 set to "-O" ;  $  TAB1 left = array of strings length 5 set to "|-OOOO", "|O-OOO", "|OO-OO", "|OOO-O", "|OOOO-" ;  $  TAB1 for i = length of num - 1 to 0 inclusive, while decrementing i by 1 ;  $  TAB2 if num[i] - '0' is >= 5 ;  $  TAB3 print r1 + left[(num[i] - '0') - 5] ;  $  TAB2 else ;  $  TAB3 print r0 + left[num[i] - '0'] ;
TAB0 declare A which takes in integers l, r, and a ;  $  TAB1 s, ab = integers ;  $  TAB1 if l is r ;  $  TAB2 set s to 0 ;  $  TAB2 if a isn't 0, set s to a / 2 ;  $  TAB2 print l + r + 2 * s ;  $  TAB1 if l< r ;  $  TAB2 if a + l <=r ;  $  TAB3 print 2 * a + 1 ;  $  TAB2 else ;  $  TAB3 set ab to a - r - 1 / 2 ;  $  TAB3 print absolute value of ab * 2 + 2 * r ;  $  TAB1 if r < 0 ;  $  TAB2 if a + r <= 1 ;  $  TAB3 print c * a + r ;  $  TAB2 else ;  $  TAB3 set ab to a - l - r / 2 ;  $  TAB3 print absolute value of ab * 2 + 2 * 1 ;  $  TAB1 l, r, a = integers ;  $  TAB1 read l, r and a ;  $  TAB1 run A of l, r and a ;
TAB0 define constant integer MAXN = 100001 ;  $  TAB0 define constant integer inf = 1000000000 ;  $  TAB0 define constant long double INF = 1.0 / 0.0 ;  $  TAB0 define constant long double EPS = 1e-7 ;  $  TAB0 define constant int mod = inf + 7 ;  $  TAB0 define constant long double PI = acos(-1.0) ;  $  TAB1 declare set<long long> x ;  $  TAB1 long long i = 3 to 228228 exclusive ;  $  TAB2 if (i - 2) * 180 mod i equals 0, insert (i - 2) * 180 / i into x ;  $  TAB1 declare long long t ;  $  TAB1 read t ;  $  TAB1 while t decremented ;  $  TAB2 declare long long a ;  $  TAB2 read a ;  $  TAB2 if x.find(a) not equal to x.end() ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 if n greater than or equal to 0 ;  $  TAB2 print n ;  $  TAB1 else ;  $  TAB2 if n modulo 10 less than n modulo 100 / 10 ;  $  TAB3 print n / 10 ;  $  TAB2 else ;  $  TAB3 create int digit = abs(n) modulo 10 ;  $  TAB3 set n to abs(n) / 100 * -10 - digit ;  $  TAB3 print n ;
TAB1 let a= 1000 arrays of characters of size 1000 ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 for integer j=0 to n exclusive do the read a[i][j] ;  $  TAB1 let sum = integer with value = 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let c = integer with value = 0 ;  $  TAB2 for integer j=0 to n exclusive do the following ;  $  TAB3 if a[i][j] is C increment c ;  $  TAB2 set sum = sum + c * (c-1) / 2 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let c = integer with value = 0 ;  $  TAB2 for integer j=0 to n exclusive do the following ;  $  TAB3 if a[j][i] is C increment c ;  $  TAB2 set sum = sum + c * (c-1) / 2 ;  $  TAB1 print sum ;
TAB0 Grades = char array of size 200005 ;  $  TAB1 let lfp, zp, n, i, t, last be integers with lfp = -1 ;  $  TAB1 let carryFlag, pf be boolean with carryFlag = false, pf = false ;  $  TAB1 read n, t, Grades[1] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if Grades[i] == '.' ;  $  TAB3 increment i ;  $  TAB3 break out of for loop ;  $  TAB1 while Grades[i] and t > 0 ;  $  TAB2 if Grades[i] is greater than or equal to '5' ;  $  TAB3 set lfp to i ;  $  TAB3 break ;  $  TAB2 increment i ;  $  TAB1 while (-lfp) is not zero and t > 0 and pf is false ;  $  TAB2 if Grades[lfp - 1] == '.' ;  $  TAB3 set Grades[lfp - 1] to 0 ;  $  TAB3 increment Grades[lfp - 2] ;  $  TAB3 update last to lfp - 2 ;  $  TAB3 set pf to true ;  $  TAB2 else ;  $  TAB3 update Grades[lfp] to 0 ;  $  TAB3 increment Grades[lfp - 1] ;  $  TAB3 update last to lfp - 1 ;  $  TAB2 set lfp to -1 ;  $  TAB2 decrement t ;  $  TAB2 if Grades[last] > '9' ;  $  TAB3 let c be integer with c = 1 ;  $  TAB3 set Grades[last] to '0' ;  $  TAB3 decrement last ;  $  TAB3 while c is not zero ;  $  TAB4 set c to 0 ;  $  TAB4 if Grades[last] == '.' ;  $  TAB5 set Grades[last] to '\0' ;  $  TAB5 increment Grades[last - 1] ;  $  TAB5 decrement last by 2 ;  $  TAB5 set pf to true ;  $  TAB4 else if last == '\0' ;  $  TAB5 set carryFlag to true ;  $  TAB5 set Grades[0] to '1' ;  $  TAB5 break ;  $  TAB4 else ;  $  TAB5 increment Grades[last] ;  $  TAB4 if Grades[last] > '9' ;  $  TAB5 if not pf ;  $  TAB6 set Grades[last] to '\0' ;  $  TAB5 else ;  $  TAB6 set Grades[last] to '0' ;  $  TAB5 decrement last ;  $  TAB5 set c to 1 ;  $  TAB4 if Grades[last] >= '5', set lfp to last ;  $  TAB2 else if Grades[last] >= '5' ;  $  TAB3 set lfp to last ;  $  TAB1 if carryFlag is true ;  $  TAB2 print out first element of Grades ;  $  TAB1 else ;  $  TAB2 print out second element of Grades ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 if n - 10 equals 10 ;  $  TAB2 print 15 ;  $  TAB1 else if n - 10 equals 1 or n - 10 equals 11 ;  $  TAB2 print 4 ;  $  TAB1 else if n - 10 is at most 9 and n - 10 is at least 2 ;  $  TAB2 print 4 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB0 n, k are integers ;  $  TAB0 in function judge with parameter integer x and return integer ;  $  TAB1 a is an integer array of size 11 with a = 0 ;  $  TAB1 while x ;  $  TAB2 p is an integer with p = x modulo 10 ;  $  TAB2 a[p] is assigned 1 ;  $  TAB2 divide x by 10 ;  $  TAB1 for i = 0 to k inclusive ;  $  TAB2 if a[i] doesn't equal 1, return 0 ;  $  TAB1 return 1 ;  $  TAB1 while read n, k ;  $  TAB2 sum is an integer with sum = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 declare an integer x ;  $  TAB3 read n ;  $  TAB3 declare an integer p with p = call judge with argument x ;  $  TAB3 if p equals 1, increment sum ;  $  TAB2 display sum ;
TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 if 1 > 4 * floor(n * sqrt(2)) ;  $  TAB2 print 1 and a new line ;  $  TAB1 else do the following ;  $  TAB2 print (long long)(4 * (long long)(floor(n * sqrt(2)))) ;
TAB0 declare function output1 taking in integer x ;  $  TAB1 for integer i=0 to x exclusive print * ;  $  TAB0 declare function output2 taking in integer x ;  $  TAB1 for integer i=0 to x exclusive print D ;  $  TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 for integer i=n /2 to 0 inclusive decrementing do the following ;  $  TAB2 call output1 on i ;  $  TAB2 call output2 on n - 2 * i ;  $  TAB2 call output1 on i ;  $  TAB2 print a new line ;  $  TAB1 for integer i=1 to n / 2 inclusive do the following ;  $  TAB2 call output1 on i ;  $  TAB2 call output2 on n - 2 * i ;  $  TAB2 call output1 on i ;  $  TAB2 print a new line ;
TAB1 declare integers k, a, b, v ;  $  TAB1 while read k, a, b, v ;  $  TAB2 define integer ans = 0 ;  $  TAB2 while a ;  $  TAB3 define integer sec = 0 ;  $  TAB3 if k greater than or equals b + 1 ;  $  TAB4 assign b + 1 to sec ;  $  TAB4 assign 0 to b ;  $  TAB3 else ;  $  TAB4 assign k to sec ;  $  TAB4 decrease b by k - 1 ;  $  TAB3 define integer num = sec * v ;  $  TAB3 if num greater than a ;  $  TAB4 assign 0 to a ;  $  TAB3 else ;  $  TAB4 decrease a by num ;  $  TAB3 add 1 to ans ;  $  TAB2 print ans ;
TAB1 a, b, r are integers ;  $  TAB1 read a, b, and r ;  $  TAB1 if 2 * r is greater than call min with arguments a, b ;  $  TAB2 display Second ;  $  TAB1 else ;  $  TAB2 display First ;  $  TAB1 return true bitwise and false ;
TAB1 let n be an integer ;  $  TAB1 read n ;  $  TAB1 let arr be an integer array of size n ;  $  TAB1 if n equals 1 ;  $  TAB2 read n ;  $  TAB2 if n equals 0 ;  $  TAB3 display UP ;  $  TAB2 else if n equals 15 ;  $  TAB3 display DOWN ;  $  TAB2 else ;  $  TAB3 display -1 ;  $  TAB1 else ;  $  TAB2 read n values into array arr ;  $  TAB2 if arr[n] equals 15 ;  $  TAB3 display DOWN ;  $  TAB2 else if arr[n] equals 0 ;  $  TAB3 display UP ;  $  TAB2 else if arr[n] is less than arr[n - 1] ;  $  TAB3 display DOWN ;  $  TAB2 else ;  $  TAB3 display UP ;
TAB1 n, x, tmp, sum, ans are integers with sum = 0 ;  $  TAB1 read n, x ;  $  TAB1 iterate n times ;  $  TAB2 read tmp ;  $  TAB2 add tmp to sum ;  $  TAB1 set ans to absolute value (sum / x) ;  $  TAB1 if absolute value (sum mod x) is positive, increment ans ;  $  TAB1 print ans ;
TAB1 let n, m, min, max, rec be integers ;  $  TAB1 read n, m, min, max ;  $  TAB1 let minr, maxr be integers with minr = max + 1 and maxr = min - 1 ;  $  TAB1 for i = 0 to m exclusive ;  $  TAB2 read rec ;  $  TAB2 if rec is less than minr, set minr to rec ;  $  TAB2 if rec is greater than maxr, set maxr to rec ;  $  TAB1 let reqrec be integer with reqrec = 2 ;  $  TAB1 if min is equal to minr, decrement reqrec ;  $  TAB1 if max is equal to maxr, decrement reqrec ;  $  TAB1 if min is greater than minr or max is less than maxr, set reqrec to -1 ;  $  TAB1 if reqrec is equal to -1 or n - m is less than reqrec ;  $  TAB2 print out Incorrect ;  $  TAB1 else ;  $  TAB2 print out Correct ;  $  TAB1 read n ;
TAB0 n,p= integers ;  $  TAB0 s,t,a,b = strings ;  $  TAB0 ma = map<pair<string, string>, bool> ;  $  TAB1 read n ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 if i is not equal to 0 then read s ;  $  TAB2 read s and t ;  $  TAB2 if ma[{s, t}] then continue ;  $  TAB2 set ma[{s,t}] to 1 ;  $  TAB2 set a=b = "" ;  $  TAB2 set a = a + t[0] ;  $  TAB2 set a = a + s[0] ;  $  TAB2 set b = b+ t[1] ;  $  TAB2 set b = b +s[1] ;  $  TAB2 set ma[{a, b}] = 1 ;  $  TAB2 set a=b="" ;  $  TAB2 set a= a+ t[1] ;  $  TAB2 set a=a+ t[0] ;  $  TAB2 set b=b+s[1] ;  $  TAB2 set b=b+s[0] ;  $  TAB2 set ma[{a, b}] = 1 ;  $  TAB2 set a=b="" ;  $  TAB2 set a=a+ s[1] ;  $  TAB2 set a=a+ t[1] ;  $  TAB2 set b=b+s[0] ;  $  TAB2 set b=b+t[0]; ;  $  TAB2 set ma[{a, b}] = 1 ;  $  TAB2 increment p ;  $  TAB1 print p ;
TAB1 let n,h,i,j be ints with h=0 and i=j=1 ;  $  TAB1 read n ;  $  TAB1 while n-i>=0 ;  $  TAB2 set n=n-i ;  $  TAB2 add 1 to j ;  $  TAB2 set i=i+j ;  $  TAB2 increment h ;  $  TAB1 print h ;
TAB1 n=integer ;  $  TAB1 v= integer vector ;  $  TAB1 a=integer ;  $  TAB1 read n ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 add a to end of v ;  $  TAB1 if v[n-1] = 15 then ;  $  TAB2 print DOWN and new line ;  $  TAB1 if v[n-1] = 0 ;  $  TAB2 then print UP and new line ;  $  TAB1 if n=1 and v[0] is not 0 and v[0] is not 15 ;  $  TAB2 print -1 ;  $  TAB1 set a= v[n-1] - v[n-2] ;  $  TAB1 if a<0 ;  $  TAB2 then print DOWN and new line ;  $  TAB1 else do the following ;  $  TAB2 print UP and new line ;
TAB0 create long long n, m, a ;  $  TAB0 create long long mod = 1000000 + 3 ;  $  TAB0 in function poww returning long long, taking long long x and long long y ;  $  TAB1 if y equals 0, return 1 ;  $  TAB1 if y equals 1, return x ;  $  TAB1 if y is odd, return ((poww(x, y / 2) % mod) * (poww(x, y / 2) % mod) * (x % mod)) % mod ;  $  TAB1 return ((poww(x, y / 2) % mod) * (poww(x, y / 2) % mod)) % mod ;  $  TAB1 read n ;  $  TAB1 if not n ;  $  TAB2 print 1 ;  $  TAB1 else ;  $  TAB2 print poww(3, n - 1) ;
TAB0 in function acceleration ;  $  TAB0 let long long const size = 1e2 ;  $  TAB0 declare vector<long long> g[size] ;  $  TAB0 declare int path[size][size] ;  $  TAB0 declare vector<long long> road ;  $  TAB1 call acceleration ;  $  TAB1 declare long long n, u, v, weight, begin, current, previous and define long long sum1 = 0, sum2 = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read n, v, weight ;  $  TAB2 decrement u ;  $  TAB2 decrement v ;  $  TAB2 if i == 0 then begin = u ;  $  TAB2 append v to g[u] ;  $  TAB2 append u to g[v] ;  $  TAB2 let path[v][u] = weight ;  $  TAB1 set current to g[begin][0] ;  $  TAB1 append begin to road ;  $  TAB1 set previous to begin ;  $  TAB1 while current != begin ;  $  TAB2 append current to road ;  $  TAB2 if g[current][0] == previous ;  $  TAB3 set previous to current ;  $  TAB3 set current to g[current][1] ;  $  TAB2 else ;  $  TAB3 set previous to current ;  $  TAB3 set current to g[current][0] ;  $  TAB1 for i = 1 to n exclusive: increase sum1 by path[road[i - 1]][road[i]] ;  $  TAB1 increase sum1 by path[road[n - 1]][road[0]] ;  $  TAB1 for i = n - 1 to 0 exclusive: increase sum2 by path[road[i]][road[i - 1]] ;  $  TAB1 increase sum2 by path[road[0]][road[n - 1]] ;  $  TAB1 print min of sum1 and sum2 ;
TAB0 n, wnk are integers with wnk = 0 ;  $  TAB0 Tb = boolean array of length 102 ;  $  TAB1 readn ;  $  TAB1 set Tb[0] to 0 ;  $  TAB1 set Tb[n + 1] to 0 ;  $  TAB1 read n values into array Tb ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if Tb[i] ;  $  TAB3 increment wnk ;  $  TAB2 else if not Tb[i] and (Tb[i - 1] and Tb[i + 1]) ;  $  TAB3 increment wnk ;  $  TAB1 print wnk ;
TAB0 in function ui with parameter integer x and return long long ;  $  TAB1 i is an integer ;  $  TAB1 k is an integer set to 0 ;  $  TAB1 for i = 1 to x inclusive, add i to k ;  $  TAB1 return k ;  $  TAB1 n is an integer ;  $  TAB1 while input n ;  $  TAB2 i is an integer ;  $  TAB2 u is an integer ;  $  TAB2 t is a long long set to 0 ;  $  TAB2 for i = 1 to 100000 exclusive ;  $  TAB3 set t to t + call ui with argument i ;  $  TAB3 if n is at least t ;  $  TAB4 assign i to u ;  $  TAB3 else ;  $  TAB4 break ;  $  TAB2 display u ;
TAB0 declare integer function gcd which takes in integers a and b ;  $  TAB1 let i, g = integers ;  $  TAB1 for i=0 to a and b inclusive ;  $  TAB2 if a modulo i is 0 and b modulo i is 0 set g = i ;  $  TAB1 return g ;  $  TAB1 let i, j, t, l = integers ;  $  TAB1 read t ;  $  TAB1 let a = array of integers of size t ;  $  TAB1 read t values into array a ;  $  TAB1 set l = result of call to gcd on a[0] and a[1] ;  $  TAB1 for j=2 to t-1 inclusive set l = result of call to gcd on l and a[j] ;  $  TAB1 print l * t ;
TAB0 maxx is a constant integer with maxx = 1e6 ;  $  TAB0 a is an integer array of length maxx ;  $  TAB0 in function read and return integer ;  $  TAB1 declare an integer k ;  $  TAB1 input k ;  $  TAB1 return k ;  $  TAB0 declare a long long sum ;  $  TAB0 declare long longs n and m ;  $  TAB0 Max, A, S are long longs with Max = 0 ;  $  TAB1 input n ;  $  TAB1 if n mod 10 is at most 5 ;  $  TAB2 subtract (n mod 10) from n ;  $  TAB1 else ;  $  TAB2 assign n - n mod 10 + 10 to n ;  $  TAB1 display n ;
TAB0 make int n, k, a, s = 0, all = 0 ;  $  TAB1 read n, k ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 increase a by s ;  $  TAB2 assign 0 to s ;  $  TAB2 if a greater than 8 ;  $  TAB3 increase s by a - 8 ;  $  TAB3 assign 8 to a ;  $  TAB2 increase all by a ;  $  TAB2 if all is greater than or equal to k ;  $  TAB3 print i ;  $  TAB1 print -1 ;
TAB1 n, m, cnt = integers with cnt set to 0 ;  $  TAB1 str = string ;  $  TAB1 arr = array of integers with length 15 ;  $  TAB1 read n, m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m inclusive, set arr[j] to 0 ;  $  TAB2 read str ;  $  TAB2 len = integer set to length of str ;  $  TAB2 for j = 0 to len exclusive, set arr[str[j]] - '0'] to 1 ;  $  TAB2 flag = integer set to 0 ;  $  TAB2 for j = 0 to m inclusive ;  $  TAB3 if arr[j] is 0 ;  $  TAB4 set flag to 1 ;  $  TAB4 break ;  $  TAB2 if flag is falsey, increment cnt by 1 ;  $  TAB1 print cnt ;
TAB1 let t, s, q, ans be integers with ans = 1 ;  $  TAB1 terminate statement ;  $  TAB1 read t, s, q ;  $  TAB1 while q * s is less than t ;  $  TAB2 increment ans ;  $  TAB2 multiply s by q ;  $  TAB1 output ans ;
TAB1 let x, y, z, a = integers ;  $  TAB1 read x, y, z ;  $  TAB1 set a = square root of x * y / z ;  $  TAB1 set a = a + square root of x * z / y ;  $  TAB1 set a = a + square root of z * y / x ;  $  TAB1 print a * 4 ;
TAB1 declare int n ;  $  TAB1 read n ;  $  TAB1 declare string arr[n][2] ;  $  TAB1 for r = 0 to n exclusive: read arr[r][0] and arr[r][1] ;  $  TAB1 for r = 0 to n exclusive ;  $  TAB2 if arr[r][1] == "rat" then print arr[r][0] ;  $  TAB1 for r = 0 to n exclusive ;  $  TAB2 if arr[r][1] == "woman" or arr[r][1] == "child" then print arr[r][0] ;  $  TAB1 for r = 0 to n exclusive ;  $  TAB2 if arr[r][1] == "man" then print arr[r][0] ;  $  TAB1 for r = 0 to n exclusive ;  $  TAB2 if arr[r][1] == "captain" then print arr[r][0] ;
TAB1 n is an integer ;  $  TAB1 a is an integer array of size 102 ;  $  TAB1 sum is an integer set to 0 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 add a[i] * (i - 1) * 4 to sum ;  $  TAB1 display sum ;
TAB0 create integer n, array a with size 105 ;  $  TAB0 create map mp of char to int ;  $  TAB1 read n ;  $  TAB1 set mp['R'] to 5 ;  $  TAB1 set mp['G'] to 6 ;  $  TAB1 set mp['B'] to 7 ;  $  TAB1 set mp['Y'] to 8 ;  $  TAB1 set mp['W'] to 9 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 create stirng s ;  $  TAB2 read s ;  $  TAB2 create ints c, v ;  $  TAB2 set c to mp[s[0]] ;  $  TAB2 set v to s[1] - '0' - 1 ;  $  TAB2 set a[i] to (1 bitwise shift left c) bitwise or (1 bitwise shift left v) ;  $  TAB1 sort a [0:n) ;  $  TAB1 set n to unique(a, a + n) - a ;  $  TAB1 create integer ans = 11 ;  $  TAB1 for int mask = 0; msk less than (1 bitwise shift left 10); increment msk ;  $  TAB2 create bool f = true ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 for j = i + 1 to n exclusive ;  $  TAB4 create int t = a[i] bitwise XOR a[j] ;  $  TAB4 if (msk bitwise and t) equals 0 ;  $  TAB5 set f to false ;  $  TAB5 break ;  $  TAB3 if not f, break ;  $  TAB2 if f, set ans to min(ans, __builtin_popcount(msk)) ;  $  TAB1 print ans ;
TAB1 let a be integer ;  $  TAB1 read a, b ;  $  TAB1 print a % 2 ;
TAB1 define int test = 1 ;  $  TAB1 while test decremented is not equal to 0 ;  $  TAB2 declare int n, m, i, j, x, y, s, q, a, b, c ;  $  TAB2 declare long int k ;  $  TAB2 read n ;  $  TAB2 define int count = 0 ;  $  TAB2 while n is not equal to 0 ;  $  TAB3 set n to n & (n - 1) ;  $  TAB3 increment count ;  $  TAB2 print count and newline ;
TAB1 let int n, x, y, z, xsum = 0, ysum = 0, zsum = 0 ;  $  TAB1 read n ;  $  TAB1 while n decremented is not 0 ;  $  TAB2 read x, y, z ;  $  TAB2 increase xsum by x ;  $  TAB2 increase ysum by y ;  $  TAB2 increase zsum by z ;  $  TAB1 if xsum, ysum, and zsum all equal 0 ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 create int array arr of length 6 ;  $  TAB1 create int sum = 0 ;  $  TAB1 for i = 0 to 6 exclusive ;  $  TAB2 read arr[i] ;  $  TAB2 add arr[i] to sum ;  $  TAB1 for i = 0 to 4 exclusive ;  $  TAB2 for j = i + 1 to 5 exclusive ;  $  TAB3 for k = j + 1 to 6 exclusive ;  $  TAB4 create int curs = arr[i] + arr[j] + arr[k] ;  $  TAB4 if sum equals curs * 2 ;  $  TAB5 print "YES" ;  $  TAB1 print "NO" ;
TAB1 let n,t,k,d = integers, all = 0 ;  $  TAB1 read n,t,k,d ;  $  TAB1 if ((d+t) divided by t) times k is less than n ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 n, k are integers ;  $  TAB1 read n, k ;  $  TAB1 red is an integer set to ceiling (2 * n * 1.0 / k) ;  $  TAB1 green is an integer set to ceiling (5 * n * 1.0 / k) ;  $  TAB1 blue is an integer set to ceiling (8 * n * 1.0 / k) ;  $  TAB1 display red + green + blue ;
TAB0 let N be a constant long long with N = 1e9 + 3 ;  $  TAB0 let MN be a constant long long with MN = 1e9 ;  $  TAB0 k, n, s, p, c, cnt are all long longs ;  $  TAB1 read k, n, s, and p ;  $  TAB1 set c to (n + s - 1) / s ;  $  TAB1 set c to the product of c and k ;  $  TAB1 output (cnt + p - 1) / p ;  $  TAB1 output newline ;
TAB1 let a, b = integers ;  $  TAB1 let arr = 5 arrays of integers of size 5 ;  $  TAB1 for integer i=0 to 5 exclusive do the following ;  $  TAB2 for integer j=0 to 5 exclusive do the following ;  $  TAB3 read arr[i][j] ;  $  TAB3 if arr[i][j] is 1 do the following ;  $  TAB4 set a=i ;  $  TAB4 set b=j ;  $  TAB1 let k = integer ;  $  TAB1 while a is not equal to 2 do the following ;  $  TAB2 if a is greater than 2 do the following ;  $  TAB3 decrement a ;  $  TAB3 increment k ;  $  TAB2 else do the following ;  $  TAB3 increment a ;  $  TAB3 increment k ;  $  TAB1 while b is not equal to 2 do the following ;  $  TAB2 if b is greater than 2 do the following ;  $  TAB3 decrement b ;  $  TAB3 increment k ;  $  TAB2 else do the following ;  $  TAB3 increment b ;  $  TAB3 increment k ;  $  TAB1 print k ;
TAB1 create int n, sum, array a of size 1001 ;  $  TAB1 while reading n ;  $  TAB2 set sum to 0 ;  $  TAB2 for i = 0 to n exclusive, read a[i] ;  $  TAB2 for i =1 to n - 1 exclusive ;  $  TAB3 if a[i] is less than a[i - 1] ;  $  TAB4 if a[i] is less than a[i + 1], increment sum ;  $  TAB3 if a[i] is greater than a[i - 1] ;  $  TAB4 if a[i] is greater than a[i + 1], increment sum ;  $  TAB2 print sum ;
TAB1 create int n, p, q ;  $  TAB1 read n ;  $  TAB1 read p ;  $  TAB1 create int x ;  $  TAB1 create map m of int to bool ;  $  TAB1 for i = 0 to p exclusive ;  $  TAB2 read x ;  $  TAB2 set m[x] to true ;  $  TAB1 read q ;  $  TAB1 for i = 0 to q exclusive ;  $  TAB2 read x ;  $  TAB2 set m[x] to true ;  $  TAB1 create int flag = 0 ;  $  TAB1 if p + q is less than n ;  $  TAB2 print "Oh, my keyboard!" ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if m[i] equals false ;  $  TAB3 set flag to 1 ;  $  TAB3 print "Oh, my keyboard!" ;  $  TAB3 break ;  $  TAB1 if flag equals 0 then print "I become the guy." ;
TAB0 let ans = vector of integers ;  $  TAB1 let n, temp, temp1 = integers ;  $  TAB1 read n ;  $  TAB1 for integer i=1 to 90 inclusive do the following ;  $  TAB2 set temp = n - i ;  $  TAB2 if tmp is less than or equal to 0 exit the loop ;  $  TAB2 set temp1 = 0 ;  $  TAB2 while temp is true do the following ;  $  TAB3 let integer d = temp modulo 10 ;  $  TAB3 set temp1 = temp1 + d ;  $  TAB3 set temp = temp / 10 ;  $  TAB2 if temp1 is i append n-i to ans ;  $  TAB1 print size of ans ;  $  TAB1 for integer i = (size of ans-1) to 0 inclusive decrementing print ans[i] ;
TAB0 l = integer ;  $  TAB0 a, b = char array of size 150 ;  $  TAB1 read a, b ;  $  TAB1 set l to strlen of a ;  $  TAB1 for i = 0 to l exclusive ;  $  TAB2 if 'A' <= a[i] and a[i] <= 'Z', update a[i] to a[i] + 32 ;  $  TAB2 if 'A' <= b[i] and b[i] <= 'Z', update b[i] to b[i] + 32 ;  $  TAB2 if a[i] < b[i] ;  $  TAB3 print -1 ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 if b[i] < a[i] ;  $  TAB4 print 1 ;  $  TAB4 break ;  $  TAB3 else if a[i] == b[i] and i == l - 1 ;  $  TAB4 print 0 ;
TAB0 a = integer array of size 105 ;  $  TAB0 in function summ with parameters integers l, r and return long long ;  $  TAB1 ans = long long set to 0 ;  $  TAB1 for i = l to r inclusive, add a[i] to ans ;  $  TAB1 return ans ;  $  TAB1 declare an integer n ;  $  TAB1 input n ;  $  TAB1 sum = long long set to 0 ;  $  TAB1 ans = integer set to 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a[i] ;  $  TAB2 add a[i] to sum ;  $  TAB2 if a[i] is 0, increment ans ;  $  TAB1 if sum is 0 ;  $  TAB2 if ans is n ;  $  TAB3 print NO ;  $  TAB2 else ;  $  TAB3 for i = 1 to n exclusive ;  $  TAB4 if call summ with 1, i isn't 0 and call summ with i + 1, n isn't 0 ;  $  TAB5 print YES, newline, 2 ;  $  TAB5 print 1, " ", i ;  $  TAB5 print i + 1, " ", n ;  $  TAB5 break ;  $  TAB1 else ;  $  TAB2 print YES ;  $  TAB2 print 1 ;  $  TAB2 print 1, " ", n ;
TAB1 let i, j, k, l be integers ;  $  TAB1 a is an integer array of lengths 3 and 3 with a[3][3] = 1, 1, 1, 1, 1, 1, 1, 1, 1 ;  $  TAB1 b is an integer array of lengths 3 and 3 ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 for j = 0 to 3 exclusive, read b[i][j] ;  $  TAB1 for i = 0 to 3 exclusive ;  $  TAB2 for j = 0 to 3 exclusive ;  $  TAB3 if b[i][j] mod 2 equals 1 ;  $  TAB4 set a[i][j] to a[i][j] bitwise or 1 ;  $  TAB4 if i + 1 is at least 0 and j + 1 is at most 2, set a[i + 1][j] to a[i + 1][j] bitwise exclusive or 1 ;  $  TAB4 if j + 1 is at least 0 and j + 1 is at most 2, set a[i][j + 1] to a[i][j + 1] bitwise exclusive or 1 ;  $  TAB4 if i - 1 is at least 0 and i - 1 is at most 2, set a[i - 1][j] to a[i - 1][j] bitwise exclusive or1 ;  $  TAB4 if j - 1 is at least 0 and j - 1 is at most 2, set a[i][j - 1] to a[i][j - 1] bitwise exclusive or 1 ;  $  TAB1 for k = 0 to 3 exclusive ;  $  TAB2 for l = 0 to 3 exclusive, display a[k][l] ;  $  TAB2 print newline ;
TAB0 m = multimap from long long int to long long int ;  $  TAB1 let a, b, i, j be long long int ;  $  TAB1 read a and b ;  $  TAB1 flag = long long int with flag = 1 ;  $  TAB1 for i = 1 to a inclusive ;  $  TAB2 if i is odd ;  $  TAB3 for j = 0 to b exclusive print # ;  $  TAB3 print newline ;  $  TAB2 if i is even ;  $  TAB3 if flag is not zero ;  $  TAB4 for j = 0 to b -1 exclusive print out . ;  $  TAB4 print # and newline ;  $  TAB4 set flag to 0 ;  $  TAB3 if flag is zero ;  $  TAB4 print out # ;  $  TAB4 set flag to 1 ;  $  TAB4 for j = 0 to b-1 exclusive print . ;  $  TAB4 print newline ;
TAB1 n = integer ;  $  TAB1 input n ;  $  TAB1 while n ;  $  TAB2 d = integer ;  $  TAB2 input d ;  $  TAB2 if 360 modulo (180 - d) equals 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB2 decrement n ;
TAB1 b = string ;  $  TAB1 create char array sz of size 101 by 101 ;  $  TAB1 n.m = integer ;  $  TAB1 read n and m ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read b ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if b[j-1] is equal to . ;  $  TAB4 if (i+j)%2 = 1 ;  $  TAB5 set sz[i][j] = 'W' ;  $  TAB4 else do the following ;  $  TAB5 set sz[i][j] = 'B' ;  $  TAB3 else do the following ;  $  TAB4 set sz[i][j] = b[j - 1] ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 for j=1 to m inclusive print sz[i][j] ;  $  TAB2 print a new line ;
TAB1 x is an integer ;  $  TAB1 input x ;  $  TAB1 subtract 10 from x ;  $  TAB1 if x equals 10 ;  $  TAB2 print 15 ;  $  TAB1 else if x is at least 1 and x is at most 11 ;  $  TAB2 print 4 ;  $  TAB1 else ;  $  TAB2 print 0 ;
TAB0 man is a constant integer initialized to 1e5 + 5 ;  $  TAB0 mod is a constant long long initialized to 1e9 + 7 ;  $  TAB1 declare doubles l, a, b ;  $  TAB1 declare doubles t1, t2 ;  $  TAB1 declare doubles a1, a2 ;  $  TAB1 input l, a, and b ;  $  TAB1 assign 1 / (a + b) to t1 ;  $  TAB1 assign a * t1 to a1 ;  $  TAB1 display a1 ;
TAB0 a is an integer array of size 300005 ;  $  TAB1 n is a long long integer ;  $  TAB1 read n ;  $  TAB1 sum is a long long integer set to 0 ;  $  TAB1 read n values into array a ;  $  TAB1 call sort with a, a + n ;  $  TAB1 for long long integer i = 0 to n exclusive, add a[i] * (i + 2) to sum ;  $  TAB1 print sum - a[n - 1] ;
TAB0 in function ring with parameters integers a, b and return integer ;  $  TAB1 return 2 * a + 2 * b - 4 ;  $  TAB1 n, m, a are integers ;  $  TAB1 read n, m, a ;  $  TAB1 suma is an integer set to 0 ;  $  TAB1 for i = 1 to a inclusive, add call ring with n - 4 * i + 4, m - 4 * i + 4 to suma ;  $  TAB1 output suma ;
TAB0 in function teto, return type of int, parameters int num and int div ;  $  TAB1 if num equals 0, return 0 ;  $  TAB1 return 1 + (num - 1) / div ;  $  TAB1 n, m = ints ;  $  TAB1 read n, m ;  $  TAB1 a = int array of n elements ;  $  TAB1 for i = 0 to n exclusive, read a[i] ;  $  TAB1 mx = int = *max_element(a, a + n) ;  $  TAB1 ans2 = int = mx + m ;  $  TAB1 sort a ;  $  TAB1 aux = int = m ;  $  TAB1 for i = 0 to n - 1 exclusive ;  $  TAB2 if aux is less than a[n - 1] - a[i] ;  $  TAB3 print a[n - 1], " ", ans2 ;  $  TAB2 decrease aux by a[n - 1] - a[i] ;  $  TAB1 print a[n - 1] + teto(aux, n), " ", ans2 ;
TAB0 let m be map of string to integer ;  $  TAB0 let it be iterator of map of string to int ;  $  TAB1 x = string ;  $  TAB1 read x ;  $  TAB1 for i = size of x to till i is greater than 0, decrement i ;  $  TAB2 call clear on m ;  $  TAB2 for j = 0 to size of x - i inclusive ;  $  TAB3 let s be string of begin of x + j and begin of x + j + i ;  $  TAB3 increment m[s] ;  $  TAB2 for t = begin of m to end of m ;  $  TAB3 if it->second > 1, return 0 and print i ;  $  TAB1 print 0 ;
TAB1 print Karen ;
TAB0 n,m = integers ;  $  TAB0 s =string ;  $  TAB1 read n,m,s ;  $  TAB1 l,r = integers ;  $  TAB1 a,b = characters ;  $  TAB1 for i=0 to m exclusive ;  $  TAB2 read l,r,a,b ;  $  TAB2 for j=l-1 to r exclusive ;  $  TAB3 if s[j] is equal to a then set s[j] to b ;  $  TAB1 print s and new line ;
TAB1 create array of vector<int> v size 4 ;  $  TAB1 create int n, x, m = 5005 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read x ;  $  TAB2 push i onto v[x] ;  $  TAB1 for i = 1 to 3 inclusive, set m to min of v[i] size cas to int and m ;  $  TAB1 print m ;  $  TAB1 for i = 0 to m exclusive, print v[1][i] " " v[2][i] " " v[3][i] ;
TAB1 let s = string ;  $  TAB1 read s ;  $  TAB1 let ok = bool = 0 ;  $  TAB1 let len = int = s.size() cast to int ;  $  TAB1 for i = 0; i LESS THAN len AND NOT ok; ;  $  TAB2 if s[i] equals '1' and s[i + 1] equals '4' and s[i + 2] equals '4' ;  $  TAB3 increase i by 3 ;  $  TAB2 else if s[i] equals '1' and s[i + 1] equals '4' ;  $  TAB3 increase i by 2 ;  $  TAB2 else if s[i] equals '1' ;  $  TAB3 increment i ;  $  TAB2 else ;  $  TAB3 set ok to 1 ;  $  TAB1 if ok ;  $  TAB2 print "NO" ;  $  TAB1 else ;  $  TAB2 print "YES" ;
TAB0 let M be a constant integer with M = 50 + 5 ;  $  TAB1 declare integers n, m ;  $  TAB1 input n and m ;  $  TAB1 if n is equal to 0 ;  $  TAB2 if m is positive ;  $  TAB3 display Impossible ;  $  TAB2 else ;  $  TAB3 display "0 0" ;  $  TAB1 else ;  $  TAB2 if m is equal to 0 ;  $  TAB3 display n, " ", n ;  $  TAB2 else ;  $  TAB3 minv is an integer with minv = n + call max with arguments m - n, 0 ;  $  TAB3 maxv is an integer with maxv = n + m - 1 ;  $  TAB3 display minv, " ", maxv ;
TAB1 declare int n ;  $  TAB1 declare int x1, y1, x2, y2 ;  $  TAB1 while read n not interrupted ;  $  TAB2 define int s = 0 ;  $  TAB2 while n decremented is not equal to 0 ;  $  TAB3 read x1, y1, x2, y2 ;  $  TAB3 increase s by (x2 - x1 + 1) * (y2 - y1 + 1) ;  $  TAB2 print s ;
TAB0 declare function bricksort taking in integer array arr and integer num ;  $  TAB1 let sorted = boolean with value false ;  $  TAB1 while (!sorted) is true do the following ;  $  TAB2 set sorted = true ;  $  TAB2 for integer i=1 to num-2 inclusive increment sstep 2 ;  $  TAB3 if arr[i] is greater than arr[i+1] do the following ;  $  TAB4 call swap on arr[i] and arr[i+1] ;  $  TAB4 set sorted = false ;  $  TAB2 for integer i=0 to num-2 inclusive increment step 2 do the following ;  $  TAB3 if arr[i] is greater than arr[i+1] do the following ;  $  TAB4 call swap on arr[i] and arr[i+1] ;  $  TAB4 set sorted = false ;  $  TAB1 return ;  $  TAB1 let secretaries_num = integer ;  $  TAB1 let counter = integer ;  $  TAB1 set flag = integer ;  $  TAB1 read secretaries_num ;  $  TAB1 let spyke_id = array of integers of size secretaries_num ;  $  TAB1 read secretaries_num values into array spyke_id ;  $  TAB1 call brickSort on spyke_id and secretaries_num ;  $  TAB1 for integer i=0 to secretaries_num do the following ;  $  TAB2 set flag = i + 2 ;  $  TAB2 if spyke_id[i] is spyke_id[i + 1] and spyke_id[i] is not equal to 0 increment counter ;  $  TAB2 if spyke_id[i] is spyke_id[flag] and spyke_id[i] is not equal to 0 do the following ;  $  TAB3 set counter = 1 ;  $  TAB3 exit the loop ;  $  TAB1 print counter ;
TAB1 create int X ;  $  TAB1 read X ;  $  TAB1 if X less than or equal to 2 ;  $  TAB2 print X ;  $  TAB1 print 1 ;
TAB1 create float n and m ;  $  TAB1 k=float ;  $  TAB1 read k ;  $  TAB1 read n,m ;  $  TAB1 create double int p ;  $  TAB1 set p= k/(n+m) ;  $  TAB1 create double int answer ;  $  TAB1 set answer=p*(n) ;  $  TAB1 print answer ;
TAB1 a = string ;  $  TAB1 n = integer ;  $  TAB1 read a, n ;  $  TAB1 l is an integer set to length of a ;  $  TAB1 if l modulo n ;  $  TAB2 display NO ;  $  TAB1 assign l / n to n ;  $  TAB1 for i = 0 with condition i is less than l with increment add n to i ;  $  TAB2 end = integer = i + n - 1 ;  $  TAB2 begin = integer = i ;  $  TAB2 while begin is at most end ;  $  TAB3 if a[begin] equals a[end] ;  $  TAB4 increment begin ;  $  TAB4 decrement end ;  $  TAB3 else ;  $  TAB4 display NO ;  $  TAB1 display YES ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create dynamically allocated array A of length n ;  $  TAB1 read to A ;  $  TAB1 create int count1 = 0, count2 = 0, count3 = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if A[i] equals 1 ;  $  TAB3 increment count1 ;  $  TAB2 else if A[i] equals 2 ;  $  TAB3 increment count2 ;  $  TAB2 else if A[i] equals 3 ;  $  TAB3 increment count3 ;  $  TAB1 create int result = -1 ;  $  TAB1 if count1 is greater than or equal to count2 ;  $  TAB2 if count1 is greater than or equal to count3 ;  $  TAB3 set result to count2 + count3 ;  $  TAB2 else ;  $  TAB3 set result to count1 + count2 ;  $  TAB1 else if count2 is greater than or equal to count3 ;  $  TAB2 set result to count1 + count3 ;  $  TAB1 else ;  $  TAB2 set result to count1 + count2 ;  $  TAB1 print result ;
TAB1 n, i, ct are integers with ct = 0 ;  $  TAB1 ch = string ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read ch ;  $  TAB2 if ch is equal to "Tetrahedron" ;  $  TAB3 add 4 to ct ;  $  TAB2 else if ch is equal to "Cube" ;  $  TAB3 add 6 to ct ;  $  TAB2 else if ch is equal to "Icosahedron" ;  $  TAB3 add 20 to ct ;  $  TAB2 else if ch is equal to "Octahedron" ;  $  TAB3 add 8 to ct ;  $  TAB2 else if ch is equal to "Dodecahedron" ;  $  TAB3 add 12 to ct ;  $  TAB2 else ;  $  TAB1 print ct ;
TAB0 x, y, x2, y2, a, b are long longs ;  $  TAB1 read x, y, x2, y2, a, b ;  $  TAB1 if (absolute value of x - x2) mod a doesn't equal 0 or (absolute value of y - y2) mod b doesn't equal 0 ;  $  TAB2 display NO ;  $  TAB1 o1 = long long = (absolute value of x - x2) / a ;  $  TAB1 o2 = long long = (absolute value of y - y2) / b ;  $  TAB1 if o1 mod 2 isn't o2 mod 2 ;  $  TAB2 display NO ;  $  TAB1 display YES ;
TAB0 n and k are integers ;  $  TAB0 s is a string ;  $  TAB0 way is a boolean with way = 0 ;  $  TAB1 read n, k, s ;  $  TAB1 if 2 * k is at most n ;  $  TAB2 set way to 1 ;  $  TAB2 for i = 1 to k exclusive, display LEFT ;  $  TAB2 set k to 0 ;  $  TAB1 else ;  $  TAB2 set way to 0 ;  $  TAB2 for i = 1 to n - k inclusive, display RIGHT ;  $  TAB2 set k to n - 1 ;  $  TAB1 if way equals 1 ;  $  TAB2 display PRINT , s[0] ;  $  TAB2 for i = 1 to n exclusive ;  $  TAB3 display RIGHT ;  $  TAB3 display PRINT , s[i] ;  $  TAB1 else ;  $  TAB2 display PRINT , s[n - 1] ;  $  TAB2 for i = n - 2 to 0 inclusive ;  $  TAB3 display LEFT ;  $  TAB3 display PRINT , s[i] ;
TAB1 let s, v1, v2, t1, t2, a, b, c, d be integers ;  $  TAB1 read s, v1, v2, t1, t2 ;  $  TAB1 assign v1 * s + 2 * t1 to c ;  $  TAB1 assign v2 * s + 2 * t2 to d ;  $  TAB1 if c is less than d ;  $  TAB2 display Friendship ;  $  TAB1 else if c is equal to d ;  $  TAB2 display Friendship ;  $  TAB1 else if c is greater than d ;  $  TAB2 display Second ;
TAB1 n,k= integer ;  $  TAB1 read n,k ;  $  TAB1 let v be an integer vector of size n ;  $  TAB1 for i=1 to n exclusive read v[i] ;  $  TAB1 let ans be an integer with ans=0 ;  $  TAB1 let fi be an integer with fi=n-1 ;  $  TAB1 for i=0 to size of v exclusive ;  $  TAB2 if v[i]<=k ;  $  TAB3 increment ans ;  $  TAB2 else do the following ;  $  TAB3 set fi=i ;  $  TAB3 break ;  $  TAB1 for i=n-1 to fi exlusive ;  $  TAB2 if v[i]<=k ;  $  TAB3 increment ans ;  $  TAB2 else do the following ;  $  TAB3 break ;  $  TAB1 print ans ;
TAB1 input_len, input_op are integers ;  $  TAB1 read input_len, input_op ;  $  TAB1 str = string ;  $  TAB1 read str ;  $  TAB1 start, end are integers ;  $  TAB1 c1, c2 are characters ;  $  TAB1 while read start, end, c1, c2 ;  $  TAB2 for i = start - 1 to end exclusive ;  $  TAB3 if str[i] equals c1, set str[i] to c2 ;  $  TAB1 output str ;
TAB1 w, h, k = long long integers ;  $  TAB1 read w, h, k ;  $  TAB1 print 2 * k * w + h - 2 - 8 * k * k -1 ;
TAB0 create constant long long integer MOD = 1000000007 ;  $  TAB0 create long long integer N,M,K,H,W,L,R ;  $  TAB1 read N ;  $  TAB1 print N mod 2 and a new line ;
TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 create int array a of length n ;  $  TAB1 read n values into a ;  $  TAB1 create int out = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if a[i] is 1 then increment out ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if a[i] is 0 and a[i - 1] is 1 and a[i + 1] is 1 then increment out ;  $  TAB1 print out ;
TAB1 declare long long ints n, k ;  $  TAB1 declare long long int m ;  $  TAB1 read n, k ;  $  TAB1 if k is less than or equal to n ;  $  TAB2 set m to 1 ;  $  TAB1 else if k modulo n is 0 ;  $  TAB2 set m to k / n ;  $  TAB1 else ;  $  TAB2 set m to k / n + 1 ;  $  TAB1 print m ;
TAB1 n, a, and b are long long integers ;  $  TAB1 read n, a, and b ;  $  TAB1 s is a string ;  $  TAB1 read s ;  $  TAB1 if s[a - 1] equals s[b - 1] ;  $  TAB2 display 0 ;  $  TAB1 else ;  $  TAB2 display 1 ;
TAB1 let a, b = arrays of character size 10 ;  $  TAB1 read a, b ;  $  TAB1 let x1, y1, x2, y2 = integer with x1 = a[0]-a+1, y1 = a[1]-0, x2 = b[0]-a+1, y2 = b[1]-0 ;  $  TAB1 let integer ans = max of float absolute of (x1-x2) and float absolute of (y1-y2) ;  $  TAB1 print ans ;  $  TAB1 wile (decrement ans) is true do the following ;  $  TAB2 if x1 is not equal to x2 do the following ;  $  TAB3 if x1 is greater than x2 do the following ;  $  TAB4 if y1 is y2 do the following ;  $  TAB5 decrement x1 ;  $  TAB5 print L ;  $  TAB4 else if y1 is greater than y2 do the following ;  $  TAB5 decrement y1 ;  $  TAB5 decrement x1 ;  $  TAB5 print LD ;  $  TAB4 else do the following ;  $  TAB5 decrement y2 ;  $  TAB5 decrement x1 ;  $  TAB5 print LU ;  $  TAB3 else do the following ;  $  TAB4 if y1 is y2 do the following ;  $  TAB5 decrement x2 ;  $  TAB5 print R ;  $  TAB4 else if y1 is greater than y2 do the following ;  $  TAB5 decrement y1 ;  $  TAB5 decrement x2 ;  $  TAB5 print RD ;  $  TAB4 else do the following ;  $  TAB5 decrement y2 ;  $  TAB5 decrement x2 ;  $  TAB5 print RU ;  $  TAB2 else do the following ;  $  TAB3 if y1 is greater than y2 do the following ;  $  TAB4 decrement y1 ;  $  TAB4 print D ;  $  TAB3 else do the following ;  $  TAB4 decrement y2 ;  $  TAB4 print U ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let arr = array of integers of size n ;  $  TAB1 read n values into arr ;  $  TAB1 i, j = integers where j = n-2 and i = n-1 ;  $  TAB1 while i is greater than 0 do the following ;  $  TAB2 call sort on arr and arr + n ;  $  TAB2 if j is greater than 0 do the following ;  $  TAB3 decrement i ;  $  TAB3 set j = i - 1 ;  $  TAB2 else if arr[i] is greater than arr[j] ;  $  TAB3 set arr[i] = arr[i] - arr[j] ;  $  TAB2 else ;  $  TAB3 decrement j ;  $  TAB1 let sum = integer value = 0 ;  $  TAB1 for i=0 to n set sum = sum = arr[i] ;  $  TAB1 print sum ;
TAB1 s1, s2 are strings ;  $  TAB1 read s1, s2 ;  $  TAB1 for i = 0 to length of s1 exclusive ;  $  TAB2 n = integer = s1[i] ;  $  TAB2 if n is at least 65 and n is at most 90 ;  $  TAB3 add 32 to n ;  $  TAB3 set s1[i] to n ;  $  TAB1 for i = 0 to length of s2 exclusive ;  $  TAB2 n = integer = s2[i] ;  $  TAB2 if n is at least 65 and n is at most 90 ;  $  TAB3 add 32 to n ;  $  TAB3 set s2[i] to n ;  $  TAB1 x = integer = 0 ;  $  TAB1 for i = 0 to length of s1 exclusive ;  $  TAB2 if s1[i] is greater than s2[i] ;  $  TAB3 set x to 1 ;  $  TAB3 break ;  $  TAB2 if s1[i] is less than s2[i] ;  $  TAB3 set x to -1 ;  $  TAB3 break ;  $  TAB1 display x ;
TAB1 t = integer ;  $  TAB1 read t ;  $  TAB1 for t to 0, while decrementing t by 1 ;  $  TAB2 a, b = integers ;  $  TAB2 res = long long integer set to 0 ;  $  TAB2 read a, b ;  $  TAB2 while a and b are truthy ;  $  TAB3 if a < b ;  $  TAB4 add b / a to res ;  $  TAB4 modulo b by a ;  $  TAB3 else ;  $  TAB4 add a / b to res ;  $  TAB4 modulo a by b ;  $  TAB2 print res ;
TAB1 let i, j, k, l, p, q, r, t, u, v, w, x, y, z, n = long long integers ;  $  TAB1 let s = string ;  $  TAB1 read t ;  $  TAB1 for i=0 to t inclusive do the following ;  $  TAB2 read n, s ;  $  TAB2 set l = size of s ;  $  TAB2 let temp = long long integers with value = 0 ;  $  TAB2 let first = long long integer ;  $  TAB2 let second = long long integer ;  $  TAB2 for j=0 to l / 2 exclusive do the following ;  $  TAB3 set first = integer cast of s[j] ;  $  TAB3 set second = integer cast of s[l - j - 1] ;  $  TAB3 if abs(first - second) is 2 or abs(first - second) is 0 do the following ;  $  TAB4 set temp = 0 ;  $  TAB3 else do the following ;  $  TAB4 set temp = 1exit the loop ;  $  TAB4 exit the loop ;  $  TAB2 if temp is 1 ;  $  TAB3 write NO to stdout ;  $  TAB2 else do the following ;  $  TAB3 write YES to stdout ;
TAB0 create const int maxn = 110 ;  $  TAB0 create int arrays a and b with size maxn ;  $  TAB0 in function mex with return type of int and parameters int A and int B ;  $  TAB1 if A is not equal to 0 AND B is not equal to 0 then return 0 ;  $  TAB1 if A is not equal to 1 AND B is not equal to 1 then return 1 ;  $  TAB1 if A is not equal to 2 AND B is not equal to 2 then return 2 ;  $  TAB0 in function end ;  $  TAB1 print "NO\n" ;  $  TAB1 exit with status 0 ;  $  TAB1 create int n ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive do read a[i], decrement a[i] ;  $  TAB1 if a[0] is equal to 2 then call end ;  $  TAB1 if a[0] is equal to 0 then set b[0] to 1 ;  $  TAB1 create bool okay = true ;  $  TAB1 for i = 1 to n exclusive ;  $  TAB2 if a[i] is equal to b[i - 1] then call end ;  $  TAB2 set b[i] to mex of a[i] and b[i - 1] ;  $  TAB1 if okay ;  $  TAB2 print "YES\n" ;  $  TAB1 else ;  $  TAB2 print "NO\n" ;
TAB0 go is a boolean array of length 200005 ;  $  TAB0 nex is an integer array of length 200005 ;  $  TAB0 declare an integer n ;  $  TAB0 in function dfs with parameter integer x ;  $  TAB1 if go[x] is true, return ;  $  TAB1 assign 1 to go[x] ;  $  TAB1 call dfs with argument nex[x] ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive, read nex[i] ;  $  TAB1 let cnt be an integer with a value of 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 declare an integer x ;  $  TAB2 read x ;  $  TAB2 add x to cnt ;  $  TAB1 let ans be an integer with a value of 0 ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 if not go[i] ;  $  TAB3 increment ans ;  $  TAB3 call dfs with argument i ;  $  TAB1 if ans is equal to 1, assign 0 to ans ;  $  TAB1 display ans + 1 - (cnt bitwise and 1) ;
TAB1 let n,m be integers with m = 1 ;  $  TAB1 read n ;  $  TAB1 for a = 1 to n/2 inclusive ;  $  TAB2 for i = 0 to (n-m)/2 inclusive, print out * ;  $  TAB2 for i = 1 to m inclusive, print out D ;  $  TAB2 for i = 1 to (n-m)/2, print * ;  $  TAB2 print newline ;  $  TAB2 increment m by 2 ;  $  TAB1 for i = 1 to n inclusive print D ;  $  TAB1 print newline ;  $  TAB1 set m to n - 2 ;  $  TAB1 for a = 1 to n/2 inclusive ;  $  TAB2 for i = 0 to (n-m)/2 inclusive, print out * ;  $  TAB2 for i = 1 to m inclusive, print out D ;  $  TAB2 for i = 1 to (n-m)/2, print * ;  $  TAB2 print newline ;  $  TAB2 decrement m by 2 ;
TAB0 let k, r, res be integers ;  $  TAB1 read k, r ;  $  TAB1 for i = 1 t infinity ;  $  TAB2 let x be integer with x = k*i ;  $  TAB2 if x mod 10 == 0 ;  $  TAB3 print i ;  $  TAB3 break ;  $  TAB2 else if (x-r) mod 10 == 10 ;  $  TAB3 print i ;  $  TAB3 break ;
TAB1 n = integer, a, b, c are integer arrays of size 10 each and set to {0} each ;  $  TAB1 while input n ;  $  TAB2 call memset with a, 0, call sizeof with a ;  $  TAB2 call memset with b, 0, call sizeof with b ;  $  TAB2 call memset with c, 0, call sizeof with c ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 declare an integer temp ;  $  TAB3 input temp ;  $  TAB3 increment a[temp] ;  $  TAB3 increment c[temp] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 declare an integer temp ;  $  TAB3 input temp ;  $  TAB3 increment b[temp] ;  $  TAB3 increment c[temp] ;  $  TAB2 flag, sum are integers both set to 0 ;  $  TAB2 for i = 1 to 5 inclusive ;  $  TAB3 if c[i] mod 2 equals 1 ;  $  TAB4 set flag to 1 ;  $  TAB4 break ;  $  TAB3 add absolute value (a[i] - c[i] / 2) to sum ;  $  TAB2 if flag ;  $  TAB3 print -1 ;  $  TAB2 else ;  $  TAB3 print sum / 2 ;
TAB0 create const long long N = 1e5 + 5, mod = 1e9 + 7, inf = 1e18 + 7 ;  $  TAB1 create long long n ;  $  TAB1 read n ;  $  TAB1 create string array a with a size of n, t ;  $  TAB1 create set of strings b ;  $  TAB1 for long long i = 0 to n exclusive ;  $  TAB2 read a[i] ;  $  TAB2 sort a[i] ;  $  TAB2 null statement ;  $  TAB2 assign "" to t ;  $  TAB2 push a[i][0] onto t ;  $  TAB2 for long long j = 1 to a[i] length exclusive ;  $  TAB3 if a[i][j] is not equal to a[i][j - 1] then push a[i][j] onto t ;  $  TAB2 insert t into b ;  $  TAB1 print b size ;
TAB1 a, b, c, d are strings ;  $  TAB1 read a, b ;  $  TAB1 display a, ' ', b ;  $  TAB1 n is an integer ;  $  TAB1 read n ;  $  TAB1 iterate n times ;  $  TAB2 read c, d ;  $  TAB2 if c equals a ;  $  TAB3 assign d to a ;  $  TAB2 else ;  $  TAB3 assign d to b ;  $  TAB2 display a, ' ', b ;
TAB1 let t be integer ;  $  TAB1 a = b = integer array of size 101, a1, b1 = integer array of size 6 = {0} ;  $  TAB1 read t ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 read a[i] ;  $  TAB2 increment a1[a[i]]++ ;  $  TAB1 for i = 0 to t exclusive ;  $  TAB2 read b[i] ;  $  TAB2 read b1[b[i]]++ ;  $  TAB1 sum = integer = 0 ;  $  TAB1 for i = 1 to 6 exclusive ;  $  TAB2 if (a1[i] + b1[i]) mod 2 != 0 ;  $  TAB3 print -1 ;  $  TAB2 update sum to sum + abs of (b1[i] - a1[i])/2 ;  $  TAB1 print sum/2 ;
TAB0 declare int n, k, array num of length 1000 ;  $  TAB1 declare string a ;  $  TAB1 read n and k ;  $  TAB1 read a ;  $  TAB1 for i = 0 to n exclusive: increment num[a[i]] ;  $  TAB1 for i = 0 to 1000 exclusive ;  $  TAB2 if num[i] > k ;  $  TAB3 print "NO" with newline ;  $  TAB1 print "YES" with newline ;
TAB0 declare string s ;  $  TAB0 declare int array a of length 27 ;  $  TAB1 declare int n, k and define int f = 0 ;  $  TAB1 read n, k ;  $  TAB1 read s ;  $  TAB1 for i = 0 to n exclusive: increment a[s[i] - 'a'] ;  $  TAB1 for i = 0 to 26 exclusive ;  $  TAB2 if a[i] is not equal to 0 and a[i] is greater than k ;  $  TAB3 print "NO" ;  $  TAB3 set f = 1 ;  $  TAB3 break ;  $  TAB1 if not f: print "YES" ;
TAB1 n, l, r, ql, qr, sum are integers with sum = 0, Ar is an integer array of size 100000 ;  $  TAB1 read n, l, r, ql, qr ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 input Ar[i] ;  $  TAB2 add Ar[i - 1] to Ar[i] ;  $  TAB1 answer is an integer with answer = 1e9 ;  $  TAB1 for i = 0 to n inclusive ;  $  TAB2 result is an integer with result = Ar[i] * l + (Ar[n] - Ar[i]) * r ;  $  TAB2 if i is less than n - i, add (n - i - i - 1) * qr to result ;  $  TAB2 if i is greater than n - i, add (i - n + i - 1) * ql to result ;  $  TAB2 set answer to call min with arguments answer, result ;  $  TAB1 display answer ;
TAB1 let a, b = strings ;  $  TAB1 let c, d, cnt = integers ;  $  TAB1 let flag = integer ;  $  TAB1 while ( read a, b) is true do the following ;  $  TAB2 if the size of a is less than the size of b do the following ;  $  TAB3 print NO ;  $  TAB3 continue at the beginning of the loop ;  $  TAB2 else do the following ;  $  TAB3 set flag to 1 ;  $  TAB3 sent cnt to 0 ;  $  TAB3 for i=0 to the size of a exclusive, do the following ;  $  TAB4 if a[i] is not equal to b[i] and cnt is 0 do the following ;  $  TAB5 increment cnt ;  $  TAB5 set c to i ;  $  TAB4 else if a[i] is not equal to b[i] and cnt is 1 do the following ;  $  TAB5 increment cnt ;  $  TAB5 set d to i ;  $  TAB4 else if a[i] is not equal to b[i] and cnt is 2 do the following ;  $  TAB5 print NO ;  $  TAB5 set flag to 0 ;  $  TAB5 exit the loop ;  $  TAB3 if flag is 0 ;  $  TAB4 continue at the beginning of the loop ;  $  TAB3 else do the following ;  $  TAB4 if cnt is 1 do the following ;  $  TAB5 print NO ;  $  TAB5 continue at the beginning of the loop ;  $  TAB4 if a[c] is b[d] and a[d] is b[c] ;  $  TAB5 print YES ;  $  TAB4 else ;  $  TAB5 print NO ;
TAB0 let n, m, a, b, res be long longs ;  $  TAB1 read n, m, a, b ;  $  TAB1 set res to n * b ;  $  TAB1 set res to call function min with arguments res, (n - (n / m) * m) * b ;  $  TAB1 set res to call function min with arguments res, ((n / m + 1) * m - n) * a ;  $  TAB1 output res ;
TAB1 declare int n, k ;  $  TAB1 read n, k ;  $  TAB1 declare vector<int> vec of size n ;  $  TAB1 define int result = 0 ;  $  TAB1 read n values into vec ;  $  TAB1 define int score = vec[k - 1] ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if vec[i] >= score and vec[i] > 0, increment result ;  $  TAB1 print result ;
TAB0 let tu be an aarray of vectors of integers size 1005 ;  $  TAB0 let n = integer and a, cnt, checks = arrays of integers, size 1005 ;  $  TAB0 define integer function check which takes in integer x ;  $  TAB1 let i, k = integers ;  $  TAB1 let sum = integer value -1 ;  $  TAB1 let qua be an array of queues of integers size 5 ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 if cnt[i] is 0 add an element to qua[a[i]] and initialize to 1 ;  $  TAB1 for null = 0 to infinity do the following ;  $  TAB2 if the size of qua[1] is 0 and the size of qua[2] is 0 and the size of qua[3] is 0 ,exit the loop ;  $  TAB2 while qua[x] is not empty do the following ;  $  TAB3 increment sum ;  $  TAB3 set k = oldest element of qua[x] ;  $  TAB3 remove he oldest element of qua[x] ;  $  TAB3 for i=0 to size of tu[k] do the following ;  $  TAB4 let xx = integer value tu[k][i] ;  $  TAB4 decrement cnt[xx] ;  $  TAB4 if cnt[xx] is 0 add an element to qua[a[xx]] and initialize to xx ;  $  TAB2 if x is 1 ;  $  TAB3 set x = 2 ;  $  TAB2 else if x is 2 ;  $  TAB3 set x = 3 ;  $  TAB2 else if x is 3 ;  $  TAB3 set x = 1 ;  $  TAB2 increment sum ;  $  TAB1 if sum is -1 ;  $  TAB1 else ;  $  TAB2 return sum ;  $  TAB1 let i = integer ;  $  TAB1 let ans, T, x = integers ;  $  TAB1 read n ;  $  TAB1 set sizeof(a) bytes starting at a to 0 ;  $  TAB1 set sizeof(tu) bytes starting at tu to 0 ;  $  TAB1 set sizeof(cnt) bytes starting at cnt to 0 ;  $  TAB1 read n values into array a ;  $  TAB1 for i=1 to n inclusive ;  $  TAB2 read T ;  $  TAB2 while (decrement T) is true do the following ;  $  TAB3 read x ;  $  TAB3 add an element, value i to the end of tu[x] ;  $  TAB3 increment checks[i] ;  $  TAB1 set ans = 1 left shifted 30 ;  $  TAB1 let j = integer ;  $  TAB1 for i=1 to 3 inclusive do the following ;  $  TAB2 for j=1 to n inclusive set cnt[j] = checks[j] ;  $  TAB2 set ans = min of ans and checks[i] ;  $  TAB1 print ans ;
TAB1 let a and b be long long integers ;  $  TAB1 input a ;  $  TAB1 assign a / 5 to b ;  $  TAB1 if a is equal to b * 5 ;  $  TAB2 display b ;  $  TAB1 else ;  $  TAB2 display b + 1 ;
TAB0 n, k, and x are long longs ;  $  TAB1 input n and k ;  $  TAB1 assign n / k to x ;  $  TAB1 if x is even ;  $  TAB2 display NO ;  $  TAB1 else ;  $  TAB2 display YES ;
TAB0 let Names be char array of size 6 by 15 with values Power, Time, Space, Soul, Reality, Mind ;  $  TAB0 define DeleteIt which takes integer x as argument ;  $  TAB1 call strcpy with Names[x] and " " ;  $  TAB1 return ;  $  TAB1 let n, i be integers ;  $  TAB1 read n ;  $  TAB1 if n is not equal to 0 ;  $  TAB2 Colours = array of char with size n by 10 ;  $  TAB2 for i = 0 to n exclusive, read Colours[i] ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if Colours[i] is equal to purple ;  $  TAB4 call DeleteIt with 0 ;  $  TAB4 continue ;  $  TAB3 if Colours[i] is equal to green ;  $  TAB4 call DeleteIt with 1 ;  $  TAB4 continue ;  $  TAB3 if Colours[i] is equal to blue ;  $  TAB4 call DeleteIt with 2 ;  $  TAB4 continue ;  $  TAB3 if Colours[i] is equal to orange ;  $  TAB4 call DeleteIt with 3 ;  $  TAB4 continue ;  $  TAB3 if Colours[i] is equal to red ;  $  TAB4 call DeleteIt with 4 ;  $  TAB4 continue ;  $  TAB3 if Colours[i] is equal to yellow ;  $  TAB4 call DeleteIt with 5 ;  $  TAB4 continue ;  $  TAB1 print out 6 - n ;  $  TAB1 for i = 0 to 6 ;  $  TAB2 if Names[i] is equal to " ", continue ;  $  TAB2 print out Names[i] with newline ;
TAB1 n, m, g = integers ;  $  TAB1 read n and m ;  $  TAB1 arr = array of integers with length 105 ;  $  TAB1 for i = 0 to n exclusive, print arr[i] ;  $  TAB1 for i = n ;  $  TAB2 for j = 0 to n exclusive ;  $  TAB3 if arr[j] > 0 ;  $  TAB4 decrement arr[j] by m ;  $  TAB4 if arr[j] <= 0 ;  $  TAB5 set g to j ;  $  TAB5 decrement i by 1 ;  $  TAB1 print g + 1 ;
TAB1 make integers m and n ;  $  TAB1 read m and n ;  $  TAB1 print (m * n) / 2 ;
TAB0 create a long long integer mod=1e9+9 ;  $  TAB0 into the function qm which takes two long long integers a and b and returns a long long int ;  $  TAB1 let ans be long long int with ans=1 ;  $  TAB1 while b>0 do the following ;  $  TAB2 if b&1 then set ans= ans * a % mod ;  $  TAB2 set b= b >> 1 ;  $  TAB2 set a= a*a%mod ;  $  TAB1 return (ans % mod + mod) % mod ;  $  TAB0 c= character array of size 1000005 ;  $  TAB1 n,a,b,k= long long ints ;  $  TAB1 read n,a,b,k ;  $  TAB1 read c ;  $  TAB1 create long long int ans=0 ;  $  TAB1 if n+1 <= k ;  $  TAB2 for i=0 to n inclusive ;  $  TAB3 if c[i] = - ;  $  TAB4 then set ans = ans - qm(a, n - i) * qm(b, i) ;  $  TAB4 set ans = (ans % mod + mod) % mod ;  $  TAB3 else do the following ;  $  TAB4 set ans = ans + qm(a, n - i) * qm(b, i) ;  $  TAB4 set ans = (ans % mod + mod) % mod ;  $  TAB2 set ans = (ans % mod + mod) % mod ;  $  TAB2 print ans ;  $  TAB1 else do the following ;  $  TAB2 create long long t= (n+1) / k ;  $  TAB2 creaye long long integer g = (n+1) %k ;  $  TAB2 let x=0 be a long long integer ;  $  TAB2 if g is equal to 0 ;  $  TAB3 for i=0 to k exclusive ;  $  TAB4 if c[i] is equal to - ;  $  TAB5 then set x = x - qm(a, n - i) * qm(b, i) ;  $  TAB5 set x = (x % mod + mod) % mod ;  $  TAB4 else do the following ;  $  TAB5 set x = x + qm(a, n - i) * qm(b, i) ;  $  TAB5 assign (x % mod + mod) % mod to x ;  $  TAB3 if qm(a, k) = qm(b, k) ;  $  TAB4 then set ans = t*t ;  $  TAB4 assign (ans % mod + mod) % mod to ans ;  $  TAB4 print ans ;  $  TAB3 create long long integer jj = qm(a, t * k) - qm(b, t * k) ;  $  TAB3 set jj = x*jj%mod ;  $  TAB3 set jj= jj* qm(a,k) % mod ;  $  TAB3 do nothing ;  $  TAB3 set jj = jj % mod ;  $  TAB3 create long long integer nn = qm(a, k) - qm(b, k) ;  $  TAB3 set nn = nn % mod ;  $  TAB3 assign nn * qm(a, t * k) to nn ;  $  TAB3 set nn = nn % mod ;  $  TAB3 set nn = qm(nn, mod - 2) ;  $  TAB3 assign jj * nn to ans ;  $  TAB3 set ans to (ans % mod + mod) % mod ;  $  TAB3 print ans ;  $  TAB2 else do the following ;  $  TAB3 for i=0 to k exclusive ;  $  TAB4 if c[i] is equal to - ;  $  TAB5 set x = x - qm(a, n - i) * qm(b, i) ;  $  TAB5 set x = (x % mod + mod) % mod ;  $  TAB4 else do the following ;  $  TAB5 set x to x + qm(a, n - i) * qm(b, i) ;  $  TAB5 assign (x % mod + mod) % mod to x ;  $  TAB3 if qm(a, k) == qm(b, k) ;  $  TAB4 then set ans= t*x ;  $  TAB4 set ans = (ans % mod + mod) % mod ;  $  TAB4 for hh=0 to g exclusive ;  $  TAB5 if c[hh] is equal to - ;  $  TAB6 set ans = ans - qm(a, n - (t * k + hh)) * qm(b, (t * k + hh)) ;  $  TAB6 set ans = (ans % mod + mod) % mod ;  $  TAB5 else do the following ;  $  TAB6 set ans = ans + qm(a, n - (t * k + hh)) * qm(b, (t * k + hh)) ;  $  TAB6 set ans = (ans % mod + mod) % mod ;  $  TAB4 set ans = (ans % mod + mod) % mod ;  $  TAB4 print ans ;  $  TAB3 create long long integer jj = qm(a, t * k) - qm(b, t * k) ;  $  TAB3 set jj to x * jj % mod ;  $  TAB3 set jj = jj * qm(a, k) % mod ;  $  TAB3 do nothing ;  $  TAB3 assign jj % mod to jj ;  $  TAB3 create long long integer nn = (qm(a, k) - qm(b, k)) ;  $  TAB3 set nn = nn % mod ;  $  TAB3 assign nn * qm(a, t * k) to nn ;  $  TAB3 set nn = nn % mod ;  $  TAB3 set nn = qm(nn, mod - 2) ;  $  TAB3 set ans = jj * nn ;  $  TAB3 set ans = (ans % mod + mod) % mod ;  $  TAB3 for hh=0 to g exclusive ;  $  TAB4 if c[hh] is - ;  $  TAB5 set ans = ans - qm(a, n - (t * k + hh)) * qm(b, (t * k + hh)) ;  $  TAB5 set ans = (ans % mod + mod) % mod ;  $  TAB4 else do the following ;  $  TAB5 set ans = ans + qm(a, n - (t * k + hh)) * qm(b, (t * k + hh)) ;  $  TAB5 set ans = (ans % mod + mod) % mod ;  $  TAB3 set ans = (ans % mod + mod) % mod ;  $  TAB3 print ans ;
TAB0 in function gcd, returning int and accepting ints x and y ;  $  TAB1 if y equals 0, return x ;  $  TAB1 return gcd(y, x mod y) ;  $  TAB1 create int n, i, a, g, mv = 0 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 read a ;  $  TAB2 mv = max of mv and a ;  $  TAB2 if i equals 1 ;  $  TAB3 g = a ;  $  TAB2 else ;  $  TAB3 g = gcd of g and a ;  $  TAB1 create int turns = mv / g - n ;  $  TAB1 if turns is even ;  $  TAB2 print "Bob" ;  $  TAB1 else ;  $  TAB2 Alice ;
TAB1 let p = boolean with value = 0 ;  $  TAB1 let n, x = integers ;  $  TAB1 read n, x ;  $  TAB1 let cur = integer with value = 1 ;  $  TAB1 if x is 1 set p = 1 ;  $  TAB1 for integer i=1 to n exclusive do the following ;  $  TAB2 let a = integer ;  $  TAB2 read a ;  $  TAB2 if cur is i set cur = cur + a ;  $  TAB2 if cur is x set p = 1 ;  $  TAB1 if p is true ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB1 create string str ;  $  TAB1 create ints i, j, len, ans = 0, k1, k2, t ;  $  TAB1 read str ;  $  TAB1 assign str length to len ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 for j = i + 1 to len exclusive ;  $  TAB3 assign i to k1 ;  $  TAB3 assign j to k2 ;  $  TAB3 assign 0 to t ;  $  TAB3 while str[k1++] equals str[k2++], increment t ;  $  TAB3 assign max of ans and t to ans ;  $  TAB1 print ans ;
TAB1 N and K are integers ;  $  TAB1 read N and K ;  $  TAB1 set K to 240 - K ;  $  TAB1 ans is an integer with ans = 0 ;  $  TAB1 while K is positive ;  $  TAB2 subtract (ans + 1) * 5 from K ;  $  TAB2 increment ans ;  $  TAB2 if ans is greater than N ;  $  TAB3 display ans - 1 ;  $  TAB1 if K is 0, display ans ;  $  TAB1 if K is negative, display ans - 1 ;
TAB1 let n,k,x = long longs ;  $  TAB1 read n,k,x ;  $  TAB1 let a = array of long longs, size n ;  $  TAB1 read n values into array a ;  $  TAB1 for i=0 to k exclusive a[n-1-i] = x ;  $  TAB1 let time = long long value 0 ;  $  TAB1 for i=0 to n exclusive set time = time + a[i] ;  $  TAB1 print time ;
TAB1 let n = integer ;  $  TAB1 read n ;  $  TAB1 let x = integer with value = 0 ;  $  TAB1 let gcd = integer with value = 0 ;  $  TAB1 for integer i=0 to n exclusive do the following ;  $  TAB2 let w = integer ;  $  TAB2 read w ;  $  TAB2 set x = max of x and w ;  $  TAB2 set gcd = call __gcd on gcd and w ;  $  TAB1 if x / (gcd -n) and 1 is true ;  $  TAB2 print Alice ;  $  TAB1 else ;  $  TAB2 print Bob ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 subtract 10 from n ;  $  TAB1 if n is greater than 11 or n is less than 1 ;  $  TAB2 print 0 ;  $  TAB1 else if n equals 10 ;  $  TAB2 print 15 ;  $  TAB1 else ;  $  TAB2 print 4 ;
TAB0 define INF as an integer constant = hexadecimal 3f3f3f ;  $  TAB0 define maxn as an integer constant = 120 ;  $  TAB0 arr = array of integers size maxn ;  $  TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 set integer mx to 0 ;  $  TAB1 set integer sum to 0 ;  $  TAB1 for i=1 to n inclusive do the following ;  $  TAB2 read arr[i] ;  $  TAB2 sum = sum + arr[i] ;  $  TAB2 set mx to max of mx and arr[i] ;  $  TAB1 for i=mx to infinity do the following ;  $  TAB2 if i * n - sum is greater than sum ;  $  TAB3 print i ;
TAB1 n = integer ;  $  TAB1 read n ;  $  TAB1 C = boolean array of sizes 5, 5 with C = {} ;  $  TAB1 color = string = "RGBYW" ;  $  TAB1 value = string = "12345" ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 declare a string c ;  $  TAB2 read c ;  $  TAB2 for i = 0 to 5 exclusive ;  $  TAB3 for j = 0 to 5 exclusive ;  $  TAB4 if c[0] equals color[i] and c[1] equals value[j], set C[i][j] to true ;  $  TAB1 ans = integer set to 25 ;  $  TAB1 for bc = 0 as long as bc is less than 1 shifted left 5 bits with increment bc + 1 ;  $  TAB2 for bv = 0 as long as bv is less than 1 shifted left 5 bits with increment bv + 1 ;  $  TAB3 ok = boolean = true ;  $  TAB3 for c = 0 to 5 exclusive ;  $  TAB4 if bc shifted left c bitwise and 1 bits ;  $  TAB5 t = integer = 0 ;  $  TAB5 for v = 0 to 5 exclusive ;  $  TAB6 if bv shifted right v bitwise and 1 bits is false, add integer value of C[c][v] to t ;  $  TAB5 if t is greater than 1, set ok to false ;  $  TAB3 for v = 0 to 5 exclusive ;  $  TAB4 if bv shifted right v bitwise and 1 bits ;  $  TAB5 t = integer = 0 ;  $  TAB5 for c = 0 to 5 exclusive ;  $  TAB6 if bc shifted right c bitwise and 1 bits is false, add integer value of C[c][v] to t ;  $  TAB5 if t is greater than 1, set ok to false ;  $  TAB3 t = integer = 0 ;  $  TAB3 for c = 0 to 5 exclusive ;  $  TAB4 for v = 0 to 5 exclusive ;  $  TAB5 if not (bc shifted right c bitwise and 1 bits) and not (bv shifted right v bitwise and 1 bits), add integer value of C[c][v] to t ;  $  TAB3 if t is greater than 1, set ok to false ;  $  TAB3 if ok ;  $  TAB4 a = integer set to 0 ;  $  TAB4 for i = 0 to 5 exclusive, add (bc shifted right i bitwise and 1 bits) + (bv shifted right i bitwise and 1 bits) to a ;  $  TAB4 set ans to call min with ans, a ;  $  TAB1 display ans ;
TAB1 n = integer = 0 ;  $  TAB1 dict = string array of size 5 with dict = "rat", "child", "woman", "man", "captain" ;  $  TAB1 input n ;  $  TAB1 name is a string reference with name = new string[n] ;  $  TAB1 pos is a string reference with pos = new string[n] ;  $  TAB1 for i = 0 to n exclusive, input name[i] and pos[i] ;  $  TAB1 for i = 0 to 5 exclusive ;  $  TAB2 if i is equal to 0 or i is greater than 2 ;  $  TAB3 for j = 0 to n exclusive ;  $  TAB4 if dict[i] is equal to pos[j], display name[j] ;  $  TAB2 else ;  $  TAB3 for j = 0 to n exclusive ;  $  TAB4 if dict[i] is equal to pos[j], display name[j] ;  $  TAB4 if dict[i + 1] is equal to pos[j], display name[j] ;  $  TAB3 increment i ;
TAB1 w,h,w1,h1,w2,h2=integers ;  $  TAB1 read w,h,w1,h1,w2,h2 ;  $  TAB1 for i=h to 0 inclusive ;  $  TAB2 set w = w+i ;  $  TAB2 if i=h1 then set w=w-w1 ;  $  TAB2 if i=h2 then set w=w-w2 ;  $  TAB2 if w<0 then set w=0 ;  $  TAB1 print w ;
TAB1 n and s are integers ;  $  TAB1 read n and s ;  $  TAB1 let a be an integer array of size n ;  $  TAB1 let b be an integer array of size n ;  $  TAB1 read n values into array a ;  $  TAB1 read n values into array b ;  $  TAB1 if a[0] equals 0 ;  $  TAB2 output NO ;  $  TAB1 else ;  $  TAB2 if b[s - 1] equals 0 and a[s - 1] equals 0 ;  $  TAB3 output NO ;  $  TAB2 else if a[s - 1] equals 1 ;  $  TAB3 output YES ;  $  TAB2 else ;  $  TAB3 let flag be an integer set to 0 ;  $  TAB3 for i = s to n exclusive ;  $  TAB4 if a[i] equals 1 and b[i] equals 1 ;  $  TAB5 set flag to 1 ;  $  TAB5 break ;  $  TAB3 if flag equals 1 ;  $  TAB4 output YES ;  $  TAB3 else ;  $  TAB4 output NO ;
TAB1 t = integer ;  $  TAB1 input t ;  $  TAB1 while decrement t ;  $  TAB2 n, x, y, d are inetgers ;  $  TAB2 read n, x, y, d ;  $  TAB2 ans is an integer set to 1e9 ;  $  TAB2 delta is an integer set to absolute value (x - y) ;  $  TAB2 if delta is divisible by d, set ans to delta / d ;  $  TAB2 set delta to y - 1 ;  $  TAB2 if delta is divisible by d, set ans to call min with ans, delta / d + (x - 1 + d - 1) / d ;  $  TAB2 set delta to n - y ;  $  TAB2 if delta is divisible by d, set ans to call min with ans, delta / d + (n - x + d - 1) / d ;  $  TAB2 if ans equals 1e9, set ans to -1 ;  $  TAB2 display ans ;
TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 ans is an integer set to 2 * n - (n / 2) ;  $  TAB1 display ans ;
TAB1 n = integer ;  $  TAB1 input n ;  $  TAB1 a, ok are integer arrays both of size 1005 and both set to 0 ;  $  TAB1 j = integer = 0 ;  $  TAB1 read n values into array a ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if a[i] is less than a[i - 1] and a[i] is less than a[i + 1] ;  $  TAB3 set ok[j] to a[i] ;  $  TAB3 increment j ;  $  TAB2 else if a[i] is greater than a[i - 1] and a[i] is greater than a[i + 1] ;  $  TAB3 set ok[j] to a[i] ;  $  TAB3 increment j ;  $  TAB1 output j ;
TAB1 make integers k, num, and i ;  $  TAB1 read num and k ;  $  TAB1 i = 0 ;  $  TAB1 while i is less than k ;  $  TAB2 if num modulo 10 is equal to 0 ;  $  TAB3 set num to num / 10 ;  $  TAB2 else ;  $  TAB3 subtract 1 from num ;  $  TAB2 add 1 to i ;  $  TAB1 print num ;
TAB1 declare int n, i, pposi, nposi ;  $  TAB1 declare char now, prev ;  $  TAB1 declare string str ;  $  TAB1 read n ;  $  TAB1 read str ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i == 0 ;  $  TAB3 set prev to str[i] ;  $  TAB3 set pposi to 0 ;  $  TAB2 else ;  $  TAB3 set now to str[i] ;  $  TAB3 if now is not equal to prev ;  $  TAB4 set nposi to i ;  $  TAB4 break ;  $  TAB3 else ;  $  TAB4 set prev to str[i] ;  $  TAB4 set pposi to i ;  $  TAB1 if i is not equal to n ;  $  TAB2 print "YES" ;  $  TAB2 print str[pposi] and str[nposi] ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB0 let p be an integer array of size 2000 ;  $  TAB0 in function next that takes integers n, k and return integer ;  $  TAB1 if n equals 0, return 0 ;  $  TAB1 let x be an integer with x = p[n - 1] ;  $  TAB1 for d = 0 to the integer 4 exclusive ;  $  TAB2 if d ;  $  TAB3 if x + d is less than k ;  $  TAB4 if (n is less than 2 or p[n - 2] isn't equal to x + d) and (n is less than 3 or p[n - 3] isn't equal to x + d) ;  $  TAB5 assign x + d to p[n - 1] ;  $  TAB5 return 1 ;  $  TAB1 if call function next with arguments n - 1, k ;  $  TAB2 for d = 0 to the integer 3 exclusive ;  $  TAB3 if (n is less than 2 or p[n - 2] doesn't equal d) and (n is less than 3 or p[n - 3] is unequal to d) ;  $  TAB4 assign d to p[n - 1] ;  $  TAB4 return 1 ;  $  TAB1 let n, k be integers ;  $  TAB1 input n, k ;  $  TAB1 s = string ;  $  TAB1 input s ;  $  TAB1 if k equals 1 ;  $  TAB2 print NO ;  $  TAB1 if k equals 2 ;  $  TAB2 if s equals the string ab ;  $  TAB3 print ba ;  $  TAB2 else if s equals the string a ;  $  TAB3 print b ;  $  TAB2 else ;  $  TAB3 print NO ;  $  TAB1 for i = 0 to the integer n exclusive, set p[i] to s[i] - the character a ;  $  TAB1 if call function next with arguments n, k ;  $  TAB2 for i = 0 to the integer n exclusive, set s[i] to p[i] + the character a ;  $  TAB1 else ;  $  TAB2 assign NO to s ;  $  TAB1 output s ;
TAB1 n is a long long ;  $  TAB1 input n ;  $  TAB1 x is a long long initialized to 3 ;  $  TAB1 res is a long long initialized to 1 ;  $  TAB1 while 1 ;  $  TAB2 if n modulo x doesn't equal 0 ;  $  TAB3 assign n / x + 1 to res ;  $  TAB3 break ;  $  TAB2 else ;  $  TAB3 assign x * 3 to x ;  $  TAB1 display res ;
TAB1 n = long long ;  $  TAB1 read n ;  $  TAB1 r is a long long set to 1 ;  $  TAB1 while n is greater than r * 5 ;  $  TAB2 subtract (r * 5) from n ;  $  TAB2 multiply r by 2 ;  $  TAB1 a is a long long set to (n - 1) / r ;  $  TAB1 if a is 0 ;  $  TAB2 display Sheldon ;  $  TAB1 else if a is 1 ;  $  TAB2 display Leonard ;  $  TAB1 else if a is 2 ;  $  TAB2 display Penny ;  $  TAB1 else if a is 3 ;  $  TAB2 display Rajesh ;  $  TAB1 else ;  $  TAB2 display Howard ;
TAB1 let n, m, mn, mx be integers ;  $  TAB1 read n, m, mn, mx ;  $  TAB1 let V be vector of integers of size m ;  $  TAB1 read m entries of V ;  $  TAB1 sort V ;  $  TAB1 let cnt be integer with cnt = (V[0] != mn) + (V[m-1] != mx) ;  $  TAB1 if V[0] < mn or V[m-1] > mx or n < m + cnt ;  $  TAB2 print Incorrect ;  $  TAB1 else ;  $  TAB2 print Correct ;
TAB0 declare function subtraction taking in an istream reference &r and an ostream reference &w ;  $  TAB1 let arg1, arg2 = integer ;  $  TAB1 read arg1 from r ;  $  TAB1 read arg2 from r ;  $  TAB1 if arg1 is greater than arg2 do the following ;  $  TAB2 let temp = integer with temp = arg1 ;  $  TAB2 set arg1 = arg2 ;  $  TAB2 set arg2 = temp ;  $  TAB1 let quotient = integer value = 0 ;  $  TAB1 let remainder = integer ;  $  TAB1 start loop ;  $  TAB2 set quotient = quotient + arg2 / arg1 ;  $  TAB2 set remainder = arg2 modulo arg1 ;  $  TAB2 set arg2 = arg1 ;  $  TAB2 set arg1 = remainder ;  $  TAB1 return to loop start while remainder is not equal to 0 ;  $  TAB1 write quotient to w ;  $  TAB0 declare function evaluate taking in an istream reference r and an ostream reference w ;  $  TAB1 let numOfTestCases = integer ;  $  TAB1 read numOfTestCases from r ;  $  TAB1 for integer i=1 to numOfTestCases inclusive call subtraction on r and w ;  $  TAB1 call evaluate on cin and cout ;
TAB0 a, b, c, d = integers ;  $  TAB0 function check takes two integers; t1 and t2 ;  $  TAB1 if t1 < t2 ;  $  TAB2 return 1 ;  $  TAB1 else if t1 > t2 ;  $  TAB2 return -1 ;  $  TAB1 read a, b, c, d ;  $  TAB1 x, y = integers set to 0 ;  $  TAB1 t1, t2 = integers with t1 set to b and t2 set to d ;  $  TAB1 while true is true ;  $  TAB2 if check of t1 and t2 is true ;  $  TAB3 add a to t1 ;  $  TAB3 increment x by 1 ;  $  TAB2 if check of t1 and t2 is -1 ;  $  TAB3 add c to t2 ;  $  TAB3 increment y by 1 ;  $  TAB2 if check of t1 and t2 is 0 ;  $  TAB3 print t1 ;  $  TAB3 break ;  $  TAB2 if x > 1000 or y > 1000 ;  $  TAB3 print "-1" ;
TAB1 tt = integer ;  $  TAB1 read tt ;  $  TAB1 while (decrement tt) is true do the following ;  $  TAB2 x,y,p,q = integers ;  $  TAB2 read x,y,p,q ;  $  TAB2 if p is 0 do the following ;  $  TAB3 if x is 0 print 0 else print -1 ;  $  TAB3 transfer control to beginning of loop ;  $  TAB2 if p is q do the following ;  $  TAB3 if x is y print 0 else print -1 ;  $  TAB3 transfer control to beginning of loop ;  $  TAB2 t1 = integer with t1 = (x+p-1)/p ;  $  TAB2 t2 = integer with t2 = ((y-x)+(q-p)-1)/(q-p) ;  $  TAB2 print (q * 1LL * max(t1, t2) - y) ;
TAB1 k, a, b, v are integers ;  $  TAB1 read k, a, b, v ;  $  TAB1 ans = integer = 0 ;  $  TAB1 while a ;  $  TAB2 x = integer = call min with k - 1, b ;  $  TAB2 set a to call max with 0, a - (x + 1) * v ;  $  TAB2 subtract x from b ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB1 make integers t and a ;  $  TAB1 read t ;  $  TAB1 for i = 1 to t inclusive ;  $  TAB2 read a ;  $  TAB2 if 360 mod (180 - a) equal 0 AND 360 / (180 - a) greater than 2 ;  $  TAB3 print "YES" ;  $  TAB2 else ;  $  TAB3 print "NO" ;
TAB1 result, n, and m are all integers with result = 0 and m = 0 ;  $  TAB1 input n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 x and y are integers ;  $  TAB2 read x and y ;  $  TAB2 set m to m - (x - y) ;  $  TAB2 if result is less than m, set result to m ;  $  TAB1 display result ;
TAB0 create int arrays a and b, both of length 21 ;  $  TAB0 create vector<int> p ;  $  TAB1 create int n and m ;  $  TAB1 read n and m ;  $  TAB1 for i = 1 to n inclusive, read a[i] ;  $  TAB1 for i = 1 to m inclusive, read b[i] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to m inclusive ;  $  TAB3 if b[j] is equal to a[i] ;  $  TAB4 push b[j] onto p ;  $  TAB4 continue ;  $  TAB1 if p empty ;  $  TAB2 print newline ;  $  TAB1 else ;  $  TAB2 for i = 0 to p size - 1 exclusive, print p[i] " " ;  $  TAB2 print last element of p ;
TAB1 n, m are integers ;  $  TAB1 read n, m ;  $  TAB1 piche = integer = 0 ;  $  TAB1 snake is a character array of sizes n, m ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 for j = 0 to m exclusive, set snake[i][j] to the character # ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 if i bitwise and 1 ;  $  TAB3 if piche is 0 ;  $  TAB4 for j = 0 to m - 1 exclusive ;  $  TAB5 set snake[i][j] to the character . ;  $  TAB5 set piche to 1 ;  $  TAB3 else ;  $  TAB4 for j = 1 to m exclusive ;  $  TAB5 set snake[i][j] to the character . ;  $  TAB5 set piche to 0 ;  $  TAB1 iterate n times ;  $  TAB2 for j = 0 to m exclusive, display snake[i][j] ;  $  TAB2 display newline ;
TAB1 t= integer ;  $  TAB1 read t ;  $  TAB1 while t is true, decrement t and do the following ;  $  TAB2 maze= character array of size 10 by 10 ;  $  TAB2 flag,sx,sy,gx,gy=integers with flag=0 ;  $  TAB2 for i=0 to 8 exclusive ;  $  TAB3 for j=0 to 8 exclusive ;  $  TAB4 read maze[i][j] ;  $  TAB4 if maze[i][j] is equal to K and flag is 0 ;  $  TAB5 then increment flag ;  $  TAB5 set sx=i ;  $  TAB5 assign j to sy ;  $  TAB4 else if maze[i][j] is K and flag is 1 ;  $  TAB5 increment flag ;  $  TAB5 set gx to i ;  $  TAB5 gy=j ;  $  TAB2 create integer a and b ;  $  TAB2 set a = absolute value of sx-gx ;  $  TAB2 set b= abs(gy-sy) ;  $  TAB2 if a mod 4 is 0 and b mod 4 is 0 ;  $  TAB3 print YES ;  $  TAB2 else do the following ;  $  TAB3 print NO ;
TAB1 number = integer ;  $  TAB1 temp = string ;  $  TAB1 read number ;  $  TAB1 name = string array of size number ;  $  TAB1 read number values into array name ;  $  TAB1 for i = 0 to number exclusive ;  $  TAB2 if size of name[i] is greater than 10 ;  $  TAB3 num = integer = (size of name[i]) - 2 ;  $  TAB3 print name[i][0], num, name[i][(size of name[i]) - 1] ;  $  TAB2 else ;  $  TAB3 print name[i] ;
TAB1 create map m with keys char, values int ;  $  TAB1 create int n, k, cek = 1 ;  $  TAB1 create string s ;  $  TAB1 read n, k, s ;  $  TAB1 for i = 0 to s length exclusive ;  $  TAB2 if s[i] is equal to 'G', m['G'] = i ;  $  TAB2 if s[i] is equal to 'T', m['T'] = i ;  $  TAB1 if m['G'] less than m['T'] ;  $  TAB2 if (m['T'] - m['G']) mod k is not equal to 0 ;  $  TAB3 set cek to 0 ;  $  TAB2 else ;  $  TAB3 for i = m['G']; i less than or equal to m['T']; increase i by k ;  $  TAB4 if s[i] equals '#', set cek to 0 ;  $  TAB1 else if m['G'] greater than m['T'] ;  $  TAB2 if (m['G'] - m['T']) mod k is not equal to 0 ;  $  TAB3 set cek to 0 ;  $  TAB2 else ;  $  TAB3 for i = m['G']; i greater than or equal to m['T']; subtract k from i ;  $  TAB4 if s[i] equals '#', set cek to 0 ;  $  TAB1 if cek ;  $  TAB2 print "YES" ;  $  TAB1 else ;  $  TAB2 print "NO" ;
TAB1 make double n and a ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 make double temp = 3 and ans = 0 ;  $  TAB2 read a ;  $  TAB2 while ans is less than a ;  $  TAB3 set ans to ((temp - 2) * 180) / temp ;  $  TAB3 increment temp ;  $  TAB2 if ans is equal to a ;  $  TAB3 print "YES\n" ;  $  TAB2 else ;  $  TAB3 print "NO\n" ;
TAB1 ch = string ;  $  TAB1 read ch ;  $  TAB1 n, sum are integers ;  $  TAB1 set name to size of ch ;  $  TAB1 set sum to 26 * (n + 1) - n ;  $  TAB1 print sum ;
TAB1 let n be an integer ;  $  TAB1 input n ;  $  TAB1 let arr be an integer array of size n ;  $  TAB1 for i = 0 to n exclusive, input arr[i] ;  $  TAB1 if n is less than 3 ;  $  TAB2 display 0 ;  $  TAB1 call sort with arguments arr, arr + n ;  $  TAB1 cnt = integer = 0 ;  $  TAB1 for i = 1 to n - 1 exclusive ;  $  TAB2 if arr[i] is greater than arr[0] and arr[i] is less than arr[n - 1], increment cnt ;  $  TAB1 display cnt ;
TAB0 declare boolean function isGood which takes in string s and integer k ;  $  TAB1 for integer i=9 to k inclusive ;  $  TAB2 if s does not contain i followed by 0 return false ;  $  TAB1 return true ;  $  TAB1 let n, k = integer ;  $  TAB1 let s = string ;  $  TAB1 read n, k ;  $  TAB1 let res = integer value 0 ;  $  TAB1 while (decrement n) is true do the following ;  $  TAB2 read s ;  $  TAB2 if a call to isGood on s and k returns true, increment res ;  $  TAB1 print res ;
TAB1 declare int n ;  $  TAB1 declare int array a of length 1001 ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive: read a[i] ;  $  TAB1 if a[n - 1] equals 15 ;  $  TAB2 print "DOWN" ;  $  TAB1 else if a[n - 1] equals 0 ;  $  TAB2 print "UP" ;  $  TAB1 else if n equals 1 ;  $  TAB2 print -1 ;  $  TAB1 else if a[n - 1] is less than a[n - 2] ;  $  TAB2 print "DOWN" ;  $  TAB1 else if a[n - 1] is greater than a[n - 2] ;  $  TAB2 print "UP" ;
TAB1 let l1, s1, r1, p1, l2, s2, r2, p2, l3, s3, r3, p3, l4, s4, r4, p4 be integers ;  $  TAB1 read l1, s1, r1, and p1 ;  $  TAB1 read l2, s2, r2, and p2 ;  $  TAB1 read l3, s3, r3, and p3 ;  $  TAB1 read l1, s4, r4, and p4 ;  $  TAB1 if (l1 or s1 or r1) and p1 ;  $  TAB2 print YES ;  $  TAB1 if (l2 or s2 or r2) and p2 ;  $  TAB2 print YES ;  $  TAB1 if (l3 or s3 or r3) and p3 ;  $  TAB2 print YES ;  $  TAB1 if (l4 or s4 or r4) and p4 ;  $  TAB2 print YES ;  $  TAB1 if l1 and p4 ;  $  TAB2 print YES ;  $  TAB1 if s1 and p3 ;  $  TAB2 print YES ;  $  TAB1 if r1 and p2 ;  $  TAB2 print YES ;  $  TAB1 if l4 and p3 ;  $  TAB2 print YES ;  $  TAB1 if s4 and p2 ;  $  TAB2 print YES ;  $  TAB1 if r4 and p1 ;  $  TAB2 print YES ;  $  TAB1 if l3 and p2 ;  $  TAB2 print YES ;  $  TAB1 if s3 and p1 ;  $  TAB2 print YES ;  $  TAB1 if r3 and p4 ;  $  TAB2 print YES ;  $  TAB1 if l2 and p1 ;  $  TAB2 print YES ;  $  TAB1 if s2 and p4 ;  $  TAB2 print YES ;  $  TAB1 if r2 and p3 ;  $  TAB2 print YES ;  $  TAB1 print NO ;
TAB0 let freq be an integer array of size 1005 ;  $  TAB1 create string str= " qwertyuiopasdfghjkl;zxcvbnm,./" ;  $  TAB1 create string s ;  $  TAB1 dir=char ;  $  TAB1 read dir ;  $  TAB1 read s ;  $  TAB1 j= integer ;  $  TAB1 newstr= string ;  $  TAB1 for i=0 to size of s exclusive ;  $  TAB2 for j=0 to size of str exclusive ;  $  TAB3 if str[j] is equal to s[i] then break ;  $  TAB2 if dir is equal to R ;  $  TAB3 then set newstr = newstr + str[j-1] ;  $  TAB2 else do the following ;  $  TAB3 set newstr = newstr + str[j+1] ;  $  TAB1 print newstr and new line ;
TAB0 S and T are strings ;  $  TAB0 x, a, b are integers ;  $  TAB0 status = boolean set to true ;  $  TAB1 read S, T ;  $  TAB1 for x = 0 to length of S exclusive ;  $  TAB2 if S[x] is greater than the character Z, set S[x] to S[x] - the character a + the character A ;  $  TAB2 if T[x] is greater than the character Z, set T[x] to T[x] - the character a + the character A ;  $  TAB2 if S[x] is greater than T[x] ;  $  TAB3 print 1 ;  $  TAB3 assign false to status ;  $  TAB3 break ;  $  TAB2 if S[x] is less than T[x] ;  $  TAB3 print -1 ;  $  TAB3 assign false to status ;  $  TAB3 break ;  $  TAB1 if status, print 0 ;
TAB0 declare integer array a, size 105 ;  $  TAB1 declare integers n, m ;  $  TAB1 while reading n and m is not interrupted ;  $  TAB2 set a elements to 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 declare integer x ;  $  TAB3 read x ;  $  TAB3 for j = 0 to x exclusive ;  $  TAB4 declare integer w ;  $  TAB4 read w ;  $  TAB4 set a[w] to 1 ;  $  TAB2 define integer f = 0 ;  $  TAB2 for i = 1 to m inclusive ;  $  TAB3 if not a[i] ;  $  TAB4 set f to 1 ;  $  TAB4 stop loop ;  $  TAB2 if f ;  $  TAB3 print "NO\n" ;  $  TAB2 else ;  $  TAB3 print "YES\n" ;
TAB0 create function fast ;  $  TAB0 in function gcd with parameters integers a, b and return integer ;  $  TAB1 if b equals 0, return a ;  $  TAB1 return call gcd with b, a mod b ;  $  TAB1 call fast ;  $  TAB1 n, x are integers ;  $  TAB1 read n ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 m = double = 360.0 / (180.0 - x) ;  $  TAB2 if m equals integer value of m ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 n,k = integer ;  $  TAB1 read n and k ;  $  TAB1 create an integer ans = n ;  $  TAB1 set k = k - n * 2 ;  $  TAB1 set ans = ans - k ;  $  TAB1 if ans < 0 then set ans=0 ;  $  TAB1 print ans and new line ;
TAB1 n is an integer ;  $  TAB1 input n ;  $  TAB1 q1, q2, k1, k2, c1, c2 are integers ;  $  TAB1 read q1, q2, k1, k2, c1, and c2 ;  $  TAB1 f = integer = 0 ;  $  TAB1 if (both k1 and c1 are less than q1) or (both k1 and c1 are greater than q1) ;  $  TAB2 if (both k2 and c2 are less than q1) or (both k2 and c2 are greater than q2), set f to 1 ;  $  TAB1 if f is equal to 0 ;  $  TAB2 display NO ;  $  TAB1 else ;  $  TAB2 display YES ;
TAB1 n, x, a, c = long long integers with c set to 0 ;  $  TAB1 ch = character ;  $  TAB1 read n and x ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read ch and a ;  $  TAB2 if ch is '+' ;  $  TAB3 increment x by a ;  $  TAB2 else ;  $  TAB3 if x < a ;  $  TAB4 increment c by 1 ;  $  TAB3 else ;  $  TAB4 decrement x by a ;  $  TAB1 print x, " ", c ;
TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 create set<string> ss ;  $  TAB1 sort s ;  $  TAB1 do ;  $  TAB2 create string m = s ;  $  TAB2 create vector<string> v ;  $  TAB2 for i = 0 to 3 exclusive do push s.substr(2 * i, 2) onto v ;  $  TAB2 for i = 0 to 4 exclusive ;  $  TAB3 for i = 0 to 4 exclusive ;  $  TAB4 for i = 0 to 4 exclusive ;  $  TAB5 create string str = v[0] + v[1] + v[2] ;  $  TAB5 set m to min of m and str ;  $  TAB5 swap v[1] and v[2] ;  $  TAB5 swap v[2][0] and v[2][1] ;  $  TAB4 swap v[0] and v[1] ;  $  TAB4 swap v[0][0] and v[0][1] ;  $  TAB3 swap v[0] and v[2] ;  $  TAB3 swap v[2][0] and v[2][1] ;  $  TAB2 insert m into ss ;  $  TAB1 while next_permutation(s.begin(), s.end()) ;  $  TAB1 print ss size ;
TAB1 define int array month of size 13 = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} ;  $  TAB1 declare int m, d ;  $  TAB1 while read m and d ;  $  TAB2 declare int res ;  $  TAB2 define int temp = month[m] + d - 1 ;  $  TAB2 if temp mod 7 ;  $  TAB3 assign temp / 7 + 1 to res ;  $  TAB2 else ;  $  TAB3 assign temp / 7 to res ;  $  TAB2 print res ;
TAB1 let n be an integer ;  $  TAB1 a is an integer array of size 101 ;  $  TAB1 ans is an integer set to 1000000000 ;  $  TAB1 input n ;  $  TAB1 read n values into array a ;  $  TAB1 for x = 1 to n inclusive ;  $  TAB2 e is an integer set to 0 ;  $  TAB2 for i - 1 to n inclusive, set e to (absolute value (x - i) + i - 1 + x - 1) * a[i] ;  $  TAB2 if e is less than ans, set ans to e ;  $  TAB1 display 2 * ans ;
TAB0 n, m, i, j, ans are integers ;  $  TAB0 a = character array of sizes 105 and 105 ;  $  TAB1 input n ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 for j = 1 to n inclusive, read a[i][j] ;  $  TAB1 for i = 1 to n inclusive ;  $  TAB2 assign 0 to m ;  $  TAB2 for j = 1 to n inclusive ;  $  TAB3 if a[i][j] is the character C ;  $  TAB2 add m * (m - 1) / 2 to ans ;  $  TAB1 for j = 1 to n inclusive ;  $  TAB2 assign 0 to m ;  $  TAB2 for i = 1 to n inclusive ;  $  TAB3 if a[i][j] is the character C, increment m ;  $  TAB2 add m * (m - 1) / 2 to ans ;  $  TAB1 display ans ;
TAB0 declare function won1, which returns a boolean and takes strings a and b ;  $  TAB1 if a is "rock" and b is "scissors", return true ;  $  TAB1 if a is "scissors" and b is "paper" return true ;  $  TAB1 if a is "paper" and b is "rock" return true ;  $  TAB1 return false ;  $  TAB1 names = array of strings length 3 set to "F", "M", "S" ;  $  TAB1 a = array of strings length 3 ;  $  TAB1 for i = 0 to _n where _n is 3 - 1, inclusive, read a[i] ;  $  TAB1 for i = 0 to _n where _n is 3 - 1, inclusive ;  $  TAB2 won = boolean set to true ;  $  TAB2 for j = 0 to _n where _n is 3 - 1 inclusive ;  $  TAB3 if i ins't j, set won to won1 of a[i] and a[j] ;  $  TAB2 if won is true ;  $  TAB3 print names[i] ;  $  TAB3 exit of 0 ;  $  TAB1 print "?" ;
TAB0 create constant integer INF = 1000007 ;  $  TAB0 create constant integer MAXN = 99999 ;  $  TAB0 create constant integer QW = 55555 ;  $  TAB0 in function File ;  $  TAB1 freopen("in.in", "r", stdin) ;  $  TAB1 freopen("out.out", "w", stdout) ;  $  TAB0 in inline function boost ;  $  TAB1 create integers k, a, b, v ;  $  TAB1 read k, a, b, v ;  $  TAB1 create integer cnt = 0 ;  $  TAB1 while true ;  $  TAB2 add 1 to cnt ;  $  TAB2 create integer box = min of k - 1 and b ;  $  TAB2 assign b - box to b ;  $  TAB2 create integer nuts = (box + 1) * v ;  $  TAB2 assign a - nuts to a ;  $  TAB2 if a is less than or equal to 0, break ;  $  TAB1 print cnt ;
TAB1 students = integer, g1, g2, amounts1, amounts2 are integer arrays of size 105 each ;  $  TAB1 call memset with amounts1, 0, call sizeof with amounts1 ;  $  TAB1 call memset with amounts2, 0, call sizeof with amounts2 ;  $  TAB1 read students ;  $  TAB1 read students values into array g1 ;  $  TAB1 read students values into array g2 ;  $  TAB1 for i = 0 to students exclusive ;  $  TAB2 increment amounts1[g1[i]] ;  $  TAB2 increment amounts2[g2[i]] ;  $  TAB1 for i = 1 to 5 inclusive ;  $  TAB2 if (amounts1[i] + amounts2[i]) mod 2 equals 1 ;  $  TAB3 output -1 ;  $  TAB1 sitch = integer = 0 ;  $  TAB1 for i = 1 to 5 inclusive, add absolute value ((amounts1[i] - amounts2[i]) / 2) to sitch ;  $  TAB1 divide sitch by 2 ;  $  TAB1 output sitch ;
TAB1 let n, sol = integers ;  $  TAB1 read n ;  $  TAB1 set sol = 0 ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 let x1, y1, x2, y2 = integers ;  $  TAB2 read x1, y1, x2, y2 ;  $  TAB2 set sol = sol + (x2 - x1 +1) * (y2 - y1 +1) ;  $  TAB1 print sol ;
TAB1 let n = long longs ;  $  TAB1 while (read n) is true do the following ;  $  TAB2 let a, i, p = long longs where a=0, i=0 and p=0 ;  $  TAB2 if n is less than 1 print 0 ;  $  TAB2 for integer j=1 to n inclusive do the following ;  $  TAB3 set p = (j* (j+1)) / 2 ;  $  TAB3 set a = a + p ;  $  TAB3 if a is greater tan n exit the loop ;  $  TAB3 increment i ;  $  TAB2 print i ;
TAB0 n is an integer, a is an integer array of size 209 ;  $  TAB1 read n ;  $  TAB1 for i = 1 to n * 2 inclusive, read a[i] ;  $  TAB1 call sort with a + 1, a + 1 + n * 2 ;  $  TAB1 if a[n + 1] is greater than a[n] ;  $  TAB2 display YES ;  $  TAB1 else ;  $  TAB2 display NO ;
TAB0 define fp which takes long long n, p and returns long lon ;  $  TAB1 if p is equal to 0, return 1 ;  $  TAB1 if p is equal to 1 return n ;  $  TAB1 let res be long long with res = fp of n, p/2 ;  $  TAB1 update res to res * res ;  $  TAB1 if p is odd, update res to res * n ;  $  TAB1 return res ;  $  TAB1 n,ma,b,ans,t = long long with ans = 0 ;  $  TAB1 read n,a,b,m ;  $  TAB1 while a is greater than 0 ;  $  TAB2 set t to min of n-1, b ;  $  TAB2 decrement a by m*(t+1) ;  $  TAB2 decrement b by t ;  $  TAB2 increment ans ;  $  TAB1 print ans ;
TAB1 let a,b,c be integers ;  $  TAB1 read a,b,c ;  $  TAB1 print out 2 * c * (a + b - 2) - 8 * (c * (c - 1)) ;
TAB0 let MAXN = integer constant value 110 ;  $  TAB0 let mark = array of boolean with size MAXN ;  $  TAB1 set sizeof(mark) bytes starting at mark to false ;  $  TAB1 let n, m = integers ;  $  TAB1 read n, m ;  $  TAB1 for integer i=1 to n inclusive do the following ;  $  TAB2 let x, y = integers ;  $  TAB2 read x, y ;  $  TAB2 for integer j=x to y exclusive set mark[j] = true ;  $  TAB1 let flag = boolean with value = true ;  $  TAB1 for integer i=0 to m exclusive do the following ;  $  TAB2 if mark[i] is false do the following ;  $  TAB3 set flag = false ;  $  TAB3 exit the loop ;  $  TAB1 if flag is true ;  $  TAB2 print YES ;  $  TAB1 else ;  $  TAB2 print NO ;
TAB0 a=array of integer of size 110 ;  $  TAB1 n,m,x,y=integers ;  $  TAB1 read n,m ;  $  TAB1 set all the content of a to 0 ;  $  TAB1 let flag bean integer with flag=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 read x ;  $  TAB2 for j =0 to x exclusive ;  $  TAB3 read y ;  $  TAB3 set a[y]=1 ;  $  TAB1 for i=1 to m inclusive ;  $  TAB2 if a[i] =0 ;  $  TAB3 set flag=1 ;  $  TAB3 break ;  $  TAB1 if flag is true ;  $  TAB2 print NO ;  $  TAB1 else do the following ;  $  TAB2 print YES ;
TAB1 len is an integer ;  $  TAB1 n0 is an integer set to 0 ;  $  TAB1 n1 is an integer set to 0 ;  $  TAB1 galaxy is a string ;  $  TAB1 input len ;  $  TAB1 input galaxy ;  $  TAB1 for i = 0 to len exclusive ;  $  TAB2 if galaxy[i] is the character 0 ;  $  TAB3 increment n0 ;  $  TAB2 else ;  $  TAB3 increment n1 ;  $  TAB1 display absolute value of (n0 - n1) ;
TAB1 let n, k be integers ;  $  TAB1 let s be array of char of size 111 ;  $  TAB1 while input available, read n, k ;  $  TAB2 reads ;  $  TAB2 let x, y be integers ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if s[i] is equal to G, set x to i ;  $  TAB3 if s[i] is equal to T, set y to i ;  $  TAB2 let a be integer with a = 1 ;  $  TAB2 let flag be integer with flag = 0 ;  $  TAB2 if x is less than y ;  $  TAB3 while true ;  $  TAB4 if s[x + k * a] is euqla to T ;  $  TAB5 set flag to 1 ;  $  TAB5 break ;  $  TAB4 if s[x + k * a] is equal to #, break ;  $  TAB4 if x + k*a is greater than or equal to n, break ;  $  TAB4 increment a ;  $  TAB2 else ;  $  TAB3 while true ;  $  TAB4 if s[x - k * a] is equal to T ;  $  TAB5 set flag to 1 ;  $  TAB5 break ;  $  TAB4 if s[x - k*a] is equal to #, break ;  $  TAB4 if x - k * a is less than 0, break ;  $  TAB4 increment a ;  $  TAB2 if flag is equal to 1 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 make integers n, x, sum = 0, v = 0 ;  $  TAB1 while reading n and x ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 make integer array z of size n ;  $  TAB3 read z[i] ;  $  TAB3 increase sum by z[i] ;  $  TAB2 if sum greater than 0 ;  $  TAB3 while (sum greater than 0) ;  $  TAB4 if ((sum mod x not equal to sum) and (sum / x not equal to sum)) or (sum equals x) ;  $  TAB5 decrease sum by x ;  $  TAB5 increment v ;  $  TAB4 else ;  $  TAB5 decrement x ;  $  TAB2 else if sum less than 0 ;  $  TAB3 multiply sum by itself and -1 ;  $  TAB3 while (sum greater than 0) ;  $  TAB4 if (sum mod x equals 0 or sum mod x greater than 0) and (sum / x not equal to 0) ;  $  TAB5 decrease sum by x ;  $  TAB5 increment v ;  $  TAB4 else ;  $  TAB5 decrement x ;  $  TAB2 print v ;  $  TAB2 set v to 0 ;
TAB1 make ints a and b ;  $  TAB1 read a and b ;  $  TAB1 make dynamically allocated array arr with 1000 ints ;  $  TAB1 make dynamically allocated array brr with 1000 ints ;  $  TAB1 read a values into arr ;  $  TAB1 read a values into brr ;  $  TAB1 if arr[0] is 0 ;  $  TAB2 print "NO" ;  $  TAB1 if arr[b - 1] is 1 ;  $  TAB2 print "YES" ;  $  TAB1 for i = b - 1 to a - 1 inclusive ;  $  TAB2 if arr[i] is 1 and brr[i] is 1 and brr[b - 1] is 1 ;  $  TAB3 print "YES" ;  $  TAB1 print "NO" ;
TAB1 a,b,c=integer ;  $  TAB1 read a,b,c ;  $  TAB1 n=integer ;  $  TAB1 read n ;  $  TAB1 ans be an integer with ans=0 ;  $  TAB1 for i=0 to n exclusive ;  $  TAB2 cnt=integer ;  $  TAB2 read cnt ;  $  TAB2 if cnt>b and cnt>c then increment ans ;  $  TAB1 print ans ;
TAB1 create long long n, k ;  $  TAB1 read n, k ;  $  TAB1 create long long x = (n / 2) / (1 + k) ;  $  TAB1 print x, " ", x * k, " ", n - x * (1 + k) ;
TAB1 create integer n ;  $  TAB1 read n ;  $  TAB1 create integer array mas with 100 elements ;  $  TAB1 fill mas with 0 ;  $  TAB1 while n decrement ;  $  TAB2 create integer a ;  $  TAB2 read a ;  $  TAB2 increment mas[a - 1] ;  $  TAB1 create ans = mas[0] ;  $  TAB1 for i = 1 to 100 exclusive do set ans to max of ans and mas[i] ;  $  TAB1 print ans ;
TAB1 declare int array a of size 110 ;  $  TAB1 declare int n ;  $  TAB1 while read n ;  $  TAB2 read n values into a ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if i is 0 or i is n - 1 then continue ;  $  TAB3 if a[i] is 0 and a[i - 1] is 1 and a[i + 1] is 1 then set a[i] to 1 ;  $  TAB2 define int num = 0 ;  $  TAB2 for i = 0 to n exclusive ;  $  TAB3 if a[i] is 1 then increment num ;  $  TAB2 print num ;
TAB1 n is a long integer ;  $  TAB1 input n ;  $  TAB1 c = integer = 0 ;  $  TAB1 while n is positive ;  $  TAB2 let x be an integer with x = log base 2 of n ;  $  TAB2 set n to n - 2 to the power of x ;  $  TAB2 increment c ;  $  TAB1 display c ;
TAB0 let c be a character array of size 1000 ;  $  TAB0 let res be an integer array of size 1000 ;  $  TAB0 let l, mn, pl, n be integers with pl = 1 ;  $  TAB1 ch = character ;  $  TAB1 input ch ;  $  TAB1 while input ch ;  $  TAB2 if ch is the character =, break ;  $  TAB2 set c[l] to ch ;  $  TAB2 if c[l] is the character + ;  $  TAB3 increment pl ;  $  TAB2 else ;  $  TAB3 increment mn ;  $  TAB2 increment l ;  $  TAB2 input ch ;  $  TAB1 input n ;  $  TAB1 if n * pl - nm is less than n or pl - n * mn is greater than n ;  $  TAB2 print Impossible ;  $  TAB1 else ;  $  TAB2 print Possible ;  $  TAB2 for i = 0 to 1 inclusive, set res[i] to 1 ;  $  TAB2 d is an integer with d = n - (pl - mn) ;  $  TAB2 for i = 0 to 1 inclusive ;  $  TAB3 if (i equals 0 or c[i - 1] equals the character +) and d is greater than 0 ;  $  TAB4 if d is less than n - res[i] ;  $  TAB5 add d to res[i] ;  $  TAB5 set d to 0 ;  $  TAB4 else ;  $  TAB5 subtract n - res[i] from d ;  $  TAB5 res[i] is assigned n ;  $  TAB3 else if i isn't 0 and c[i - 1] equals the character - and d is less than 0 ;  $  TAB4 if -d is less than n - res[i] ;  $  TAB5 add -d to res[i] ;  $  TAB5 set d to 0 ;  $  TAB4 else ;  $  TAB5 add n - res[i] to d ;  $  TAB5 set res[i] to n ;  $  TAB2 output res[0] ;  $  TAB2 for i = 0 to 1 exclusive, output the character space, c[i] the character space, and res[i + 1] ;  $  TAB2 output the string " = " and n ;
TAB0 create string s ;  $  TAB0 create ints f1 and f2 ;  $  TAB1 read s ;  $  TAB1 create int len = s length ;  $  TAB1 create int st = -1 and en = -2 ;  $  TAB1 for i = 0 to len - 1 inclusive ;  $  TAB2 if f1 is equal to 0 and s[i] is equal to 'a', continue ;  $  TAB2 set f1 to 1 ;  $  TAB2 if f2 is equal to 0 ;  $  TAB3 set st to i ;  $  TAB3 set f2 to 1 ;  $  TAB2 if s[i] is equal to 'a', break ;  $  TAB2 set en to i ;  $  TAB1 for i = st to en inclusive, subtract 1 from s[i] ;  $  TAB1 if not f1, set s[len - 1] to 'z' ;  $  TAB1 print s ;
TAB0 create int n, k, cur, ans ;  $  TAB1 read n, k ;  $  TAB1 while n decremented ;  $  TAB2 create int x ;  $  TAB2 read x ;  $  TAB2 increase cur by x ;  $  TAB2 create int r = min of 8 and cur ;  $  TAB2 decrease cur by r ;  $  TAB2 decrease k by r ;  $  TAB2 increment ans ;  $  TAB2 if k is less than or equal to 0 then break ;  $  TAB1 if k greater than 0 ;  $  TAB2 print -1 ;  $  TAB1 else ;  $  TAB2 print ans ;
TAB0 create int const MAXN = 5005 ;  $  TAB0 in function izq returning string and taking string c ;  $  TAB1 create string temp of size 6 filled with ' ' ;  $  TAB1 set temp[0] to c[3] ;  $  TAB1 set temp[1] to c[5] ;  $  TAB1 set temp[2] to c[2] ;  $  TAB1 set temp[3] to c[1] ;  $  TAB1 set temp[4] to c[4] ;  $  TAB1 set temp[5] to c[0] ;  $  TAB1 return temp ;  $  TAB0 in function abajo with return type string and taking string c ;  $  TAB1 create string temp of size 6 filled with ' ' ;  $  TAB1 set temp[0] to c[0] ;  $  TAB1 set temp[1] to c[1] ;  $  TAB1 set temp[2] to c[3] ;  $  TAB1 set temp[3] to c[4] ;  $  TAB1 set temp[4] to c[5] ;  $  TAB1 set temp[5] to c[2] ;  $  TAB1 return temp ;  $  TAB0 in function last, accepting string c and returning a string ;  $  TAB1 create string ans = c ;  $  TAB1 for i = 0 to 3000 exclusive ;  $  TAB2 if rand() % 2 ;  $  TAB3 set c to izq of c ;  $  TAB2 else ;  $  TAB3 set c to abajo of c ;  $  TAB2 set ans to max of ans and c ;  $  TAB1 return ans ;  $  TAB1 create string color ;  $  TAB1 read color ;  $  TAB1 sort color ;  $  TAB1 create set ans containing strings ;  $  TAB1 do ;  $  TAB2 create string maxi = last(color) ;  $  TAB2 if maxi not in ans then insert maxi into ans ;  $  TAB1 while next_permutation(color.begin(), color.end()) ;  $  TAB1 print ans size ;
TAB1 let a, b, c, d = integers ;  $  TAB1 read a, b, c, d ;  $  TAB1 if gcd of a and c is not equal to 1 and b modulo gcd of a and c is not equal to d modulo gcd of a and c ;  $  TAB2 print -1 ;  $  TAB1 else do the following ;  $  TAB2 while b is not equal to d do the following ;  $  TAB3 if b is less than d ;  $  TAB4 set b = b+a ;  $  TAB3 else ;  $  TAB4 set d = d+c ;  $  TAB2 print b ;
TAB0 let a, b be integers ;  $  TAB1 read a and b ;  $  TAB1 if abs of a-b is greater than or equal to 2 ;  $  TAB2 print out NO with newline ;  $  TAB1 else ;  $  TAB2 if a is equal to 0 and b is equal to 0 ;  $  TAB3 print NO with newline ;  $  TAB2 else ;  $  TAB3 print YES with newline ;
TAB1 create long longs a, b, c, d, e, n ;  $  TAB1 create string s ;  $  TAB1 read s ;  $  TAB1 n = size of s ;  $  TAB1 n = (n + 1) * 26 - n ;  $  TAB1 print n ;
TAB0 create constant integer M = 50+5 ;  $  TAB1 x,t,a,b,da,db = integers ;  $  TAB1 read x,t,a,b,da,db ;  $  TAB1 create boolean ok = false ;  $  TAB1 for i=0 to t-1 inclusive ;  $  TAB2 for j=0 to t-1 inclusive ;  $  TAB3 create integer tsum = a - da * i + b - db * j ;  $  TAB3 if tsum is equal to x then assign true to ok ;  $  TAB1 for i=0 to t-1 inclusive ;  $  TAB2 create integer tsum = a - da * i ;  $  TAB2 if tsum is equal to x then set ok to true ;  $  TAB1 for i=0 to t-1 inclusive ;  $  TAB2 create integer tsum = b - db * i ;  $  TAB2 if tsum is equal to x then set ok to true ;  $  TAB1 if x is equal to 0 then assign true to ok ;  $  TAB1 create integer string = YES if ok is true else string = NO ;  $  TAB1 print ans and new line ;
TAB0 in function isPrime with parameter long long n and return boolean ;  $  TAB1 if n is at most 1, return false ;  $  TAB1 if n is at most 3, return true ;  $  TAB1 if n is even or n is divisible by 3, return false ;  $  TAB1 for i = 5 as long as i * i is at most n with increment i + 6 ;  $  TAB2 if n is divisible by i or n mod (i + 2) is 0, return false ;  $  TAB1 return true ;  $  TAB1 t, x, y, k, m, ans are long longs all set to 0, n, i, j are long longs ;  $  TAB1 s, p are strings ;  $  TAB1 read t ;  $  TAB1 while decrement t ;  $  TAB2 input n ;  $  TAB2 if 360 mod (180 - n) equals 0 ;  $  TAB3 print YES ;  $  TAB2 else ;  $  TAB3 print NO ;
TAB1 make integers n and x ;  $  TAB1 read n and x ;  $  TAB1 make vector cards, holding ints with size of n + 1 ;  $  TAB1 make int tot = 0 ;  $  TAB1 for i = 0 to n exclusive ;  $  TAB2 read cards[i] ;  $  TAB2 increase tot by cards[i] ;  $  TAB1 set tot to abs of tot ;  $  TAB1 make int cnt = tot / x ;  $  TAB1 if tot mod x greater than 0, increment cnt ;  $  TAB1 print cnt ;
TAB1 s, u are strings ;  $  TAB1 read s, u ;  $  TAB1 m is an integer set to length of u ;  $  TAB1 for i = 0 to m exclusive, assign the character . + s + the character . to s ;  $  TAB1 mini and cur are integers with mini set to m, cur set to 0 ;  $  TAB1 for i = 0 to (length of s) - (length of u) + 1 exclusive ;  $  TAB2 assign 0 to cur ;  $  TAB2 for j = 0 to length of u exclusive ;  $  TAB3 if s[i + j] is unequal to u[j], increment cur ;  $  TAB2 set mini to call min with mini, cur ;  $  TAB1 print mini ;
TAB0 maxl is a constant integer set to 2e5 + 10 ;  $  TAB0 la, lb are integers ;  $  TAB0 s and t are both character arrays both with size maxl ;  $  TAB1 read la, lb, s, t ;  $  TAB1 tar is an integer set to -1 ;  $  TAB1 for i = 0 to la exclusive ;  $  TAB2 if s[i] equals the character *, assign i to tar ;  $  TAB1 if tar equals -1 ;  $  TAB2 if la isn't lb ;  $  TAB3 display NO ;  $  TAB2 for i = 0 to la exclusive ;  $  TAB3 if s[i] isn't t[i] ;  $  TAB4 display NO ;  $  TAB2 display YES ;  $  TAB1 if la - 1 is greater than lb ;  $  TAB2 display NO ;  $  TAB1 for i = 0 to tar exclusive ;  $  TAB2 if s[i] isn't t[i] ;  $  TAB3 display NO ;  $  TAB1 for i = 0 as long as la - i - 1 is greater than tar with increment i ;  $  TAB2 if s[la - i - 1] isn't t[lb - i - 1] ;  $  TAB3 display NO ;  $  TAB1 display YES ;
