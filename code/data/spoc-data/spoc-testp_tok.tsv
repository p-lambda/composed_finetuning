TAB0 declare string variable s ; TAB0 declare short int sz ; TAB0 declare boolean called flag = false ; TAB1 read s ; TAB1 for integer i = length of s - 1 to 0 inclusive counting down ; TAB2 if s [ i ] ! = ' / ' ; TAB3 sz = i ; TAB3 break the loop ; TAB1 for i = 0 to sz inclusive ; TAB2 if flag = false and s [ i ] = ' / ' ; TAB3 set flag to true ; TAB3 print s [ i ] ; TAB2 else if s [ i ] ! = ' / ' ; TAB3 set flag to false ; TAB3 print s [ i ] ; TAB1 print ' \ n ' ;	string s ; short int sz ; bool flag = false ; int main ( ) { cin >> s ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' / ' ) { sz = i ; break ; } } for ( int i = 0 ; i <= sz ; i ++ ) { if ( flag == false && s [ i ] == ' / ' ) { flag = true ; cout << s [ i ] ; } else if ( s [ i ] != ' / ' ) { flag = false ; cout << s [ i ] ; } } cout << ' \n ' ; return 0 ; }
TAB1 let a be array of chars of length 110 ; TAB1 len , i , j = integers ; TAB1 read a ; TAB1 len = length of a ; TAB1 for i = 0 to len exclusive ; TAB2 if a [ j ] ! = ' / ' or a [ i ] ! = ' / ' increment j and set a [ j ] to a [ i ] ; TAB1 decrement j while j > 0 and a [ j ] = = ' / ' ; TAB1 set a [ j + 1 ] to " \ 0 " ; TAB1 print a [ i ] in the loop from 0 while a [ i ] is not equal to " \ 0 " ; TAB1 print end of line ;	int main ( ) { char a [ 110 ] ; int len , i , j ; cin >> a ; len = strlen ( a ) ; for ( i = 1 , j = 0 ; i < len ; i ++ ) { if ( a [ j ] != ' / ' || a [ i ] != ' / ' ) { a [ ++ j ] = a [ i ] ; } } while ( j > 0 && a [ j ] == ' / ' ) { j -- ; } a [ j + 1 ] = ' \0 ' ; for ( i = 0 ; a [ i ] != ' \0 ' ; i ++ ) cout << a [ i ] ; cout << endl ; return 0 ; }
TAB0 let eps be constant long double = 1e - 7 ; TAB0 set constant integer inf to 1000000010 ; TAB0 set constant integer mod to 1000000007 ; TAB0 set constant integer MAXN to 100010 ; TAB0 declare strings called s and t ; TAB1 read input into s ; TAB1 set value of t to s [ 0 ] ; TAB1 for integer i = 1 to length of s exclusive ; TAB2 if s [ i ] = = ' / ' and s [ i - 1 ] is equal to ' / ' continue the loop ; TAB2 increase t by s [ i ] ; TAB1 if last element of t is equal to ' / ' , set t to t . substr ( 0 , t . size ( ) - 1 ) ; TAB1 if t is an empty string set t to " / " ; TAB1 print t and a new line ; TAB0 create constant long double eps with eps = 1e - 7 ; TAB0 creat constant integer inf with inf = 1000000010 ; TAB0 create constant integer mod with mod = 1000000007 ; TAB0 create constant integer MAXN with MAXN = 100010 ; TAB0 create strings s , t ; TAB1 read line from cin to s ; TAB1 set t to s [ 0 ] ; TAB1 for i = 1 to size of s ; TAB2 if s [ i ] is ' / ' and s [ i - 1 ] is ' / ' , break current loop iteration ; TAB2 increment t by s [ i ] ; TAB1 if t [ size of t - 1 ] is ' / ' , set t to substring of t starting at 0 to size of t - 1 ; TAB1 if t is " " , set t to " / " ; TAB1 print t print newline ;	const long double eps = 1e-7 ; const int inf = 1000000010 ; const int mod = 1000000007 ; const int MAXN = 100010 ; string s , t ; int main ( ) { getline ( cin , s ) ; t = s [ 0 ] ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' / ' && s [ i - 1 ] == ' / ' ) continue ; t += s [ i ] ; } if ( t [ t . size ( ) - 1 ] == ' / ' ) t = t . substr ( 0 , t . size ( ) - 1 ) ; if ( t == "  " ) t = " / " ; cout << t << endl ; return 0 ; } const long double eps = 1e-7 ; const int inf = 1000000010 ; const int mod = 1000000007 ; const int MAXN = 100010 ; string s , t ; int main ( ) { getline ( cin , s ) ; t = s [ 0 ] ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' / ' && s [ i - 1 ] == ' / ' ) continue ; t += s [ i ] ; } if ( t [ t . size ( ) - 1 ] == ' / ' ) t = t . substr ( 0 , t . size ( ) - 1 ) ; if ( t == "  " ) t = " / " ; cout << t << endl ; return 0 ; }
TAB1 declare string variable str ; TAB1 read str ; TAB1 ans is vector of characters ; TAB1 assign value false to the boolean flag ; TAB1 for long long i from 0 to length of str exclusive ; TAB2 if str [ i ] is ' / ' ; TAB3 if flag is true , continue ; TAB3 set flag to true ; TAB2 else ; TAB3 set flag to false ; TAB2 push str [ i ] into ans ; TAB1 for i = 0 to length of ans exclusive ; TAB2 if length of ans > 1 and i = length of ans - and ans [ i ] = ' / ' , continue the loop ; TAB2 print ans [ i ] ; TAB1 print new line ; TAB1 create string str ; TAB1 read str ; TAB1 create character vector ans ; TAB1 create boolean flag with flag = false ; TAB1 for i = 0 to size of str exclusive ; TAB2 if str [ i ] is ' / ' ; TAB3 if flag is true , break current loop iteration ; TAB3 set flag to true ; TAB2 else ; TAB3 set flag to false ; TAB2 add element str [ i ] to end of ans ; TAB1 for i = 0 to size of ans exclusive ; TAB2 if size of ans is greater than 1 and i is size of ans - 1 and ans [ i ] is ' / ' , break current loop iteration ; TAB2 print ans [ i ] ; TAB1 print newline ;	int main ( ) { string str ; cin >> str ; vector < char > ans ; bool flag = false ; for ( long long ( i ) = ( 0 ) ; ( i ) < ( str . size ( ) ) ; ++ i ) { if ( str [ i ] == ' / ' ) { if ( flag ) continue ; flag = true ; } else { flag = false ; } ans . push_back ( str [ i ] ) ; } for ( long long ( i ) = ( 0 ) ; ( i ) < ( ans . size ( ) ) ; ++ i ) { if ( ans . size ( ) > 1 && i == ans . size ( ) - 1 && ans [ i ] == ' / ' ) continue ; cout << ans [ i ] ; } cout << endl ; return 0 ; } int main ( ) { string str ; cin >> str ; vector < char > ans ; bool flag = false ; for ( long long ( i ) = ( 0 ) ; ( i ) < ( str . size ( ) ) ; ++ i ) { if ( str [ i ] == ' / ' ) { if ( flag ) continue ; flag = true ; } else { flag = false ; } ans . push_back ( str [ i ] ) ; } for ( long long ( i ) = ( 0 ) ; ( i ) < ( ans . size ( ) ) ; ++ i ) { if ( ans . size ( ) > 1 && i == ans . size ( ) - 1 && ans [ i ] == ' / ' ) continue ; cout << ans [ i ] ; } cout << endl ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 create integer t with value 2 ; TAB1 declare empty strings ans and temps ; TAB1 set value of booleans chk and lol to false ; TAB1 for integer i = 0 to size of s exclusive ; TAB2 if isalpha ( s [ i ] ) ; TAB3 increase temps by s [ i ] ; TAB3 set chk to true ; TAB2 else ; TAB3 if chk is true ; TAB4 append string " / " + temps to ans ; TAB4 set value of temps to an empty string ; TAB4 set chk to false ; TAB3 set lol to true ; TAB1 if temps is not empty attach " / " and temps to ans ; TAB1 if and is empty and lol is true append character " / " to ans ; TAB1 print ans and a new line ;	int main ( ) { string s ; cin >> s ; int t = 2 ; string ans = "  " , temps = "  " ; bool chk = false , lol = false ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( isalpha ( s [ i ] ) ) { temps += s [ i ] ; chk = true ; } else { if ( chk == true ) { ans += " / " + temps ; temps = "  " ; chk = false ; } lol = true ; } } if ( temps . size ( ) != 0 ) ans += " / " + temps ; if ( ans . size ( ) == 0 && lol == true ) ans += " / " ; cout << ans << endl ; }
TAB1 let s be string ; TAB1 read s ; TAB1 Let l be the size of string s ; TAB1 let n = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is not equal to s [ i - 1 ] and s [ i ] is equal to / ; TAB3 increment n ; TAB3 print s [ i - 1 ] ; TAB1 if s [ i - 1 ] is not equal to / or n = 0 ; TAB1 end of the line ; TAB1 create string s ; TAB1 read s ; TAB1 create integer l with l = size of s ; TAB1 create integer n with n = 0 ; TAB1 for i = 1 to l exclusive ; TAB2 if ( s [ i ] is s [ i - 1 ] and s [ i ] is ' / ' ) is false ; TAB3 increment n ; TAB3 print s [ i - 1 ] ; TAB1 if s [ l - 1 ] is not ' / ' or n is 0 , print s [ l - 1 ] ; TAB1 print newline ;	int main ( ) { string s ; cin >> s ; int l = s . size ( ) ; int n = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( ! ( s [ i ] == s [ i - 1 ] && s [ i ] == ' / ' ) ) { ++ n ; cout << s [ i - 1 ] ; } } if ( s [ l - 1 ] != ' / ' || n == 0 ) cout << s [ l - 1 ] ; cout << endl ; return 0 ; } int main ( ) { string s ; cin >> s ; int l = s . size ( ) ; int n = 0 ; for ( int i = 1 ; i < l ; i ++ ) { if ( ! ( s [ i ] == s [ i - 1 ] && s [ i ] == ' / ' ) ) { ++ n ; cout << s [ i - 1 ] ; } } if ( s [ l - 1 ] != ' / ' || n == 0 ) cout << s [ l - 1 ] ; cout << endl ; return 0 ; }
TAB0 create constant integer maxn with maxn = 200005 ; TAB0 create constant integer mod with mod = 1e9 + 7 ; TAB0 create constant double eps with eps = 1e - 8 ; TAB0 create constant double PI with PI = acosign of - 1 ; TAB0 declare judge with doubles x1 , x2 , x3 , y1 , y2 , y3 as arguments , returning double ; TAB1 if x1 is x2 and y1 is y2 or x2 is x3 and y2 is y3 or x3 is x1 and y3 is y1 , return 0 from function ; TAB1 create double array a with size 3 ; TAB1 set a [ 0 ] to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; TAB1 set a [ 1 ] to ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ; TAB1 set a [ 2 ] to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; TAB1 sort elements from a to a + 3 ; TAB1 if a [ 0 ] + a [ 1 ] is a [ 2 ] , return 1 from function ; TAB0 create integer array dx with dx = { 0 , 0 , 1 , - 1 } ; TAB0 create integer array dy with dy = { 1 , - 1 , 0 , 0 } ; TAB1 create doubles x1 , x2 , x3 , y1 , y2 , y3 ; TAB1 while read x1 read y1 read x2 read y2 read x3 read y3 is true ; TAB2 if result of run judge with arguments x1 , x2 , x3 , y1 , y2 , y3 is true ; TAB3 print " RIGHT " print newline ; TAB2 else ; TAB3 create integer flag with flag = 0 ; TAB3 for i = 0 to 4 exclusive ; TAB4 create doubles xx , yy with xx = x1 + dx [ i ] , yy = y1 + dy [ i ] ; TAB4 if result of run judge with arguments xx , x2 , x3 , yy , y2 , y3 is true ; TAB5 set flag to 1 ; TAB5 print " ALMOST " print newline ; TAB5 break loop ; TAB3 if flag is true , break current loop iteration ; TAB3 for i = 0 to 4 exclusive ; TAB4 create doubles xx , yy , with xx = x2 + dx [ i ] , yy = y2 + dy [ i ] ; TAB4 if result of run judge with arguments x1 , xx , x3 , y1 , yy , y3 is true ; TAB5 set flag to 1 ; TAB5 print " ALMOST " print newline ; TAB5 break loop ; TAB3 if flag is true , break current loop iteration ; TAB3 for i = 0 to 4 exclusive ; TAB4 create double xx , yy with xx = x3 + dx [ i ] , yy = y3 + dy [ i ] ; TAB4 if result of run judge with x1 , x2 , xx , y1 , y2 , yy is true ; TAB5 set flag to 1 ; TAB5 print " ALMOST " print newline ; TAB5 break loop ; TAB3 if not flag , print " NEITHER " print newline ;	const int maxn = 200005 ; const int mod = 1e9 + 7 ; const double eps = 1e-8 ; const double PI = acos ( - 1.0 ) ; double judge ( double x1 , double x2 , double x3 , double y1 , double y2 , double y3 ) { if ( x1 == x2 && y1 == y2 || x2 == x3 && y2 == y3 || x3 == x1 && y3 == y1 ) return 0 ; double a [ 3 ] ; a [ 0 ] = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; a [ 1 ] = ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ; a [ 2 ] = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; sort ( a , a + 3 ) ; if ( a [ 0 ] + a [ 1 ] == a [ 2 ] ) return 1 ; return 0 ; } int dx [ ] = { 0 , 0 , 1 , - 1 } ; int dy [ ] = { 1 , - 1 , 0 , 0 } ; int main ( ) { double x1 , x2 , x3 , y1 , y2 , y3 ; while ( cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 ) { if ( judge ( x1 , x2 , x3 , y1 , y2 , y3 ) ) cout << " RIGHT " << endl ; else { int flag = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { double xx = x1 + dx [ i ] , yy = y1 + dy [ i ] ; if ( judge ( xx , x2 , x3 , yy , y2 , y3 ) ) { flag = 1 ; cout << " ALMOST " << endl ; break ; } } if ( flag ) continue ; for ( int i = 0 ; i < 4 ; i ++ ) { double xx = x2 + dx [ i ] , yy = y2 + dy [ i ] ; if ( judge ( x1 , xx , x3 , y1 , yy , y3 ) ) { flag = 1 ; cout << " ALMOST " << endl ; break ; } } if ( flag ) continue ; for ( int i = 0 ; i < 4 ; i ++ ) { double xx = x3 + dx [ i ] , yy = y3 + dy [ i ] ; if ( judge ( x1 , x2 , xx , y1 , y2 , yy ) ) { flag = 1 ; cout << " ALMOST " << endl ; break ; } } if ( ! flag ) cout << " NEITHER " << endl ; } } return 0 ; }
TAB1 let s be string ; TAB1 while can read input into s ; TAB2 integer sz = size of s ; TAB2 ns = empty string ; TAB2 create integer flag with value 0 ; TAB2 for i = 0 to sz exclusive ; TAB3 if s [ i ] is equal to ' / ' ; TAB4 increase flag ; TAB3 else ; TAB4 set flag to 0 ; TAB3 if flag and 0 or flag is equal to 1 increase ns by s [ i ] ; TAB2 if length of ns is equal to 1 ; TAB3 print ns and a new line ; TAB2 else if last element of ns is ' / ' ; TAB3 print ns without last symbol and a new line ; TAB2 else ; TAB3 print ns and a new line ; TAB1 create string s ; TAB1 while read s is true ; TAB2 create integer sz with sz = size of s ; TAB2 create string ns with ns = " " ; TAB2 create integer flag with flag = 0 ; TAB2 for i = 0 to sz exclusive ; TAB3 if s [ i ] is ' / ' ; TAB4 increment flag ; TAB3 else ; TAB4 set flag to 0 ; TAB3 if flag is 0 or flag is 1 , increment ns by s [ i ] ; TAB2 if size of ns is 1 ; TAB3 print ns print newline ; TAB2 else if ns [ size of ns - 1 ] is ' / ' ; TAB3 print substring of ns from 0 to size of ns - 1 , print newline ; TAB2 else ; TAB3 print ns print newline ;	int main ( ) { string s ; while ( cin >> s ) { int sz = s . size ( ) ; string ns = "  " ; int flag = 0 ; for ( int i = 0 ; i < sz ; i ++ ) { if ( s [ i ] == ' / ' ) { flag ++ ; } else { flag = 0 ; } if ( flag == 0 || flag == 1 ) { ns += s [ i ] ; } } if ( ns . size ( ) == 1 ) cout << ns << endl ; else if ( ns [ ns . size ( ) - 1 ] == ' / ' ) cout << ns . substr ( 0 , ns . size ( ) - 1 ) << endl ; else cout << ns << endl ; } return 0 ; } int main ( ) { string s ; while ( cin >> s ) { int sz = s . size ( ) ; string ns = "  " ; int flag = 0 ; for ( int i = 0 ; i < sz ; i ++ ) { if ( s [ i ] == ' / ' ) { flag ++ ; } else { flag = 0 ; } if ( flag == 0 || flag == 1 ) { ns += s [ i ] ; } } if ( ns . size ( ) == 1 ) cout << ns << endl ; else if ( ns [ ns . size ( ) - 1 ] == ' / ' ) cout << ns . substr ( 0 , ns . size ( ) - 1 ) << endl ; else cout << ns << endl ; } return 0 ; }
TAB1 declare string variable s ; TAB1 read s ; TAB1 let vv be a vector of strings ; TAB1 create integers i and j ; TAB1 n = length of s ; TAB1 str is an empty string , temp is string ; TAB1 set temp to str ; TAB1 if s [ 0 ] is equal to ' / ' ; TAB2 push " / " into vv ; TAB2 set value of i to 0 ; TAB2 for j = i to n exclusive ; TAB3 if s [ j ] ! = ' / ' , break the loop ; TAB1 set value of i to j ; TAB1 loop while i < n incrementing i ; TAB2 if s [ i ] is equal to ' / ' ; TAB3 if temp ! = str , push str into vv ; TAB3 str = " " ; TAB3 for j = i to n exclusive ; TAB4 if s [ j ] is not ' / ' , break ; TAB3 i = j - 1 ; TAB3 if i ! = n - 1 , push " / " into vv ; TAB2 else ; TAB3 increase str by s [ i ] ; TAB1 if str ! = temp , push str into vv ; TAB1 print all elements of vv one by one ; TAB1 print ' \ n ' ; TAB1 create string s ; TAB1 read s ; TAB1 create string vector vv ; TAB1 create integers i , j ; TAB1 create integer n with n = size of s ; TAB1 create strings str , temp with str = " " , ; TAB1 set temp to str ; TAB1 if s [ 0 ] is / ; TAB2 add element / to end of vv ; TAB2 set i to 0 ; TAB2 for j = i + 1 to n exclusive ; TAB3 if s [ j ] is not / , break loop ; TAB1 set i to j ; TAB1 for i to n exclusive ; TAB2 set s [ i ] to / ; TAB3 if temp is not str , add element str to end of vv ; TAB3 set str to " " ; TAB3 for j = i + 1 to n exclusive ; TAB4 if s [ j ] is not / , break loop ; TAB3 set i to j - 1 ; TAB3 if i is not n - 1 , add element / to end of vv ; TAB2 else ; TAB3 increment str by s [ i ] ; TAB1 if str is not temp , add element str to end of vv ; TAB1 for i = 0 to size of vv , print vv [ i ] ; TAB1 print \ n ;	int main ( ) { string s ; cin >> s ; vector < string > vv ; int i , j ; int n = s . size ( ) ; string str = "  " , temp ; temp = str ; if ( s [ 0 ] == ' / ' ) { vv . push_back ( " / " ) ; i = 0 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] != ' / ' ) break ; } } i = j ; for ( ; i < n ; i ++ ) { if ( s [ i ] == ' / ' ) { if ( temp != str ) vv . push_back ( str ) ; str = "  " ; for ( j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] != ' / ' ) break ; } i = j - 1 ; if ( i != n - 1 ) vv . push_back ( " / " ) ; } else { str += s [ i ] ; } } if ( str != temp ) vv . push_back ( str ) ; for ( i = 0 ; i < vv . size ( ) ; i ++ ) cout << vv [ i ] ; cout << ' \n ' ; } int main ( ) { string s ; cin >> s ; vector < string > vv ; int i , j ; int n = s . size ( ) ; string str = "  " , temp ; temp = str ; if ( s [ 0 ] == ' / ' ) { vv . push_back ( " / " ) ; i = 0 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] != ' / ' ) break ; } } i = j ; for ( ; i < n ; i ++ ) { if ( s [ i ] == ' / ' ) { if ( temp != str ) vv . push_back ( str ) ; str = "  " ; for ( j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] != ' / ' ) break ; } i = j - 1 ; if ( i != n - 1 ) vv . push_back ( " / " ) ; } else { str += s [ i ] ; } } if ( str != temp ) vv . push_back ( str ) ; for ( i = 0 ; i < vv . size ( ) ; i ++ ) cout << vv [ i ] ; cout << ' \n ' ; }
TAB0 create constant integer maxn with maxn = 200005 ; TAB0 create constant integer mod with mod = 1e9 + 7 ; TAB0 create constant double eps with eps = 1e - 8 ; TAB0 create constant double PI with PI = acosign of - 1 . 0 ; TAB0 declare judge with doubles x1 , x2 , x3 , y1 , y2 , y3 as arguments , returning double ; TAB1 if x1 is x2 and y1 is y2 or x2 is x3 and y2 is y3 or x3 is x1 and y3 is y1 , return 0 from function ; TAB1 create double array a of size 3 ; TAB1 set a [ 0 ] to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; TAB1 set a [ 1 ] to ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ; TAB1 set a [ 2 ] to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; TAB1 sort elements from a to a + 3 ; TAB1 if a [ 0 ] + a [ 1 ] is a [ 2 ] , return 1 from function ; TAB0 create integer array dx with dx = { 0 , 0 , 1 , - 1 } ; TAB0 create integer array dy with dy = { 1 , - 1 , 0 , 0 } ; TAB1 create doubles x1 , x2 , x3 , y1 , y2 , y3 ; TAB1 while read x1 read y1 read x2 read y2 read x3 read y3 is true ; TAB2 if result of run judge with x1 , x2 , x3 , y1 , y2 , y3 as arguments is true ; TAB3 print " RIGHT " print newline ; TAB2 else ; TAB3 create integer flag with flag = 0 ; TAB3 for i = 0 to 4 exclusive ; TAB4 create double xx with xx = x1 + dx [ i ] , yy = y1 + dy [ i ] ; TAB4 if result of run judge with xx , x2 , x3 , yy , y2 , y3 as arguments is true ; TAB5 set flag to 1 ; TAB5 print " ALMOST " print newline ; TAB5 break loop ; TAB3 if flag is true , break current loop iteration ; TAB3 for i = 0 to 4 exclusive ; TAB4 create doubles xx , yy with xx = x2 + dx [ i ] , yy = y2 + dy [ i ] ; TAB4 if run judge with arguments x1 , xx , x3 , y1 , yy , y3 is true ; TAB5 set flag to 1 ; TAB5 print " ALMOST " print newline ; TAB5 break loop ; TAB3 if flag is true , break current loop iteration ; TAB3 for i = 0 to 4 exclusive ; TAB4 create doubles xx , yy , with xx = x3 + dx [ i ] , yy = y3 + dy [ i ] ; TAB4 if result of run judge with arguments x1 , x2 , xx , y1 , y2 , yy is true ; TAB5 set flag to 1 ; TAB5 print " ALMOST " print newline ; TAB5 break loop ; TAB3 if not flag , print " NEITHER " print newline ;	const int maxn = 200005 ; const int mod = 1e9 + 7 ; const double eps = 1e-8 ; const double PI = acos ( - 1.0 ) ; double judge ( double x1 , double x2 , double x3 , double y1 , double y2 , double y3 ) { if ( x1 == x2 && y1 == y2 || x2 == x3 && y2 == y3 || x3 == x1 && y3 == y1 ) return 0 ; double a [ 3 ] ; a [ 0 ] = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; a [ 1 ] = ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ; a [ 2 ] = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; sort ( a , a + 3 ) ; if ( a [ 0 ] + a [ 1 ] == a [ 2 ] ) return 1 ; return 0 ; } int dx [ ] = { 0 , 0 , 1 , - 1 } ; int dy [ ] = { 1 , - 1 , 0 , 0 } ; int main ( ) { double x1 , x2 , x3 , y1 , y2 , y3 ; while ( cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 ) { if ( judge ( x1 , x2 , x3 , y1 , y2 , y3 ) ) cout << " RIGHT " << endl ; else { int flag = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { double xx = x1 + dx [ i ] , yy = y1 + dy [ i ] ; if ( judge ( xx , x2 , x3 , yy , y2 , y3 ) ) { flag = 1 ; cout << " ALMOST " << endl ; break ; } } if ( flag ) continue ; for ( int i = 0 ; i < 4 ; i ++ ) { double xx = x2 + dx [ i ] , yy = y2 + dy [ i ] ; if ( judge ( x1 , xx , x3 , y1 , yy , y3 ) ) { flag = 1 ; cout << " ALMOST " << endl ; break ; } } if ( flag ) continue ; for ( int i = 0 ; i < 4 ; i ++ ) { double xx = x3 + dx [ i ] , yy = y3 + dy [ i ] ; if ( judge ( x1 , x2 , xx , y1 , y2 , yy ) ) { flag = 1 ; cout << " ALMOST " << endl ; break ; } } if ( ! flag ) cout << " NEITHER " << endl ; } } return 0 ; }
TAB1 create constant integer size with size = 101 ; TAB1 create character array str with size size ; TAB1 read line from str to size ; TAB1 create boolean flag with flag = false ; TAB1 create character pointer start with start = str ; TAB1 create character pointer s with s = start ; TAB1 create character pointer p with p = start ; TAB1 while value of s is not ' \ 0 ' ; TAB2 if value of is is ' / ' ; TAB3 if not flag ; TAB4 set flag to true ; TAB3 else ; TAB4 increment s ; TAB4 break current loop iteration ; TAB2 else ; TAB3 set flag to false ; TAB2 set value of p to value of s ; TAB2 increment p ; TAB2 increment s ; TAB1 set value of p to ' \ 0 ' ; TAB1 create size_t len with len = string length of str ; TAB1 if len is greater than 1 and str [ len - 1 ] is ' / ' , set str [ len - 1 ] to ' \ 0 ' ; TAB1 copy string to str from start ; TAB1 print str ; TAB1 create constant integer size with value 101 ; TAB1 create char array str with size size ; TAB1 read line from the input into size ; TAB1 bool flag is false ; TAB1 char pointer start = str ; TAB1 char pointer s = start ; TAB1 char pointer p = start ; TAB1 while * s ! = ' \ 0 ' ; TAB2 if * s is equal to ' / ' ; TAB3 if flag is false ; TAB4 set value of flag to true ; TAB3 else ; TAB4 increment s ; TAB4 skip the rest of the loop ; TAB2 else ; TAB3 set flag to false ; TAB2 * p = * s ; TAB2 increment p ; TAB2 increment s ; TAB1 * p = ' \ 0 ' ; TAB1 len is size_t with value = length of str ; TAB1 if len > 1 & & str [ len - 1 ] is ' / ' , set last symbol of str to ' \ 0 ' ; TAB1 copy start to str ; TAB1 print str and a new line ;	int main ( ) { const int size = 101 ; char str [ size ] ; cin . getline ( str , size ) ; bool flag = false ; char * start = str ; char * s = start ; char * p = start ; while ( * s != ' \0 ' ) { if ( * s == ' / ' ) { if ( ! flag ) { flag = true ; } else { s ++ ; continue ; } } else { flag = false ; } * p = * s ; p ++ ; s ++ ; } * p = ' \0 ' ; size_t len = strlen ( str ) ; if ( len > 1 && str [ len - 1 ] == ' / ' ) { str [ len - 1 ] = ' \0 ' ; } strcpy ( str , start ) ; puts ( str ) ; return 0 ; } int main ( ) { const int size = 101 ; char str [ size ] ; cin . getline ( str , size ) ; bool flag = false ; char * start = str ; char * s = start ; char * p = start ; while ( * s != ' \0 ' ) { if ( * s == ' / ' ) { if ( ! flag ) { flag = true ; } else { s ++ ; continue ; } } else { flag = false ; } * p = * s ; p ++ ; s ++ ; } * p = ' \0 ' ; size_t len = strlen ( str ) ; if ( len > 1 && str [ len - 1 ] == ' / ' ) { str [ len - 1 ] = ' \0 ' ; } strcpy ( str , start ) ; puts ( str ) ; return 0 ; }
TAB0 create integers l1 , l2 , l3 ; TAB0 create integer arrays a , b , c , d , with a size 5 , b size 5 , c size 5 , d size 5 , create integers j , i ; TAB0 create integer array dix with dix = { 1 , 0 , - 1 , 0 } ; TAB0 create integer array diy with diy = { 0 , 1 , 0 , - 1 } ; TAB1 for i = 1 to 3 inclusive , read a [ i ] read b [ i ] ; TAB1 set l1 to abs ( a [ 1 ] - a [ 2 ] ) * abs ( a [ 1 ] - a [ 2 ] ) + abs ( b [ 1 ] - b [ 2 ] ) * abs ( b [ 1 ] - b [ 2 ] ) ; TAB1 set l2 to abs ( a [ 2 ] - a [ 3 ] ) * abs ( a [ 2 ] - a [ 3 ] ) + abs ( b [ 2 ] - b [ 3 ] ) * abs ( b [ 2 ] - b [ 3 ] ) ; TAB1 set l3 to abs ( a [ 3 ] - a [ 1 ] ) * abs ( a [ 3 ] - a [ 1 ] ) + abs ( b [ 3 ] - b [ 1 ] ) * abs ( b [ 3 ] - b [ 1 ] ) ; TAB1 if l1 + l2 is l3 or l1 + l3 is l2 or l2 + l3 is l1 ; TAB2 if l1 is not 0 and l2 is not 0 and l3 is not 0 ; TAB3 print " RIGHT " print newline ; TAB1 for i = 1 to 3 inclusive ; TAB2 set c [ 1 ] to a [ 1 ] , set c [ 2 ] to a [ 2 ] , set c [ 3 ] to a [ 3 ] ; TAB2 set d [ 1 ] to b [ 1 ] , set d [ 2 ] to b [ 2 ] , set d [ 3 ] to b [ 3 ] ; TAB2 for j = 0 to 4 exclusive ; TAB3 set c [ i ] to a [ i ] + dix [ j ] ; TAB3 set d [ i ] to b [ i ] + diy [ j ] ; TAB3 set l1 to abs ( c [ 1 ] - c [ 2 ] ) * abs ( c [ 1 ] - c [ 2 ] ) + abs ( d [ 1 ] - d [ 2 ] ) * abs ( d [ 1 ] - d [ 2 ] ) ; TAB3 set l2 to abs ( c [ 2 ] - c [ 3 ] ) * abs ( c [ 2 ] - c [ 3 ] ) + abs ( d [ 2 ] - d [ 3 ] ) * abs ( d [ 2 ] - d [ 3 ] ) ; TAB3 set l3 to abs ( c [ 3 ] - c [ 1 ] ) * abs ( c [ 3 ] - c [ 1 ] ) + abs ( d [ 3 ] - d [ 1 ] ) * abs ( d [ 3 ] - d [ 1 ] ) ; TAB3 if l1 + l2 is l3 or l1 + l3 is l2 or l2 + l3 is l1 ; TAB4 if l1 is not 0 and l2 is not 0 and l3 is not 0 ; TAB5 print " ALMOST " print newline ; TAB1 print " NEITHER " print newline ;	int l1 , l2 , l3 ; int a [ 5 ] , b [ 5 ] , c [ 5 ] , d [ 5 ] , j , i ; int dix [ ] = { 1 , 0 , - 1 , 0 } ; int diy [ ] = { 0 , 1 , 0 , - 1 } ; int main ( ) { for ( i = 1 ; i <= 3 ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } l1 = abs ( a [ 1 ] - a [ 2 ] ) * abs ( a [ 1 ] - a [ 2 ] ) + abs ( b [ 1 ] - b [ 2 ] ) * abs ( b [ 1 ] - b [ 2 ] ) ; l2 = abs ( a [ 2 ] - a [ 3 ] ) * abs ( a [ 2 ] - a [ 3 ] ) + abs ( b [ 2 ] - b [ 3 ] ) * abs ( b [ 2 ] - b [ 3 ] ) ; l3 = abs ( a [ 3 ] - a [ 1 ] ) * abs ( a [ 3 ] - a [ 1 ] ) + abs ( b [ 3 ] - b [ 1 ] ) * abs ( b [ 3 ] - b [ 1 ] ) ; if ( l1 + l2 == l3 || l1 + l3 == l2 || l2 + l3 == l1 ) { if ( l1 != 0 && l2 != 0 && l3 != 0 ) { cout << " RIGHT " << endl ; return 0 ; } } for ( i = 1 ; i <= 3 ; i ++ ) { c [ 1 ] = a [ 1 ] , c [ 2 ] = a [ 2 ] , c [ 3 ] = a [ 3 ] ; d [ 1 ] = b [ 1 ] , d [ 2 ] = b [ 2 ] , d [ 3 ] = b [ 3 ] ; for ( j = 0 ; j < 4 ; j ++ ) { c [ i ] = a [ i ] + dix [ j ] ; d [ i ] = b [ i ] + diy [ j ] ; l1 = abs ( c [ 1 ] - c [ 2 ] ) * abs ( c [ 1 ] - c [ 2 ] ) + abs ( d [ 1 ] - d [ 2 ] ) * abs ( d [ 1 ] - d [ 2 ] ) ; l2 = abs ( c [ 2 ] - c [ 3 ] ) * abs ( c [ 2 ] - c [ 3 ] ) + abs ( d [ 2 ] - d [ 3 ] ) * abs ( d [ 2 ] - d [ 3 ] ) ; l3 = abs ( c [ 3 ] - c [ 1 ] ) * abs ( c [ 3 ] - c [ 1 ] ) + abs ( d [ 3 ] - d [ 1 ] ) * abs ( d [ 3 ] - d [ 1 ] ) ; if ( l1 + l2 == l3 || l1 + l3 == l2 || l2 + l3 == l1 ) { if ( l1 != 0 && l2 != 0 && l3 != 0 ) { cout << " ALMOST " << endl ; return 0 ; } } } } cout << " NEITHER " << endl ; }
TAB1 create constant integer size with value 101 ; TAB1 str = array of characters of length size ; TAB1 read line of length size to str ; TAB1 set boolean flag to false ; TAB1 * start is a char pointer to str ; TAB1 * s is a char pointer to start ; TAB1 * p is a char pointer to start ; TAB1 while value at s ! = ' \ 0 ' ; TAB2 if value at s is equal to ' / ' ; TAB3 if flag is false ; TAB4 assign value of true to the flag ; TAB3 else ; TAB4 increase s by one ; TAB4 skip the rest of the loop ; TAB2 else ; TAB3 set flag to false ; TAB2 * p = * s ; TAB2 increase p ; TAB2 increase s ; TAB1 * p = ' \ 0 ' ; TAB1 len is size_t with value equal to length of str ; TAB1 if len > 1 and str [ len - 1 ] is equal to ' / ' , set str at len - 1 to ' \ 0 ' ; TAB1 print start ; TAB1 create constant integer size with size = 101 ; TAB1 create character array str of size size ; TAB1 read line into str with maximum size size ; TAB1 create boolean flag with flag = false ; TAB1 create character pointer start with start = str ; TAB1 create character pointer s with s = start ; TAB1 create character pointer p with p = start ; TAB1 while value of s is not \ 0 ; TAB2 if value of s is not / ; TAB3 if not flag ; TAB4 set flag to true ; TAB3 else ; TAB4 increment s ; TAB4 break current loop iteration ; TAB2 else ; TAB3 set flag to false ; TAB2 set value of p to value of s ; TAB2 increment p ; TAB2 increment s ; TAB1 set value of p to \ 0 ; TAB1 create size_t len with len = string length of str ; TAB1 if len is greater than 1 and str [ len - 1 ] is / , set str [ len - 1 ] to \ 0 ; TAB1 print start ;	int main ( ) { const int size = 101 ; char str [ size ] ; cin . getline ( str , size ) ; bool flag = false ; char * start = str ; char * s = start ; char * p = start ; while ( * s != ' \0 ' ) { if ( * s == ' / ' ) { if ( ! flag ) { flag = true ; } else { s ++ ; continue ; } } else { flag = false ; } * p = * s ; p ++ ; s ++ ; } * p = ' \0 ' ; size_t len = strlen ( str ) ; if ( len > 1 && str [ len - 1 ] == ' / ' ) { str [ len - 1 ] = ' \0 ' ; } puts ( start ) ; return 0 ; } int main ( ) { const int size = 101 ; char str [ size ] ; cin . getline ( str , size ) ; bool flag = false ; char * start = str ; char * s = start ; char * p = start ; while ( * s != ' \0 ' ) { if ( * s == ' / ' ) { if ( ! flag ) { flag = true ; } else { s ++ ; continue ; } } else { flag = false ; } * p = * s ; p ++ ; s ++ ; } * p = ' \0 ' ; size_t len = strlen ( str ) ; if ( len > 1 && str [ len - 1 ] == ' / ' ) { str [ len - 1 ] = ' \0 ' ; } puts ( start ) ; return 0 ; }
TAB0 d = array of integers of size 6 ; TAB0 define function sqr with argument n ; TAB1 return n * n ; TAB0 define function check with string argument s ; TAB1 a , b and c = integers ; TAB1 a = sqr ( d [ 0 ] - d [ 2 ] ) + sqr ( d [ 1 ] - d [ 3 ] ) ; TAB1 b = sqr ( d [ 0 ] - d [ 4 ] ) + sqr ( d [ 1 ] - d [ 5 ] ) ; TAB1 c = sqr ( d [ 2 ] - d [ 4 ] ) + sqr ( d [ 3 ] - d [ 5 ] ) ; TAB1 if ( a , b and c ) are equal to 0 , return ; TAB1 if a + b = c or a + c = b or b + c is equal to a ; TAB2 print s ; TAB2 call exit ( 0 ) ; TAB1 let i be integer ; TAB1 read 6 value into d ; TAB1 call function check with argument " RIGHT \ n " ; TAB1 for i = 0 to 6 exclusive ; TAB2 decrease d [ i ] by one ; TAB2 call function check with argument " ALMOST \ n " ; TAB2 increase d [ i ] by 2 ; TAB2 call function check with argument " ALMOST \ n " ; TAB2 decrease d [ i ] ; TAB1 print " NEITHER \ n " ; TAB0 create integer array d with size 6 ; TAB0 declare sqr with integer n as argument , returning integer ; TAB1 return n * n from function ; TAB0 declare check with string s as argument , return void ; TAB1 create integers a , b , c ; TAB1 set a to result of run sqr with d [ 0 ] - d [ 2 ] as arguments + result of run sqr with d [ 1 ] - d [ 3 ] as arguments ; TAB1 set b to result of run sqr with d [ 0 ] - d [ 4 ] as arguments + result of run sqr with d [ 1 ] - d [ 5 ] as arguments ; TAB1 set c to result of run sqr with d [ 2 ] - d [ 4 ] as arguments + result of run sqr with d [ 3 ] - d [ 5 ] as arguments ; TAB1 if a and b and c is 0 , return from function ; TAB1 if a + b is c or a + c is b or b + c is a ; TAB2 print s ; TAB2 exit program with code 0 ; TAB1 create integer i ; TAB1 for i = 0 to 6 exclusive , read d [ i ] ; TAB1 run check with " RIGHT \ n " as argument ; TAB1 for i = 0 to 6 exclusive ; TAB2 decrement d [ i ] ; TAB2 run check with " ALMOST \ n " as argument ; TAB2 increment d [ i ] by 2 ; TAB2 run check with " ALMOST \ n " as argument ; TAB2 decrement d [ i ] ; TAB1 print " NEITHER \ n " ;	int d [ 6 ] ; int sqr ( int n ) { return n * n ; } void check ( string s ) { int a , b , c ; a = sqr ( d [ 0 ] - d [ 2 ] ) + sqr ( d [ 1 ] - d [ 3 ] ) ; b = sqr ( d [ 0 ] - d [ 4 ] ) + sqr ( d [ 1 ] - d [ 5 ] ) ; c = sqr ( d [ 2 ] - d [ 4 ] ) + sqr ( d [ 3 ] - d [ 5 ] ) ; if ( ( a && b && c ) == 0 ) return ; if ( a + b == c || a + c == b || b + c == a ) { cout << s ; exit ( 0 ) ; } } int main ( ) { int i ; for ( i = 0 ; i < 6 ; i ++ ) { cin >> d [ i ] ; } check ( " RIGHT\n " ) ; for ( i = 0 ; i < 6 ; i ++ ) { d [ i ] -- ; check ( " ALMOST\n " ) ; d [ i ] += 2 ; check ( " ALMOST\n " ) ; d [ i ] -- ; } cout << " NEITHER\n " ; return 0 ; } int d [ 6 ] ; int sqr ( int n ) { return n * n ; } void check ( string s ) { int a , b , c ; a = sqr ( d [ 0 ] - d [ 2 ] ) + sqr ( d [ 1 ] - d [ 3 ] ) ; b = sqr ( d [ 0 ] - d [ 4 ] ) + sqr ( d [ 1 ] - d [ 5 ] ) ; c = sqr ( d [ 2 ] - d [ 4 ] ) + sqr ( d [ 3 ] - d [ 5 ] ) ; if ( ( a && b && c ) == 0 ) return ; if ( a + b == c || a + c == b || b + c == a ) { cout << s ; exit ( 0 ) ; } } int main ( ) { int i ; for ( i = 0 ; i < 6 ; i ++ ) { cin >> d [ i ] ; } check ( " RIGHT\n " ) ; for ( i = 0 ; i < 6 ; i ++ ) { d [ i ] -- ; check ( " ALMOST\n " ) ; d [ i ] += 2 ; check ( " ALMOST\n " ) ; d [ i ] -- ; } cout << " NEITHER\n " ; return 0 ; }
TAB0 declare check with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , returning boolean ; TAB1 if ( x1 is x2 and y1 is y2 ) or ( x1 is x3 and y1 is y3 ) or ( x3 is x2 and y3 is y2 ) return false from function ; TAB1 if ( y2 - y1 ) * ( y3 - y2 ) is ( x1 - x2 ) * ( x3 - x2 ) return true from function ; TAB1 if ( y3 - y2 ) * ( y1 - y3 ) is ( x2 - x3 ) * ( x1 - x3 ) return true from function ; TAB1 if ( y1 - y3 ) * ( y2 - y1 ) is ( x3 - x1 ) * ( x2 - x1 ) return true from function ; TAB1 return false from function ; TAB1 create integers x1 , y1 , x2 , y2 , x3 , y3 ; TAB1 read x1 read y1 read x2 read y2 read x3 read y3 ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 , x3 , y3 is true ; TAB2 print " RIGHT " print newline ; TAB1 if result of run check with arguments x1 - 1 , y1 , x2 , y2 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 + 1 , y1 , x2 , y2 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 - 1 , x2 , y2 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 + 1 , x2 , y2 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 - 1 , y2 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 + 1 , y2 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 - 1 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 + 1 , x3 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 , x3 - 1 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 , x3 + 1 , y3 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 , x3 , y3 - 1 is true ; TAB2 print " ALMOST " print newline ; TAB1 if result of run check with arguments x1 , y1 , x2 , y2 , x3 , y3 + 1 is true ; TAB2 print " ALMOST " print newline ; TAB1 print " NEITHER " print newline ;	bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( x1 == x2 && y1 == y2 ) || ( x1 == x3 && y1 == y3 ) || ( x3 == x2 && y3 == y2 ) ) return false ; if ( ( y2 - y1 ) * ( y3 - y2 ) == ( ( x1 - x2 ) * ( x3 - x2 ) ) ) return true ; if ( ( y3 - y2 ) * ( y1 - y3 ) == ( ( x2 - x3 ) * ( x1 - x3 ) ) ) return true ; if ( ( y1 - y3 ) * ( y2 - y1 ) == ( ( x3 - x1 ) * ( x2 - x1 ) ) ) return true ; return false ; } int main ( ) { int x1 , y1 , x2 , y2 , x3 , y3 ; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 ; if ( check ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " RIGHT " << endl ; return 0 ; } if ( check ( x1 - 1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 + 1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 - 1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 + 1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 - 1 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 + 1 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 , y2 - 1 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 , y2 + 1 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 , y2 , x3 - 1 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 , y2 , x3 + 1 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 , y2 , x3 , y3 - 1 ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( check ( x1 , y1 , x2 , y2 , x3 , y3 + 1 ) ) { cout << " ALMOST " << endl ; return 0 ; } cout << " NEITHER " << endl ; return 0 ; }
TAB0 declare check with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , returning boolean ; TAB1 create integers a , b , c ; TAB1 set a to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; TAB1 set b to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; TAB1 set c to ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 ) ; TAB1 if a is 0 or b is 0 or c is 0 , return 0 from function ; TAB1 if a + b is c or a + c is b or b + c is a ; TAB2 return 1 from function ; TAB1 else ; TAB1 create 2d integer array move of size 4 by 2 , with move = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; TAB1 create integer arrays x1 , y1 with x1 size 4 , y1 size 4 ; TAB1 for i = 0 to 3 exclusive , read x1 [ i ] read y1 [ i ] ; TAB1 if result of run check with x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] as arguments is true ; TAB2 print " RIGHT " print newline ; TAB1 create integers tx , ty ; TAB1 for i = 0 to 3 inclusive ; TAB2 for j = 0 to 3 inclusive ; TAB3 set tx to x1 [ i ] + move [ j ] [ 0 ] ; TAB3 set ty to y1 [ i ] + move [ j ] [ 1 ] ; TAB3 if i is 0 and result of run check with tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] as arguments is true ; TAB4 print " ALMOST " print newline ; TAB3 if i is 1 and result of run check with x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] as arguments is true ; TAB4 print " ALMOST " print newline ; TAB3 if i is 2 and result of run check with x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty as arguments is true ; TAB4 print " ALMOST " print newline ; TAB2 if i is 3 print " NEITHER " print newline ; TAB0 bool function check wih integer arguments x1 , y1 , x2 , y2 , x3 and y3 ; TAB1 a , b and c = integers ; TAB1 set value of a to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; TAB1 b = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; TAB1 c = ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 ) ; TAB1 if a = = 0 or b = = 0 or c is equal to 0 return 0 ; TAB1 if a + b = c or a + c = b or b + c = a ; TAB2 return 1 ; TAB1 else ; TAB1 move = 2d array of integers with values { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; TAB1 x1 and y1 = arrays of integers of size 4 ; TAB1 read 3 values into x1 and y1 ; TAB1 if check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) returns true ; TAB2 print " RIGHT " and a new line ; TAB1 let tx and ty be integers ; TAB1 for i = 0 to 3 inclusive ; TAB2 for integer j = 0 to 3 inclusive ; TAB3 set tx to x1 [ i ] + move [ j ] [ 0 ] ; TAB3 set ty to y1 [ i ] + move [ j ] [ 1 ] ; TAB3 if i is equal to 0 and check ( tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) returns true ; TAB4 print " ALMOST " and a new line ; TAB3 if i is equal to 1 & & check ( x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] ) is true ; TAB4 print " ALMOST " and a new line ; TAB3 if i is equal to 2 & & check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty ) is true ; TAB4 print " ALMOST " and a new line ; TAB2 if i is equal to 3 print " NEITHER " and a new line ;	bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a , b , c ; a = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; b = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; c = ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 ) ; if ( a == 0 || b == 0 || c == 0 ) return 0 ; if ( a + b == c || a + c == b || b + c == a ) return 1 ; else return 0 ; } int main ( ) { int move [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int x1 [ 4 ] , y1 [ 4 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { cin >> x1 [ i ] >> y1 [ i ] ; } if ( check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " RIGHT " << endl ; return 0 ; } int tx , ty ; for ( int i = 0 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= 3 ; j ++ ) { tx = x1 [ i ] + move [ j ] [ 0 ] ; ty = y1 [ i ] + move [ j ] [ 1 ] ; if ( i == 0 && check ( tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( i == 1 && check ( x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( i == 2 && check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty ) ) { cout << " ALMOST " << endl ; return 0 ; } } if ( i == 3 ) cout << " NEITHER " << endl ; } return 0 ; } bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a , b , c ; a = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; b = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; c = ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 ) ; if ( a == 0 || b == 0 || c == 0 ) return 0 ; if ( a + b == c || a + c == b || b + c == a ) return 1 ; else return 0 ; } int main ( ) { int move [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int x1 [ 4 ] , y1 [ 4 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { cin >> x1 [ i ] >> y1 [ i ] ; } if ( check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " RIGHT " << endl ; return 0 ; } int tx , ty ; for ( int i = 0 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= 3 ; j ++ ) { tx = x1 [ i ] + move [ j ] [ 0 ] ; ty = y1 [ i ] + move [ j ] [ 1 ] ; if ( i == 0 && check ( tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( i == 1 && check ( x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( i == 2 && check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty ) ) { cout << " ALMOST " << endl ; return 0 ; } } if ( i == 3 ) cout << " NEITHER " << endl ; } return 0 ; }
TAB0 declare right_tri with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , return boolean ; TAB1 create integer a with a = ( ( x3 - x1 ) * ( x3 - x1 ) ) + ( ( y3 - y1 ) * ( y3 - y1 ) ) ; TAB1 create integer b with b = ( ( x2 - x1 ) * ( x2 - x1 ) ) + ( ( y2 - y1 ) * ( y2 - y1 ) ) ; TAB1 create integer c with c = ( ( x3 - x2 ) * ( x3 - x2 ) ) + ( ( y3 - y2 ) * ( y3 - y2 ) ) ; TAB1 create integer vector temp ; TAB1 add element a to end of temp , add element b to end of temp , add element c to end of temp ; TAB1 sort elements from reverse beginning of temp to reverse ending of temp ; TAB1 if temp [ 2 ] is 0 , return false from function ; TAB1 if temp [ 1 ] + temp [ 2 ] is temp [ 0 ] , return true from function ; TAB1 return false from function ; TAB1 create integer vector a initialized with 6 ; TAB1 for i = 0 to 6 exclusive , read a [ i ] ; TAB1 if result of run right_tri with arguments a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] is true ; TAB2 print " RIGHT " print newline ; TAB1 for i = 0 to 6 exclusive ; TAB2 for j = 0 to 2 exclusive ; TAB3 create integer offset with offset = - 1 if j is 0 , else 1 ; TAB3 increment a [ i ] by offset ; TAB3 if result of run right_tri with a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] as arguments is true ; TAB4 print " ALMOST " print newline ; TAB3 decrement a [ i ] by offset ; TAB1 print " NEITHER " print newline ; TAB0 bollean function right_tri with int arguments x1 , y1 , x2 , y2 , x3 and y3 ; TAB1 a = ( ( x3 - x1 ) * ( x3 - x1 ) ) + ( ( y3 - y1 ) * ( y3 - y1 ) ) ; TAB1 b = ( ( x2 - x1 ) * ( x2 - x1 ) ) + ( ( y2 - y1 ) * ( y2 - y1 ) ) ; TAB1 c = ( ( x3 - x2 ) * ( x3 - x2 ) ) + ( ( y3 - y2 ) * ( y3 - y2 ) ) ; TAB1 temp = vector of integers ; TAB1 push a , b and c into temp ; TAB1 sort temp ; TAB1 if temp [ 2 ] is equal to 0 , return false ; TAB1 if temp [ 1 ] + temp [ 2 ] is equal to temp [ 0 ] , return true ; TAB1 return false ; TAB1 a = vector of integers of size 6 ; TAB1 read 6 values into a ; TAB1 if right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) is true ; TAB2 print " RIGHT " and a new line ; TAB1 for i = 0 to 6 exclusive ; TAB2 for integer j = 0 to 2 exclusive ; TAB3 offset = - 1 if j is 0 and 1 otherwise ; TAB3 increase a [ i ] by offset ; TAB3 if right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) is true ; TAB4 print " ALMOST " and a new line ; TAB3 decrease a [ i ] by offset ; TAB1 print " NEITHER " and a new line ;	bool right_tri ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = ( ( x3 - x1 ) * ( x3 - x1 ) ) + ( ( y3 - y1 ) * ( y3 - y1 ) ) ; int b = ( ( x2 - x1 ) * ( x2 - x1 ) ) + ( ( y2 - y1 ) * ( y2 - y1 ) ) ; int c = ( ( x3 - x2 ) * ( x3 - x2 ) ) + ( ( y3 - y2 ) * ( y3 - y2 ) ) ; vector < int > temp ; temp . push_back ( a ) , temp . push_back ( b ) , temp . push_back ( c ) ; sort ( temp . rbegin ( ) , temp . rend ( ) ) ; if ( temp [ 2 ] == 0 ) return false ; if ( temp [ 1 ] + temp [ 2 ] == temp [ 0 ] ) return true ; return false ; } int main ( ) { vector < int > a ( 6 ) ; for ( int i = 0 ; i < 6 ; i ++ ) cin >> a [ i ] ; if ( right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) == true ) { cout << " RIGHT " << endl ; return 0 ; } for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { int offset = ( j == 0 ) ? ( - 1 ) : ( 1 ) ; a [ i ] += offset ; if ( right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) == true ) { cout << " ALMOST " << endl ; return 0 ; } a [ i ] -= offset ; } } cout << " NEITHER " << endl ; } bool right_tri ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = ( ( x3 - x1 ) * ( x3 - x1 ) ) + ( ( y3 - y1 ) * ( y3 - y1 ) ) ; int b = ( ( x2 - x1 ) * ( x2 - x1 ) ) + ( ( y2 - y1 ) * ( y2 - y1 ) ) ; int c = ( ( x3 - x2 ) * ( x3 - x2 ) ) + ( ( y3 - y2 ) * ( y3 - y2 ) ) ; vector < int > temp ; temp . push_back ( a ) , temp . push_back ( b ) , temp . push_back ( c ) ; sort ( temp . rbegin ( ) , temp . rend ( ) ) ; if ( temp [ 2 ] == 0 ) return false ; if ( temp [ 1 ] + temp [ 2 ] == temp [ 0 ] ) return true ; return false ; } int main ( ) { vector < int > a ( 6 ) ; for ( int i = 0 ; i < 6 ; i ++ ) cin >> a [ i ] ; if ( right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) == true ) { cout << " RIGHT " << endl ; return 0 ; } for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { int offset = ( j == 0 ) ? ( - 1 ) : ( 1 ) ; a [ i ] += offset ; if ( right_tri ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] ) == true ) { cout << " ALMOST " << endl ; return 0 ; } a [ i ] -= offset ; } } cout << " NEITHER " << endl ; }
TAB0 create character array s of size 100005 ; TAB0 create character array revs of size 100005 ; TAB0 create integers ln , ln1 , ln2 ; TAB0 create character array str of size 100005 ; TAB0 create character array src1 of size 100005 ; TAB0 create character array src2 of size 100005 ; TAB0 create booleans flag1 , flag2 ; TAB1 read line into s with maximum size of 100005 ; TAB1 set ln to string length of s ; TAB1 for i = 0 to ln exclusive , set revs [ i ] to s [ ln - i - 1 ] ; TAB1 read line into src1 with maximum size of 100005 ; TAB1 read line into src2 with maximum size of 100005 ; TAB1 set ln1 to string length of src1 ; TAB1 set ln2 to string length of src2 ; TAB1 create character pointer p with p = pointer to first occurrence of string src1 in s ; TAB1 if p is true ; TAB2 create character pointer p2 with p2 = pointer to first occurrence of src2 in p + ln1 ; TAB2 if p2 is true , set flag1 to true ; TAB1 set p to first occurrence of string src1 in revs ; TAB1 if p is true ; TAB2 create character pointer p2 with p2 = first occurrence of src2 in p + ln1 ; TAB2 if p2 is true set flag2 to true ; TAB1 if flag1 and flag2 ; TAB2 print " both \ n " ; TAB1 else if flag1 ; TAB2 print " forward \ n " ; TAB1 else if flag2 ; TAB2 print " backward \ n " ; TAB1 else ; TAB2 print " fantasy \ n " ;	char s [ 100005 ] ; char revs [ 100005 ] ; int ln , ln1 , ln2 ; char str [ 100005 ] ; char src1 [ 100005 ] ; char src2 [ 100005 ] ; bool flag1 , flag2 ; int main ( ) { cin . getline ( s , 100005 ) ; ln = strlen ( s ) ; for ( int i = 0 ; i < ln ; ++ i ) { revs [ i ] = s [ ln - i - 1 ] ; } cin . getline ( src1 , 100005 ) ; cin . getline ( src2 , 100005 ) ; ln1 = strlen ( src1 ) ; ln2 = strlen ( src2 ) ; char * p = strstr ( s , src1 ) ; if ( p ) { char * p2 = strstr ( p + ln1 , src2 ) ; if ( p2 ) { flag1 = true ; } } p = strstr ( revs , src1 ) ; if ( p ) { char * p2 = strstr ( p + ln1 , src2 ) ; if ( p2 ) { flag2 = true ; } } if ( flag1 && flag2 ) { cout << " both\n " ; } else if ( flag1 ) { cout << " forward\n " ; } else if ( flag2 ) { cout << " backward\n " ; } else { cout << " fantasy\n " ; } return 0 ; }
TAB1 create strings s , a , b ; TAB1 read s read a read b ; TAB2 create boolean array isok with size 2 , with isok = { 0 , 0 } ; TAB2 for i = 0 to 2 exclusive ; TAB3 create integer idx with idx = first index of a in s ; TAB3 if idx is not end of string ; TAB4 set idx to first index of b starting at idx + size of a in s ; TAB4 if idx is not end of string , set isok [ i ] to 1 ; TAB3 reverse element order from beginning of s to end of s ; TAB2 if isok [ 0 ] and isok [ 1 ] ; TAB3 print " both " print newline ; TAB2 else if isok [ 0 ] ; TAB3 print " forward " print newline ; TAB2 else if isok [ 1 ] ; TAB3 print " backward " print newline ; TAB2 else ; TAB3 print " fantasy " print newline ; TAB1 s , a and b = strings ; TAB1 while can read s , a and b ; TAB2 isok = array of boolean of size 2 initialized with 0 ; TAB2 for integer i = 0 to 2 exclusive ; TAB3 idx = index of a in s ; TAB3 if idx ! = string : : npos ; TAB4 set idx to index of b in s looking from idx + length of a ; TAB4 if idx ! = string : : npos ; TAB3 reverse s ; TAB2 if isok [ 0 ] and isok [ 1 ] are both true ; TAB3 print " both " and a new line ; TAB2 else if isok [ 0 ] is true ; TAB3 print " forward " and a new line ; TAB2 else if isok [ 1 ] is true ; TAB3 print " backward " and a new line ; TAB2 else ; TAB3 print " fantasy " and a new line ;	int main ( ) { string s , a , b ; while ( cin >> s >> a >> b ) { bool isok [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < 2 ; i ++ ) { int idx = s . find ( a ) ; if ( idx != string :: npos ) { idx = s . find ( b , idx + a . size ( ) ) ; if ( idx != string :: npos ) isok [ i ] = 1 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } if ( isok [ 0 ] && isok [ 1 ] ) cout << " both " << endl ; else if ( isok [ 0 ] ) cout << " forward " << endl ; else if ( isok [ 1 ] ) cout << " backward " << endl ; else cout << " fantasy " << endl ; } return 0 ; } int main ( ) { string s , a , b ; while ( cin >> s >> a >> b ) { bool isok [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < 2 ; i ++ ) { int idx = s . find ( a ) ; if ( idx != string :: npos ) { idx = s . find ( b , idx + a . size ( ) ) ; if ( idx != string :: npos ) isok [ i ] = 1 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } if ( isok [ 0 ] && isok [ 1 ] ) cout << " both " << endl ; else if ( isok [ 0 ] ) cout << " forward " << endl ; else if ( isok [ 1 ] ) cout << " backward " << endl ; else cout << " fantasy " << endl ; } return 0 ; }
TAB1 create strings s , a and b ; TAB1 declare booleans atob and btoa = false ; TAB1 read s , a and b ; TAB1 pos = position of a in s ; TAB1 if pos ! = - 1 and b can be found in s after pos , set atob to true ; TAB1 reverse s ; TAB1 pos = position of a in s ; TAB1 if pos ! = - 1 and b can be found in s after pos , set btoa to true ; TAB1 if atob and btoa are both true ; TAB2 print " both " and a new line ; TAB1 else if atob is true ; TAB2 print " forward " and a new line ; TAB1 else if btoa is true ; TAB2 print " backward " and a new line ; TAB1 else ; TAB2 print " fantasy " and a new line ; TAB1 create strings s , a , b ; TAB1 create booleans atob , btoa with atob = false , btoa = false ; TAB1 read s read a read b ; TAB1 create integer pos with pos = first index of a in s ; TAB1 if pos is not - 1 and integer casted first index of b in s from pos + length of a is not - 1 , set atob to true ; TAB1 reverse order from beginning of s to end of s ; TAB1 set pos to first index of a in s ; TAB1 if pos is not - 1 and integer casted first index of b in s from pos + length of a is not - 1 , set btoa to true ; TAB1 if atob and btoa ; TAB2 print " both " print newline ; TAB1 else if atob ; TAB2 print " forward " print newline ; TAB1 else if btoa ; TAB2 print " backward " print newline ; TAB1 else ; TAB2 print " fantasy " print newline ;	int main ( ) { string s , a , b ; bool atob = false , btoa = false ; cin >> s >> a >> b ; int pos = s . find ( a ) ; if ( pos != - 1 && ( int ) s . find ( b , pos + a . length ( ) ) != - 1 ) atob = true ; reverse ( s . begin ( ) , s . end ( ) ) ; pos = s . find ( a ) ; if ( pos != - 1 && ( int ) s . find ( b , pos + a . length ( ) ) != - 1 ) btoa = true ; if ( atob && btoa ) cout << " both " << endl ; else if ( atob ) cout << " forward " << endl ; else if ( btoa ) cout << " backward " << endl ; else cout << " fantasy " << endl ; return 0 ; } int main ( ) { string s , a , b ; bool atob = false , btoa = false ; cin >> s >> a >> b ; int pos = s . find ( a ) ; if ( pos != - 1 && ( int ) s . find ( b , pos + a . length ( ) ) != - 1 ) atob = true ; reverse ( s . begin ( ) , s . end ( ) ) ; pos = s . find ( a ) ; if ( pos != - 1 && ( int ) s . find ( b , pos + a . length ( ) ) != - 1 ) btoa = true ; if ( atob && btoa ) cout << " both " << endl ; else if ( atob ) cout << " forward " << endl ; else if ( btoa ) cout << " backward " << endl ; else cout << " fantasy " << endl ; return 0 ; }
TAB0 double constant PI = acos ( - 1 . 0 ) ; TAB0 set constant integer INF to 1000 * 1000 * 1000 + 7 ; TAB0 long long constant LINF = INF * INF casted to long long ; TAB0 set constant integer MAX to 1000 + 7 ; TAB0 declare strings called s , a and b ; TAB0 method can ; TAB1 integer p1 = - 1 ; TAB1 for integer i from 0 to length of s exclusive ; TAB2 set boolean ok to true ; TAB2 for j = 0 to length of a exclusive ; TAB3 if i + j is > = length of s or s [ i + j ] ! = a [ j ] ; TAB4 set ok = false ; TAB4 stop the loop ; TAB2 if ok is true ; TAB3 set p1 to i ; TAB3 break the loop ; TAB1 return false if p1 is equal to - 1 ; TAB1 set p2 to - 1 ; TAB1 for i = length of s - 1 to 0 inclusive decrementing i by one ; TAB2 set ok to true ; TAB2 for j = 0 to size of b ; TAB3 if i + j is > = length of s or s [ i + j ] ! = b [ j ] ; TAB4 set ok to false ; TAB4 break the loop ; TAB2 if ok is true ; TAB3 set p2 to i ; TAB3 break the loop ; TAB1 if ( p1 + length of a - 1 ) is less than p2 return true ; TAB1 return false ; TAB1 read s , a and b ; TAB1 let boolen forward = result of can ( ) ; TAB1 reverse s ; TAB1 boolean backward = can ( ) ; TAB1 if forward and backward are both true ; TAB2 print " both " and a new line ; TAB1 if forward is true ; TAB2 print " forward " and a new line ; TAB1 if backward is true ; TAB2 print " backward " and a new line ; TAB1 print " fantasy " and a new line ;	const double PI = acos ( - 1.0 ) ; const int INF = 1000 * 1000 * 1000 + 7 ; const long long LINF = INF * ( long long ) INF ; const int MAX = 1000 + 7 ; string s , a , b ; bool can ( ) { int p1 = - 1 ; for ( int i = ( 0 ) ; i < ( ( int ) s . size ( ) ) ; i ++ ) { bool ok = true ; for ( int j = ( 0 ) ; j < ( ( int ) a . size ( ) ) ; j ++ ) { if ( i + j >= ( int ) s . size ( ) || s [ i + j ] != a [ j ] ) { ok = false ; break ; } } if ( ok ) { p1 = i ; break ; } } if ( p1 == - 1 ) return false ; int p2 = - 1 ; for ( int i = ( ( int ) s . size ( ) ) - 1 ; i >= ( 0 ) ; i -- ) { bool ok = true ; for ( int j = ( 0 ) ; j < ( ( int ) b . size ( ) ) ; j ++ ) { if ( i + j >= ( int ) s . size ( ) || s [ i + j ] != b [ j ] ) { ok = false ; break ; } } if ( ok ) { p2 = i ; break ; } } if ( p1 + ( int ) a . size ( ) - 1 < p2 ) return true ; return false ; } int main ( ) { cin >> s >> a >> b ; bool forward = can ( ) ; reverse ( s . begin ( ) , s . end ( ) ) ; bool backward = can ( ) ; if ( forward && backward ) { cout << " both " << endl ; return 0 ; } if ( forward ) { cout << " forward " << endl ; return 0 ; } if ( backward ) { cout << " backward " << endl ; return 0 ; } cout << " fantasy " << endl ; }
TAB0 create character array s with size 123456 ; TAB0 create character array a with size 128 ; TAB0 create character array b with size 128 ; TAB0 create integer arrays p , p2 , with p size 128 , p2 size 128 ; TAB0 declare check with no arguments , returning boolean ; TAB1 set p [ 0 ] to - 1 ; TAB1 create integer sa with sa = string length of a ; TAB1 create integer sb with sb = string length of b ; TAB1 for i = ( 1 ) , _b ( sa ) to _b exclusive ; TAB2 set p [ i ] to p [ i - 1 ] ; TAB2 while p [ i ] is not - 1 and a [ p [ i ] + 1 ] is not a [ i ] , set p [ i ] to p [ p [ i ] ] ; TAB2 if a [ p [ i ] + 1 ] is a [ i ] , increment p [ i ] ; TAB1 set p2 [ 0 ] to - 1 ; TAB1 for i = ( 1 ) , _b ( sb ) to _b exclusive ; TAB2 set p2 [ i ] to p2 [ i - 1 ] ; TAB2 while p2 [ i ] is not - 1 and b [ p2 [ i ] + 1 ] is not b [ i ] , set p2 [ i ] to p2 [ p2 [ i ] ] ; TAB2 if b [ p2 [ i ] + 1 ] is b [ i ] , increment p2 [ i ] ; TAB1 create integer n with n = string length of s ; TAB1 create integer x with x = - 1 ; TAB1 for i = ( 0 ) , _b ( n ) to _b exclusive ; TAB2 while x is not - 1 and a [ x + 1 ] is not s [ i ] , set x to p [ x ] ; TAB2 if a [ x + 1 ] is s [ i ] , increment x ; TAB2 if x is sa - 1 ; TAB3 set x to - 1 ; TAB3 for incremented i to n exclusive ; TAB4 while x is not - 1 and b [ x + 1 ] is not s [ i ] , set x to p2 [ x ] ; TAB4 if b [ x + 1 ] is s [ i ] , increment x ; TAB4 if x is sb - 1 , return true from function ; TAB3 return false from function ; TAB1 return false from function ; TAB1 read string into s ; TAB1 read string into a ; TAB1 read string into b ; TAB1 create boolean q with q = result of run check ; TAB1 reverse element order from s to s + string length of s ; TAB1 create boolean w with w = result of run check ; TAB1 if q and w , print " both \ n " ; TAB1 if q and not w , print " forward \ n " ; TAB1 if not q and w , print " backward \ n " ; TAB1 if not q and not w , print " fantasy \ n " ;	char s [ 123456 ] ; char a [ 128 ] ; char b [ 128 ] ; int p [ 128 ] , p2 [ 128 ] ; bool check ( ) { p [ 0 ] = - 1 ; int sa = strlen ( a ) ; int sb = strlen ( b ) ; for ( int i = ( 1 ) , _b ( sa ) ; i < _b ; ++ i ) { p [ i ] = p [ i - 1 ] ; while ( p [ i ] != - 1 && a [ p [ i ] + 1 ] != a [ i ] ) p [ i ] = p [ p [ i ] ] ; if ( a [ p [ i ] + 1 ] == a [ i ] ) p [ i ] ++ ; } p2 [ 0 ] = - 1 ; for ( int i = ( 1 ) , _b ( sb ) ; i < _b ; ++ i ) { p2 [ i ] = p2 [ i - 1 ] ; while ( p2 [ i ] != - 1 && b [ p2 [ i ] + 1 ] != b [ i ] ) p2 [ i ] = p2 [ p2 [ i ] ] ; if ( b [ p2 [ i ] + 1 ] == b [ i ] ) p2 [ i ] ++ ; } int n = strlen ( s ) ; int x = - 1 ; for ( int i = ( 0 ) , _b ( n ) ; i < _b ; ++ i ) { while ( x != - 1 && a [ x + 1 ] != s [ i ] ) x = p [ x ] ; if ( a [ x + 1 ] == s [ i ] ) ++ x ; if ( x == sa - 1 ) { x = - 1 ; for ( ++ i ; i < n ; ++ i ) { while ( x != - 1 && b [ x + 1 ] != s [ i ] ) x = p2 [ x ] ; if ( b [ x + 1 ] == s [ i ] ) ++ x ; if ( x == sb - 1 ) return true ; } return false ; } } return false ; } int main ( ) { gets ( s ) ; gets ( a ) ; gets ( b ) ; bool q = check ( ) ; reverse ( s , s + strlen ( s ) ) ; bool w = check ( ) ; if ( q && w ) cout << " both\n " ; if ( q && ! w ) cout << " forward\n " ; if ( ! q && w ) cout << " backward\n " ; if ( ! q && ! w ) cout << " fantasy\n " ; return 0 ; }
TAB0 s = array of characters of size 100010 ; TAB0 a and b = arrays of characters of size 100010 ; TAB1 read s + 1 , a + 1 and b + 1 ; TAB1 let ls , la and lb be integers with ls = length of s + 1 , la = length of a + 1 and lb = length of b + 1 ; TAB1 let p1 and p2 be integers with value - 1 ; TAB1 let f1 and f2 be booleans with value 0 ; TAB1 for register int i = 1 to ls - la + 1 inclusive ; TAB2 set boolean flag to 1 ; TAB2 for register int j = 1 , k = i to j < = la , incrementing j and k ; TAB3 if a [ j ] ! = s [ k ] ; TAB4 set value of flag to 0 ; TAB4 stop the loop ; TAB2 if flag ; TAB3 p1 = i + la - 1 ; TAB3 stop the loop ; TAB1 if p1 ! = - 1 ; TAB2 for i = p1 + 1 to ls - lb + 1 inclusive ; TAB3 set f1 to 1 ; TAB3 for j = 1 , k = i to j < = lb , incrementing k and j ; TAB4 if b [ j ] ! = s [ k ] ; TAB5 set f1 to 0 ; TAB5 stop the loop ; TAB3 if f1 ; TAB1 for register = 1 to ls - lb + 1 inclusive ; TAB2 create boolean flag with value 1 ; TAB2 for j = 1 , k = i + lb - 1 to j < = lb , incrementing j and decrementing k ; TAB3 if b [ j ] ! = s [ k ] ; TAB4 set value of flag to 0 ; TAB4 stop the loop ; TAB2 if flag ; TAB3 p2 = i + lb - 1 ; TAB3 stop the loop ; TAB1 if p2 ! = - 1 ; TAB2 for int i = p2 + 1 to ls - la + 1 inclusive ; TAB3 set value of f2 to 1 ; TAB3 for int j = 1 , k = i + la - 1 to j < = la incrementing j and decrementing k ; TAB4 if a [ j ] ! = s [ k ] ; TAB5 f2 = 0 ; TAB5 break the loop ; TAB3 if f2 ; TAB1 if f1 and f2 ; TAB2 print " both " ; TAB1 else if f1 ; TAB2 print " forward " ; TAB1 else if f2 ; TAB2 print " backward " ; TAB1 else ; TAB2 print " fantasy " ;	char s [ 100010 ] ; char a [ 100010 ] , b [ 100010 ] ; int main ( ) { cin >> s + 1 >> a + 1 >> b + 1 ; int ls = strlen ( s + 1 ) , la = strlen ( a + 1 ) , lb = strlen ( b + 1 ) ; int p1 = - 1 , p2 = - 1 ; bool f1 = 0 , f2 = 0 ; for ( register int i = 1 ; i <= ls - la + 1 ; i ++ ) { bool flag = 1 ; for ( register int j = 1 , k = i ; j <= la ; j ++ , k ++ ) if ( a [ j ] != s [ k ] ) { flag = 0 ; break ; } if ( flag ) { p1 = i + la - 1 ; break ; } } if ( p1 != - 1 ) { for ( register int i = p1 + 1 ; i <= ls - lb + 1 ; i ++ ) { f1 = 1 ; for ( register int j = 1 , k = i ; j <= lb ; j ++ , k ++ ) if ( b [ j ] != s [ k ] ) { f1 = 0 ; break ; } if ( f1 ) break ; } } for ( register int i = 1 ; i <= ls - lb + 1 ; i ++ ) { bool flag = 1 ; for ( register int j = 1 , k = i + lb - 1 ; j <= lb ; j ++ , k -- ) if ( b [ j ] != s [ k ] ) { flag = 0 ; break ; } if ( flag ) { p2 = i + lb - 1 ; break ; } } if ( p2 != - 1 ) { for ( register int i = p2 + 1 ; i <= ls - la + 1 ; i ++ ) { f2 = 1 ; for ( register int j = 1 , k = i + la - 1 ; j <= la ; j ++ , k -- ) if ( a [ j ] != s [ k ] ) { f2 = 0 ; break ; } if ( f2 ) break ; } } if ( f1 && f2 ) puts ( " both " ) ; else if ( f1 ) puts ( " forward " ) ; else if ( f2 ) puts ( " backward " ) ; else puts ( " fantasy " ) ; return 0 ; }
TAB0 let s be an array of characters of length 123456 ; TAB0 let a be an array of characters of size 128 ; TAB0 b = array of characters of length 128 ; TAB0 p and p2 = integer arrays of length 128 ; TAB0 function check ; TAB1 set p [ 0 ] to - 1 ; TAB1 sa = length of a ; TAB1 sb = length of b ; TAB1 for integer i = from 1 to _b exclusive call _b ( sa ) ; TAB2 p [ i ] = p [ i - 1 ] ; TAB2 while p [ i ] ! = - 1 & & a [ p [ i ] + 1 ] ! = a [ i ] set p [ i ] to p [ p [ i ] ] ; TAB2 if a [ p [ i ] + 1 ] is equal to a [ i ] increase p [ i ] by one ; TAB1 set p2 [ 0 ] to - 1 ; TAB1 for integer i = from 1 to _b exclusive call _b ( sb ) ; TAB2 p2 [ i ] = p2 [ i - 1 ] ; TAB2 while p2 [ i ] ! = - 1 & & b [ p2 [ i ] + 1 ] ! = b [ i ] set p2 [ i ] to p2 [ p2 [ i ] ] ; TAB2 if b [ p2 [ i ] + 1 ] is equal to b [ i ] increment p2 [ i ] ; TAB1 integer n = length of s ; TAB1 integer x = - 1 ; TAB1 for integer i = from 1 to _b exclusive call _b ( n ) ; TAB2 while x ! = - 1 & & a [ x + 1 ] ! = s [ i ] set x to p [ x ] ; TAB2 if a [ x + 1 ] is equal to s [ i ] increment x ; TAB2 if x is equal to sa - 1 ; TAB3 set value of x to - 1 ; TAB3 loop from i + 1 to n exclusive ; TAB4 while x ! = - 1 & & b [ x + 1 ] ! = s [ i ] set x to p2 [ x ] ; TAB4 if b [ x + 1 ] is equal to s [ i ] increment x ; TAB4 if x is equal to sb - 1 return true ; TAB3 return false ; TAB1 return false ; TAB1 read string from the input to variable s ; TAB1 read string from the input to variable a ; TAB1 read string from the input to variable b ; TAB1 set q to the result of check ( ) ; TAB1 call reverse with arguments s and s + length of s ; TAB1 boolean w = result of function check ; TAB1 if q & & w print " both \ n " ; TAB1 if ( q & & ! w ) " forward \ n " ; TAB1 if ( ! q & & w ) " backward \ n " ; TAB1 if ( ! q & & ! w ) " fantasy \ n " ; TAB0 create character array s with size 123456 ; TAB0 create character array a with size 128 ; TAB0 create character array b with size 128 ; TAB0 create character arrays p , p2 with p size 128 , p2 size 128 ; TAB0 declare check with no arguments , returning boolean ; TAB1 set p [ 0 ] to - 1 ; TAB1 create integer sa with sa = string length of a ; TAB1 create integer sb with sb = string length of b ; TAB1 for i = ( 1 ) , _b ( sa ) , to _b exclusive ; TAB2 set p [ i ] to p [ i - 1 ] ; TAB2 while p [ i ] is not - 1 and a [ p [ i ] + 1 ] is not a [ i ] , set p [ i ] to p [ p [ i ] ] ; TAB2 if a [ p [ i ] ] + 1 is a [ i ] , increment p [ i ] ; TAB1 set p2 [ 0 ] to - 1 ; TAB1 for i = ( 1 ) , _b ( sb ) to _b exclusive ; TAB2 set p2 [ i ] to p2 [ i - 1 ] ; TAB2 while p2 [ i ] is not - 1 and b [ p2 [ i ] + 1 ] is not b [ i ] , set p2 [ i ] to p2 [ p2 [ i ] ] ; TAB2 if b [ p2 [ i ] + 1 ] is b [ i ] , increment p2 [ i ] ; TAB1 create integer n with n = string length of s ; TAB1 create integer x with x = - 1 ; TAB1 for i = ( 0 ) , _b ( n ) to _b exclusive ; TAB2 while x is not - 1 and a [ x + 1 ] is not s [ i ] , set x to p [ x ] ; TAB2 if a [ x + 1 ] is s [ 1 ] , increment x ; TAB2 if x is sa - 1 ; TAB3 set x to - 1 ; TAB3 for i to n exclusive ; TAB4 while x is not - 1 and b [ x + 1 ] is not s [ i ] , set x to p2 [ x ] ; TAB4 if b [ x + 1 ] is s [ i ] , increment x ; TAB4 if x is sb - 1 return true from function ; TAB3 return false from function ; TAB1 return false from function ; TAB1 read s ; TAB1 read a ; TAB1 read b ; TAB1 create boolean q with q = result of run check ; TAB1 reverse element order from s to s + string length of s ; TAB1 create boolean w with w = result of run check ; TAB1 if q and w , print " both \ n " ; TAB1 if q and not w , print " forward \ n " ; TAB1 if not q and w , print " backward \ n " ; TAB1 if not q and not w , print " fantasy \ n " ;	char s [ 123456 ] ; char a [ 128 ] ; char b [ 128 ] ; int p [ 128 ] , p2 [ 128 ] ; bool check ( ) { p [ 0 ] = - 1 ; int sa = strlen ( a ) ; int sb = strlen ( b ) ; for ( int i = ( 1 ) , _b ( sa ) ; i < _b ; ++ i ) { p [ i ] = p [ i - 1 ] ; while ( p [ i ] != - 1 && a [ p [ i ] + 1 ] != a [ i ] ) p [ i ] = p [ p [ i ] ] ; if ( a [ p [ i ] + 1 ] == a [ i ] ) p [ i ] ++ ; } p2 [ 0 ] = - 1 ; for ( int i = ( 1 ) , _b ( sb ) ; i < _b ; ++ i ) { p2 [ i ] = p2 [ i - 1 ] ; while ( p2 [ i ] != - 1 && b [ p2 [ i ] + 1 ] != b [ i ] ) p2 [ i ] = p2 [ p2 [ i ] ] ; if ( b [ p2 [ i ] + 1 ] == b [ i ] ) p2 [ i ] ++ ; } int n = strlen ( s ) ; int x = - 1 ; for ( int i = ( 0 ) , _b ( n ) ; i < _b ; ++ i ) { while ( x != - 1 && a [ x + 1 ] != s [ i ] ) x = p [ x ] ; if ( a [ x + 1 ] == s [ i ] ) ++ x ; if ( x == sa - 1 ) { x = - 1 ; for ( ++ i ; i < n ; ++ i ) { while ( x != - 1 && b [ x + 1 ] != s [ i ] ) x = p2 [ x ] ; if ( b [ x + 1 ] == s [ i ] ) ++ x ; if ( x == sb - 1 ) return true ; } return false ; } } return false ; } int main ( ) { gets ( s ) ; gets ( a ) ; gets ( b ) ; bool q = check ( ) ; reverse ( s , s + strlen ( s ) ) ; bool w = check ( ) ; if ( q && w ) cout << " both\n " ; if ( q && ! w ) cout << " forward\n " ; if ( ! q && w ) cout << " backward\n " ; if ( ! q && ! w ) cout << " fantasy\n " ; return 0 ; } char s [ 123456 ] ; char a [ 128 ] ; char b [ 128 ] ; int p [ 128 ] , p2 [ 128 ] ; bool check ( ) { p [ 0 ] = - 1 ; int sa = strlen ( a ) ; int sb = strlen ( b ) ; for ( int i = ( 1 ) , _b ( sa ) ; i < _b ; ++ i ) { p [ i ] = p [ i - 1 ] ; while ( p [ i ] != - 1 && a [ p [ i ] + 1 ] != a [ i ] ) p [ i ] = p [ p [ i ] ] ; if ( a [ p [ i ] + 1 ] == a [ i ] ) p [ i ] ++ ; } p2 [ 0 ] = - 1 ; for ( int i = ( 1 ) , _b ( sb ) ; i < _b ; ++ i ) { p2 [ i ] = p2 [ i - 1 ] ; while ( p2 [ i ] != - 1 && b [ p2 [ i ] + 1 ] != b [ i ] ) p2 [ i ] = p2 [ p2 [ i ] ] ; if ( b [ p2 [ i ] + 1 ] == b [ i ] ) p2 [ i ] ++ ; } int n = strlen ( s ) ; int x = - 1 ; for ( int i = ( 0 ) , _b ( n ) ; i < _b ; ++ i ) { while ( x != - 1 && a [ x + 1 ] != s [ i ] ) x = p [ x ] ; if ( a [ x + 1 ] == s [ i ] ) ++ x ; if ( x == sa - 1 ) { x = - 1 ; for ( ++ i ; i < n ; ++ i ) { while ( x != - 1 && b [ x + 1 ] != s [ i ] ) x = p2 [ x ] ; if ( b [ x + 1 ] == s [ i ] ) ++ x ; if ( x == sb - 1 ) return true ; } return false ; } } return false ; } int main ( ) { gets ( s ) ; gets ( a ) ; gets ( b ) ; bool q = check ( ) ; reverse ( s , s + strlen ( s ) ) ; bool w = check ( ) ; if ( q && w ) cout << " both\n " ; if ( q && ! w ) cout << " forward\n " ; if ( ! q && w ) cout << " backward\n " ; if ( ! q && ! w ) cout << " fantasy\n " ; return 0 ; }
TAB0 create character array s of size 100010 ; TAB0 create character arrays a , b , with a size 100010 , b size 100010 ; TAB1 read s + 1 read a + 1 read b + 1 ; TAB1 create integers ls , la , lb with ls = string length of s + 1 , la = string length of a + 1 , lb = string length of b + 1 ; TAB1 create integers p1 , p2 , with p1 = - 1 , p2 = - 1 ; TAB1 create booleans f1 , f2 with f1 = 0 , f2 = 0 ; TAB1 for i = 1 to ls - la + 1 inclusive ; TAB2 create boolean flag with flag = 1 ; TAB2 for j = 1 , k = i to j less than or equal to la , incrementing j , k ; TAB3 if a [ j ] is not s [ k ] ; TAB4 set flag to 0 ; TAB4 break loop ; TAB2 if flag is true ; TAB3 set p1 to i + la - 1 ; TAB3 break loop ; TAB1 if p1 is not - 1 ; TAB2 for i = p1 + 1 to ls - lb + 1 inclusive ; TAB3 set f1 to 1 ; TAB3 for j = 1 , k = i to j less than or equal to lb , incrementing j , k ; TAB4 if b [ j ] is not s [ k ] ; TAB5 set f1 to 0 ; TAB5 break loop ; TAB3 if f1 is true , break loop ; TAB1 for i = 1 to ls - lb + 1 inclusive ; TAB2 create boolean flag with flag = 1 ; TAB2 for j = 1 , k = i + lb - 1 to j less than or equal to lb , incrementing j , decrementing k ; TAB3 if b [ j ] is not s [ k ] ; TAB4 set flag to 0 ; TAB4 break loop ; TAB2 if flag is true ; TAB3 set p2 to i + lb - 1 ; TAB3 break loop ; TAB1 if p2 is not - 1 ; TAB2 for i = p2 + 1 to ls - la + 1 inclusive ; TAB3 set f2 to 1 ; TAB3 for j = 1 , k = i + la - 1 to j less than or equal to la , incrementing j , decrementing k ; TAB4 if a [ j ] is not s [ k ] ; TAB5 set f2 to 0 ; TAB5 break loop ; TAB3 if f2 is true , break loop ; TAB1 if f1 and f2 ; TAB2 print " both " ; TAB1 else if f1 is true ; TAB2 print " forward " ; TAB1 else if f2 is true ; TAB2 print " backward " ; TAB1 else ; TAB2 print " fantasy " ;	char s [ 100010 ] ; char a [ 100010 ] , b [ 100010 ] ; int main ( ) { cin >> s + 1 >> a + 1 >> b + 1 ; int ls = strlen ( s + 1 ) , la = strlen ( a + 1 ) , lb = strlen ( b + 1 ) ; int p1 = - 1 , p2 = - 1 ; bool f1 = 0 , f2 = 0 ; for ( register int i = 1 ; i <= ls - la + 1 ; i ++ ) { bool flag = 1 ; for ( register int j = 1 , k = i ; j <= la ; j ++ , k ++ ) if ( a [ j ] != s [ k ] ) { flag = 0 ; break ; } if ( flag ) { p1 = i + la - 1 ; break ; } } if ( p1 != - 1 ) { for ( register int i = p1 + 1 ; i <= ls - lb + 1 ; i ++ ) { f1 = 1 ; for ( register int j = 1 , k = i ; j <= lb ; j ++ , k ++ ) if ( b [ j ] != s [ k ] ) { f1 = 0 ; break ; } if ( f1 ) break ; } } for ( register int i = 1 ; i <= ls - lb + 1 ; i ++ ) { bool flag = 1 ; for ( register int j = 1 , k = i + lb - 1 ; j <= lb ; j ++ , k -- ) if ( b [ j ] != s [ k ] ) { flag = 0 ; break ; } if ( flag ) { p2 = i + lb - 1 ; break ; } } if ( p2 != - 1 ) { for ( register int i = p2 + 1 ; i <= ls - la + 1 ; i ++ ) { f2 = 1 ; for ( register int j = 1 , k = i + la - 1 ; j <= la ; j ++ , k -- ) if ( a [ j ] != s [ k ] ) { f2 = 0 ; break ; } if ( f2 ) break ; } } if ( f1 && f2 ) puts ( " both " ) ; else if ( f1 ) puts ( " forward " ) ; else if ( f2 ) puts ( " backward " ) ; else puts ( " fantasy " ) ; return 0 ; }
TAB1 create strings a , b and c ; TAB1 read a , b and c ; TAB1 forward and backward are booleans with value false ; TAB1 integer pos_1 = index of b in a ; TAB1 pos_2 = integer ; TAB1 if pos_1 ! = - 1 ; TAB2 pos_2 = index of c in a starting from position pos_1 + length of b ; TAB2 if pos_2 ! = - 1 , set forward to true ; TAB1 reverse a ; TAB1 pos_1 = index of b in a ; TAB1 if pos_1 ! = - 1 ; TAB2 pos_2 = index of c in a starting from pos_1 + length of b ; TAB2 if pos_2 ! = - 1 , set backward to true ; TAB1 if backward = false & & forward = false , print " fantasy " ; TAB1 if backward = false and forward = true , print " forward " ; TAB1 if forward = false and backward = true , print " backward " ; TAB1 if backward = true & & forward = true , print " both " ; TAB1 create strings a , b , c ; TAB1 read a read b read c ; TAB1 create booleans forward , backward with forward = false , backward = false ; TAB1 create integer pos_1 with pos_1 = first index of b in a ; TAB1 create integer pos_2 ; TAB1 if pos_1 is not - 1 ; TAB2 set pos_2 to first index of c starting at pos_1 + length of b in a ; TAB2 if pos_2 is not - 1 , set forward to true ; TAB1 reverse elements from beginning of a to end of a ; TAB1 set pos_1 to first index of b in a ; TAB1 if pos_1 is not - 1 ; TAB2 set pos_2 to first index of c starting at pos_1 + length of b in a ; TAB2 if pos_2 is not - 1 , set backward to true ; TAB1 if backward is false and forward is true , print " fantasy " ; TAB1 if backward is false and forward is true , print " forward " ; TAB1 if forward is false and backward is true , print " backward " ; TAB1 if backward is true and forward is true , print " both " ;	int main ( ) { string a , b , c ; cin >> a >> b >> c ; bool forward = false , backward = false ; int pos_1 = a . find ( b ) ; int pos_2 ; if ( pos_1 != - 1 ) { pos_2 = a . find ( c , pos_1 + b . length ( ) ) ; if ( pos_2 != - 1 ) { forward = true ; } } reverse ( a . begin ( ) , a . end ( ) ) ; pos_1 = a . find ( b ) ; if ( pos_1 != - 1 ) { pos_2 = a . find ( c , pos_1 + b . length ( ) ) ; if ( pos_2 != - 1 ) { backward = true ; } } if ( backward == false && forward == false ) { puts ( " fantasy " ) ; } if ( backward == false && forward == true ) { puts ( " forward " ) ; } if ( forward == false && backward == true ) { puts ( " backward " ) ; } if ( backward == true && forward == true ) { puts ( " both " ) ; } } int main ( ) { string a , b , c ; cin >> a >> b >> c ; bool forward = false , backward = false ; int pos_1 = a . find ( b ) ; int pos_2 ; if ( pos_1 != - 1 ) { pos_2 = a . find ( c , pos_1 + b . length ( ) ) ; if ( pos_2 != - 1 ) { forward = true ; } } reverse ( a . begin ( ) , a . end ( ) ) ; pos_1 = a . find ( b ) ; if ( pos_1 != - 1 ) { pos_2 = a . find ( c , pos_1 + b . length ( ) ) ; if ( pos_2 != - 1 ) { backward = true ; } } if ( backward == false && forward == false ) { puts ( " fantasy " ) ; } if ( backward == false && forward == true ) { puts ( " forward " ) ; } if ( forward == false && backward == true ) { puts ( " backward " ) ; } if ( backward == true && forward == true ) { puts ( " both " ) ; } }
TAB1 create strings s , a , b ; TAB1 while read s read a read b is true ; TAB2 create boolean array isok of size 2 with isok = { 0 , 0 } ; TAB2 for i = 0 to 2 exclusive ; TAB3 create integer idx with idx = first index of a in s ; TAB3 if idx is not end of string ; TAB4 set idx to first index of b starting at idx + size of a , in s ; TAB4 if idx is not end of string , set isok [ i ] to 1 ; TAB3 reverse element order starting at beginning of s to end of s ; TAB2 if isok [ 0 ] and isok [ 1 ] ; TAB3 print " both " print newline ; TAB2 else if isok [ 0 ] is true ; TAB3 print " forward " print newline ; TAB2 else if isok [ 1 ] is true ; TAB3 print " backward " print newline ; TAB2 else ; TAB3 print " fantasy " print newline ; TAB1 declare strings called s , a and b ; TAB1 read s , a and b in a loop ; TAB2 boolean array isok with 2 elements = 0 ; TAB2 for i = 0 to 2 exclusive ; TAB3 idx = index of a in the s ; TAB3 if idx ! = string : : npos ; TAB4 idx = index of b in the s , starting from idx + length of a ; TAB4 if idx ! = string : : npos , set isok [ i ] to 1 ; TAB3 reverse s ; TAB2 if isok [ 0 ] and isok [ 1 ] are true ; TAB3 print " both " and a new line ; TAB2 else if isok [ 0 ] is true ; TAB3 print " forward " and a new line ; TAB2 else if isok [ 1 ] is true ; TAB3 print " backward " and a new line ; TAB2 else ; TAB3 print " fantasy " and a new line ;	int main ( ) { string s , a , b ; while ( cin >> s >> a >> b ) { bool isok [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < 2 ; i ++ ) { int idx = s . find ( a ) ; if ( idx != string :: npos ) { idx = s . find ( b , idx + a . size ( ) ) ; if ( idx != string :: npos ) isok [ i ] = 1 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } if ( isok [ 0 ] && isok [ 1 ] ) cout << " both " << endl ; else if ( isok [ 0 ] ) cout << " forward " << endl ; else if ( isok [ 1 ] ) cout << " backward " << endl ; else cout << " fantasy " << endl ; } return 0 ; } int main ( ) { string s , a , b ; while ( cin >> s >> a >> b ) { bool isok [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < 2 ; i ++ ) { int idx = s . find ( a ) ; if ( idx != string :: npos ) { idx = s . find ( b , idx + a . size ( ) ) ; if ( idx != string :: npos ) isok [ i ] = 1 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } if ( isok [ 0 ] && isok [ 1 ] ) cout << " both " << endl ; else if ( isok [ 0 ] ) cout << " forward " << endl ; else if ( isok [ 1 ] ) cout << " backward " << endl ; else cout << " fantasy " << endl ; } return 0 ; }
TAB0 declare fill_prefix with arguments string address P , integer vector address F ; TAB1 resize F to fit size of P elements , copying 0 to new elements ; TAB1 for j , i = 1 to i is less than size of P , incrementing i ; TAB2 set j to F [ i - 1 ] ; TAB2 while j is greater than 0 and P [ i ] is not P [ j ] , set j to F [ j - 1 ] ; TAB2 if P [ i ] is P [ j ] , increment j ; TAB2 set F [ i ] to j ; TAB0 declare kmp with arguments string address T , string address P , integer vector address F , integers start , end , returning integer ; TAB1 if start is size of T , return - 1 from function ; TAB1 if end - start + 1 is less than size of P , return - 1 from function ; TAB1 create integer i with i = start ; TAB1 create integer j with j = 0 ; TAB1 create integer idx with idx = - 1 ; TAB1 while i is less than or equal to end ; TAB2 while j is less than size of P and i is less than or equal to end and T [ i ] is P [ j ] ; TAB3 increment i ; TAB3 increment j ; TAB2 if j is size of P ; TAB3 set idx to i - size of P ; TAB3 return idx from function ; TAB2 else ; TAB3 if j is 0 ; TAB4 set i to i + 1 ; TAB3 else ; TAB4 set j to F [ j - 1 ] ; TAB1 return idx from function ; TAB0 declare valid with arguments string address T , string address P1 , string address P2 , integer vector address F1 , integer vector address F2 , returning boolean ; TAB1 create integer i with i = result of run kmp with arguments T , P1 , F1 , 0 , size of T - 1 ; TAB1 if i is - 1 , return false from function ; TAB1 increment i by size of P1 ; TAB1 set i to result of run kmp with arguments T , P2 , F2 , i , size of T - 1 ; TAB1 if i is - 1 , return false from function ; TAB1 return true from function ; TAB1 create strings T , P1 , P2 ; TAB1 create integer vectors F1 , F2 ; TAB1 read T read P1 read P2 ; TAB1 run fill_prefix with arguments P1 , F1 ; TAB1 run fill_prefix with arguments P2 , F2 ; TAB1 create boolean x with x = result of run valid with arguments T , P1 , P2 , F1 , F2 ; TAB1 reverse elements order from beginning of T to end of T ; TAB1 create boolean y with y = result of run valid with arguments T , P1 , P2 , F1 , F2 ; TAB1 if not x and not y ; TAB2 print " fantasy \ n " ; TAB1 else if not x and y ; TAB2 print " backward \ n " ; TAB1 else if x and not y ; TAB2 print " forward \ n " ; TAB1 else ; TAB2 print " both \ n " ;	void fill_prefix ( string & P , vector < int > & F ) { F . resize ( P . size ( ) , 0 ) ; for ( int j , i = 1 ; i < P . size ( ) ; ++ i ) { j = F [ i - 1 ] ; while ( j > 0 && P [ i ] != P [ j ] ) j = F [ j - 1 ] ; if ( P [ i ] == P [ j ] ) ++ j ; F [ i ] = j ; } } int kmp ( string & T , string & P , vector < int > & F , int start , int end ) { if ( start == T . size ( ) ) return - 1 ; if ( end - start + 1 < P . size ( ) ) return - 1 ; int i = start ; int j = 0 ; int idx = - 1 ; while ( i <= end ) { while ( j < P . size ( ) && i <= end && T [ i ] == P [ j ] ) { ++ i ; ++ j ; } if ( j == P . size ( ) ) { idx = i - P . size ( ) ; return idx ; } else { if ( j == 0 ) i = i + 1 ; else j = F [ j - 1 ] ; } } return idx ; } bool valid ( string & T , string & P1 , string & P2 , vector < int > & F1 , vector < int > & F2 ) { int i = kmp ( T , P1 , F1 , 0 , T . size ( ) - 1 ) ; if ( i == - 1 ) return false ; i += P1 . size ( ) ; i = kmp ( T , P2 , F2 , i , T . size ( ) - 1 ) ; if ( i == - 1 ) return false ; return true ; } int main ( ) { string T , P1 , P2 ; vector < int > F1 , F2 ; cin >> T >> P1 >> P2 ; fill_prefix ( P1 , F1 ) ; fill_prefix ( P2 , F2 ) ; bool x = valid ( T , P1 , P2 , F1 , F2 ) ; reverse ( T . begin ( ) , T . end ( ) ) ; bool y = valid ( T , P1 , P2 , F1 , F2 ) ; if ( ! x && ! y ) cout << " fantasy\n " ; else if ( ! x && y ) cout << " backward\n " ; else if ( x && ! y ) cout << " forward\n " ; else cout << " both\n " ; return 0 ; }
TAB0 create integer ind ; TAB0 create booleans forw , backw ; TAB0 create strings s , a , b , tmp ; TAB0 declare search with integer start , string x , string y as arguments , returning integer ; TAB1 for i = start to length of x - length of y inclusive ; TAB2 for j = 0 to length of y exclusive ; TAB3 if x [ i + j ] is not y [ j ] break loop ; TAB3 if j is length of y - 1 , return i + j from function ; TAB1 return - 1 from function ; TAB1 read s read a read b ; TAB1 if length of a + length of b is greater than length of s ; TAB2 print " fantasy " print newline ; TAB1 set ind to result of run search with 0 , s , a as arguments ; TAB1 if ind is greater than or equal to 0 ; TAB2 set ind to run search with ind + 1 , s , b as arguments ; TAB2 set forw to true if ind is greater than or equal to 0 , else false ; TAB1 set tmp to s ; TAB1 set s to " " ; TAB1 for i = length of tmp - 1 to 0 inclusive , decrementing i , increment s by tmp [ i ] ; TAB1 set ind to result of run search with 0 , s , a as arguments ; TAB1 if ind is greater than or equal to 0 ; TAB2 set ind to result of run search with ind + 1 , s , b as arguments ; TAB2 set backw to true if ind is not - 1 , else false ; TAB1 if forw and not backw ; TAB2 print " forward " print newline ; TAB1 else if not forw and backw ; TAB2 print " backward " print newline ; TAB1 else if forw and backw ; TAB2 print " both " print newline ; TAB1 else ; TAB2 print " fantasy " print newline ; TAB0 declare integer variable ind ; TAB0 boolean forw , backw ; TAB0 create strings s , a , b and tmp ; TAB0 define function search with int argument start and string arguments x , y ; TAB1 for integer i = start to ( length of x - length of y ) inclusive ; TAB2 for integer j = 0 to length of y exclusive ; TAB3 if x [ i + j ] ! = y [ j ] break ; TAB3 if j is equal to length of y - 1 return i + j ; TAB1 return - 1 ; TAB1 read s , a and b ; TAB1 if length of a + length of b is greater than length of s ; TAB2 print " fantasy " and a new line ; TAB1 set value of ind to search ( 0 , s , a ) ; TAB1 if ind is greater than or equal to 0 ; TAB2 ind = search ( ind + 1 , s , b ) ; TAB2 forw = true if ind > = 0 and false otherwise ; TAB1 set tmp to s ; TAB1 s = emtpy string ; TAB1 loop i from length of tmp - 1 to 0 inclusive decrementing by 1 , add tmp [ i ] to s on each loop ; TAB1 set ind to search ( 0 , s , a ) ; TAB1 if ind is greater than or equal to 0 ; TAB2 ind = search ( ind + 1 , s , b ) ; TAB2 set backw to true of ind ! = - 1 and false otherwise ; TAB1 if forw is true and backw is false ; TAB2 print " forward " and a new line ; TAB1 else if forw is false and backw is true ; TAB2 print " backward " and a new line ; TAB1 else if forw and backw are both true ; TAB2 print " both " and a new line ; TAB1 else ; TAB2 print " fantasy " and a new line ;	int ind ; bool forw , backw ; string s , a , b , tmp ; int search ( int start , string x , string y ) { for ( int i = start ; i <= x . length ( ) - y . length ( ) ; i ++ ) { for ( int j = 0 ; j < y . length ( ) ; j ++ ) { if ( x [ i + j ] != y [ j ] ) break ; if ( j == y . length ( ) - 1 ) return i + j ; } } return - 1 ; } int main ( ) { cin >> s >> a >> b ; if ( a . length ( ) + b . length ( ) > s . length ( ) ) { cout << " fantasy " << endl ; return 0 ; } ind = search ( 0 , s , a ) ; if ( ind >= 0 ) { ind = search ( ind + 1 , s , b ) ; forw = ( ind >= 0 ) ; } tmp = s ; s = "  " ; for ( int i = tmp . length ( ) - 1 ; i >= 0 ; i -- ) { s += tmp [ i ] ; } ind = search ( 0 , s , a ) ; if ( ind >= 0 ) { ind = search ( ind + 1 , s , b ) ; backw = ( ind != - 1 ) ; } if ( forw && ! backw ) cout << " forward " << endl ; else if ( ! forw && backw ) cout << " backward " << endl ; else if ( forw && backw ) cout << " both " << endl ; else cout << " fantasy " << endl ; } int ind ; bool forw , backw ; string s , a , b , tmp ; int search ( int start , string x , string y ) { for ( int i = start ; i <= x . length ( ) - y . length ( ) ; i ++ ) { for ( int j = 0 ; j < y . length ( ) ; j ++ ) { if ( x [ i + j ] != y [ j ] ) break ; if ( j == y . length ( ) - 1 ) return i + j ; } } return - 1 ; } int main ( ) { cin >> s >> a >> b ; if ( a . length ( ) + b . length ( ) > s . length ( ) ) { cout << " fantasy " << endl ; return 0 ; } ind = search ( 0 , s , a ) ; if ( ind >= 0 ) { ind = search ( ind + 1 , s , b ) ; forw = ( ind >= 0 ) ; } tmp = s ; s = "  " ; for ( int i = tmp . length ( ) - 1 ; i >= 0 ; i -- ) { s += tmp [ i ] ; } ind = search ( 0 , s , a ) ; if ( ind >= 0 ) { ind = search ( ind + 1 , s , b ) ; backw = ( ind != - 1 ) ; } if ( forw && ! backw ) cout << " forward " << endl ; else if ( ! forw && backw ) cout << " backward " << endl ; else if ( forw && backw ) cout << " both " << endl ; else cout << " fantasy " << endl ; }
TAB1 create strings colors , round1 , round2 ; TAB1 read colors read round1 read round2 ; TAB1 create string colors_rev initialized with arguments reverse beginning to reverse end ; TAB1 create boolean forwards with forwards = function address of colors , address of round1 , address of round2 ; TAB2 create size_t match1 with match1 = first index of round1 in colors ; TAB2 if match1 is end of string , return false from function ; TAB2 create size_t match2 with match2 = first index of round2 starting at match1 + length of round1 ; TAB2 if match2 is end of strong , return false from function ; TAB2 return true from function ; TAB1 end function ; TAB1 create boolean backwards with backwards = function with arguments address of colors_rev , address of round1 , address of round2 ; TAB2 create size_t match1 with match1 = first index of round1 in colors_rev ; TAB2 if match1 is end of string , return false from function ; TAB2 create size_t match2 with match2 = first index of round2 starting at match1 + length of round1 in colors_rev ; TAB2 if match2 is end of string , return false from function ; TAB2 return true from function ; TAB1 end function ; TAB1 if forwards and backwards is true ; TAB2 print " both " ; TAB1 else if forwards is true ; TAB2 print " forward " ; TAB1 else if backwards is true ; TAB2 print " backward " ; TAB1 else ; TAB2 print " fantasy " ; TAB1 print ' \ n ' ;	int main ( ) { string colors , round1 , round2 ; cin >> colors >> round1 >> round2 ; string colors_rev ( colors . rbegin ( ) , colors . rend ( ) ) ; bool forwards = [ & colors , & round1 , & round2 ] ( ) { size_t match1 = colors . find ( round1 ) ; if ( match1 == string :: npos ) return false ; size_t match2 = colors . find ( round2 , match1 + round1 . length ( ) ) ; if ( match2 == string :: npos ) return false ; return true ; } ( ) ; bool backwards = [ & colors_rev , & round1 , & round2 ] ( ) { size_t match1 = colors_rev . find ( round1 ) ; if ( match1 == string :: npos ) return false ; size_t match2 = colors_rev . find ( round2 , match1 + round1 . length ( ) ) ; if ( match2 == string :: npos ) return false ; return true ; } ( ) ; if ( forwards && backwards ) { cout << " both " ; } else if ( forwards ) { cout << " forward " ; } else if ( backwards ) { cout << " backward " ; } else { cout << " fantasy " ; } cout << ' \n ' ; return 0 ; }
TAB1 declare strings called s , a and b ; TAB1 while can read s , a and b ; TAB2 bool array isok with size 2 initialized with 0 ; TAB2 for integer i = 0 to 2 exclusive ; TAB3 idx = index of a in s ; TAB3 if idx ! = string : : npos ; TAB4 idx = index of b in s starting from idx + length of a ; TAB4 if idx ! = string : : npos set isok [ i ] to 1 ; TAB3 reverse s ; TAB2 if isok [ 0 ] and isok [ 1 ] are both true ; TAB3 print " both " and a new line ; TAB2 else if isok [ 0 ] is true ; TAB3 print " forward " and a new line ; TAB2 else if isok [ 1 ] is true ; TAB3 print " backward " and a new line ; TAB2 else ; TAB3 print " fantasy " and a new line ; TAB1 create strings s , a , b ; TAB1 while read s read a read b is true ; TAB2 create boolean array isok with size 2 , with isok = { 0 , 0 } ; TAB2 for i = 0 to 2 exclusive ; TAB3 create integer idx with idx = first index of a in s ; TAB3 if idx is not end of string ; TAB4 set idx to first index of b after idx + size of a in s ; TAB4 if idx is not end of string , set isok [ i ] to 1 ; TAB3 reverse element order from beginning of s to end of s ; TAB2 if isok [ 0 ] and isok [ 1 ] ; TAB3 print " both " print newline ; TAB2 else if isok [ 0 ] is true ; TAB3 print " forward " print newline ; TAB2 else if isok [ 1 ] is true ; TAB3 print " backward " print newline ; TAB2 else ; TAB3 print " fantasy " print newline ;	int main ( ) { string s , a , b ; while ( cin >> s >> a >> b ) { bool isok [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < 2 ; i ++ ) { int idx = s . find ( a ) ; if ( idx != string :: npos ) { idx = s . find ( b , idx + a . size ( ) ) ; if ( idx != string :: npos ) isok [ i ] = 1 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } if ( isok [ 0 ] && isok [ 1 ] ) cout << " both " << endl ; else if ( isok [ 0 ] ) cout << " forward " << endl ; else if ( isok [ 1 ] ) cout << " backward " << endl ; else cout << " fantasy " << endl ; } return 0 ; } int main ( ) { string s , a , b ; while ( cin >> s >> a >> b ) { bool isok [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < 2 ; i ++ ) { int idx = s . find ( a ) ; if ( idx != string :: npos ) { idx = s . find ( b , idx + a . size ( ) ) ; if ( idx != string :: npos ) isok [ i ] = 1 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } if ( isok [ 0 ] && isok [ 1 ] ) cout << " both " << endl ; else if ( isok [ 0 ] ) cout << " forward " << endl ; else if ( isok [ 1 ] ) cout << " backward " << endl ; else cout << " fantasy " << endl ; } return 0 ; }
TAB1 n , c , a and counter are integers with a and counter = 0 , arr is array of integers of size 101 ; TAB1 boolean flag = true ; TAB1 read n ; TAB1 if n is equal to 1 ; TAB2 print " NO " and a new line ; TAB1 read n values into arr ; TAB1 sort arr ; TAB1 set c to arr [ 0 ] ; TAB1 for x = n to 0 decreasing x ; TAB2 if arr [ x ] is equal to arr [ x - 1 ] ; TAB3 flag = false ; TAB3 increment counter ; TAB1 if flag is false and counter is equal to n - 1 ; TAB2 print " NO " and a new line ; TAB1 while true ; TAB2 if arr [ a ] ! = arr [ a + 1 ] ; TAB3 set value of c to arr [ a + 1 ] ; TAB3 break the loop ; TAB2 increase a by one ; TAB1 print c and a new line ; TAB1 create integers n , c , a , counter with a = 0 , counter = 0 , create integer array arr of size 101 ; TAB1 create boolean flag with flag = true ; TAB1 read n ; TAB1 if n is 1 ; TAB2 print " NO " print newline ; TAB1 for x = 0 to n exclusive , read arr [ x ] ; TAB1 sort elements from arr to arr + n ; TAB1 set c to arr [ 0 ] ; TAB1 for x = n to 0 exclusive , decrementing x ; TAB2 if arr [ x ] is arr [ x - 1 ] ; TAB3 set flag to false ; TAB3 increment counter ; TAB1 if flag is false and counter is n - 1 ; TAB2 print " NO " print newline ; TAB1 while true ; TAB2 if arr [ a ] is not arr [ a + 1 ] ; TAB3 set c to arr [ a + 1 ] ; TAB3 break loop ; TAB2 increment a ; TAB1 print c print newline ;	int main ( ) { int n , arr [ 101 ] , c , a = 0 , counter = 0 ; bool flag = true ; cin >> n ; if ( n == 1 ) { cout << " NO " << endl ; return 0 ; } for ( int x = 0 ; x < n ; x ++ ) cin >> arr [ x ] ; sort ( arr , arr + n ) ; c = arr [ 0 ] ; for ( int x = n ; x > 0 ; x -- ) { if ( arr [ x ] == arr [ x - 1 ] ) { flag = false ; counter ++ ; } } if ( flag == false && counter == n - 1 ) { cout << " NO " << endl ; return 0 ; } while ( true ) { if ( arr [ a ] != arr [ a + 1 ] ) { c = arr [ a + 1 ] ; break ; } a ++ ; } cout << c << endl ; return 0 ; } int main ( ) { int n , arr [ 101 ] , c , a = 0 , counter = 0 ; bool flag = true ; cin >> n ; if ( n == 1 ) { cout << " NO " << endl ; return 0 ; } for ( int x = 0 ; x < n ; x ++ ) cin >> arr [ x ] ; sort ( arr , arr + n ) ; c = arr [ 0 ] ; for ( int x = n ; x > 0 ; x -- ) { if ( arr [ x ] == arr [ x - 1 ] ) { flag = false ; counter ++ ; } } if ( flag == false && counter == n - 1 ) { cout << " NO " << endl ; return 0 ; } while ( true ) { if ( arr [ a ] != arr [ a + 1 ] ) { c = arr [ a + 1 ] ; break ; } a ++ ; } cout << c << endl ; return 0 ; }
TAB1 declare an integer t ; TAB1 read a value into t ; TAB1 declare a set of integers called st ; TAB1 declare an integer n ; TAB1 do the following t times : ; TAB2 read a value into n ; TAB2 insert the value n into the set st ; TAB1 declare a set iterator it ; TAB1 declare a value l which is equal to the size of st ; TAB1 If l is 1 ; TAB2 output NO and a newline ; TAB1 If l is any other value : ; TAB2 set it equal to an iterator ; TAB2 add one to it ; TAB2 output the values of the set ; TAB1 create integer t ; TAB1 read t ; TAB1 create integer set st ; TAB1 create integer n ; TAB1 for i = 0 to t exclusive ; TAB2 read n ; TAB2 insert n into st ; TAB1 create integer set iterator it ; TAB1 create integer l with l = size of st ; TAB1 if l is 1 ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 set it to beginning of st ; TAB2 increment it ; TAB2 print value of it print newline ;	int main ( ) { int t ; cin >> t ; set < int > st ; int n ; for ( int i = 0 ; i < t ; i ++ ) { cin >> n ; st . insert ( n ) ; } set < int > :: iterator it ; int l = st . size ( ) ; if ( l == 1 ) cout << " NO " << endl ; else { it = st . begin ( ) ; it ++ ; cout << * it << endl ; } return 0 ; } int main ( ) { int t ; cin >> t ; set < int > st ; int n ; for ( int i = 0 ; i < t ; i ++ ) { cin >> n ; st . insert ( n ) ; } set < int > :: iterator it ; int l = st . size ( ) ; if ( l == 1 ) cout << " NO " << endl ; else { it = st . begin ( ) ; it ++ ; cout << * it << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create integer set s ; TAB1 for i = 0 to n exclusive ; TAB2 create integer b ; TAB2 read b ; TAB2 insert b into s ; TAB1 if size of s is 1 ; TAB2 print " NO " print newline ; TAB1 create integer set iterator rit with rit = beginning of s ; TAB1 remove value of rit from s ; TAB1 print value of beginning of s print newline ; TAB1 n = integer ; TAB1 read n ; TAB1 s = set of integers ; TAB1 for integer i = 0 to n exclusive ; TAB2 let b be integer ; TAB2 read b ; TAB2 insert b into s ; TAB1 if length of s is 1 ; TAB2 print " NO " and a new line ; TAB1 rit = set iterator pointing at the first element of s ; TAB1 erase element of s at rit ; TAB1 print first element of s and a new line ;	int main ( ) { int n ; cin >> n ; set < int > s ; for ( int i = 0 ; i < n ; ++ i ) { int b ; cin >> b ; s . insert ( b ) ; } if ( s . size ( ) == 1 ) { cout << " NO " << endl ; return 0 ; } set < int > :: iterator rit = s . begin ( ) ; s . erase ( * rit ) ; cout << * ( s . begin ( ) ) << endl ; return 0 ; } int main ( ) { int n ; cin >> n ; set < int > s ; for ( int i = 0 ; i < n ; ++ i ) { int b ; cin >> b ; s . insert ( b ) ; } if ( s . size ( ) == 1 ) { cout << " NO " << endl ; return 0 ; } set < int > :: iterator rit = s . begin ( ) ; s . erase ( * rit ) ; cout << * ( s . begin ( ) ) << endl ; return 0 ; }
TAB1 create integers n , i , k ; TAB1 create integer array a with size 105 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 sort elements from a to a + n ; TAB1 set k to 1 ; TAB1 for i = 1 to n exclusive ; TAB2 if a [ i ] is not a [ i - 1 ] , increment k ; TAB2 if k is 2 ; TAB3 print a [ i ] print newline ; TAB1 print " NO " print newline ; TAB1 create integers n , i and k ; TAB1 a = array of integers of length 105 ; TAB1 read n ; TAB1 read n values into array a ; TAB1 sort a ; TAB1 set k to 1 ; TAB1 for i = 1 to n exclusive ; TAB2 if a [ i ] ! = a [ i - 1 ] increment k ; TAB2 if k is equal to 2 ; TAB3 print a [ i ] and a new line ; TAB1 print " NO " and a new line ;	int main ( ) { int n , i , k ; int a [ 105 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; k = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) k ++ ; if ( k == 2 ) { cout << a [ i ] << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; } int main ( ) { int n , i , k ; int a [ 105 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; k = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) k ++ ; if ( k == 2 ) { cout << a [ i ] << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; }
TAB0 create integers n , a , cnr , with cnr = 0 , create integer array p of size 201 ; TAB1 read n ; TAB1 while decrementing n is true ; TAB2 read a ; TAB2 increment p [ a + 100 ] ; TAB1 for i = 0 to 200 inclusive ; TAB2 if p [ i ] is true , increment cnr ; TAB2 if cnr is 2 ; TAB3 print i - 100 print newline ; TAB1 print " NO " print newline ; TAB1 end statement ; TAB0 n , a and cnr are integers with cnt = 0 , p = array of integers with size 201 ; TAB1 read n ; TAB1 while n - - ; TAB2 read a ; TAB2 increment p [ a + 100 ] ; TAB1 for i = 0 to 200 inclusive ; TAB2 if p [ i ] is true , increment cnr ; TAB2 if cnr is equal to 2 ; TAB3 print i - 100 and a new line ; TAB1 print " NO " and a new line ; TAB1 ; ;	int n , a , cnr = 0 , p [ 201 ] ; int main ( ) { cin >> n ; while ( n -- ) { cin >> a ; p [ a + 100 ] ++ ; } for ( int i = 0 ; i <= 200 ; i ++ ) { if ( p [ i ] ) cnr ++ ; if ( cnr == 2 ) { cout << i - 100 << endl ; return 0 ; } } cout << " NO " << endl ; ; return 0 ; } int n , a , cnr = 0 , p [ 201 ] ; int main ( ) { cin >> n ; while ( n -- ) { cin >> a ; p [ a + 100 ] ++ ; } for ( int i = 0 ; i <= 200 ; i ++ ) { if ( p [ i ] ) cnr ++ ; if ( cnr == 2 ) { cout << i - 100 << endl ; return 0 ; } } cout << " NO " << endl ; ; return 0 ; }
TAB1 x = integer ; TAB1 read x ; TAB1 num = integer ; TAB1 let arr be an array of integers of size 201 ; TAB1 for integer i = 0 to 201 exclusive arr [ i ] = 900 ; TAB1 create integer count with value 0 ; TAB1 for i = 0 to x exclusive ; TAB2 read num ; TAB2 if arr [ num + 100 ] is 900 increment count ; TAB2 arr [ num + 100 ] = num ; TAB1 if count is < = 1 ; TAB2 print " NO " and a new line ; TAB1 else ; TAB2 create integer cursor with value 1 ; TAB2 for integer i = 0 to 201 exclusive ; TAB3 if cursor is 2 and arr [ i ] is not 900 ; TAB4 print arr [ i ] and a new line ; TAB3 else if arr [ i ] ! = 900 ; TAB4 increase cursor ; TAB1 create integer x ; TAB1 read x ; TAB1 create integer num ; TAB1 create integer array arr of size 201 ; TAB1 for i = 0 to 201 exclusive , set arr [ i ] to 900 ; TAB1 create integer count with count = 0 ; TAB1 for i = 0 to x exclusive ; TAB2 read num ; TAB2 if arr [ num + 100 ] is 900 , increment count ; TAB2 set arr [ num + 100 ] to num ; TAB1 if count is less than or equal to 1 ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 create integer cursor with cursor = 1 ; TAB2 for i = 0 to 201 exclusive ; TAB3 if cursor is 2 and arr [ i ] is not 900 ; TAB4 print arr [ i ] print newline ; TAB3 else if arr [ i ] is not 900 ; TAB4 increment cursor ;	int main ( ) { int x ; cin >> x ; int num ; int arr [ 201 ] ; for ( int i = 0 ; i < 201 ; i ++ ) arr [ i ] = 900 ; int count = 0 ; for ( int i = 0 ; i < x ; i ++ ) { cin >> num ; if ( arr [ num + 100 ] == 900 ) count ++ ; arr [ num + 100 ] = num ; } if ( count <= 1 ) cout << " NO " << endl ; else { int cursor = 1 ; for ( int i = 0 ; i < 201 ; i ++ ) { if ( cursor == 2 && arr [ i ] != 900 ) { cout << arr [ i ] << endl ; return 0 ; } else if ( arr [ i ] != 900 ) { cursor ++ ; } } } return 0 ; } int main ( ) { int x ; cin >> x ; int num ; int arr [ 201 ] ; for ( int i = 0 ; i < 201 ; i ++ ) arr [ i ] = 900 ; int count = 0 ; for ( int i = 0 ; i < x ; i ++ ) { cin >> num ; if ( arr [ num + 100 ] == 900 ) count ++ ; arr [ num + 100 ] = num ; } if ( count <= 1 ) cout << " NO " << endl ; else { int cursor = 1 ; for ( int i = 0 ; i < 201 ; i ++ ) { if ( cursor == 2 && arr [ i ] != 900 ) { cout << arr [ i ] << endl ; return 0 ; } else if ( arr [ i ] != 900 ) { cursor ++ ; } } } return 0 ; }
TAB1 let s be a unique set of integers ; TAB1 let itr be set iterator ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 let x be integer ; TAB2 read x ; TAB2 insert x into s ; TAB1 if length of s is equal to 1 ; TAB2 print " NO " and a new line ; TAB1 set itr to the beginning of s ; TAB1 increase itr ; TAB1 print * itr and a new line ;	int main ( ) { set < int > s ; set < int > :: iterator itr ; int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; s . insert ( x ) ; } if ( s . size ( ) == 1 ) { cout << " NO " << endl ; return 0 ; } itr = s . begin ( ) ; itr ++ ; cout << * itr << endl ; return 0 ; }
TAB1 create integers n , i , j ; TAB1 while read n is true ; TAB2 create integer arrays a , b , with a size 500 , b size 500 , with a = { 0 } , b = { 0 } , create integers flog initialized with 0 , e , k initialized with 0 , f ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] is a [ 0 ] ; TAB4 set flog to flog ; TAB3 else ; TAB4 set flog to flag + 1 ; TAB2 if flog is 0 ; TAB3 print " NO " print newline ; TAB2 else ; TAB3 for i = 0 to n exclusive ; TAB4 for j = 1 to n - i exclusive ; TAB5 if a [ j ] is less than a [ j - 1 ] ; TAB6 set e to a [ j - 1 ] ; TAB6 set a [ j - 1 ] to a [ j ] ; TAB6 set a [ j ] to e ; TAB3 for i = 0 to n - 1 exclusive ; TAB4 for f = i + 1 to n exclusive ; TAB5 if a [ f ] is a [ i ] ; TAB6 for k = i to n exclusive , set a [ k ] to a [ k + 1 ] ; TAB6 decrement n ; TAB6 decrement f ; TAB3 if n is 2 ; TAB4 print a [ 1 ] print newline ; TAB3 else ; TAB4 print a [ 1 ] print newline ;	int main ( ) { int n , i , j ; while ( cin >> n ) { int a [ 500 ] = { 0 } , flog ( 0 ) , e , k ( 0 ) , f , b [ 500 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ 0 ] ) { flog = flog ; } else { flog = flog + 1 ; } } if ( flog == 0 ) { cout << " NO " << endl ; } else { for ( i = 0 ; i < n ; i ++ ) { for ( j = 1 ; j < n - i ; j ++ ) { if ( a [ j ] < a [ j - 1 ] ) { e = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = e ; } } } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( f = i + 1 ; f < n ; f ++ ) { if ( a [ f ] == a [ i ] ) { for ( k = i ; k < n ; k ++ ) { a [ k ] = a [ k + 1 ] ; } n -- ; f -- ; } } } if ( n == 2 ) { cout << a [ 1 ] << endl ; } else { cout << a [ 1 ] << endl ; } } } }
TAB0 create integer n ; TAB0 create integer array a with size 110 ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 for i = 1 to n exclusive ; TAB2 for j = i + 1 to n inclusive ; TAB3 if a [ i ] is greater than a [ j ] , swap values of a [ i ] and a [ j ] ; TAB1 for i = 2 to n inclusive ; TAB2 if a [ i ] is not a [ i - 1 ] ; TAB3 print a [ i ] print newline ; TAB1 print " NO " print newline ; TAB0 declare integer variable n ; TAB0 let a be an array of integers of size 110 ; TAB1 read n ; TAB1 for i = 1 to n inclusive read a [ i ] ; TAB1 for i = 1 to n exclusive ; TAB2 for j = i + 1 to n inclusive ; TAB3 if a [ i ] is greater than a [ j ] , swap a [ i ] and a [ j ] ; TAB1 for integer i = 2 to n inclusive ; TAB2 if a [ i ] ! = a [ i - 1 ] ; TAB3 print a [ i ] and a new line ; TAB1 print " NO " and a new line ;	int n ; int a [ 110 ] ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) { if ( a [ i ] > a [ j ] ) swap ( a [ i ] , a [ j ] ) ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { cout << a [ i ] << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; } int n ; int a [ 110 ] ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) { if ( a [ i ] > a [ j ] ) swap ( a [ i ] , a [ j ] ) ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { cout << a [ i ] << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; }
TAB0 create integers a and cnr ; TAB0 let p be an array of booleans of size 201 ; TAB1 let n be integer ; TAB1 read n ; TAB1 while n - - ; TAB2 read a ; TAB2 increment p [ a + 100 ] ; TAB1 for i = 0 to 200 inclusive ; TAB2 if p [ i ] is true , increment cnr ; TAB2 if cnr is 2 ; TAB3 print i - 100 and a new line ; TAB1 print " NO " and a new line ; TAB1 ; ; TAB0 create integers a , cnr ; TAB0 create boolean array p of size 201 ; TAB1 create integer n ; TAB1 read n ; TAB1 while decrementing n ; TAB2 read a ; TAB2 increment p [ a + 100 ] ; TAB1 for i = 0 to 200 inclusive ; TAB2 if p [ i ] is true , increment cnr ; TAB2 if cnr is 2 ; TAB3 print i - 100 print newline ; TAB1 print " NO " print newline ; TAB1 end statement ;	int a , cnr ; bool p [ 201 ] ; int main ( ) { int n ; cin >> n ; while ( n -- ) { cin >> a ; p [ a + 100 ] ++ ; } for ( int i = 0 ; i <= 200 ; i ++ ) { if ( p [ i ] ) cnr ++ ; if ( cnr == 2 ) { cout << i - 100 << endl ; return 0 ; } } cout << " NO " << endl ; ; return 0 ; } int a , cnr ; bool p [ 201 ] ; int main ( ) { int n ; cin >> n ; while ( n -- ) { cin >> a ; p [ a + 100 ] ++ ; } for ( int i = 0 ; i <= 200 ; i ++ ) { if ( p [ i ] ) cnr ++ ; if ( cnr == 2 ) { cout << i - 100 << endl ; return 0 ; } } cout << " NO " << endl ; ; return 0 ; }
TAB0 let a be an array of booleans of size 205 ; TAB0 define function solve ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 v = vector of integers ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare integer variable x ; TAB2 read x ; TAB2 increase x by 100 ; TAB2 if a [ x ] is false ; TAB3 add x to the end of v ; TAB3 set a [ x ] to true ; TAB1 sort v ; TAB1 if size of v is 1 ; TAB2 print " NO " and a new line ; TAB2 return ; TAB1 else ; TAB2 print v [ 1 ] - 100 and a new line ; TAB1 invoke function solve ; TAB0 create boolean array a with size 205 ; TAB0 declare solve with no arguments , returning void ; TAB1 create integer n ; TAB1 read n ; TAB1 create integer vector v ; TAB1 for i = 0 to n exclusive ; TAB2 create integer x ; TAB2 read x ; TAB2 increment x b y 100 ; TAB2 if a [ x ] is false ; TAB3 add element x to end of v ; TAB3 set a [ x ] to true ; TAB1 sort elements from beginning of v to end of v ; TAB1 if size of v is 1 ; TAB2 print " NO " print newline ; TAB2 return from function ; TAB1 else ; TAB2 print v [ 1 ] - 100 print newline ; TAB1 run solve ;	bool a [ 205 ] ; void solve ( ) { int n ; cin >> n ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; x += 100 ; if ( a [ x ] == false ) { v . push_back ( x ) ; a [ x ] = true ; } } sort ( v . begin ( ) , v . end ( ) ) ; if ( v . size ( ) == 1 ) { cout << " NO " << endl ; return ; } else cout << v [ 1 ] - 100 << endl ; } int main ( ) { solve ( ) ; return 0 ; } bool a [ 205 ] ; void solve ( ) { int n ; cin >> n ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; x += 100 ; if ( a [ x ] == false ) { v . push_back ( x ) ; a [ x ] = true ; } } sort ( v . begin ( ) , v . end ( ) ) ; if ( v . size ( ) == 1 ) { cout << " NO " << endl ; return ; } else cout << v [ 1 ] - 100 << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB0 create integers n , x ; TAB0 create integer set s ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read x ; TAB2 insert x into s ; TAB1 remove beginning of s from s ; TAB1 if s is empty ; TAB2 print " NO " ; TAB1 else ; TAB2 print value of beginning of s print newline ;	int n , x ; set < int > s ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x ; s . insert ( x ) ; } s . erase ( s . begin ( ) ) ; if ( s . empty ( ) ) puts ( " NO " ) ; else cout << * s . begin ( ) << endl ; return 0 ; }
TAB1 n and i are integers , arr is an array of integers of size 100 ; TAB1 read n ; TAB1 read n elements into arr ; TAB1 sort array arr ; TAB1 if arr [ 0 ] = arr [ n - 1 ] or n is equal to 1 ; TAB2 print " NO \ n " ; TAB1 i = 1 ; TAB1 while arr [ i ] is equal to arr [ 0 ] ; TAB1 print arr [ i ] and " \ n " ; TAB1 create integers n , i , create integer array arr with size 100 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 sort elements from arr to arr + n ; TAB1 if arr [ 0 ] is arr [ n - 1 ] or n is 1 ; TAB2 print " NO \ n " ; TAB1 set i to 1 ; TAB1 while arr [ i ] is arr [ 0 ] , increment i ; TAB1 print arr [ i ] print " \ n " ;	int main ( ) { int n , arr [ 100 ] , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> arr [ i ] ; sort ( arr , arr + n ) ; if ( arr [ 0 ] == arr [ n - 1 ] || n == 1 ) { cout << " NO\n " ; return 0 ; } i = 1 ; while ( arr [ i ] == arr [ 0 ] ) i ++ ; cout << arr [ i ] << " \n " ; return 0 ; } int main ( ) { int n , arr [ 100 ] , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> arr [ i ] ; sort ( arr , arr + n ) ; if ( arr [ 0 ] == arr [ n - 1 ] || n == 1 ) { cout << " NO\n " ; return 0 ; } i = 1 ; while ( arr [ i ] == arr [ 0 ] ) i ++ ; cout << arr [ i ] << " \n " ; return 0 ; }
TAB0 declare integer variable n ; TAB0 ns = array of integers of size 100 ; TAB1 read n ; TAB1 read n values into ns ; TAB1 sort ns ; TAB1 i and ans are integers with i = 0 and ans = ns [ 0 ] ; TAB1 while i is less than n ; TAB2 if ns [ i ] ! = ns [ 0 ] ; TAB3 assign value of ns [ i ] to the ans ; TAB3 break the loop ; TAB2 else ; TAB3 increase i ; TAB1 if ans ! = ns [ 0 ] ; TAB2 print ans and a new line ; TAB1 else ; TAB2 print " NO " and a new line ;	int n ; int ns [ 100 ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> ns [ i ] ; } sort ( ns , ns + n ) ; int i = 0 , ans = ns [ 0 ] ; while ( i < n ) { if ( ns [ i ] != ns [ 0 ] ) { ans = ns [ i ] ; break ; } else { i ++ ; } } if ( ans != ns [ 0 ] ) cout << ans << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 create integer set s ; TAB1 create integer n ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 create integer k ; TAB2 read k ; TAB2 insert k into s ; TAB1 remove beginning of s from s ; TAB1 if s is empty ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 print value of beginning of s print newline ;	int main ( ) { set < int > s ; int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int k ; cin >> k ; s . insert ( k ) ; } s . erase ( s . begin ( ) ) ; if ( s . empty ( ) ) { cout << " NO " << endl ; } else { cout << * s . begin ( ) << endl ; } return 0 ; }
TAB1 let n be integer ; TAB1 read n ; TAB1 x = integer ; TAB1 let v be a vector of integers ; TAB1 let m be a map from integer to boolean ; TAB1 for integer i = 1 to n inclusive ; TAB2 read x ; TAB2 if m [ x ] is false ; TAB3 push x to the end of v ; TAB3 assign value of 1 to the m [ x ] ; TAB1 sort v ; TAB1 if length of v is greater than 1 ; TAB2 print v [ 1 ] and a new line ; TAB1 else ; TAB2 print " NO " and a new line ;	int main ( ) { int n ; cin >> n ; int x ; vector < int > v ; map < int , bool > m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x ; if ( ! m [ x ] ) { v . push_back ( x ) ; m [ x ] = 1 ; } } sort ( v . begin ( ) , v . end ( ) ) ; if ( v . size ( ) > 1 ) { cout << v [ 1 ] << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 create integers n , x ; TAB1 read n ; TAB1 create integer arr [ n ] ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 create integer set s initialized with arr , arr + n ; TAB1 create integer set iterator ; TAB1 set it to beginning of s ; TAB1 if increment it is end of s ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 print value of it print newline ; TAB1 create integers n and x ; TAB1 read n ; TAB1 arr = array of integers of length n ; TAB1 read n values into arr ; TAB1 s = set of integers ; TAB1 let it = set iterator ; TAB1 set it = to the beginning of s ; TAB1 if incremented it is at the end of s ; TAB2 print " NO " and a new line ; TAB1 else ; TAB2 print value at the it and a new line ;	int main ( ) { int n , x ; cin >> n ; int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } set < int > s ( arr , arr + n ) ; set < int > :: iterator it ; it = s . begin ( ) ; if ( ++ it == s . end ( ) ) cout << " NO " << endl ; else cout << * it << endl ; } int main ( ) { int n , x ; cin >> n ; int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } set < int > s ( arr , arr + n ) ; set < int > :: iterator it ; it = s . begin ( ) ; if ( ++ it == s . end ( ) ) cout << " NO " << endl ; else cout << * it << endl ; }
TAB1 create doubles x and y ; TAB1 read x and y ; TAB1 assign square root of x * x + y * y to the double variable raw ; TAB1 let int p_sign be 1 if x * y > 0 , or 0 if it is not ; TAB1 set integer d_raw to square root of x * x + y * y ; TAB1 integer color = ( d_raw % 2 ) + p_sign ; TAB1 if raw is a whole number ; TAB2 print " black " and a new line ; TAB1 else ; TAB2 print " white " if color is even , " black " if color is odd , and a new line ; TAB1 create doubles x , y ; TAB1 read x read y ; TAB1 create double raw with raw = square root of ( x * x + y * y ) ; TAB1 create integer p_sign with p_sign = 1 if x * y is greater than 0 , else 0 ; TAB1 create integer d_raw with d_raw = integer casted square root of ( x * x + y * y ) ; TAB1 create integer color with color = ( d_raw % 2 ) + p_sign ; TAB1 if raw - integer casted raw is 0 ; TAB2 print " black " print newline ; TAB1 else ; TAB2 print " white " if color % 2 is 0 , else " black " , print newline ;	int main ( ) { double x , y ; cin >> x >> y ; double raw = sqrt ( x * x + y * y ) ; int p_sign = ( x * y > 0 ? 1 : 0 ) ; int d_raw = ( int ) sqrt ( x * x + y * y ) ; int color = ( d_raw % 2 ) + p_sign ; if ( raw - ( int ) raw == 0 ) cout << " black " << endl ; else cout << ( ( color % 2 == 0 ) ? " white " : " black " ) << endl ; return 0 ; } int main ( ) { double x , y ; cin >> x >> y ; double raw = sqrt ( x * x + y * y ) ; int p_sign = ( x * y > 0 ? 1 : 0 ) ; int d_raw = ( int ) sqrt ( x * x + y * y ) ; int color = ( d_raw % 2 ) + p_sign ; if ( raw - ( int ) raw == 0 ) cout << " black " << endl ; else cout << ( ( color % 2 == 0 ) ? " white " : " black " ) << endl ; return 0 ; }
TAB1 declare int_64_t x and y ; TAB1 read x and y ; TAB1 set int64_t rs to x * x + y * y ; TAB1 set int64_t r to the square root of rs ; TAB1 if r * r = rs | | x = 0 | | y = 0 ; TAB2 print " black \ n " ; TAB1 else ; TAB2 integer parity = r % 2 ; TAB2 if x * y > = 0 ; TAB3 if parity is 1 ; TAB4 print " white \ n " ; TAB3 else ; TAB4 print " black \ n " ; TAB2 else ; TAB3 if parity is 1 ; TAB4 print " black \ n " ; TAB3 else ; TAB4 print " white \ n " ;	int main ( ) { int64_t x , y ; cin >> x >> y ; int64_t rs = x * x + y * y ; int64_t r = int64_t ( sqrt ( double ( rs ) ) ) ; if ( r * r == rs || x == 0 || y == 0 ) { cout << " black\n " ; } else { int parity = r % 2 ; if ( x * y >= 0 ) { if ( parity ) { cout << " white\n " ; } else { cout << " black\n " ; } } else { if ( parity ) { cout << " black\n " ; } else { cout << " white\n " ; } } } }
TAB1 create integers x and y ; TAB1 read x and y ; TAB1 create double r with value x * x + y * y ; TAB1 set r to square root of r ; TAB1 intpart = double ; TAB1 if modf ( r , & intpart ) is equal to 0 . 0 ; TAB2 print " black " and a new line ; TAB1 else ; TAB2 create integer int_r = floor of r ; TAB2 if ( x > 0 and y > 0 ) and ( int_r is even ) print " black " and a new line ; TAB2 if ( x < 0 and y < 0 ) and ( int_r is even ) ; TAB3 print " black " and a new line ; TAB2 else if ( x < 0 and y > 0 ) and ( int_r is even ) ; TAB3 print " white " and a new line ; TAB2 else if ( x > 0 and y < 0 ) and ( int_r is even ) ; TAB3 print " white " and a new line ; TAB2 else if ( x > 0 & & y is greater than 0 ) & & ( int_r is odd ) ; TAB3 print " white " and a new line ; TAB2 else if ( x < 0 & & y is less than 0 ) & & ( int_r is odd ) ; TAB3 print " white " and a new line ; TAB2 else if ( x > 0 and y is less than 0 ) and ( int_r is odd ) ; TAB3 print " black " and a new line ; TAB2 else if ( x < 0 & & y is greater than 0 ) & & ( int_r is odd ) ; TAB3 print " black " and a new line ; TAB1 create integers x , y ; TAB1 read x read y ; TAB1 create double r with r = x * x + y * y ; TAB1 set r to square root of r ; TAB1 create double intpart ; TAB1 if result of break r into integer and fraction , storing integer in address of intpart is 0 . 0 ; TAB2 print " black " print newline ; TAB1 else ; TAB2 create integer int_r with int_r = static casted integer rounded down r ; TAB2 if ( x is greater than 0 and y is greater than 0 ) and ( int_r % 2 is 0 ) , print " black " print newline ; TAB2 if ( x is less than 0 and y is less than 0 ) and ( int_r % 2 ) is 0 ; TAB3 print " black " print newline ; TAB2 else if ( x is less than 0 and y is greater than 0 ) and ( int_r % 2 is 0 ) ; TAB3 print " white " print newline ; TAB2 else if ( x is greater than 0 and y is less than 0 ) and ( int_r % 2 is 0 ) ; TAB3 print " white " print newline ; TAB2 else if ( x is greater than 0 and y is greater than 0 ) and ( int_r % 2 is not 0 ) ; TAB3 print " white " print newline ; TAB2 else if ( x is less than 0 and y is less than 0 ) and ( int_r % 2 is not 0 ) ; TAB3 print " white " print newline ; TAB2 else if ( x is greater than 0 and y is less than 0 ) and ( int_r % 2 is not 0 ) ; TAB3 print " black " print newline ; TAB2 else if ( x is less than 0 and y is greater than 0 ) and ( int_r % 2 is not 0 ) ; TAB3 print " black " print newline ;	int main ( ) { int x , y ; cin >> x >> y ; double r = x * x + y * y ; r = sqrt ( r ) ; double intpart ; if ( modf ( r , & intpart ) == 0.0 ) { cout << " black " << endl ; } else { int int_r = static_cast < int > ( floor ( r ) ) ; if ( ( x > 0 && y > 0 ) && ( int_r % 2 == 0 ) ) { cout << " black " << endl ; } if ( ( x < 0 && y < 0 ) && ( int_r % 2 == 0 ) ) { cout << " black " << endl ; } else if ( ( x < 0 && y > 0 ) && ( int_r % 2 == 0 ) ) { cout << " white " << endl ; } else if ( ( x > 0 && y < 0 ) && ( int_r % 2 == 0 ) ) { cout << " white " << endl ; } else if ( ( x > 0 && y > 0 ) && ( int_r % 2 != 0 ) ) { cout << " white " << endl ; } else if ( ( x < 0 && y < 0 ) && ( int_r % 2 != 0 ) ) { cout << " white " << endl ; } else if ( ( x > 0 && y < 0 ) && ( int_r % 2 != 0 ) ) { cout << " black " << endl ; } else if ( ( x < 0 && y > 0 ) && ( int_r % 2 != 0 ) ) { cout << " black " << endl ; } } return 0 ; } int main ( ) { int x , y ; cin >> x >> y ; double r = x * x + y * y ; r = sqrt ( r ) ; double intpart ; if ( modf ( r , & intpart ) == 0.0 ) { cout << " black " << endl ; } else { int int_r = static_cast < int > ( floor ( r ) ) ; if ( ( x > 0 && y > 0 ) && ( int_r % 2 == 0 ) ) { cout << " black " << endl ; } if ( ( x < 0 && y < 0 ) && ( int_r % 2 == 0 ) ) { cout << " black " << endl ; } else if ( ( x < 0 && y > 0 ) && ( int_r % 2 == 0 ) ) { cout << " white " << endl ; } else if ( ( x > 0 && y < 0 ) && ( int_r % 2 == 0 ) ) { cout << " white " << endl ; } else if ( ( x > 0 && y > 0 ) && ( int_r % 2 != 0 ) ) { cout << " white " << endl ; } else if ( ( x < 0 && y < 0 ) && ( int_r % 2 != 0 ) ) { cout << " white " << endl ; } else if ( ( x > 0 && y < 0 ) && ( int_r % 2 != 0 ) ) { cout << " black " << endl ; } else if ( ( x < 0 && y > 0 ) && ( int_r % 2 != 0 ) ) { cout << " black " << endl ; } } return 0 ; }
TAB0 create constant integer M with value 1000 + 5 ; TAB1 x and y = integers ; TAB1 read x and y ; TAB1 assign value 0 to the integer r ; TAB1 increment r while x * x + y * y is greater than r * r ; TAB1 if x or y are equal to 0 ; TAB2 print " black " and a new line ; TAB1 else ; TAB2 if x * x + y * y is equal to r * r ; TAB3 print " black " and a new line ; TAB2 else ; TAB3 if r is even ; TAB4 if x * y is greater than 0 ; TAB5 print " white " and a new line ; TAB4 else ; TAB5 print " black " and a new line ; TAB3 else ; TAB4 if x * y is greater than 0 ; TAB5 print " black " and a new line ; TAB4 else ; TAB5 print " white " and a new line ; TAB0 create constant integer M with M = 1000 + 5 ; TAB1 create integers x , y ; TAB1 read x read y ; TAB1 create integer r with r = 0 ; TAB1 while x * x + y * y is greater than r * r , increment r ; TAB1 if x is 0 or y is 0 ; TAB2 print " black " print newline ; TAB1 else ; TAB2 if x * x + y * y is r * r ; TAB3 print " black " print newline ; TAB2 else ; TAB3 if r % 2 is 0 ; TAB4 if x * y is greater than 0 ; TAB5 print " white " print newline ; TAB4 else ; TAB5 print " black " print newline ; TAB3 else ; TAB4 if x * y is greater than 0 ; TAB5 print " black " print newline ; TAB4 else ; TAB5 print " white " print newline ;	const int M = 1000 + 5 ; int main ( ) { int x , y ; cin >> x >> y ; int r = 0 ; while ( x * x + y * y > r * r ) { r ++ ; } if ( x == 0 || y == 0 ) { cout << " black " << endl ; } else { if ( x * x + y * y == r * r ) { cout << " black " << endl ; } else { if ( r % 2 == 0 ) { if ( x * y > 0 ) { cout << " white " << endl ; } else { cout << " black " << endl ; } } else { if ( x * y > 0 ) { cout << " black " << endl ; } else { cout << " white " << endl ; } } } } return 0 ; } const int M = 1000 + 5 ; int main ( ) { int x , y ; cin >> x >> y ; int r = 0 ; while ( x * x + y * y > r * r ) { r ++ ; } if ( x == 0 || y == 0 ) { cout << " black " << endl ; } else { if ( x * x + y * y == r * r ) { cout << " black " << endl ; } else { if ( r % 2 == 0 ) { if ( x * y > 0 ) { cout << " white " << endl ; } else { cout << " black " << endl ; } } else { if ( x * y > 0 ) { cout << " black " << endl ; } else { cout << " white " << endl ; } } } } return 0 ; }
TAB1 create integers x and y ; TAB1 read x and y ; TAB1 set integer d to x * x + y * y ; TAB1 assign square root of d to the new integer sq ; TAB1 if sq * sq = d ; TAB2 print " black " and a new line ; TAB1 else if ( x > 0 and y > 0 ) or ( x < 0 and y is less than 0 ) ; TAB2 if sq & 1 ; TAB3 print " white " and a new line ; TAB2 else ; TAB3 print " black " and a new line ; TAB1 else ; TAB2 if sq & 1 ; TAB3 print " black " and a new line ; TAB2 else ; TAB3 print " white " and a new line ;	int main ( ) { int x , y ; cin >> x >> y ; int d = x * x + y * y ; int sq = sqrt ( d ) ; if ( sq * sq == d ) cout << " black " << endl ; else if ( ( x > 0 && y > 0 ) || ( x < 0 && y < 0 ) ) { if ( sq & 1 ) cout << " white " << endl ; else cout << " black " << endl ; } else { if ( sq & 1 ) cout << " black " << endl ; else cout << " white " << endl ; } return 0 ; }
TAB0 function f that returns boolean ; TAB1 declare integers called x and y ; TAB1 read x and y ; TAB1 if x or y = 0 return true ; TAB1 assign value of square root of x * x + y * y to the integer s ; TAB1 if s * s = x * x + y * y return true ; TAB1 if ( x * y > 0 ) = ( s % 2 = 0 ) return true ; TAB1 return false ; TAB1 if f ( ) is true ; TAB2 print " black " and a new line ; TAB1 else ; TAB2 print " white " and a new line ; TAB0 declare f with no arguments , returning boolean ; TAB1 create integers x , y ; TAB1 read x read y ; TAB1 if x is 0 or y is 0 , return true from function ; TAB1 create integer s with s = square root of ( x * x + y * y ) ; TAB1 if s * s is x * x + y * y , return true from function ; TAB1 if ( x * y is greater than 0 ) or ( s % 2 is 0 ) , return true from function ; TAB1 return false from function ; TAB1 if result of run f is true ; TAB2 print " black " print newline ; TAB1 else ; TAB2 print " white " print newline ;	bool f ( ) { int x , y ; cin >> x >> y ; if ( x == 0 || y == 0 ) { return true ; } int s = sqrt ( x * x + y * y ) ; if ( s * s == x * x + y * y ) { return true ; } if ( ( x * y > 0 ) == ( s % 2 == 0 ) ) { return true ; } return false ; } int main ( ) { if ( f ( ) ) { cout << " black " << endl ; } else { cout << " white " << endl ; } return 0 ; } bool f ( ) { int x , y ; cin >> x >> y ; if ( x == 0 || y == 0 ) { return true ; } int s = sqrt ( x * x + y * y ) ; if ( s * s == x * x + y * y ) { return true ; } if ( ( x * y > 0 ) == ( s % 2 == 0 ) ) { return true ; } return false ; } int main ( ) { if ( f ( ) ) { cout << " black " << endl ; } else { cout << " white " << endl ; } return 0 ; }
TAB1 create integers x and y ; TAB1 let n be double ; TAB1 read x and y ; TAB1 n = square root of x * x + y * y ; TAB1 if ceil ( n ) > n ; TAB2 if x * y > 0 is equal to ceil ( n ) casted to integer & 1 ; TAB3 print " black " and a new line ; TAB2 else ; TAB3 print " white " and a new line ; TAB1 else ; TAB2 print " black " and a new line ;	int main ( ) { int x , y ; double n ; cin >> x >> y ; n = sqrt ( x * x + y * y ) ; if ( ceil ( n ) > n ) { if ( x * y > 0 == ( ( ( int ) ( ceil ( n ) ) ) & 1 ) ) { cout << " black " << endl ; } else { cout << " white " << endl ; } } else { cout << " black " << endl ; } return 0 ; }
TAB1 let x and y be integers ; TAB1 read x and y ; TAB1 assign square root of x * x + y * y to the integer r ; TAB1 if r * r = x * x + y * y ; TAB2 print " black \ n " ; TAB1 if ( x > 0 and y > 0 ) or ( x < 0 and y is less than 0 ) ; TAB2 if r is odd ; TAB3 print " white \ n " ; TAB2 else ; TAB3 print " black \ n " ; TAB1 else ; TAB2 if r is odd ; TAB3 print " black \ n " ; TAB2 else ; TAB3 print " white \ n " ;	int main ( ) { int x , y ; cin >> x >> y ; int r = sqrt ( x * x + y * y ) ; if ( r * r == x * x + y * y ) { cout << " black\n " ; return 0 ; } if ( ( x > 0 && y > 0 ) || ( x < 0 && y < 0 ) ) { if ( r % 2 ) cout << " white\n " ; else cout << " black\n " ; } else { if ( r % 2 ) cout << " black\n " ; else cout << " white\n " ; } return 0 ; }
TAB1 declare integers called a and b ; TAB1 read a and b ; TAB1 integer cnt = ( ( a > 0 ) + ( b > 0 ) ) % 2 ; TAB1 integer d = a * a + b * b ; TAB1 for int i = 1 to infinity , increment i ; TAB2 if i * i is equal to d ; TAB3 print " black \ n " ; TAB2 if i * i is greater than d ; TAB3 integer ans = ( cnt + i ) % 2 ; TAB3 print " black \ n " if ans is 1 and " white \ n " otherwise ;	int main ( ) { int a , b ; cin >> a >> b ; int cnt = ( ( a > 0 ) + ( b > 0 ) ) % 2 ; int d = a * a + b * b ; for ( int i = 1 ; ; ++ i ) { if ( i * i == d ) { cout << " black\n " ; return 0 ; } if ( i * i > d ) { int ans = ( cnt + i ) % 2 ; cout << ( ans ? " black\n " : " white\n " ) ; return 0 ; } } return 0 ; }
TAB1 let x and y be integers ; TAB1 read x and y ; TAB1 double r = square root of 1 . 0 * x * x + y * y ; TAB1 assign value of r casted to int to the integer a ; TAB1 let b be integer ; TAB1 if r - a is greater than 0 ; TAB2 b = a + 1 ; TAB1 else ; TAB2 b = a ; TAB1 if x * y is greater than 0 ; TAB2 if b = a or a is even ; TAB3 print " black " and a new line ; TAB2 else ; TAB3 print " white " and a new line ; TAB1 else ; TAB2 if b = a or a is odd ; TAB3 print " black " and a new line ; TAB2 else ; TAB3 print " white " and a new line ;	int main ( ) { int x , y ; cin >> x >> y ; double r = sqrt ( 1.0 * x * x + y * y ) ; int a = ( int ) r ; int b ; if ( r - a > 0 ) b = a + 1 ; else b = a ; if ( x * y > 0 ) { if ( b == a || a % 2 == 0 ) cout << " black " << endl ; else cout << " white " << endl ; } else { if ( b == a || a % 2 != 0 ) cout << " black " << endl ; else cout << " white " << endl ; } return 0 ; }
TAB1 let x and y be doubles ; TAB1 read x and y ; TAB1 create double r with value of square root of x * x + y * y ; TAB1 set double s to floor of r ; TAB1 if absolute value of s - r is less than 1e - 6 ; TAB2 print " black " and a new line ; TAB1 if x = 0 | | y = 0 ; TAB2 print " black " and a new line ; TAB1 if ( x > 0 & & y > 0 ) or ( x < 0 & & y < 0 ) ; TAB2 int a = r % 2 ; TAB2 if a is not 0 ; TAB3 print " white " and a new line ; TAB2 else ; TAB3 print " black " and a new line ; TAB1 else ; TAB2 int a = r % 2 ; TAB2 if a = 0 ; TAB3 print " white " and a new line ; TAB2 else ; TAB3 print " black " and a new line ;	int main ( ) { double x , y ; cin >> x >> y ; double r = sqrt ( x * x + y * y ) ; double s = floor ( r ) ; if ( abs ( s - r ) < 1e-6 ) { cout << " black " << endl ; return 0 ; } if ( x == 0 || y == 0 ) { cout << " black " << endl ; return 0 ; } if ( ( x > 0 && y > 0 ) || ( x < 0 && y < 0 ) ) { int a = ( ( int ) r ) % 2 ; if ( a ) cout << " white " << endl ; else cout << " black " << endl ; } else { int a = ( ( int ) r ) % 2 ; if ( a == 0 ) cout << " white " << endl ; else cout << " black " << endl ; } return 0 ; }
TAB1 create doubles x and y ; TAB1 create double d ; TAB1 read x and y ; TAB1 d = square root of x * x + y * y ; TAB1 integer es = d / 1 ; TAB1 if ( es = d ) or ( x * y = 0 ) ; TAB2 print " black " and a new line ; TAB1 else if x * y is less than 0 ; TAB2 if es is even ; TAB3 print " white " and a new line ; TAB2 else ; TAB3 print " black " and a new line ; TAB1 else if x * y is greater than 0 ; TAB2 if es is odd ; TAB3 print " white " and a new line ; TAB2 else ; TAB3 print " black " and a new line ;	int main ( ) { double x , y ; double d ; cin >> x >> y ; d = sqrt ( x * x + y * y ) ; int es = d / 1 ; if ( ( es == d ) || ( x * y == 0 ) ) cout << " black " << endl ; else if ( x * y < 0 ) { if ( es % 2 == 0 ) cout << " white " << endl ; else cout << " black " << endl ; } else if ( x * y > 0 ) { if ( es % 2 != 0 ) cout << " white " << endl ; else cout << " black " << endl ; } return 0 ; }
TAB0 long doubles x , y and dist ; TAB0 boolean function Greater with integer arguments x ; TAB1 return ( ( long double ) x > = dist ) ; TAB0 boolean function eq with long arguments double , x , double and y ; TAB1 if x > = 0 and y > = 0 return 1 ; TAB1 if x < = 0 and y < = 0 return 1 ; TAB1 read x and y ; TAB1 set dist to square root of x * x + y * y ; TAB1 r and pas are integers with r = 0 and pas = ( 1 < < 30 ) ; TAB1 while pas ; TAB2 if Greater ( r + pas ) = 0 , add pas to r ; TAB2 divide pas by 2 ; TAB1 increase r ; TAB1 if r = dist ; TAB2 print " black \ n " ; TAB1 if eq ( x , y ) ; TAB2 if r is odd ; TAB3 print " black \ n " ; TAB2 else ; TAB3 print " white \ n " ; TAB1 else ; TAB2 if r % 2 is even ; TAB3 print " black \ n " ; TAB2 else ; TAB3 print " white \ n " ;	long double x , y , dist ; bool Greater ( int x ) { return ( ( long double ) x >= dist ) ; } bool eq ( long double x , long double y ) { if ( x >= 0 && y >= 0 ) return 1 ; if ( x <= 0 && y <= 0 ) return 1 ; return 0 ; } int main ( ) { cin >> x >> y ; dist = sqrt ( x * x + y * y ) ; int r = 0 , pas = ( 1 << 30 ) ; while ( pas ) { if ( Greater ( r + pas ) == 0 ) r += pas ; pas /= 2 ; } r ++ ; if ( ( long double ) r == dist ) { cout << " black\n " ; return 0 ; } if ( eq ( x , y ) ) { if ( r % 2 ) cout << " black\n " ; else cout << " white\n " ; } else { if ( r % 2 == 0 ) cout << " black\n " ; else cout << " white\n " ; } return 0 ; }
TAB1 create integers i , j , x and y ; TAB1 read x and y ; TAB1 if x = 0 or y is equal to 0 ; TAB2 print " black \ n " ; TAB1 if x < 0 and y is less than 0 ; TAB2 invert sign of x ; TAB2 invert sign of y ; TAB1 assign value x * x + y * y to the integer dist ; TAB1 for i = 2000 to 1 inclusive decrementing i ; TAB2 if i * i > = dist and ( i - 1 ) * ( i - 1 ) is less than dist , break ; TAB1 if i * i is equal to dist ; TAB2 print " black \ n " ; TAB1 if x * y is greater than 0 ; TAB2 if i is odd ; TAB3 print " black \ n " ; TAB2 else ; TAB3 print " white \ n " ; TAB1 else ; TAB2 if i is even ; TAB3 print " black \ n " ; TAB2 else ; TAB3 print " white \ n " ;	int main ( ) { int i , j , x , y ; cin >> x >> y ; if ( x == 0 || y == 0 ) { cout << " black\n " ; return 0 ; } if ( x < 0 && y < 0 ) { x *= - 1 ; y *= - 1 ; } int dist = x * x + y * y ; for ( i = 2000 ; i >= 1 ; i -- ) { if ( i * i >= dist && ( i - 1 ) * ( i - 1 ) < dist ) break ; } if ( i * i == dist ) { cout << " black\n " ; return 0 ; } if ( x * y > 0 ) { if ( i % 2 == 1 ) cout << " black\n " ; else cout << " white\n " ; } else { if ( i % 2 == 0 ) cout << " black\n " ; else cout << " white\n " ; } return 0 ; }
TAB0 create maps f , g from string to integer ; TAB0 create string array s of size 1005 ; TAB0 create integer array c with size 1005 ; TAB1 create integers n , m with m = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read s [ i ] read c [ i ] , increment f [ s [ i ] ] by c [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 if m is less than f [ s [ i ] ] set m to f [ s [ i ] ] ; TAB1 create integer i ; TAB1 for i = 0 to f [ s [ i ] ] is less than m or ( g [ s [ i ] ] incremented by c [ i ] ) is less than m , incrementing i ; TAB2 end statement ; TAB1 return result of ( print s [ i ] print newline ) and 0 ; TAB0 let f and g be maps of string to integer ; TAB0 let s be an array of strings of length 1005 ; TAB0 c = array of integers of length 1005 ; TAB1 integers n and m with m = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read s [ i ] and c [ i ] , then increase f [ s [ i ] ] by c [ i ] ; TAB1 for integer i = 0 to n exclusive ; TAB2 if m is less than f [ s [ i ] ] , set m to f [ s [ i ] ] ; TAB1 declare integer variable i ; TAB1 loop through i from 0 while f [ s [ i ] ] < m or ( g [ s [ i ] ] + = c [ i ] ) < m ; TAB2 ; ; TAB1 return ( cout < < s [ i ] < < endl ) & & 0 ;	map < string , int > f , g ; string s [ 1005 ] ; int c [ 1005 ] ; int main ( ) { int n , m = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] >> c [ i ] , f [ s [ i ] ] += c [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( m < f [ s [ i ] ] ) m = f [ s [ i ] ] ; int i ; for ( i = 0 ; f [ s [ i ] ] < m || ( g [ s [ i ] ] += c [ i ] ) < m ; i ++ ) ; return ( cout << s [ i ] << endl ) && 0 ; } map < string , int > f , g ; string s [ 1005 ] ; int c [ 1005 ] ; int main ( ) { int n , m = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] >> c [ i ] , f [ s [ i ] ] += c [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( m < f [ s [ i ] ] ) m = f [ s [ i ] ] ; int i ; for ( i = 0 ; f [ s [ i ] ] < m || ( g [ s [ i ] ] += c [ i ] ) < m ; i ++ ) ; return ( cout << s [ i ] << endl ) && 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 mmp and fq are maps of string to integer ; TAB1 max = - 20000000 ; TAB1 name = array of strings of size 1005 ; TAB1 sc = array of integers of size 1005 ; TAB1 for integer i = 0 to n exclusive ; TAB2 read name [ i ] and sc [ i ] ; TAB2 increase mmp [ name [ i ] ] by sc [ i ] ; TAB1 for integer i = 0 to n exclusive ; TAB2 if max is less than mmp [ name [ i ] ] , set max to mmp [ name [ i ] ] ; TAB1 for integer i = 0 to n exclusive ; TAB2 increase fq [ name [ i ] ] by sc [ i ] ; TAB2 if fq [ name [ i ] ] > = max and mmp [ name [ i ] ] > = max ; TAB3 print name [ i ] and a new line ;	int main ( ) { int n ; cin >> n ; map < string , int > mmp , fq ; int max = - 20000000 ; string name [ 1005 ] ; int sc [ 1005 ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> name [ i ] >> sc [ i ] ; mmp [ name [ i ] ] += sc [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( max < mmp [ name [ i ] ] ) { max = mmp [ name [ i ] ] ; } } for ( int i = 0 ; i < n ; i ++ ) { fq [ name [ i ] ] += sc [ i ] ; if ( fq [ name [ i ] ] >= max && mmp [ name [ i ] ] >= max ) { cout << name [ i ] << endl ; return 0 ; } } }
TAB0 create maps name , name2 from string to integer ; TAB1 create integer n ; TAB1 read n ; TAB1 create string tempname with size 1010 ; TAB1 create integer score with size 1010 ; TAB1 create integer mx with mx = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read tempname [ i ] read score [ i ] ; TAB2 increment name [ tempname [ i ] ] by score [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 if name [ tempname [ i ] ] is greater than mx , set mx to name [ tempname [ i ] ] ; TAB1 for i = 0 to n exclusive ; TAB2 if name [ tempname [ i ] ] is mx ; TAB3 set name2 [ tempname [ i ] ] by score [ i ] ; TAB3 if name2 [ tempname [ i ] ] is greater than or equal to mx ; TAB4 print tempname [ i ] print ' \ n ' ; TAB4 break loop ;	map < string , int > name , name2 ; int main ( ) { int n ; cin >> n ; string tempname [ 1010 ] ; int score [ 1010 ] ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) { cin >> tempname [ i ] >> score [ i ] ; name [ tempname [ i ] ] += score [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( name [ tempname [ i ] ] > mx ) { mx = name [ tempname [ i ] ] ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( name [ tempname [ i ] ] == mx ) { name2 [ tempname [ i ] ] += score [ i ] ; if ( name2 [ tempname [ i ] ] >= mx ) { cout << tempname [ i ] << ' \n ' ; break ; } } } return 0 ; }
TAB0 let II be an array of integers of size 100007 ; TAB0 let SS be an array of strings of length 100007 ; TAB0 SC1 and SC2 are map of string to integer ; TAB1 let n and mx be integers ; TAB1 mx = - 1000000007 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read SS [ i ] and II [ i ] ; TAB2 increase SC1 [ SS [ i ] ] by II [ i ] ; TAB1 create map iterator it and set it to the first element of SC1 ; TAB1 move it through SC1 , setting mx to max of max and value at the iterator ; TAB1 for i = 0 to n exclusive ; TAB2 increase SC2 [ SS [ i ] ] by II [ i ] ; TAB2 if SC1 [ SS [ i ] ] > = mx and mx < = SC2 [ SS [ i ] ] ; TAB3 print SS [ i ] and a new line ;	int II [ 100007 ] ; string SS [ 100007 ] ; map < string , int > SC1 , SC2 ; int main ( ) { int n , mx ; mx = - 1000000007 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> SS [ i ] >> II [ i ] ; SC1 [ SS [ i ] ] += II [ i ] ; } map < string , int > :: iterator it = SC1 . begin ( ) ; for ( it ; it != SC1 . end ( ) ; it ++ ) mx = max ( mx , ( * it ) . second ) ; for ( int i = 0 ; i < n ; i ++ ) { SC2 [ SS [ i ] ] += II [ i ] ; if ( SC1 [ SS [ i ] ] >= mx && mx <= SC2 [ SS [ i ] ] ) { cout << SS [ i ] << endl ; return 0 ; } } return 0 ; }
TAB0 integers n , maxn = - 1000 and sc is an array of integers with size 1009 ; TAB0 stu = array of strings of size 1009 ; TAB0 m and m1 are maps of string to integers ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read stu [ i ] and sc [ i ] ; TAB2 increase m [ stu [ i ] ] by sc [ i ] ; TAB1 for integer i = 1 to n inclusive ; TAB2 if m [ stu [ i ] ] is greater than maxn set maxn to m [ stu [ i ] ] ; TAB1 for i = 1 to n inclusive ; TAB2 increase m1 [ stu [ i ] ] by sc [ i ] ; TAB2 if m1 [ stu [ i ] ] > = maxn and m [ stu [ i ] ] is equal to maxn ; TAB3 print stu [ i ] and a new line ; TAB3 stop the loop ; TAB0 create integers n , maxn with maxn = - 1000 , create integer array sc with size 1009 ; TAB0 create string array stu with size 1009 ; TAB0 create maps m , m1 from string to integer ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read stu [ i ] read sc [ i ] ; TAB2 increment m [ stu [ i ] ] by sc [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 if m [ stu [ i ] ] is greater than maxn , set maxn to m [ stu [ i ] ] ; TAB1 for i = 1 to n inclusive ; TAB2 increment m1 [ stu [ i ] ] by sc [ i ] ; TAB2 if m1 [ stu [ i ] ] is greater than or equal to maxn and m [ stu [ i ] ] is maxn ; TAB3 print stu [ i ] print newline ; TAB3 break loop ;	int n , maxn = - 1000 , sc [ 1009 ] ; string stu [ 1009 ] ; map < string , int > m , m1 ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> stu [ i ] >> sc [ i ] ; m [ stu [ i ] ] += sc [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) if ( m [ stu [ i ] ] > maxn ) { maxn = m [ stu [ i ] ] ; } for ( int i = 1 ; i <= n ; i ++ ) { m1 [ stu [ i ] ] += sc [ i ] ; if ( m1 [ stu [ i ] ] >= maxn && m [ stu [ i ] ] == maxn ) { cout << stu [ i ] << endl ; break ; } } return 0 ; } int n , maxn = - 1000 , sc [ 1009 ] ; string stu [ 1009 ] ; map < string , int > m , m1 ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> stu [ i ] >> sc [ i ] ; m [ stu [ i ] ] += sc [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) if ( m [ stu [ i ] ] > maxn ) { maxn = m [ stu [ i ] ] ; } for ( int i = 1 ; i <= n ; i ++ ) { m1 [ stu [ i ] ] += sc [ i ] ; if ( m1 [ stu [ i ] ] >= maxn && m [ stu [ i ] ] == maxn ) { cout << stu [ i ] << endl ; break ; } } return 0 ; }
TAB0 create 2d integer array a with size 1005 by 1005 ; TAB1 create integers n , i , j , k , x , with k = 0 , create integer array b with size 1005 ; TAB1 create boolean f ; TAB1 create string array name with size 1005 , create strings ans , s ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 set f to 0 ; TAB2 read s read x ; TAB2 for j = 0 to k exclusive ; TAB3 if s is name [ j ] ; TAB4 set a [ i ] [ j ] to a [ i - 1 ] [ j ] + x ; TAB4 end statement ; TAB4 set f to 1 ; TAB3 else ; TAB4 set a [ i ] [ j ] to a [ i - 1 ] [ j ] ; TAB2 if f is 0 ; TAB3 set name [ k ] to s ; TAB3 set a [ i ] [ k ] to x ; TAB3 increment k ; TAB1 for j = 0 to k exclusive , set b [ j ] to a [ n - 1 ] [ j ] ; TAB1 sort elements from b to b + k ; TAB1 if b [ k - 1 ] is b [ k - 2 ] ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to k exclusive ; TAB4 if a [ i ] [ j ] is greater than or equal to b [ k - 1 ] and a [ n - 1 ] [ j ] is b [ k - 1 ] ; TAB5 set ans to name [ j ] ; TAB5 set i to n ; TAB5 break loop ; TAB1 else ; TAB2 for j = 0 to k exclusive ; TAB3 if a [ n - 1 ] [ j ] is b [ k - 1 ] ; TAB4 set ans to name [ j ] ; TAB4 break loop ; TAB1 print ans print newline ; TAB0 a is an array of integers with size 1005 by 1005 ; TAB1 declare integers n , i , j , k and x , with k = 0 , b is an array of integers with size 1005 ; TAB1 declare boolean variable f ; TAB1 let ans and s be strings , name is an array of strings with 1005 elements ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 set f to 0 ; TAB2 read s and x ; TAB2 for j = 0 to k exclusive ; TAB3 if s = name [ j ] ; TAB4 a [ i ] [ j ] = a [ i - 1 ] [ j ] + x ; TAB4 ; ; TAB4 assign value of 1 to the f ; TAB3 else ; TAB4 a [ i ] [ j ] = a [ i - 1 ] [ j ] ; TAB2 if f = 0 ; TAB3 assign value of s to the name [ k ] ; TAB3 a [ i ] [ k ] = x ; TAB3 increase k by one ; TAB1 for j = 0 to k exclusive , set value of b [ j ] to a [ n - 1 ] [ j ] ; TAB1 sort array b from the start to k ; TAB1 if b [ k - 1 ] = b [ k - 2 ] ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to k exclusive ; TAB4 if a [ i ] [ j ] > = b [ k - 1 ] & & a [ n - 1 ] [ j ] = b [ k - 1 ] ; TAB5 set ans to name [ j ] ; TAB5 assign value of n to the i ; TAB5 break the loop ; TAB1 else ; TAB2 for j = 0 to k exclusive ; TAB3 if a [ n - 1 ] [ j ] = b [ k - 1 ] ; TAB4 set value of ans to name [ j ] ; TAB4 stop the loop ; TAB1 print ans and a new line ;	int a [ 1005 ] [ 1005 ] ; int main ( ) { int n , i , j , k = 0 , x , b [ 1005 ] ; bool f ; string name [ 1005 ] , ans , s ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { f = 0 ; cin >> s >> x ; for ( j = 0 ; j < k ; j ++ ) { if ( s == name [ j ] ) { a [ i ] [ j ] = a [ i - 1 ] [ j ] + x ; ; f = 1 ; } else a [ i ] [ j ] = a [ i - 1 ] [ j ] ; } if ( f == 0 ) { name [ k ] = s ; a [ i ] [ k ] = x ; k ++ ; } } for ( j = 0 ; j < k ; j ++ ) b [ j ] = a [ n - 1 ] [ j ] ; sort ( b , b + k ) ; if ( b [ k - 1 ] == b [ k - 2 ] ) { for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < k ; j ++ ) { if ( a [ i ] [ j ] >= b [ k - 1 ] && a [ n - 1 ] [ j ] == b [ k - 1 ] ) { ans = name [ j ] ; i = n ; break ; } } } else { for ( j = 0 ; j < k ; j ++ ) if ( a [ n - 1 ] [ j ] == b [ k - 1 ] ) { ans = name [ j ] ; break ; } } cout << ans << endl ; return 0 ; } int a [ 1005 ] [ 1005 ] ; int main ( ) { int n , i , j , k = 0 , x , b [ 1005 ] ; bool f ; string name [ 1005 ] , ans , s ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { f = 0 ; cin >> s >> x ; for ( j = 0 ; j < k ; j ++ ) { if ( s == name [ j ] ) { a [ i ] [ j ] = a [ i - 1 ] [ j ] + x ; ; f = 1 ; } else a [ i ] [ j ] = a [ i - 1 ] [ j ] ; } if ( f == 0 ) { name [ k ] = s ; a [ i ] [ k ] = x ; k ++ ; } } for ( j = 0 ; j < k ; j ++ ) b [ j ] = a [ n - 1 ] [ j ] ; sort ( b , b + k ) ; if ( b [ k - 1 ] == b [ k - 2 ] ) { for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < k ; j ++ ) { if ( a [ i ] [ j ] >= b [ k - 1 ] && a [ n - 1 ] [ j ] == b [ k - 1 ] ) { ans = name [ j ] ; i = n ; break ; } } } else { for ( j = 0 ; j < k ; j ++ ) if ( a [ n - 1 ] [ j ] == b [ k - 1 ] ) { ans = name [ j ] ; break ; } } cout << ans << endl ; return 0 ; }
TAB1 create integers t , x and y ; TAB1 read t ; TAB1 let s be an array of strings of size t ; TAB1 create a map from strings to integers called m ; TAB1 declare vector of strings called v ; TAB1 declare vector of integers called v1 ; TAB1 create a map from strings to integers called m1 ; TAB1 for integer i = 0 to t exclusive ; TAB2 read s [ i ] and x ; TAB2 push s [ i ] into v ; TAB2 push x into v1 ; TAB2 if s [ i ] is the last element in m ; TAB3 assign value of x to the m [ s [ i ] ] ; TAB2 else ; TAB3 increase m [ s [ i ] ] by x ; TAB1 create iterator of map from string to int , called it ; TAB1 iterate it through m ; TAB2 if it is at the first element of m ; TAB3 y = it - > second ; TAB2 else ; TAB3 if it - > second is greater than y , y = it - > second ; TAB1 iterate it through m ; TAB2 if it - > second = y , set m1 [ it - > first ] = 1 ; TAB1 clear m ; TAB1 for i = 0 to t exclusive ; TAB2 if v [ i ] is the last element of m1 ; TAB3 go to the start of the loop ; TAB2 else ; TAB3 if v [ i ] is the last element of m ; TAB4 set value of m [ v [ i ] ] to v1 [ i ] ; TAB4 if m [ v [ i ] ] > = y ; TAB5 print v [ i ] and a new line ; TAB5 break the loop ; TAB3 else ; TAB4 increase m [ v [ i ] ] by v1 [ i ] ; TAB4 if m [ v [ i ] ] > = y ; TAB5 print v [ i ] and a new line ; TAB5 break the loop ; TAB1 create integers t , x , y ; TAB1 read t ; TAB1 create string s [ t ] ; TAB1 create map m from string to integer ; TAB1 create string vector v ; TAB1 create integer vector v1 ; TAB1 create map m1 from string to integer ; TAB1 for i = 0 to t exclusive ; TAB2 read s [ i ] read x ; TAB2 add element s [ i ] to end of v ; TAB2 add element x to end of v1 ; TAB2 if first index of s [ i ] in m is end of m ; TAB3 set m [ s [ i ] ] to x ; TAB2 else ; TAB3 increment m [ s [ i ] ] by x ; TAB1 create map iterator it from string to integer ; TAB1 for it = beginning of m to it is not end of m , incrementing it ; TAB2 if it is beginning of m ; TAB3 set y to second element of it ; TAB2 else ; TAB3 if second element of it is greater than y , set y to second element of it ; TAB1 for it = beginning of m to end of m , incrementing it ; TAB2 if second element of it is y , set m1 [ first element of it ] to 1 ; TAB1 remove all elements from m ; TAB1 for i = 0 to t exclusive ; TAB2 if first index of v [ i ] in m1 is end of m1 ; TAB3 break current loop iteration ; TAB2 else ; TAB3 if first index of v [ i ] in m is end of m ; TAB4 set m [ v [ i ] ] to v1 [ i ] ; TAB4 if m [ v [ i ] ] is greater than or equal to y ; TAB5 print v [ i ] print newline ; TAB5 break loop ; TAB3 else ; TAB4 increment m [ v [ i ] ] by v1 [ i ] ; TAB4 if m [ v [ i ] ] is greater than or equal to y ; TAB5 print v [ i ] print newline ; TAB5 break loop ;	int main ( ) { int t , x , y ; cin >> t ; string s [ t ] ; map < string , int > m ; vector < string > v ; vector < int > v1 ; map < string , int > m1 ; for ( int i = 0 ; i < t ; i ++ ) { cin >> s [ i ] >> x ; v . push_back ( s [ i ] ) ; v1 . push_back ( x ) ; if ( m . find ( s [ i ] ) == m . end ( ) ) { m [ s [ i ] ] = x ; } else { m [ s [ i ] ] += x ; } } map < string , int > :: iterator it ; for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it == m . begin ( ) ) y = it -> second ; else { if ( it -> second > y ) y = it -> second ; } } for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it -> second == y ) m1 [ it -> first ] = 1 ; } m . clear ( ) ; for ( int i = 0 ; i < t ; i ++ ) { if ( m1 . find ( v [ i ] ) == m1 . end ( ) ) continue ; else { if ( m . find ( v [ i ] ) == m . end ( ) ) { m [ v [ i ] ] = v1 [ i ] ; if ( m [ v [ i ] ] >= y ) { cout << v [ i ] << endl ; break ; } } else { m [ v [ i ] ] += v1 [ i ] ; if ( m [ v [ i ] ] >= y ) { cout << v [ i ] << endl ; break ; } } } } return 0 ; } int main ( ) { int t , x , y ; cin >> t ; string s [ t ] ; map < string , int > m ; vector < string > v ; vector < int > v1 ; map < string , int > m1 ; for ( int i = 0 ; i < t ; i ++ ) { cin >> s [ i ] >> x ; v . push_back ( s [ i ] ) ; v1 . push_back ( x ) ; if ( m . find ( s [ i ] ) == m . end ( ) ) { m [ s [ i ] ] = x ; } else { m [ s [ i ] ] += x ; } } map < string , int > :: iterator it ; for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it == m . begin ( ) ) y = it -> second ; else { if ( it -> second > y ) y = it -> second ; } } for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it -> second == y ) m1 [ it -> first ] = 1 ; } m . clear ( ) ; for ( int i = 0 ; i < t ; i ++ ) { if ( m1 . find ( v [ i ] ) == m1 . end ( ) ) continue ; else { if ( m . find ( v [ i ] ) == m . end ( ) ) { m [ v [ i ] ] = v1 [ i ] ; if ( m [ v [ i ] ] >= y ) { cout << v [ i ] << endl ; break ; } } else { m [ v [ i ] ] += v1 [ i ] ; if ( m [ v [ i ] ] >= y ) { cout << v [ i ] << endl ; break ; } } } } return 0 ; }
TAB0 set constant integer maxn to 128 ; TAB0 mp1 and mp2 are maps of string to integer ; TAB0 let name be an array of strings of size 1010 ; TAB0 let score be an array of integers of length 1010 ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read name [ i ] and score [ i ] ; TAB2 increase mp1 [ name [ i ] ] by score [ i ] ; TAB1 set integer maxnum to 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 if mp1 [ name [ i ] ] is greater than maxnum , set maxnum value to mp1 [ name [ i ] ] ; TAB1 for integer i = 0 to n exclusive ; TAB2 increase mp2 [ name [ i ] ] by score [ i ] ; TAB2 if mp2 [ name [ i ] ] > = maxnum & & mp1 [ name [ i ] ] > = maxnum ; TAB3 print name [ i ] and a new line ; TAB3 stop the loop ;	const int maxn = 128 ; map < string , int > mp1 , mp2 ; string name [ 1010 ] ; int score [ 1010 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> name [ i ] >> score [ i ] ; mp1 [ name [ i ] ] += score [ i ] ; } int maxnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp1 [ name [ i ] ] > maxnum ) maxnum = mp1 [ name [ i ] ] ; } for ( int i = 0 ; i < n ; i ++ ) { mp2 [ name [ i ] ] += score [ i ] ; if ( mp2 [ name [ i ] ] >= maxnum && mp1 [ name [ i ] ] >= maxnum ) { cout << name [ i ] << endl ; break ; } } return 0 ; }
TAB1 create integer T ; TAB1 read T ; TAB1 create string array a with size 1000 , create string max1 ; TAB1 create integer array b with size 1000 , create integer max with max = - 2000 ; TAB1 create map mp from string to int ; TAB1 for i = 0 to T exclusive ; TAB2 read a [ i ] read b [ i ] ; TAB2 increment mp [ a [ i ] ] by b [ i ] ; TAB1 for it = beginning of mp to it is not end of mp , incrementing it ; TAB2 if max is less than second element of it ; TAB3 set max to second element of it ; TAB3 set max1 to first element of it ; TAB1 create map mm from string to int ; TAB1 for i = 0 to T exclusive ; TAB2 increment mm [ a [ i ] ] by b [ i ] ; TAB2 if mm [ a [ i ] ] is greater than or equal to maxn and mp [ a [ i ] ] is max ; TAB3 print a [ i ] print newline ; TAB3 break loop ; TAB1 declare integer variable T ; TAB1 read T ; TAB1 a is an array of strings with size 1000 , max1 is string ; TAB1 b is an array of ints with size 1000 , max is int = - 2000 ; TAB1 mp = map from string to integer ; TAB1 for i = 0 to T exclusive ; TAB2 read a [ i ] and b [ i ] ; TAB2 increase mp [ a [ i ] ] by b [ i ] ; TAB1 create map iterator it and move it in the loop through mp ; TAB2 if max is less than it - > second ; TAB3 max = it - > second ; TAB3 max1 = it - > first ; TAB1 mm = map from string to integer ; TAB1 for integer i = 0 to T exclusive ; TAB2 increase mm [ a [ i ] ] by b [ i ] ; TAB2 if mm [ a [ i ] ] > = max and mp [ a [ i ] ] = max ; TAB3 print a [ i ] and a new line ; TAB3 stop the loop ;	int main ( ) { int T ; cin >> T ; string a [ 1000 ] , max1 ; int b [ 1000 ] , max = - 2000 ; map < string , int > mp ; for ( int i = 0 ; i < T ; i ++ ) { cin >> a [ i ] >> b [ i ] ; mp [ a [ i ] ] += b [ i ] ; } for ( map < string , int > :: iterator it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { if ( max < it -> second ) { max = it -> second ; max1 = it -> first ; } } map < string , int > mm ; for ( int i = 0 ; i < T ; i ++ ) { mm [ a [ i ] ] += b [ i ] ; if ( mm [ a [ i ] ] >= max && mp [ a [ i ] ] == max ) { cout << a [ i ] << endl ; break ; } } } int main ( ) { int T ; cin >> T ; string a [ 1000 ] , max1 ; int b [ 1000 ] , max = - 2000 ; map < string , int > mp ; for ( int i = 0 ; i < T ; i ++ ) { cin >> a [ i ] >> b [ i ] ; mp [ a [ i ] ] += b [ i ] ; } for ( map < string , int > :: iterator it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { if ( max < it -> second ) { max = it -> second ; max1 = it -> first ; } } map < string , int > mm ; for ( int i = 0 ; i < T ; i ++ ) { mm [ a [ i ] ] += b [ i ] ; if ( mm [ a [ i ] ] >= max && mp [ a [ i ] ] == max ) { cout << a [ i ] << endl ; break ; } } }
TAB1 declare integers called t , x and y ; TAB1 read t ; TAB1 s = array of strings of size t ; TAB1 create a map from strings to integers with name m ; TAB1 v = vector of strings ; TAB1 declare vector of integers called v1 ; TAB1 let m1 be a map from string to integer ; TAB1 for integer i = 0 to t exclusive ; TAB2 read s [ i ] and x ; TAB2 push s [ i ] into v ; TAB2 push x into v1 ; TAB2 if s [ i ] is the last element in m ; TAB3 m [ s [ i ] ] = x ; TAB2 else ; TAB3 increase m [ s [ i ] ] by x ; TAB1 let it be an iterator through a map of string to int ; TAB1 iterate it through m ; TAB2 if it is at the start of the m ; TAB3 y = it - > second ; TAB2 else ; TAB3 if it - > second is greater than y , set y to it - > second ; TAB1 iterate it through m ; TAB2 if it - > second is equal to y , set m1 [ it - > first ] to 1 ; TAB1 clear m ; TAB1 for integer i = 0 to t exclusive ; TAB2 if v [ i ] is the last element in m1 ; TAB3 skip the rest of the loop ; TAB2 else ; TAB3 if v [ i ] is the last element in m ; TAB4 m [ v [ i ] ] = v1 [ i ] ; TAB4 if m [ v [ i ] ] > = y ; TAB5 print v [ i ] and a new line ; TAB5 stop the loop ; TAB3 else ; TAB4 increase m [ v [ i ] ] by v1 [ i ] ; TAB4 if m [ v [ i ] ] > = y ; TAB5 print v [ i ] and a new line ; TAB5 stop the loop ;	int main ( ) { int t , x , y ; cin >> t ; string s [ t ] ; map < string , int > m ; vector < string > v ; vector < int > v1 ; map < string , int > m1 ; for ( int i = 0 ; i < t ; i ++ ) { cin >> s [ i ] >> x ; v . push_back ( s [ i ] ) ; v1 . push_back ( x ) ; if ( m . find ( s [ i ] ) == m . end ( ) ) { m [ s [ i ] ] = x ; } else { m [ s [ i ] ] += x ; } } map < string , int > :: iterator it ; for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it == m . begin ( ) ) y = it -> second ; else { if ( it -> second > y ) y = it -> second ; } } for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it -> second == y ) m1 [ it -> first ] = 1 ; } m . clear ( ) ; for ( int i = 0 ; i < t ; i ++ ) { if ( m1 . find ( v [ i ] ) == m1 . end ( ) ) continue ; else { if ( m . find ( v [ i ] ) == m . end ( ) ) { m [ v [ i ] ] = v1 [ i ] ; if ( m [ v [ i ] ] >= y ) { cout << v [ i ] << endl ; break ; } } else { m [ v [ i ] ] += v1 [ i ] ; if ( m [ v [ i ] ] >= y ) { cout << v [ i ] << endl ; break ; } } } } return 0 ; }
TAB1 n , t , cnt0 , cnt5 = integers with cnt0 = 0 and cnt5 = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read t ; TAB2 if t equals 0 ; TAB3 add 1 to cnt0 ; TAB2 else ; TAB3 add 1 to cnt5 ; TAB1 set x to cnt5 / 9 ; TAB1 ans = string ; TAB1 if cnt0 equals 0 ; TAB2 set ans to " - 1 " ; TAB1 else ; TAB2 if x equals 0 ; TAB3 set ans to " 0 " ; TAB2 else ; TAB3 for i = 0 to x exclusive add " 555555555 " to ans ; TAB3 for i = 0 to cnt0 exclusive add " 0 " to ans ; TAB1 print ans ;	int main ( ) { int n , t , cnt0 = 0 , cnt5 = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t ; if ( t == 0 ) cnt0 ++ ; else cnt5 ++ ; } int x = cnt5 / 9 ; string ans ; if ( cnt0 == 0 ) { ans = " -1 " ; } else { if ( x == 0 ) ans = " 0 " ; else { for ( int i = 0 ; i < x ; i ++ ) { ans += " 555555555 " ; } for ( int i = 0 ; i < cnt0 ; i ++ ) { ans += " 0 " ; } } } cout << ans << endl ; return 0 ; }
TAB1 declare long longs a , b , c , d , e , f , l , g , m , n , k , i , j , t , p , q and s , with a , b , f and s = 0 ; TAB1 let v be a vector of long longs ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 push a in vector v ; TAB2 if a is greater than f , set f to a ; TAB2 increase s by a ; TAB1 a = n - 1 ; TAB1 c = s / a ; TAB1 if s % a , increment c ; TAB1 if f is less than c , set f to c ; TAB1 print f and a new line ;	int main ( ) { long long a = 0 , b = 0 , c , d , e , f = 0 , l , g , m , n , k , i , j , t , p , q , s = 0 ; vector < long long > v ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> a ; v . push_back ( a ) ; if ( a > f ) f = a ; s += a ; } a = n - 1 ; c = s / a ; if ( s % a ) c ++ ; if ( f < c ) f = c ; cout << f << endl ; return 0 ; }
TAB1 set refused to 0 ; TAB1 create integers n , a , client ; TAB1 create float b , c = 0 ; TAB1 read n , a and b ; TAB1 for i = 0 to n exclusive ; TAB2 read client ; TAB2 if client = 1 ; TAB3 if a > 0 ; TAB4 decrement a ; TAB3 else if b greater than 0 ; TAB4 set b to b - 1 ; TAB4 c = c + 0 . 5 ; TAB3 else if c > 0 ; TAB4 assign c - 0 . 5 to c ; TAB3 other ; TAB4 increment refused ; TAB2 else ; TAB3 if b > = 1 ; TAB4 decrement b ; TAB3 otherwise ; TAB4 refused = refused + 2 ; TAB1 print refused ;	int main ( ) { int refused = 0 ; int n , a , client ; float b , c = 0 ; cin >> n >> a >> b ; for ( int i = 0 ; i < n ; i ++ ) { cin >> client ; if ( client == 1 ) { if ( a > 0 ) { a -- ; } else if ( b > 0 ) { b -= 1 ; c += 0.5 ; } else if ( c > 0 ) { c -= 0.5 ; } else refused ++ ; } else { if ( b >= 1 ) { b -- ; } else refused += 2 ; } } cout << refused << endl ; return 0 ; }
TAB1 create integers n , m , c ; TAB1 read n read m read c ; TAB1 for i = 0 to 10 exclusive ; TAB2 if ( n * 10 + 1 ) % m is 0 ; TAB3 print n * 10 + 1 ; TAB3 create string x initialized with size c - 1 filled with ' 0 ' ; TAB3 print x print newline ; TAB3 set n to 0 ; TAB3 break loop ; TAB1 if n is true , print - 1 print newline ;	int main ( ) { int n , m , c ; cin >> n >> m >> c ; for ( size_t i = 0 ; i < 10 ; i ++ ) { if ( ( n * 10 + i ) % m == 0 ) { cout << n * 10 + i ; string x ( c - 1 , ' 0 ' ) ; cout << x << endl ; n = 0 ; break ; } } if ( n ) cout << - 1 << endl ; }
TAB0 create integer array n with size 20 ; TAB0 create integer array m with size 20 ; TAB0 create integer n1 ; TAB0 create integer sumn ; TAB0 create boolean p ; TAB0 declare findn with integer ti as argument , returning integer ; TAB1 if ti is 1 , return 3 from function ; TAB1 if ti is 2 , return 3 from function ; TAB1 if ti is 3 , return 3 from function ; TAB1 if ti is 4 , return 2 from function ; TAB1 if ti is 5 , return 2 from function ; TAB1 if ti is 6 , return 2 from function ; TAB1 if ti is 7 , return 1 from function ; TAB1 if ti is 8 , return 1 from function ; TAB1 if ti is 9 , return 1 from function ; TAB1 if ti is 0 , return 0 from function ; TAB0 declare findm with integer ti as argument , returning integer ; TAB1 if ti is 1 , return 1 from function ; TAB1 if ti is 2 , return 2 from function ; TAB1 if ti is 3 , return 3 from function ; TAB1 if ti is 4 , return 1 from function ; TAB1 if ti is 5 , return 2 from function ; TAB1 if ti is 6 , return 3 from function ; TAB1 if ti is 7 , return 1 from function ; TAB1 if ti is 8 , return 2 from function ; TAB1 if ti is 9 , return 3 from function ; TAB1 if ti is 0 , return 2 from function ; TAB0 declare readin with no arguments , returning void ; TAB1 create character c with c = read character ; TAB1 while c is not a digit , set c to read c ; TAB1 set n [ 1 ] to result of run findn with c - ' 0 ' as argument ; TAB1 set m [ 1 ] to result of run findm with c - ' 0 ' as argument ; TAB1 for i = 2 to n1 inclusive ; TAB2 set c to read character ; TAB2 set n [ 1 ] to result of run findn with c - ' 0 ' as argument ; TAB2 set m [ i ] to result of run findm with c - ' 0 ' as argument ; TAB1 for i = n1 to 1 inclusive , decrementing i ; TAB2 set n [ i ] to n [ i - 1 ] ; TAB2 set m [ i ] to m [ i - 1 ] ; TAB0 declare dfs with integers ni , mi , tip as arguments , returning void ; TAB1 if tip is n1 ; TAB2 increment sumn ; TAB2 return from function ; TAB1 create integer ui with ui = ni incremented by n [ tip + 1 ] ; TAB1 create integer vi with vi = mi incremented by m [ tip + 1 ] ; TAB1 if ( ui is greater than or equal to 1 and ui is less than or equal to 3 and vi is greater than or equal to 1 and vi is less than or equal to 3 ) or ( ui is 0 and vi is 2 ) , run dfs with ui , vi , tip + 1 as arguments ; TAB1 read n1 ; TAB1 run readin ; TAB1 for i = 0 to 9 inclusive , run dfs with ( result of run findn with i as argument , result of run findm with i as argument , 1 ) as arguments ; TAB1 if sum1 is 1 ; TAB2 print " YES " print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int n [ 20 ] ; int m [ 20 ] ; int n1 ; int sumn ; bool p ; int findn ( int ti ) { if ( ti == 1 ) return 3 ; if ( ti == 2 ) return 3 ; if ( ti == 3 ) return 3 ; if ( ti == 4 ) return 2 ; if ( ti == 5 ) return 2 ; if ( ti == 6 ) return 2 ; if ( ti == 7 ) return 1 ; if ( ti == 8 ) return 1 ; if ( ti == 9 ) return 1 ; if ( ti == 0 ) return 0 ; } int findm ( int ti ) { if ( ti == 1 ) return 1 ; if ( ti == 2 ) return 2 ; if ( ti == 3 ) return 3 ; if ( ti == 4 ) return 1 ; if ( ti == 5 ) return 2 ; if ( ti == 6 ) return 3 ; if ( ti == 7 ) return 1 ; if ( ti == 8 ) return 2 ; if ( ti == 9 ) return 3 ; if ( ti == 0 ) return 2 ; } void readin ( ) { char c = getchar ( ) ; while ( ! isdigit ( c ) ) { c = getchar ( ) ; } n [ 1 ] = findn ( c - ' 0 ' ) ; m [ 1 ] = findm ( c - ' 0 ' ) ; for ( int i = 2 ; i <= n1 ; i ++ ) { c = getchar ( ) ; n [ i ] = findn ( c - ' 0 ' ) ; m [ i ] = findm ( c - ' 0 ' ) ; } for ( int i = n1 ; i >= 1 ; i -- ) { n [ i ] -= n [ i - 1 ] ; m [ i ] -= m [ i - 1 ] ; } } void dfs ( int ni , int mi , int tip ) { if ( tip == n1 ) { sumn ++ ; return ; } int ui = ni += n [ tip + 1 ] ; int vi = mi += m [ tip + 1 ] ; if ( ( ui >= 1 && ui <= 3 && vi >= 1 && vi <= 3 ) || ( ui == 0 && vi == 2 ) ) { dfs ( ui , vi , tip + 1 ) ; } } int main ( ) { cin >> n1 ; readin ( ) ; for ( int i = 0 ; i <= 9 ; i ++ ) { dfs ( findn ( i ) , findm ( i ) , 1 ) ; } if ( sumn == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 declare integers n , a , b , t , x and s with t and s = 0 ; TAB1 read n , a and b ; TAB1 for integer i = 0 to n exclusive ; TAB2 read x ; TAB2 if x = 1 ; TAB3 if a is greater than 0 ; TAB4 decrease a by one ; TAB3 else if b is greater than 0 ; TAB4 decrease b ; TAB4 increase s by one ; TAB3 else if s ! = 0 ; TAB4 decrease s by one ; TAB3 else ; TAB4 increment t ; TAB2 else ; TAB3 if b is greater than 0 ; TAB4 decrease b ; TAB3 else ; TAB4 set value of t to t + 2 ; TAB1 print t ;	int main ( ) { int n , a , b , t = 0 , x , s = 0 ; cin >> n >> a >> b ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 1 ) { if ( a > 0 ) a -- ; else if ( b > 0 ) { b -- ; s ++ ; } else if ( s != 0 ) s -- ; else { t ++ ; } } else { if ( b > 0 ) b -- ; else t = t + 2 ; } } cout << t << endl ; return 0 ; }
TAB1 create long long n ; TAB1 read n in a loop ; TAB2 create integers z , f and ans = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 declare integer tmp ; TAB3 read tmp ; TAB3 if tmp = 5 increment f ; TAB3 if tmp = 0 increment z ; TAB3 if f % 9 = 0 , set ans to f ; TAB2 if z is 0 ; TAB3 print - 1 and a new line ; TAB2 else if f is less than 9 ; TAB3 print 0 and a new line ; TAB2 else ; TAB3 print 5 ans times ; TAB3 print 0 z times ; TAB3 print new line ;	int main ( ) { long long n ; while ( cin >> n ) { int z = 0 , f = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp ; cin >> tmp ; if ( tmp == 5 ) f ++ ; if ( tmp == 0 ) z ++ ; if ( f % 9 == 0 ) ans = f ; } if ( ! z ) cout << - 1 << endl ; else if ( f < 9 ) cout << 0 << endl ; else { for ( int i = 0 ; i < ans ; i ++ ) cout << 5 ; for ( int i = 0 ; i < z ; i ++ ) cout << 0 ; cout << endl ; } } return 0 ; }
TAB1 a , b , n = int ; TAB1 read a , b , n ; TAB1 let ans = a ; TAB1 let flag = 0 ; TAB1 for i = 0 to 9 inclusive ; TAB2 multiply and by a * 10 + i ; TAB2 if ans module b is 0 ; TAB3 flag = 1 ; TAB3 print ans ; TAB3 for j = 1 to n exclusive print " 0 " ; TAB3 print newline ; TAB1 if flag is 0 print " - 1 " ;	int main ( ) { int a , b , n ; cin >> a >> b >> n ; long long ans = a ; int flag = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) { ans = a * 10 + i ; if ( ans % b == 0 ) { flag = 1 ; cout << ans ; for ( int j = 1 ; j < n ; j ++ ) { cout << " 0 " ; } cout << endl ; return 0 ; } } if ( flag == 0 ) cout << " -1 " << endl ; return 0 ; }
TAB0 declare inline read with no arguments , returning integer ; TAB1 create integer x with x = 0 ; TAB1 create character c with c = read character ; TAB1 create boolean flag with flag = 0 ; TAB1 while c is less than ' 0 ' or c is greater than ' 9 ' ; TAB2 if c is ' - ' , set flag to 1 ; TAB2 set c to read character ; TAB1 while c is greater than or equal to ' 0 ' and c is less than or equal to ' 9 ' ; TAB2 set x to ( x + ( x bitshift left 2 ) bitshift left 1 ) + c - ' 0 ' ; TAB2 set c to read character ; TAB1 return - x is flag is true , else x ; TAB0 create integer array a of size 100010 , create integer n ; TAB0 declare cmp with integers a , b as arguments ; TAB1 return ( if a is greater than b ) ; TAB1 set n to result of run read ; TAB1 for i = 0 to n exclusive , set a [ i ] to result of run read ; TAB1 sort elements from a to a + n using cmp to compare ; TAB1 create long longs r , l , ans with r = 100000000000 , l = 0 , ans = ( l + r ) / 2 ; TAB1 while l is less than r ; TAB2 create long longs left , i with left = ans ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] is greater than ans ; TAB4 set l to ans + 1 ; TAB4 set ans to ( r + 1 ) / 2 ; TAB4 break loop ; TAB3 else ; TAB4 set left to left - ( ans - a [ i ] ) ; TAB4 if left is less than or equal to 0 ; TAB5 set r to ans ; TAB5 set ans to ( r + 1 ) / 2 ; TAB5 break loop ; TAB2 if i is n and left is greater than 0 ; TAB3 set l to ans + 1 ; TAB3 set ans to ( r + 1 ) / 2 ; TAB1 print ans print newline ;	inline int read ( ) { int x = 0 ; char c = getchar ( ) ; bool flag = 0 ; while ( c < ' 0 ' || c > ' 9 ' ) { if ( c == ' - ' ) flag = 1 ; c = getchar ( ) ; } while ( c >= ' 0 ' && c <= ' 9 ' ) { x = ( x + ( x << 2 ) << 1 ) + c - ' 0 ' ; c = getchar ( ) ; } return flag ? - x : x ; } int a [ 100010 ] , n ; int cmp ( int a , int b ) { return a > b ; } int main ( ) { n = read ( ) ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = read ( ) ; sort ( a , a + n , cmp ) ; long long r = 100000000000 , l = 0 , ans = ( l + r ) / 2 ; while ( l < r ) { long long left = ans , i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > ans ) { l = ans + 1 ; ans = ( r + l ) / 2 ; break ; } else { left = left - ( ans - a [ i ] ) ; if ( left <= 0 ) { r = ans ; ans = ( r + l ) / 2 ; break ; } } } if ( i == n && left > 0 ) { l = ans + 1 ; ans = ( r + l ) / 2 ; } } cout << ans << endl ; }
TAB1 a , b and n = integers ; TAB1 read a , b and n ; TAB1 multiply a by 10 ; TAB1 create integer flag with value 0 ; TAB1 assign value 0 to the integer ans ; TAB1 for i = 0 to 9 inclusive ; TAB2 set integer x to a + i ; TAB2 if x % b = 0 ; TAB3 ans = x ; TAB3 set flag to 1 ; TAB3 stop the loop ; TAB2 else ; TAB3 set flag to 0 ; TAB1 if flag = 1 ; TAB2 print ans ; TAB2 for i = 0 to n - 1 exclusive ; TAB2 print new line ; TAB1 else ; TAB2 print - 1 and a new line ;	int main ( ) { int a , b , n ; cin >> a >> b >> n ; a *= 10 ; int flag = 0 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) { int x = a + i ; if ( x % b == 0 ) { ans = x ; flag = 1 ; break ; } else flag = 0 ; } if ( flag == 1 ) { cout << ans ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << " 0 " ; } cout << endl ; } else { cout << - 1 << endl ; } return 0 ; }
TAB0 create integers i , j , k ; TAB0 create integer array fr with fr = { 0 , 0 , 1 , - 1 , - 1 , 1 , - 1 , 1 } ; TAB0 create integer array fc with fc = { - 1 , 1 , 0 , 0 , 1 , 1 , - 1 , - 1 } ; TAB1 create long longs n , m , k , mx , mn , sum , sum2 with sum = 0 ; TAB1 read n read m read k ; TAB1 set mx to maximum of n and m ; TAB1 set mn to minimum of n and m ; TAB1 if k is greater than ( m + n - 2 ) ; TAB2 print - 1 print newline ; TAB1 else ; TAB2 if k is less than or equal to mn - 1 ; TAB3 set sum to ( mn / ( k + 1 ) ) , set sum to sum * mx ; TAB3 set sum2 to ( mx / ( k + 1 ) ) , set sum2 to sum2 * mn ; TAB3 set sum to maximum of sum and sum2 ; TAB2 else if k is less than or equal to mx - 1 ; TAB3 set sum to ( mx / ( k + 1 ) ) , set sum to sum * mn ; TAB2 else ; TAB3 set sum to mn / ( k - mx + 2 ) ; TAB2 print sum print newline ;	int i , j , k ; int fr [ ] = { 0 , 0 , 1 , - 1 , - 1 , 1 , - 1 , 1 } ; int fc [ ] = { - 1 , 1 , 0 , 0 , 1 , 1 , - 1 , - 1 } ; int main ( ) { long long n , m , k , mx , mn , sum = 0 , sum2 ; cin >> n >> m >> k ; mx = max ( n , m ) ; mn = min ( n , m ) ; if ( k > ( m + n - 2 ) ) cout << - 1 << endl ; else { if ( k <= mn - 1 ) { sum = ( mn / ( k + 1 ) ) , sum *= mx ; sum2 = ( mx / ( k + 1 ) ) , sum2 *= mn ; sum = max ( sum , sum2 ) ; } else if ( k <= mx - 1 ) sum = ( mx / ( k + 1 ) ) , sum *= mn ; else sum = mn / ( k - mx + 2 ) ; cout << sum << endl ; } return 0 ; }
TAB1 declare long long integer variable n ; TAB1 read n ; TAB1 create long long integers fives , tmp and zeroes = 0 ; TAB1 while n > 0 , decrement it in a loop ; TAB2 read tmp ; TAB2 if tmp = 5 ; TAB3 increase fives by 1 ; TAB2 else ; TAB3 increase zeroes by 1 ; TAB1 divide fives by 9 ; TAB1 if fives and zeroes ; TAB2 while fives > 0 , decrement it in a loop and print " 555555555 " ; TAB2 while zeroes > 0 , decrement it in a loop and print " 0 " ; TAB2 print new line ; TAB1 else if zeroes is not 0 ; TAB2 print " 0 " ; TAB1 else ; TAB2 print " - 1 " ;	int main ( ) { long long int n ; cin >> n ; long long int fives = 0 , tmp = 0 , zeroes = 0 ; while ( n -- ) { cin >> tmp ; if ( tmp == 5 ) fives += 1 ; else zeroes += 1 ; } fives /= 9 ; if ( fives && zeroes ) { while ( fives -- > 0 ) { cout << " 555555555 " ; } while ( zeroes -- > 0 ) { cout << " 0 " ; } cout << endl ; } else if ( zeroes ) cout << " 0 " << endl ; else cout << " -1 " << endl ; return 0 ; }
TAB0 create long longs x , y , z , a , b ; TAB0 create deque q with long long ; TAB1 read x ; TAB1 for i = 0 to x exclusive ; TAB2 read y ; TAB2 set b to maximum of b and y ; TAB2 increment a by y ; TAB1 decrement x ; TAB1 print maximum of ( b and long long casted rounded up ( long double casted a / long double casted x ) ) print newline ;	long long x , y , z , a , b ; deque < long long > q ; int main ( ) { cin >> x ; for ( int i = 0 ; i < x ; i ++ ) { cin >> y ; b = max ( b , y ) ; a += y ; } x -- ; cout << max ( b , ( long long ) ceil ( ( long double ) a / ( long double ) x ) ) << endl ; return 0 ; }
TAB0 arrays of integers posy and posx with size 10 ; TAB0 array of integers valid with size 5 by 5 ; TAB0 s is string ; TAB0 function calc with integer arguments y , x and id that returns boolean ; TAB1 if id + 1 = length of s return true ; TAB1 integer variable dy = y + posy [ s [ id + 1 ] - ' 0 ' ] - posy [ s [ id ] - ' 0 ' ] ; TAB1 integer variable dx = x + posx [ s [ id + 1 ] - ' 0 ' ] - posx [ s [ id ] - ' 0 ' ] ; TAB1 return false if dy < 0 | | dx < 0 | | dy > 4 | | dx > 4 | | valid [ dy ] [ dx ] = 0 ; TAB1 return calc ( dy , dx , id + 1 ) ; TAB1 for integer i = 1 to 9 inclusive ; TAB2 declare integer called x = i - 1 ; TAB2 posy [ i ] = x / 3 ; TAB2 posx [ i ] = x % 3 ; TAB2 valid [ x / 3 ] [ x % 3 ] = 1 ; TAB1 assign value of 3 to posy [ 0 ] ; TAB1 posx [ 0 ] = 1 ; TAB1 set valid [ 3 ] [ 1 ] to 1 ; TAB1 create integer n ; TAB1 read n ; TAB1 read s ; TAB1 tot is integer = 0 ; TAB1 for i = 0 to 10 exclusive ; TAB2 if calc ( posy [ i ] , posx [ i ] , 0 ) returns true , increment tot ; TAB1 if tot = 1 ; TAB2 print " YES " and a new line ; TAB1 else ; TAB2 print " NO " and a new line ;	int posy [ 10 ] , posx [ 10 ] ; int valid [ 5 ] [ 5 ] ; string s ; bool calc ( int y , int x , int id ) { if ( id + 1 == s . size ( ) ) return true ; int dy = y + posy [ s [ id + 1 ] - ' 0 ' ] - posy [ s [ id ] - ' 0 ' ] ; int dx = x + posx [ s [ id + 1 ] - ' 0 ' ] - posx [ s [ id ] - ' 0 ' ] ; if ( dy < 0 || dx < 0 || dy > 4 || dx > 4 || valid [ dy ] [ dx ] == 0 ) return false ; return calc ( dy , dx , id + 1 ) ; } int main ( ) { for ( int i = 1 ; i <= 9 ; i ++ ) { int x = i - 1 ; posy [ i ] = x / 3 ; posx [ i ] = x % 3 ; valid [ x / 3 ] [ x % 3 ] = 1 ; } posy [ 0 ] = 3 ; posx [ 0 ] = 1 ; valid [ 3 ] [ 1 ] = 1 ; int n ; cin >> n ; cin >> s ; int tot = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( calc ( posy [ i ] , posx [ i ] , 0 ) == true ) tot ++ ; } if ( tot == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 declare integer n ; TAB1 read n ; TAB1 create integer array a with 3 elements ; TAB1 read a [ 1 ] and a [ 2 ] ; TAB1 put 0 to a [ 0 ] ; TAB1 declare integer inp ; TAB1 create unsigned integer left_out = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read inp ; TAB2 if a [ inp ] is greater than 0 ; TAB3 decrement a [ inp ] ; TAB2 else if a [ 2 ] > 0 & & inp = 1 ; TAB3 decrement a [ 2 ] ; TAB3 increase a [ 0 ] by one ; TAB2 else if a [ 0 ] > 0 & & inp = 1 ; TAB3 decrement a [ 0 ] ; TAB2 else ; TAB3 increase left_out by inp ; TAB1 print left_out ;	int main ( ) { int n ; cin >> n ; int a [ 3 ] ; cin >> a [ 1 ] >> a [ 2 ] ; a [ 0 ] = 0 ; int inp ; unsigned int left_out = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> inp ; if ( a [ inp ] > 0 ) a [ inp ] -- ; else if ( a [ 2 ] > 0 && inp == 1 ) { a [ 2 ] -- ; a [ 0 ] ++ ; } else if ( a [ 0 ] > 0 && inp == 1 ) a [ 0 ] -- ; else left_out += inp ; } cout << left_out << endl ; return 0 ; }
TAB1 create integer test with test = 1 ; TAB1 while decrement test is true ; TAB2 create integers n , m , i , j , x , y , s , k , q , a , b , c with c = 0 ; TAB2 create long long integer sum with sum = 0 ; TAB2 read n ; TAB2 for i = 0 to n exclusive ; TAB3 read k ; TAB3 increment sum by k ; TAB3 set c to maximum of c and k ; TAB2 set j to 1 if sum % ( n - 1 ) is greater than 0 , else 0 ; TAB2 set sum to sum / ( n - 1 ) + j ; TAB2 set sum to sum if sum is greater than c , else c ; TAB2 print sum print " \ n " ;	int main ( ) { int test = 1 ; while ( test -- ) { int n , m , i , j , x , y , s , k , q , a , b , c = 0 ; long long int sum = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> k ; sum += k ; c = max ( c , k ) ; } j = sum % ( n - 1 ) > 0 ? 1 : 0 ; sum = sum / ( n - 1 ) + j ; sum = sum > c ? sum : c ; cout << sum << " \n " ; } return 0 ; }
TAB0 num is an integer array with 30 elements and vis is an integer array with 1010 elements ; TAB0 str and ans are character arrays with size 1010 ; TAB1 declare integer variables t , q , i , j , k , len , t1 and mx , with mx = 0 ; TAB1 read str + 1 ; TAB1 len = length of ( str + 1 ) ; TAB1 for i = 1 to len inclusive ; TAB2 t = str [ i ] - ' a ' + 1 ; TAB2 increase num [ t ] by one ; TAB2 if num [ t ] is greater than num [ mx ] set mx to t ; TAB1 let cur = 1 and nf = 0 be integers ; TAB1 for i = 2 to len inclusive ; TAB2 continue the loop if vis [ i ] is not 0 ; TAB2 if i * 2 < = len ; TAB3 for j = i to len inclusive incrementing j by i ; TAB4 continue if vis [ j ] is not 0 ; TAB4 if num [ mx ] < = 0 ; TAB5 assign value of 1 to nf ; TAB5 stop the loop ; TAB4 ans [ j ] = mx - 1 + ' a ' ; TAB4 decrease num [ mx ] ; TAB4 set vis [ j ] to 1 ; TAB2 if nf is not 0 , break ; TAB1 for i = 1 to len while - < = len and ! nf ; TAB2 continue if vis [ i ] is not 0 ; TAB2 while num [ cur ] < = 0 & & cur < = 26 increment cur ; TAB2 if cur is greater than 26 ; TAB3 assign value of 1 to nf ; TAB3 stop the loop ; TAB2 ans [ i ] = cur - 1 + ' a ' ; TAB2 decrease num [ cur ] by one ; TAB1 if nf is not 0 ; TAB2 print " NO \ n " ; TAB1 else ; TAB2 print " YES \ n " , ans + 1 and a new line ;	int num [ 30 ] , vis [ 1010 ] ; char str [ 1010 ] , ans [ 1010 ] ; int main ( ) { int t , q , i , j , k , len , t1 , mx = 0 ; cin >> str + 1 ; len = strlen ( str + 1 ) ; for ( i = 1 ; i <= len ; i ++ ) { t = str [ i ] - ' a ' + 1 ; num [ t ] ++ ; if ( num [ t ] > num [ mx ] ) mx = t ; } int cur = 1 , nf = 0 ; for ( i = 2 ; i <= len ; i ++ ) { if ( vis [ i ] ) continue ; if ( i * 2 <= len ) { for ( j = i ; j <= len ; j += i ) { if ( vis [ j ] ) continue ; if ( num [ mx ] <= 0 ) { nf = 1 ; break ; } ans [ j ] = mx - 1 + ' a ' ; num [ mx ] -- ; vis [ j ] = 1 ; } } if ( nf ) break ; } for ( i = 1 ; i <= len && ! nf ; i ++ ) { if ( vis [ i ] ) continue ; while ( num [ cur ] <= 0 && cur <= 26 ) cur ++ ; if ( cur > 26 ) { nf = 1 ; break ; } ans [ i ] = cur - 1 + ' a ' ; num [ cur ] -- ; } if ( nf ) cout << " NO\n " ; else cout << " YES\n " << ans + 1 << endl ; return 0 ; }
TAB1 declare integer variables n , left , right , up and down ; TAB1 str is string ; TAB1 read n ; TAB1 read str ; TAB1 left , right , up and down = 1 ; TAB1 for integer i = 0 to n exclusive ; TAB2 if str [ i ] = ' 1 ' | | str [ i ] = ' 2 ' | | str [ i ] = ' 3 ' , set up to 0 ; TAB2 if str [ i ] = ' 1 ' | | str [ i ] = ' 4 ' | | str [ i ] = ' 7 ' | | str [ i ] = ' 0 ' , set left to 0 ; TAB2 if str [ i ] = ' 7 ' | | str [ i ] = ' 9 ' | | str [ i ] = ' 0 ' , set down to 0 ; TAB2 if str [ i ] = ' 6 ' | | str [ i ] = ' 9 ' | | str [ i ] = ' 3 ' | | str [ i ] = ' 0 ' , set right to 0 ; TAB1 if down = 1 | | up = 1 | | left = 1 | | right = 1 ; TAB2 print " NO " and a new line ; TAB1 else ; TAB2 print " YES " and a new line ;	int main ( ) { int n , left , right , up , down ; string str ; cin >> n ; cin >> str ; left = right = up = down = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' 1 ' || str [ i ] == ' 2 ' || str [ i ] == ' 3 ' ) up = 0 ; if ( str [ i ] == ' 1 ' || str [ i ] == ' 4 ' || str [ i ] == ' 7 ' || str [ i ] == ' 0 ' ) left = 0 ; if ( str [ i ] == ' 7 ' || str [ i ] == ' 9 ' || str [ i ] == ' 0 ' ) down = 0 ; if ( str [ i ] == ' 6 ' || str [ i ] == ' 9 ' || str [ i ] == ' 3 ' || str [ i ] == ' 0 ' ) right = 0 ; } if ( down == 1 || up == 1 || left == 1 || right == 1 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 declare fastIo with no arguments , returning void ; TAB1 run fastIo ; TAB1 create long longs n , m ; TAB1 read n read m ; TAB1 create long long sum with sum = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 create long long temp ; TAB2 read temp ; TAB2 increment sum by temp ; TAB1 if m - sum is less than 10 * ( n - 1 ) ; TAB2 print " - 1 " print newline ; TAB1 else ; TAB2 set sum to m - sum - 10 * ( n - 1 ) ; TAB2 create long long cnt with cnt = ( n - 1 ) * 2 ; TAB2 increment cnt by sum / 5 ; TAB2 print cnt print newline ;	void fastIo ( ) { } int main ( ) { fastIo ( ) ; long long n , m ; cin >> n >> m ; long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long long temp ; cin >> temp ; sum += temp ; } if ( m - sum < 10 * ( n - 1 ) ) cout << " -1 " << endl ; else { sum = m - sum - 10 * ( n - 1 ) ; long long cnt = ( n - 1 ) * 2 ; cnt += sum / 5 ; cout << cnt << endl ; } return 0 ; }
TAB1 create long longs n , i , ans , m , sol with ans = 0 , m = - 1 ; TAB1 read n ; TAB1 create long long array ar with size n ; TAB1 for i = 0 to n exclusive ; TAB2 read ar [ i ] ; TAB2 set ans to ans + ar [ i ] ; TAB2 set m to maximum of m and ar [ i ] ; TAB1 set sol to ans / ( n - 1 ) ; TAB1 if sol * ( n - 1 ) is not ans , increment sol ; TAB1 print maximum of m and sol , print " \ n " ;	int main ( ) { long long n , i , ans = 0 , m = - 1 , sol ; cin >> n ; long long ar [ n ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> ar [ i ] ; ans = ans + ar [ i ] ; m = max ( m , ar [ i ] ) ; } sol = ( ans ) / ( n - 1 ) ; if ( sol * ( n - 1 ) != ans ) { sol ++ ; } cout << max ( m , sol ) << " \n " ; return 0 ; }
TAB1 hy , ay , dy , hm , am , dm , h , a , d = int ; TAB1 read hy then ay then dy ; TAB1 read hm then am then dm ; TAB1 read h then a then d ; TAB1 minbitcoins = int with minbitcoins = INT_MAX ; TAB1 for t = 1 to 201 ; TAB2 defcos = int with defcos = 0 ; TAB2 if hy is less or equal to am * t - dy * t then set defcos to ( am * t - dy * t - hy + 1 ) * h ; TAB2 if dy * t is greater than am * t - hy ; TAB3 set defcos to 0 ; TAB2 else ; TAB3 set defcos to min of defcos and ( ( am * t - hy ) / t - dy + 1 ) * d ; TAB2 atcos = int with atcos = 0 ; TAB2 if hm + dm * t is greater than ay * t then set atcos to ( rounded up value of ( ( double ) ( hm + dm * t ) / t ) - ay ) * a ; TAB2 set minbitcoins to min of minbitcoins and atcos + defcos ; TAB1 print minbitcoins ;	int main ( ) { int hy , ay , dy , hm , am , dm , h , a , d ; cin >> hy >> ay >> dy ; cin >> hm >> am >> dm ; cin >> h >> a >> d ; int minbitcoins = INT_MAX ; for ( int t = 1 ; t < 201 ; ++ t ) { int defcos = 0 ; if ( hy <= am * t - dy * t ) { defcos = ( am * t - dy * t - hy + 1 ) * h ; } if ( dy * t > ( am * t - hy ) ) defcos = 0 ; else { defcos = min ( defcos , ( ( am * t - hy ) / t - dy + 1 ) * d ) ; } int atcos = 0 ; if ( hm + dm * t > ay * t ) { atcos = ( ceil ( ( double ) ( hm + dm * t ) / t ) - ay ) * a ; } minbitcoins = min ( minbitcoins , atcos + defcos ) ; } cout << minbitcoins << " \n " ; }
TAB1 declare integer called n ; TAB1 read n ; TAB1 let f and z be integers = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare integer a ; TAB2 read a ; TAB2 if a = 5 ; TAB3 increase f by 1 ; TAB2 else ; TAB3 increase z by 1 ; TAB1 f = f / 9 * 9 ; TAB1 if z = 0 ; TAB2 print - 1 and a new line ; TAB1 print string ( f , ' 5 ' ) , " 0 " if f = 0 or string ( z , ' 0 ' ) , and a new line ;	int main ( ) { int n ; cin >> n ; int f = 0 , z = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int a ; cin >> a ; if ( a == 5 ) f += 1 ; else z += 1 ; } f = f / 9 * 9 ; if ( z == 0 ) { cout << - 1 << endl ; return 0 ; } cout << string ( f , ' 5 ' ) << ( f == 0 ? " 0 " : string ( z , ' 0 ' ) ) << endl ; }
TAB1 create integer n , create integer array a with size 11 , with a = { 0 } ; TAB1 read n ; TAB1 create string s ; TAB1 read s ; TAB1 for i = 0 to n exclusive , set a [ s [ i ] - ' 0 ' ] to 1 ; TAB1 create integers flag_u , flag_d , flag_l , flag_r , set flag_u to 1 , set flag_d to 1 , set flag_l to 1 , set flag_r to 1 ; TAB1 if a [ 0 ] ; TAB2 set flag_d to 0 ; TAB2 set flag_l to 0 ; TAB2 set flag_r to 0 ; TAB1 if a [ 0 ] or ( a [ 0 ] is false and a [ 7 ] or a [ 9 ] ) set flag_d to 0 ; TAB1 if a [ 1 ] or a [ 2 ] or a [ 3 ] , set flag_u to 0 ; TAB1 if a [ 1 ] or a [ 4 ] or a [ 7 ] , set flag_l to 0 ; TAB1 if a [ 3 ] or a [ 6 ] or a [ 9 ] , set flag_r to 0 ; TAB1 if not flag_u and not flag_d and not flag_l and not flag_r ; TAB2 print " YES " print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { int n , a [ 11 ] = { 0 } ; cin >> n ; string s ; cin >> s ; for ( int i = 0 ; i < n ; i ++ ) { a [ s [ i ] - ' 0 ' ] = 1 ; } int flag_u = 1 , flag_d = 1 , flag_l = 1 , flag_r = 1 ; if ( a [ 0 ] ) { flag_d = 0 ; flag_l = 0 ; flag_r = 0 ; } if ( a [ 0 ] || ( ! a [ 0 ] && a [ 7 ] || a [ 9 ] ) ) flag_d = 0 ; if ( a [ 1 ] || a [ 2 ] || a [ 3 ] ) flag_u = 0 ; if ( a [ 1 ] || a [ 4 ] || a [ 7 ] ) flag_l = 0 ; if ( a [ 3 ] || a [ 6 ] || a [ 9 ] ) flag_r = 0 ; if ( ! flag_u && ! flag_d && ! flag_l && ! flag_r ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 create integers i , j , n , count ; TAB1 create 2d character array a with size 1001 by 5 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 5 exclusive , read a [ i ] [ j ] ; TAB1 for x = 0 to n exclusive ; TAB2 for y = 0 to 5 exclusive ; TAB3 if a [ x ] [ y ] is ' O ' and a [ x ] [ y + 1 ] is ' O ' ; TAB4 set count to 0 ; TAB4 print " YES " print newline ; TAB4 set a [ x ] [ y ] to ' + ' ; TAB4 set a [ x ] [ y + 1 ] to ' + ' ; TAB4 break loop ; TAB3 else ; TAB4 increment y by 2 ; TAB4 set count to 1 ; TAB2 if count is 0 , break loop ; TAB1 if count is 1 , print " NO " print newline ; TAB1 if count is 0 ; TAB2 for k = 0 to n exclusive ; TAB3 for l = 0 to 5 exclusive , print a [ k ] [ l ] ; TAB3 print newline ;	int main ( ) { int i , j , n , count ; char a [ 1001 ] [ 5 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 5 ; j ++ ) { cin >> a [ i ] [ j ] ; } } for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < 5 ; y ++ ) { if ( a [ x ] [ y ] == ' O ' && a [ x ] [ y + 1 ] == ' O ' ) { count = 0 ; cout << " YES " << endl ; a [ x ] [ y ] = ' + ' ; a [ x ] [ y + 1 ] = ' + ' ; break ; } else { y += 2 ; count = 1 ; } } if ( count == 0 ) break ; } if ( count == 1 ) { cout << " NO " << endl ; } if ( count == 0 ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) { cout << a [ k ] [ l ] ; } cout << endl ; } } return 0 ; }
TAB0 k = array of ints of length 10000000 ; TAB1 create integers a , b , p , m , j with m and j set to 0 ; TAB1 read p , a and b ; TAB1 for i = 1 to p inclusive read k [ i ] ; TAB1 for i = 1 to p inclusive ; TAB2 if k [ i ] is 1 ; TAB3 if a is greater than 0 ; TAB4 set a to a - 1 ; TAB4 continue ; TAB3 else if b is greater than 0 ; TAB4 set b to b - 1 ; TAB4 assign m + 1 to m ; TAB4 continue ; TAB3 else if m is greater than 0 ; TAB4 set m to m - 1 ; TAB4 continue ; TAB3 else do the following ; TAB4 assign j + 1 to j ; TAB4 continue ; TAB2 else do the following ; TAB3 if b is greater than 0 ; TAB4 set b to b - 1 ; TAB4 continue ; TAB3 else do the following ; TAB4 assign j + 2 to j ; TAB4 continue ; TAB1 print j ;	int k [ 10000000 ] ; int main ( ) { int a , b , p , m = 0 , j = 0 ; cin >> p >> a >> b ; for ( int i = 1 ; i <= p ; i ++ ) { cin >> k [ i ] ; } for ( int i = 1 ; i <= p ; i ++ ) { if ( k [ i ] == 1 ) { if ( a > 0 ) { a = a - 1 ; continue ; } else if ( b > 0 ) { b = b - 1 ; m = m + 1 ; continue ; } else if ( m > 0 ) { m = m - 1 ; continue ; } else { j = j + 1 ; continue ; } } else { if ( b > 0 ) { b = b - 1 ; continue ; } else { j = j + 2 ; continue ; } } } cout << j << endl ; return 0 ; }
TAB0 create long long n ; TAB0 cad is string ; TAB0 declare boolean variable called power ; TAB1 read n ; TAB1 read cad ; TAB1 set value of power to true ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare integer called x = cad [ i ] - ' 0 ' ; TAB2 if x = 0 , set x to 1 ; TAB2 if x = 1 or x = 4 or x = 7 , set power to false ; TAB1 if power is true ; TAB2 print " NO \ n " ; TAB1 power = true ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare integer variable called x = cad [ i ] - ' 0 ' ; TAB2 if x = 0 set x to 9 ; TAB2 if x = 3 or x = 6 or x = 9 , set power to false ; TAB1 if power = true ; TAB2 print " NO \ n " ; TAB1 assign value of true to power ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare integer called x = cad [ i ] - ' 0 ' ; TAB2 if x = 0 , set x = 11 ; TAB2 if x - 3 is less than 1 , set power to false ; TAB1 if power is true ; TAB2 print " NO \ n " ; TAB1 assign value of true to power ; TAB1 for i = 0 to n exclusive ; TAB2 create integer x = cad [ i ] - ' 0 ' ; TAB2 if x = 8 ; TAB2 if x = 0 ; TAB2 if x + 3 is greater than 9 , set power to false ; TAB1 if power is true ; TAB2 print " NO \ n " ; TAB1 print " YES \ n " ;	long long n ; string cad ; bool power ; int main ( ) { cin >> n ; cin >> cad ; power = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = cad [ i ] - ' 0 ' ; if ( x == 0 ) x = 1 ; if ( x == 1 || x == 4 || x == 7 ) power = false ; } if ( power ) { cout << " NO\n " ; return 0 ; } power = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = cad [ i ] - ' 0 ' ; if ( x == 0 ) x = 9 ; if ( x == 3 || x == 6 || x == 9 ) power = false ; } if ( power ) { cout << " NO\n " ; return 0 ; } power = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = cad [ i ] - ' 0 ' ; if ( x == 0 ) x = 11 ; if ( x - 3 < 1 ) power = false ; } if ( power ) { cout << " NO\n " ; return 0 ; } power = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = cad [ i ] - ' 0 ' ; if ( x == 8 ) x = 5 ; if ( x == 0 ) x = 11 ; if ( x + 3 > 9 ) power = false ; } if ( power ) { cout << " NO\n " ; return 0 ; } cout << " YES\n " ; return 0 ; }
TAB0 let n be integer ; TAB0 m = long long ; TAB0 s = long long ; TAB1 read n in a loop ; TAB2 s = 0 ; TAB2 for integer i = 0 to n exclusive ; TAB3 t = integer ; TAB3 read t ; TAB3 increase s by t ; TAB3 if i = 0 ; TAB4 set m to t ; TAB3 else ; TAB4 if m is less than t ; TAB2 long long x = s / ( n - 1 ) ; TAB2 if s % ( n - 1 ) is not 0 , increment x ; TAB2 if m is greater than x set x to the value of m ; TAB2 print x and a new line ;	int n ; long long m ; long long s ; int main ( ) { while ( cin >> n ) { s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int t ; cin >> t ; s += t ; if ( i == 0 ) m = t ; else { if ( m < t ) m = t ; } } long long x = s / ( n - 1 ) ; if ( s % ( n - 1 ) ) x ++ ; if ( m > x ) x = m ; cout << x << endl ; } }
TAB1 let n , d , t , aux be integers with aux is equal to 0 ; TAB1 read n and d ; TAB1 for i = 0 to n exclusive ; TAB2 read t ; TAB2 aux is equal to ( aux + t ) ; TAB1 if ( aux + ( n - 1 ) * 10 is greater than d ) ; TAB2 print - 1 and newline ; TAB1 else do the following ; TAB2 print ( d - aux ) / 5 and newline ;	int main ( ) { int n , d , t , aux = 0 ; cin >> n >> d ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t ; aux += t ; } if ( aux + ( n - 1 ) * 10 > d ) { cout << - 1 << endl ; return 0 ; } else { cout << ( d - aux ) / 5 << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 declare boolean check = false ; TAB1 read n ; TAB1 declare string variable input = " " ; TAB1 declare vector of characters result ; TAB1 read and discard current input ; TAB1 for integer i = 0 to n exclusive ; TAB2 read input into input ; TAB2 if ( input [ 0 ] = ' O ' ) & & ( input [ 1 ] = ' O ' ) & & check is false ; TAB3 assign value of true to check ; TAB3 push " + " to result ; TAB3 push " + " to result ; TAB2 else ; TAB3 push input [ 0 ] to result ; TAB3 push input [ 1 ] to result ; TAB2 push input [ 2 ] to result ; TAB2 if ( input [ 3 ] = ' O ' ) & & ( input [ 4 ] = ' O ' ) & & check is false ; TAB3 set value of check to true ; TAB3 push " + " to result ; TAB3 push " + " to result ; TAB3 push " \ n " to result ; TAB2 else ; TAB3 push input [ 3 ] to result ; TAB3 push input [ 4 ] to result ; TAB3 push " \ n " to result ; TAB1 print " YES " is check is true or " NO " if it false , and a new line ; TAB1 for integer i = 0 to length of result exclusive , while check is true , print result [ i ] ;	int main ( ) { int n ; bool check = false ; cin >> n ; string input = "  " ; vector < char > result ; cin . ignore ( ) ; for ( int i = 0 ; i < n ; i ++ ) { getline ( cin , input ) ; if ( ( input [ 0 ] == ' O ' ) && ( input [ 1 ] == ' O ' ) && ! check ) { check = true ; result . push_back ( ' + ' ) ; result . push_back ( ' + ' ) ; } else { result . push_back ( input [ 0 ] ) ; result . push_back ( input [ 1 ] ) ; } result . push_back ( input [ 2 ] ) ; if ( ( input [ 3 ] == ' O ' ) && ( input [ 4 ] == ' O ' ) && ! check ) { check = true ; result . push_back ( ' + ' ) ; result . push_back ( ' + ' ) ; result . push_back ( ' \n ' ) ; } else { result . push_back ( input [ 3 ] ) ; result . push_back ( input [ 4 ] ) ; result . push_back ( ' \n ' ) ; } } cout << ( check ? " YES " : " NO " ) << endl ; for ( int i = 0 ; i < result . size ( ) && check ; i ++ ) { cout << result [ i ] ; } return 0 ; }
TAB0 let n , m , p , a and b be integers ; TAB0 void function solve ; TAB1 read a , b and n ; TAB1 let tmp be integer = a * 10 ; TAB1 for i = 0 to 10 exclusive ; TAB2 if tmp % b = 0 ; TAB3 print tmp ; TAB3 print " 0 " n - 1 times ; TAB3 print new line ; TAB3 return ; TAB2 increase tmp ; TAB1 print - 1 and a new line ; TAB1 ; ; TAB1 declare integer variable T = 1 ; TAB1 call solve ( ) T times ;	int n , m , p , a , b ; void solve ( ) { cin >> a >> b >> n ; int tmp = a * 10 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( tmp % b == 0 ) { cout << tmp ; for ( int i = 0 ; i < n - 1 ; ++ i ) cout << " 0 " ; cout << endl ; return ; } tmp ++ ; } cout << - 1 << endl ; } int main ( ) { ; int T = 1 ; for ( int i = 0 ; i < T ; i ++ ) { solve ( ) ; } return 0 ; }
TAB0 long long integer n , and an array a of long long integers with size 100010 ; TAB0 boolean function check with long long int argument x ; TAB1 tmp and i are long long integers , with tmp = 0 ; TAB1 for i = 0 to n exclusive , increment tmp by x - a [ i ] ; TAB1 return ( tmp > = x ) ; TAB0 long long int function binSearch with long long integer arguments low and high ; TAB1 while low is less than high ; TAB2 long long int mid = low + ( high - low ) / 2 ; TAB2 if check ( mid ) returns true ; TAB3 assign value of mid to high ; TAB2 else ; TAB3 assign value of mid + 1 to low ; TAB1 return low ; TAB1 t is long long integer = 1 ; TAB1 decrement t in a loop ; TAB2 ans and i are long long integers , with ans = 0 ; TAB2 read n ; TAB2 read n elements into a ; TAB2 sort a ; TAB2 set ans to binSearch ( a [ n - 1 ] , 1e14 ) ; TAB2 print ans and " \ n " ;	long long int a [ 100010 ] , n ; bool check ( long long int x ) { long long int tmp = 0 , i ; for ( i = 0 ; i < n ; i ++ ) tmp += ( x - a [ i ] ) ; return ( tmp >= x ) ; } long long int binSearch ( long long int low , long long int high ) { while ( low < high ) { long long int mid = low + ( high - low ) / 2 ; if ( check ( mid ) ) high = mid ; else low = mid + 1 ; } return low ; } int main ( ) { long long int t = 1 ; while ( t -- ) { long long int ans = 0 , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; ans = binSearch ( a [ n - 1 ] , 1e14 ) ; cout << ans << " \n " ; } return 0 ; }
TAB0 pi = const double with pi = acos of - 1 ; TAB0 MODPRIMA = const long long with MODPRIMA = 1e9 + 7 ; TAB0 MAXX = const long long with MAXX = 1e18 ; TAB0 MINN = const long long with MINN = - 1e18 ; TAB0 EPS = const double with EPS = 1e - 9 ; TAB0 N , M , K = long long ; TAB1 read N then M then K ; TAB1 if K is greater than N - 1 + M - 1 ; TAB2 print - 1 ; TAB1 else ; TAB2 ans = long long with ans = 0 ; TAB2 if K is less than N then set ans to ( N / ( K + 1 ) ) * M ; TAB2 if K is less than M then set ans to max of ans and ( M / ( K + 1 ) ) * N ; TAB2 if K is greater or equal to N then set ans to max of ans and ( M / ( K - ( N - 1 ) + 1 ) ) ; TAB2 if K is greater or equal to M then set ans to max of ans and ( N / ( K - ( M - 1 ) + 1 ) ) ; TAB2 print ans ;	const double pi = acos ( - 1 ) ; const long long MODPRIMA = ( long long ) 1e9 + 7 ; const long long MAXX = ( long long ) 1e18 ; const long long MINN = - ( long long ) 1e18 ; const double EPS = 1e-9 ; long long N , M , K ; int main ( ) { cin >> N >> M >> K ; if ( K > N - 1 + M - 1 ) cout << - 1 << ' \n ' ; else { long long ans = 0 ; if ( K <= N - 1 ) { ans = ( N / ( K + 1 ) ) * M ; } if ( K <= M - 1 ) { ans = max ( ans , ( M / ( K + 1 ) ) * N ) ; } if ( K > N - 1 ) { ans = max ( ans , ( M / ( K - ( N - 1 ) + 1 ) ) ) ; } if ( K > M - 1 ) { ans = max ( ans , ( N / ( K - ( M - 1 ) + 1 ) ) ) ; } cout << ans << ' \n ' ; } return 0 ; }
TAB0 n , m , k , ans = integers with ans = 0 ; TAB1 Read n , m , k ; TAB1 if n is greater than m ; TAB2 t = integer , set to n ; TAB2 set n to m ; TAB2 set m to t ; TAB1 if k is greater than n + m - 2 ; TAB2 print - 1 and a new line ; TAB1 if k is less than m ; TAB2 print maximum value of m / ( k + 1 ) * n and n / ( k + 1 ) * m and a new line ; TAB1 else do the following ; TAB2 print n / ( k + 2 - m ) and new line ;	long long int n , m , k , ans = 0 ; int main ( ) { cin >> n >> m >> k ; if ( n > m ) { long long int t = n ; n = m ; m = t ; } if ( k > n + m - 2 ) { cout << - 1 << endl ; return 0 ; } if ( k < m ) cout << max ( m / ( k + 1 ) * n , n / ( k + 1 ) * m ) << endl ; else cout << ( n / ( k + 2 - m ) ) << endl ; return 0 ; }
TAB0 declare long longs called n , maxn , sum , tot and ans ; TAB0 long long integer method read ; TAB1 X and w are long longs = 0 ; TAB1 set character ch to 0 ; TAB1 while isdigit ( ch ) is false , w | = ch = ' - ' , ch = char from the input ; TAB1 while isdigit ( ch ) is true , X = ( X < < 3 ) + ( X < < 1 ) + ( ch ^ 48 ) , ch = char from the input ; TAB1 return - X is w , or X ; TAB0 in the method write with long long argument x ; TAB1 create long long num with value 0 ; TAB1 let ch be an array of characters of size 20 ; TAB1 if x is 0 , increment num and set ch [ num ] to ' 0 ' ; TAB1 while x is 1 , increment num and set ch [ num ] to ( x % 10 ) + 48 , x / = 10 ; TAB1 while num is 1 putchar ( ch [ num - - ] ) ; TAB1 call function puts with arguments " " ; TAB1 n = read ( ) ; TAB1 for i = 1 to n inclusive ; TAB2 assign result of the read ( ) to the long long x ; TAB2 decrease sum by x ; TAB2 set maxn to max of maxn and x ; TAB1 tot = maxn * n + sum ; TAB1 if tot > = maxn ; TAB2 invoke function write with arguments maxn ; TAB1 else ; TAB2 ans = maxn + ceil ( ( maxn - tot ) / ( n - 1 . 0 ) ) ; TAB2 call function write with arguments ans ;	long long n , maxn , sum , tot , ans ; inline long long read ( ) { long long X = 0 , w = 0 ; char ch = 0 ; while ( ! isdigit ( ch ) ) w |= ch == ' - ' , ch = getchar ( ) ; while ( isdigit ( ch ) ) X = ( X << 3 ) + ( X << 1 ) + ( ch ^ 48 ) , ch = getchar ( ) ; return w ? - X : X ; } inline void write ( long long x ) { long long num = 0 ; char ch [ 20 ] ; if ( ! x ) ch [ ++ num ] = ' 0 ' ; while ( x ) ch [ ++ num ] = ( x % 10 ) + 48 , x /= 10 ; while ( num ) putchar ( ch [ num -- ] ) ; puts ( "  " ) ; } int main ( ) { n = read ( ) ; for ( int i = 1 ; i <= n ; ++ i ) { long long x = read ( ) ; sum -= x ; maxn = max ( maxn , x ) ; } tot = maxn * n + sum ; if ( tot >= maxn ) write ( maxn ) ; else { ans = maxn + ceil ( ( maxn - tot ) / ( n - 1.0 ) ) ; write ( ans ) ; } return 0 ; }
TAB1 create integer n ; TAB1 create booleans z , y , x , with z = 1 , y = 1 , x = 0 ; TAB1 create 2d character array arr with size 1069 by 1069 ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 inclusive , read arr [ i ] [ j ] ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 inclusive ; TAB3 if arr [ i ] [ j ] is arr [ i ] [ j + 1 ] and arr [ i ] [ j ] is ' O ' , set x to 1 ; TAB1 if x is true ; TAB2 print " YES \ n " ; TAB1 else ; TAB2 print " NO \ n " ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 inclusive ; TAB3 if arr [ i ] [ j ] is arr [ i ] [ j + 1 ] and arr [ i ] [ j ] is ' O ' and z is 1 ; TAB4 print " + " ; TAB4 set z to false ; TAB3 else if arr [ i ] [ j ] is arr [ i ] [ j - 1 ] and arr [ i ] [ j ] is ' O ' and y is 1 ; TAB4 print ' + ' ; TAB4 set y to 0 ; TAB3 else ; TAB4 print arr [ i ] [ j ] ; TAB2 print newline ;	int main ( ) { int n ; bool z = 1 , y = 1 , x = 0 ; char arr [ 1069 ] [ 1069 ] ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= 5 ; j ++ ) { cin >> arr [ i ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= 5 ; j ++ ) { if ( arr [ i ] [ j ] == arr [ i ] [ j + 1 ] && arr [ i ] [ j ] == ' O ' ) { x = 1 ; } } } if ( x ) cout << " YES\n " ; else { cout << " NO\n " ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= 5 ; j ++ ) { if ( arr [ i ] [ j ] == arr [ i ] [ j + 1 ] && arr [ i ] [ j ] == ' O ' && z == 1 ) { cout << " + " ; z = false ; } else if ( arr [ i ] [ j ] == arr [ i ] [ j - 1 ] && arr [ i ] [ j ] == ' O ' && y == 1 ) { cout << ' + ' ; y = 0 ; } else { cout << arr [ i ] [ j ] ; } } cout << endl ; } }
TAB1 n , temp = integers ; TAB1 zeros , fives = integers with zeros = 0 and fives = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read temp ; TAB2 if temp = 5 ; TAB3 increment fives ; TAB2 else ; TAB3 increment zeros ; TAB1 if zeros > 0 and fives > 9 ; TAB2 i = 0 ; TAB2 for i = 1 to ( fives - fives remainder 9 ) inclusive print 5 ; TAB2 while decrement zeros print 0 ; TAB2 print newline ; TAB1 else if zeros < = 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print 0 ;	int main ( ) { int n , temp ; int zeros = 0 , fives = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> temp ; if ( temp == 5 ) fives ++ ; else zeros ++ ; } if ( zeros > 0 && fives >= 9 ) { int i = 0 ; for ( int i = 1 ; i <= ( fives - ( fives % 9 ) ) ; i ++ ) { cout << 5 ; } while ( zeros -- ) { cout << 0 ; } cout << endl ; } else if ( zeros <= 0 ) { cout << " -1 " << endl ; } else { cout << 0 << endl ; } }
TAB1 let n , a , b , sum , ans and s be integers where sum and s = 0 ; TAB1 read n , a and b ; TAB1 for integer i = 0 to n exclusive ; TAB2 read ans ; TAB2 if ans = 1 ; TAB3 if a is greater than 0 ; TAB4 decrement a ; TAB3 else if b is greater than 0 ; TAB4 decrement b ; TAB4 increase s ; TAB3 else if s ! = 0 ; TAB4 decrease s ; TAB3 else ; TAB4 increase sum ; TAB2 else ; TAB3 if b is greater than 0 ; TAB4 decrease b ; TAB3 else ; TAB4 assign value of sum + 2 to sum ; TAB1 print sum ;	int main ( ) { int n , a , b , sum = 0 , ans , s = 0 ; cin >> n >> a >> b ; for ( int i = 0 ; i < n ; i ++ ) { cin >> ans ; if ( ans == 1 ) { if ( a > 0 ) a -- ; else if ( b > 0 ) { b -- ; s ++ ; } else if ( s != 0 ) s -- ; else { sum ++ ; } } else { if ( b > 0 ) b -- ; else sum = sum + 2 ; } } cout << sum << endl ; return 0 ; }
TAB0 the integer value of long is sum ; TAB0 let mx , n be integers ; TAB1 read the value of n ; TAB1 for i = 0 to n exclusive ; TAB2 let x be a integer ; TAB2 read the value of x ; TAB2 sum is equal to sum + x ; TAB2 mx is equal to maximum of mx and x ; TAB1 printout max ( 1LL * mx , ( sum + n - 2 ) / ( n - 1 ) ) and newline ;	long long sum ; int mx , n ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; sum += x ; mx = max ( mx , x ) ; } cout << max ( 1LL * mx , ( sum + n - 2 ) / ( n - 1 ) ) << endl ; return 0 ; }
TAB0 s = array of 1001 strings ; TAB0 x = string ; TAB0 n = int ; TAB1 read n ; TAB1 for i = 0 to n exclusive read s [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 if first char of s [ i ] is ' O ' and is equal to second char ; TAB3 first and second chars of s [ i ] = ' + ' ; TAB3 print " YES " ; TAB3 for i = 0 to n exclusive read s [ i ] ; TAB2 if fourth char of s [ i ] is ' O ' and is equal to fifth char ; TAB3 fourth and fifth chars of s [ i ] = ' + ' ; TAB3 print " YES " ; TAB3 for i = 0 to n exclusive read s [ i ] ; TAB1 print " NO " ;	string s [ 1001 ] ; string x ; int n ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] [ 0 ] == ' O ' && s [ i ] [ 0 ] == s [ i ] [ 1 ] ) { s [ i ] [ 0 ] = s [ i ] [ 1 ] = ' + ' ; cout << " YES " << endl ; for ( int i = 0 ; i < n ; i ++ ) cout << s [ i ] << endl ; return 0 ; } if ( s [ i ] [ 3 ] == ' O ' && s [ i ] [ 3 ] == s [ i ] [ 4 ] ) { s [ i ] [ 3 ] = s [ i ] [ 4 ] = ' + ' ; cout << " YES " << endl ; for ( int i = 0 ; i < n ; i ++ ) cout << s [ i ] << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; }
TAB0 create integer arrays num , vis with num size 30 , vis size 1010 ; TAB0 create character arrays str , ans , with str size 1010 , ans size 1010 ; TAB1 create integers t , q , i , j , k , len , mx , mp , with mx = 0 ; TAB1 create character mw ; TAB1 read str + 1 ; TAB1 set len to string length of ( str + 1 ) ; TAB1 for i = 1 to len inclusive ; TAB2 set t to str [ i ] - ' a ' + 1 ; TAB2 increment num [ t ] ; TAB2 if num [ t ] is greater than mx ; TAB3 set mx to num [ t ] ; TAB3 set mp to t ; TAB1 create integers cur , nf with cur = 1 , nf = 0 ; TAB1 for i = 2 to len inclusive ; TAB2 if vis [ i ] is true , break current loop iteration ; TAB2 if i * 2 is less than or equal to len ; TAB3 for j = i to len inclusive , increment j by i ; TAB4 if vis [ j ] is true , break current loop iteration ; TAB4 if num [ mp ] is less than or equal to 0 ; TAB5 set nf to 1 ; TAB5 break loop ; TAB4 set ans [ j ] to mp - 1 + ' a ' ; TAB4 decrement num [ mp ] ; TAB4 set vis [ j ] to 1 ; TAB2 if nf is true , break loop ; TAB1 for i = 1 to len inclusive ; TAB2 if vis [ i ] is true , break current loop iteration ; TAB2 while num [ cur ] is lesser than or equal to 0 and cur is lesser than or equal to 26 , increment cur ; TAB2 if cur is greater than 26 ; TAB3 set nf to 1 ; TAB3 break loop ; TAB2 set ans [ i ] to cur - 1 + ' a ' ; TAB2 decrement num [ cur ] ; TAB1 if nf is true ; TAB2 print " NO \ n " ; TAB1 else ; TAB2 print " YES \ n " print ans + 1 print newline ;	int num [ 30 ] , vis [ 1010 ] ; char str [ 1010 ] , ans [ 1010 ] ; int main ( ) { int t , q , i , j , k , len , mx = 0 , mp ; char mw ; cin >> str + 1 ; len = strlen ( str + 1 ) ; for ( i = 1 ; i <= len ; i ++ ) { t = str [ i ] - ' a ' + 1 ; num [ t ] ++ ; if ( num [ t ] > mx ) { mx = num [ t ] ; mp = t ; } } int cur = 1 , nf = 0 ; for ( i = 2 ; i <= len ; i ++ ) { if ( vis [ i ] ) continue ; if ( i * 2 <= len ) { for ( j = i ; j <= len ; j += i ) { if ( vis [ j ] ) continue ; if ( num [ mp ] <= 0 ) { nf = 1 ; break ; } ans [ j ] = mp - 1 + ' a ' ; num [ mp ] -- ; vis [ j ] = 1 ; } } if ( nf ) break ; } for ( i = 1 ; i <= len ; i ++ ) { if ( vis [ i ] ) continue ; while ( num [ cur ] <= 0 && cur <= 26 ) cur ++ ; if ( cur > 26 ) { nf = 1 ; break ; } ans [ i ] = cur - 1 + ' a ' ; num [ cur ] -- ; } if ( nf ) cout << " NO\n " ; else cout << " YES\n " << ans + 1 << endl ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create integers cf , cz with cf = 0 , cz = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 create integer t ; TAB2 read t ; TAB2 if t is 5 ; TAB3 increment cf ; TAB2 else ; TAB3 increment cz ; TAB1 if cz is 0 ; TAB2 print - 1 print newline ; TAB1 for i = 0 to cf / 9 * 9 exclusive , print " 5 " ; TAB1 if cf is greater than or equal to 9 ; TAB2 for i = 0 to cz exclusive , print " 0 " ; TAB1 else ; TAB2 print " 0 " ; TAB1 print newline ;	int main ( ) { int n ; cin >> n ; int cf = 0 , cz = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int t ; cin >> t ; if ( t == 5 ) cf ++ ; else cz ++ ; } if ( cz == 0 ) { cout << - 1 << endl ; return 0 ; } for ( int i = 0 ; i < cf / 9 * 9 ; i ++ ) { cout << " 5 " ; } if ( cf >= 9 ) for ( int i = 0 ; i < cz ; i ++ ) cout << " 0 " ; else cout << " 0 " ; cout << endl ; }
TAB1 declare long integers a , b , c , d , i , j , k , l , n and m with b = 0 ; TAB1 read n and m ; TAB1 assign value of m to d ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 increase b by a ; TAB1 decrease m by b ; TAB1 c = m / 10 ; TAB1 if c > = ( n - 1 ) and ( b < = d ) ; TAB2 print m / 5 ; TAB1 else ; TAB2 print " - 1 " ;	int main ( ) { long int a , b = 0 , c , d , i , j , k , l , n , m ; cin >> n >> m ; d = m ; for ( i = 0 ; i < n ; i ++ ) { cin >> a ; b += a ; } m -= b ; c = m / 10 ; if ( c >= ( n - 1 ) && ( b <= d ) ) { cout << m / 5 << endl ; } else cout << " -1 " << endl ; }
TAB1 set ng , a , b , h to 0 ; TAB1 read ng , a and b ; TAB1 assign 0 to ans ; TAB1 create int k ; TAB1 for i = 0 to ng exclusive ; TAB2 read k ; TAB2 if k = 1 ; TAB3 if a is greater than 0 ; TAB4 decrement a ; TAB3 else if b > 0 ; TAB4 decrement b ; TAB4 increment h ; TAB3 otherwise if h > 0 ; TAB4 decrement h ; TAB3 else ; TAB4 add 1 to ans ; TAB2 else ; TAB3 if b is greater than 0 ; TAB4 decrement b ; TAB3 other ; TAB4 ans = ans + 2 ; TAB1 print ans ;	int main ( ) { int ng , a , b , h = 0 ; cin >> ng >> a >> b ; int ans = 0 ; int k ; for ( int i = 0 ; i < ng ; ++ i ) { cin >> k ; if ( k == 1 ) { if ( a > 0 ) a -- ; else if ( b > 0 ) { b -- ; h ++ ; } else if ( h > 0 ) { h -- ; } else ans ++ ; } else { if ( b > 0 ) b -- ; else ans += 2 ; } } cout << ans << endl ; return 0 ; }
TAB0 create long long b , n , a , s , e , g , h , i , t ; TAB1 read n , a , b ; TAB1 for i = 0 to n exclusive ; TAB2 read t ; TAB2 if t = 1 ; TAB3 if a > 0 ; TAB4 decrement a ; TAB3 else ; TAB4 if b > 0 ; TAB5 decrement b ; TAB5 increment h ; TAB4 otherwise ; TAB5 if h > 0 ; TAB6 decrement h ; TAB5 else ; TAB6 increment g ; TAB2 if t = 2 ; TAB3 if b > 0 ; TAB4 decrement b ; TAB3 else ; TAB4 g = g + 2 ; TAB1 print g ;	long long b , n , a , s , e , g , h , i , t ; int main ( ) { cin >> n >> a >> b ; for ( i = 0 ; i < n ; i ++ ) { cin >> t ; if ( t == 1 ) { if ( a > 0 ) a -- ; else { if ( b > 0 ) { b -- ; h ++ ; } else { if ( h > 0 ) h -- ; else g ++ ; } } } if ( t == 2 ) { if ( b > 0 ) b -- ; else { g += 2 ; } } } cout << g << endl ; return 0 ; }
TAB0 h1 , h2 , a1 , a2 , d1 , d2 , hc , dc , ac = integers ; TAB0 in the function win that takes integers h1 , h2 , a1 , a2 , d1 , d2 , hc , dc , ac and returns integer ; TAB1 x1 , x2 = integer with x1 = max ( 0 , a2 - d1 ) , x2 = max ( 0 , a1 - d2 ) ; TAB1 if x1 is 0 and x2 is not 0 , return 1 ; TAB1 if x2 is 0 , return 0 ; TAB1 k1 , k2 = integers with k1 = ceil of ( double ) h1 / x1 ) , k2 = ceil of ( double ) h2 / x2 ) ; TAB1 if k1 > k2 , return 1 ; TAB1 read h1 , a1 , d1 ; TAB1 read h2 , a2 , d2 ; TAB1 read hc , ac , dc ; TAB1 ans = integer with ans = 1000000 ; TAB1 if win takes h1 , h2 , a1 , d1 , a2 , d2 ; TAB2 print 0 ; TAB1 k = integer ; TAB1 if max of a2 - d1 and 0 is 0 ; TAB2 print ( d2 + 1 - a1 ) * ac ; TAB1 k = ceil of ( double ) h1 / ( a2 - d1 ) ; TAB1 for d = 0 to a2 ; TAB2 for a = 0 to 200 ; TAB3 if win takes h1 , h2 , a1 + a , d1 + d , a2 , d2 ; TAB4 ans = min of ans and a * ac + d * dc ; TAB4 continue next iteration ; TAB3 for i = k + 1 to 100 ; TAB4 h = integer with h = ( i - 1 ) * ( a2 - d1 ) + 1 - h1 ; TAB4 if win takes h1 + h , h2 , a1 + a , d1 + d , a2 , d2 ; TAB5 ans = min of ans and h * hc + a * ac + d * dc ; TAB5 continue next iteration ; TAB1 print ans ;	int h1 , h2 , a1 , a2 , d1 , d2 , hc , dc , ac ; int win ( int h1 , int h2 , int a1 , int d1 , int a2 , int d2 ) { int x1 = max ( 0 , a2 - d1 ) , x2 = max ( 0 , a1 - d2 ) ; if ( x1 == 0 && x2 != 0 ) return 1 ; if ( x2 == 0 ) return 0 ; int k1 = ceil ( ( double ) h1 / x1 ) , k2 = ceil ( ( double ) h2 / x2 ) ; if ( k1 > k2 ) return 1 ; return 0 ; } int main ( ) { cin >> h1 >> a1 >> d1 ; cin >> h2 >> a2 >> d2 ; cin >> hc >> ac >> dc ; int ans = 1000000 ; if ( win ( h1 , h2 , a1 , d1 , a2 , d2 ) ) { cout << 0 << endl ; return 0 ; } int k ; if ( max ( a2 - d1 , 0 ) == 0 ) { cout << ( d2 + 1 - a1 ) * ac << endl ; return 0 ; } k = ceil ( ( double ) h1 / ( a2 - d1 ) ) ; for ( int d = 0 ; d <= a2 ; d ++ ) for ( int a = 0 ; a <= 200 ; a ++ ) { if ( win ( h1 , h2 , a1 + a , d1 + d , a2 , d2 ) ) { ans = min ( ans , a * ac + d * dc ) ; continue ; } for ( int i = k + 1 ; i <= 100 ; i ++ ) { int h = ( i - 1 ) * ( a2 - d1 ) + 1 - h1 ; if ( win ( h1 + h , h2 , a1 + a , d1 + d , a2 , d2 ) ) { ans = min ( ans , h * hc + a * ac + d * dc ) ; continue ; } } } cout << ans << endl ; return 0 ; }
TAB0 declare prime with integer x as argument , returning integer ; TAB1 for i = 2 to x exclusive ; TAB2 if x % i is 0 , return false from function ; TAB1 return true from function ; TAB1 create string s ; TAB1 read s ; TAB1 create integer comp with comp = length of s - 1 ; TAB1 for i = 2 to length of s inclusive ; TAB2 if 2 * i is greater than length of s and result of run prime with i as argument , decrement comp ; TAB1 create integer vector letters initialized with 26 , 0 ; TAB1 for i = 0 to length of s exclusive , increment letter [ s [ i ] - ' a ' ] ; TAB1 create boolean ok with ok = false ; TAB1 create integer let ; TAB1 for i = 0 to 26 exclusive ; TAB2 if letters [ i ] is greater than or equal to comp ; TAB3 set let to i , set ok to true ; TAB3 break loop ; TAB1 create integer cur with cur = 0 ; TAB1 if not ok ; TAB2 print " NO \ n " ; TAB1 decrement letters [ let ] by comp ; TAB1 print " YES \ n " ; TAB1 create string t with t = " " ; TAB1 for i = 1 to length of s inclusive ; TAB2 if i is 1 or ( 2 * i is greater than length of s and result of run prime with i as argument ) ; TAB3 while letters [ cur ] is 0 , increment cur ; TAB3 increment to by character casted ( ' a ' + cur ) ; TAB3 decrement letters [ cur ] ; TAB2 else ; TAB3 increment t by character casted ( ' a ' + let ) ; TAB1 print t print newline ;	int prime ( int x ) { for ( int i = 2 ; i < x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } int main ( ) { string s ; cin >> s ; int comp = s . length ( ) - 1 ; for ( int i = 2 ; i <= s . length ( ) ; i ++ ) { if ( 2 * i > s . length ( ) && prime ( i ) ) comp -- ; } vector < int > letters ( 26 , 0 ) ; for ( size_t i = 0 ; i < s . length ( ) ; i ++ ) { ++ letters [ s [ i ] - ' a ' ] ; } bool ok = false ; int let ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( letters [ i ] >= comp ) { let = i , ok = true ; break ; } } int cur = 0 ; if ( ! ok ) { cout << " NO\n " ; return 0 ; } letters [ let ] -= comp ; cout << " YES\n " ; string t = "  " ; for ( int i = 1 ; i <= s . length ( ) ; i ++ ) { if ( i == 1 || ( 2 * i > s . length ( ) && prime ( i ) ) ) { while ( letters [ cur ] == 0 ) cur ++ ; t += ( char ) ( ' a ' + cur ) ; -- letters [ cur ] ; } else { t += ( char ) ( ' a ' + let ) ; } } cout << t << endl ; return 0 ; }
TAB1 declare integer variables n , a and b ; TAB1 read n , a and b ; TAB1 create integer i ; TAB1 declare vector of integers variable gp ; TAB1 for i = 0 to n exclusive ; TAB2 declare integer g ; TAB2 read g ; TAB2 push g to gp ; TAB1 create integers count and seat = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if gp [ i ] = 1 ; TAB3 if a is greater than 0 ; TAB4 set a to a - 1 ; TAB3 else ; TAB4 if b is greater than 0 ; TAB5 decrement b ; TAB5 increment seat ; TAB4 else if seat is greater than 0 ; TAB5 decrement seat ; TAB4 else ; TAB5 increase count ; TAB2 else ; TAB3 if b is greater than 0 ; TAB4 decrement b ; TAB3 else ; TAB4 set count to count + 2 ; TAB1 print count ;	int main ( ) { int n , a , b ; cin >> n >> a >> b ; int i ; vector < int > gp ; for ( i = 0 ; i < n ; i ++ ) { int g ; cin >> g ; gp . push_back ( g ) ; } int count = 0 , seat = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( gp [ i ] == 1 ) { if ( a > 0 ) { a = a - 1 ; } else { if ( b > 0 ) { b -- ; seat ++ ; } else if ( seat > 0 ) { seat -- ; } else { count ++ ; } } } else { if ( b > 0 ) { b -- ; } else { count = count + 2 ; } } } cout << count << endl ; return 0 ; }
TAB1 create integer numPeople ; TAB1 read numPeople ; TAB1 create long long sum with sum = 0 ; TAB1 create long long maxVal with maxVal = 0 ; TAB1 for i = 0 to numPeople exclusive ; TAB2 create long long person ; TAB2 read person ; TAB2 set maxVal to maximum of maxVal and person ; TAB2 increment sum by person ; TAB1 while maxVal * ( numPeople - 1 ) is less than sum , increment maxVal ; TAB1 print maxVal print " \ n " ;	int main ( ) { int numPeople ; cin >> numPeople ; long long sum = 0 ; long long maxVal = 0 ; for ( int i = 0 ; i < numPeople ; i ++ ) { long long person ; cin >> person ; maxVal = max ( maxVal , person ) ; sum += person ; } while ( maxVal * ( numPeople - 1 ) < sum ) { maxVal ++ ; } cout << maxVal << " \n " ; }
TAB0 declare sum_mod with long longs a , b as arguments , returning long long ; TAB1 return ( a + b ) % 1000000007 from function ; TAB0 declare subtract mod with long longs a , b as arguments , returning long long ; TAB1 return ( a % 1000000007 - b % 1000000007 + 1000000007 ) % 1000000007 from function ; TAB0 declare multiply_mod with long longs a , b as arguments returning long long ; TAB1 return ( a % 1000000007 * b % 1000000007 ) % 1000000007 from function ; TAB0 declare modInverse with long longs x , y as arguments , returning long long ; TAB1 declare long long res with res = 1 ; TAB1 set x to x % 1000000007 ; TAB1 while y is greater than 0 ; TAB2 if y bitwise and 1 , set res to ( res * x ) % 1000000007 ; TAB2 set y to y bitshift right 1 ; TAB2 set x to ( x * x ) % 1000000007 ; TAB1 return res from function ; TAB0 declare divide_mod with long longs a , b as arguments , returning long long ; TAB1 return ( a * modInverse ( b , 1000000007 - 2 ) ) % 1000000007 from function ; TAB0 declare gcd with long longs a , b as arguments , returning long long ; TAB1 while b is true , swap values between ( set a to a % b ) and b ; TAB1 return a from function ; TAB1 create long longs n , d ; TAB1 read n read d ; TAB1 create long long vector nums initialized with n ; TAB1 create long longs cnt , t , with cnt = 0 , t = 0 ; TAB1 end statement ; TAB1 for i = 0 to n exclusive ; TAB2 read nums [ i ] ; TAB2 increment t by nums [ i ] ; TAB2 if i is less than n - 1 , increment t by 10 ; TAB2 increment cnt by nums [ i ] ; TAB1 if t is greater than d ; TAB2 print - 1 print newline ; TAB1 else ; TAB2 print ( d - cnt ) / 5 print newline ;	long long sum_mod ( long long a , long long b ) { return ( a + b ) % 1000000007 ; } long long subtract_mod ( long long a , long long b ) { return ( a % 1000000007 - b % 1000000007 + 1000000007 ) % 1000000007 ; } long long multiply_mod ( long long a , long long b ) { return ( a % 1000000007 * b % 1000000007 ) % 1000000007 ; } long long modInverse ( long long x , long long y ) { long long res = 1 ; x = x % 1000000007 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % 1000000007 ; y = y >> 1 ; x = ( x * x ) % 1000000007 ; } return res ; } long long divide_mod ( long long a , long long b ) { return ( a * modInverse ( b , 1000000007 - 2 ) ) % 1000000007 ; } long long gcd ( long long a , long long b ) { while ( b ) swap ( a %= b , b ) ; return a ; } int main ( ) { long long n , d ; cin >> n >> d ; vector < long long > nums ( n ) ; long long cnt = 0 , t = 0 ; ; for ( long long i = 0 ; i < n ; ++ i ) { cin >> nums [ i ] ; t += nums [ i ] ; if ( i < n - 1 ) t += 10 ; cnt += nums [ i ] ; } if ( t > d ) cout << - 1 << endl ; else cout << ( d - cnt ) / 5 << endl ; }
TAB1 create integers n , a , denied , client , single with denied = 0 , single = 0 ; TAB1 create integer b ; TAB1 read n read a read b ; TAB1 for i = 0 to n exclusive ; TAB2 read client ; TAB2 if client is 1 ; TAB3 if a is greater than 0 ; TAB4 decrement a ; TAB3 else if b is greater than 0 ; TAB4 decrement b ; TAB4 increment single ; TAB3 else if single is greater than 0 ; TAB4 decrement single ; TAB3 else ; TAB4 increment denied ; TAB2 else if b is greater than 0 ; TAB3 decrement b ; TAB2 else ; TAB3 increment denied by 2 ; TAB1 print denied print newline ;	int main ( ) { int n , a , denied = 0 , client , single = 0 ; int b ; cin >> n >> a >> b ; for ( int i = 0 ; i < n ; i ++ ) { cin >> client ; if ( client == 1 ) { if ( a > 0 ) a -- ; else if ( b > 0 ) { b -- ; single ++ ; } else if ( single > 0 ) single -- ; else denied ++ ; } else if ( b > 0 ) b -- ; else denied += 2 ; } cout << denied << endl ; return 0 ; }
TAB1 n , m , k = long long ; TAB1 read n , m , k ; TAB1 if n - 1 + 1 - 1 < k ; TAB2 print - 1 ; TAB1 if n < m swap ( n , m ) ; TAB1 maxx = 0 ; TAB1 maxx = max ( maxx , n / ( k + 1 ) * m ) ; TAB1 maxx = max ( maxx , m / ( k + 1 ) * n ) ; TAB1 if maxx is not zero ; TAB2 print maxx ; TAB1 subtract n - 1 from k ; TAB1 print m / ( k + 1 ) ;	int main ( ) { long long n , m , k ; cin >> n >> m >> k ; if ( n - 1 + m - 1 < k ) { cout << - 1 << endl ; return 0 ; } if ( n < m ) swap ( n , m ) ; long long maxx = 0 ; maxx = max ( maxx , n / ( k + 1 ) * m ) ; maxx = max ( maxx , m / ( k + 1 ) * n ) ; if ( maxx != 0 ) { cout << maxx << endl ; return 0 ; } k = k - ( n - 1 ) ; cout << m / ( k + 1 ) << endl ; return 0 ; }
TAB0 create 2d integer array a with size 5 by 5 ; TAB0 create integer arrays b , c , with b size 10 , c size 10 ; TAB1 create integer x with x = 1 ; TAB1 create integer n ; TAB1 read n ; TAB1 set bytes from a to size of a to - 1 ; TAB1 for i = 1 to 4 exclusive ; TAB2 for j = 1 to 4 exclusive , set a [ i ] [ j ] to increment x ; TAB1 set a [ 4 ] [ 2 ] to 0 ; TAB1 create string s ; TAB1 read s ; TAB1 create integers last , coun with last = s [ 0 ] - ' 0 ' , coun = 0 ; TAB1 for i = 1 to size of s exclusive ; TAB2 create integers y , now , with y = 0 , now = s [ i ] - ' 0 ' ; TAB2 if last is 0 , set last to 11 ; TAB2 if now is 0 , set now to 11 ; TAB2 set x to ( now + 2 ) / 3 - ( last + 2 ) / 3 ; TAB2 set y to now - x * 3 - last ; TAB2 set b [ i ] to x ; TAB2 set c [ i ] to y ; TAB2 set last to now ; TAB1 for i = 1 to 5 exclusive ; TAB2 for j = 1 to 5 exclusive ; TAB3 if a [ i ] [ j ] is - 1 , break current loop iteration ; TAB3 create integer k with k = 1 ; TAB3 create integers newX , newY ; TAB3 set newX to i , set newY to j ; TAB3 for k = 1 to n exclusive ; TAB4 increment newX by b [ x ] , increment newY by c [ k ] ; TAB4 if newX is less than 0 or newX is greater than 4 or newY is less than 0 or new Y is greater than 4 or a [ newX ] [ newY ] is - 1 , break loop ; TAB3 if k is n , increment coun ; TAB1 if coun is greater than 1 ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 print " YES " print newline ;	int a [ 5 ] [ 5 ] ; int b [ 10 ] , c [ 10 ] ; int main ( ) { int x = 1 ; int n ; cin >> n ; memset ( a , - 1 , sizeof ( a ) ) ; for ( int i = 1 ; i < 4 ; i ++ ) for ( int j = 1 ; j < 4 ; j ++ ) { a [ i ] [ j ] = x ++ ; } a [ 4 ] [ 2 ] = 0 ; string s ; cin >> s ; int last = s [ 0 ] - ' 0 ' , coun = 0 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { int y = 0 , now = s [ i ] - ' 0 ' ; if ( last == 0 ) last = 11 ; if ( now == 0 ) now = 11 ; x = ( now + 2 ) / 3 - ( last + 2 ) / 3 ; y = now - x * 3 - last ; b [ i ] = x ; c [ i ] = y ; last = now ; } for ( int i = 1 ; i < 5 ; i ++ ) { for ( int j = 1 ; j < 5 ; j ++ ) { if ( a [ i ] [ j ] == - 1 ) continue ; int k = 1 ; int newX , newY ; newX = i , newY = j ; for ( k = 1 ; k < n ; k ++ ) { newX += b [ k ] , newY += c [ k ] ; if ( newX < 0 || newX > 4 || newY < 0 || newY > 4 || a [ newX ] [ newY ] == - 1 ) break ; } if ( k == n ) coun ++ ; } } if ( coun > 1 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 in the function power with arguments long long int x , long long int n , long long int m and return long long int ; TAB1 if n is 0 , then return 1 ; TAB1 if n is 1 , then return x ; TAB1 x is assigned x mod m ; TAB1 if n mod 2 is true , then return ( x * ( power ( ( x * x ) % m , n / 2 , m ) % m ) ) % m ; TAB1 return power ( ( x * x ) % m , n / 2 , m ) mod m ; TAB1 make long long integers hy , ay , dy , hm , am , dm , h , a , d ; TAB1 read hy , ay , dy , hm , am , dm , h , a , d ; TAB1 make long long integer ans with ans = 1000000000000000 ; TAB1 for long long integer atk = ay to 200 inclusive ; TAB2 for long long integer def = dy to 100 inclusive ; TAB3 if atk is less than or equal to dm , then continue ; TAB3 make long long integer t with t = hm / ( atk - dm ) ; TAB3 if hm modulo ( atk - dm ) is not 0 , then increment t ; TAB3 make long long integer hr with hr = t * ( max ( 0LL , am - def ) ) + 1 ; TAB3 make long long integer cost with cost = 0 ; TAB3 if hr is greater than hy , then add ( ( hr - hy ) * h ) to cost ; TAB3 if atk is greater than ay , then add ( ( atk - ay ) * a ) to cost ; TAB3 if def is greater than dy , then add ( ( def - dy ) * d ) to cost ; TAB3 if ans is greater than cost , set ans to cost ; TAB1 output ans ;	long long int power ( long long int x , long long int n , long long int m ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return x ; x %= m ; if ( n % 2 ) return ( x * ( power ( ( x * x ) % m , n / 2 , m ) % m ) ) % m ; return power ( ( x * x ) % m , n / 2 , m ) % m ; } int main ( ) { long long int hy , ay , dy , hm , am , dm , h , a , d ; cin >> hy >> ay >> dy >> hm >> am >> dm >> h >> a >> d ; long long int ans = 1000000000000000 ; for ( long long int atk = ay ; atk <= 200 ; atk ++ ) { for ( long long int def = dy ; def <= 100 ; def ++ ) { if ( atk <= dm ) continue ; long long int t = hm / ( atk - dm ) ; if ( hm % ( atk - dm ) != 0 ) t ++ ; long long int hr = t * ( max ( 0LL , am - def ) ) + 1 ; long long int cost = 0 ; if ( hr > hy ) cost += ( hr - hy ) * h ; if ( atk > ay ) cost += ( atk - ay ) * a ; if ( def > dy ) cost += ( def - dy ) * d ; if ( ans > cost ) { ans = cost ; } } } cout << ans << endl ; }
TAB1 create integers h , a , d , hp1 , atk1 , def1 , hp2 , atk2 , def2 ; TAB1 create integers i , j , k , diff , res ; TAB1 while read hp1 read atk1 read def1 ; TAB2 read hp2 read atk2 read def2 ; TAB2 read h read a read d ; TAB2 create integer temp ; TAB2 set res to 100000000 ; TAB2 for i = 0 to 1001 exclusive ; TAB3 for j = 0 to 1001 exclusive ; TAB4 set k to 0 ; TAB4 set temp to hp1 + i ; TAB4 set diff to ( atk1 + j ) - def2 ; TAB4 if diff is less than or equal to 0 , break current loop iteration ; TAB4 if diff is greater than hp2 ; TAB5 set k to temp - 1 ; TAB4 else ; TAB5 set k to hp2 / diff ; TAB5 set k to temp / k ; TAB5 while 1 is true ; TAB6 if k is less than or equal to 0 ; TAB7 break loop ; TAB6 else if ( temp / k ) + ( temp % k is greater than 0 ) is greater than ( hp2 / diff ) + ( hp2 % diff is greater than 0 ) ; TAB7 break loop ; TAB6 decrement k ; TAB4 set temp to atk2 - def1 if 0 is less than atk2 - def1 , else 0 ; TAB4 if k is less than temp ; TAB5 set k to temp - k ; TAB4 else ; TAB5 set k to 0 ; TAB4 set res to i * h + j * a + k * d if res is greater than i * h + j * a + k * d , else res ; TAB2 print res print newline ;	int main ( ) { int h , a , d , hp1 , atk1 , def1 , hp2 , atk2 , def2 ; int i , j , k , diff , res ; while ( cin >> hp1 >> atk1 >> def1 ) { cin >> hp2 >> atk2 >> def2 ; cin >> h >> a >> d ; int temp ; res = 100000000 ; for ( i = 0 ; i < 1001 ; i ++ ) { for ( j = 0 ; j < 1001 ; j ++ ) { k = 0 ; temp = hp1 + i ; diff = ( atk1 + j ) - def2 ; if ( diff <= 0 ) continue ; if ( diff > hp2 ) { k = temp - 1 ; } else { k = hp2 / diff ; k = temp / k ; while ( 1 ) { if ( k <= 0 ) break ; else if ( ( temp / k ) + ( temp % k > 0 ) > ( hp2 / diff ) + ( hp2 % diff > 0 ) ) break ; k -- ; } } temp = ( 0 < atk2 - def1 ? atk2 - def1 : 0 ) ; if ( k < temp ) k = temp - k ; else k = 0 ; res = ( res > i * h + j * a + k * d ? i * h + j * a + k * d : res ) ; } } cout << res << endl ; } return 0 ; }
TAB1 create long long integers i , n , m , j , a , count , c , last , have , sum , rest with count = 0 , c = 0 , sum = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 end statement ; TAB2 if a is 0 ; TAB3 increment c ; TAB2 else ; TAB3 increment count ; TAB3 increment sum by a ; TAB1 if count / 9 is not 0 and c is greater than 0 ; TAB2 set have to sum / 9 ; TAB2 set rest to have / 5 ; TAB2 for i = 0 to 9 * rest exclusive , print 5 ; TAB2 for i = 0 to c exclusive , print 0 ; TAB2 print newline ; TAB1 else if c is greater than 0 ; TAB2 print 0 print newline ; TAB1 else ; TAB2 print - 1 print newline ;	int main ( ) { long long int i , n , m , j , a , count = 0 , c = 0 , last , have , sum = 0 , rest ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> a ; ; if ( a == 0 ) c ++ ; else { count ++ ; sum += a ; } } if ( count / 9 != 0 && c > 0 ) { have = sum / 9 ; rest = have / 5 ; for ( i = 0 ; i < 9 * rest ; i ++ ) cout << 5 ; for ( i = 0 ; i < c ; i ++ ) cout << 0 ; cout << endl ; } else if ( c > 0 ) cout << 0 << endl ; else cout << - 1 << endl ; return 0 ; }
TAB0 declare long long integers n , m , k , mn and mm ; TAB1 read n , m and k ; TAB1 if n - 1 + m - 1 is less than k ; TAB2 print - 1 ; TAB1 else ; TAB2 if k is greater than n - 1 ; TAB3 mm = m / ( k - ( n - 1 ) + 1 ) ; TAB2 else ; TAB3 mm = m * ( n / ( k + 1 ) ) ; TAB2 if k is greater than m - 1 ; TAB3 mn = n / ( k - ( m - 1 ) + 1 ) ; TAB2 else ; TAB3 mn = n * ( m / ( k + 1 ) ) ; TAB1 print max of mn and mm ;	long long int n , m , k , mn , mm ; int main ( ) { cin >> n >> m >> k ; if ( n - 1 + m - 1 < k ) { cout << - 1 << endl ; return 0 ; } else { if ( k > n - 1 ) { mm = m / ( k - ( n - 1 ) + 1 ) ; } else { mm = m * ( n / ( k + 1 ) ) ; } if ( k > m - 1 ) { mn = n / ( k - ( m - 1 ) + 1 ) ; } else { mn = n * ( m / ( k + 1 ) ) ; } } cout << max ( mn , mm ) << endl ; }
TAB1 let n and check be integers with check = 0 ; TAB1 create string array s with 1000 elements ; TAB1 read n ; TAB1 read n elements into s ; TAB1 for i = 0 to n exclusive ; TAB3 for integer j = 0 to length of s [ i ] - 1 exclusive ; TAB4 if s [ i ] [ j ] = ' O ' & & s [ i ] [ j + 1 ] = ' O ' ; TAB5 s [ i ] [ j ] = ' + ' ; TAB5 s [ i ] [ j + 1 ] = ' + ' ; TAB5 set check to 1 ; TAB5 break the loop ; TAB2 if check is not 0 , break ; TAB1 if check is not 0 ; TAB2 print " YES \ n " ; TAB2 print n elements of array s ; TAB1 else ; TAB2 print " NO \ n " ;	int main ( ) { int n , check = 0 ; string s [ 1000 ] ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { { for ( int j = 0 ; j < s [ i ] . length ( ) - 1 ; j ++ ) { if ( s [ i ] [ j ] == ' O ' && s [ i ] [ j + 1 ] == ' O ' ) { s [ i ] [ j ] = ' + ' ; s [ i ] [ j + 1 ] = ' + ' ; check = 1 ; break ; } } } if ( check ) break ; } if ( check ) { cout << " YES\n " ; for ( int i = 0 ; i < n ; i ++ ) cout << s [ i ] << endl ; } else cout << " NO\n " ; return 0 ; }
TAB0 create constant integer maxn with maxn = 5005 ; TAB1 create integers n , flag1 , flag2 , flag3 , flag4 ; TAB1 read n ; TAB1 create string str ; TAB1 read str ; TAB1 set flag1 to flag2 to flag3 to flag4 to j ; TAB1 for i = 0 to n exclusive ; TAB2 ir str [ i ] is ' 1 ' or str [ i ] is ' 2 ' or str [ i ] is ' 3 ' , set flag1 to 0 ; TAB2 if str [ i ] is ' 1 ' or str [ i ] is ' 4 ' , or str [ i ] is ' 7 ' or str [ i ] is ' 0 ' , set flag2 to 0 ; TAB2 if str [ i ] is ' 7 ' or str [ i ] is ' 9 ' or str [ i ] is ' 0 ' , set flag3 to 0 ; TAB2 if str [ i ] is ' 6 ' or str [ i ] is ' 9 ' or str [ i ] is ' 3 ' or str [ i ] is ' 0 ' , set flag4 to 0 ; TAB1 if flag1 or flag2 or flag3 or flag4 ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 print " YES " print newline ;	const int maxn = 5005 ; int main ( ) { int n , flag1 , flag2 , flag3 , flag4 ; cin >> n ; string str ; cin >> str ; flag1 = flag2 = flag3 = flag4 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' 1 ' || str [ i ] == ' 2 ' || str [ i ] == ' 3 ' ) flag1 = 0 ; if ( str [ i ] == ' 1 ' || str [ i ] == ' 4 ' || str [ i ] == ' 7 ' || str [ i ] == ' 0 ' ) flag2 = 0 ; if ( str [ i ] == ' 7 ' || str [ i ] == ' 9 ' || str [ i ] == ' 0 ' ) flag3 = 0 ; if ( str [ i ] == ' 6 ' || str [ i ] == ' 9 ' || str [ i ] == ' 3 ' || str [ i ] == ' 0 ' ) flag4 = 0 ; } if ( flag1 || flag2 || flag3 || flag4 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 declare constant integer N = 101010 ; TAB0 declare integers hp , atk and def ; TAB0 declare integer variables hp1 , atk1 and def1 ; TAB0 declare integers a , b and c ; TAB1 read hp , atk and def ; TAB1 read hp1 , atk1 and def1 ; TAB1 read a , b and c ; TAB1 declare integer cost = 99999999 ; TAB1 for j = 0 to 100 + 100 + 1 exclusive ; TAB2 for k = 0 to 100 + 1 exclusive ; TAB3 if atk1 - def - k < = 0 ; TAB4 if atk + j - def1 is greater than 0 ; TAB5 cost = min of b * j + c * k and cost ; TAB4 else ; TAB5 go to the start of the loop ; TAB3 else ; TAB4 create integer time = hp1 * 1 . / ( 1 . * ( atk + j - def1 ) ) rounded up ; TAB4 create integer time2 = hp / ( atk1 - def - k ) rounded up ; TAB4 if time is less than 0 , continue the loop ; TAB4 if time2 is greater than time ; TAB5 cost = min of b * j + c * k and cost ; TAB4 else ; TAB5 set integer addhp to max of 0 and ( time * ( atk1 - def - k ) ) + 1 - hp ; TAB5 cost = min of cost and addhp * a + j * b + c * k ; TAB1 print cost ;	const int N = 101010 ; int hp , atk , def ; int hp1 , atk1 , def1 ; int a , b , c ; int main ( ) { cin >> hp >> atk >> def ; cin >> hp1 >> atk1 >> def1 ; cin >> a >> b >> c ; int cost = 99999999 ; for ( int j = 0 ; j < ( 100 + 100 + 1 ) ; ++ j ) for ( int k = 0 ; k < ( 100 + 1 ) ; ++ k ) { if ( atk1 - def - k <= 0 ) { if ( atk + j - def1 > 0 ) cost = min ( b * j + c * k , cost ) ; else continue ; } else { int time = ceil ( hp1 * 1. / ( 1. * ( atk + j - def1 ) ) ) ; int time2 = ceil ( hp / ( atk1 - def - k ) ) ; if ( time < 0 ) continue ; if ( time2 > time ) { cost = min ( b * j + c * k , cost ) ; } else { int addhp = max ( 0 , ( time * ( atk1 - def - k ) ) + 1 - hp ) ; cost = min ( cost , addhp * a + j * b + c * k ) ; } } } cout << cost << endl ; return 0 ; }
TAB1 create integer n ; TAB1 while read n is true ; TAB2 create string s ; TAB2 read s ; TAB2 create booleans left , right , up , down ; TAB2 set left to right to up to down to false ; TAB2 for i = 0 to length of s exclusive ; TAB3 if s [ i ] is ' 1 ' or s [ i ] is ' 2 ' or s [ i ] is ' 3 ' , set up to true ; TAB3 if s [ i ] is ' 1 ' or s [ i ] is ' 4 ' or s [ i ] is ' 4 ' or s [ i ] is ' 0 ' , set left to true ; TAB3 if s [ i ] is ' 3 ' or s [ i ] is ' 6 ' or s [ i ] is ' 9 ' or s [ i ] is ' 0 ' , set right to true ; TAB3 if s [ i ] is ' 7 ' or s [ i ] is ' 0 ' or s [ i ] is ' 9 ' , set down to true ; TAB2 if up and down and left and right ; TAB3 print " YES " print newline ; TAB2 else ; TAB3 print " NO " print newline ;	int main ( ) { int n ; while ( cin >> n ) { string s ; cin >> s ; bool left , right , up , down ; left = right = up = down = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' 1 ' || s [ i ] == ' 2 ' || s [ i ] == ' 3 ' ) up = true ; if ( s [ i ] == ' 1 ' || s [ i ] == ' 4 ' || s [ i ] == ' 7 ' || s [ i ] == ' 0 ' ) left = true ; if ( s [ i ] == ' 3 ' || s [ i ] == ' 6 ' || s [ i ] == ' 9 ' || s [ i ] == ' 0 ' ) right = true ; if ( s [ i ] == ' 7 ' || s [ i ] == ' 0 ' || s [ i ] == ' 9 ' ) down = true ; } if ( up && down && left && right ) cout << " YES " << endl ; else cout << " NO " << endl ; } }
TAB0 declare solve with no arguments , returning void ; TAB1 create integer n ; TAB1 read n ; TAB1 create integer vector v ; TAB1 for i = 0 to n exclusive ; TAB2 create integer x ; TAB2 read x ; TAB2 add element x to end of v ; TAB1 sort elements from beginning of v to end of v ; TAB1 create integer i with i = 0 ; TAB1 create integer j with j = n - 1 ; TAB1 create integer ans with ans = 0 ; TAB1 while 2 * v [ i ] is less than v [ j ] ; TAB2 if 2 * v [ i + 1 ] is greater than or equal to v [ j ] ; TAB3 increment i ; TAB3 increment ans ; TAB2 else if 2 * v [ i ] is greater than or equal to v [ j - 1 ] ; TAB3 decrement j ; TAB3 increment ans ; TAB2 else ; TAB3 increment ans by 2 ; TAB3 increment i ; TAB3 decrement j ; TAB1 print ans print newline ; TAB0 declare solve2 ; TAB1 create integers a , b , n ; TAB1 read a read b read n ; TAB1 if a % b is 0 ; TAB2 print a ; TAB2 for i = 0 to n exclusive , print 0 ; TAB2 print newline ; TAB2 return from function ; TAB1 create boolean c with c = false ; TAB1 for i = 0 to 9 inclusive ; TAB2 if ( a * 10 + i ) % b is 0 ; TAB3 print a print i ; TAB3 set c to true ; TAB3 break loop ; TAB1 if c is true ; TAB2 for i = 0 to n - 1 exclusive , print 0 ; TAB2 print newline ; TAB1 else ; TAB2 print - 1 print newline ; TAB1 run solve2 ;	void solve ( ) { int n ; cin >> n ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; v . push_back ( x ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int i = 0 ; int j = n - 1 ; int ans = 0 ; while ( 2 * v [ i ] < v [ j ] ) { if ( 2 * v [ i + 1 ] >= v [ j ] ) { i ++ ; ans ++ ; } else if ( 2 * v [ i ] >= v [ j - 1 ] ) { j -- ; ans ++ ; } else { ans += 2 ; i ++ ; j -- ; } } cout << ans << endl ; } void solve2 ( ) { int a , b , n ; cin >> a >> b >> n ; if ( a % b == 0 ) { cout << a ; for ( int i = 0 ; i < n ; i ++ ) { cout << 0 ; } cout << endl ; return ; } bool c = false ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( ( a * 10 + i ) % b == 0 ) { cout << a << i ; c = true ; break ; } } if ( c ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << 0 ; } cout << endl ; } else cout << - 1 << endl ; } int main ( ) { solve2 ( ) ; return 0 ; }
TAB1 declare unsigned long longs n , m and k ; TAB1 read n , m and k ; TAB1 if n is greater than m , swap n and m ; TAB1 if k is less than m ; TAB2 print max of ( n / ( k + 1 ) ) * m and n * ( m / ( k + 1 ) ) ; TAB1 else if k < = n + m - 2 ; TAB2 print ( n / ( k + 2 - m ) ) ; TAB1 else ; TAB2 print - 1 ;	int main ( ) { unsigned long long n , m , k ; cin >> n >> m >> k ; if ( n > m ) swap ( n , m ) ; if ( k < m ) cout << max ( ( n / ( k + 1 ) ) * m , n * ( m / ( k + 1 ) ) ) << endl ; else if ( k <= n + m - 2 ) cout << ( n / ( k + 2 - m ) ) << endl ; else cout << - 1 << endl ; return 0 ; }
TAB1 declare character array ch with size 1009 by 200 ; TAB1 let n , flag , i and j be integers with flag = 0 ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 inclusive read ch [ i ] [ j ] ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 exclusive ; TAB3 if ch [ i ] [ j ] = ' O ' and ch [ i ] [ j + 1 ] = ' O ' ; TAB4 ch [ i ] [ j ] = ' + ' ; TAB4 ch [ i ] [ j + 1 ] = ' + ' ; TAB4 set flag to 1 ; TAB4 stop the loop ; TAB2 if flag = 1 , break ; TAB1 if flag = 1 ; TAB2 print " YES " ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to 5 inclusive print ch [ i ] [ j ] ; TAB3 print new line ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { char ch [ 1009 ] [ 200 ] ; int n , flag = 0 , i , j ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { cin >> ch [ i ] [ j ] ; } } for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j < 5 ; j ++ ) { if ( ch [ i ] [ j ] == ' O ' && ch [ i ] [ j + 1 ] == ' O ' ) { ch [ i ] [ j ] = ' + ' ; ch [ i ] [ j + 1 ] = ' + ' ; flag = 1 ; break ; } } if ( flag == 1 ) break ; } if ( flag == 1 ) { cout << " YES " << endl ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { cout << ch [ i ] [ j ] ; } cout << endl ; } } else cout << " NO " << endl ; }
TAB1 n , a , b , x , sum , c = int with sum = 0 and c = 0 ; TAB1 read n then a then b ; TAB1 for i = 0 to n ; TAB2 read x ; TAB2 if x equals 1 ; TAB3 if a is not 0 ; TAB4 decrement a ; TAB3 else if b is not 0 ; TAB4 decrement b ; TAB4 increment c ; TAB3 else if c is not zero ; TAB4 decrement c ; TAB3 else ; TAB4 increment sum ; TAB2 else ; TAB3 if b is not zero ; TAB4 decrement b ; TAB3 else ; TAB4 add 2 to sum ; TAB1 print sum ;	int main ( ) { int n , a , b , x , sum = 0 , c = 0 ; cin >> n >> a >> b ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 1 ) { if ( a ) a -- ; else if ( b ) { b -- ; c ++ ; } else if ( c ) c -- ; else sum ++ ; } else { if ( b ) b -- ; else sum += 2 ; } } cout << sum << endl ; return 0 ; }
TAB0 mpu = map from character to character ; TAB0 vec is vector of long longs of size 1000006 ; TAB0 let b and a be empty integer arrays of size 1000006 ; TAB0 let visit be empty boolean array of size 1000006 ; TAB1 declare string variable s ; TAB1 read s ; TAB1 n and sum are long longs with sum = 0 ; TAB1 n = size of s ; TAB1 declare vector of long longs called v ; TAB1 for i = 2 to n inclusive ; TAB2 set boolean t to 0 ; TAB2 for integer j = 2 to i exclusive ; TAB3 if i % j = 0 ; TAB4 assign value of 1 to the t ; TAB4 stop the loop ; TAB2 if t = 0 , push i into v ; TAB1 w is an empty array of integers with size 26 ; TAB1 for i = 0 to length of s exclusive ; TAB2 integer t = s [ i ] - ' a ' casted to int ; TAB2 increase w [ t ] ; TAB1 for integer i = 0 to length of v exclusive ; TAB2 if v [ i ] * 2 is greater than n , break ; TAB2 for k = v [ i ] to length of s inclusive incrementing by v [ i ] ; TAB3 if visit [ k - 1 ] = 1 , continue ; TAB3 increment sum ; TAB3 visit [ k - 1 ] = 1 ; TAB1 if sum = 0 ; TAB2 print " YES \ n " , s and a new line ; TAB1 assign value - 1 to the integer p ; TAB1 for integer i = 0 to 26 exclusive ; TAB2 if w [ i ] > = sum , set p to i ; TAB1 if p = - 1 ; TAB2 print " NO \ n " ; TAB1 print " YES \ n " ; TAB1 for i = 0 to n exclusive ; TAB2 if visit [ i ] = 1 ; TAB3 s [ i ] = char ( p ) + ' a ' ; TAB3 decrease w [ p ] ; TAB1 for integer i = 0 to n exclusive ; TAB2 if visit [ i ] = 1 , continue ; TAB2 for integer j = 0 to 26 exclusive ; TAB3 if w [ j ] is greater than 0 ; TAB4 s [ i ] = char ( j ) + ' a ' ; TAB4 decrease w [ j ] ; TAB4 stop the loop ; TAB1 print s and a new line ;	map < char , char > mpu ; vector < long long > vec [ 1000006 ] ; int b [ 1000006 ] = { } , a [ 1000006 ] = { } ; bool visit [ 1000006 ] = { } ; int main ( ) { string s ; cin >> s ; long long n , sum = 0 ; n = s . size ( ) ; vector < long long > v ; for ( int i = 2 ; i <= n ; i ++ ) { bool t = 0 ; for ( int j = 2 ; j < i ; j ++ ) { if ( i % j == 0 ) { t = 1 ; break ; } } if ( t == 0 ) { v . push_back ( i ) ; } } int w [ 26 ] = { } ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { int t = int ( s [ i ] - ' a ' ) ; w [ t ] ++ ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] * 2 > n ) break ; for ( int k = v [ i ] ; k <= s . size ( ) ; k += v [ i ] ) { if ( visit [ k - 1 ] == 1 ) continue ; sum ++ ; visit [ k - 1 ] = 1 ; } } if ( sum == 0 ) { cout << " YES\n " << s << endl ; return 0 ; } int p = - 1 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( w [ i ] >= sum ) { p = i ; } } if ( p == - 1 ) { cout << " NO\n " ; return 0 ; } cout << " YES\n " ; for ( int i = 0 ; i < n ; i ++ ) { if ( visit [ i ] == 1 ) { s [ i ] = char ( p ) + ' a ' ; w [ p ] -- ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( visit [ i ] == 1 ) continue ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( w [ j ] > 0 ) { s [ i ] = char ( j ) + ' a ' ; w [ j ] -- ; break ; } } } cout << s << endl ; }
TAB1 create integer a ; TAB1 read a ; TAB1 create string s ; TAB1 create string sum ; TAB1 create string vector v2 ; TAB1 create boolean check with check = false ; TAB1 for i = 0 to a exclusive ; TAB2 read s ; TAB2 for j = 0 to length of s exclusive ; TAB3 if s [ j ] is ' O ' and s [ j + 1 ] is ' O ' and check is false ; TAB4 set s [ j ] to ' + ' ; TAB4 set s [ j + 1 ] to ' + ' ; TAB4 set check to true ; TAB3 if check is true ; TAB4 set sum to " YES " ; TAB3 else ; TAB4 set sum to " NO " ; TAB2 add element s to end of v2 ; TAB1 print sum print newline ; TAB1 for i = 0 to a exclusive ; TAB2 if sum is " YES " print v2 [ i ] print newline ;	int main ( ) { int a ; cin >> a ; string s ; string sum ; vector < string > v2 ; bool check = false ; for ( int i = 0 ; i < a ; i ++ ) { cin >> s ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == ' O ' && s [ j + 1 ] == ' O ' && check == false ) { s [ j ] = ' + ' ; s [ j + 1 ] = ' + ' ; check = true ; } if ( check == true ) { sum = " YES " ; } else sum = " NO " ; } v2 . push_back ( s ) ; } cout << sum << endl ; for ( int i = 0 ; i < a ; i ++ ) { if ( sum == " YES " ) { cout << v2 [ i ] << endl ; } } return 0 ; }
TAB1 create integer N ; TAB1 read N ; TAB1 declare character array mat with size N + 1 by N + 1 ; TAB1 let rows and columns be arrays of integer vectors with size N + 1 ; TAB1 for integer i = 1 to N inclusive ; TAB2 for integer j = 1 to N inclusive ; TAB3 read mat [ i ] [ j ] ; TAB3 if mat [ i ] [ j ] ! = ' E ' ; TAB4 push j to the end of rows [ i ] ; TAB4 push i to the end of columns [ j ] ; TAB1 create booleans rowFull and columnFull = false ; TAB1 for i = 1 to N inclusive ; TAB2 if size of rows [ i ] is 0 , set rowFull to true ; TAB2 if size of columns [ i ] is 0 , set columnFull to true ; TAB1 if rowFull & & columnFull ; TAB2 print " - 1 " ; TAB1 else if rowFull ; TAB2 for i = 1 to N inclusive print columns [ i ] [ 0 ] , " " and i ; TAB1 else ; TAB2 for integer i = 1 to N inclusive print i , " " and rows [ i ] [ 0 ] ;	int main ( ) { int N ; cin >> N ; char mat [ N + 1 ] [ N + 1 ] ; vector < int > rows [ N + 1 ] , columns [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { cin >> mat [ i ] [ j ] ; if ( mat [ i ] [ j ] != ' E ' ) { rows [ i ] . push_back ( j ) ; columns [ j ] . push_back ( i ) ; } } } bool rowFull = false , columnFull = false ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! rows [ i ] . size ( ) ) rowFull = true ; if ( ! columns [ i ] . size ( ) ) columnFull = true ; } if ( rowFull && columnFull ) { cout << " -1 " << endl ; } else if ( rowFull ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << columns [ i ] [ 0 ] << "   " << i << endl ; } } else { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << "   " << rows [ i ] [ 0 ] << endl ; } } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create a char str with lenght of 10000 ; TAB1 for i = 0 to n * 5 exclusive read str [ i ] ; TAB1 create integer c with c = 0 ; TAB1 for i = 0 to n * 5 exclusive ; TAB2 if str [ i ] is equal ' O ' and str [ i + 1 ] is equal ' O ' ; TAB3 if i + 1 module 5 ; TAB4 set c to 1 ; TAB4 set str [ i ] to ' + ' ; TAB4 set str [ i + 1 ] to ' + ' ; TAB4 stop loop ; TAB1 if c equal to 1 ; TAB2 print " YES " and new line ; TAB2 for i = 0 to n * 5 exclusive ; TAB3 print str [ i ] ; TAB3 if i + 1 module 5 equal to 0 print new line ; TAB1 else ; TAB2 print " NO " and new line ;	int main ( ) { int n ; cin >> n ; char str [ 10000 ] ; for ( int i = 0 ; i < n * 5 ; i ++ ) { cin >> str [ i ] ; } int c = 0 ; for ( int i = 0 ; i < n * 5 ; i ++ ) { if ( str [ i ] == ' O ' && str [ i + 1 ] == ' O ' ) { if ( ( ( i + 1 ) % 5 ) ) { c = 1 ; str [ i ] = ' + ' ; str [ i + 1 ] = ' + ' ; break ; } } } if ( c == 1 ) { cout << " YES " << endl ; for ( int i = 0 ; i < n * 5 ; i ++ ) { cout << str [ i ] ; if ( ( i + 1 ) % 5 == 0 ) cout << endl ; } } else { cout << " NO " << endl ; } }
TAB1 create integer n ; TAB1 create boolean ok with ok = false ; TAB1 read n ; TAB1 create 2d character array seat with size n by 5 ; TAB1 for i = 0 to n exclusive ; TAB2 read seat [ i ] ; TAB2 if not ok ; TAB3 for j = 0 to 5 exclusive ; TAB4 if seat [ i ] [ j ] is ' O ' and seat [ i ] [ j + 1 ] is ' O ' ; TAB5 set ok to true ; TAB5 set seat [ i ] [ j ] to seat [ i ] [ j + 1 ] to ' + ' ; TAB5 set ok to true ; TAB5 go to jump label l ; TAB2 create jump label l ; TAB0 create jump label end ; TAB1 if ok is true ; TAB2 print " YES " print newline ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to 5 exclusive , print seat [ i ] [ j ] ; TAB3 print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { int n ; bool ok = false ; cin >> n ; char seat [ n ] [ 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> seat [ i ] ; if ( ! ok ) { for ( int j = 0 ; j < 5 ; j ++ ) { if ( seat [ i ] [ j ] == ' O ' && seat [ i ] [ j + 1 ] == ' O ' ) { ok = true ; seat [ i ] [ j ] = seat [ i ] [ j + 1 ] = ' + ' ; ok = true ; goto l ; } } l : ; } } end : if ( ok ) { cout << " YES " << endl ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { cout << seat [ i ] [ j ] ; } cout << endl ; } } else cout << " NO " << endl ; }
TAB0 hp_y , atk_y , def_y = int ; TAB0 hp_m , atk_m , def_m = int ; TAB0 h , a , d = int ; TAB1 read hp_y , atk_y , def_y ; TAB1 read hp_m , atk_m , def_m ; TAB1 read h , a , d ; TAB1 ans = INT_MAX ; TAB1 for i = atk_y to 200 inclusive ; TAB2 for j = def_y to 200 inclusive ; TAB3 damage_y = max ( 0 , i - def_m ) ; TAB3 damage_m = max ( 0 , atk_m - j ) ; TAB3 if damage_y is zero continue ; TAB3 turn = hp_m / damage_y ; TAB3 if hp_m modulo damage_y is not zero increment turn ; TAB3 hp_needed = max ( 0 , 1 - ( hp_y - damage_m * turn ) ) ; TAB3 ans = min ( ans , ( i - atk_y ) * a + ( j - def_y ) * d + hp_needed * h ) ; TAB1 print ans ;	int hp_y , atk_y , def_y ; int hp_m , atk_m , def_m ; int h , a , d ; int main ( ) { cin >> hp_y >> atk_y >> def_y ; cin >> hp_m >> atk_m >> def_m ; cin >> h >> a >> d ; int ans = INT_MAX ; for ( int i = atk_y ; i <= 200 ; i ++ ) { for ( int j = def_y ; j <= 200 ; j ++ ) { int damage_y = max ( 0 , i - def_m ) ; int damage_m = max ( 0 , atk_m - j ) ; if ( damage_y == 0 ) { continue ; } int turn = hp_m / damage_y ; if ( hp_m % damage_y != 0 ) { turn ++ ; } int hp_needed = max ( 0 , 1 - ( hp_y - damage_m * turn ) ) ; ans = min ( ans , ( i - atk_y ) * a + ( j - def_y ) * d + hp_needed * h ) ; } } cout << ans << " \n " ; return 0 ; }
TAB1 hy , ay , dy , hm , am , dm , h , a , d = long long int , cost = 10 ^ 12 ; TAB1 read hy , ay , dy , hm , am , dm , h , a , d ; TAB1 q = hm , z = ay , n = dm ; TAB1 temp = q / ( z - n ) ; TAB1 for i = max ( dm - ay + 1 , 0 ) to 200 inclusive ; TAB2 for j = 0 to 200 inclusive ; TAB3 v = ( ( hm - 1 ) / ( ay - dm + i ) ) + 1 ; TAB3 p = max ( 0 , am - dy - j ) ; TAB3 req = max ( v * p + 1 - hy , 0 ) ; TAB3 cost = min ( cost , req * h + i * a + j * d ) ; TAB1 print cost ;	int main ( ) { long long int hy , ay , dy , hm , am , dm , h , a , d , cost = 1e12 ; cin >> hy >> ay >> dy >> hm >> am >> dm >> h >> a >> d ; double q = hm , z = ay , n = dm ; double temp = q / ( z - n ) ; for ( int i = max ( dm - ay + 1 , ( long long int ) 0 ) ; i <= 200 ; i ++ ) { for ( int j = 0 ; j <= 200 ; j ++ ) { long long int v = ( ( hm - 1 ) / ( ay - dm + i ) ) + 1 ; long long int p = max ( ( long long int ) 0 , am - dy - j ) ; long long int req = max ( v * p + 1 - hy , ( long long int ) 0 ) ; cost = min ( cost , req * h + i * a + j * d ) ; } } cout << cost << endl ; return 0 ; }
TAB0 create long longs n , m , k ; TAB0 create long longs ans , a , b ; TAB1 read n read m read k ; TAB1 set ans to 0 ; TAB1 if k is greater than n + m - 2 ; TAB2 print " - 1 " ; TAB1 for i = 1 to i is less than or equal to squre root of n and i is less than or equal to k + 1 ; TAB2 if n % i is 0 ; TAB3 set a to i - 1 ; TAB3 set b to k - a ; TAB3 set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) ) ; TAB3 set a to ( n / i ) - 1 ; TAB3 if a is greater than k , break current loop iteration ; TAB3 set b to k - a ; TAB3 set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) ) ; TAB1 for i = 1 to i is less than or equal to square root of m and i is less then or equal to k + 1 ; TAB2 if n % i is 0 ; TAB3 set b to i - 1 ; TAB3 set a to k - b ; TAB3 set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) ) ; TAB3 set b to ( m / i ) - 1 ; TAB3 if b is greater than k , break current loop iteration ; TAB3 set a to k - b ; TAB3 set ans to maximum of ans and ( long long casted ( n / ( a + 1 ) ) * long long casted ( m / ( b + 1 ) ) ) ; TAB1 print ans print newline ;	long long n , m , k ; long long ans , a , b ; int main ( ) { cin >> n >> m >> k ; ans = 0 ; if ( k > n + m - 2 ) { puts ( " -1 " ) ; return 0 ; } for ( int i = 1 ; i <= sqrt ( n ) && i <= k + 1 ; i ++ ) if ( n % i == 0 ) { a = i - 1 ; b = k - a ; ans = max ( ans , ( long long ) ( n / ( a + 1 ) ) * ( long long ) ( m / ( b + 1 ) ) ) ; a = ( n / i ) - 1 ; if ( a > k ) continue ; b = k - a ; ans = max ( ans , ( long long ) ( n / ( a + 1 ) ) * ( long long ) ( m / ( b + 1 ) ) ) ; } for ( int i = 1 ; i <= sqrt ( m ) && i <= k + 1 ; i ++ ) if ( n % i == 0 ) { b = i - 1 ; a = k - b ; ans = max ( ans , ( long long ) ( n / ( a + 1 ) ) * ( long long ) ( m / ( b + 1 ) ) ) ; b = ( m / i ) - 1 ; if ( b > k ) continue ; a = k - b ; ans = max ( ans , ( long long ) ( n / ( a + 1 ) ) * ( long long ) ( m / ( b + 1 ) ) ) ; } cout << ans << endl ; return 0 ; }
TAB0 create integers n , i , c with c = 0 ; TAB0 create string s , create string array ch with size 1001 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read s ; TAB2 if s [ 0 ] is ' O ' and s [ 1 ] is ' O ' and c is 0 ; TAB3 set s [ 0 ] to ' + ' ; TAB3 set s [ 1 ] to ' + ' ; TAB3 set c to 1 ; TAB2 else if s [ 3 ] is ' O ' and s [ 4 ] is ' O ' and c is 0 ; TAB3 set s [ 3 ] to ' + ' ; TAB3 set s [ 4 ] to ' + ' ; TAB3 set c to 1 ; TAB2 set ch [ i ] to s ; TAB1 if c is 1 ; TAB2 print " YES " print newline ; TAB2 for i = 0 to n exclusive , print ch [ i ] print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int n , i , c = 0 ; string s , ch [ 1001 ] ; int main ( ) { cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> s ; if ( s [ 0 ] == ' O ' && s [ 1 ] == ' O ' && c == 0 ) { s [ 0 ] = ' + ' ; s [ 1 ] = ' + ' ; c = 1 ; } else if ( s [ 3 ] == ' O ' && s [ 4 ] == ' O ' && c == 0 ) { s [ 3 ] = ' + ' ; s [ 4 ] = ' + ' ; c = 1 ; } ch [ i ] = s ; } if ( c == 1 ) { cout << " YES " << endl ; for ( i = 0 ; i < n ; i ++ ) { cout << ch [ i ] << endl ; } } else cout << " NO " << endl ; return 0 ; }
TAB1 integer array x of size 10 with values 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2 ; TAB1 integer array y of size 10 with values 1 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 ; TAB1 p is an integer array with size 4 by 3 ; TAB1 let n be integer ; TAB1 read n ; TAB1 a is string ; TAB1 read a ; TAB1 declare integer variable called check = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 let z be integer = a [ i ] - 48 ; TAB2 create integer xx = x [ z ] ; TAB2 let yy be integer = y [ z ] ; TAB2 set value of p [ xx ] [ yy ] to 1 ; TAB1 let ans be integer = 1 ; TAB1 integer array xxx of size 4 with values 1 , - 1 , 0 , 0 ; TAB1 integer array yyy of size 4 with values 0 , 0 , 1 , - 1 ; TAB1 for integer i = 0 to 4 exclusive ; TAB2 declare integer variable called check = 0 ; TAB2 for j = 0 to 4 exclusive ; TAB3 for integer k = 0 to 3 exclusive ; TAB4 if p [ j ] [ k ] = 1 ; TAB5 if j = 2 and k = 1 and i = 0 ; TAB6 if j + xxx [ i ] > = 0 and j + xxx [ i ] < 4 and k + yyy [ i ] > = 0 and k + yyy [ i ] is less than 3 ; TAB6 else ; TAB7 check = 1 ; TAB5 else if j < 3 or ( j = 3 and k = 1 ) ; TAB6 if j + xxx [ i ] > = 0 and j + xxx [ i ] < 3 and k + yyy [ i ] > = 0 and k + yyy [ i ] is less than 3 ; TAB6 else ; TAB7 set check to 1 ; TAB2 if check = 0 , set ans to 0 ; TAB1 if ans = 0 ; TAB2 print " NO " and a new line ; TAB1 else ; TAB2 print " YES " and a new line ;	int main ( ) { int x [ 10 ] = { 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2 } ; int y [ 10 ] = { 1 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 } ; int p [ 4 ] [ 3 ] = { } ; int n ; cin >> n ; string a ; cin >> a ; int check = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int z = ( int ) a [ i ] - 48 ; int xx = x [ z ] ; int yy = y [ z ] ; p [ xx ] [ yy ] = 1 ; } int ans = 1 ; int xxx [ 4 ] = { 1 , - 1 , 0 , 0 } ; int yyy [ 4 ] = { 0 , 0 , 1 , - 1 } ; for ( int i = 0 ; i < 4 ; i ++ ) { int check = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { if ( p [ j ] [ k ] == 1 ) { if ( j == 2 && k == 1 && i == 0 ) { if ( j + xxx [ i ] >= 0 && j + xxx [ i ] < 4 && k + yyy [ i ] >= 0 && k + yyy [ i ] < 3 ) { } else { check = 1 ; } } else if ( ( j < 3 ) || ( j == 3 && k == 1 ) ) { if ( j + xxx [ i ] >= 0 && j + xxx [ i ] < 3 && k + yyy [ i ] >= 0 && k + yyy [ i ] < 3 ) { } else { check = 1 ; } } } } } if ( check == 0 ) ans = 0 ; } if ( ans == 0 ) cout << " NO " << endl ; else cout << " YES " << endl ; }
TAB0 let y , m and s be integer arrays with size 5 ; TAB0 create integers ans , atkm , atky , mm , my , j , i and sum ; TAB1 for i = 1 to 3 inclusive , read y [ i ] ; TAB1 for i = 1 to 3 inclusive , read m [ i ] ; TAB1 for i = 1 to 3 inclusive , read s [ i ] ; TAB1 ans = 999999 ; TAB1 for i = 0 to 200 inclusive ; TAB2 for j = 0 to 200 inclusive ; TAB3 sum = s [ 3 ] * j + s [ 2 ] * i ; TAB3 atky = i + y [ 2 ] - m [ 3 ] ; TAB3 atkm = m [ 2 ] - j - y [ 3 ] ; TAB3 skip the rest of the loop if atky < = 0 ; TAB3 if atkm < = 0 ; TAB4 ans = min of ans and sum ; TAB4 skip the rest of the loop ; TAB3 if m [ 1 ] modulo atky ! = 0 ; TAB4 mm = m [ 1 ] / atky + 1 ; TAB3 else ; TAB4 mm = m [ 1 ] / atky ; TAB3 if y [ 1 ] modulo atkm ! = 0 ; TAB4 my = y [ 1 ] / atkm + 1 ; TAB3 else ; TAB4 my = y [ 1 ] / atkm ; TAB3 if my < = mm , increase sum by ( mm * atkm + 1 - y [ 1 ] ) * s [ 1 ] ; TAB3 set ans to min of ans and sum ; TAB1 print ans ;	int y [ 5 ] , m [ 5 ] , s [ 5 ] ; int ans , atkm , atky , mm , my , j , i , sum ; int main ( ) { for ( i = 1 ; i <= 3 ; i ++ ) { cin >> y [ i ] ; } for ( i = 1 ; i <= 3 ; i ++ ) { cin >> m [ i ] ; } for ( i = 1 ; i <= 3 ; i ++ ) { cin >> s [ i ] ; } ans = 999999 ; for ( i = 0 ; i <= 200 ; i ++ ) { for ( j = 0 ; j <= 200 ; j ++ ) { sum = s [ 3 ] * j + s [ 2 ] * i ; atky = i + y [ 2 ] - m [ 3 ] ; atkm = m [ 2 ] - j - y [ 3 ] ; if ( atky <= 0 ) { continue ; } if ( atkm <= 0 ) { ans = min ( ans , sum ) ; continue ; } if ( m [ 1 ] % atky != 0 ) { mm = m [ 1 ] / atky + 1 ; } else { mm = m [ 1 ] / atky ; } if ( y [ 1 ] % atkm != 0 ) { my = y [ 1 ] / atkm + 1 ; } else { my = y [ 1 ] / atkm ; } if ( my <= mm ) { sum += ( mm * atkm + 1 - y [ 1 ] ) * s [ 1 ] ; } ans = min ( ans , sum ) ; } } cout << ans << endl ; }
TAB0 power is a function that get two ints and return an int ; TAB1 if x is 0 return 1 ; TAB1 if x is 1 return a ; TAB1 return power ( a , x / 2 ) * power ( a , x / 2 ) * power ( a , x % 2 ) ; TAB0 digitLen is a function that get an int and return an int ; TAB1 if x is 0 return 1 ; TAB1 set cnt to 0 ; TAB1 while x ; TAB2 divide x by 10 ; TAB2 increment cnt ; TAB1 return cnt ; TAB0 generate is a function that get an int and return a string ; TAB1 s = empty string ; TAB1 while a ; TAB2 concatenate s with a modulo 10 and ' 0 ' ; TAB2 divide a by 10 ; TAB1 reverse s ; TAB1 return s ; TAB1 a , b , n = int ; TAB1 read a , b , n ; TAB1 let string s = generate ( a ) ; TAB1 let can = false ; TAB1 for i = 0 to 9 inclusive ; TAB2 if ( a * power ( 10 , 1 ) + i ) modulo b is 0 ; TAB3 concatenate s with 1 and i + ' 0 ' ; TAB3 let can = true ; TAB3 break ; TAB1 if not can ; TAB2 print - 1 ; TAB1 for i = 0 to n - 1 exclusive concatenate s with " 0 " ; TAB1 print s ;	int power ( int a , int x ) { if ( x == 0 ) return 1 ; if ( x == 1 ) return a ; return power ( a , x / 2 ) * power ( a , x / 2 ) * power ( a , x % 2 ) ; } int digitLen ( int x ) { if ( x == 0 ) return 1 ; int cnt = 0 ; while ( x ) { x /= 10 ; cnt ++ ; } return cnt ; } string generate ( int a ) { string s = "  " ; while ( a ) { s += ( a % 10 ) + ' 0 ' ; a /= 10 ; } reverse ( s . begin ( ) , s . end ( ) ) ; return s ; } int main ( ) { int a , b , n ; cin >> a >> b >> n ; string s = generate ( a ) ; bool can = false ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( ( a * power ( 10 , 1 ) + i ) % b == 0 ) { s += string ( 1 , i + ' 0 ' ) ; can = true ; break ; } } if ( ! can ) { cout << - 1 << endl ; return 0 ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { s += " 0 " ; } cout << s << endl ; return 0 ; }
TAB1 n , d , i , sum , l = integers with sum , l set to 0 ; TAB1 Read n and d ; TAB1 a = array of n integers ; TAB1 for i = 0 to n exclusive ; TAB2 Read a [ i ] ; TAB2 set sum to sum + a [ i ] ; TAB1 if sum + 10 * ( n - 1 ) is greater than d ; TAB2 print - 1 and a new line ; TAB1 else do the following ; TAB2 print ( d - sum ) / 5 and a new line ;	int main ( ) { int n , d , i , sum = 0 , l = 0 ; cin >> n >> d ; int a [ n ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; sum += a [ i ] ; } if ( sum + 10 * ( n - 1 ) > d ) cout << - 1 << endl ; else cout << ( d - sum ) / 5 << endl ; }
TAB0 a = array of characters of size 105 ; TAB0 n = integer ; TAB0 declare check which returns an integer ; TAB1 set up , left , down , right to 0 ; TAB1 read a ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is 1 , 2 or 3 set up to 1 ; TAB2 if a [ i ] is 1 , 4 , 7 or 0 set left to 1 ; TAB2 if a [ i ] is 7 , 9 or 0 set down to 1 ; TAB2 if a [ i ] is 3 , 6 , 9 or 0 set right to 1 ; TAB1 if up , down , left and right are 1 return 1 ; TAB1 read n ; TAB1 if check returns 1 do the following ; TAB2 print YES ; TAB1 else do the following ; TAB2 print NO ;	char a [ 105 ] ; int n ; int check ( ) { int up = 0 , left = 0 , down = 0 , right = 0 ; cin >> a ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ' 1 ' || a [ i ] == ' 2 ' || a [ i ] == ' 3 ' ) up = 1 ; if ( a [ i ] == ' 1 ' || a [ i ] == ' 4 ' || a [ i ] == ' 7 ' || a [ i ] == ' 0 ' ) left = 1 ; if ( a [ i ] == ' 7 ' || a [ i ] == ' 9 ' || a [ i ] == ' 0 ' ) down = 1 ; if ( a [ i ] == ' 3 ' || a [ i ] == ' 6 ' || a [ i ] == ' 9 ' || a [ i ] == ' 0 ' ) right = 1 ; } if ( up && down && left && right ) return 1 ; return 0 ; } int main ( ) { cin >> n ; if ( check ( ) ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB0 create constant long long N with value 1001 ; TAB0 create integer n ; TAB0 create array of strings with size N called s ; TAB1 read n ; TAB1 let ok be boolean = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 read s [ i ] ; TAB2 if ok is false and s [ i ] [ 0 ] = s [ i ] [ 1 ] and s [ i ] [ 0 ] = ' O ' ; TAB3 set value of ok to 1 ; TAB3 s [ i ] [ 0 ] = ' + ' ; TAB3 s [ i ] [ 1 ] = ' + ' ; TAB2 if ok is false and s [ i ] [ 3 ] = s [ i ] [ 4 ] and s [ i ] [ 3 ] = ' O ' ; TAB3 set value of ok to 1 ; TAB3 s [ i ] [ 3 ] = ' + ' ; TAB3 s [ i ] [ 4 ] = ' + ' ; TAB1 if ok is true ; TAB2 print " YES " and a new line ; TAB2 print n elements of s and a new line after each one ; TAB1 else ; TAB2 print " NO " and a new line ;	const long long N = 1001 ; int n ; string s [ N ] ; int main ( ) { cin >> n ; bool ok = 0 ; for ( int i = 0 ; i < n ; ++ i ) { cin >> s [ i ] ; if ( ! ok and s [ i ] [ 0 ] == s [ i ] [ 1 ] and s [ i ] [ 0 ] == ' O ' ) { ok = 1 ; s [ i ] [ 0 ] = ' + ' ; s [ i ] [ 1 ] = ' + ' ; } if ( ! ok and s [ i ] [ 3 ] == s [ i ] [ 4 ] and s [ i ] [ 3 ] == ' O ' ) { ok = 1 ; s [ i ] [ 3 ] = ' + ' ; s [ i ] [ 4 ] = ' + ' ; } } if ( ok ) { cout << " YES " << endl ; for ( int i = 0 ; i < n ; ++ i ) { cout << s [ i ] << endl ; } } else { cout << " NO " << endl ; } return 0 ; }
TAB0 create long long int p = 998244353 ; TAB0 create long long int ans = 0 ; TAB0 in the function read that returns an integer ; TAB1 create integer x = 0 and f = 1 ; TAB1 read c ; TAB1 while c < 0 or c > 9 do the following ; TAB2 if c = - then set f to - 1 ; TAB2 read c ; TAB1 while c > = 0 and c < = 9 then set x = ( x < < 1 ) + ( x < < 3 ) + ( c ^ 48 ) and read c ; TAB1 return x * f ; TAB1 in the function main ; TAB1 create long long int n and m ; TAB1 read n and m ; TAB1 create integers dig_n = 0 and dig_m = 0 ; TAB1 create integer arrays count_n and count_m of size 7 each ; TAB1 create integer ans = 0 ; TAB1 call memset of count_n , 0 and sizeof ( count_n ) ; TAB1 call memset of count_m , 0 and sizeof ( count_m ) ; TAB1 while a is not 0 ; TAB2 set a = a / 7 ; TAB2 increment dig_n ; TAB1 while b is not 0 ; TAB2 set b = b / 7 ; TAB2 increment dig_m ; TAB1 if n = 1 then set dig_n to 1 ; TAB1 if m = 1 then set dig_m to 1 ; TAB1 if dig ) _n + dig_m > 7 ; TAB2 print 0 ; TAB1 else do the following ; TAB2 for i = 0 to n - 1 inclusive ; TAB3 call memset of count_n , 0 and sizeof ( count_n ) ; TAB3 set a = i ; TAB3 create integer ch = 0 ; TAB3 let count be an integer with count = 0 ; TAB3 while count is less than dig_n ; TAB4 create integer r = a mod 7 ; TAB4 set a = a / 7 ; TAB4 if count_n [ r ] is not 0 ; TAB5 then set ch = 1 ; TAB5 break ; TAB4 else do the following ; TAB5 set count_n [ r ] = 1 ; TAB4 add 1 to count ; TAB3 if ch is 1 then continue ; TAB3 for j = 0 to m - 1 inclusive ; TAB4 call memset of count_m , 0 and sizeof ( count_m ) ; TAB4 set b = j ; TAB4 create integer ch = 0 ; TAB4 let count be an integer with count = 0 ; TAB4 while count is less than dig_m ; TAB5 create integer r = b mod 7 ; TAB5 set b = b / 7 ; TAB5 if count_n [ r ] is not 0 or count_m [ r ] is not 0 ; TAB6 set ch to 1 ; TAB6 break ; TAB5 else do the following ; TAB6 set count_m [ r ] = 1 ; TAB5 add 1 to count ; TAB4 if ch is 1 ; TAB5 then continue ; TAB4 else do the following ; TAB5 add 1 to ans ; TAB2 print ans ;	long long p = 998244353 ; long long ans = 0 ; int read ( ) { int x = 0 , f = 1 ; char c = getchar ( ) ; while ( c < ' 0 ' || c > ' 9 ' ) { if ( c == ' - ' ) f = - 1 ; c = getchar ( ) ; } while ( c >= ' 0 ' && c <= ' 9 ' ) x = ( x << 1 ) + ( x << 3 ) + ( c ^ 48 ) , c = getchar ( ) ; return x * f ; } int main ( ) { long long n , m ; cin >> n >> m ; int dig_n = 0 , dig_m = 0 ; long long a = n - 1 , b = m - 1 ; int count_n [ 7 ] , count_m [ 7 ] ; int ans = 0 ; memset ( count_n , 0 , sizeof ( count_n ) ) ; memset ( count_m , 0 , sizeof ( count_m ) ) ; while ( a != 0 ) { a = a / 7 ; dig_n ++ ; } while ( b != 0 ) { b = b / 7 ; dig_m ++ ; } if ( n == 1 ) dig_n = 1 ; if ( m == 1 ) dig_m = 1 ; if ( dig_n + dig_m > 7 ) cout << 0 << endl ; else { for ( long long i = 0 ; i <= n - 1 ; i ++ ) { memset ( count_n , 0 , sizeof ( count_n ) ) ; a = i ; int ch = 0 ; int count = 0 ; while ( count < dig_n ) { int r = a % 7 ; a = a / 7 ; if ( count_n [ r ] != 0 ) { ch = 1 ; break ; } else count_n [ r ] = 1 ; count ++ ; } if ( ch == 1 ) continue ; for ( long long j = 0 ; j <= m - 1 ; j ++ ) { memset ( count_m , 0 , sizeof ( count_m ) ) ; b = j ; int ch = 0 ; int count = 0 ; while ( count < dig_m ) { int r = b % 7 ; b = b / 7 ; if ( count_n [ r ] != 0 || count_m [ r ] != 0 ) { ch = 1 ; break ; } else count_m [ r ] = 1 ; count ++ ; } if ( ch == 1 ) continue ; else { ans ++ ; } } } cout << ans << endl ; } return 0 ; }
TAB0 create constant integer M with M = 1e9 + 7 ; TAB0 declare solve with long longs n , m , k as arguments , returning long long ; TAB1 if k is greater than m + n - 2 ; TAB2 return - 1 from function ; TAB1 else if k is less than n ; TAB2 return n / ( k + 1 ) * m from function ; TAB1 else ; TAB2 decrement k by n - 1 ; TAB2 return m / ( k + 1 ) from function ; TAB1 create long longs n , m , k ; TAB1 while read n read m read k , print maximum of ( result of run solve with n , m , k as arguments and result of run solve with m , n , k as arguments ) print newline ;	const int M = 1e9 + 7 ; long long solve ( long long n , long long m , long long k ) { if ( k > m + n - 2 ) return - 1 ; else if ( k < n ) { return n / ( k + 1 ) * m ; } else { k -= n - 1 ; return m / ( k + 1 ) ; } } int main ( ) { long long n , m , k ; while ( cin >> n >> m >> k ) { cout << max ( solve ( n , m , k ) , solve ( m , n , k ) ) << endl ; } }
TAB1 create string a ; TAB1 read a ; TAB1 create integer n with n = integer casted size of a ; TAB1 if n is less than or equal to 3 ; TAB2 print " YES " print ' \ n ' ; TAB2 print a print ' \ n ' ; TAB1 create integer vector f initialized with 26 ; TAB1 for i = 0 to n exclusive , increment f [ a [ i ] - ' a ' ] ; TAB1 create character vector ans initialized with n + 1 ; TAB1 create boolean vector flags initialized with n + 1 ; TAB1 for i = 2 to n inclusive , incrementing i by 2 , set flags [ i ] to true ; TAB1 for i = 3 to n inclusive ; TAB2 if not flags [ i ] and i * 2 is less than or equal to n ; TAB3 for j = i to n inclusive , incrementing j by i , set flags [ j ] to true ; TAB1 create integer cont with cont = 0 ; TAB1 for i = 1 to n inclusive , increment cont by flags [ i ] ; TAB1 create integers most , pos with most = - 1 , pos = - 1 ; TAB1 for i = 0 to 26 exclusive ; TAB2 if f [ i ] is greater than most ; TAB3 set most to f [ i ] ; TAB3 set pos to i ; TAB1 if most is less than cont ; TAB2 print " NO " print ' \ n ' ; TAB1 decrement f [ pos ] by cont ; TAB1 for i = 1 to n inclusive ; TAB2 if flags [ i ] is true , set ans [ i ] to character casted ( pos + ' a ' ) ; TAB1 for i = 1 to n inclusive ; TAB2 if flags [ i ] is false ; TAB3 for j = 0 to 26 exclusive ; TAB4 if f [ j ] is greater than 0 ; TAB5 decrement f [ j ] ; TAB5 set ans [ i ] to character casted ( j + ' a ' ) ; TAB5 set flags [ i ] to true ; TAB5 break loop ; TAB1 for i = 1 to n inclusive ; TAB2 if flags [ i ] is false ; TAB3 print " NO " print ' \ n ' ; TAB1 print " YES " print ' \ n ' ; TAB1 for i = 1 to n inclusive , print ans [ i ] ; TAB1 print ' \ n ' ;	int main ( ) { string a ; cin >> a ; int n = ( int ) a . size ( ) ; if ( n <= 3 ) { cout << " YES " << ' \n ' ; cout << a << ' \n ' ; return 0 ; } vector < int > f ( 26 ) ; for ( int i = 0 ; i < n ; i ++ ) f [ a [ i ] - ' a ' ] ++ ; vector < char > ans ( n + 1 ) ; vector < bool > flags ( n + 1 ) ; for ( int i = 2 ; i <= n ; i += 2 ) flags [ i ] = true ; for ( int i = 3 ; i <= n ; i ++ ) { if ( ! flags [ i ] && i * 2 <= n ) { for ( int j = i ; j <= n ; j += i ) flags [ j ] = true ; } } int cont = 0 ; for ( int i = 1 ; i <= n ; i ++ ) cont += flags [ i ] ; int most = - 1 , pos = - 1 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( f [ i ] > most ) { most = f [ i ] ; pos = i ; } if ( most < cont ) { cout << " NO " << ' \n ' ; return 0 ; } f [ pos ] -= cont ; for ( int i = 1 ; i <= n ; i ++ ) if ( flags [ i ] ) ans [ i ] = ( char ) ( pos + ' a ' ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! flags [ i ] ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( f [ j ] > 0 ) { f [ j ] -- ; ans [ i ] = ( char ) ( j + ' a ' ) ; flags [ i ] = true ; break ; } } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! flags [ i ] ) { cout << " NO " << ' \n ' ; return 0 ; } } cout << " YES " << ' \n ' ; for ( int i = 1 ; i <= n ; i ++ ) cout << ans [ i ] ; cout << ' \n ' ; return 0 ; }
TAB1 h1 , a1 , d1 , h2 , a2 , d2 , h , a , d = integer ; TAB1 read h1 , a1 , d1 , h2 , a2 , d2 , h , a , d ; TAB1 min_val = integer with min_val = 1000000000 ; TAB1 for i = 0 to 200 ; TAB2 for j = 0 to 100 ; TAB3 a_n = integer with a_n = a1 + i ; TAB3 d_n = integer with d_n = d1 + j ; TAB3 if a_n < = d2 , continue ; TAB3 t = ( h2 - ( d2 - a_n + 1 ) ) / ( a_n - d2 ) ; TAB3 new_pwr = integer with new_pwr = t * max ( 0 , a2 - d_n ) + 1 ; TAB3 min_val = min ( min_val , i * a + j * d + max ( 0 , new_pwr - h1 ) * h ) ; TAB1 print min_val ;	int main ( ) { int h1 , a1 , d1 , h2 , a2 , d2 , h , a , d ; cin >> h1 >> a1 >> d1 >> h2 >> a2 >> d2 >> h >> a >> d ; int min_val = 1000000000 ; for ( int i = 0 ; i <= 200 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { int a_n = a1 + i ; int d_n = d1 + j ; if ( a_n <= d2 ) { continue ; } int t = ( h2 - ( d2 - a_n + 1 ) ) / ( a_n - d2 ) ; int new_pwr = t * max ( 0 , a2 - d_n ) + 1 ; min_val = min ( min_val , i * a + j * d + max ( 0 , new_pwr - h1 ) * h ) ; } } cout << min_val << endl ; }
TAB0 declare solve with no arguments , returning void ; TAB1 create integer n ; TAB1 read n ; TAB1 create integer vector v ; TAB1 for i = 0 to n exclusive ; TAB2 create integer x ; TAB2 read x ; TAB2 add element x to end of v ; TAB1 sort elements from beginning of v to end of v ; TAB1 create integer i with i = 0 ; TAB1 create integer j with j = n - 1 ; TAB1 create integer ans with ans = 0 ; TAB1 while 2 * v [ i ] is less than v [ j ] ; TAB2 if 2 * v [ i + 1 ] is greater than or equal to v [ j ] ; TAB3 increment i ; TAB3 increment ans ; TAB2 else if 2 * v [ i ] is greater than or equal to v [ j - 1 ] ; TAB3 decrement j ; TAB3 increment ans ; TAB2 else ; TAB3 increment ans by 2 ; TAB3 increment i ; TAB3 decrement j ; TAB1 print ans print newline ; TAB0 declare solve2 with no arguments , returning void ; TAB1 create integers a , b , n ; TAB1 read a read b read n ; TAB1 if a % b is 0 ; TAB2 print a ; TAB2 for i = 0 to n exclusive , print 0 ; TAB2 print newline ; TAB2 return from function ; TAB1 create boolean c with c = false ; TAB1 for i = 0 to 9 inclusive ; TAB2 if a * 10 + i % b is 0 ; TAB3 print a print i ; TAB3 set c to true ; TAB3 break loop ; TAB1 if c is true ; TAB2 for i = 0 to n - 1 exclusive , print 0 ; TAB2 print newline ; TAB1 else ; TAB2 print - 1 print newline ; TAB1 run solve2 ;	void solve ( ) { int n ; cin >> n ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; v . push_back ( x ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int i = 0 ; int j = n - 1 ; int ans = 0 ; while ( 2 * v [ i ] < v [ j ] ) { if ( 2 * v [ i + 1 ] >= v [ j ] ) { i ++ ; ans ++ ; } else if ( 2 * v [ i ] >= v [ j - 1 ] ) { j -- ; ans ++ ; } else { ans += 2 ; i ++ ; j -- ; } } cout << ans << endl ; } void solve2 ( ) { int a , b , n ; cin >> a >> b >> n ; if ( a % b == 0 ) { cout << a ; for ( int i = 0 ; i < n ; i ++ ) { cout << 0 ; } cout << endl ; return ; } bool c = false ; for ( int i = 0 ; i <= 9 ; i ++ ) { if ( ( a * 10 + i ) % b == 0 ) { cout << a << i ; c = true ; break ; } } if ( c ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << 0 ; } cout << endl ; } else cout << - 1 << endl ; } int main ( ) { solve2 ( ) ; return 0 ; }
TAB1 declare integers n , a , b and p ; TAB1 loop , reading n , a and b from the input ; TAB2 create integers r1 and r2 = 0 ; TAB2 for integer i = 0 to n exclusive ; TAB3 read p ; TAB3 if p is 1 ; TAB4 if a is greater than 0 ; TAB5 decrement a ; TAB4 else ; TAB5 if b is greater than 0 ; TAB6 decrease b by one ; TAB6 increase r1 by one ; TAB5 else if r1 is greater than 0 ; TAB6 decrement r1 ; TAB5 else ; TAB6 increment r2 ; TAB3 else ; TAB4 if b is greater than 0 ; TAB5 decrease b ; TAB4 else ; TAB5 increase r2 by 2 ; TAB2 print r2 ;	int main ( ) { int n , a , b , p ; while ( cin >> n >> a >> b ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> p ; if ( p == 1 ) { if ( a > 0 ) { a -- ; } else { if ( b > 0 ) { b -- ; r1 ++ ; } else if ( r1 > 0 ) r1 -- ; else r2 ++ ; } } else { if ( b > 0 ) b -- ; else r2 += 2 ; } } cout << r2 << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create 2d character array s with size 1000 by 20 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 5 exclusive , read s [ i ] [ j ] ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] [ 0 ] is ' O ' and s [ i ] [ 1 ] is ' O ' ; TAB3 set s [ i ] [ 0 ] to ' + ' ; TAB3 set s [ i ] [ 1 ] to ' + ' ; TAB3 print " YES \ n " ; TAB3 for j = 0 to n exclusive ; TAB4 for k = 0 to 5 exclusive , print s [ j ] [ k ] ; TAB4 print newline ; TAB2 if s [ i ] [ 3 ] is ' O ' and s [ i ] [ 4 ] is ' O ' ; TAB3 set s [ i ] [ 3 ] is ' + ' ; TAB3 set s [ i ] [ 4 ] is ' + ' ; TAB3 print " YES \ n " ; TAB3 for j = 0 to n exclusive ; TAB4 for k = 0 to 5 exclusive , print s [ j ] [ k ] ; TAB4 print newline ; TAB1 print " NO \ n " ;	int main ( ) { int n ; cin >> n ; char s [ 1000 ] [ 20 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { cin >> s [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] [ 0 ] == ' O ' && s [ i ] [ 1 ] == ' O ' ) { s [ i ] [ 0 ] = ' + ' ; s [ i ] [ 1 ] = ' + ' ; cout << " YES\n " ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < 5 ; k ++ ) { cout << s [ j ] [ k ] ; } cout << endl ; } return 0 ; } if ( s [ i ] [ 3 ] == ' O ' && s [ i ] [ 4 ] == ' O ' ) { s [ i ] [ 3 ] = ' + ' ; s [ i ] [ 4 ] = ' + ' ; cout << " YES\n " ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < 5 ; k ++ ) { cout << s [ j ] [ k ] ; } cout << endl ; } return 0 ; } } cout << " NO\n " ; return 0 ; }
TAB1 create integer n ; TAB1 let a be integer array with size 1005 ; TAB1 declare integer variables num5 , num0 and flag ; TAB1 read n in a loop ; TAB2 set value of num5 to 0 ; TAB2 set value of num0 to 0 ; TAB2 for integer i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 if a [ i ] = 5 ; TAB4 increment num5 ; TAB3 else if a [ i ] = 0 ; TAB4 increase num0 ; TAB2 flag = num5 / 9 ; TAB2 if num0 is 0 ; TAB3 print " - 1 " ; TAB2 else ; TAB3 if flag is not 0 ; TAB4 for integer i = 0 to flag * 9 exclusive print " 5 " ; TAB4 for integer i = 0 to num0 exclusive print " 0 " ; TAB3 else ; TAB4 print " 0 " ; TAB3 print new line ;	int main ( ) { int n ; int a [ 1005 ] ; int num5 , num0 , flag ; while ( cin >> n ) { num5 = 0 ; num0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] == 5 ) num5 ++ ; else if ( a [ i ] == 0 ) num0 ++ ; } flag = num5 / 9 ; if ( ! num0 ) cout << " -1 " << endl ; else { if ( flag ) { for ( int i = 0 ; i < flag * 9 ; i ++ ) cout << " 5 " ; for ( int i = 0 ; i < num0 ; i ++ ) cout << " 0 " ; } else cout << " 0 " ; cout << endl ; } } return 0 ; }
TAB1 a , b , n , k and i are integers where k = 0 ; TAB1 read a , b and n ; TAB1 create string s with length n - 1 filled with character ' 0 ' ; TAB1 for i = 0 to 10 exclusive ; TAB2 if ( a * 10 + i ) % b = 0 ; TAB3 set k to 1 ; TAB3 stop the loop ; TAB1 if k ! = 1 ; TAB2 print - 1 ; TAB1 else ; TAB2 print a * 10 + i ; TAB2 print s ;	int main ( ) { int a , b , n , k = 0 , i ; cin >> a >> b >> n ; string s ( n - 1 , ' 0 ' ) ; for ( i = 0 ; i < 10 ; ++ i ) { if ( ( a * 10 + i ) % b == 0 ) { k = 1 ; break ; } } if ( k != 1 ) { cout << - 1 << endl ; return 0 ; } else { cout << a * 10 + i ; cout << s << endl ; } return 0 ; }
TAB0 create constant integer MAXN with value 1001 ; TAB0 declare integer called n ; TAB0 let s be an array of characters of length MAXN ; TAB0 c is an array of integers with size 256 filled with 0 ; TAB0 f is an array of booleans with size MAXN ; TAB1 read input to s ; TAB1 assign length of s to n ; TAB1 memset with arguments c , sizeof ( c ) and 0 ; TAB1 for i = 0 to n exclusive incremen c [ s [ i ] ] ; TAB1 k is integer = 0 ; TAB1 for i = 0 to 256 exclusive ; TAB2 if c [ i ] is greater than c [ k ] set k to i ; TAB1 memset with arguments f , true and sizeof ( f ) ; TAB1 for integer i = 2 to i * i < = n ; TAB2 if f [ i ] is true ; TAB3 for integer j = i * i to n inclusive with step of i , set f [ j ] to false ; TAB1 set value of f [ 1 ] to true ; TAB1 for integer i = 2 to i + i < = n , set f [ j ] to false ; TAB1 for i = 1 to n inclusive ; TAB2 if f [ i ] is false ; TAB3 if c [ k ] = 0 ; TAB4 print " NO " and a new line ; TAB3 decrease c [ s [ i - 1 ] = k ] by one ; TAB1 assign value of 0 to k ; TAB1 for integer i = 1 to n inclusive ; TAB2 if f [ i ] is true ; TAB3 increment k while c [ k ] = 0 ; TAB3 decrease c [ s [ i - 1 ] = k ] by one ; TAB1 print " YES " and a new line ; TAB1 print s and a new line ;	const int MAXN = 1001 ; int n ; char s [ MAXN ] ; int c [ 256 ] = { 0 } ; bool f [ MAXN ] ; int main ( ) { gets ( s ) ; n = strlen ( s ) ; memset ( c , sizeof ( c ) , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) c [ s [ i ] ] ++ ; int k = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) if ( c [ i ] > c [ k ] ) k = i ; memset ( f , true , sizeof ( f ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( f [ i ] ) for ( int j = i * i ; j <= n ; j += i ) f [ j ] = false ; f [ 1 ] = true ; for ( int i = 2 ; i + i <= n ; i ++ ) f [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! f [ i ] ) { if ( c [ k ] == 0 ) { cout << " NO " << endl ; return 0 ; } c [ s [ i - 1 ] = k ] -- ; } k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( f [ i ] ) { while ( c [ k ] == 0 ) k ++ ; c [ s [ i - 1 ] = k ] -- ; } cout << " YES " << endl ; cout << s << endl ; return 0 ; }
TAB1 create integers n , d , t ; TAB1 create integer array a with size 1000 ; TAB1 read n read d ; TAB1 create integer jokes with jokes = 0 ; TAB1 create integer mint with mint = 0 ; TAB1 create integer restBetween with restBetween = ( n - 1 ) * 10 ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 increment mint by a [ i ] ; TAB1 if mint + restBetween is less than or equal to d ; TAB2 create integer rem with rem = d - ( mint + restBetween ) ; TAB2 print restBetween / 5 + rem / 5 print newline ; TAB1 else ; TAB2 print - 1 print newline ;	int main ( ) { int n , d , t ; int a [ 1000 ] ; cin >> n >> d ; int jokes = 0 ; int mint = 0 ; int restBetween = ( n - 1 ) * 10 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; mint += a [ i ] ; } if ( mint + restBetween <= d ) { int rem = d - ( mint + restBetween ) ; cout << restBetween / 5 + rem / 5 << endl ; } else { cout << - 1 << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 a = matrix of [ n + 10 ] x [ 10 ] char ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 5 exclusive read a [ i ] [ j ] ; TAB1 create integer flag with flag = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] [ 0 ] is O and a [ i ] [ 1 ] is O ; TAB3 a [ i ] [ 0 ] = + ; TAB3 a [ i ] [ 1 ] = + ; TAB3 flag = 1 ; TAB3 stop loop ; TAB2 else if a [ i ] [ 3 ] is O and a [ i ] [ 4 ] is O ; TAB3 a [ i ] [ 3 ] = + ; TAB3 a [ i ] [ 4 ] = + ; TAB3 flag = 1 ; TAB3 stop loop ; TAB1 if flag is 1 ; TAB2 print YES and new line ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to 5 exlusive print a [ i ] [ j ] ; TAB3 print new line ; TAB1 else ; TAB2 print NO and new line ;	int main ( ) { int n ; cin >> n ; char a [ n + 10 ] [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { cin >> a [ i ] [ j ] ; } } int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] [ 0 ] == ' O ' && a [ i ] [ 1 ] == ' O ' ) { a [ i ] [ 0 ] = ' + ' ; a [ i ] [ 1 ] = ' + ' ; flag = 1 ; break ; } else if ( a [ i ] [ 3 ] == ' O ' && a [ i ] [ 4 ] == ' O ' ) { a [ i ] [ 3 ] = ' + ' ; a [ i ] [ 4 ] = ' + ' ; flag = 1 ; break ; } } if ( flag == 1 ) { cout << " YES " << endl ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) cout << a [ i ] [ j ] ; cout << endl ; } } else cout << " NO " << endl ; return 0 ; }
TAB0 inf = const int with value 0x3f3f3f3f ; TAB0 pi = const double with value result of acos called with - 1 ; TAB1 a , b , c = long long ; TAB1 input a , b and c ; TAB1 if a + b - 2 < c then ; TAB2 print - 1 ; TAB1 else ; TAB2 if a > b call swap with a and b ; TAB2 if a mod c + 1 is zero or b % c + 1 is zero ; TAB3 print a * b / ( c + 1 ) ; TAB2 else ; TAB3 if b - 1 greater than or equal to c ; TAB4 if a - 1 greater than or equal c ; TAB5 print max ( b / ( c + 1 ) * a , a / ( c + 1 ) * b ) ; TAB4 else ; TAB5 print b / ( c + 1 ) * a ; TAB3 else ; TAB4 print a / ( c - b + 1 + 1 ) ;	const int inf = 0x3f3f3f3f ; const double pi = acos ( - 1.0 ) ; int main ( ) { long long a , b , c ; cin >> a >> b >> c ; if ( a + b - 2 < c ) cout << - 1 << endl ; else { if ( a > b ) swap ( a , b ) ; if ( a % ( c + 1 ) == 0 || b % ( c + 1 ) == 0 ) { cout << a * b / ( c + 1 ) << endl ; } else { if ( b - 1 >= c ) { if ( a - 1 >= c ) cout << max ( b / ( c + 1 ) * a , a / ( c + 1 ) * b ) << endl ; else cout << b / ( c + 1 ) * a << endl ; } else { cout << a / ( c - b + 1 + 1 ) << endl ; } } } return 0 ; }
TAB1 n , i and ct are integers , with ct = 0 ; TAB1 ch = array of characters of length 100 ; TAB1 read n ; TAB1 arr is an array of strings with size 1010 ; TAB1 for i = 0 to n exclusive ; TAB2 read ch ; TAB2 if ct = 0 ; TAB3 if ch [ 0 ] = ' O ' and ch [ 1 ] = ' O ' ; TAB4 ch [ 0 ] = ' + ' ; TAB4 ch [ 1 ] = ' + ' ; TAB4 set value of ct to 1 ; TAB2 if ct = 0 ; TAB3 if ch [ 3 ] = ' O ' and ch [ 4 ] = ' O ' ; TAB4 ch [ 3 ] = ' + ' ; TAB4 ch [ 4 ] = ' + ' ; TAB4 set ct to 1 ; TAB2 set arr [ i ] to ch ; TAB1 if ct = 1 ; TAB2 print " YES " and a new line ; TAB2 print n elements of arr with new line after each one ; TAB1 else ; TAB2 print " NO " and a new line ;	int main ( ) { int n , i , ct = 0 ; char ch [ 100 ] ; cin >> n ; string arr [ 1010 ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> ch ; if ( ct == 0 ) { if ( ch [ 0 ] == ' O ' && ch [ 1 ] == ' O ' ) { ch [ 0 ] = ' + ' ; ch [ 1 ] = ' + ' ; ct = 1 ; } } if ( ct == 0 ) { if ( ch [ 3 ] == ' O ' && ch [ 4 ] == ' O ' ) { ch [ 3 ] = ' + ' ; ch [ 4 ] = ' + ' ; ct = 1 ; } } arr [ i ] = ch ; } if ( ct == 1 ) { cout << " YES " << endl ; for ( i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << endl ; } } else { cout << " NO " << endl ; } return 0 ; }
TAB0 y , m and s = arrays of length 5 ; TAB0 ans , atkm , atky , mm , my , j , i , sum = integers ; TAB1 for i = 1 to 3 inclusive , read index i of y ; TAB1 for i = 1 to 3 inclusive , read index i of m ; TAB1 for i = 1 to 3 inclusive , read index i of s ; TAB1 set ans = 999999 ; TAB1 for i = 0 to 200 inclusive ; TAB2 for j = 0 j to 200 inclusive ; TAB3 set sum = index 3 of s * j + index 2 of s * i ; TAB3 set atky = i + index 2 of y - index 3 of m ; TAB3 set atkm = index 2 of m - j - index 3 of y ; TAB3 if atky is less than or equal to 0 , continue ; TAB3 if atkm is less than or equal to 0 ; TAB4 set ans = the smaller number between ans and sum ; TAB4 continue ; TAB3 if index 1 of m modulo atky doesn ' t = 0 ; TAB4 set mm = index 1 of m / atky + 1 ; TAB3 else ; TAB4 set mm = index 1 of m / atky ; TAB3 if index 1 of y modulo atkm doesn ' t = 0 ; TAB4 set my = index 1 of y / atkm + 1 ; TAB3 else ; TAB4 set my = index 1 of y / atkm ; TAB3 if my is less than = mm , increment sum by ( mm * atkm + 1 - index 1 of y ) * index 1 of s ; TAB3 set ans = the smaller number between ans and sum ; TAB1 print ans ;	int y [ 5 ] , m [ 5 ] , s [ 5 ] ; int ans , atkm , atky , mm , my , j , i , sum ; int main ( ) { for ( i = 1 ; i <= 3 ; i ++ ) { cin >> y [ i ] ; } for ( i = 1 ; i <= 3 ; i ++ ) { cin >> m [ i ] ; } for ( i = 1 ; i <= 3 ; i ++ ) { cin >> s [ i ] ; } ans = 999999 ; for ( i = 0 ; i <= 200 ; i ++ ) { for ( j = 0 ; j <= 200 ; j ++ ) { sum = s [ 3 ] * j + s [ 2 ] * i ; atky = i + y [ 2 ] - m [ 3 ] ; atkm = m [ 2 ] - j - y [ 3 ] ; if ( atky <= 0 ) { continue ; } if ( atkm <= 0 ) { ans = min ( ans , sum ) ; continue ; } if ( m [ 1 ] % atky != 0 ) { mm = m [ 1 ] / atky + 1 ; } else { mm = m [ 1 ] / atky ; } if ( y [ 1 ] % atkm != 0 ) { my = y [ 1 ] / atkm + 1 ; } else { my = y [ 1 ] / atkm ; } if ( my <= mm ) { sum += ( mm * atkm + 1 - y [ 1 ] ) * s [ 1 ] ; } ans = min ( ans , sum ) ; } } cout << ans << endl ; }
TAB0 create constant integer MAXN with MAXN = 1001 ; TAB0 create integer n ; TAB0 create character array s with size MAXN ; TAB0 create integer array c with size 256 ; TAB0 declare boolean array f with size MAXN ; TAB1 read string into s ; TAB1 set n to string length of s ; TAB1 for i = 0 to n exclusive , increment c [ s [ i ] ] ; TAB1 create integer k with k = 0 ; TAB1 for i = 0 to 256 exclusive ; TAB2 if c [ i ] is greater than c [ k ] , set k to i ; TAB1 set bytes from f to size of f to true ; TAB1 for i = 2 to i * i is less than or equal to n , incrementing i ; TAB2 if f [ i ] is true ; TAB3 for j = i * i to n inclusive , incrementing j by i , set f [ j ] to false ; TAB1 set f [ 1 ] to true ; TAB1 for i = 2 to i + i is less than or equal to n , incrementing i , set f [ i ] to false ; TAB1 for i = 1 to n inclusive ; TAB2 if not f [ i ] ; TAB3 if c [ k ] is 0 ; TAB4 print " NO " ; TAB3 decrement c [ set s [ i - 1 ] to k ] ; TAB1 set k to 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if f [ i ] is true ; TAB3 while c [ k ] is 0 , increment k ; TAB3 decrement c [ set s [ i - 1 ] to k ] ; TAB1 print " YES " ; TAB1 print s ;	const int MAXN = 1001 ; int n ; char s [ MAXN ] ; int c [ 256 ] ; bool f [ MAXN ] ; int main ( ) { gets ( s ) ; n = strlen ( s ) ; for ( int i = 0 ; i < n ; ++ i ) c [ s [ i ] ] ++ ; int k = 0 ; for ( int i = 0 ; i < 256 ; ++ i ) if ( c [ i ] > c [ k ] ) k = i ; memset ( f , true , sizeof ( f ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( f [ i ] ) for ( int j = i * i ; j <= n ; j += i ) f [ j ] = false ; f [ 1 ] = true ; for ( int i = 2 ; i + i <= n ; i ++ ) f [ i ] = false ; for ( int i = ( 1 ) ; i <= ( n ) ; ++ i ) if ( ! f [ i ] ) { if ( c [ k ] == 0 ) { puts ( " NO " ) ; return 0 ; } c [ s [ i - 1 ] = k ] -- ; } k = 0 ; for ( int i = ( 1 ) ; i <= ( n ) ; ++ i ) if ( f [ i ] ) { while ( c [ k ] == 0 ) k ++ ; c [ s [ i - 1 ] = k ] -- ; } puts ( " YES " ) ; puts ( s ) ; return 0 ; }
TAB1 declare integer variables n and temp ; TAB1 read n ; TAB1 declare integer variables cont1 and cont2 = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read temp ; TAB2 if temp = 5 ; TAB3 increase cont1 by one ; TAB2 else ; TAB3 increase cont2 by one ; TAB1 if cont2 = 0 ; TAB2 print " - 1 \ n " ; TAB1 else ; TAB2 declare integer variable ans = 0 ; TAB2 temp = 0 ; TAB2 for i = 1 to cont1 inclusive ; TAB3 temp = temp * 10 + 5 ; TAB3 temp % = 9 ; TAB3 if temp = 0 assign i to ans ; TAB2 if ans = 0 ; TAB3 print " 0 \ n " ; TAB2 else ; TAB3 print " 5 " ans times ; TAB3 print " 0 " cont2 times ; TAB3 print ' \ n ' ;	int main ( ) { int n , temp ; cin >> n ; int cont1 = 0 , cont2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> temp ; if ( temp == 5 ) cont1 ++ ; else cont2 ++ ; } if ( cont2 == 0 ) cout << " -1\n " ; else { int ans = 0 ; temp = 0 ; for ( int i = 1 ; i <= cont1 ; i ++ ) { temp = temp * 10 + 5 ; temp %= 9 ; if ( temp == 0 ) { ans = i ; } } if ( ans == 0 ) { cout << " 0\n " ; } else { for ( int i = 0 ; i < ans ; i ++ ) { cout << " 5 " ; } for ( int i = 0 ; i < cont2 ; i ++ ) { cout << " 0 " ; } cout << ' \n ' ; } } return 0 ; }
TAB1 declare integer variable zeroes = 0 ; TAB1 declare integer variable fives = 0 ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 declare integer variable temp ; TAB1 for integer i = 0 to n exclusive ; TAB2 read temp ; TAB2 if temp = 0 increment zeroes ; TAB2 if temp = 5 increment fives ; TAB1 if zeroes and fives > = 9 ; TAB2 for integer i = 0 to fives / 9 * 9 exclusive print " 5 " ; TAB2 for i = 0 to zeroes exclusive print " 0 " ; TAB2 print " \ n " ; TAB1 else if zeroes is not 0 ; TAB2 print " 0 \ n " ; TAB1 else ; TAB2 print " - 1 \ n " ;	int main ( ) { int zeroes = 0 ; int fives = 0 ; int n ; cin >> n ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { cin >> temp ; if ( temp == 0 ) zeroes ++ ; if ( temp == 5 ) fives ++ ; } if ( zeroes && fives >= 9 ) { for ( int i = 0 ; i < fives / 9 * 9 ; i ++ ) { cout << " 5 " ; } for ( int i = 0 ; i < zeroes ; i ++ ) { cout << " 0 " ; } cout << " \n " ; } else if ( zeroes ) { cout << " 0\n " ; } else { cout << " -1\n " ; } }
TAB1 n is integer ; TAB1 s is an character array with 10000 elements ; TAB1 read n and s in a loop ; TAB2 let be integers U , D , L and R = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if s [ i ] = ' 0 ' , set D , R and L to 1 ; TAB3 if s [ i ] = ' 1 ' | | s [ i ] = ' 2 ' | | s [ i ] = ' 3 ' , set U to 1 ; TAB3 if s [ i ] = ' 1 ' | | s [ i ] = ' 4 ' | | s [ i ] = ' 7 ' , set L to 1 ; TAB3 if s [ i ] = ' 3 ' | | s [ i ] = ' 6 ' | | s [ i ] = ' 9 ' , set R to 1 ; TAB3 if s [ i ] = ' 7 ' | | s [ i ] = ' 9 ' , set D to 1 ; TAB2 if U , D , R and L are all equal to 1 ; TAB3 print " YES " and a new line ; TAB2 else ; TAB3 print " NO " and a new line ;	int main ( ) { int n ; char s [ 10000 ] ; while ( cin >> n >> s ) { int U = 0 , D = 0 , L = 0 , R = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 0 ' ) D = R = L = 1 ; if ( s [ i ] == ' 1 ' || s [ i ] == ' 2 ' || s [ i ] == ' 3 ' ) U = 1 ; if ( s [ i ] == ' 1 ' || s [ i ] == ' 4 ' || s [ i ] == ' 7 ' ) L = 1 ; if ( s [ i ] == ' 3 ' || s [ i ] == ' 6 ' || s [ i ] == ' 9 ' ) R = 1 ; if ( s [ i ] == ' 7 ' || s [ i ] == ' 9 ' ) D = 1 ; } if ( U == 1 && D == 1 && R == 1 && L == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB0 create integers a , b and n ; TAB0 declare integer called flag = 0 ; TAB0 create long long integer bb ; TAB1 read a , b and n ; TAB1 for i = 0 to 9 inclusive ; TAB2 bb = ( a * 10 ) + i ; TAB2 if bb % b = 0 ; TAB3 print bb ; TAB3 flag = 1 ; TAB3 print 0 n - 1 times ; TAB3 stop the loop ; TAB1 if flag = 1 ; TAB2 print new line ; TAB1 else ; TAB2 print " - 1 " and a new line ;	int a , b , n ; int flag = 0 ; long long int bb ; int main ( ) { cin >> a >> b >> n ; for ( int i = 0 ; i <= 9 ; i ++ ) { bb = ( a * 10 ) + i ; if ( bb % b == 0 ) { cout << bb ; flag = 1 ; for ( long long int j = 1 ; j < n ; j ++ ) { cout << 0 ; } break ; } } if ( flag == 1 ) cout << endl ; else cout << " -1 " << endl ; }
TAB1 n , a , b , x , y , z = integers with y = 0 and z = 0 ; TAB1 Read n , a , b ; TAB1 while n is not equal to 0 ; TAB2 Read x ; TAB2 if x is equal to 1 ; TAB3 if a is not equal to 0 ; TAB4 decrement a ; TAB3 else if b is not equal to 0 ; TAB4 decrement b ; TAB4 increment z ; TAB3 else if z is not equal to 0 ; TAB4 decrement z ; TAB3 else do the following ; TAB4 increment y ; TAB2 else do the following ; TAB3 if b is not equal to 0 ; TAB4 decrement b ; TAB3 else do the following ; TAB4 increment y ; TAB4 increment y ; TAB1 print y and a new line ;	int main ( ) { long long int n , a , b , x , y = 0 , z = 0 ; cin >> n >> a >> b ; while ( n -- ) { cin >> x ; if ( x == 1 ) { if ( a ) { a -- ; } else if ( b ) { b -- ; z ++ ; } else if ( z ) { z -- ; } else { y ++ ; } } else { if ( b ) { b -- ; } else { y ++ ; y ++ ; } } } cout << y << " \n " ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create integer maxn with maxn = 0 ; TAB1 create long long sum with sum = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 create integer x ; TAB2 read x ; TAB2 increment sum by x ; TAB2 set maxn to maximum of maxn and x ; TAB1 create long long ans with ans = ( sum + n - 2 ) / ( n - 1 ) ; TAB1 set ans to maximum of ans and 1LL * maxn ; TAB1 print ans print newline ;	int main ( ) { int n ; cin >> n ; int maxn = 0 ; long long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x ; cin >> x ; sum += x ; maxn = max ( maxn , x ) ; } long long ans = ( sum + n - 2 ) / ( n - 1 ) ; ans = max ( ans , 1LL * maxn ) ; cout << ans << endl ; return 0 ; }
TAB1 create long longs s , x , n , mx with s = 0 , mx = INT_MIN ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read x ; TAB2 increment x by x ; TAB2 set mx to maximum of x and mx ; TAB1 print maximum of ( mx and ( s - 1 ) / ( n - 1 ) + 1 ) print newline ;	int main ( ) { long long s = 0 , x , n , mx = INT_MIN ; cin >> n ; for ( long long i = 1 ; i <= n ; i ++ ) { cin >> x ; s += x ; mx = max ( x , mx ) ; } cout << max ( mx , ( s - 1 ) / ( n - 1 ) + 1 ) << endl ; return 0 ; }
TAB1 declare integers a , b and n ; TAB1 read a , b and n ; TAB1 boolean exist = false ; TAB1 for integer i = 0 to 10 exclusive ; TAB2 if ( a * 10 + i ) % b = 0 ; TAB3 print a * 10 + i ; TAB3 create string s with length n - 1 filled with ' 0 ' ; TAB3 print s and a new line ; TAB3 assign value of true to exist ; TAB3 stop the loop ; TAB1 if exist is false , print - 1 and a new line ;	int main ( ) { int a , b , n ; cin >> a >> b >> n ; bool exist ( false ) ; for ( int i = 0 ; i < 10 ; ++ i ) { if ( ( a * 10 + i ) % b == 0 ) { cout << a * 10 + i ; string s ( n - 1 , ' 0 ' ) ; cout << s << endl ; exist = true ; break ; } } if ( ! exist ) { cout << - 1 << endl ; } return 0 ; }
TAB0 let n , m be integers ; TAB0 used = bool array of size 7 ; TAB0 counter , digitn , digitm = integers with counter = 0 , digitn = 0 , and digitm = 0 ; TAB0 in the function checkh that takes integer x and return bool ; TAB1 if x is greater than or equal to 0 and x is less than n , then return true ; TAB1 return false ; TAB0 in the function checkm that takes integer x and return bool ; TAB1 if x is greater than or equal to 0 and x is less than m , then return true ; TAB1 return false ; TAB0 in the function permutem that takes integers a , number ; TAB1 if number is equal to digitm ; TAB2 if call checkm with argument a is true , then increment counter ; TAB2 return ; TAB1 for i = 0 to 7 exclusive ; TAB2 if not used [ i ] ; TAB3 set used [ i ] to true ; TAB3 call permutem with arguments a * 7 + i , number + 1 ; TAB3 set used [ i ] to false ; TAB0 in the function permuteh that takes integers a , number ; TAB1 if number is equal to digitn ; TAB2 if call checkh with argument a is true , then call permutem with arguments 0 , 0 ; TAB2 return ; TAB1 for i = 0 to 7 exclusive ; TAB2 if not used [ i ] ; TAB3 set used [ i ] to true ; TAB3 call permuteh with arguments a * 7 + i , number + 1 ; TAB3 set used [ i ] to false ; TAB1 read n , m ; TAB1 faken = integer = n - 1 , fakem = integer = m - 1 ; TAB1 if n is equal to 1 , then assign 1 to faken ; TAB1 if m is equal to 1 , then assign 1 to fakem ; TAB1 while faken is greater than 0 ; TAB2 assign faken / 7 to faken ; TAB2 increment digitn ; TAB1 while fakem is greater than 0 ; TAB2 assign fakem / 7 to fakem ; TAB2 increment digitm ; TAB1 if the sum of digitn and digitm is greater than 7 ; TAB2 output 0 ; TAB1 else ; TAB2 call permuteh with arguments 0 , 0 ; TAB2 output counter ;	int n , m ; bool used [ 7 ] ; int counter = 0 , digitn = 0 , digitm = 0 ; bool checkh ( int x ) { if ( x >= 0 && x < n ) return true ; return false ; } bool checkm ( int x ) { if ( x >= 0 && x < m ) return true ; return false ; } void permutem ( int a , int number ) { if ( number == digitm ) { if ( checkm ( a ) ) counter ++ ; return ; } for ( int i = 0 ; i < 7 ; i ++ ) if ( ! used [ i ] ) { used [ i ] = true ; permutem ( a * 7 + i , number + 1 ) ; used [ i ] = false ; } } void permuteh ( int a , int number ) { if ( number == digitn ) { if ( checkh ( a ) ) permutem ( 0 , 0 ) ; return ; } for ( int i = 0 ; i < 7 ; i ++ ) if ( ! used [ i ] ) { used [ i ] = true ; permuteh ( a * 7 + i , number + 1 ) ; used [ i ] = false ; } } int main ( ) { cin >> n >> m ; int faken = n - 1 , fakem = m - 1 ; if ( n == 1 ) faken = 1 ; if ( m == 1 ) fakem = 1 ; while ( faken > 0 ) { faken /= 7 ; digitn ++ ; } while ( fakem > 0 ) { fakem /= 7 ; digitm ++ ; } if ( digitn + digitm > 7 ) cout << 0 << " \n " ; else { permuteh ( 0 , 0 ) ; cout << counter << " \n " ; } return 0 ; }
TAB0 unsigned long long integer n and array a [ 100010 ] ; TAB0 check is a boolean function with unsigned long long integer argument x ; TAB1 unsigned long long int tmp = 0 , i ; TAB1 for i = 0 to n exclusive , increase tmp by x - a [ i ] ; TAB1 return ( tmp > = x ) ; TAB0 unsigned long long int function binSearch with arguments called low and high ; TAB1 while low is less than high ; TAB2 mid = ( low + high ) / 2 ; TAB2 if check ( mid ) is true ; TAB3 high = mid ; TAB2 else ; TAB3 low = mid + 1 ; TAB1 return low ; TAB1 unsigned long long int t = 1 ; TAB1 decrement t while it is > 0 ; TAB2 unsigned long long integers ans = 0 and i ; TAB2 read n ; TAB2 for i = 0 to n exclusive read a [ i ] ; TAB2 sort a ; TAB2 set value of ans to binSearch ( a [ n - 1 ] , 1e15 ) ; TAB2 print ans and " \ n " ;	unsigned long long int a [ 100010 ] , n ; bool check ( unsigned long long int x ) { unsigned long long int tmp = 0 , i ; for ( i = 0 ; i < n ; i ++ ) tmp += ( x - a [ i ] ) ; return ( tmp >= x ) ; } unsigned long long int binSearch ( unsigned long long int low , unsigned long long int high ) { while ( low < high ) { unsigned long long int mid = ( low + high ) / 2 ; if ( check ( mid ) ) high = mid ; else low = mid + 1 ; } return low ; } int main ( ) { unsigned long long int t = 1 ; while ( t -- ) { unsigned long long int ans = 0 , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; ans = binSearch ( a [ n - 1 ] , 1e15 ) ; cout << ans << " \n " ; } return 0 ; }
TAB1 create integers n , x , num1 , num2 , ans ; TAB1 while read n is true ; TAB2 set num1 to 0 ; TAB2 set num2 to 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read x ; TAB3 if x is 0 ; TAB4 increment num1 ; TAB3 else if x is 5 ; TAB4 increment num2 ; TAB2 if num1 is 0 ; TAB3 print " - 1 " print newline ; TAB2 else ; TAB3 set ans to num2 / 9 ; TAB3 if ans and num1 ; TAB4 for i = 0 to ans * 9 exclusive , print " 5 " ; TAB4 for i = 0 to num1 exclusive , print " 0 " ; TAB3 else ; TAB4 print " 0 " ; TAB3 print newline ;	int main ( ) { int n , x , num1 , num2 , ans ; while ( cin >> n ) { num1 = 0 ; num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 0 ) num1 ++ ; else if ( x == 5 ) num2 ++ ; } if ( num1 == 0 ) cout << " -1 " << endl ; else { ans = num2 / 9 ; if ( ans && num1 ) { for ( int i = 0 ; i < ans * 9 ; i ++ ) cout << " 5 " ; for ( int i = 0 ; i < num1 ; i ++ ) cout << " 0 " ; } else cout << " 0 " ; cout << endl ; } } return 0 ; }
TAB0 let songs be integer array with size 100001 ; TAB1 declare integers n and d ; TAB1 read n and d ; TAB1 for integer i = 0 to n exclusive ; TAB1 declare integer replica = d ; TAB1 declare integer availabletime = d ; TAB1 for i = 0 to n exclusive ; TAB2 decrease replica by songs [ i ] ; TAB2 decrease replica by 10 ; TAB2 decrease availabletime by songs [ i ] ; TAB1 increase replica by 10 ; TAB1 if replica is less than 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print availabletime / 5 ;	int songs [ 100001 ] ; int main ( ) { int n , d ; cin >> n >> d ; for ( int i = 0 ; i < n ; i ++ ) { cin >> songs [ i ] ; } int replica = d ; int availabletime = d ; for ( int i = 0 ; i < n ; i ++ ) { replica -= songs [ i ] ; replica -= 10 ; availabletime -= songs [ i ] ; } replica += 10 ; if ( replica < 0 ) { cout << - 1 << endl ; return 0 ; } else { cout << availabletime / 5 << endl ; } }
TAB1 let a , b , c and flag be unsigned long longs where flag = 1 ; TAB1 read a , b and c ; TAB1 for i = 0 to 10 exclusive ; TAB2 create long long integer p ; TAB2 p = 10 * a + i ; TAB2 if p modulo b is 0 ; TAB3 flag = 0 ; TAB3 print a and i ; TAB3 for integer j = 1 to c exclusive print 0 ; TAB3 stop the loop ; TAB1 if flag = 0 , print a new line ; TAB1 if flag print - 1 ;	int main ( ) { unsigned long long a , b , c , flag = 1 ; cin >> a >> b >> c ; for ( int i = 0 ; i < 10 ; i ++ ) { long long int p ; p = 10 * a + i ; if ( p % b == 0 ) { flag = 0 ; cout << a << i ; for ( int j = 1 ; j < c ; j ++ ) { cout << 0 ; } break ; } } if ( flag == 0 ) cout << endl ; if ( flag ) cout << - 1 << endl ; }
TAB1 round , num , sum and max are long longs , with sum = 0 and max = - 1 , a is an array of long longs with size 100005 ; TAB1 read num ; TAB1 for i = 0 to num exclusive ; TAB2 read a [ i ] ; TAB2 increase sum by a [ i ] ; TAB2 if a [ i ] is greater than max set max to a [ i ] ; TAB1 round = sum / ( num - 1 . 0 ) rounded up ; TAB1 if round is less than max set round to max ; TAB1 print round and a new line ;	int main ( ) { long long round , num , sum = 0 , a [ 100005 ] , max = - 1 ; cin >> num ; for ( int i = 0 ; i < num ; i ++ ) { cin >> a [ i ] ; sum += a [ i ] ; if ( a [ i ] > max ) { max = a [ i ] ; } } round = ceil ( sum / ( num - 1.0 ) ) ; if ( round < max ) round = max ; cout << round << endl ; return 0 ; }
TAB1 declare integers n , d and a ; TAB1 read n and d ; TAB1 create integer s = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 read a ; TAB2 increase s by a ; TAB1 declare integer variable x = d - s ; TAB1 if s + ( n - 1 ) * 10 is greater than d ; TAB2 print " - 1 " ; TAB1 else ; TAB2 print x / 5 ;	int main ( ) { int n , d , a ; cin >> n >> d ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; s += a ; } int x = d - s ; if ( s + ( n - 1 ) * 10 > d ) { cout << " -1 " << endl ; return 0 ; } else { cout << x / 5 << endl ; return 0 ; } return 0 ; }
TAB1 n = int ; TAB1 read n ; TAB1 a = array of n by 5 char ; TAB1 i , j , c = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 5 exclusive read a [ i ] [ j ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 4 exclusive ; TAB3 if a [ i ] [ j ] and a [ i ] [ j + 1 ] are ' O ' ; TAB4 a [ i ] [ j ] = ' + ' ; TAB4 a [ i ] [ j + 1 ] = ' + ' ; TAB4 c = 1 ; TAB4 goto end ; TAB0 end label ; TAB1 if c is 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ; TAB2 goto end1 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 5 exclusive print a [ i ] [ j ] ; TAB2 print a newline ; TAB0 end1 label ;	int main ( ) { int n ; cin >> n ; char a [ n ] [ 5 ] ; int i , j , c = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 5 ; j ++ ) { cin >> a [ i ] [ j ] ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ] [ j ] == ' O ' && a [ i ] [ j + 1 ] == ' O ' ) { a [ i ] [ j ] = ' + ' ; a [ i ] [ j + 1 ] = ' + ' ; c = 1 ; goto end ; } } } end : if ( c == 1 ) cout << " YES " << endl ; else { cout << " NO " << endl ; goto end1 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 5 ; j ++ ) { cout << a [ i ] [ j ] ; } cout << endl ; } end1 : return 0 ; }
TAB1 n is integer ; TAB1 read n ; TAB1 c is an character array with size 1000 by 1000 ; TAB1 let flag be boolean = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 for integer j = 0 to 5 exclusive ; TAB3 read c [ i ] [ j ] ; TAB3 if c [ i ] [ 0 ] = ' O ' & & c [ i ] [ 1 ] = ' O ' & & flag = 0 ; TAB4 set value of flag to 1 ; TAB4 c [ i ] [ 0 ] = ' + ' ; TAB4 c [ i ] [ 1 ] = ' + ' ; TAB3 if c [ i ] [ 3 ] = ' O ' & & c [ i ] [ 4 ] = ' O ' & & flag = 0 ; TAB4 flag = 1 ; TAB4 c [ i ] [ 3 ] = ' + ' ; TAB4 c [ i ] [ 4 ] = ' + ' ; TAB1 print " YES " if flag = 1 , else print " NO " ; print new line ; TAB1 if flag = 1 ; TAB2 for integer i = 0 to n exclusive ; TAB3 for integer j = 0 to 5 exclusive print c [ i ] [ j ] ; TAB3 print ' \ n ' ;	int main ( ) { int n ; cin >> n ; char c [ 1000 ] [ 1000 ] ; bool flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { cin >> c [ i ] [ j ] ; if ( c [ i ] [ 0 ] == ' O ' && c [ i ] [ 1 ] == ' O ' && flag == 0 ) { flag = 1 ; c [ i ] [ 0 ] = ' + ' ; c [ i ] [ 1 ] = ' + ' ; } if ( c [ i ] [ 3 ] == ' O ' && c [ i ] [ 4 ] == ' O ' && flag == 0 ) { flag = 1 ; c [ i ] [ 3 ] = ' + ' ; c [ i ] [ 4 ] = ' + ' ; } } } cout << ( flag == 1 ? " YES " : " NO " ) << endl ; if ( flag == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { cout << c [ i ] [ j ] ; } cout << ' \n ' ; } } return 0 ; }
TAB0 a [ 100010 ] , n be of type long long int ; TAB0 boolean check ( long long int x ) ; TAB1 let long long int tmp = 0 , i ; TAB1 for i = o to n exclusive , tmp + = ( x - a [ i ] ) ; TAB1 return value of ( tmp > = x ) ; TAB0 let long long int binSearch ( long long int low , long long int high ) ; TAB1 while low is less than high ; TAB2 long long int mid is equal to low + ( high - low ) / 2 ; TAB2 if ( check of mid ) ; TAB3 high is equal to mid ; ; TAB2 else ; TAB3 low is equal to mid + 1 ; ; TAB1 return value low ; TAB1 let long long int t is equal to 1 ; ; TAB1 while t value is decremented by 1 ; TAB2 let long long int ans = 0 , i ; TAB2 read n ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 sort ( a , a + n ) ; TAB2 ans is equal to binSearch ( a [ n - 1 ] , 1e12 ) ; TAB2 print ans and newline ;	long long int a [ 100010 ] , n ; bool check ( long long int x ) { long long int tmp = 0 , i ; for ( i = 0 ; i < n ; i ++ ) tmp += ( x - a [ i ] ) ; return ( tmp >= x ) ; } long long int binSearch ( long long int low , long long int high ) { while ( low < high ) { long long int mid = low + ( high - low ) / 2 ; if ( check ( mid ) ) high = mid ; else low = mid + 1 ; } return low ; } int main ( ) { long long int t = 1 ; while ( t -- ) { long long int ans = 0 , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; ans = binSearch ( a [ n - 1 ] , 1e12 ) ; cout << ans << " \n " ; } return 0 ; }
TAB0 create constant integer maxn with maxn = 105 ; TAB1 create integers n , sum with sum = 0 ; TAB1 create character array a with size 12 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 create integers t , d , r , l , with t = 1 , d = 1 , r = 1 , l = 1 ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is ' 1 ' or a [ i ] is ' 2 ' or a [ i ] is ' 3 ' , set t to 0 ; TAB2 if a [ i ] is ' 1 ' or a [ i ] is ' 4 ' or a [ i ] is ' 7 ' or a [ i ] is ' 0 ' , set l to 0 ; TAB2 if a [ i ] is ' 3 ' or a [ i ] is ' 6 ' or a [ i ] is ' 9 ' or a [ i ] is ' 0 ' , set r to 0 ; TAB2 if a [ i ] is ' 7 ' or a [ i ] is ' 0 ' or a [ i ] is ' 9 ' , set d to 0 ; TAB1 if t or l or r or d ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 print " YES " print newline ;	const int maxn = 105 ; int main ( ) { int n , sum = 0 ; char a [ 12 ] ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } int t = 1 , d = 1 , r = 1 , l = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ' 1 ' || a [ i ] == ' 2 ' || a [ i ] == ' 3 ' ) t = 0 ; if ( a [ i ] == ' 1 ' || a [ i ] == ' 4 ' || a [ i ] == ' 7 ' || a [ i ] == ' 0 ' ) l = 0 ; if ( a [ i ] == ' 3 ' || a [ i ] == ' 6 ' || a [ i ] == ' 9 ' || a [ i ] == ' 0 ' ) r = 0 ; if ( a [ i ] == ' 7 ' || a [ i ] == ' 0 ' || a [ i ] == ' 9 ' ) d = 0 ; } if ( t || l || r || d ) cout << " NO " << endl ; else cout << " YES " << endl ; }
TAB1 let n , a , b be long integers ; TAB1 read n , a , b ; TAB1 let bb be a integer with value 0 ; TAB1 let ans be a long integer with value 0 ; TAB1 for ( integer i = 0 to n exclusive ) ; TAB2 let tmp be a integer ; TAB2 read tmp ; TAB2 if ( tmp is equal to 2 and b ) ; TAB3 decrease b by 1 ; TAB2 else if ( tmp is equal to 1 and a ) ; TAB3 decrease a by 1 ; TAB2 else if ( tmp is equal to 1 and b ) ; TAB3 decrease b by 1 , increase bb by 1 ; TAB2 else if ( tmp is equal to 1 and bb ) ; TAB3 decrease bb by 1 ; TAB2 else , do the following ; TAB3 let the value of ans is equal to ans + tmp ; TAB1 print ans and new line ;	int main ( ) { long long n , a , b ; cin >> n >> a >> b ; int bb = 0 ; long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp ; cin >> tmp ; if ( tmp == 2 && b ) b -- ; else if ( tmp == 1 && a ) a -- ; else if ( tmp == 1 && b ) b -- , bb ++ ; else if ( tmp == 1 && bb ) bb -- ; else ans += tmp ; } cout << ans << endl ; }
TAB0 n = integer ; TAB0 s = string ; TAB0 h = 2D array in boolean with 10 rows and 4 columns ; TAB1 Read n and s ; TAB1 for i = 0 to 4 exclusive ; TAB2 set h [ 5 ] [ i ] to true ; TAB2 set h [ 8 ] [ i ] to true ; TAB1 set h [ 2 ] [ 0 ] to true ; TAB1 set h [ 3 ] [ 0 ] to true ; TAB1 set h [ 6 ] [ 0 ] to true ; TAB1 set h [ 9 ] [ 0 ] to true ; TAB1 set h [ 1 ] [ 1 ] to true ; TAB1 set h [ 4 ] [ 1 ] to true ; TAB1 set h [ 7 ] [ 1 ] to true ; TAB1 set h [ 2 ] [ 1 ] to true ; TAB1 set h [ 4 ] [ 2 ] to true ; TAB1 set h [ 6 ] [ 2 ] to true ; TAB1 set h [ 7 ] [ 2 ] to true ; TAB1 set h [ 9 ] [ 2 ] to true ; TAB1 set h [ 0 ] [ 2 ] to true ; TAB1 set h [ 1 ] [ 3 ] to true ; TAB1 set h [ 2 ] [ 3 ] to true ; TAB1 set h [ 3 ] [ 3 ] to true ; TAB1 set h [ 4 ] [ 3 ] to true ; TAB1 set h [ 6 ] [ 3 ] to true ; TAB1 for j = 0 to 4 exclusive ; TAB2 done = boolean , set to true ; TAB2 for i = 0 to n exclusive ; TAB3 if h [ s [ i ] - ' 0 ' ] [ j ] is false , then set done to false ; TAB2 if done is true ; TAB3 print NO and a new line ; TAB1 print YES and a new line ;	int n ; string s ; bool h [ 10 ] [ 4 ] ; int main ( ) { cin >> n >> s ; for ( int i = 0 ; i < 4 ; i ++ ) { h [ 5 ] [ i ] = true ; h [ 8 ] [ i ] = true ; } h [ 2 ] [ 0 ] = true ; h [ 3 ] [ 0 ] = true ; h [ 6 ] [ 0 ] = true ; h [ 9 ] [ 0 ] = true ; h [ 1 ] [ 1 ] = true ; h [ 4 ] [ 1 ] = true ; h [ 7 ] [ 1 ] = true ; h [ 2 ] [ 1 ] = true ; h [ 4 ] [ 2 ] = true ; h [ 6 ] [ 2 ] = true ; h [ 7 ] [ 2 ] = true ; h [ 9 ] [ 2 ] = true ; h [ 0 ] [ 2 ] = true ; h [ 1 ] [ 3 ] = true ; h [ 2 ] [ 3 ] = true ; h [ 3 ] [ 3 ] = true ; h [ 4 ] [ 3 ] = true ; h [ 6 ] [ 3 ] = true ; for ( int j = 0 ; j < 4 ; j ++ ) { bool done = true ; for ( int i = 0 ; i < n ; i ++ ) if ( ! h [ s [ i ] - ' 0 ' ] [ j ] ) done = false ; if ( done ) { cout << " NO\n " ; return 0 ; } } cout << " YES\n " ; return 0 ; }
TAB1 create long integers n , m , x , y , z , i , with z = 9 , i = 0 ; TAB1 read x read y read m ; TAB1 while i is less than or equal to z ; TAB2 if ( x * 10 + i ) % y is 0 ; TAB3 set z to 10 ; TAB3 break loop ; TAB2 increment i ; TAB1 decrement m ; TAB1 if z is 10 ; TAB2 print x * 10 + i ; TAB2 while decrement m is true , print " 0 " ; TAB1 else ; TAB2 print " - 1 " ; TAB1 print newline ;	int main ( ) { long int n , m , x , y , z = 9 , i = 0 ; cin >> x >> y >> m ; while ( i <= z ) { if ( ( x * 10 + i ) % y == 0 ) { z = 10 ; break ; } i ++ ; } m -- ; if ( z == 10 ) { cout << x * 10 + i ; while ( m -- ) cout << " 0 " ; } else { cout << " -1 " ; } cout << endl ; return 0 ; }
TAB1 n , d = integer ; TAB1 read n and d ; TAB1 arr = array of n integers ; TAB1 set sum to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 sum = sum + arr [ i ] ; TAB1 set T to sum + ( n - 1 ) * 10 ; TAB1 if T > d ; TAB2 print - 1 ; TAB1 d = d - sum ; TAB1 d = d / 5 ; TAB1 print d ;	int main ( ) { int n , d ; cin >> n >> d ; int arr [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; sum += arr [ i ] ; } int T = sum + ( n - 1 ) * 10 ; if ( T > d ) { cout << - 1 << endl ; return 0 ; } d = d - sum ; d = d / 5 ; cout << d << endl ; return 0 ; }
TAB1 declare integers n and d and an array of integers arr with size 105 ; TAB1 read n and d ; TAB1 read n elements into arr ; TAB1 create integer sum = 0 ; TAB1 sum n elements from arr and put them into variable sum ; TAB1 create integer x = sum + ( n - 1 ) * 10 ; TAB1 if x < = d ; TAB2 print ( d - sum ) / 5 ; TAB1 else ; TAB2 print - 1 ;	int main ( ) { int n , d , arr [ 105 ] ; cin >> n >> d ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int x = sum + ( n - 1 ) * 10 ; if ( x <= d ) cout << ( d - sum ) / 5 << endl ; else cout << - 1 << endl ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 arr = long long array of size n ; TAB1 sum , n = long long with sum = 0 and x = INT_MIN ; TAB1 for i = 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 increase sum by arr [ i ] ; TAB2 set x to the max of x and arr [ i ] ; TAB1 set x to the max of x and ( sum + n - 2 ) / ( n - 1 ) ; TAB1 print x ;	int main ( ) { int n ; cin >> n ; long long arr [ n ] ; long long sum = 0 , x = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; sum += arr [ i ] ; x = max ( x , arr [ i ] ) ; } x = max ( x , ( sum + n - 2 ) / ( n - 1 ) ) ; cout << x << endl ; return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 let count5 be a integer with value 0 ; TAB1 let count0 be a integer with value 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 let temp be a integer with value 0 ; TAB2 read temp ; TAB2 if ( temp is equal to 0 ) ; TAB3 increase count0 by 1 ; TAB2 else do the following ; TAB3 increase count5 by 1 ; TAB1 let a be an integer with value count5 / 9 ; TAB1 let b be an integer with value count0 ; TAB1 if ( b is equal to 0 ) ; TAB2 print - 1 and newline ; TAB1 else if ( a is equal to 0 ) ; TAB2 print 0 and newline ; TAB1 else do the following ; TAB2 for ( integer i = 0 to a exclusive ) , print 555555555 ; TAB2 for ( integer i = 0 to b exclusive ) , print 0 ; TAB2 print newline ;	int main ( ) { int n ; cin >> n ; int count5 = 0 ; int count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = 0 ; cin >> temp ; if ( temp == 0 ) count0 ++ ; else count5 ++ ; } int a = count5 / 9 ; int b = count0 ; if ( b == 0 ) { cout << - 1 << endl ; } else if ( a == 0 ) { cout << 0 << endl ; } else { for ( int i = 0 ; i < a ; i ++ ) cout << 555555555 ; for ( int i = 0 ; i < b ; i ++ ) cout << 0 ; cout << endl ; } return 0 ; }
TAB1 n , i , j , c , flg = integers set c , flg = 0 ; TAB1 read n ; TAB1 s = array of strings of size n ; TAB1 for i = 0 to n exclusive ; TAB2 read into array s ; TAB2 if s [ i ] [ 0 ] = O and s [ i ] [ 1 ] = O ; TAB3 if c = 0 ; TAB4 s [ i ] [ 0 ] = + ; TAB4 s [ i ] [ 1 ] = + ; TAB4 flg = 1 ; TAB3 increment c ; TAB2 else if s [ i ] [ 3 ] = O and s [ i ] [ 4 ] = O ; TAB3 if c = 0 ; TAB4 s [ i ] [ 3 ] = + ; TAB4 s [ i ] [ 4 ] = + ; TAB4 flg = 1 ; TAB3 increment c ; TAB1 if lfg = 1 ; TAB2 print YES ; TAB2 for i = 0 to n exclusive print s [ i ] ; TAB1 else ; TAB2 print NO ;	int main ( ) { int n , i , j , c = 0 , flg = 0 ; cin >> n ; string s [ n ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> s [ i ] ; if ( s [ i ] [ 0 ] == ' O ' && s [ i ] [ 1 ] == ' O ' ) { if ( c == 0 ) { s [ i ] [ 0 ] = ' + ' ; s [ i ] [ 1 ] = ' + ' ; flg = 1 ; } c ++ ; } else if ( s [ i ] [ 3 ] == ' O ' && s [ i ] [ 4 ] == ' O ' ) { if ( c == 0 ) { s [ i ] [ 3 ] = ' + ' ; s [ i ] [ 4 ] = ' + ' ; flg = 1 ; } c ++ ; } } if ( flg == 1 ) { cout << " YES " << endl ; for ( i = 0 ; i < n ; i ++ ) { cout << s [ i ] << endl ; } } else cout << " NO " << endl ; return 0 ; }
TAB0 declare integer variable ans = INT_MAX ; TAB1 declare integer variables hy , ay , dy , hm , am , dm , h , a , d , xh , xa and xd ; TAB1 read hy , ay , dy , hm , am , dm , h , a and d ; TAB1 for xh = 0 to 1000 inclusive ; TAB2 for xa = 0 to 200 inclusive ; TAB3 for xd = 0 to 100 inclusive ; TAB4 create integers ll = 1 and hh = 1000 ; TAB4 while ll < = hh ; TAB5 declare integer m = ( ll + hh ) / 2 ; TAB5 set integer l to ( hy + xh ) - m * max of 0 and am - ( dy + xd ) ; TAB5 set integer r to hm - m * max of 0 and ay + xa - dm ; TAB5 create integer val = h * xh + xa * a + xd * d ; TAB5 if l > 0 and r < = 0 ; TAB6 set ans to min of ans and h * xh + xa * a + xd * d ; TAB6 stop the loop ; TAB5 else if l < = 0 and r < = 0 ; TAB6 hh = m - 1 ; TAB5 else if l < = 0 and r is greater than 0 ; TAB6 break the loop ; TAB5 else if l > 0 and r is greater than 0 ; TAB6 assign value of m + 1 to ll ; TAB1 print ans ;	int ans = INT_MAX ; int main ( ) { int hy , ay , dy , hm , am , dm , h , a , d , xh , xa , xd ; cin >> hy >> ay >> dy >> hm >> am >> dm >> h >> a >> d ; for ( xh = 0 ; xh <= 1000 ; xh ++ ) { for ( xa = 0 ; xa <= 200 ; xa ++ ) { for ( xd = 0 ; xd <= 100 ; xd ++ ) { int ll = 1 , hh = 1000 ; while ( ll <= hh ) { int m = ( ll + hh ) / 2 ; int l = ( hy + xh ) - m * max ( 0 , am - ( dy + xd ) ) ; int r = hm - m * max ( 0 , ay + xa - dm ) ; int val = h * xh + xa * a + xd * d ; if ( l > 0 && r <= 0 ) { ans = min ( ans , h * xh + xa * a + xd * d ) ; break ; } else if ( l <= 0 && r <= 0 ) hh = m - 1 ; else if ( l <= 0 && r > 0 ) break ; else if ( l > 0 && r > 0 ) ll = m + 1 ; } } } } cout << ans << endl ; }
TAB0 create vector integer digit ; TAB0 create vector integer iterator it ; TAB1 create unsigned long longs a , b , n ; TAB1 read a read b read n ; TAB1 add element a to end of digit ; TAB1 for i = 1 to n inclusive ; TAB2 create integer flag with flag = 0 ; TAB2 for j = 0 to 9 inclusive ; TAB3 if ( ( a * 10 ) + j ) % b is 0 ; TAB4 add element j to end of digit ; TAB4 set a to ( ( a * 10 ) + j ) % b ; TAB4 set flag to 1 ; TAB4 break loop ; TAB2 if flag is 0 ; TAB3 print " - 1 " print newline ; TAB1 for it = beginning of digit to it is not end of digit , print value of it ; TAB1 print newline ;	vector < int > digit ; vector < int > :: iterator it ; int main ( ) { unsigned long long a , b , n ; cin >> a >> b >> n ; digit . push_back ( a ) ; for ( unsigned long long i = 1 ; i <= n ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j <= 9 ; j ++ ) { if ( ( ( a * 10 ) + j ) % b == 0 ) { digit . push_back ( j ) ; a = ( ( a * 10 ) + j ) % b ; flag = 1 ; break ; } } if ( flag == 0 ) { cout << " -1 " << endl ; return 0 ; } } for ( it = digit . begin ( ) ; it != digit . end ( ) ; it ++ ) cout << ( * it ) ; cout << endl ; }
TAB0 assign value 100005 to constant integer MAX ; TAB0 arr is an array of integers of size MAX ; TAB0 long long function divc with long long arguments a and b ; TAB1 if a % b = 0 return a / b ; TAB1 return ( a / b + 1 ) ; TAB1 let n be integer ; TAB1 read n ; TAB1 let sum and mx be long longs , with sum = 0 and mx = - 1 ; TAB1 for i = 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 increase sum by arr [ i ] ; TAB2 set mx to max of mx and arr [ i ] ; TAB1 long long ans with value divc ( sum , n - 1 ) ; TAB1 set value of ans to max of ans and mx ; TAB1 print ans and " \ n " ;	const int MAX = 100005 ; int arr [ MAX ] ; long long divc ( long long a , long long b ) { if ( a % b == 0 ) return a / b ; return ( a / b + 1 ) ; } int main ( ) { int n ; cin >> n ; long long sum = 0 , mx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; sum += arr [ i ] ; mx = max ( mx , ( long long ) arr [ i ] ) ; } long long ans = divc ( sum , ( long long ) ( n - 1 ) ) ; ans = max ( ans , mx ) ; cout << ans << " \n " ; }
TAB1 declare integer variables n , a , i , j , num5 , num0 and r ; TAB1 while reading n in a loop ; TAB2 set value of num5 to 0 ; TAB2 set value of num0 to 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read a ; TAB3 if a = 5 ; TAB4 increase num5 by one ; TAB3 else if a = 0 ; TAB4 increase num0 by one ; TAB2 r = num5 / 9 ; TAB2 if num0 is 0 ; TAB3 print " - 1 " ; TAB2 else ; TAB3 if r & & num0 are both not 0 ; TAB4 for i = 0 to r * 9 exclusive print " 5 " ; TAB4 for i = 0 to num0 exclusive print " 0 " ; TAB3 else ; TAB4 print " 0 " ; TAB3 print " " ;	int main ( ) { int n , a , i , j , num5 , num0 , r ; while ( cin >> n ) { num5 = 0 ; num0 = 0 ; for ( i = 0 ; i < n ; i ++ ) { cin >> a ; if ( a == 5 ) { num5 ++ ; } else if ( a == 0 ) { num0 ++ ; } } r = num5 / 9 ; if ( ! num0 ) { cout << " -1 " << endl ; } else { if ( r && num0 ) { for ( i = 0 ; i < r * 9 ; i ++ ) { cout << " 5 " ; } for ( i = 0 ; i < num0 ; i ++ ) { cout << " 0 " ; } } else { cout << " 0 " ; } cout << "  " << endl ; } } return 0 ; }
TAB1 declare integer variable n ; TAB1 read n ; TAB1 declare string variable s ; TAB1 read s ; TAB1 declare boolean c1 = false ; TAB1 declare boolean c3 = false ; TAB1 declare boolean l1 = false ; TAB1 declare boolean l3 = false ; TAB1 declare boolean t0 = false ; TAB1 for integer i = 0 to n exclusive ; TAB2 set l1 to true if s [ i ] - ' 0 ' = 1 | | s [ i ] - ' 0 ' = 2 | | s [ i ] - ' 0 ' = 3 ; TAB2 set l3 to true if s [ i ] - ' 0 ' = 7 | | s [ i ] - ' 0 ' = 9 ; TAB2 set c1 to true if s [ i ] - ' 0 ' = 1 | | s [ i ] - ' 0 ' = 4 | | s [ i ] - ' 0 ' = 7 ; TAB2 set c3 to true if s [ i ] - ' 0 ' = 3 | | s [ i ] - ' 0 ' = 6 | | s [ i ] - ' 0 ' = 9 ; TAB2 set t0 to true if s [ i ] - ' 0 ' = 0 ; TAB1 if l1 = true & & l3 = true & & c1 = true & & c3 = true ; TAB2 print " YES " ; TAB1 if t0 = true & & l1 = true ; TAB2 print " YES " ; TAB1 print " NO " ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; bool c1 = false ; bool c3 = false ; bool l1 = false ; bool l3 = false ; bool t0 = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - ' 0 ' == 1 || s [ i ] - ' 0 ' == 2 || s [ i ] - ' 0 ' == 3 ) l1 = true ; if ( s [ i ] - ' 0 ' == 7 || s [ i ] - ' 0 ' == 9 ) l3 = true ; if ( s [ i ] - ' 0 ' == 1 || s [ i ] - ' 0 ' == 4 || s [ i ] - ' 0 ' == 7 ) c1 = true ; if ( s [ i ] - ' 0 ' == 3 || s [ i ] - ' 0 ' == 6 || s [ i ] - ' 0 ' == 9 ) c3 = true ; if ( s [ i ] - ' 0 ' == 0 ) t0 = true ; } if ( l1 == true && l3 == true && c1 == true && c3 == true ) { cout << " YES " << endl ; return 0 ; } if ( t0 == true && l1 == true ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; }
TAB1 declare long integer variables n , d and i ; TAB1 read n and d ; TAB1 create long integer array arr with n elements ; TAB1 read input into arr n times ; TAB1 declare long integer o = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; TAB1 declare integer variables initial_sum and flag = 0 ; TAB1 sum all elements of arr , add it to initial_sum and put it to y ; TAB1 create long integers p and count = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if p + arr [ i ] < = d ; TAB3 if i = n - 1 ; TAB4 flag = 1 ; TAB4 set value of p to p + arr [ i ] ; TAB3 else ; TAB4 set value of p to p + arr [ i ] ; TAB2 if p < = d - 5 ; TAB3 set value of p to p + 5 ; TAB3 increase count ; TAB2 else ; TAB3 stop the loop ; TAB2 if p < = d - 5 ; TAB3 set value of p to p + 5 ; TAB3 increase count by one ; TAB2 else ; TAB3 break the loop ; TAB1 if flag = 1 ; TAB2 if p > = d - 5 ; TAB3 print count ; TAB2 else ; TAB3 while p < = d - 5 ; TAB4 increment count ; TAB4 set value of p to p + 5 ; TAB3 print count ; TAB1 else ; TAB2 print " - 1 " ;	int main ( ) { long int n , d , i ; cin >> n >> d ; long int arr [ n ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } long int o = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int initial_sum = 0 , flag = 0 ; long int y = accumulate ( arr , arr + o , initial_sum ) ; long int p = 0 , count = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( p + arr [ i ] <= d ) { if ( i == n - 1 ) { flag = 1 ; p = p + arr [ i ] ; } else { p = p + arr [ i ] ; } } if ( p <= d - 5 ) { p = p + 5 ; count ++ ; } else { break ; } if ( p <= d - 5 ) { p = p + 5 ; count ++ ; } else { break ; } } if ( flag == 1 ) { if ( p >= d - 5 ) { cout << count << endl ; } else { while ( p <= d - 5 ) { count ++ ; p = p + 5 ; } cout << count << endl ; } } else { cout << " -1 " << endl ; } return 0 ; }
TAB1 n , m , k = long long ; TAB1 while reading n then m then k ; TAB2 ans = long long with ans = 0 ; TAB2 if k is greater than n + m - 2 ; TAB3 set ans to - 1 ; TAB2 else ; TAB3 Max = long long with Max = max of n - 1 and m - 1 ; TAB3 Min = long long with Min = min of n - 1 and m - 1 ; TAB3 if k is greater than Max ; TAB4 yu = long long with yu = k - Max ; TAB4 set ans to ( Min + 1 ) / ( yu + 1 ) ; TAB3 else ; TAB4 a = long long with a = ( n / ( k + 1 ) ) * m ; TAB4 b = long long with b = ( m / ( k + 1 ) ) * n ; TAB4 set ans to max of a and b ; TAB2 print ans ;	int main ( ) { long long n , m , k ; while ( cin >> n >> m >> k ) { long long ans = 0 ; if ( k > n + m - 2 ) ans = - 1 ; else { long long Max = max ( n - 1 , m - 1 ) ; long long Min = min ( n - 1 , m - 1 ) ; if ( k > Max ) { long long yu = k - Max ; ans = ( Min + 1 ) / ( yu + 1 ) ; } else { long long a = ( n / ( k + 1 ) ) * m ; long long b = ( m / ( k + 1 ) ) * n ; ans = max ( a , b ) ; } } cout << ans << endl ; } return 0 ; }
TAB0 create long long c , n , a , b , i , x , y and z ; TAB1 read a , b , c ; TAB1 while decremen a ; TAB2 read x ; TAB2 if x equal to 1 ; TAB3 if b = true ; TAB4 decrement b ; TAB3 other if c is true ; TAB4 decrement c and increment y ; TAB3 else if y is true ; TAB4 decrement y ; TAB3 else ; TAB4 decrement z ; TAB2 if x = 2 ; TAB3 if c is true ; TAB4 decrement c ; TAB3 otherwise ; TAB4 set z = z + 2 ; TAB1 print z ; TAB1 ; ;	long long c , n , a , b , i , x , y , z ; int main ( ) { cin >> a >> b >> c ; while ( a -- ) { cin >> x ; if ( x == 1 ) { if ( b ) b -- ; else if ( c ) { c -- , y ++ ; } else if ( y ) y -- ; else z ++ ; } if ( x == 2 ) { if ( c ) c -- ; else z += 2 ; } } cout << z << endl ; ; return 0 ; }
TAB0 const int64_t infint64_t = 9223372036854775807LL ; TAB0 define function solve ; TAB1 declare int64_t variables n , a , b ; TAB1 read n , a and b ; TAB1 declare int64_t variable c = 0 ; TAB1 declare int64_t variable denied = 0 ; TAB1 for 64_t = 0 to n exclusive ; TAB2 declare int64_t variable t ; TAB2 read t ; TAB2 if t = 1 ; TAB3 if a is greater than 0 ; TAB4 decrement a ; TAB3 else if b is greater than 0 ; TAB4 decrement b ; TAB4 increment c ; TAB3 else if c is greater than 0 ; TAB4 decrease c ; TAB3 else ; TAB4 increment denied ; TAB2 else ; TAB3 if b is greater than 0 ; TAB4 decrease b ; TAB3 else ; TAB4 increase denied by 2 ; TAB1 print denied ; TAB1 call function solve ;	const int64_t infint64_t = 9223372036854775807LL ; void solve ( ) { int64_t n , a , b ; cin >> n >> a >> b ; int64_t c = 0 ; int64_t denied = 0 ; for ( int64_t i = 0 ; i < n ; i ++ ) { int64_t t ; cin >> t ; if ( t == 1 ) { if ( a > 0 ) { a -- ; } else if ( b > 0 ) { b -- ; c ++ ; } else if ( c > 0 ) { c -- ; } else denied ++ ; } else { if ( b > 0 ) { b -- ; } else denied += 2 ; } } cout << denied << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create string y with y = " NO " ; TAB1 create string s ; TAB1 for i = 0 to n exclusive ; TAB2 create string s1 ; TAB2 read s1 ; TAB2 for j = 0 to j is less than 5 and y is " NO " , increment j ; TAB3 if s1 [ j ] is ' O ' and s1 [ j + 1 ] is ' O ' ; TAB4 set y to " YES " ; TAB4 set s1 [ j ] to ' + ' ; TAB4 set s1 [ j + 1 ] to ' + ' ; TAB2 set s to s + s1 + ' \ n ' ; TAB1 if y is " YES " ; TAB2 print y print newline print s ; TAB1 else ; TAB2 print y print newline ;	int main ( ) { int n ; cin >> n ; string y = " NO " ; string s ; for ( int i = 0 ; i < n ; i ++ ) { string s1 ; cin >> s1 ; for ( int j = 0 ; j < 5 && y == " NO " ; j ++ ) { if ( s1 [ j ] == ' O ' && s1 [ j + 1 ] == ' O ' ) { y = " YES " ; s1 [ j ] = ' + ' ; s1 [ j + 1 ] = ' + ' ; } } s = s + s1 + ' \n ' ; } if ( y == " YES " ) cout << y << endl << s ; else cout << y << endl ; }
TAB1 a , b , n = integer ; TAB1 read a , b , n ; TAB1 let d = - 1 ; TAB1 for i = 0 to 10 exclusive ; TAB2 if ( a * 10 + 1 ) remainder b = 0 ; TAB3 d = i ; TAB3 exit for ; TAB1 if d = - 1 ; TAB2 print - 1 ; TAB1 else ; TAB2 print a and d ; TAB2 for i = 0 to n - 1 exclusive print 0 ; TAB2 print newline ;	int main ( ) { int a , b , n ; cin >> a >> b >> n ; int d = - 1 ; for ( int i = 0 ; i < 10 ; ++ i ) { if ( ( a * 10 + i ) % b == 0 ) { d = i ; break ; } } if ( d == - 1 ) { cout << - 1 << endl ; } else { cout << a << d ; for ( int i = 0 ; i < n - 1 ; ++ i ) { cout << 0 ; } cout << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create integer array arr with size n , create integers number_of_5 , number_of_0 , with number_of_5 = 0 , number_of_0 = 0 ; TAB1 end statement ; TAB1 for i = 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 if arr [ i ] is 5 ; TAB3 increment number_of_5 ; TAB2 else ; TAB3 increment number_of_0 ; TAB1 if number_of_0 is 0 ; TAB2 print " - 1 \ n " ; TAB1 else ; TAB2 set number_of_5 to round up ( number_of_5 / 9 ) ; TAB2 create string answer with answer = " " ; TAB2 for i = 0 to number_of_5 exclusive , increment answer by " 555555555 " ; TAB2 for i = 1 to number_of_0 inclusive ; TAB3 if length of answer is 0 ; TAB4 increment answer by " 0 " ; TAB4 break loop ; TAB3 else ; TAB4 increment answer by " 0 " ; TAB2 print answer print newline ;	int main ( ) { int n ; cin >> n ; int arr [ n ] , number_of_5 = 0 , number_of_0 = 0 ; ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; if ( arr [ i ] == 5 ) { number_of_5 ++ ; } else { number_of_0 ++ ; } } if ( number_of_0 == 0 ) { cout << " -1\n " ; return 0 ; } else { number_of_5 = floor ( number_of_5 / 9 ) ; string answer = "  " ; for ( int i = 0 ; i < ( number_of_5 ) ; i ++ ) { answer += " 555555555 " ; } for ( int i = 1 ; i <= number_of_0 ; i ++ ) { if ( answer . length ( ) == 0 ) { answer += " 0 " ; break ; } else { answer += " 0 " ; } } cout << answer << endl ; } return 0 ; }
TAB1 declare integers n and d ; TAB1 create integer total = 0 ; TAB1 create integer ans = 0 ; TAB1 read n and d ; TAB1 while n > 0 , decrement it and continue the loop ; TAB2 create integer tmp ; TAB2 read tmp ; TAB2 increase total by tmp ; TAB2 increase total by 10 ; TAB2 increase ans by 2 ; TAB1 decrease total by 10 ; TAB1 decrease ans by 2 ; TAB1 if total is greater than d ; TAB2 assign value of - 1 to ans ; TAB1 else ; TAB2 increase ans by ( d - total ) / 5 ; TAB1 print ans ;	int main ( ) { int n , d ; int total = 0 ; int ans = 0 ; cin >> n >> d ; while ( n -- ) { int tmp ; cin >> tmp ; total += tmp ; total += 10 ; ans += 2 ; } total -= 10 ; ans -= 2 ; if ( total > d ) { ans = - 1 ; } else { ans += ( d - total ) / 5 ; } cout << ans << endl ; return 0 ; }
TAB1 declare integer variables n and m ; TAB1 read n and m ; TAB1 declare integer vector v ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare integer x ; TAB2 read x ; TAB2 add x into v ; TAB1 declare integer sum = 0 ; TAB1 sum = sum of elements of v ; TAB1 declare integer variable a = sum + ( ( n - 1 ) * 10 ) ; TAB1 if a < = m ; TAB2 declare integer variable b = m - a ; TAB2 print ( ( n - 1 ) * 2 ) + ( m - a ) / 5 ; TAB1 else ; TAB2 print " - 1 " ;	int main ( ) { int n , m ; cin >> n >> m ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; v . push_back ( x ) ; } int sum = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum = sum + v [ i ] ; } int a = sum + ( ( n - 1 ) * 10 ) ; if ( a <= m ) { int b = m - a ; cout << ( ( n - 1 ) * 2 ) + ( m - a ) / 5 << endl ; } else cout << " -1 " << endl ; return 0 ; }
TAB1 declare long long integer variables n , i , sum and a , where sum and a = 0 ; TAB1 create long long integer array ar with 100000 elements ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read ar [ i ] ; TAB2 increase sum by ar [ i ] ; TAB2 set value of a to max of a and ar [ i ] ; TAB1 decrease n by one ; TAB1 print max of a and sum / n rounded up ;	int main ( ) { long long int n , i , sum = 0 , a = 0 ; long long int ar [ 100000 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> ar [ i ] ; sum += ar [ i ] ; a = max ( a , ar [ i ] ) ; } n -- ; cout << max ( a , ( long long int ) ceil ( ( double ) sum / ( double ) n ) ) << endl ; return 0 ; }
TAB0 create integers n , d , sum , ans ; TAB1 read n read d ; TAB1 for i = 0 to n exclusive ; TAB2 create integer x ; TAB2 read x ; TAB2 increment sum by x ; TAB1 increment sum by ( n - 1 ) * 10 ; TAB1 if sum is greater than d ; TAB2 print - 1 print newline ; TAB1 else ; TAB2 increment ans by ( n - 1 ) * 2 ; TAB1 if ( d - sum ) / 5 is greater than or equal to 1 , increment ans by ( d - sum ) / 5 ; TAB1 print ans print newline ;	int n , d , sum , ans ; int main ( ) { cin >> n >> d ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; sum += x ; } sum += ( n - 1 ) * 10 ; if ( sum > d ) { cout << - 1 << endl ; return 0 ; } else { ans += ( n - 1 ) * 2 ; } if ( ( d - sum ) / 5 >= 1 ) ans += ( d - sum ) / 5 ; cout << ans << endl ; return 0 ; }
TAB0 create character array a with 20 elements ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 read a ; TAB1 declare integer x = length of a ; TAB1 declare integers temp1 , temp2 , temp3 and temp4 = 1 ; TAB1 for i = 0 to x exclusive ; TAB2 if a [ i ] - 48 > = 1 & & a [ i ] - 48 < = 3 , set temp1 to 0 ; TAB2 if a [ i ] - 48 = 7 | | a [ i ] - 48 = 9 | | a [ i ] - 48 = 0 , set temp2 to 0 ; TAB2 if a [ i ] - 48 = 1 | | a [ i ] - 48 = 4 | | a [ i ] - 48 = 7 | | a [ i ] - 48 = 0 , set temp3 to 0 ; TAB2 if a [ i ] - 48 = 3 | | a [ i ] - 48 = 6 | | a [ i ] - 48 = 9 | | a [ i ] - 48 = 0 , set temp4 to 0 ; TAB1 if temp1 = 0 & & temp2 = 0 & & temp3 = 0 & & temp4 = 0 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	char a [ 20 ] ; int main ( ) { int n ; cin >> n ; cin >> a ; int x = strlen ( a ) ; int temp1 = 1 , temp2 = 1 , temp3 = 1 , temp4 = 1 ; for ( int i = 0 ; i < x ; i ++ ) { if ( a [ i ] - 48 >= 1 && a [ i ] - 48 <= 3 ) { temp1 = 0 ; } if ( a [ i ] - 48 == 7 || a [ i ] - 48 == 9 || a [ i ] - 48 == 0 ) { temp2 = 0 ; } if ( a [ i ] - 48 == 1 || a [ i ] - 48 == 4 || a [ i ] - 48 == 7 || a [ i ] - 48 == 0 ) { temp3 = 0 ; } if ( a [ i ] - 48 == 3 || a [ i ] - 48 == 6 || a [ i ] - 48 == 9 || a [ i ] - 48 == 0 ) { temp4 = 0 ; } } if ( temp1 == 0 && temp2 == 0 && temp3 == 0 && temp4 == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB1 declare integer variables a , b , n , k and i where k = 0 ; TAB1 read a , b and n ; TAB1 create string s of length n - 1 , filled with ' 0 ' ; TAB1 for i = 0 to 10 exclusive ; TAB2 if ( a * 10 + i ) % b = 0 ; TAB3 assign value of 1 to k ; TAB3 stop the loop ; TAB1 if k ! = 1 ; TAB2 print - 1 and a new line ; TAB1 else ; TAB2 print a * 10 + i ; TAB2 print s and a new line ;	int main ( ) { int a , b , n , k = 0 , i ; cin >> a >> b >> n ; string s ( n - 1 , ' 0 ' ) ; for ( i = 0 ; i < 10 ; ++ i ) { if ( ( a * 10 + i ) % b == 0 ) { k = 1 ; break ; } } if ( k != 1 ) { cout << - 1 << endl ; return 0 ; } else { cout << a * 10 + i ; cout << s << endl ; } return 0 ; }
TAB0 let pal be an array of characters of size 1100 ; TAB0 declare array of integers qtd with size 1100 ; TAB0 declare array of integers d with size 1100 ; TAB0 primo is a boolean function with integer argument n ; TAB1 return 0 if n = 1 ; TAB1 for i = 2 while i squared < = n ; TAB2 return 0 if n % i = 0 ; TAB1 return 1 ; TAB0 res = array of characters of length 1100 ; TAB1 declare integer called i ; TAB1 declare string called a ; TAB1 read a ; TAB1 declare integer variable called n = length of s ; TAB1 for i = 0 to length of a exclusive increment qtd [ a [ i ] ] ; TAB1 declare integer called dois = 0 ; TAB1 for i = 2 to length of a casted to integer inclusive ; TAB2 if primo ( i ) & & i * 2 is greater than n ; TAB3 d [ i ] = 0 ; TAB2 else ; TAB3 d [ i ] = 1 ; TAB3 increase dois by one ; TAB1 assign value 0 to character l ; TAB1 for i = ' a ' to ' z ' inclusive ; TAB2 if qtd [ i ] > = dois ; TAB3 set l to i ; TAB3 decrease qtd [ i ] by dois ; TAB3 break the loop ; TAB1 declare integer called j = ' a ' ; TAB1 if l ! = 0 ; TAB2 print " YES " and a new line ; TAB2 for i = 1 to n inclusive ; TAB3 if d [ i ] = 1 ; TAB4 print l ; TAB3 else ; TAB4 increment j while qtd [ j ] = 0 ; TAB4 decrease qtd [ j ] by one ; TAB4 print j casted to char ; TAB2 print new line ; TAB1 else ; TAB2 print " NO " and a new line ;	char pal [ 1100 ] ; int qtd [ 1100 ] ; bool d [ 1100 ] ; bool primo ( int n ) { if ( n == 1 ) return 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; } char res [ 1100 ] ; int main ( ) { int i ; string a ; cin >> a ; int n = ( int ) a . size ( ) ; for ( i = 0 ; i < ( int ) a . size ( ) ; i ++ ) { qtd [ ( int ) a [ i ] ] ++ ; } int dois = 0 ; for ( i = 2 ; i <= ( int ) a . size ( ) ; i ++ ) { if ( primo ( i ) && i * 2 > n ) { d [ i ] = 0 ; } else { d [ i ] = 1 ; dois ++ ; } } char l = 0 ; for ( i = ' a ' ; i <= ' z ' ; i ++ ) { if ( qtd [ i ] >= dois ) { l = i ; qtd [ i ] -= dois ; break ; } } int j = ' a ' ; if ( l != 0 ) { cout << " YES " << endl ; for ( i = 1 ; i <= n ; i ++ ) { if ( d [ i ] == 1 ) { cout << l ; } else { while ( qtd [ j ] == 0 ) { j ++ ; } qtd [ j ] -- ; cout << ( char ) j ; } } cout << endl ; } else { cout << " NO " << endl ; } }
TAB1 create clock_ts t1 , t2 ; TAB1 set t1 to processor time ; TAB1 create integers d , time ; TAB1 read d read time ; TAB1 create integer sum with sum = 0 ; TAB1 for i = 0 to d exclusive ; TAB2 create integer x ; TAB2 read x ; TAB2 increment sum by x ; TAB1 create integer rem with rem = time - sum ; TAB1 create integer rest with rest = ( d - 1 ) * 10 ; TAB1 if rest is greater than rem ; TAB2 print " - 1 " ; TAB3 print " \ n " ; TAB1 else ; TAB2 print ( rem - rest ) / 5 + rest / 5 print " \ n " ; TAB1 set t2 to processor time ; TAB1 create float diff with diff = float casted t2 - float casted t1 ; TAB1 create float execution_time with execution_time = diff / CLOCKS_PER_SEC ;	int main ( ) { clock_t t1 , t2 ; t1 = clock ( ) ; int d , time ; cin >> d >> time ; int sum = 0 ; for ( int i = 0 ; i < d ; i ++ ) { int x ; cin >> x ; sum += x ; } int rem = time - sum ; int rest = ( d - 1 ) * 10 ; if ( rest > rem ) { cout << " -1 " << " \n " ; } else { cout << ( rem - rest ) / 5 + rest / 5 << " \n " ; } t2 = clock ( ) ; float diff = ( float ) t2 - ( float ) t1 ; float execution_time = diff / CLOCKS_PER_SEC ; }
TAB1 n , a , b , sum , ans and s are integers where sum and s = 0 ; TAB1 read n , a and b ; TAB1 for integer i = 0 to n exclusive ; TAB2 read ans ; TAB2 if ans = 1 ; TAB3 if a is greater than 0 ; TAB4 decrease a ; TAB3 else if b is greater than 0 ; TAB4 decrement b ; TAB4 increase s ; TAB3 else if s ! = 0 ; TAB4 decrease s by one ; TAB3 else ; TAB4 increase sum by one ; TAB2 else ; TAB3 if b is greater than 0 ; TAB4 decrement b ; TAB3 else ; TAB4 set value of sum to sum + 2 ; TAB1 print sum ;	int main ( ) { int n , a , b , sum = 0 , ans , s = 0 ; cin >> n >> a >> b ; for ( int i = 0 ; i < n ; i ++ ) { cin >> ans ; if ( ans == 1 ) { if ( a > 0 ) a -- ; else if ( b > 0 ) { b -- ; s ++ ; } else if ( s != 0 ) s -- ; else { sum ++ ; } } else { if ( b > 0 ) b -- ; else sum = sum + 2 ; } } cout << sum << endl ; return 0 ; }
TAB1 create 2d character array cd with size 1009 by 200 ; TAB1 create integers n , flag , i , j , with flag = 0 ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 inclusive , read ch [ i ] [ j ] ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to 5 exclusive ; TAB3 if ch [ i ] [ j ] is ' O ' and ch [ i ] [ j + 1 ] is ' O ' ; TAB4 set ch [ i ] [ j ] to ' + ' ; TAB4 set ch [ i ] [ j + 1 ] to ' + ' ; TAB4 set flag to 1 ; TAB4 break loop ; TAB2 if flag is 1 , break loop ; TAB1 if flag is 1 ; TAB2 print " YES " print newline ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to 5 inclusive , print ch [ i ] [ j ] ; TAB3 print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { char ch [ 1009 ] [ 200 ] ; int n , flag = 0 , i , j ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { cin >> ch [ i ] [ j ] ; } } for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j < 5 ; j ++ ) { if ( ch [ i ] [ j ] == ' O ' && ch [ i ] [ j + 1 ] == ' O ' ) { ch [ i ] [ j ] = ' + ' ; ch [ i ] [ j + 1 ] = ' + ' ; flag = 1 ; break ; } } if ( flag == 1 ) break ; } if ( flag == 1 ) { cout << " YES " << endl ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { cout << ch [ i ] [ j ] ; } cout << endl ; } } else cout << " NO " << endl ; }
TAB1 declare integers hy , ay , dy , hm , am , dm , h , a and d ; TAB1 read hy , ay and dy ; TAB1 read hm , am and dm ; TAB1 read h , a and d ; TAB1 declare integer variable n = 300 ; TAB1 create integer ans = 1e9 ; TAB1 for integer j = 0 to n exclusive ; TAB2 for integer k = 0 to n exclusive ; TAB3 declare integer variable cay = ay + j ; TAB3 declare integer variable cdy = dy + k ; TAB3 assign value max of cay - dm and 0 to integer damageY ; TAB3 set integer damageM to max of 0 and am - cdy ; TAB3 if damageY is 0 , skip the rest of the loop ; TAB3 create integer hits = hm / damageY + ( hm % damageY ! = 0 ) ; TAB3 create integer hp = damageM * hits ; TAB3 assign value max of 0 and hp - hy + 1 to integer toBuy ; TAB3 ans = min of ans and j * a + d * k + toBuy * h ; TAB1 print ans and " \ n " ;	int main ( ) { int hy , ay , dy , hm , am , dm , h , a , d ; cin >> hy >> ay >> dy ; cin >> hm >> am >> dm ; cin >> h >> a >> d ; int n = 300 ; int ans = 1e9 ; for ( int j = 0 ; j < n ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { int cay = ay + j ; int cdy = dy + k ; int damageY = max ( cay - dm , 0 ) ; int damageM = max ( 0 , am - cdy ) ; if ( ! damageY ) continue ; int hits = hm / damageY + ( hm % damageY != 0 ) ; int hp = damageM * hits ; int toBuy = max ( 0 , hp - hy + 1 ) ; ans = min ( ans , j * a + d * k + toBuy * h ) ; } } cout << ans << " \n " ; return 0 ; }
TAB0 let N = 1e5 + 5 be a const integer ; TAB0 let n , sum , Max , res , a [ N ] be of type long long ; TAB0 void Input ( ) be a non returning function ; TAB1 read n ; TAB1 int i = 1 to n exclusive ; TAB2 read a [ i ] ; TAB2 sum + = a [ i ] , set Max to max of Max and a [ i ] ; TAB0 void Solve ( ) be a non returning function ; TAB1 set values long long l = 1 , r = 1e14 ; ; TAB1 while l is less than or equals to r ; TAB2 set value long long mid to ( l + r ) / 2 ; TAB2 set value long long c_games to ( mid * n ) - sum ; ; TAB2 if c_games is greater than or equal to mid ; TAB3 res is equal to mid , r is equal to mid - 1 ; TAB2 else ; TAB3 l is equal to mid + 1 ; ; TAB1 printout max ( res , Max ) and newline ; TAB1 let Input ( ) is a function ; TAB1 let Solve ( ) is a function ;	const int N = 1e5 + 5 ; long long n , sum , Max , res , a [ N ] ; void Input ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; sum += a [ i ] , Max = max ( Max , a [ i ] ) ; } } void Solve ( ) { long long l = 1 , r = 1e14 ; while ( l <= r ) { long long mid = ( l + r ) / 2 ; long long c_games = ( mid * n ) - sum ; if ( c_games >= mid ) res = mid , r = mid - 1 ; else l = mid + 1 ; } cout << max ( res , Max ) << ' \n ' ; } int main ( ) { Input ( ) ; Solve ( ) ; return 0 ; }
TAB1 create integers x , y , songs , sum with sum = 0 ; TAB1 read x read y ; TAB1 for i = 0 to x exclusive ; TAB2 read songs ; TAB2 increment sum by songs ; TAB1 if sum + ( x - 1 ) * 10 is greater than y ; TAB2 print - 1 print newline ; TAB1 else ; TAB2 print ( y - sum ) / 5 print newline ;	int main ( ) { int x , y , songs , sum = 0 ; cin >> x >> y ; for ( int i = 0 ; i < x ; i ++ ) { cin >> songs ; sum += songs ; } if ( sum + ( x - 1 ) * 10 > y ) { cout << - 1 << endl ; return 0 ; } else { cout << ( y - sum ) / 5 << endl ; } }
TAB0 function soshu ( get _n long long , return long long ) ; TAB1 n = _n ; TAB1 for i = 2 to square root of n inclusive ; TAB2 if n modulo i is zero return n / i ; TAB1 return 1 ; TAB0 function cnt ( get three long long n , m , t , return long long ) ; TAB1 ans = - 1 ; TAB1 if n - 1 > t ; TAB2 ans = max ( n / ( t + 1 ) * m , ans ) ; TAB1 else ; TAB2 ans = max ( m / ( t - n + 1 + 1 ) ans ) ; TAB1 t1 = soshu ( n ) ; TAB1 if t > t1 ; TAB2 decrement t by t1 - 1 ; TAB2 tt = ceil ( ( t - m + 1 ) / t1 ) ; TAB2 _n = n / t1 ; TAB2 if m - 1 > = t ; TAB3 ans = max ( ans , ( m / ( t + 1 ) ) * _n ) ; TAB2 else if tt not equal 0 ; TAB3 ans = max ( ans , _n / ( tt + 1 ) ) ; TAB1 return ans ; TAB1 n , m , t = long long ; TAB1 read n , m , t ; TAB1 maxt = ( n - 1 ) + ( m - 1 ) ; TAB1 if maxt < t ; TAB2 print - 1 ; TAB1 else ; TAB2 ans = - 1 ; TAB2 ans = max ( cnt ( n , m , t ) , cnt ( m , n , t ) ) ; TAB2 print ans ;	long long sushu ( long long _n ) { long long n = _n ; for ( int i = 2 ; i <= sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) return n / i ; } return 1 ; } long long cnt ( long long n , long long m , long long t ) { long long ans = - 1 ; if ( n - 1 > t ) ans = max ( ( n / ( t + 1 ) ) * m , ans ) ; else ans = max ( m / ( t - n + 1 + 1 ) , ans ) ; long long t1 = sushu ( n ) ; if ( t > t1 ) { t -= ( t1 - 1 ) ; int tt = ceil ( ( t - m + 1 ) / t1 ) ; long long _n = n / t1 ; if ( m - 1 >= t ) ans = max ( ans , ( m / ( t + 1 ) ) * _n ) ; else if ( tt != 0 ) ans = max ( ans , _n / ( tt + 1 ) ) ; } return ans ; } int main ( ) { long long n , m , t ; cin >> n >> m >> t ; long long maxt = ( long long ) ( n - 1 ) + ( m - 1 ) ; if ( maxt < t ) cout << - 1 << endl ; else { long long ans = - 1 ; ans = max ( cnt ( n , m , t ) , cnt ( m , n , t ) ) ; cout << ans << endl ; } }
TAB1 n = long long ; TAB1 read n ; TAB1 a , b , c , d , suma , sumAux = long long ; TAB1 read a then b then c then d ; TAB1 cont = long long with cont = 1 ; TAB1 set suma to a + b + c + d ; TAB1 for i = 0 to n - 1 ; TAB2 read a then b then c then d ; TAB2 set sumAux to a + b + c + d ; TAB2 if sumAux > suma increment cont ; TAB1 print cont ;	int main ( ) { long long n ; cin >> n ; long long a , b , c , d , suma , sumAux ; cin >> a >> b >> c >> d ; long long cont = 1 ; suma = a + b + c + d ; for ( long long i = 0 ; i < n - 1 ; i ++ ) { cin >> a >> b >> c >> d ; sumAux = a + b + c + d ; if ( sumAux > suma ) cont ++ ; } cout << cont << endl ; return 0 ; }
TAB1 create long long n , a , b , c , remaind , t1 , set c1 = 0 , c2 = 0 ; TAB1 read n , a , b and c ; TAB1 if n is less than a and b ; TAB2 print 0 ; TAB1 if n > = a ; TAB2 c1 = n / a ; TAB2 set remaind to n mod a ; TAB2 if remaind > = b ; TAB3 set remaind to remaind - c ; TAB3 assign c1 + ( remaind / ( b - c ) ) to c1 ; TAB3 t1 = c1 * ( b - c ) ; TAB3 set t1 = remaind - t1 ; TAB3 set t1 to t1 + c ; TAB3 if t1 > = b , increment c1 ; TAB1 if n > = b ; TAB2 n = n - c ; TAB2 set c2 = n / ( b - c ) ; TAB2 set t1 = c2 * ( b - c ) ; TAB2 set t1 to n - t1 ; TAB2 assign t1 + c to t1 ; TAB2 if t1 > = b ; TAB3 increment c2 ; TAB3 set t1 to t1 - b - c ; TAB2 if t1 > = a , set c2 to c2 + t1 / a ; TAB1 c1 = max of c1 and c2 ; TAB1 print c1 ;	int main ( ) { long long n , a , b , c , remaind , c1 = 0 , c2 = 0 , t1 ; cin >> n >> a >> b >> c ; if ( a > n && b > n ) { cout << " 0 " << endl ; return 0 ; } if ( n >= a ) { c1 = n / a ; remaind = n % a ; if ( remaind >= b ) { remaind -= c ; c1 += ( remaind / ( b - c ) ) ; t1 = c1 * ( b - c ) ; t1 = remaind - t1 ; t1 += c ; if ( t1 >= b ) c1 ++ ; } } if ( n >= b ) { n = n - c ; c2 = n / ( b - c ) ; t1 = c2 * ( b - c ) ; t1 = n - t1 ; t1 += c ; if ( t1 >= b ) { c2 ++ ; t1 -= ( b - c ) ; } if ( t1 >= a ) { c2 += ( t1 / a ) ; } } c1 = max ( c1 , c2 ) ; cout << c1 << endl ; return 0 ; }
TAB0 test_case = integer ; TAB0 A = character array of size [ 100 ] [ 100 ] ; TAB0 B = integer array of size [ 100 ] [ 100 ] ; TAB1 read test_case ; TAB1 while decrement test_case ; TAB2 for i = 1 to 9 , read A [ i ] + 1 ; TAB2 a , b , c , d = integers with a = 0 , b = 0 , c = 0 , d = 0 ; TAB2 for i = 1 to 8 ; TAB3 for j = 1 to 8 ; TAB4 if ( A [ i ] [ j ] is K ) ; TAB5 if ( a is 0 ) ; TAB6 a = i ; TAB6 b = j ; TAB5 else ; TAB6 c = i ; TAB6 d = j ; TAB2 if ( ( a + b ) modulo 4 is ( c + d ) modulo 4 and a modulo 4 is c modulo 4 ) ; TAB3 print YES ; TAB2 else ; TAB3 print NO ;	int test_case ; char A [ 100 ] [ 100 ] ; int B [ 100 ] [ 100 ] ; int main ( ) { cin >> test_case ; while ( test_case -- ) { for ( int i = 1 ; i <= 8 ; i ++ ) cin >> A [ i ] + 1 ; int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( A [ i ] [ j ] == ' K ' ) { if ( a == 0 ) { a = i ; b = j ; } else { c = i ; d = j ; } } } } if ( ( a + b ) % 4 == ( c + d ) % 4 && a % 4 == c % 4 ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB0 declare constant integer variable called maxn = 3e5 + 5 ; TAB0 new constant double pi with value 3 . 1415926535 ; TAB0 create constant long long with name mod and value 1e9 + 7 ; TAB0 declare an arrays of ints a and b with size maxn ; TAB1 declare integer variable n ; TAB1 loop , reading n from the input ; TAB2 set values of first sizeof ( a ) bytes at the pointer a to 0 ; TAB2 create long longs ans , k and pos = 0 ; TAB2 in a for loop , change i from 1 to n inclusive incrementing i ; TAB3 read input to a [ i ] ; TAB3 for integer j = 1 to a [ i ] inclusive ; TAB4 x is a new integer variable ; TAB4 read x ; TAB4 set b [ i ] to x if b [ i ] is less than x ; TAB3 if k is less than b [ i ] ; TAB4 change k to b [ i ] ; TAB4 set pos to i ; TAB2 in a for loop , change i from 1 to n inclusive ; TAB3 if i is equal to pos ; TAB4 skip the rest of the loop ; TAB3 else ; TAB4 change ans to ans + a [ i ] * ( b [ pos ] - b [ i ] ) ; TAB2 print ans ;	const int maxn = 3e5 + 5 ; const double pi = 3.1415926535 ; const long long mod = 1e9 + 7 ; int a [ maxn ] , b [ maxn ] ; int main ( ) { int n ; while ( cin >> n ) { memset ( a , 0 , sizeof ( a ) ) , memset ( b , 0 , sizeof ( b ) ) ; long long ans = 0 , k = 0 , pos = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; for ( int j = 1 ; j <= a [ i ] ; j ++ ) { int x ; cin >> x ; if ( b [ i ] < x ) { b [ i ] = x ; } } if ( k < b [ i ] ) { k = b [ i ] ; pos = i ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == pos ) continue ; else { ans += ( long long ) a [ i ] * ( b [ pos ] - b [ i ] ) ; } } cout << ans << endl ; } }
TAB0 hor = integer array of size 100 ; TAB0 ver = integer array of size 100 ; TAB0 hasil = vector of integer ; TAB1 set all contents of hor to 0 ; TAB1 set all contents of ver to 0 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 1 to pow of n and 2 ; TAB2 h , v = integers ; TAB2 read h , v ; TAB2 if hor [ h ] is 0 and ver [ v ] is 0 ; TAB3 hor [ h ] = 1 ; TAB3 ver [ v ] = 1 ; TAB3 append i to hasil ; TAB1 for i = 0 to hasil . size ( ) - 1 exclusive , print hasil [ i ] ; TAB1 print hasil [ hasil . size ( ) - 1 ] ;	int hor [ 100 ] ; int ver [ 100 ] ; vector < int > hasil ; int main ( ) { memset ( hor , 0 , sizeof ( hor ) ) ; memset ( ver , 0 , sizeof ( ver ) ) ; int n ; cin >> n ; for ( int i = 1 ; i <= pow ( n , 2 ) ; i ++ ) { int h , v ; cin >> h >> v ; if ( hor [ h ] == 0 && ver [ v ] == 0 ) { hor [ h ] = 1 ; ver [ v ] = 1 ; hasil . push_back ( i ) ; } } for ( int i = 0 ; i < hasil . size ( ) - 1 ; i ++ ) { cout << hasil [ i ] << "   " ; } cout << hasil [ hasil . size ( ) - 1 ] << endl ; }
TAB1 create int a , b , c , d ; TAB1 while read a , b , c , d ; TAB2 set i and j to 0 , flag to 233 ; TAB2 for i = 0 to 10000 inclusive ; TAB3 for j = 0 to 10000 inclusive ; TAB4 if b + a * i = d + c * j ; TAB5 print b + a * i ; TAB5 set flag to 1 ; TAB5 break ; TAB3 if b + a * i = d + c * j , break ; TAB2 if flag = 233 , print - 1 ;	int main ( ) { int a , b , c , d ; while ( cin >> a >> b >> c >> d ) { int i = 0 , j = 0 , flag = 233 ; for ( i = 0 ; i <= 10000 ; i ++ ) { for ( j = 0 ; j <= 10000 ; j ++ ) if ( b + a * i == d + c * j ) { cout << b + a * i << endl ; flag = 1 ; break ; } if ( b + a * i == d + c * j ) break ; } if ( flag == 233 ) cout << " -1 " << endl ; } return 0 ; }
TAB1 create ints n , m , i , j and k ; TAB1 define an arrays of integers a , b and c with 15 elements ; TAB1 read n and m from the input ; TAB1 read n elements from the input to consecutive items of array a ; TAB1 read m elements from the input stream into b ; TAB1 assign 0 to k ; TAB1 in a for loop , change i from 0 to n exclusive ; TAB2 in a for loop , change j from 0 to m exclusive incrementing j ; TAB3 if a [ i ] = b [ j ] ; TAB4 assign the new value = a [ i ] to c [ k ] ; TAB4 increment k ; TAB4 break the loop ; TAB1 if k is equal to 0 ; TAB2 print new line ; TAB1 else ; TAB2 for i = 0 to k - 1 exclusive , print c [ i ] and " " ; TAB2 print c [ k - 1 ] to the standard output ;	int main ( ) { int n , m , i , j , k ; int a [ 15 ] , b [ 15 ] , c [ 15 ] ; cin >> n >> m ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( j = 0 ; j < m ; j ++ ) cin >> b [ j ] ; k = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ] ) { c [ k ] = a [ i ] ; k ++ ; break ; } } } if ( k == 0 ) cout << endl ; else { for ( i = 0 ; i < k - 1 ; i ++ ) { cout << c [ i ] << "   " ; } cout << c [ k - 1 ] << endl ; } return 0 ; }
TAB0 create map m using string and integer ; TAB1 a , b = string array ; TAB1 integer as s ; TAB1 set m [ saturday ] to 1 ; TAB1 set m [ sunday ] to 2 ; TAB1 set m [ monday ] to 3 ; TAB1 set m [ tuesday ] to 4 ; TAB1 set m [ wednesday ] to 5 ; TAB1 set m [ thursday ] to 6 ; TAB1 set m [ friday ] to 7 ; TAB1 read a , b ; TAB1 set s to ( ( m [ b ] + 7 ) - m [ a ] ) modulo 7 ; TAB1 if s is 0 , 2 or 3 then do the following ; TAB2 output YES ; TAB1 else ; TAB2 output NO ;	map < string , int > m ; int main ( ) { string a , b ; int s ; m [ " saturday " ] = 1 ; m [ " sunday " ] = 2 ; m [ " monday " ] = 3 ; m [ " tuesday " ] = 4 ; m [ " wednesday " ] = 5 ; m [ " thursday " ] = 6 ; m [ " friday " ] = 7 ; cin >> a >> b ; s = ( ( m [ b ] + 7 ) - m [ a ] ) % 7 ; if ( s == 0 || s == 2 || s == 3 ) { cout << " YES " << endl ; return 0 ; } else { cout << " NO " << endl ; return 0 ; } }
TAB0 let long long int mod = 1000000007 ; TAB0 create long long integer MOD = 998244353 ; TAB1 create string s ; TAB1 read s ; TAB1 let int len = s . size ( ) ; TAB1 let ints a = 0 , b = 0 , c = 0 ; TAB1 for i = 0 to len exclusive ; TAB2 if s [ i ] is equal to ' ( ' ; TAB3 increment a ; TAB2 else if s [ i ] is equal to ' ) ' ; TAB3 increment b ; TAB2 else ; TAB3 increase c by 1 ; TAB1 create int vector A ; TAB1 let ints x = 0 and y = 0 ; TAB1 if b is greater than a or b is equal to a and c is greater than 0 ; TAB2 print - 1 ; TAB1 let integer cnt = ( a - b ) ; TAB1 create string ans = " " ; TAB1 for i = 0 to len exclusive ; TAB2 if s [ i ] is equal to ' ( ' or s [ i ] is equal to ' ) ' ; TAB3 set ans to ans + s [ i ] ; TAB2 else if c is greater than 1 ; TAB3 set ans to ans + " ) " ; TAB3 decrease c by 1 ; TAB3 reduce cnt by 1 ; TAB3 append 1 to A ; TAB2 else ; TAB3 append cnt to vector A ; TAB3 for j = 0 to cnt exclusive ; TAB3 reduce c by 1 ; TAB1 for i = 0 to the size of ans exclusive ; TAB2 if ans [ i ] is equal to ' ( ' ; TAB3 increase x by 1 ; TAB2 else ; TAB3 increment y ; TAB2 if x is less than y ; TAB3 print - 1 ; TAB1 for i = 0 to size of A exclusive , print A [ i ] ;	long long int mod = 1000000007 ; long long int MOD = 998244353 ; int main ( ) { string s ; cin >> s ; int len = s . size ( ) ; int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == ' ( ' ) { a ++ ; } else if ( s [ i ] == ' ) ' ) { b ++ ; } else { c ++ ; } } vector < int > A ; int x = 0 , y = 0 ; if ( b > a || ( b == a && c > 0 ) ) { cout << - 1 << endl ; return 0 ; } int cnt = ( a - b ) ; string ans = "  " ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == ' ( ' || s [ i ] == ' ) ' ) { ans += s [ i ] ; } else if ( c > 1 ) { ans += " ) " ; c -- ; cnt -- ; A . push_back ( 1 ) ; } else { A . push_back ( cnt ) ; for ( int j = 0 ; j < cnt ; j ++ ) { ans += " ) " ; } c -- ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] == ' ( ' ) { x ++ ; } else { y ++ ; } if ( x < y ) { cout << - 1 << endl ; return 0 ; } } for ( int i = 0 ; i < A . size ( ) ; i ++ ) { cout << A [ i ] << endl ; } return 0 ; }
TAB0 in function check taking int x1 , int y1 , int x2 , int y2 , int x3 , int y3 and returning bool ; TAB1 a , b , c = int ; TAB1 set a to ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; TAB1 set b to ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; TAB1 set c to ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 ) ; TAB1 if a or b or c is 0 return 0 ; TAB1 if a + b is c or a + c is b or b + c is a ; TAB2 return 1 ; TAB1 else ; TAB1 move = two dimensional array of sizes 4 and 2 with the values { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } ; TAB1 x1 , y1 = int array of size 4 each ; TAB1 for i = 0 to 3 read x1 [ i ] then y1 [ i ] ; TAB1 if check of x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ; TAB2 print " RIGHT " ; TAB1 tx , ty = int ; TAB1 for i = 0 to 3 inclusive ; TAB2 for j = 0 to 3 inclusive ; TAB3 set tx to x1 [ i ] + move [ j ] [ 0 ] ; TAB3 set ty to y1 [ i ] + move [ j ] [ 1 ] ; TAB3 if i is 0 and check of tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ; TAB4 print " ALMOST " ; TAB3 if i is 1 and check of x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] ; TAB4 print " ALMOST " ; TAB3 if i = 2 and check of x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty ; TAB4 print " ALMOST " ; TAB2 if i is 3 print " NEITHER " ;	bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a , b , c ; a = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; b = ( x1 - x3 ) * ( x1 - x3 ) + ( y1 - y3 ) * ( y1 - y3 ) ; c = ( x3 - x2 ) * ( x3 - x2 ) + ( y3 - y2 ) * ( y3 - y2 ) ; if ( a == 0 || b == 0 || c == 0 ) return 0 ; if ( a + b == c || a + c == b || b + c == a ) return 1 ; else return 0 ; } int main ( ) { int move [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int x1 [ 4 ] , y1 [ 4 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { cin >> x1 [ i ] >> y1 [ i ] ; } if ( check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " RIGHT " << endl ; return 0 ; } int tx , ty ; for ( int i = 0 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= 3 ; j ++ ) { tx = x1 [ i ] + move [ j ] [ 0 ] ; ty = y1 [ i ] + move [ j ] [ 1 ] ; if ( i == 0 && check ( tx , ty , x1 [ 1 ] , y1 [ 1 ] , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( i == 1 && check ( x1 [ 0 ] , y1 [ 0 ] , tx , ty , x1 [ 2 ] , y1 [ 2 ] ) ) { cout << " ALMOST " << endl ; return 0 ; } if ( i == 2 && check ( x1 [ 0 ] , y1 [ 0 ] , x1 [ 1 ] , y1 [ 1 ] , tx , ty ) ) { cout << " ALMOST " << endl ; return 0 ; } } if ( i == 3 ) cout << " NEITHER " << endl ; } return 0 ; }
TAB0 maxn = 4000000 ; TAB0 prime = array of maxn int ; TAB0 vis = array of maxn bool ; TAB0 ans = vector of long long ; TAB0 cnt = 0 ; TAB0 function Prime ( no args , no return value ) ; TAB1 fill vis with false ; TAB1 for i = 2 to maxn exclusive ; TAB2 if not vis [ i ] prime [ cnt ] = i , increment cnt ; TAB2 for j = 0 to cnt exclusive while i * prime [ j ] < maxn ; TAB3 vis [ i * prime [ j ] ] = true ; TAB3 if i modulo prime [ j ] is 0 break ; TAB1 n = long long ; TAB1 read n ; TAB1 for i = 2 to sqrt ( n ) inclusive ; TAB2 if n modulo i is 0 ; TAB3 while n modulo i is 0 ; TAB4 divide n by i ; TAB4 put i at end of ans ; TAB1 if n is not 1 put n at end of ans ; TAB1 if size of ans is 0 or 1 or is > = 3 ; TAB2 print 1 ; TAB2 if size of ans is 0 or 1 ; TAB3 print 0 ; TAB2 else ; TAB3 print ans [ 0 ] * ans [ 1 ] ; TAB1 else ; TAB2 print 2 ;	const int maxn = 4e6 ; int prime [ maxn ] ; bool vis [ maxn ] ; vector < long long > ans ; int cnt = 0 ; void Prime ( ) { memset ( vis , false , sizeof vis ) ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( ! vis [ i ] ) prime [ cnt ++ ] = i ; for ( int j = 0 ; j < cnt && i * prime [ j ] < maxn ; j ++ ) { vis [ i * prime [ j ] ] = true ; if ( i % prime [ j ] == 0 ) break ; } } } int main ( ) { long long n ; cin >> n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) { n /= i ; ans . push_back ( i ) ; } } } if ( n != 1 ) ans . push_back ( n ) ; if ( ans . size ( ) == 0 || ans . size ( ) == 1 || ans . size ( ) >= 3 ) { cout << 1 << endl ; if ( ans . size ( ) == 0 || ans . size ( ) == 1 ) cout << 0 << endl ; else cout << ans [ 0 ] * ans [ 1 ] << endl ; } else cout << 2 << endl ; return 0 ; }
TAB1 n , x , y , i , len are integers , a = integer array of size 100005 ; TAB1 s = string ; TAB1 read s ; TAB1 set len to size of s ; TAB1 for i = 0 to len exclusive ; TAB2 if s [ i ] isn ' t the character a ; TAB3 set x to i ; TAB3 break ; TAB1 if i equals len ; TAB2 assign the character z to s [ len - 1 ] ; TAB1 else ; TAB2 for i = x + 1 to len exclusive ; TAB3 if s [ i ] is the character a ; TAB4 set y to i - 1 ; TAB4 break ; TAB2 if i equals len , set y to len - 1 ; TAB2 for i = 1 to y inclusive , subtract 1 from s [ i ] ; TAB1 output s ;	int main ( ) { int n , x , y , i , len , a [ 100005 ] ; string s ; cin >> s ; len = s . size ( ) ; for ( i = 0 ; i < len ; i ++ ) if ( s [ i ] != ' a ' ) { x = i ; break ; } if ( i == len ) s [ len - 1 ] = ' z ' ; else { for ( i = x + 1 ; i < len ; i ++ ) if ( s [ i ] == ' a ' ) { y = i - 1 ; break ; } if ( i == len ) y = len - 1 ; for ( i = x ; i <= y ; i ++ ) s [ i ] = s [ i ] - 1 ; } cout << s << endl ; return 0 ; }
TAB1 create string a ; TAB1 read a and while a is truthy ; TAB2 create bool flag = true ; TAB2 make integer array num of size 3 containing { 0 } ; TAB2 for i = 0 to a . size ( ) exclusive ; TAB3 increase num [ a [ i ] - ' a ' ] by 1 ; TAB3 if i is not equal to 0 and a [ i ] is less than a [ i - 1 ] ; TAB4 set flag to false ; TAB4 break loop ; TAB2 if num [ 2 ] is not num [ 1 ] and num [ 2 ] is not num [ 0 ] , set flag to false ; TAB2 if num [ 0 ] is equal to 0 or num [ 1 ] is equal to 0 , set flag to false ; TAB2 if flag is true ; TAB3 display " YES " ; TAB2 else do ; TAB3 show " NO " ;	int main ( ) { string a ; while ( cin >> a ) { bool flag = true ; int num [ 3 ] = { 0 } ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { num [ a [ i ] - ' a ' ] ++ ; if ( i != 0 && a [ i ] < a [ i - 1 ] ) { flag = false ; break ; } } if ( num [ 2 ] != num [ 1 ] && num [ 2 ] != num [ 0 ] ) flag = false ; if ( num [ 0 ] == 0 || num [ 1 ] == 0 ) flag = false ; if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; } }
TAB0 create constant integer inf = 0x3f3f3f3f ; TAB0 make constant long long integer linf = 0x3f3f3f3fLL ; TAB0 create constant integer EPS = 1e - 6 ; TAB0 make const long long int mod = 1000000007 ; TAB1 create string exp ; TAB1 read exp ; TAB1 make ints a = 0 , b = 0 , and c = 0 ; TAB1 make integer t = 0 ; TAB1 let integer ind_s = 0 ; TAB1 create integer ind_e = 0 ; TAB1 for i = 0 to exp . size ( ) exclusive ; TAB2 if exp [ i ] is equal to ' + ' or exp [ i ] is equal to ' = ' ; TAB3 increase t by 1 ; TAB3 if exp [ i ] is equal to ' + ' ; TAB4 set ind_s to i ; TAB3 else do ; TAB4 set ind_e to i ; TAB3 continue to next loop iteration ; TAB2 if t is 0 ; TAB3 increment a ; TAB2 else if t is equal to 1 ; TAB3 increase b by 1 ; TAB2 else if t is equal to 2 ; TAB3 increase c by 1 ; TAB1 create string str ; TAB1 if ( a + b - 1 ) is not equal to ( c + 1 ) and ( a + b + 1 ) is not equal to ( c - 1 ) and ( a + b ) is not equal to c ; TAB2 output " Impossible " ; TAB1 else ; TAB2 if a + b is c ; TAB3 print exp ; TAB2 else if ( a + b ) - 1 is equal to c + 1 ; TAB3 if a is equal to 1 ; TAB4 create string s1 = exp . substr ( 0 , ind_s + 1 ) ; TAB4 make string s2 = exp . substr ( ind_s + 2 , ( ind_e - 1 ) - ind_s ) ; TAB4 let string s2 = exp . substr ( ind_e + 1 , ( exp . size ( ) - 1 ) - ind_e ) + " | " ; TAB4 print s1 + s2 + s3 ; TAB3 else do ; TAB4 set str to exp . substr ( 1 , exp . size ( ) - 1 ) + " | " ; TAB4 output str ; TAB2 else ; TAB3 set str to " | " + exp . substr ( 0 , exp . size ( ) - 1 ) ; TAB3 display str ;	const int inf = 0x3f3f3f3f ; const long long linf = 0x3f3f3f3fLL ; const int EPS = 1e-6 ; const long long mod = 1000000007 ; int main ( ) { string exp ; cin >> exp ; int a = 0 , b = 0 , c = 0 ; int t = 0 ; int ind_s = 0 ; int ind_e = 0 ; for ( int i = 0 ; i < exp . size ( ) ; i ++ ) { if ( exp [ i ] == ' + ' || exp [ i ] == ' = ' ) { t ++ ; if ( exp [ i ] == ' + ' ) ind_s = i ; else ind_e = i ; continue ; } if ( t == 0 ) a ++ ; else if ( t == 1 ) b ++ ; else if ( t == 2 ) c ++ ; } string str ; if ( ( a + b - 1 ) != ( c + 1 ) && ( a + b + 1 ) != ( c - 1 ) && ( a + b ) != c ) puts ( " Impossible " ) ; else { if ( a + b == c ) cout << exp << endl ; else if ( ( ( a + b ) - 1 ) == ( c + 1 ) ) { if ( a == 1 ) { string s1 = exp . substr ( 0 , ind_s + 1 ) ; string s2 = exp . substr ( ind_s + 2 , ( ind_e - 1 ) - ind_s ) ; string s3 = exp . substr ( ind_e + 1 , ( exp . size ( ) - 1 ) - ind_e ) + " | " ; cout << s1 + s2 + s3 << endl ; } else { str = exp . substr ( 1 , exp . size ( ) - 1 ) + " | " ; cout << str << endl ; } } else { str = " | " + exp . substr ( 0 , exp . size ( ) - 1 ) ; cout << str << endl ; } } return 0 ; }
TAB1 create long long ints n , m , k and ans ; TAB1 loop , reading n , m and k from the input ; TAB2 change ans to 0 ; TAB2 if n + m - 2 is less than k ; TAB3 print - 1 ; TAB2 else ; TAB3 if n is greater than k ; TAB4 set ans to n / ( k + 1 ) * m ; TAB3 else ; TAB4 assign m / ( k - n + 2 ) to ans ; TAB3 if m is greater than k ; TAB4 assign max of m / ( k + 1 ) * n and ans to ans ; TAB3 else ; TAB4 change ans to max of n / ( k - m + 2 ) and ans ; TAB3 print ans ;	int main ( ) { long long int n , m , k , ans ; while ( cin >> n >> m >> k ) { ans = 0 ; if ( n + m - 2 < k ) { cout << - 1 << endl ; } else { if ( n > k ) ans = n / ( k + 1 ) * m ; else ans = m / ( k - n + 2 ) ; if ( m > k ) ans = max ( m / ( k + 1 ) * n , ans ) ; else ans = max ( n / ( k - m + 2 ) , ans ) ; cout << ans << endl ; } } return 0 ; }
TAB0 MAXN = const int with MAXN = 100000 + 7 ; TAB0 mod = const int with mod = 23333333 ; TAB0 l , r , ans , n = long long with ans = 0 ; TAB0 a = int array of size 20 ; TAB0 in function Solve taking a long long n and returning a long long ; TAB1 if n is less than 10 return n ; TAB1 x , y = int with x = n mod 10 ; TAB1 tmp = long long with tmp = n ; TAB1 loop while tmp is greater than 9 set tmp to tmp / 10 ; TAB1 set y to tmp ; TAB1 if x is greater or equal to y ; TAB2 return n / 10 + 9 ; TAB1 else ; TAB2 return n / 10 + 8 ; TAB1 L , R = long long ; TAB1 read l then r ; TAB1 set ans to Solve of r - Solve of l - 1 ; TAB1 print ans ;	const int MAXN = 100000 + 7 ; const int mod = 23333333 ; long long l , r , ans = 0 , n ; int a [ 20 ] ; long long Solve ( long long n ) { if ( n < 10 ) return n ; int x = n % 10 , y ; long long tmp = n ; while ( tmp >= 10 ) tmp /= 10 ; y = tmp ; if ( x >= y ) return n / 10 + 9 ; else return n / 10 + 8 ; } int main ( ) { long long L , R ; cin >> l >> r ; ans = Solve ( r ) - Solve ( l - 1 ) ; cout << ans << endl ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 v = vector of integer with v = n ; TAB1 for i = 0 to n exclusive , read v [ i ] ; TAB1 a , b = integers with a = 0 , b = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if ( v [ i ] is 25 ) ; TAB3 increment a ; TAB2 else if ( v [ i ] is 50 and a > = 1 ) ; TAB3 decrement a , increment b ; TAB2 else if ( v [ i ] is 100 and b > = 1 and a > = 1 ) ; TAB3 decrement b , a ; TAB2 else if ( v [ i ] is 100 and a > = 3 ) ; TAB3 a = a - 3 ; TAB2 else ; TAB3 print NO ; TAB1 print YES ;	int main ( ) { int n ; cin >> n ; vector < int > v ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> v [ i ] ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 25 ) a ++ ; else if ( v [ i ] == 50 && a >= 1 ) a -- , b ++ ; else if ( v [ i ] == 100 && b >= 1 && a >= 1 ) b -- , a -- ; else if ( v [ i ] == 100 && a >= 3 ) a -= 3 ; else { cout << " NO\n " ; return 0 ; } } cout << " YES\n " ; return 0 ; }
TAB0 declare new long long called n ; TAB0 declare vector of long longs vct ; TAB1 read n from the input ; TAB1 create long long x with value n ; TAB1 start for loop from i = 2 to n inclusive incrementing i ; TAB2 while n % i = 0 ; TAB3 push i to the end of vector vct ; TAB3 set value of n to n divided by i ; TAB1 if x ! = n and n ! = 1 , push i to the vector vct ; TAB1 if length of vct is greater than 2 ; TAB2 print " 1 " and vct [ 0 ] * vct [ 1 ] ; TAB1 else if length of vct is equal to 2 ; TAB2 print " 2 " to the standard output ; TAB1 else ; TAB2 print " 1 " and " 0 " to the standard output ;	long long n ; vector < long long > vct ; int main ( ) { cin >> n ; long long x = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { vct . push_back ( i ) ; n /= i ; } } if ( x != n && n != 1 ) vct . push_back ( n ) ; if ( vct . size ( ) > 2 ) cout << " 1 " << endl << vct [ 0 ] * vct [ 1 ] << endl ; else if ( vct . size ( ) == 2 ) cout << " 2 " << endl ; else cout << " 1 " << endl << " 0 " << endl ; return 0 ; }
TAB0 c = array of 200200 char ; TAB0 ic = int ; TAB0 function check ( get char c , return int ) ; TAB1 return true if c is a vowel ; TAB1 s = string ; TAB1 read s ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is an uppercase letter add 32 to s [ i ] ; TAB2 c [ ic ] = s [ i ] , increment ic ; TAB1 for i = 0 to ic exclusive ; TAB2 ch = c [ i ] ; TAB2 if check ( ch ) ; TAB3 for j = i to ic - 1 exclusive c [ j ] = c [ j + 1 ] ; TAB3 decrement ic ; TAB3 decrement i ; TAB2 else ; TAB3 for j = ic down to i + 1 inclusive c [ j ] = c [ j - 1 ] ; TAB3 increment ic ; TAB3 c [ i ] = ' . ' ; TAB3 increment i ; TAB1 for i = 0 to ic exclusive print c [ i ] ; TAB1 print newline ;	char c [ 200200 ] ; int ic ; int check ( char c ) { return c == ' a ' || c == ' o ' || c == ' y ' || c == ' e ' || c == ' u ' || c == ' i ' ; } int main ( ) { string s ; cin >> s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) s [ i ] = s [ i ] + 32 ; c [ ic ++ ] = s [ i ] ; } for ( int i = 0 ; i < ic ; i ++ ) { char ch = c [ i ] ; if ( check ( ch ) ) { for ( int j = i ; j < ic - 1 ; j ++ ) c [ j ] = c [ j + 1 ] ; ic -- ; i -- ; } else { for ( int j = ic ; j >= i + 1 ; j -- ) c [ j ] = c [ j - 1 ] ; ic ++ ; c [ i ] = ' . ' ; i ++ ; } } for ( int i = 0 ; i < ic ; i ++ ) cout << c [ i ] ; cout << endl ; }
TAB0 trees = pair of int and int array of size 105 ; TAB1 n = int ; TAB1 read n ; TAB1 sum , sum_pos , sum_neg = int with sum = 0 and sum_pos = 0 and sum_neg = 0 ; TAB1 for i = 0 to n ; TAB2 read trees [ i ] . first then trees [ i ] . second ; TAB2 increment sum by trees [ i ] . second ; TAB2 if trees [ i ] . first is less than 0 then increment sum_neg by trees [ i ] . second ; TAB2 if trees [ i ] . first is greater than 0 then increment sum_pos by trees [ i ] . second ; TAB1 sort trees ; TAB1 pos , neg , center = int with pos = 0 and neg = 0 and center = - 1 ; TAB1 for i = 0 to n ; TAB2 if trees [ i ] . first is greater than 0 then increment pos ; TAB2 if trees [ i ] . first is greater than 0 and center is - 1 then set center to i ; TAB1 if pos is 0 then set center to n ; TAB1 set neg to n - pos ; TAB1 if absolute of pos - neg is less than 2 ; TAB2 print sum ; TAB1 else ; TAB2 if neg is greater than pos ; TAB3 set sum to sum_pos ; TAB3 i , j = int with i = center - 1 and j = 0 then loop while i is greater or equal to 0 and j is less than pos + 1 incrementing j and decrementing i increment sum by trees [ i ] . second ; TAB2 else ; TAB3 set sum to sum_neg ; TAB3 i , j = int with i = center and j = 0 then loop while i is less than n and j is less than neg + 1 incrementing both i and j increment sum by trees [ i ] . second ; TAB2 print sum ;	pair < int , int > trees [ 105 ] ; int main ( ) { int n ; cin >> n ; int sum = 0 , sum_pos = 0 , sum_neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> trees [ i ] . first >> trees [ i ] . second ; sum += trees [ i ] . second ; if ( trees [ i ] . first < 0 ) sum_neg += trees [ i ] . second ; if ( trees [ i ] . first > 0 ) sum_pos += trees [ i ] . second ; } sort ( trees , trees + n ) ; int pos = 0 , neg = 0 , center = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( trees [ i ] . first > 0 ) pos ++ ; if ( trees [ i ] . first > 0 && center == - 1 ) center = i ; } if ( pos == 0 ) center = n ; neg = n - pos ; if ( abs ( pos - neg ) <= 1 ) cout << sum << endl ; else { if ( neg > pos ) { sum = sum_pos ; for ( int i = center - 1 , j = 0 ; i >= 0 && j < pos + 1 ; i -- , j ++ ) sum += trees [ i ] . second ; } else { sum = sum_neg ; for ( int i = center , j = 0 ; i < n && j < neg + 1 ; i ++ , j ++ ) sum += trees [ i ] . second ; } cout << sum << endl ; } }
TAB0 n , s = int ; TAB0 a , b = int ; TAB0 maxn = - 9999 ; TAB0 x , y = long long ; TAB1 read n , s ; TAB1 y = s * 100 ; TAB1 for i = 0 to n exclusive ; TAB2 read a , b ; TAB2 x = a * 100 + b ; TAB2 if x < = y ; TAB3 if x modulo 100 is 0 ; TAB4 if 0 > maxn maxn = 0 ; TAB3 else if ( 100 - x modulo 100 ) > maxn ; TAB4 maxn = 100 - x modulo 100 ; TAB1 if maxn < 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print maxn ;	int n , s ; int a , b ; int maxn = - 9999 ; long long x , y ; int main ( ) { cin >> n >> s ; y = s * 100 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b ; x = a * 100 + b ; if ( x <= y ) { if ( x % 100 == 0 ) { if ( 0 > maxn ) maxn = 0 ; } else if ( ( 100 - x % 100 ) > maxn ) maxn = 100 - x % 100 ; } } if ( maxn < 0 ) cout << " -1 " << endl ; else cout << maxn << endl ; return 0 ; }
TAB1 integer as n ; TAB1 read n ; TAB1 integer as k = ( n / 2 ) if ( n & 1 ) is true else ( n - ( int ) pow ( 2 , ( int ) log2 ( n ) ) ) / 2 ; TAB1 output k ;	int main ( ) { int n ; cin >> n ; int k = ( n & 1 ) ? ( n / 2 ) : ( n - ( int ) pow ( 2 , ( int ) log2 ( n ) ) ) / 2 ; cout << k << endl ; }
TAB0 mod = 998244353 ; TAB0 maxn = 2e5 ; TAB1 create int t ; TAB1 create long long n , a , b , c ; TAB1 read n ; TAB1 read a , b and c ; TAB1 one = a , two = b - c ; TAB1 set sum1 = n / one , yu1 = n % one , create long long c1 ; TAB1 while yu1 / b > 0 ; TAB2 set ci = ( yu1 - b ) / two ; TAB2 if ci = 0 and yu1 > = b ; TAB3 if yu1 / a > 0 and yu1 / a * a < yu1 / b * two ; TAB4 set yu1 to yu1 - yu1 / a * a ; TAB4 assign sum1 + yu1 / a to sum1 ; TAB3 else ; TAB4 yu1 = yu1 - two ; TAB4 increment sum1 ; TAB2 else ; TAB3 yu1 = yu1 - ci * two ; TAB3 set sum1 to sum1 + ci ; TAB1 set yu2 = n , sum2 = 0 , ans = 0 ; TAB1 while yu2 / b > 0 ; TAB2 assign ( yu2 - b ) / two to ci ; TAB2 if ci = 0 and yu2 > = b ; TAB3 if yu2 / a > 0 and yu2 / a * a < yu2 / b * two ; TAB4 set yu2 to yu2 - yu2 / a * a ; TAB4 sum2 = sum2 + yu2 / a ; TAB3 else ; TAB4 set yu2 to yu2 - two ; TAB4 add 1 to sum2 ; TAB2 else ; TAB3 yu2 = yu2 - ci * two ; TAB3 assign sum2 + ci to sum2 ; TAB1 set sum2 to sum2 + yu2 / one ; TAB1 yu2 = yu2 % one ; TAB1 ans = max ( ans , sum2 ) ; TAB1 ans = max of sum1 and ans ; TAB1 print ans ;	const long long mod = 998244353 ; const int maxn = 2e5 ; int main ( ) { int t ; long long n , a , b , c ; cin >> n ; cin >> a >> b >> c ; long long one = a , two = b - c ; long long sum1 = n / one , yu1 = n % one , ci ; while ( yu1 / b > 0 ) { ci = ( yu1 - b ) / two ; if ( ci == 0 && yu1 >= b ) { if ( yu1 / a > 0 && yu1 / a * a < yu1 / b * two ) { yu1 = yu1 - yu1 / a * a ; sum1 = sum1 + yu1 / a ; } else { yu1 -= two ; sum1 ++ ; } } else { yu1 = yu1 - ci * two ; sum1 += ci ; } } long long yu2 = n , sum2 = 0 , ans = 0 ; while ( yu2 / b > 0 ) { ci = ( yu2 - b ) / two ; if ( ci == 0 && yu2 >= b ) { if ( yu2 / a > 0 && yu2 / a * a < yu2 / b * two ) { yu2 = yu2 - yu2 / a * a ; sum2 += yu2 / a ; } else { yu2 -= two ; sum2 ++ ; } } else { yu2 = yu2 - ci * two ; sum2 += ci ; } } sum2 += yu2 / one ; yu2 = yu2 % one ; ans = max ( ans , sum2 ) ; ans = max ( sum1 , ans ) ; cout << ans << endl ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create boolean array horizontal with size n + 1 with horizontal = { } ; TAB1 create boolean array vertikal with size n + 1 with vertikal = { } ; TAB1 create boolean array theyareworking with size n * n + 1 with theyareworking = { } ; TAB1 for i = 1 to n * n inclusive ; TAB2 create integers v , h ; TAB2 read h read v ; TAB2 if horizontal [ h ] is false and vertikal [ v ] is false ; TAB3 set theyareworking [ i ] to true ; TAB3 set horizontal [ h ] to true ; TAB3 set vertikal [ v ] to true ; TAB1 create boolean hihi with hihi = false ; TAB1 for i = 1 to n * n inclusive ; TAB2 if theyareworking [ i ] is true ; TAB3 if hihi is false ; TAB4 print i ; TAB4 set hihi to true ; TAB3 else ; TAB4 print " " print i ; TAB1 print newline ;	int main ( ) { int n ; cin >> n ; bool horizontal [ n + 1 ] = { } ; bool vertikal [ n + 1 ] = { } ; bool theyareworking [ n * n + 1 ] = { } ; for ( int i = 1 ; i <= n * n ; i ++ ) { int v , h ; cin >> h >> v ; if ( horizontal [ h ] == false && vertikal [ v ] == false ) { theyareworking [ i ] = true ; horizontal [ h ] = true ; vertikal [ v ] = true ; } } bool hihi = false ; for ( int i = 1 ; i <= n * n ; i ++ ) { if ( theyareworking [ i ] == true ) { if ( hihi == false ) { cout << i ; hihi = true ; } else { cout << "   " << i ; } } } cout << endl ; }
TAB1 let n = integer and ts = array of integers size 26 ; TAB1 let s = string ; TAB1 read n , s ; TAB1 if n is 1 do the following ; TAB2 print Yes ; TAB1 set sizeof ( ts ) bytes starting at ts to 0 ; TAB1 for integer i = 0 to n exclusive increment ts [ s [ i ] - a ] ; TAB1 call sort on ts and ts + 26 ; TAB1 if ts [ 25 ] is less than 2 ; TAB2 print No ; TAB1 else ; TAB2 print Yes ;	int main ( ) { int n , ts [ 26 ] ; string s ; cin >> n >> s ; if ( n == 1 ) { cout << " Yes " << endl ; return 0 ; } memset ( ts , 0 , sizeof ( ts ) ) ; for ( int i = 0 ; i < n ; i ++ ) { ts [ s [ i ] - ' a ' ] ++ ; } sort ( ts , ts + 26 ) ; if ( ts [ 25 ] < 2 ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB1 let i , j , n , k , p , t , coun and temp be integers where j , k , t , coun and temp = 0 , and b is an integer array b with 51 element ; TAB1 read variable n from the input ; TAB1 in a for loop , change i from 0 to n exclusive incrementing i ; TAB2 read variable p from the input ; TAB2 if p is equal to 25 , increment j by one ; TAB2 if p = 50 ; TAB3 decrement j ; TAB3 increment k by one ; TAB3 if j is less than 0 , change temp to 1 ; TAB2 else if p is equal to 100 ; TAB3 if k ! = 0 & j ! = 0 ; TAB4 decrement k by one ; TAB4 substract 1 from j ; TAB3 else ; TAB4 decrease j by 3 ; TAB3 if j is less than 0 , assign 1 to temp ; TAB1 if temp = 0 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int i , j = 0 , n , k = 0 , p , t = 0 , b [ 51 ] , coun = 0 , temp = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> p ; if ( p == 25 ) j ++ ; if ( p == 50 ) { j -- ; k ++ ; if ( j < 0 ) temp = 1 ; } else if ( p == 100 ) { if ( k != 0 & j != 0 ) { k -- ; j -- ; } else { j -= 3 ; } if ( j < 0 ) temp = 1 ; } } if ( temp == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 declare long longs n , r , c , w = 0 , b = 0 ; TAB1 read n , r , c ; TAB1 if r is 1 , let w be c - 1 ; TAB1 if c is 1 , let w be r - 1 ; TAB1 if w is 0 , let w be minimum of ( r and c ) - 1 + maximum of ( r and c ) - minimum of ( r and c ) ; TAB1 if r is n , let b be absolute value of ( c - n ) ; TAB1 if c is n , let b be absolute value of ( r - n ) ; TAB1 if b is 0 , let b be n - maximum of ( r and c ) + absolute value of ( minimum of ( r and c ) - maximum of ( r and c ) ) ; TAB1 if w is less than or equal to b ; TAB2 print " White " ; TAB3 print " \ n " ; TAB1 else ; TAB2 print " Black " ; TAB3 print " \ n " ;	int main ( ) { long long n , r , c , w = 0 , b = 0 ; cin >> n >> r >> c ; if ( r == 1 ) w = c - 1 ; if ( c == 1 ) w = r - 1 ; if ( w == 0 ) w = min ( r , c ) - 1 + max ( r , c ) - min ( r , c ) ; if ( r == n ) b = abs ( c - n ) ; if ( c == n ) b = abs ( r - n ) ; if ( b == 0 ) b = n - max ( r , c ) + abs ( min ( r , c ) - max ( r , c ) ) ; if ( w <= b ) cout << " White " << " \n " ; else cout << " Black " << " \n " ; }
TAB0 nums is a integer array ; TAB0 divisors is a ineger array ; TAB0 get_gcd is a function ; TAB1 while ( a % = b ) and ( b % = a ) is true ; TAB2 end statement ; TAB1 return a + b ; TAB0 primes is an ineger array ; TAB0 get_prime is a function ; TAB1 for integer i = 0 to end - begin + 1 exclusive , ; TAB2 if primes [ i ] = 0 or primes [ i ] = 1 ; TAB3 primes [ i ] equals 0 ; TAB3 continue ; TAB2 else ; TAB3 appear_ctr is an integer equals 0 ; TAB3 if nums [ i ] is not equal to 0 , increase appear_ctr by nums [ i ] ; TAB3 for integer j = i + primes [ i ] to end - begin + 1 ; TAB4 primes [ j ] equals 0 ; TAB4 if nums [ j ] is not equal to 0 , increase appear_ctr by nums [ j ] ; TAB3 divisors [ i ] equals appear_ctr ; TAB1 let n be an integer ; TAB1 let gcd be an integer and equals 1 ; TAB1 read n ; TAB1 is_first is a boolean value true ; TAB1 let first_ctr is an integer 0 ; TAB1 let max_num is an integer 0 ; TAB1 let first be an integer ; TAB1 for integer currnum = 1 to n inclusive ; TAB2 let temp be an integer ; TAB2 read temp ; TAB2 let max_num equal max ( max_num , temp ) ; TAB2 increase nums [ temp ] by 1 ; TAB2 if is_first is true ; TAB3 first equals temp ; TAB3 gcd equals temp ; TAB3 is_first equals false ; TAB2 else if nums [ temp ] equals 1 ; TAB3 gcd equals get_gcd ( gcd , temp ) ; TAB2 if temp equals first , increase first_ctr by 1 ; TAB1 if first_ctr equals n ; TAB2 print - 1 and endline ; TAB1 if gcd is not equal to 1 , ; TAB2 for integer currnum = 1 to max_num inclusive ; TAB3 if nums [ currnum ] is not equal to 0 ; TAB4 integer appear equals nums [ currnum ] ; TAB4 nums [ currnum ] equals 0 ; TAB4 nums [ currnum / gcd ] equals appear ; TAB1 for integer currnum = 1 to max_num inclusive , primes [ currnum ] = currnum ; TAB1 call function get_prime ; TAB1 integer max_appear equals 0 ; TAB1 for integer currdiv = 1 to max_num inclusive , max_appear = max ( max_appear , divisors [ currdiv ] ; TAB1 print n - max_appear and endline ;	int nums [ 15000001 ] ; int divisors [ 15000001 ] ; inline int get_gcd ( int a , int b ) { while ( ( a %= b ) && ( b %= a ) ) ; return a + b ; } int primes [ 15000001 ] ; void get_prime ( int begin , int end ) { for ( int i = 0 ; i < end - begin + 1 ; ++ i ) { if ( primes [ i ] == 0 || primes [ i ] == 1 ) { primes [ i ] = 0 ; continue ; } else { int appear_ctr = 0 ; if ( nums [ i ] != 0 ) appear_ctr += nums [ i ] ; for ( int j = i + primes [ i ] ; j < end - begin + 1 ; j += primes [ i ] ) { primes [ j ] = 0 ; if ( nums [ j ] != 0 ) appear_ctr += nums [ j ] ; } divisors [ i ] = appear_ctr ; } } } int main ( ) { int n ; int gcd = 1 ; cin >> n ; bool is_first = true ; int first_ctr = 0 ; int max_num = 0 ; int first ; for ( int currnum = 1 ; currnum <= n ; ++ currnum ) { int temp ; cin >> temp ; max_num = max ( max_num , temp ) ; ++ nums [ temp ] ; if ( is_first == true ) { first = temp ; gcd = temp ; is_first = false ; } else if ( nums [ temp ] == 1 ) gcd = get_gcd ( gcd , temp ) ; if ( temp == first ) ++ first_ctr ; } if ( first_ctr == n ) { cout << - 1 << endl ; return 0 ; } if ( gcd != 1 ) { for ( int currnum = 1 ; currnum <= max_num ; ++ currnum ) { if ( nums [ currnum ] != 0 ) { int appear = nums [ currnum ] ; nums [ currnum ] = 0 ; nums [ currnum / gcd ] = appear ; } } } for ( int currnum = 1 ; currnum <= max_num ; ++ currnum ) { primes [ currnum ] = currnum ; } get_prime ( 1 , max_num + 1 ) ; int max_appear = 0 ; for ( int currdiv = 1 ; currdiv <= max_num ; ++ currdiv ) { max_appear = max ( max_appear , divisors [ currdiv ] ) ; } cout << n - max_appear << endl ; return 0 ; }
TAB0 integers = presub ( string s ) ; TAB1 integers = aux ; TAB1 for pos = 1 to less than ( int ) s . size ( ) do the following ; TAB2 set aux to 0 ; TAB2 if aux + pos is less than ( integer then do the following s . size ( ; TAB2 if aux + pos is ( integer then do the following s . size ( ; TAB1 return ( int ) s . size ( ) ; TAB1 s , t = string array ; TAB1 integers = n , k , pos ; TAB1 read input n , k ; TAB1 read in t ; TAB1 set pos to n - presub ( t ) ; TAB1 set s to t ; TAB1 for i = 0 to less than k - 1 do the following ; TAB2 for j = pos to less than n then add t [ j ] to s ; TAB1 output s ;	int presub ( string s ) { int aux ; for ( int pos = 1 ; pos < ( int ) s . size ( ) ; pos ++ ) { aux = 0 ; while ( aux + pos < ( int ) s . size ( ) && s [ aux ] == s [ pos + aux ] ) aux ++ ; if ( aux + pos == ( int ) s . size ( ) ) return pos ; } return ( int ) s . size ( ) ; } int main ( ) { string s , t ; int n , k , pos ; cin >> n >> k ; cin >> t ; pos = n - presub ( t ) ; s = t ; for ( int i = 0 ; i < k - 1 ; i ++ ) for ( int j = pos ; j < n ; j ++ ) s += t [ j ] ; cout << s << endl ; return 0 ; }
TAB0 a , b , l , r , ans , T = int ; TAB0 s = char array of size 200 ; TAB0 vis = bool array of size 27 ; TAB0 in function dfs taking char cp and returning int ; TAB1 count = int with count = 0 ; TAB1 for i = 0 to a set s [ i ] to ' a ' + i ; TAB1 for i = a to a + b set s [ i ] to cp ; TAB1 set all values of vis to false ; TAB1 for i = b to a + b set vis [ s [ i ] - ' a ' ] to true ; TAB1 sta , ed = int with sta = a + b and ed = 0 ; TAB1 loop while sta < 2 * a + b ; TAB2 loop while vis [ ed ] increment ed ; TAB2 set s [ sta ] to ed + ' a ' ; TAB2 increment both sta and ed ; TAB1 for i = 2 * a + b to T set s [ i ] to s [ i - 1 ] ; TAB1 set all values of vis to false ; TAB1 if l < = r ; TAB2 for i = l to r inclusive ; TAB3 if not vis [ s [ i ] - ' a ' ] increment count then set vis [ s [ i ] - ' a ' ] to true ; TAB1 else ; TAB2 for i = 0 to r inclusive ; TAB3 if not vis [ s [ i ] - ' a ' ] increment count then set vis [ s [ i ] - ' a ' ] to true ; TAB2 for i = l to T ; TAB3 if not vis [ s [ i ] - ' a ' ] increment count then set vis [ s [ i ] - ' a ' ] to true ; TAB1 return count ; TAB1 read a then b then l then r ; TAB1 decrement both l and r ; TAB1 if a < = b ; TAB2 set ans to a + 1 ; TAB1 else ; TAB2 set ans to 2 * a - b ; TAB1 set T to 2 * ( a + b ) ; TAB1 if r - l > = T ; TAB2 noop ; TAB1 else ; TAB2 set r to r mod T then set l to l mod T ; TAB2 for i = 0 to a set ans to min of dfs of ( ' a ' + i ) , ans ; TAB1 print ans ;	int a , b , l , r , ans , T ; char s [ 200 ] ; bool vis [ 27 ] ; int dfs ( char cp ) { int count = 0 ; for ( int i = 0 ; i < a ; i ++ ) s [ i ] = ( ' a ' + i ) ; for ( int i = a ; i < a + b ; i ++ ) s [ i ] = cp ; memset ( vis , false , sizeof ( vis ) ) ; for ( int i = b ; i < a + b ; i ++ ) vis [ s [ i ] - ' a ' ] = true ; int sta = a + b , ed = 0 ; while ( sta < 2 * a + b ) { while ( vis [ ed ] ) ed ++ ; s [ sta ] = ed + ' a ' ; sta ++ , ed ++ ; } for ( int i = 2 * a + b ; i < T ; i ++ ) s [ i ] = s [ i - 1 ] ; memset ( vis , false , sizeof ( vis ) ) ; if ( l <= r ) { for ( int i = l ; i <= r ; i ++ ) { if ( ! vis [ s [ i ] - ' a ' ] ) { count ++ , vis [ s [ i ] - ' a ' ] = true ; } } } else { for ( int i = 0 ; i <= r ; i ++ ) { if ( ! vis [ s [ i ] - ' a ' ] ) { count ++ , vis [ s [ i ] - ' a ' ] = true ; } } for ( int i = l ; i < T ; i ++ ) { if ( ! vis [ s [ i ] - ' a ' ] ) { count ++ , vis [ s [ i ] - ' a ' ] = true ; } } } return count ; } int main ( ) { cin >> a >> b >> l >> r ; l -- , r -- ; if ( a <= b ) ans = a + 1 ; else ans = 2 * a - b ; T = 2 * ( a + b ) ; if ( r - l >= T ) ; else { r %= T , l %= T ; for ( int i = 0 ; i < a ; i ++ ) { ans = min ( dfs ( ' a ' + i ) , ans ) ; } } cout << ans << endl ; return 0 ; }
TAB0 create new long long variable n ; TAB0 search is a bool function with long long argument t1 ; TAB1 declare new integers l = 0 and r = ( square root of ( 8 * n + 1 ) ) / 2 ; TAB1 declare integer variable m ; TAB1 create new integer called it = 0 ; TAB1 while it < = 100 ; TAB2 change m to ( l + r ) ; TAB2 declare long long variable t2 = m * ( m + 1 ) / 2 ; TAB2 if t2 = t1 when t1 ! = 0 ; TAB3 return true ; TAB2 else if t2 is greater than t1 ; TAB3 set r to m ; TAB2 else ; TAB3 assign m to l ; TAB2 increment it ; TAB1 return false ; TAB1 create new long long called t1 = 0 ; TAB1 read variable n from the input ; TAB1 create boolean variable with name found and value = false ; TAB1 if n ! = 1 ; TAB2 start for loop from i = 1 to n inclusive , while ( i * ( i + 1 ) / 2 ) < = n ; TAB3 assign n - ( i * ( i + 1 ) / 2 ) to t1 ; TAB3 change found to the result of search ( t1 ) ; TAB3 if found is true ; TAB4 print " YES " and ' \ n ' to the standard output ; TAB4 stop the loop ; TAB1 if found is false , print " NO " and ' \ n ' ;	long long n ; bool search ( long long t1 ) { int l = 0 , r = sqrt ( 8 * n + 1 ) / 2 ; int m ; int it = 0 ; while ( it <= 100 ) { m = ( l + r ) >> 1 ; long long t2 = m * ( m + 1 ) / 2 ; if ( t2 == t1 && t1 != 0 ) return true ; else if ( t2 > t1 ) r = m ; else l = m ; it ++ ; } return false ; } int main ( ) { long long t1 = 0 ; cin >> n ; bool found = false ; if ( n != 1 ) { for ( int i = 1 ; i <= n && ( i * ( i + 1 ) / 2 ) <= n ; i ++ ) { t1 = n - ( i * ( i + 1 ) / 2 ) ; found = search ( t1 ) ; if ( found ) { cout << " YES " << ' \n ' ; break ; } } } if ( ! found ) cout << " NO " << ' \n ' ; return 0 ; }
TAB1 n , m and i are integers where i = 0 ; TAB1 declare string variables s and s1 ; TAB1 read standard input to n and m ; TAB1 read user input to s and s1 ; TAB1 if s = s1 ; TAB2 print " YES " ; TAB1 while s [ i ] is s1 [ i ] and i < min of n and m ; TAB1 while s [ n - 1 ] is s1 [ m - 1 ] and i < min of n and m ; TAB1 print " YES " if s [ i ] = ' * ' and ( n - i ) = 1 or " NO " otherwise ;	int main ( ) { int n , m , i = 0 ; string s , s1 ; cin >> n >> m ; cin >> s >> s1 ; if ( s == s1 ) { cout << " YES " << endl ; return 0 ; } while ( s [ i ] == s1 [ i ] && i < min ( n , m ) ) i ++ ; while ( s [ n - 1 ] == s1 [ m - 1 ] && i < min ( n , m ) ) n -- , m -- ; cout << ( s [ i ] == ' * ' && ( n - i ) == 1 ? " YES " : " NO " ) << endl ; }
TAB1 create ints n , a = 0 , b = 0 , and c ; TAB1 read n ; TAB1 while n - - is truthy ; TAB2 read c ; TAB2 if c is equal to 25 ; TAB3 increment a ; TAB2 else if c is equal to 50 ; TAB3 add 1 to b ; TAB3 if a is falsy ; TAB4 print " NO " ; TAB3 decrease a by 1 ; TAB2 else do ; TAB3 if a and b are truthy ; TAB4 decrease a and b by 1 ; TAB3 else if a is greater than or equal to 3 ; TAB4 set a to a - 3 ; TAB3 else ; TAB4 print " NO " ; TAB1 print " YES " ;	int main ( ) { int n , a = 0 , b = 0 , c ; cin >> n ; while ( n -- ) { cin >> c ; if ( c == 25 ) a ++ ; else if ( c == 50 ) { b ++ ; if ( ! a ) { puts ( " NO " ) ; return 0 ; } a -- ; } else { if ( a && b ) a -- , b -- ; else if ( a >= 3 ) a -= 3 ; else { puts ( " NO " ) ; return 0 ; } } } puts ( " YES " ) ; }
TAB1 n , m = integers ; TAB1 create k as double ; TAB1 input n , m , k ; TAB1 a = string ; TAB1 s as integer ; TAB1 sk = map string to double ; TAB1 for i = 0 to n - 1 ; TAB2 input a , s ; TAB2 if s * k less than 100 ; TAB3 do nothing ; TAB2 else ; TAB3 sk [ a ] = return value of floor called with s * k + 0 . 00001 ; TAB1 for i = 0 to m - 1 ; TAB2 input a ; TAB2 if sk [ a ] equals 0 then set sk [ a ] to 0 ; TAB1 create an iterator for map string to double called i ; TAB1 print the size of sk ; TAB1 for all items in sk print the first and second item ;	int main ( ) { int n , m ; double k ; cin >> n >> m >> k ; string a ; int s ; map < string , double > sk ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> s ; if ( s * k < 100 ) ; else sk [ a ] = floor ( ( s * k + 0.00001 ) ) ; } for ( int i = 0 ; i < m ; i ++ ) { cin >> a ; if ( sk [ a ] == 0 ) sk [ a ] = 0 ; } map < string , double > :: iterator i ; cout << sk . size ( ) << endl ; for ( i = sk . begin ( ) ; i != sk . end ( ) ; i ++ ) { cout << i -> first << "   " << i -> second << " \n " ; } return 0 ; }
TAB1 declare long longs n , a , b , c ; TAB1 while read n is true ; TAB2 read a , b , c ; TAB2 declare long long cnt = 0 ; TAB2 if b - c is greater than or equal to a or b - c is less than a and n is less than b ; TAB3 increment cnt by n / a ; TAB2 else ; TAB3 increment cnt by ( n - b ) / ( b - c ) + 1 ; TAB3 decrement n by cnt * ( b - c ) ; TAB3 increment cnt by n / a ; TAB2 print cnt and newline ;	int main ( ) { long long n , a , b , c ; while ( cin >> n ) { cin >> a >> b >> c ; long long cnt = 0 ; if ( b - c >= a || ( b - c < a ) && ( n < b ) ) cnt += n / a ; else { cnt += ( n - b ) / ( b - c ) + 1 ; n -= cnt * ( b - c ) ; cnt += n / a ; } cout << cnt << endl ; } return 0 ; }
TAB0 integer as t integer MAXN = 2e5 + 5 ; TAB0 integer as N , L , T , H ; TAB0 integer as A [ MAXN ] ; TAB1 read N , L , T ; TAB1 set A [ 2 * N + 1 ] to L ; TAB1 for i = 1 to less than or equal to N do the following ; TAB2 read A [ 2 * i - 1 ] , A [ 2 * i ] ; TAB2 A [ 2 * i ] equals A [ 2 * i ] plus A [ 2 * i - 1 ] ; TAB1 for i = 0 to less than or equal to N then add ( A [ 2 * i + 1 ] - A [ 2 * i ] ) / T to H ; TAB1 output H ;	const int MAXN = 2e5 + 5 ; int N , L , T , H ; int A [ MAXN ] ; int main ( ) { cin >> N >> L >> T ; A [ 2 * N + 1 ] = L ; for ( int i = 1 ; i <= N ; i ++ ) { cin >> A [ 2 * i - 1 ] >> A [ 2 * i ] ; A [ 2 * i ] += A [ 2 * i - 1 ] ; } for ( int i = 0 ; i <= N ; i ++ ) { H += ( A [ 2 * i + 1 ] - A [ 2 * i ] ) / T ; } cout << H << ' \n ' ; return 0 ; }
TAB1 create long long q ; TAB1 read q ; TAB1 if q = 1 ; TAB2 print 1 \ n0 \ n and a newline ; TAB1 set a and b to - 1 ; TAB1 for d = 2 to d * d < = q ; TAB2 if q mod d different from 0 , continue ; TAB2 a = d ; TAB2 set b to q / d ; TAB2 break ; TAB1 if a = - 1 ; TAB2 print 1 \ n0 \ n ; TAB1 for d = 2 , d * d < = b ; TAB2 if b modulo d different from 0 , continue ; TAB2 print 1 \ n , a * d and a newline ; TAB1 print 2 \ n ;	int main ( ) { long long q ; cin >> q ; if ( q == 1 ) { cout << " 1\n0\n " ; return 0 ; } long long a = - 1 , b = - 1 ; for ( long long d = 2 ; d * d <= q ; d ++ ) { if ( q % d ) continue ; a = d ; b = q / d ; break ; } if ( a == - 1 ) { cout << " 1\n0\n " ; return 0 ; } for ( long long d = 2 ; d * d <= b ; d ++ ) { if ( b % d ) continue ; cout << " 1\n " << a * d << ' \n ' ; return 0 ; } cout << " 2\n " ; }
TAB1 create long double n ; TAB1 read n ; TAB1 if n is less than or equal to 127 ; TAB2 print " byte " ; TAB1 else if n is less than or equal to 32767 ; TAB2 display " short " ; TAB1 else if n is less than or equal to 2147483647 ; TAB2 display " int " ; TAB1 else if n is less than or equal to 9223372036854775807 ; TAB2 print " long " ; TAB1 otherwise ; TAB2 show " BigInteger " ;	int main ( ) { long double n ; cin >> n ; if ( n <= 127 ) { cout << " byte " << endl ; } else if ( n <= 32767 ) { cout << " short " << endl ; } else if ( n <= 2147483647 ) { cout << " int " << endl ; } else if ( n <= 9223372036854775807 ) { cout << " long " << endl ; } else { cout << " BigInteger " << endl ; } }
TAB1 create integers n and m ; TAB1 read n and m from the user input ; TAB1 dif is a new integer = 99999999 ; TAB1 decrement m and loop further , while m ! = 0 ; TAB2 declare ints a and b ; TAB2 read a and b ; TAB2 set dif to min of dif and abs ( a - b ) + 1 ; TAB1 j is a new integer variable = 0 ; TAB1 print dif ; TAB1 while j < n ; TAB2 print j modulo dif to the standard output ; TAB2 if j ! = n - 1 , print " " to the standard output ; TAB2 increment j ; TAB1 print new line ;	int main ( ) { int n , m ; cin >> n >> m ; int dif = 99999999 ; while ( m -- ) { int a , b ; cin >> a >> b ; dif = min ( dif , abs ( a - b ) + 1 ) ; } int j = 0 ; cout << dif << endl ; while ( j < n ) { cout << j % ( dif ) ; if ( j != n - 1 ) cout << "   " ; j ++ ; } cout << endl ; }
TAB0 x , y = array of 11 by 11 char ; TAB0 b = array of 10 int , n = int ; TAB1 read n ; TAB1 for i = 0 to 10 exclusive b [ i ] = 1 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive read x [ i ] [ j ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive read y [ i ] [ j ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if x [ i ] [ j ] is not y [ i ] [ j ] b [ 0 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ i ] [ n - j - 1 ] b [ 1 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ n - i - 1 ] [ j ] b [ 2 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ n - i - 1 ] [ n - j - 1 ] b [ 3 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ j ] [ n - i - 1 ] b [ 4 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ n - j - 1 ] [ n - j - 1 ] b [ 5 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ j ] [ i ] b [ 6 ] = 0 ; TAB3 if x [ i ] [ j ] is not y [ n - j - 1 ] [ i ] b [ 7 ] = 0 ; TAB1 for i = 0 to 8 exclusive ; TAB2 if b [ i ] is 1 ; TAB3 print Yes ; TAB1 print No ;	char x [ 11 ] [ 11 ] , y [ 11 ] [ 11 ] ; int b [ 10 ] , n ; int main ( ) { cin >> n ; for ( int i = 0 ; i < 10 ; i ++ ) b [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) cin >> x [ i ] [ j ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) cin >> y [ i ] [ j ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( x [ i ] [ j ] != y [ i ] [ j ] ) b [ 0 ] = 0 ; if ( x [ i ] [ j ] != y [ i ] [ n - j - 1 ] ) b [ 1 ] = 0 ; if ( x [ i ] [ j ] != y [ n - i - 1 ] [ j ] ) b [ 2 ] = 0 ; if ( x [ i ] [ j ] != y [ n - i - 1 ] [ n - j - 1 ] ) b [ 3 ] = 0 ; if ( x [ i ] [ j ] != y [ j ] [ n - i - 1 ] ) b [ 4 ] = 0 ; if ( x [ i ] [ j ] != y [ n - j - 1 ] [ n - i - 1 ] ) b [ 5 ] = 0 ; if ( x [ i ] [ j ] != y [ j ] [ i ] ) b [ 6 ] = 0 ; if ( x [ i ] [ j ] != y [ n - j - 1 ] [ i ] ) b [ 7 ] = 0 ; } for ( int i = 0 ; i < 8 ; i ++ ) if ( b [ i ] == 1 ) { cout << " Yes\n " ; return 0 ; } cout << " No\n " ; return 0 ; }
TAB1 n , a , b , num = integers with a , b = integer array of size 1001 ; TAB1 read n ; TAB1 num = n ; TAB1 for i = 1 to n , read a [ i ] , b [ i ] ; TAB1 for j = 1 to n ; TAB2 for i = 1 to n ; TAB3 if ( i is j ) , continue next iteration ; TAB3 if ( b [ j ] is a [ i ] ) ; TAB4 decrement num ; TAB4 a [ i ] = 0 ; TAB1 print num ;	int main ( ) { int n , a [ 1001 ] , b [ 1001 ] , num ; cin >> n ; num = n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( i == j ) { continue ; } if ( b [ j ] == a [ i ] ) { num -- ; a [ i ] = 0 ; } } } cout << num << endl ; return 0 ; }
TAB1 require fixed number of decimal digits in output ; TAB1 set number of decimal digits to 20 ; TAB1 n = int ; TAB1 read n ; TAB1 s = string ; TAB1 read s ; TAB1 ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is ' < ' ; TAB3 increment ans ; TAB2 else ; TAB3 break ; TAB1 for i = n - 1 down to 0 inclusive ; TAB2 if s [ i ] is ' > ' ; TAB3 increment ans ; TAB2 else ; TAB3 break ; TAB1 print ans ;	int main ( ) { cout . setf ( ios :: fixed ) ; cout . precision ( 20 ) ; int n ; cin >> n ; string s ; cin >> s ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == ' < ' ) { ++ ans ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == ' > ' ) { ++ ans ; } else break ; } cout << ans << ' \n ' ; }
TAB0 M = const int with M = 100005 ; TAB0 n , m , k = long long ; TAB0 a = long long array of size M ; TAB0 num = long long array of size M ; TAB1 read n then m then k ; TAB1 for i = 1 to n inclusive read a [ i ] ; TAB1 if n is even ; TAB2 print " 0 " ; TAB1 ans = long long ; TAB1 movs = long long with movs = n / 2 + 1 ; TAB1 if movs > m ; TAB2 set ans to 0 ; TAB1 else ; TAB2 minn = long long with minn = a [ 1 ] ; TAB2 for i = 2 to n inclusive ; TAB3 if i is uneven set minn to min of a [ i ] , minn ; TAB2 set ans to min of minn , m as long long / movs * k ; TAB1 print ans ;	const int M = 100005 ; long long n , m , k ; long long a [ M ] ; long long num [ M ] ; int main ( ) { cin >> n >> m >> k ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; if ( n % 2 == 0 ) { cout << " 0 " << endl ; return 0 ; } long long ans = 0 ; long long movs = n / 2 + 1 ; if ( movs > m ) { ans = 0 ; } else { long long minn = a [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) { minn = min ( a [ i ] , minn ) ; } } ans = min ( minn , ( long long ) m / movs * k ) ; } cout << ans << endl ; return 0 ; }
TAB1 let a , b , s be long long int ; TAB1 read a , b , s ; TAB1 if s < ( abs ( a ) + abs ( b ) ) OR ( ( s - abs ( a ) - abs ( b ) ) % 2 ) ; TAB2 print No and end line ; TAB1 if last statement was false ; TAB2 print Yes and end line ;	int main ( ) { long long int a , b , s ; cin >> a >> b >> s ; if ( s < ( abs ( a ) + abs ( b ) ) || ( ( s - abs ( a ) - abs ( b ) ) % 2 ) ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB0 ab1 , ba1 , ab2 , ba2 = false ; TAB1 s = string ; TAB1 read s ; TAB1 n = size of s ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' and not ab1 ; TAB3 ab1 = true ; TAB3 increment i ; TAB2 else if s [ i ] is ' B ' and s [ i + 1 ] is ' A ' and ab1 ; TAB3 ba1 = true ; TAB3 increment i ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if s [ i ] is ' B ' and s [ i + 1 ] is ' A ' and not ba2 ; TAB3 ba2 = true ; TAB3 increment i ; TAB2 else if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' and ba2 ; TAB3 ab = true ; TAB3 increment i ; TAB1 if ab1 and ba1 ; TAB2 print " YES " ; TAB1 else if ab2 and ba2 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	bool ab1 = false , ba1 = false , ab2 = false , ba2 = false ; int main ( ) { string s ; cin >> s ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' && ! ab1 ) { ab1 = true ; i ++ ; } else if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' && ab1 ) { ba1 = true ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' && ! ba2 ) { ba2 = true ; i ++ ; } else if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' && ba2 ) { ab2 = true ; i ++ ; } } if ( ab1 && ba1 ) cout << " YES\n " ; else if ( ab2 && ba2 ) cout << " YES\n " ; else cout << " NO\n " ; }
TAB0 MAXN = constant integer = 100000 ; TAB0 MOD = constant long long = 1000000009 ; TAB0 in function poww_mod with arguments long long a and long long b that returns long long ; TAB1 ans = long long = 1 ; TAB1 a = a modulo MOD ; TAB1 while b is nonzero ; TAB2 if b ends in a one in bits , then ans = ( a * ans ) modulo MOD ; TAB2 a = ( a * a ) modulo MOD ; TAB2 b shifted by one bit to the right ; TAB1 return ans modulo MOD ; TAB0 in function inv with arguments of long long t and long long p that returns a long long ; TAB1 t = t modulo p ; TAB1 return 1 if t is 1 else return ( p - p / t ) * ( call inv with arguments of p modulo t and p ) modulo p ; TAB0 n = integer = 0 , k = integer = 0 , a = integer = 0 , b = integer = 0 ; TAB0 ans = long long array of size MAX + 5 , answer = long long = 0 ; TAB0 s = string ; TAB1 read n , a , b , k ; TAB1 read s ; TAB1 pre = long long = 0 ; TAB1 while k < 10000 and k < n ; TAB2 k = k * 2 ; TAB2 s = s + s ; TAB1 for i = 0 to k exclusive ; TAB2 if s [ i ] is + ; TAB3 ans [ i ] = pre + ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) modulo MOD ; TAB2 else ; TAB3 ans [ i ] = pre - ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) modulo MOD ; TAB2 pre = ans [ i ] ; TAB1 if n < k ; TAB2 if ans [ n ] < 0 , then ans [ n ] = ans [ n ] + mod ; TAB2 print ans [ n ] ; TAB1 else ; TAB2 beishu = integer = n / k ; TAB2 save = integer = n - n / k ; TAB2 mode = long long = ( call poww_mod with arguments of b , k ) * ( inverse of arguments of ( the result of calling poww_mod with arguments of a , k ) , i ) MOD ) modulo MOD ; TAB2 answer = pre ; TAB2 for i = 1 to beishu exclusive ; TAB3 pre = ( pre * mode ) modulo MOD ; TAB3 answer = ( answer + pre ) modulo MOD ; TAB2 for i = n / k * k to n inclusive ; TAB3 if s [ i modulo k ] is + ; TAB4 answer = ( answer + ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) ) modulo MOD ; TAB3 else ; TAB4 answer = ( answer - ( call poww_mod with arguments of a , n - i ) * ( call poww_mod with arguments of b , i ) ) modulo MOD ; TAB2 if answer < 0 , then answer = answer + MOD ; TAB2 print answer ;	const int MAXN = 100000 ; const long long MOD = 1000000009 ; long long poww_mod ( long long a , long long b ) { long long ans = 1 ; a = a % MOD ; while ( b ) { if ( b & 1 ) ans = ( a * ans ) % MOD ; a = ( a * a ) % MOD ; b >>= 1 ; } return ans % MOD ; } long long inv ( long long t , long long p ) { t = t % p ; return t == 1 ? 1 : ( p - p / t ) * inv ( p % t , p ) % p ; } int n = 0 , k = 0 , a = 0 , b = 0 ; long long ans [ MAXN + 5 ] , answer = 0 ; string s ; int main ( ) { cin >> n >> a >> b >> k ; cin >> s ; long long pre = 0 ; while ( k < 10000 && k < n ) { k = k * 2 ; s = s + s ; } for ( int i = 0 ; i < k ; ++ i ) { if ( s [ i ] == ' + ' ) ans [ i ] = ( pre + poww_mod ( a , n - i ) * poww_mod ( b , i ) ) % MOD ; else ans [ i ] = ( pre - poww_mod ( a , n - i ) * poww_mod ( b , i ) ) % MOD ; pre = ans [ i ] ; } if ( n < k ) { if ( ans [ n ] < 0 ) ans [ n ] += MOD ; cout << ans [ n ] << endl ; } else { int beishu = n / k ; int save = n - n / k ; long long mode = ( poww_mod ( b , k ) * inv ( poww_mod ( a , k ) , MOD ) ) % MOD ; answer = pre ; for ( int i = 1 ; i < beishu ; ++ i ) { pre = ( pre * mode ) % MOD ; answer = ( answer + pre ) % MOD ; } for ( int i = ( n / k ) * k ; i <= n ; ++ i ) { if ( s [ i % k ] == ' + ' ) answer = ( answer + poww_mod ( a , n - i ) * poww_mod ( b , i ) ) % MOD ; else answer = ( answer - poww_mod ( a , n - i ) * poww_mod ( b , i ) ) % MOD ; } if ( answer < 0 ) answer += MOD ; cout << answer << endl ; } }
TAB1 create integers n , f , cnt , i1 , i2 with f = 0 , cnt = 0 ; TAB1 create strings s , s1 ; TAB1 read s read s1 ; TAB1 if size of s is not size of s1 ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 for i = 0 to size of s exclusive ; TAB3 if s [ i ] is not s1 [ i ] ; TAB4 if not f ; TAB5 set i1 to i , set f to 1 ; TAB4 else ; TAB5 set i2 to i ; TAB4 increment cnt ; TAB2 if cnt is not 2 ; TAB3 print " NO " print newline ; TAB2 else ; TAB3 if s [ i2 ] is s1 [ i1 ] and s [ i1 ] is s1 [ i2 ] ; TAB4 print " YES " print newline ; TAB3 else ; TAB4 print " NO " print newline ;	int main ( ) { int n , f = 0 , cnt = 0 , i1 , i2 ; string s , s1 ; cin >> s >> s1 ; if ( s . size ( ) != s1 . size ( ) ) cout << " NO " << endl ; else { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != s1 [ i ] ) { if ( ! f ) i1 = i , f = 1 ; else i2 = i ; cnt ++ ; } } if ( cnt != 2 ) cout << " NO " << endl ; else { if ( s [ i2 ] == s1 [ i1 ] && s [ i1 ] == s1 [ i2 ] ) cout << " YES " << endl ; else cout << " NO " << endl ; } } }
TAB0 declare integers a , b , c , d ; TAB0 declare check with integers t1 , t2 as arguments , returning integer ; TAB1 if t1 is less than t2 ; TAB2 return 1 from function ; TAB1 else if t1 is greater than t2 ; TAB2 return - 1 ; TAB1 read a , b , c , d ; TAB1 declare x = 0 , y = 0 as integers ; TAB1 declare t1 = b , t2 = b as integers ; TAB1 while true ; TAB2 if run check ( t1 , t2 ) is 1 ; TAB3 increment t1 by a ; TAB3 increment x ; TAB2 if run check ( t1 , t2 ) is - 1 ; TAB3 increment t2 by c ; TAB3 increment y ; TAB2 if result of run check ( t1 , t2 ) is 0 ; TAB3 print t1 , newline ; TAB3 break loop ; TAB2 if x is greater than 100 or y is greater than 100 ; TAB3 print " - 1 " and newline ;	int a , b , c , d ; int check ( int t1 , int t2 ) { if ( t1 < t2 ) return 1 ; else if ( t1 > t2 ) return - 1 ; return 0 ; } int main ( ) { cin >> a >> b >> c >> d ; int x = 0 , y = 0 ; int t1 = b , t2 = d ; while ( true ) { if ( check ( t1 , t2 ) == 1 ) { t1 += a ; x ++ ; } if ( check ( t1 , t2 ) == - 1 ) { t2 += c ; y ++ ; } if ( check ( t1 , t2 ) == 0 ) { cout << t1 << endl ; break ; } if ( x > 100 || y > 100 ) { cout << " -1 " << endl ; return 0 ; } } }
TAB0 arr = integer array of size 100 = { 0 } ; TAB0 str = string array of size 6 with str = { ABC , ACB , BAC , BCA , CAB , CBA } ; TAB0 function CheckStr takes string s ; TAB0 function Grow takes string s , char c ; TAB0 function CheckStr takes string s ; TAB1 D = bool with D = false ; TAB1 for i = 0 to 5 ; TAB2 if s . find ( str [ i ] ) is not string npos ; TAB3 D = true ; TAB3 print Yes ; TAB3 break loop ; TAB1 if not D , print No ; TAB0 function Grow takes string s , char c ; TAB1 s = string ; TAB1 while ( read s ) , call s on CheckStr ;	int arr [ 100 ] = { 0 } ; string str [ 6 ] = { " ABC " , " ACB " , " BAC " , " BCA " , " CAB " , " CBA " } ; void CheckStr ( string s ) ; void Grow ( string s , char c ) ; void CheckStr ( string s ) { bool D = false ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( s . find ( str [ i ] ) != string :: npos ) { D = true ; cout << " Yes\n " ; break ; } } if ( ! D ) { cout << " No\n " ; } } void Grow ( string s , char c ) { } int main ( ) { string s ; while ( cin >> s ) { CheckStr ( s ) ; } }
TAB1 declare long long n ; TAB1 input n ; TAB1 declare char array mat with n and n indices ; TAB1 loop i through 0 and one less than n ; TAB2 loop j through 0 and 1 less than n , inputting mat at indices i and j ; TAB1 set bools col_x and row_x to be false ; TAB1 loop i between 0 and one less than n ; TAB2 declare long long cnt to be 0 ; TAB2 loop j from 0 to one less than n ; TAB3 if mat at i and j is E then increment cnt ; TAB2 if cnt equals n ; TAB3 set row_x true ; TAB3 break ; TAB1 loop i between 0 and one less than n ; TAB2 declare long long cnt to be 0 ; TAB2 loop j between 0 and one less than n ; TAB3 if mat at j and i is E increment cnt ; TAB2 if cnt equals n ; TAB3 set col__x to true ; TAB3 break ; TAB1 if both col_x and row_x are true ; TAB2 output - 1 and a newline ; TAB1 otherwise if row_x is true ; TAB2 loop i from 0 to one less than n ; TAB3 loop j from 0 to one less than n ; TAB4 if mat at j and i equals . ; TAB5 output j plus 1 , a space , i plus one , and a newline ; TAB5 break ; TAB1 else ; TAB2 loop i from 0 to one less than n ; TAB3 loop j from 0 to one less than n ; TAB4 if mat at i and j is . ; TAB5 output i plus 1 , a space , and j plus 1 and a newline ; TAB5 break ;	int main ( ) { long long n ; cin >> n ; char mat [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) cin >> mat [ i ] [ j ] ; bool col_x = false , row_x = false ; for ( int i = 0 ; i < n ; i ++ ) { long long cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] == ' E ' ) cnt ++ ; if ( cnt == n ) { row_x = true ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { long long cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( mat [ j ] [ i ] == ' E ' ) cnt ++ ; if ( cnt == n ) { col_x = true ; break ; } } if ( col_x && row_x ) cout << - 1 << " \n " ; else if ( row_x ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ j ] [ i ] == ' . ' ) { cout << j + 1 << "   " << i + 1 << " \n " ; break ; } } } } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' . ' ) { cout << i + 1 << "   " << j + 1 << " \n " ; break ; } } } } return 0 ; }
TAB0 a = array of integers of size 1005 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read i values into array a ; TAB1 if n = 1 ; TAB2 if a [ 1 ] is true ; TAB3 call puts on " YES " ; TAB2 else ; TAB3 call puts on " NO " ; TAB1 num = integer with num = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if a [ i ] is false , increment num ; TAB1 if num = 1 ; TAB2 call puts on " YES " ; TAB1 else ; TAB2 call puts on " NO " ;	int a [ 1005 ] ; int main ( ) { int n ; cin >> n ; for ( int i = ( 1 ) ; i <= ( n ) ; i ++ ) cin >> a [ i ] ; if ( n == 1 ) { if ( a [ 1 ] ) { puts ( " YES " ) ; } else { puts ( " NO " ) ; } return 0 ; } int num = 0 ; for ( int i = ( 1 ) ; i <= ( n ) ; i ++ ) { if ( ! a [ i ] ) { num ++ ; } } if ( num == 1 ) { puts ( " YES " ) ; } else { puts ( " NO " ) ; } return 0 ; }
TAB0 create constant long long integer array a with size 100005 ; TAB0 create long long integer vector v ; TAB1 create string s ; TAB1 read s ; TAB1 create long long integers n , l , sum , cum , x with n = length of s , sum = 0 , cum = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is ' ( ' ; TAB3 set a [ i ] to - 1 ; TAB2 else if s [ i ] is ' ) ' ; TAB3 set a [ i ] to 1 ; TAB2 else ; TAB3 set a [ i ] to 0 ; TAB1 for i = n - 1 to 0 inclusive , decrementing i ; TAB2 if a [ i ] is 0 ; TAB3 set l to i ; TAB3 break loop ; TAB2 else ; TAB3 increment sum by a [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is 0 and i is not l ; TAB3 set a [ i ] to 1 , increment cum by 1 , add element 1 to end of v ; TAB2 else if a [ i ] is not 0 ; TAB3 increment cum by a [ i ] ; TAB2 else if a [ i ] is 0 and i is l ; TAB3 set x to - ( cum + sum ) ; TAB3 if x is less than or equal to 0 ; TAB4 print " - 1 \ n " ; TAB3 return 0 from function ; TAB4 add element x to end of v ; TAB4 increment cum by x ; TAB2 if cum is greater than 0 ; TAB3 print " - 1 \ n " ; TAB1 for i = 0 to size of v exclusive , print v [ i ] print " \ n " ;	long long int a [ 100005 ] ; vector < long long int > v ; int main ( ) { string s ; cin >> s ; long long int n = s . length ( ) , l , sum = 0 , cum = 0 , x ; for ( long long int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = - 1 ; else if ( s [ i ] == ' ) ' ) a [ i ] = 1 ; else a [ i ] = 0 ; } for ( long long int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] == 0 ) { l = i ; break ; } else sum += a [ i ] ; } for ( long long int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 && i != l ) a [ i ] = 1 , cum += 1 , v . push_back ( 1 ) ; else if ( a [ i ] != 0 ) cum += a [ i ] ; else if ( a [ i ] == 0 && i == l ) { x = - ( cum + sum ) ; if ( x <= 0 ) { cout << " -1\n " ; return 0 ; } else { v . push_back ( x ) ; cum += x ; } } if ( cum > 0 ) { cout << " -1\n " ; return 0 ; } } for ( long long int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " \n " ; }
TAB0 create new strings s and t ; TAB0 declare integer variables l1 and l2 ; TAB0 p is an 2d array of integers with size 10001 by 26 ; TAB1 read s and t and loop further ; TAB2 assign length of s to l1 ; TAB2 change l2 to the length of t ; TAB2 set first sizeof ( p ) bytes at the pointer p to 0 ; TAB2 in a for loop , change i from 0 to 26 exclusive , assigning - 1 to p [ l1 ] [ i ] on each loop ; TAB2 start for loop from j = l1 to 1 inclusive decrementing j ; TAB3 for i from 0 to 26 exclusive ; TAB4 if s [ j ] is equal to i + ' a ' ; TAB5 set p [ j - 1 ] [ i ] to j ; TAB4 else ; TAB5 change p [ j - 1 ] [ i ] to p [ j ] [ i ] ; TAB2 declare new int variables ans = 1 and l = - 2 ; TAB2 in a for loop , change i from 0 to l2 exclusive ; TAB3 if l is equal to - 2 ; TAB4 if s [ 0 ] = t [ i ] ; TAB5 change l to 0 ; TAB4 else ; TAB5 change l to p [ 0 ] [ t [ i ] - ' a ' ] ; TAB4 if l = - 1 ; TAB5 set ans to - 1 ; TAB5 break the loop ; TAB3 else ; TAB4 assign p [ l ] [ t [ i ] - ' a ' ] to l ; TAB4 if l is equal to - 1 ; TAB5 increment ans by one ; TAB5 set l to - 2 ; TAB5 decrement i ; TAB2 print ans ;	string s , t ; int l1 , l2 ; int p [ 10001 ] [ 26 ] ; int main ( ) { while ( cin >> s >> t ) { l1 = s . size ( ) ; l2 = t . size ( ) ; memset ( p , 0 , sizeof ( p ) ) ; for ( int i = 0 ; i < 26 ; i ++ ) p [ l1 ] [ i ] = - 1 ; for ( int j = l1 ; j >= 1 ; j -- ) for ( int i = 0 ; i < 26 ; i ++ ) if ( s [ j ] == i + ' a ' ) p [ j - 1 ] [ i ] = j ; else p [ j - 1 ] [ i ] = p [ j ] [ i ] ; int ans = 1 , l = - 2 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( l == - 2 ) { if ( s [ 0 ] == t [ i ] ) l = 0 ; else l = p [ 0 ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans = - 1 ; break ; } } else { l = p [ l ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans ++ ; l = - 2 ; i -- ; } } } cout << ans << endl ; } }
TAB0 declare function choose , which returns a long long integer and takes long long integers n and m ; TAB1 ans = long long integer set to 0 ; TAB1 num = long long integer set to 1 ; TAB1 den = long lon integer set to 1 ; TAB1 for i = 0 to m exclusive ; TAB2 multiply num by n - i ; TAB2 set num to num / i + 1 ; TAB1 return num ; TAB0 declare isPrime which returns a boolean and takes in an integer n ; TAB1 if n < = 1 return false ; TAB1 if n < = 3 return true ; TAB1 if n modulo 2 is 0 or n modulo 3 is 0 , return false ; TAB1 for i = 5 and i * i < = n , while incrementing by 6 ; TAB2 if n modulo i is 0 or n modulo i + 2 is 0 , return false ; TAB1 return true ; TAB0 declare gcd returns a long long integer and takes long long integers a and b ; TAB1 if a is 0 ; TAB2 return b ; TAB1 else ; TAB2 return gcd of b modulo a and a ; TAB1 i , j , k , n , m , t = long long integers ; TAB1 a , b , c , d , ans , max1 , min 2 = long long integers with ans set to 0 ; TAB1 read a , b , c , d , k ; TAB1 if a > = c ; TAB2 set max1 to a ; TAB1 else ; TAB2 set max1 to c ; TAB1 if b > = d ; TAB2 set min2 to d ; TAB1 else ; TAB2 set min2 to b ; TAB1 if max1 > min2 ; TAB2 print 0 ; TAB1 else ; TAB2 if max1 < = min2 ; TAB3 if k > min2 or k < max1 ; TAB4 print min2 - max1 + 1 ; TAB3 else ; TAB4 print min2 - max1 ;	long long int choose ( long long int n , long long int m ) { long long int ans = 0 ; long long int num = 1 ; long long int den = 1 ; for ( long long int i = 0 ; i < m ; i ++ ) { num *= ( n - i ) ; num = num / ( i + 1 ) ; } return num ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; } return true ; } long long int gcd ( long long int a , long long int b ) { if ( a == 0 ) { return b ; } else { return gcd ( b % a , a ) ; } } int main ( ) { long long int i , j , k , n , m , t ; long long int a , b , c , d , ans = 0 , max1 , min2 ; cin >> a >> b >> c >> d >> k ; if ( a >= c ) { max1 = a ; } else { max1 = c ; } if ( b >= d ) { min2 = d ; } else { min2 = b ; } if ( max1 > min2 ) { cout << 0 << endl ; return 0 ; } else { if ( max1 <= min2 ) { if ( k > min2 || k < max1 ) { cout << min2 - max1 + 1 << endl ; } else { cout << min2 - max1 << endl ; } } } return 0 ; }
TAB1 s1 = string ; TAB1 while read s1 ; TAB2 if length of s1 < 3 ; TAB3 print " NO " ; TAB2 else ; TAB3 a = position of " AB " in s1 ; TAB3 b = position of " BA " in s1 starting from a + 2 ; TAB3 c = position of " BA " in s1 ; TAB3 d = position of " AB " in s1 starting from c + 2 ; TAB3 if a is not - 1 and b is not - 1 or c is not - 1 and d is not - 1 ; TAB4 print " YES " ; TAB3 else ; TAB4 print " NO " ;	int main ( ) { string s1 ; while ( cin >> s1 ) { if ( s1 . length ( ) < 3 ) cout << " NO " << endl ; else { int a = s1 . find ( " AB " ) ; int b = s1 . find ( " BA " , a + 2 ) ; int c = s1 . find ( " BA " ) ; int d = s1 . find ( " AB " , c + 2 ) ; if ( a != - 1 && b != - 1 || c != - 1 && d != - 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; } } return 0 ; }
TAB0 s = 2d integer array of size [ 101 ] [ 101 ] ; TAB1 n , a , r = integers ; TAB1 read n ; TAB1 a = 100 ; TAB1 while ( a * ( a - 1 ) * ( a - 2 ) / 6 > n ) decrement a ; TAB1 n = n - a * ( a - 1 ) * ( a - 2 ) / 6 ; TAB1 r = a ; TAB1 for i = 1 to a exclusive ; TAB2 for j = i + 1 to a , s [ i ] [ j ] = s [ j ] [ i ] = 1 ; TAB1 for i = a down to 2 ; TAB2 while n > = i * ( i - 1 ) / 2 ; TAB3 n = n - i * ( i - 1 ) / 2 ; TAB3 increment r ; TAB3 for j = 1 to i , s [ r ] [ j ] = s [ j ] [ r ] = 1 ; TAB1 print r ; TAB1 for i = 1 to r ; TAB2 for j = 1 to r , print s [ i ] [ j ] ; TAB2 print new line ;	int s [ 101 ] [ 101 ] ; int main ( ) { int n , a , r ; cin >> n ; a = 100 ; while ( a * ( a - 1 ) * ( a - 2 ) / 6 > n ) a -- ; n -= a * ( a - 1 ) * ( a - 2 ) / 6 ; r = a ; for ( int i = 1 ; i < a ; i ++ ) for ( int j = i + 1 ; j <= a ; j ++ ) s [ i ] [ j ] = s [ j ] [ i ] = 1 ; for ( int i = a ; i >= 2 ; i -- ) { while ( n >= i * ( i - 1 ) / 2 ) { n -= i * ( i - 1 ) / 2 ; r ++ ; for ( int j = 1 ; j <= i ; j ++ ) { s [ r ] [ j ] = s [ j ] [ r ] = 1 ; } } } cout << r << endl ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= r ; j ++ ) { cout << s [ i ] [ j ] ; } cout << endl ; } return 0 ; }
TAB0 declare constant integer max_n = 2e2 ; TAB0 declare integer array a size max_n ; TAB0 declare integers n , m , cnt , mx , ans ; TAB1 read n , m ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 let mx be maximum of mx and a [ i ] ; TAB1 let mx be ( mx + m - 1 ) / m ; TAB1 for j = 0 to mx exclusive ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] is greater than 0 ; TAB4 decrement a [ i ] by m ; TAB4 if a [ i ] is less than or equal to 0 , let ans be i ; TAB1 print ans + 1 and ' \ n ' ;	const int max_n = 2e2 ; int a [ max_n ] ; int n , m , cnt , mx , ans ; int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; mx = max ( mx , a [ i ] ) ; } mx = ( mx + m - 1 ) / m ; for ( int j = 0 ; j < mx ; j ++ ) for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { a [ i ] -= m ; if ( a [ i ] <= 0 ) ans = i ; } } cout << ans + 1 << ' \n ' ; return 0 ; }
TAB1 let s , t , and x be integers ; TAB1 read in s , t and x and continue looping ; TAB2 if x is less than s + t ; TAB3 if x is equal to s ; TAB4 print YES ; TAB3 or else ; TAB4 print NO ; TAB2 or else ; TAB3 if ( x - s ) % t is equal to 0 or ( x - s - 1 ) % t is equal to 0 ; TAB4 print YES ; TAB3 or else ; TAB4 print NO ;	int main ( ) { int s , t , x ; while ( cin >> s >> t >> x ) { if ( x < s + t ) { if ( x == s ) cout << " YES " << endl ; else cout << " NO " << endl ; } else { if ( ( x - s ) % t == 0 || ( x - s - 1 ) % t == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; } } return 0 ; }
TAB0 create long longs N , M and K ; TAB1 read N , M and K ; TAB1 if N - 1 + M - 1 is less than K ; TAB2 print - 1 ; TAB1 declare long long variable ans = 0 ; TAB1 if K > = M - 1 ; TAB2 declare long long hori = K - ( M - 1 ) ; TAB2 create long long rows = N / ( hori + 1 ) ; TAB2 assign max of ans and rows to ans ; TAB1 else ; TAB2 set ans to max of ans and N * ( M / ( K + 1 ) ) ; TAB1 swap N and M ; TAB1 if K > = M - 1 ; TAB2 declare long long variable hori = K - ( M - 1 ) ; TAB2 create long long rows = N / ( hori + 1 ) ; TAB2 set ans to max of ans and rows ; TAB1 else ; TAB2 change ans to max of ans and N * ( M / ( K + 1 ) ) ; TAB1 print ans ;	long long N , M , K ; int main ( ) { cin >> N >> M >> K ; if ( N - 1 + M - 1 < K ) { cout << - 1 << endl ; return 0 ; } long long ans = 0 ; if ( K >= M - 1 ) { long long hori = K - ( M - 1 ) ; long long rows = N / ( hori + 1 ) ; ans = max ( ans , rows ) ; } else ans = max ( ans , N * ( M / ( K + 1 ) ) ) ; swap ( N , M ) ; if ( K >= M - 1 ) { long long hori = K - ( M - 1 ) ; long long rows = N / ( hori + 1 ) ; ans = max ( ans , rows ) ; } else ans = max ( ans , N * ( M / ( K + 1 ) ) ) ; cout << ans << endl ; return 0 ; }
TAB1 t1 , t2 , x1 , x2 , t0 , res_x , res_y = long long ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 t , ct = double with ct = 1e99 ; TAB1 while ( x1 > = 0 and x2 > = 0 ) ; TAB2 t = ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if ( t < t0 ) ; TAB3 decrement x1 ; TAB3 continue next iteration ; TAB2 if ( t < ct ) ; TAB3 ct = t ; TAB3 res_x = x1 ; TAB3 res_y = x2 ; TAB2 decrement x2 ; TAB1 print res_x , ' ' , res_y ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; double t , ct = 1e99 ; while ( x1 >= 0 && x2 >= 0 ) { t = ( t1 * x1 + t2 * x2 * 1.0 ) / ( x1 + x2 ) ; if ( t < t0 ) { x1 -- ; continue ; } if ( t < ct ) { ct = t ; res_x = x1 ; res_y = x2 ; } x2 -- ; } cout << res_x << '   ' << res_y << endl ; }
TAB0 bool function isP with int argument n ; TAB1 return false if n is even and n ! = 2 ; TAB1 for i from 3 , while i * i < = n , increment i b y2 ; TAB2 if n % i = 0 , return false ; TAB1 return true ; TAB1 create integers n , m , cn , cm and gc ; TAB1 read standard input to n ; TAB1 in a for loop , change i from 1 to 1000 inclusive incrementing i ; TAB2 if isP ( n * i + 1 ) returned false ; TAB3 print i ;	bool isP ( int n ) { if ( n % 2 == 0 && n != 2 ) { return false ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { return false ; } } return true ; } int main ( ) { int n , m , cn , cm , gc ; cin >> n ; for ( int i = 1 ; i <= 1000 ; i ++ ) { if ( ! isP ( n * i + 1 ) ) { cout << i << endl ; return 0 ; } } return 0 ; }
TAB0 in function g that takes integer a and return integer ; TAB1 if a is negative , return - a ; TAB1 return a ; TAB0 n , x , y , xx , yy , l are integers ; TAB1 read n , x , y , xx , yy , and l ; TAB1 if x is false ; TAB2 if xx is false ; TAB3 set l to call function g with argument y - yy ; TAB2 else ; TAB3 if xx equals n ; TAB4 set l to call function min with arguments y + yy + n , n - y + n - yy + n ; TAB3 else ; TAB4 if yy is false ; TAB5 set l to y + xx ; TAB4 else ; TAB5 set l to n - y + xx ; TAB1 else ; TAB2 if y is false ; TAB3 if xx is false ; TAB4 assign yy + x to l ; TAB3 else ; TAB4 if xx is equal to n ; TAB5 assign yy + n - x to l ; TAB4 else ; TAB5 if yy is false ; TAB6 set l to call function g with argument x - xx ; TAB5 else ; TAB6 set l to call function min with arguments x + xx + n , n - x + n - xx + n ; TAB2 else ; TAB3 if x equals n ; TAB4 if xx is false ; TAB5 set l to call function min with arguments y + yy + n , n - y + n - yy + n ; TAB4 else ; TAB5 if xx equals n ; TAB6 set l to call function g with argument y - yy ; TAB5 else ; TAB6 if yy is false ; TAB7 assign n - xx + y to l ; TAB6 else ; TAB7 assign n - xx + n - y to l ; TAB3 else ; TAB4 if xx is false ; TAB5 assign n - yy + x to l ; TAB4 else ; TAB5 if xx equals n ; TAB6 assign n - x + n - yy to l ; TAB5 else ; TAB6 if yy is false ; TAB7 set l to call function min with arguments x + xx + n , n - x + n - xx + n ; TAB6 else ; TAB7 set l to call function g with argument xx - x ; TAB1 display 1 ;	int g ( int a ) { if ( a < 0 ) { return - a ; } return a ; } int n , x , y , xx , yy , l ; int main ( ) { cin >> n >> x >> y >> xx >> yy ; if ( ! x ) { if ( ! xx ) { l = g ( y - yy ) ; } else { if ( xx == n ) { l = min ( y + yy + n , n - y + n - yy + n ) ; } else { if ( ! yy ) { l = y + xx ; } else { l = n - y + xx ; } } } } else { if ( ! y ) { if ( ! xx ) { l = yy + x ; } else { if ( xx == n ) { l = yy + n - x ; } else { if ( ! yy ) { l = g ( x - xx ) ; } else { l = min ( x + xx + n , n - x + n - xx + n ) ; } } } } else { if ( x == n ) { if ( ! xx ) { l = min ( y + yy + n , n - y + n - yy + n ) ; } else { if ( xx == n ) { l = g ( y - yy ) ; } else { if ( ! yy ) { l = n - xx + y ; } else { l = n - xx + n - y ; } } } } else { if ( ! xx ) { l = n - yy + x ; } else { if ( xx == n ) { l = n - x + n - yy ; } else { if ( ! yy ) { l = min ( x + xx + n , n - x + n - xx + n ) ; } else { l = g ( xx - x ) ; } } } } } } cout << l << endl ; return 0 ; }
TAB0 function solve with unsigned long long argument x that returns unsigned long long ; TAB1 new unsigned long longs ans , f , e and xx where ans = 0 and xx = x ; TAB1 if x is less than 10 , return x ; TAB1 change e to x % 10 ; TAB1 while x ! = 0 ; TAB2 assign x modulo 10 to f ; TAB2 divide x by 10 ; TAB1 if f < = e ; TAB2 set ans to 9 + xx / 10 ; TAB1 else ; TAB2 change ans to 8 + xx / 10 ; TAB1 return ans ; TAB1 declare unsigned long longs a and b ; TAB1 read input to a and b ; TAB1 print solve ( b ) - solve ( a - 1 ) ;	unsigned long long solve ( unsigned long long x ) { unsigned long long ans = 0 , f , e , xx = x ; if ( x < 10 ) return x ; e = x % 10 ; while ( x ) { f = x % 10 ; x /= 10 ; } if ( f <= e ) ans = 9 + xx / 10 ; else ans = 8 + xx / 10 ; return ans ; } int main ( ) { unsigned long long a , b ; cin >> a >> b ; cout << solve ( b ) - solve ( a - 1 ) << endl ; return 0 ; }
TAB0 declare constant integer maxn = 110 ; TAB0 declare integer arrays a size maxn , b size maxn ; TAB0 declare integer array vis size 1010 ; TAB1 declare integer n ; TAB1 declare integer cnt = 0 ; TAB1 read n ; TAB1 set bytes from vis to size of vis to value 0 ; TAB1 for i = 0 to n exclusive , read a [ i ] and b [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if i is j , end current loop iteration ; TAB3 if a [ i ] is b [ j ] , let vis [ i ] be 1 ; TAB1 for i = 0 to n exclusive ; TAB2 if vis [ i ] is 1 , increment cnt ; TAB1 print n - cnt and newline ;	const int maxn = 110 ; int a [ maxn ] , b [ maxn ] ; int vis [ 1010 ] ; int main ( ) { int n ; int cnt = 0 ; cin >> n ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] == b [ j ] ) vis [ i ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 1 ) cnt ++ ; } cout << n - cnt << endl ; return 0 ; }
TAB1 declare integers a , b , c , d , e , f ; TAB1 read a and b and c and d and e and f ; TAB1 if a * c * e is 0 and b * d * f is 0 ; TAB2 if d is 0 ; TAB3 print " Hermione \ n " ; TAB2 else if b is 0 ; TAB3 if c is 0 ; TAB4 print " Ron \ n " ; TAB3 else ; TAB4 print " Hermione \ n " ; TAB2 else ; TAB3 if a is 0 or c is 0 ; TAB4 print " Ron \ n " ; TAB3 else ; TAB4 print " Hermione \ n " ; TAB1 else ; TAB2 if b * d * f is greater than a * c * e ; TAB3 print " Ron \ n " ; TAB2 else ; TAB3 print " Hermione \ n " ;	int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( a * c * e == 0 && b * d * f == 0 ) { if ( d == 0 ) cout << " Hermione\n " ; else if ( b == 0 ) { if ( c == 0 ) cout << " Ron\n " ; else cout << " Hermione\n " ; } else { if ( a == 0 || c == 0 ) cout << " Ron\n " ; else cout << " Hermione\n " ; } } else { if ( b * d * f > a * c * e ) cout << " Ron\n " ; else cout << " Hermione\n " ; } }
TAB0 M = const integer with M = 500010 ; TAB0 a = string array of size M ; TAB0 dp = integer array of size [ 26 ] [ 26 ] ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 1 to n , read s [ i ] ; TAB1 for i = 1 to n ; TAB2 t = string with t = s [ i ] ; TAB2 tlen = integer with tlen = t . length ( ) ; TAB2 s1 = integer with s1 = t [ 0 ] - a ; TAB2 e1 = integer with e1 = t [ tlen - 1 ] - a ; TAB2 for j = 0 to 25 ; TAB3 if ( dp [ j ] [ s1 ] > 0 and dp [ j ] [ s1 ] + tlen > dp [ j ] [ e1 ] ) , dp [ j ] [ e1 ] = dp [ j ] [ s1 ] + tlen ; TAB2 if ( tlen > dp [ s1 ] [ e1 ] ) , dp [ s1 ] [ e1 ] = tlen ; TAB1 ans = integer with ans = 0 ; TAB1 for i = 0 to 25 , ans = max of ans and dp [ i ] [ i ] ; TAB1 print ans ;	const int M = 500000 + 10 ; string s [ M ] ; int dp [ 26 ] [ 26 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> s [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) { string t = s [ i ] ; int tlen = t . length ( ) ; int s1 = t [ 0 ] - ' a ' ; int e1 = t [ tlen - 1 ] - ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( dp [ j ] [ s1 ] > 0 && dp [ j ] [ s1 ] + tlen > dp [ j ] [ e1 ] ) { dp [ j ] [ e1 ] = dp [ j ] [ s1 ] + tlen ; } } if ( tlen > dp [ s1 ] [ e1 ] ) { dp [ s1 ] [ e1 ] = tlen ; } } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { ans = max ( ans , dp [ i ] [ i ] ) ; } cout << ans << endl ; return 0 ; }
TAB0 maxn = const int with maxn = 10005 ; TAB0 n , m , k , minn = long long with minn = 1e8 and arr = long long array of size maxn ; TAB1 read n then m then k ; TAB1 for i = 0 to n ; TAB2 read arr [ i ] ; TAB2 if not ( i bitwise - and 1 ) set minn to min of minn , arr [ i ] ; TAB1 if not ( n bitwise - and 1 ) or m < ( n / 2 + 1 ) ; TAB2 print " 0 " ; TAB1 print min of minn , m / ( n / 2 + 1 ) * k ;	const int maxn = 10005 ; long long n , m , k , arr [ maxn ] , minn = 1e8 ; int main ( ) { cin >> n >> m >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; if ( ! ( i & 1 ) ) minn = min ( minn , arr [ i ] ) ; } if ( ! ( n & 1 ) || m < ( n / 2 + 1 ) ) { cout << " 0\n " ; return 0 ; } cout << min ( minn , m / ( n / 2 + 1 ) * k ) << " \n " ; return 0 ; }
TAB1 create string a ; TAB1 make long long ints b , t , and c = 0 ; TAB1 read a ; TAB1 set b to a . find ( ' = ' ) ; TAB1 set t to b ; TAB1 set b to b + 2 ; TAB1 set b to a . size ( ) - b + 1 ; TAB1 for i = 0 to t exclusive ; TAB2 if a [ i ] is equal to ' | ' , increment c ; TAB1 if c + 1 is equal to b - 1 ; TAB2 print ' | ' ; TAB2 for i = 0 to size of a - 1 exclusive , print a [ i ] ; TAB2 print new line ; TAB1 else if c is equal to b ; TAB2 display a ; TAB1 else if c is equal to b + 2 ; TAB2 create long long z = a . find ( ' + ' ; TAB2 if z is greater than 1 ; TAB3 for i = 1 to size of a exclusive , display a [ i ] ; TAB3 print ' | ' ; TAB2 else do ; TAB3 for i = 0 to a . size ( ) exclusive ; TAB4 if i is equal to z + 1 , continue loop ; TAB4 print a [ i ] ; TAB3 show ' | ' ; TAB1 else do ; TAB2 print " Impossible " ;	int main ( ) { string a ; long long b , t , c = 0 ; getline ( cin , a ) ; b = a . find ( ' = ' ) ; t = b ; b += 2 ; b = a . size ( ) - b + 1 ; for ( long long i = 0 ; i < t ; ++ i ) { if ( a [ i ] == ' | ' ) { c ++ ; } } if ( c + 1 == b - 1 ) { cout << ' | ' ; for ( long long i = 0 ; i < a . size ( ) - 1 ; ++ i ) { cout << a [ i ] ; } cout << endl ; } else if ( c == b ) { cout << a << endl ; } else if ( c == b + 2 ) { long long z = a . find ( ' + ' ) ; if ( z > 1 ) { for ( long long i = 1 ; i < a . size ( ) ; i ++ ) { cout << a [ i ] ; } cout << ' | ' << endl ; } else { for ( long long i = 0 ; i < a . size ( ) ; i ++ ) { if ( i == z + 1 ) { continue ; } cout << a [ i ] ; } cout << ' | ' << endl ; } } else { cout << " Impossible " << endl ; } return 0 ; }
TAB1 n , t = int , cnt = 0 ; TAB1 read n ; TAB1 v = vector of int ; TAB1 q = queue of int ; TAB1 for i = 0 to n exclusive ; TAB2 read t ; TAB2 add t at end of v ; TAB1 sort v in ascending order ; TAB1 for i = 0 to size of v - 1 exclusive ; TAB2 push v [ i ] into q ; TAB2 if q is not empty and first item of q > v [ i + 1 ] ; TAB3 pop first item of q ; TAB3 increment cnt ; TAB1 print cnt ;	int main ( ) { int n , t , cnt = 0 ; cin >> n ; vector < int > v ; queue < int > q ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t ; v . push_back ( t ) ; } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i + 1 < v . size ( ) ; i ++ ) { q . push ( v [ i ] ) ; if ( ! q . empty ( ) && q . front ( ) > v [ i + 1 ] ) { q . pop ( ) ; cnt ++ ; } } cout << cnt << endl ; }
TAB1 let n , count , ret be long integers with count = 0 , ret = 0 ; TAB1 read n ; TAB1 vector < tuple < long long , long long , long long > > data be a vectoe ; TAB1 for i = 0 to n exclusive ; TAB2 let k , a0 , x , y , m , t , a be long integers with t = 0 , a = 0 ; TAB2 read k , a0 , x , y , m ; TAB2 for j = 0 to k exclusive ; TAB3 push_back the value of make_tuple ( t , a0 , i ) into data ; TAB3 a is equal to ( a0 * x + y ) modulo m ; TAB3 if a is less than a0 and j is not equal to k - 1 , increment t by 1 ; TAB3 a0 is equal to a ; TAB2 ret is equal to maximum of ret and t ; TAB1 print ret and newline ; TAB1 sort the values of data from beginning to end ; TAB1 for i = 0 to length of data exclusive , print get < 1 > ( data [ i ] ) and space and get < 2 > ( data [ i ] ) + 1 and newline ;	int main ( ) { long long n , count = 0 , ret = 0 ; cin >> n ; vector < tuple < long long , long long , long long >> data ; for ( int i = 0 ; i < n ; i ++ ) { long long k , a0 , x , y , m , t = 0 , a = 0 ; cin >> k >> a0 >> x >> y >> m ; for ( int j = 0 ; j < k ; j ++ ) { data . push_back ( make_tuple ( t , a0 , i ) ) ; a = ( a0 * x + y ) % m ; if ( a < a0 && j != k - 1 ) { t ++ ; } a0 = a ; } ret = max ( ret , t ) ; } cout << ret << endl ; sort ( data . begin ( ) , data . end ( ) ) ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { cout << get < 1 > ( data [ i ] ) << "   " << get < 2 > ( data [ i ] ) + 1 << endl ; } }
TAB0 create string s ; TAB1 read s ; TAB1 for i = 1 to size of s - 1 exclusive ; TAB2 create integers a , b , c , with a = 0 , b = 0 , c = 0 ; TAB2 if s [ i ] is ' A ' , increment a ; TAB2 if s [ i ] is ' B ' , increment b ; TAB2 if s [ i ] is ' C ' , increment c ; TAB2 if s [ i - 1 ] is ' A ' , increment a ; TAB2 if s [ i - 1 ] is ' B ' , increment b ; TAB2 if s [ i - 1 ] is ' C ' , increment c ; TAB2 if s [ i + 1 ] is ' A ' , increment a ; TAB2 if s [ i + 1 ] is ' B ' , increment b ; TAB2 if s [ i + 1 ] is ' C ' , increment c ; TAB2 if a is 1 and b is 1 and c is 1 ; TAB3 print " Yes " print newline ; TAB1 print " No " print newline ;	string s ; int main ( ) { cin >> s ; for ( int i = 1 ; i < s . size ( ) - 1 ; i ++ ) { int a = 0 , b = 0 , c = 0 ; if ( s [ i ] == ' A ' ) a ++ ; if ( s [ i ] == ' B ' ) b ++ ; if ( s [ i ] == ' C ' ) c ++ ; if ( s [ i - 1 ] == ' A ' ) a ++ ; if ( s [ i - 1 ] == ' B ' ) b ++ ; if ( s [ i - 1 ] == ' C ' ) c ++ ; if ( s [ i + 1 ] == ' A ' ) a ++ ; if ( s [ i + 1 ] == ' B ' ) b ++ ; if ( s [ i + 1 ] == ' C ' ) c ++ ; if ( a == 1 && b == 1 && c == 1 ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; return 0 ; }
TAB1 create long doubles a and b ; TAB1 display fixed and setprecision ( 12 ) ; TAB1 read a and b ; TAB1 if b is greater than a ; TAB2 print - 1 ; TAB1 if a is equal to b ; TAB2 print a ; TAB1 create long double x1 = ( ( ( a - b ) * 0 . 5 ) ) / floor ( ( ( a - b ) * 0 . 5 ) / b ) ; TAB1 make long double x2 = ( ( ( a + b ) * 0 . 5 ) ) / floor ( ( ( a + b ) * 0 . 5 ) / b ) ; TAB1 show min of x1 and x2 ;	int main ( ) { long double a , b ; cout << fixed << setprecision ( 12 ) ; cin >> a >> b ; if ( b > a ) { cout << - 1 << endl ; return 0 ; } if ( a == b ) { cout << a << endl ; return 0 ; } long double x1 = ( ( ( a - b ) * 0.5 ) ) / floor ( ( ( a - b ) * 0.5 ) / b ) ; long double x2 = ( ( ( a + b ) * 0.5 ) ) / floor ( ( ( a + b ) * 0.5 ) / b ) ; cout << min ( x1 , x2 ) << endl ; return 0 ; }
TAB1 declare new long longs ans and n ; TAB1 read n and loop further ; TAB2 if n < = 2 ; TAB3 set ans to n ; TAB2 else if n is odd ; TAB3 change the value of ans to n * ( n - 1 ) * ( n - 2 ) ; TAB2 else ; TAB3 if n cannot be divided by 3 without a remainder ; TAB4 change ans to n * ( n - 1 ) * ( n - 3 ) ; TAB3 else ; TAB4 assign ( n - 1 ) * ( n - 2 ) * ( n - 3 ) to ans ; TAB2 print ans ;	int main ( ) { long long ans , n ; while ( cin >> n ) { if ( n <= 2 ) { ans = n ; } else if ( n % 2 ) { ans = n * ( n - 1 ) * ( n - 2 ) ; } else { if ( n % 3 ) { ans = n * ( n - 1 ) * ( n - 3 ) ; } else { ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; } } cout << ans << endl ; } return 0 ; }
TAB0 SevenPows = integer array which includes = 0 , 7 , 49 , 343 , 2401 , 16807 , 117649 ; TAB0 visited = bool array of size 8 ; TAB0 N , M , dh , dm = integers ; TAB0 in the function Judge that includes integers h and m and returns bool ; TAB1 fill from visited to visited + 8 with false ; TAB1 for i = 0 to dm exclusive ; TAB2 if visited [ m modulo 7 ] , return false ; TAB2 visited [ m modulo 7 ] = true ; TAB2 m = m / 7 ; TAB1 for i = 0 to dh exclusiv ; TAB2 if visited [ h modulo 7 ] , return false ; TAB2 visited [ h modulo 7 ] = true ; TAB2 h = h / 7 ; TAB1 return true ; TAB1 i , j = integer ; TAB1 read N , M ; TAB1 for i = 0 to 6 ; TAB2 if N < = SevenPows [ i ] ; TAB3 dh = i ; TAB3 break loop ; TAB1 if i is 7 ; TAB2 print 0 ; TAB1 for i = 0 to 6 ; TAB2 if M < = SevenPows [ i ] ; TAB3 dm = i ; TAB3 break loop ; TAB1 if i is 7 ; TAB2 print 0 ; TAB1 ans = integer with ans = 0 ; TAB1 for i = 0 to N exclusive ; TAB2 for j = 0 to M exclusive ; TAB3 if Judge ( i , j ) , increment ans ; TAB1 print ans ;	int SevenPows [ ] = { 0 , 7 , 49 , 343 , 2401 , 16807 , 117649 } ; bool visited [ 8 ] ; int N , M , dh , dm ; bool Judge ( int h , int m ) { fill ( visited , visited + 8 , false ) ; for ( int i = 0 ; i < dm ; ++ i ) { if ( visited [ m % 7 ] ) return false ; visited [ m % 7 ] = true ; m /= 7 ; } for ( int i = 0 ; i < dh ; ++ i ) { if ( visited [ h % 7 ] ) return false ; visited [ h % 7 ] = true ; h /= 7 ; } return true ; } int main ( ) { int i , j ; cin >> N >> M ; for ( i = 0 ; i < 7 ; ++ i ) { if ( N <= SevenPows [ i ] ) { dh = i ; break ; } } if ( i == 7 ) { cout << 0 << endl ; return 0 ; } for ( i = 0 ; i < 7 ; ++ i ) { if ( M <= SevenPows [ i ] ) { dm = i ; break ; } } if ( i == 7 ) { cout << 0 << endl ; return 0 ; } int ans = 0 ; for ( i = 0 ; i < N ; ++ i ) { for ( j = 0 ; j < M ; ++ j ) { if ( Judge ( i , j ) ) ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 x , t , a , b , da , db are integers ; TAB0 sum = integer ; TAB1 read x , t , a , b , da , db ; TAB1 if x is 0 ; TAB2 print YES ; TAB1 for i = 0 to t exclusive ; TAB2 for j = 0 to t exclusive ; TAB3 sum1 = integer = a - ( da * i ) ; TAB3 sum2 = integer = b - ( db * j ) ; TAB3 if sum1 is x or sum2 is x or sum1 + sum2 is x ; TAB4 print YES ; TAB1 print NO ;	int x , t , a , b , da , db ; int sum ; int main ( ) { cin >> x >> t >> a >> b >> da >> db ; if ( x == 0 ) { cout << " YES " << endl ; return 0 ; } for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { int sum1 = a - ( da * i ) ; int sum2 = b - ( db * j ) ; if ( sum1 == x || sum2 == x || ( sum1 + sum2 ) == x ) { cout << " YES " << endl ; return 0 ; } } } cout << " NO " << endl ; return 0 ; }
TAB1 create int t ; TAB1 read t ; TAB1 let int array x of size 1000020 ; TAB1 for i = 0 to 1000020 exclusive , set x [ i ] to 0 ; TAB1 for i = 0 to t exclusive ; TAB2 make int temp ; TAB2 read temp ; TAB2 increment x [ temp ] ; TAB1 let int sum = 0 ; TAB1 for i = 0 to 1000020 exclusive ; TAB2 set x [ i + 1 ] to x [ i + 1 ] + ( x [ i ] > > 1 ) ; TAB2 set x [ i ] to ( x [ i ] & 1 ) ; TAB1 for i = 0 to 1000020 exclusive , set sum to sum + x [ i ] ; TAB1 print sum ;	int main ( ) { int t ; cin >> t ; int x [ 1000020 ] ; for ( int i = 0 ; i < 1000020 ; i ++ ) x [ i ] = 0 ; for ( int i = 0 ; i < t ; i ++ ) { int temp ; cin >> temp ; x [ temp ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < 1000020 ; i ++ ) { x [ i + 1 ] += ( x [ i ] >> 1 ) ; x [ i ] = ( x [ i ] & 1 ) ; } for ( int i = 0 ; i < 1000020 ; i ++ ) sum += x [ i ] ; cout << sum << endl ; return 0 ; }
TAB0 declare long long integer mod = 1000000007 ; TAB1 declare long long integers x1 , y1 , x2 , y2 , a , b , c ; TAB1 declare integers n , ans = 0 ; TAB1 read x1 , y1 , x2 , y2 , n ; TAB1 for i = 0 to n exclusive ; TAB2 read a , b , c ; TAB2 declare long long integer val1 = a * x1 + b * y1 + c ; TAB2 declare long long integer val2 = a * x2 + b * y2 + c ; TAB2 if ( val1 is less than 0 and val2 is greater than 0 ) or ( val1 is greater than 0 and val2 is less than 0 ) , increment ans ; TAB1 print ans and newline ;	long long int mod = 1000000007 ; int main ( ) { long long int x1 , y1 , x2 , y2 , a , b , c ; int n , ans = 0 ; cin >> x1 >> y1 >> x2 >> y2 >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b >> c ; long long int val1 = a * x1 + b * y1 + c ; long long int val2 = a * x2 + b * y2 + c ; if ( ( val1 < 0 && val2 > 0 ) || ( val1 > 0 && val2 < 0 ) ) { ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 constant integer INF = 1 < < 29 ; TAB0 create int arrays l , s , r and p with 4 elements ; TAB1 for i from 0 to 4 exclusive , read input to l [ i ] , s [ i ] , r [ i ] and p [ i ] ; TAB1 for i from 0 to 4 exclusive ; TAB2 if p [ i ] is not 0 ; TAB3 if l [ ( i + 1 ) % 4 ] , r [ ( i - 1 + 4 ) % 4 ] or s [ ( i + 2 ) % 4 ] is not 0 ; TAB4 print " YES \ n " ; TAB3 if l [ i ] , r [ i ] or s [ i ] is not 0 ; TAB4 print " YES \ n " ; TAB1 print " NO \ n " ;	const int INF = 1 << 29 ; int l [ 4 ] , s [ 4 ] , r [ 4 ] , p [ 4 ] ; int main ( ) { for ( int i = 0 ; i < 4 ; i ++ ) cin >> l [ i ] >> s [ i ] >> r [ i ] >> p [ i ] ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( p [ i ] ) { if ( l [ ( i + 1 ) % 4 ] || r [ ( i - 1 + 4 ) % 4 ] || s [ ( i + 2 ) % 4 ] ) { cout << " YES\n " ; return 0 ; } if ( l [ i ] || r [ i ] || s [ i ] ) { cout << " YES\n " ; return 0 ; } } } cout << " NO\n " ; return 0 ; }
TAB0 a = int array of size 30 ; TAB1 n = int ; TAB1 read n ; TAB1 if n is 1 ; TAB2 print " Yes " ; TAB1 loop n times ; TAB2 s = char ; TAB2 read s ; TAB2 increment a [ s - 96 ] ; TAB1 flag = int with flag = 0 ; TAB1 for i = 1 to 26 inclusive ; TAB2 if a [ i ] > = 2 increment flag ; TAB1 if flag is 0 ; TAB2 print " No " ; TAB1 else ; TAB2 print " Yes " ;	int a [ 30 ] ; int main ( ) { int n ; cin >> n ; if ( n == 1 ) { cout << " Yes " << endl ; return 0 ; } while ( n -- ) { char s ; cin >> s ; a [ s - 96 ] ++ ; } int flag = 0 ; for ( int i = 1 ; i <= 26 ; i ++ ) if ( a [ i ] >= 2 ) flag += 1 ; if ( flag == 0 ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB1 declare long long array a size 100005 , long longs n , k , m , minn , s , x ; TAB1 read n and m and k ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 if not n % 2 ; TAB2 print 0 and newline ; TAB1 else ; TAB2 let minn be 0 ; TAB2 let s be n / 2 + 1 ; TAB2 if s is greater than m ; TAB3 let minn be 0 ; TAB2 else ; TAB3 let minn be a [ 0 ] ; TAB3 for i = 0 to n inclusive , incrementing i by 2 , let minn be minimum of minn and a [ i ] ; TAB3 let x be m / s * k ; TAB3 let minn be minn and x ; TAB2 print minn and newline ;	int main ( ) { long long a [ 100005 ] , n , k , m , minn , s , x ; cin >> n >> m >> k ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; if ( ! n % 2 ) cout << 0 << endl ; else { minn = 0 ; s = n / 2 + 1 ; if ( s > m ) minn = 0 ; else { minn = a [ 0 ] ; for ( int i = 0 ; i <= n ; i += 2 ) minn = min ( minn , a [ i ] ) ; x = m / s * k ; minn = min ( minn , x ) ; } cout << minn << endl ; } }
TAB0 define function solve which takes in an array of long long integers dif and integer n as arguments ; TAB1 let current_max and max_so_far be integers , set current_max and max_so_far to dif [ 0 ] ; TAB1 for i = 1 to n ; TAB2 set current_max to the max of current_max + dif [ i ] and dif [ i ] ; TAB2 set max_so_far to the min of current_max and max_so_far ; TAB1 return the value of max_so_far from the function ; TAB1 let n be an integer ; TAB1 read in n ; TAB1 let arr and dif be arrays of integers , arr has a size of n and dif has a size of n - 1 ; TAB1 read in n values into array arr ; TAB1 iterate for n - 1 times , set dif [ i ] to ( ( i & 1 ) ? - 1 : 1 ) * ( abs ( arr [ i ] - arr [ i + 1 ] ) ) ; TAB1 let ans be a long long integer and set its value to - 1e18 ; TAB1 set ans to the max of ans and solve ( dif , n - 1 ) ; TAB1 iterate for n - 1 times , set dif [ i ] to dif * - 1 ; TAB1 set ans to the max of ans and solve ( dif , n - 1 ) ; TAB1 print ans and a newline ;	long long int solve ( long long int dif [ ] , int n ) { long long int current_max = dif [ 0 ] , max_so_far = dif [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { current_max = max ( current_max + dif [ i ] , dif [ i ] ) ; max_so_far = max ( current_max , max_so_far ) ; } return max_so_far ; } int main ( ) { int n ; cin >> n ; long long int arr [ n ] , dif [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) cin >> arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) dif [ i ] = ( ( i & 1 ) ? - 1 : 1 ) * ( abs ( arr [ i ] - arr [ i + 1 ] ) ) ; long long int ans = - 1e18 ; ans = max ( ans , solve ( dif , n - 1 ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) dif [ i ] *= - 1 ; ans = max ( ans , solve ( dif , n - 1 ) ) ; cout << ans << " \n " ; }
TAB1 n = integer ; TAB1 read n ; TAB1 a = integer array of size n ; TAB1 banyakyangmilihini = array of vector of integer of size 2001 ; TAB1 inilahhasilnya = integer array of size n = { } ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 append i in banyakyangmilihini [ a [ i ] ] ; TAB1 i = integer with i = 1 ; TAB1 for k = 2000 down to 0 exclusive ; TAB2 if ( banyakyangmilihini [ k ] . size ( ) > 0 ) ; TAB3 for m = 0 to banyakyangmilihini [ k ] . size ( ) exclusive , inilahhasilnya [ banyakyangmilihini [ k ] [ m ] ] = i ; TAB3 i = i + banyakyangmilihini [ k ] . size ( ) ; TAB1 for k = 0 to n exclusive ; TAB2 if ( k is 0 ) ; TAB3 print inilahhasilnya [ k ] ; TAB2 else ; TAB3 print inilahhasilnya [ k ] ; TAB1 print new line ;	int main ( ) { int n ; cin >> n ; int a [ n ] = { } ; vector < int > banyakyangmilihini [ 2001 ] ; int inilahhasilnya [ n ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; banyakyangmilihini [ a [ i ] ] . push_back ( i ) ; } int i = 1 ; for ( int k = 2000 ; k > 0 ; k -- ) { if ( banyakyangmilihini [ k ] . size ( ) > 0 ) { for ( int m = 0 ; m < banyakyangmilihini [ k ] . size ( ) ; m ++ ) { inilahhasilnya [ banyakyangmilihini [ k ] [ m ] ] = i ; } i = i + banyakyangmilihini [ k ] . size ( ) ; } } for ( int k = 0 ; k < n ; k ++ ) { if ( k == 0 ) { cout << inilahhasilnya [ k ] ; } else { cout << "   " << inilahhasilnya [ k ] ; } } cout << endl ; }
TAB0 s = integer array of size 35 ; TAB0 in the function to_int that takes character pointer a , b and returns long long ; TAB1 res = long long with res = 0 ; TAB1 if ( pointer a is 0 and a is not b ) , return - 1 ; TAB1 while ( a is not b + 1 ) ; TAB2 res = ( res * 10 ) + ( a [ 0 ] - 0 ) ; TAB2 if ( res > 1000000 ) , return - 1 ; TAB2 increment a ; TAB1 return res ; TAB1 read s ; TAB1 pointer nd = s + strlen ( s ) - 1 ; TAB1 res = long long with res = - 1 ; TAB1 for pointer p1 = s to p1 [ 2 ] ; TAB2 for pointer p2 = p1 + 1 to p2 [ 1 ] ; TAB3 a , b , c = long long with a = to_int ( s , p1 ) , b = to_int ( p1 + 1 , p2 ) , c = to_int ( p2 + 1 , nd ) ; TAB3 if ( a is - 1 or b is - 1 or c is - 1 ) , continue next iteration ; TAB3 res = max of res and a + b + c ; TAB1 print res ;	char s [ 35 ] ; long long to_int ( char * a , char * b ) { long long res = 0 ; if ( * a == ' 0 ' && a != b ) return - 1 ; while ( a != b + 1 ) { res = ( res * 10 ) + ( a [ 0 ] - ' 0 ' ) ; if ( res > 1000000 ) return - 1 ; a ++ ; } return res ; } int main ( ) { cin >> s ; char * nd = s + strlen ( s ) - 1 ; long long res = - 1 ; for ( char * p1 = s ; p1 [ 2 ] ; p1 ++ ) { for ( char * p2 = p1 + 1 ; p2 [ 1 ] ; p2 ++ ) { long long a = to_int ( s , p1 ) , b = to_int ( p1 + 1 , p2 ) , c = to_int ( p2 + 1 , nd ) ; if ( a == - 1 || b == - 1 || c == - 1 ) continue ; res = max ( res , a + b + c ) ; } } cout << res << endl ; return 0 ; }
TAB0 let gcd be a function which accepts long integers x and y and returns a long integer value ; TAB1 return y if x modulo y = 0 else return gcd of y and x modulo y ; TAB0 let lcm be a function that accepts int x , int y , int z and returns a long integer value ; TAB1 the long integer value of a = ( long long ) x * y / gcd of x and y ; TAB1 a is equal to a * z / gcd of a and z ; TAB1 return the value of a ; TAB1 let n be a integer ; TAB1 read n ; TAB1 the long integer value of ans = 0 ; TAB1 for integer i = max ( 1 , n - 100 ) to n inclusive , increment i by 1 ; TAB2 for integer j = max ( 1 , n - 100 ) to n inclusive , increment j by 1 ; TAB3 for integer k = max ( 1 , n - 100 ) to n inclusive , increment k by 1 , ans is equal to maximum of ans and lcm ( i , j , k ) ; TAB1 print ans and newline ;	long long gcd ( long long x , long long y ) { return x % y == 0 ? y : gcd ( y , x % y ) ; } long long lcm ( int x , int y , int z ) { long long a = ( long long ) x * y / gcd ( x , y ) ; a = a * z / gcd ( a , z ) ; return a ; } int main ( ) { int n ; cin >> n ; long long ans = 0 ; for ( int i = max ( 1 , n - 100 ) ; i <= n ; i ++ ) for ( int j = max ( 1 , n - 100 ) ; j <= n ; j ++ ) for ( int k = max ( 1 , n - 100 ) ; k <= n ; k ++ ) ans = max ( ans , lcm ( i , j , k ) ) ; cout << ans << endl ; return 0 ; }
TAB0 create integers m , h , h2 , a , a2 , x , x2 , y , y2 ; TAB0 declare get with integers s , e as arguments , returning integer ; TAB1 for i = 0 to m exclusive ; TAB2 set s to ( 1ll * s * x + y ) % m ; TAB2 if s is e , return i + 1 ; TAB1 return - 1 from function ; TAB0 declare get2 with integers s , e as arguments , returning integer ; TAB1 for i = 0 to m exclusive ; TAB2 set s to ( 1ll * s * x2 + y2 ) % m ; TAB2 if s is e , return i + 1 from function ; TAB1 return - 1 from function ; TAB1 read m read h read a read x read y read h2 read a2 read x2 read y2 ; TAB1 create integers t , t2 with t = result of run get with h , a as arguments , t2 = result of run get2 with h2 , a2 as arguments ; TAB1 if t is - 1 or t2 is - 1 , return print " - 1 \ n " , 0 from function ; TAB1 if t is t2 , return print t print ' \ n ' , 0 from function ; TAB1 create integers l , l2 with l = result of run get with a , a as arguments , l2 = result of run get2 with a2 , a2 , as arguments ; TAB1 if bitwise not l and t - t2 is greater than or equal to 0 and not ( ( t - t2 ) % l2 ) , return print t print ' \ n ' , 0 from function ; TAB1 if bitwise not l2 and t - t2 is greater than or equal to 0 and not ( ( t - t2 ) % l2 ) , return print t print ' \ n ' , 0 from function ; TAB1 if l is - 1 or l2 is - 1 , return print " - 1 \ n " , 0 ; TAB1 create integer val with val = t2 - t ; TAB1 for i = 1 , lim = m bitshift left 1 to i is less than or equal to lim , incrementing i ; TAB2 if ( val + 1ll * i * l2 is greater than or equal to 0 and not ( ( val + 1ll * i * l2 ) % l ) ) return print 1ll * i * l2 + t2 print ' \ n ' , 0 from function ; TAB1 print " - 1 \ n " ;	int m , h , h2 , a , a2 , x , x2 , y , y2 ; int get ( int s , int e ) { for ( int i = 0 ; i < m ; ++ i ) { s = ( 1ll * s * x + y ) % m ; if ( s == e ) return i + 1 ; } return - 1 ; } int get2 ( int s , int e ) { for ( int i = 0 ; i < m ; ++ i ) { s = ( 1ll * s * x2 + y2 ) % m ; if ( s == e ) return i + 1 ; } return - 1 ; } int main ( ) { cin >> m >> h >> a >> x >> y >> h2 >> a2 >> x2 >> y2 ; int t = get ( h , a ) , t2 = get2 ( h2 , a2 ) ; if ( t == - 1 || t2 == - 1 ) return cout << " -1\n " , 0 ; if ( t == t2 ) return cout << t << ' \n ' , 0 ; int l = get ( a , a ) , l2 = get2 ( a2 , a2 ) ; if ( ~ l && t2 - t >= 0 && ! ( ( t2 - t ) % l ) ) return cout << t2 << ' \n ' , 0 ; if ( ~ l2 && t - t2 >= 0 && ! ( ( t - t2 ) % l2 ) ) return cout << t << ' \n ' , 0 ; if ( l == - 1 || l2 == - 1 ) return cout << " -1\n " , 0 ; int val = t2 - t ; for ( int i = 1 , lim = m << 1 ; i <= lim ; ++ i ) if ( val + 1ll * i * l2 >= 0 && ! ( ( val + 1ll * i * l2 ) % l ) ) return cout << 1ll * i * l2 + t2 << ' \n ' , 0 ; cout << " -1\n " ; return 0 ; }
TAB0 N = 1e2 + 10 = const int ; TAB0 n = int ; TAB0 k = int ; TAB0 let a be an NxN integer matrix ; TAB0 now = int ; TAB0 in void function PRINT that takes n = int ; TAB1 print n ; TAB1 for i = 1 till i < = n ; TAB2 for j = 1 to n inclusive then print a [ i ] [ j ] ; TAB2 print new line ; TAB1 read k ; TAB1 reset a to all 0 ; TAB1 for i = 2 to N inclusive ; TAB2 if ( i * ( i - 1 ) * ( i - 2 ) ) / 6 > k ) then ; TAB3 set n to i - 1 ; TAB3 exit loop ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if i isn ' t j then set a [ i ] [ j ] to 1 ; TAB1 if ( n * ( n - 1 ) * ( n - 2 ) ) / 6 = k ) ; TAB2 call PRINT on n ; TAB1 set now to k - ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; TAB1 while now ; TAB2 lo , hi , mid , tmp = int ; TAB2 set lo = 1 ; TAB2 make hi = 100 ; TAB2 while lo < hi inclusive ; TAB3 set mi to ( lo + hi ) bitwiser right shit 1 ; TAB3 if mid * ( mid - 1 ) bitwise right shift < = now ; TAB4 set tmp to mid ; TAB4 make lo = mid + 1 ; TAB3 else ; TAB4 set hi = mid - 1 ; TAB2 decrement now by tmp * ( tmp - 1 ) bitwise right 1 ; TAB2 increment n ; TAB2 for i = 1 to tmp inclusive , set a [ i ] [ n ] = a [ n ] [ i ] = 1 ; TAB1 call PRINT on n ;	const int N = 1e2 + 10 ; int n ; int k ; int a [ N ] [ N ] ; int now ; void PRINT ( int n ) { cout << n << endl ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) cout << a [ i ] [ j ] ; cout << endl ; } } int main ( ) { cin >> k ; memset ( a , 0 , sizeof ( a ) ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( ( i * ( i - 1 ) * ( i - 2 ) ) / 6 > k ) { n = i - 1 ; break ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i != j ) a [ i ] [ j ] = 1 ; } } if ( ( n * ( n - 1 ) * ( n - 2 ) ) / 6 == k ) { PRINT ( n ) ; return 0 ; } now = k - ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; while ( now ) { int lo , hi , mid , tmp ; lo = 1 ; hi = 100 ; while ( lo <= hi ) { mid = ( lo + hi ) >> 1 ; if ( ( mid * ( mid - 1 ) ) >> 1 <= now ) { tmp = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } now -= ( tmp * ( tmp - 1 ) ) >> 1 ; n += 1 ; for ( int i = 1 ; i <= tmp ; i ++ ) { a [ i ] [ n ] = a [ n ] [ i ] = 1 ; } } PRINT ( n ) ; return 0 ; }
TAB0 let vis be array of integers of size 105 ; TAB1 let n , k be integers ; TAB1 read n and k ; TAB1 let num be integer with num = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 let x be integer ; TAB2 read x ; TAB2 if vis [ x ] is equal to 0 ; TAB3 set vis [ x ] to i + 1 ; TAB3 increment num by 1 ; TAB1 if num is less than k ; TAB2 print NO with newline ; TAB1 else ; TAB2 print YES with newline ; TAB2 let j be integer with j = 0 ; TAB2 call sort with vis and vis + 101 ; TAB2 for i = 0 to 100 inclusive ; TAB3 if vis [ i ] is equal to zero ; TAB4 if k is equal to 1 ; TAB5 print vis [ i ] with newline ; TAB4 else if k is greater than 1 ; TAB5 print out vis [ i ] + one empty space ; TAB4 else ; TAB5 break ; TAB4 decrement k by 1 ;	int vis [ 105 ] ; int main ( ) { int n , k ; cin >> n >> k ; int num = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int x ; cin >> x ; if ( ! vis [ x ] ) { vis [ x ] = i + 1 ; num ++ ; } } if ( num < k ) cout << " NO\n " ; else { cout << " YES\n " ; int j = 0 ; sort ( vis , vis + 101 ) ; for ( int i = 0 ; i <= 100 ; ++ i ) if ( vis [ i ] ) { if ( k == 1 ) cout << vis [ i ] << endl ; else if ( k > 1 ) cout << vis [ i ] << '   ' ; else break ; k -- ; } } return 0 ; }
TAB0 create integer N , create integer array arr with size 100001 ; TAB0 create 3d long long array dp with size 100001 by 201 by 2 ; TAB1 read N ; TAB1 for i = 1 to N inclusive , read arr [ i ] ; TAB1 for i = 1 to N inclusive ; TAB2 if arr [ i ] is not - 1 ; TAB3 if i is 1 ; TAB4 set dp [ i ] [ arr [ i ] ] [ 0 ] to 1 ; TAB3 else ; TAB4 for j = 1 to arr [ i ] exclusive ; TAB5 increment dp [ i ] [ arr [ i ] ] [ 0 ] by dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; TAB5 set dp [ i ] [ arr [ i ] ] [ 0 ] to dp [ i ] [ arr [ i ] ] [ 0 ] % 998244353 ; TAB4 increment dp [ i ] [ arr [ i ] ] [ 1 ] by dp [ i - 1 ] [ arr [ i ] ] [ 0 ] ; TAB4 set dp [ i ] [ arr [ i ] ] [ 1 ] to dp [ i ] [ arr [ i ] ] [ 1 ] % 998244353 ; TAB4 for j = arr [ i ] to 200 inclusive ; TAB5 increment dp [ i ] [ arr [ i ] ] [ 1 ] by dp [ i - 1 ] [ j ] [ 1 ] ; TAB5 set dp [ i ] [ arr [ i ] ] [ 1 ] to dp [ i ] [ arr [ i ] ] [ 1 ] % 998244353 ; TAB2 else ; TAB3 if i is 1 ; TAB4 for j = 1 to 200 inclusive , set dp [ i ] [ j ] [ 0 ] to 1 ; TAB3 else ; TAB4 create long long temp with temp = 0 ; TAB4 for j = 1 to 200 inclusive ; TAB5 increment dp [ i ] [ j ] [ 1 ] by dp [ i - 1 ] [ j ] [ 0 ] ; TAB5 set dp [ i ] [ j ] [ 1 ] to dp [ i ] [ j ] [ 1 ] % 998244353 ; TAB5 increment dp [ i ] [ j ] [ 0 ] by temp ; TAB5 set dp [ i ] [ j ] [ 0 ] to dp [ i ] [ j ] [ 0 ] % 998244353 ; TAB5 increment temp by dp [ i - 1 ] [ j ] [ 0 ] ; TAB5 set temp to temp % 998244353 ; TAB4 set temp to 0 ; TAB4 for j = 200 to 1 inclusive , decrementing i ; TAB5 increment temp by dp [ i - 1 ] [ j ] [ 1 ] ; TAB5 set temp to temp % 998244353 ; TAB5 increment dp [ i ] [ j ] [ 1 ] by temp ; TAB5 set dp [ i ] [ j ] [ 1 ] to dp [ i ] [ j ] [ 1 ] % 998244353 ; TAB4 set temp to 0 ; TAB4 for j = 1 to 200 inclusive ; TAB5 increment dp [ i ] [ j ] [ 0 ] by temp ; TAB5 set dp [ i ] [ j ] [ 0 ] to dp [ i ] [ j ] [ 0 ] % 998244353 ; TAB5 increment temp by dp [ i - 1 ] [ j ] [ 1 ] ; TAB5 set temp to temp % 998244353 ; TAB1 create long long ans with ans = 0 ; TAB1 for i = 1 to 200 inclusive , set ans to ( ans + dp [ N ] [ i ] [ 1 ] ) % 998244353 ; TAB1 print ans print ' \ n ' ;	int N , arr [ 100001 ] ; long long dp [ 100001 ] [ 201 ] [ 2 ] ; int main ( ) { cin >> N ; for ( int i = 1 ; i <= N ; i ++ ) cin >> arr [ i ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] != - 1 ) { if ( i == 1 ) dp [ i ] [ arr [ i ] ] [ 0 ] = 1 ; else { for ( int j = 1 ; j < arr [ i ] ; j ++ ) { dp [ i ] [ arr [ i ] ] [ 0 ] += dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ arr [ i ] ] [ 0 ] %= 998244353 ; } dp [ i ] [ arr [ i ] ] [ 1 ] += dp [ i - 1 ] [ arr [ i ] ] [ 0 ] ; dp [ i ] [ arr [ i ] ] [ 1 ] %= 998244353 ; for ( int j = arr [ i ] ; j <= 200 ; j ++ ) { dp [ i ] [ arr [ i ] ] [ 1 ] += dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ arr [ i ] ] [ 1 ] %= 998244353 ; } } } else { if ( i == 1 ) { for ( int j = 1 ; j <= 200 ; j ++ ) dp [ i ] [ j ] [ 0 ] = 1 ; } else { long long temp = 0 ; for ( int j = 1 ; j <= 200 ; j ++ ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j ] [ 0 ] ; dp [ i ] [ j ] [ 1 ] %= 998244353 ; dp [ i ] [ j ] [ 0 ] += temp ; dp [ i ] [ j ] [ 0 ] %= 998244353 ; temp += dp [ i - 1 ] [ j ] [ 0 ] ; temp %= 998244353 ; } temp = 0 ; for ( int j = 200 ; j >= 1 ; j -- ) { temp += dp [ i - 1 ] [ j ] [ 1 ] ; temp %= 998244353 ; dp [ i ] [ j ] [ 1 ] += temp ; dp [ i ] [ j ] [ 1 ] %= 998244353 ; } temp = 0 ; for ( int j = 1 ; j <= 200 ; j ++ ) { dp [ i ] [ j ] [ 0 ] += temp ; dp [ i ] [ j ] [ 0 ] %= 998244353 ; temp += dp [ i - 1 ] [ j ] [ 1 ] ; temp %= 998244353 ; } } } } long long ans = 0 ; for ( int i = 1 ; i <= 200 ; i ++ ) ans = ( ans + dp [ N ] [ i ] [ 1 ] ) % 998244353 ; cout << ans << ' \n ' ; return 0 ; }
TAB0 i , j = long longs , cnt = long long = 0 ; TAB0 ar = array of size 100050 ; TAB1 a , b , c , d = integers ; TAB1 read a , b , c , d ; TAB1 for i = b to 1e4 inclusive , i = i + a , then increase ar [ i ] by 1 ; TAB1 for i = d to 1e4 inclusive , i = i + c , then increase ar [ i ] by 1 ; TAB1 tp = integer = larger value between ar and ar + 10001 - ar ; TAB1 of ar [ tp ] is 2 , then print tp and end the program ; TAB1 print - 1 ; TAB1 return 0 ;	long long i , j , cnt = 0 ; int ar [ 100050 ] ; int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; for ( i = b ; i <= 1e4 ; i += a ) { ar [ i ] ++ ; } for ( i = d ; i <= 1e4 ; i += c ) { ar [ i ] ++ ; } int tp = max_element ( ar , ar + 10001 ) - ar ; if ( ar [ tp ] == 2 ) cout << tp << endl , exit ( 0 ) ; cout << - 1 << endl ; return ~ ~ ( 0 ^ 0 ^ 0 ) ; }
TAB0 MaxN = 1E5 + 10 ; TAB0 create int int a [ MaxN ] ; TAB1 create int n ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 ans = 0 ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 lg = log2 ( n - i - 1 ) ; TAB2 set ans to ans + a [ i ] ; TAB2 a [ i + ( 1 < < lg ) ] = a [ i + ( 1 < < lg ) ] + a [ i ] ; TAB2 print ans ;	const int MaxN = 1E5 + 10 ; int a [ MaxN ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int lg = log2 ( n - i - 1 ) ; ans += a [ i ] ; a [ i + ( 1 << lg ) ] += a [ i ] ; cout << ans << endl ; } }
TAB1 create integers n , x1 , y1 , x2 , y2 ; TAB1 create integer l ; TAB1 read n read x1 read y1 read x2 read y2 ; TAB1 if absolute value of ( x1 - x2 ) is n ; TAB2 set l to n + y1 + y2 ; TAB1 else if absolute value of ( y1 - y2 ) is n ; TAB2 set l to n + x1 + x2 ; TAB1 else ; TAB2 set l to absolute value of ( x1 - x2 ) + absolute value of ( y1 - y2 ) ; TAB1 print minimum of ( l and 4 * n - l ) print newline ;	int main ( ) { int n , x1 , y1 , x2 , y2 ; int l ; cin >> n >> x1 >> y1 >> x2 >> y2 ; if ( abs ( x1 - x2 ) == n ) l = n + y1 + y2 ; else if ( abs ( y1 - y2 ) == n ) l = n + x1 + x2 ; else l = abs ( x1 - x2 ) + abs ( y1 - y2 ) ; cout << min ( l , 4 * n - l ) << endl ; return 0 ; }
TAB1 f = array of 200005 characters ; TAB1 n = integer ; TAB1 Read n ; TAB1 Read f ; TAB1 sum1 , sum2 = integers , both set to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if f [ i ] is < ; TAB3 increment sum1 ; TAB2 else do the following ; TAB3 Terminate the loop ; TAB1 for i = n - 1 to 0 exclusive ; TAB2 if f [ i ] is > ; TAB3 increment sum2 ; TAB2 else do the following ; TAB3 Terminate the loop ; TAB1 print sum1 + sum2 and a new line ;	int main ( ) { char f [ 200005 ] ; int n ; cin >> n ; cin >> f ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f [ i ] == ' < ' ) sum1 ++ ; else break ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( f [ i ] == ' > ' ) sum2 ++ ; else break ; } cout << sum1 + sum2 << endl ; return 0 ; }
TAB1 n is an integer ; TAB1 read n ; TAB1 print n / 2 and endline ; TAB1 for integer i = 1 to n / 2 exclusive , print 2and space ; TAB1 if n % 2 is true ; TAB2 print 3 and newline ; TAB1 else ; TAB2 print 2 and newline ;	int main ( ) { int n ; cin >> n ; cout << n / 2 << endl ; for ( int i = 1 ; i < n / 2 ; i ++ ) { cout << 2 << "   " ; } if ( n % 2 ) cout << 3 << endl ; else cout << 2 << endl ; return 0 ; }
TAB0 n , k , ans = long long and arr = long long array of size 100005 ; TAB0 ada = map of long long and bool ; TAB1 read n then k ; TAB1 set ans to 0 ; TAB1 for i = 1 to n inclusive read arr [ i ] ; TAB1 sort arr from position 1 to n + 1 ; TAB1 for i = 1 to n inclusive ; TAB2 if ada [ arr [ i ] ] is false ; TAB3 increment ans ; TAB3 set ada [ arr [ i ] * k ] to true ; TAB1 print ans ;	long long n , k , arr [ 100005 ] , ans ; map < long long , bool > ada ; int main ( ) { cin >> n >> k ; ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> arr [ i ] ; } sort ( arr + 1 , arr + n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! ada [ arr [ i ] ] ) { ans ++ ; ada [ arr [ i ] * k ] = true ; } } cout << ans << " \n " ; }
TAB0 let maxn be const integer with maxn = 1e5 + 10 ; TAB0 let arr be array of booleans of size maxn ; TAB0 let s be string and ss be array of strings of size maxn ; TAB0 let c be char ; TAB0 let n be integer ; TAB0 in function input ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read ss [ i ] ; TAB1 read s , c ; TAB0 in function low which takes char x and returns char ; TAB1 if x is greater than or equal to A and x is less than or equal to Z , update x to x - ' A ' + ' a ' ; TAB1 return x ; TAB1 call input ; TAB1 let w be integer with w = size of s ; TAB1 for i = 0 to n exclusive ; TAB2 for wi = 0 to till wi + size of ss [ i ] - 1 is less than w ; TAB3 let b be boolean with b = true ; TAB3 for ssj = wi to till ssj is less than wi + size of ss [ i ] ; TAB4 if low of s [ ssj ] is not equal to low of ss [ i ] [ ssj - wi ] ; TAB5 set b to false ; TAB5 break ; TAB3 if b is not false ; TAB4 for ssj = wi to till ssj is less than wi + size of ss [ i ] , set arr [ ssj ] to true ; TAB1 for i = 0 to w exclusive ; TAB2 if arr [ i ] is not zero ; TAB3 if low of s [ i ] is equal to c ; TAB4 if c is equal to ' a ' ; TAB5 update s [ i ] to s [ i ] + ( ' b ' - low of s [ i ] ) ; TAB4 else ; TAB5 update s [ i ] to s [ i ] + ( ' a ' - low of s [ i ] ) ; TAB3 else ; TAB4 update s [ i ] to s [ i ] + ( c - low of s [ i ] ) ; TAB1 print out s with newline ;	const int maxn = 1e5 + 10 ; bool arr [ maxn ] ; string s , ss [ maxn ] ; char c ; int n ; void input ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> ss [ i ] ; cin >> s >> c ; } char low ( char x ) { if ( x >= ' A ' && x <= ' Z ' ) x = x - ' A ' + ' a ' ; return x ; } int main ( ) { input ( ) ; int w = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int wi = 0 ; wi + ss [ i ] . size ( ) - 1 < w ; wi ++ ) { bool b = true ; for ( int ssj = wi ; ssj < wi + ss [ i ] . size ( ) ; ssj ++ ) { if ( low ( s [ ssj ] ) != low ( ss [ i ] [ ssj - wi ] ) ) { b = false ; break ; } } if ( b ) for ( int ssj = wi ; ssj < wi + ss [ i ] . size ( ) ; ssj ++ ) arr [ ssj ] = true ; } } for ( int i = 0 ; i < w ; i ++ ) if ( arr [ i ] ) { if ( low ( s [ i ] ) == c ) { if ( c == ' a ' ) s [ i ] += ( ' b ' - low ( s [ i ] ) ) ; else s [ i ] += ( ' a ' - low ( s [ i ] ) ) ; } else s [ i ] += ( c - low ( s [ i ] ) ) ; } cout << s << endl ; }
TAB1 create integers n , a , b , c d ; TAB1 read n read a read b read c read d ; TAB1 create integers p1 , p2 , with p1 = 0 , p2 = 0 ; TAB1 if a is 0 and b is greater than 0 , set p1 to n * 4 - b ; TAB1 if a is greater than 0 and b is 0 , set p1 to a ; TAB1 if a is n and b is greater than 0 , set p1 to n + b ; TAB1 if is greater than or equal to 0 and b is n , set p1 to n * 3 - a ; TAB1 if c is 0 and d is greater than 0 , set p2 to n * 4 - d ; TAB1 if c is greater than 0 and d is 0 , set p2 to c ; TAB1 if c is n and d is greater than or equal to 0 , set p2 to n + d ; TAB1 if c is greater than 0 and d is n , set p2 to n * 3 - c ; TAB1 if p1 is less than p2 , swap values between p1 and p2 ; TAB1 if p1 - p2 is greater than 4 * n - p1 + p2 ; TAB2 print 4 * n - p1 + p2 print newline ; TAB1 else ; TAB2 print p1 - p2 print newline ;	int main ( ) { int n , a , b , c , d ; cin >> n >> a >> b >> c >> d ; int p1 = 0 , p2 = 0 ; if ( a == 0 && b > 0 ) p1 = n * 4 - b ; if ( a > 0 && b == 0 ) p1 = a ; if ( a == n && b >= 0 ) p1 = n + b ; if ( a >= 0 && b == n ) p1 = n * 3 - a ; if ( c == 0 && d > 0 ) p2 = n * 4 - d ; if ( c > 0 && d == 0 ) p2 = c ; if ( c == n && d >= 0 ) p2 = n + d ; if ( c >= 0 && d == n ) p2 = n * 3 - c ; if ( p1 < p2 ) swap ( p1 , p2 ) ; if ( p1 - p2 > 4 * n - p1 + p2 ) cout << 4 * n - p1 + p2 << endl ; else cout << p1 - p2 << endl ; return 0 ; }
TAB0 create long long int array a of size 1005 ; TAB0 create long long int vector ad of size 1005 ; TAB0 create long long int stack s ; TAB0 create long long int array visited of size 1005 ; TAB0 create long long int done of size 1005 ; TAB0 create long long int ans = 0 ; TAB0 create long long int k = 0 ; TAB0 create long long int vector cycles ; TAB0 declare dfs taking in long long int x and returning long long int ; TAB1 insert x to stack s ; TAB1 increment k ; TAB1 set done [ x ] to k ; TAB1 set visited [ x ] to 1 ; TAB1 create long long int i ; TAB1 for i = 0 to the size of ad [ x ] exclusive ; TAB2 if done [ ad [ x ] [ i ] ] is truthy ; TAB3 set ans to ans + k + 1 - done [ ad [ x ] [ i ] ] ; TAB3 if ( k + 1 - done [ ad [ x ] [ i ] ] ) modulo 2 is equal to 0 ; TAB4 append ( k + 1 - done [ ad [ x ] [ i ] ] ) / 2 to cycles ; TAB3 else ; TAB4 append k + 1 - done [ ad [ x ] [ i ] ] to cycles ; TAB2 if ! visited [ ad [ x ] [ i ] ] is truthy , call dfs ( ad [ x ] [ i ] ) ; TAB1 remove the top element of s ; TAB1 set done [ x ] to 0 ; TAB1 create long long ints n , i , and j ; TAB1 create long long int to u and v ; TAB1 read n ; TAB1 for i = 1 to n ; TAB2 read a [ i ] ; TAB2 append a [ i ] to a [ i ] ; TAB1 for i = 1 to n ; TAB2 if a [ i ] is equal to i ; TAB3 for j = 1 to n ; TAB4 if a [ j ] is equal to i and j is not equal to i ; TAB5 print - 1 ; TAB1 for i = 1 to n ; TAB2 if ! visited [ i ] is truthy ; TAB3 set k to 0 ; TAB3 call dfs ( i ) ; TAB1 if ans is not equal to n ; TAB2 print - 1 ; TAB1 create long long int lcm = cycles [ 0 ] ; TAB1 for i = 1 to size of cycles exclusive , set lcm to ( cycles [ i ] * lcm ) / ( __gcd ( cycles [ i ] , lcm ) ) ; TAB1 print lcm ;	long long int a [ 1005 ] ; vector < long long int > ad [ 1005 ] ; stack < long long int > s ; long long int visited [ 1005 ] ; long long int done [ 1005 ] ; long long int ans = 0 ; long long int k = 0 ; vector < long long int > cycles ; long long int dfs ( long long int x ) { s . push ( x ) ; k ++ ; done [ x ] = k ; visited [ x ] = 1 ; long long int i ; for ( i = 0 ; i < ( long long int ) ( ad [ x ] . size ( ) ) ; i ++ ) { if ( done [ ad [ x ] [ i ] ] ) { ans += k + 1 - done [ ad [ x ] [ i ] ] ; if ( ( k + 1 - done [ ad [ x ] [ i ] ] ) % 2 == 0 ) cycles . push_back ( ( k + 1 - done [ ad [ x ] [ i ] ] ) / 2 ) ; else cycles . push_back ( k + 1 - done [ ad [ x ] [ i ] ] ) ; return 0 ; } if ( ! visited [ ad [ x ] [ i ] ] ) dfs ( ad [ x ] [ i ] ) ; } s . pop ( ) ; done [ x ] = 0 ; return 0 ; } int main ( ) { long long int n , i , j ; long long int u , v ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; ad [ i ] . push_back ( a [ i ] ) ; } for ( i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == i ) { for ( j = 1 ; j <= n ; j ++ ) { if ( a [ j ] == i && j != i ) { cout << - 1 << endl ; return 0 ; } } } } for ( i = 1 ; i <= n ; i ++ ) { if ( ! visited [ i ] ) { k = 0 ; dfs ( i ) ; } } if ( ans != n ) { cout << - 1 << endl ; return 0 ; } long long int lcm = cycles [ 0 ] ; for ( i = 1 ; i < ( long long int ) ( cycles . size ( ) ) ; i ++ ) lcm = ( cycles [ i ] * lcm ) / ( __gcd ( cycles [ i ] , lcm ) ) ; cout << lcm << endl ; return 0 ; }
TAB0 let v be vector of long lon ; TAB0 define function Power which takes integer n and with return type long long ; TAB1 let ans be long long with ans = 1 ; TAB1 for i = 1 to n , ans = ans * 10 ; TAB1 return ans ; TAB1 let l and r be integers ; TAB1 for k = 1 to 10 ; TAB2 for i = 0 to 1 < < k exclusive ; TAB3 let arr be long long array of size k + 2 ; TAB3 for j = 0 to k - 1 , set arr [ j ] to 4 ; TAB3 for j = 0 to k exclusive ; TAB4 if i & 1 < < j is not zero , set arr [ j ] to 7 ; TAB3 let num be long long with num = 0 ; TAB3 for j = 0 to k - 1 , add arr [ j ] * ( Power of j ) ; TAB3 add num to the end of v ; TAB1 sort vector v ; TAB1 read l and r ; TAB1 let lIdx be integer with lIdx = lower_bound of v . begin ( ) , v . end ( ) , l - v . begin ( ) ; TAB1 let lIdx be integer with rIdx = lower_bound of v . begin ( ) , v . end ( ) , r - v . begin ( ) ; TAB1 let sum be long long with sum = ( v [ lIdx ] - l + 1 ) * v [ lIdx ] ; TAB1 for i = lIdx + 1 to rIdx , add ( v [ i ] - v [ i - 1 ] ) * v [ i ] to sum ; TAB1 add ( r - v [ rIdx ] ) * v [ rIdx ] to sum ; TAB1 print out sum with newline ;	vector < long long > v ; long long Power ( int n ) { long long ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans *= 10 ; } return ans ; } int main ( ) { int l , r ; for ( int k = 1 ; k <= 10 ; k ++ ) { for ( int i = 0 ; i < ( 1 << k ) ; i ++ ) { long long arr [ k + 2 ] ; for ( int j = 0 ; j < k ; j ++ ) { arr [ j ] = 4 ; } for ( int j = 0 ; j < k ; j ++ ) { if ( i & ( 1 << j ) ) { arr [ j ] = 7 ; } } long long num = 0 ; for ( int j = 0 ; j < k ; j ++ ) { num += arr [ j ] * Power ( j ) ; } v . push_back ( num ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; cin >> l >> r ; int lIdx = lower_bound ( v . begin ( ) , v . end ( ) , l ) - v . begin ( ) ; int rIdx = lower_bound ( v . begin ( ) , v . end ( ) , r ) - v . begin ( ) ; long long sum = ( v [ lIdx ] - l + 1 ) * v [ lIdx ] ; for ( int i = lIdx + 1 ; i <= rIdx ; i ++ ) { sum += ( v [ i ] - v [ i - 1 ] ) * v [ i ] ; } sum += ( r - v [ rIdx ] ) * v [ rIdx ] ; cout << sum << endl ; return 0 ; }
TAB1 create long long x , y , m , n , i , j ; TAB1 read n ; TAB1 read x and y ; TAB1 if x + y > n + 1 ; TAB2 print Black ; TAB1 else ; TAB2 print White ;	int main ( ) { long long x , y , m , n , i , j ; cin >> n ; cin >> x >> y ; if ( x + y > n + 1 ) cout << " Black " << endl ; else cout << " White " << endl ; }
TAB0 in the function meow ; TAB1 mp = string array of size 8 ; TAB1 for i = 0 to 7 , read mp [ i ] ; TAB1 dp = integer array of size [ 8 ] [ 8 ] = { 0 } , n = integer with n = 8 ; TAB1 set all contents of dp to - 1 ; TAB1 for i = 0 , _dwj = 0 to 7 ; TAB2 for j = 0 to 7 ; TAB3 if ( mp [ i ] [ j ] is K and not _dwj ) ; TAB4 _dwj = 1 ; TAB4 dp [ i ] [ j ] = 0 ; TAB4 q = queue of integer ; TAB4 push i to q ; TAB4 push j to q ; TAB4 while ( q . size ( ) ) ; TAB5 x = integer with x = q . front ( ) ; TAB5 pop q ; TAB5 y = integer with y = q . front ( ) ; TAB5 pop q ; TAB5 if ( x > 1 ) ; TAB6 if ( y > 1 and dp [ x - 2 ] [ y - 2 ] is - 1 ) ; TAB7 dp [ x - 2 ] [ y - 2 ] = dp [ x ] [ y ] + 1 ; TAB7 push x - 2 in q ; TAB7 push y - 2 in q ; TAB6 if ( y < n - 2 and dp [ x - 2 ] [ y + 2 ] is - 1 ) ; TAB7 dp [ x - 2 ] [ y + 2 ] = dp [ x ] [ y ] + 1 ; TAB7 push x - 2 in q ; TAB7 push y + 2 in q ; TAB5 if ( x < n - 2 ) ; TAB6 if ( y > 1 and dp [ x + 2 ] [ y - 2 ] is - 1 ) ; TAB7 dp [ x + 2 ] [ y - 2 ] = dp [ x ] [ y ] + 1 ; TAB7 push x + 2 in q ; TAB7 push y - 2 in q ; TAB6 if ( y < n - 2 and dp [ x + 2 ] [ y + 2 ] is - 1 ) ; TAB7 dp [ x + 2 ] [ y + 2 ] = dp [ x ] [ y ] + 1 ; TAB7 push x + 2 in q ; TAB7 push y + 2 in q ; TAB1 for i = 0 to 7 ; TAB2 for j = 0 to 7 ; TAB3 if ( mp [ i ] [ j ] is K and dp [ i ] [ j ] ) ; TAB4 if ( dp [ i ] [ j ] is - 1 ) , return print NO ; TAB4 if ( dp [ i ] [ j ] bitwise and 1 ) , return print NO ; TAB4 return print YES , 0 ; TAB1 t = integer ; TAB1 read t ; TAB1 while decrement t , call meow ;	int meow ( ) { string mp [ 8 ] ; for ( int i = 0 ; i < 8 ; ++ i ) cin >> mp [ i ] ; int dp [ 8 ] [ 8 ] = { 0 } , n = 8 ; memset ( dp , - 1 , sizeof ( dp ) ) ; for ( int i = 0 , _dwj = 0 ; i < 8 ; ++ i ) { for ( int j = 0 ; j < 8 ; ++ j ) { if ( mp [ i ] [ j ] == ' K ' and ! _dwj ) { _dwj = 1 ; dp [ i ] [ j ] = 0 ; queue < int > q ; q . push ( i ) ; q . push ( j ) ; while ( q . size ( ) ) { int x = q . front ( ) ; q . pop ( ) ; int y = q . front ( ) ; q . pop ( ) ; if ( x > 1 ) { if ( y > 1 and dp [ x - 2 ] [ y - 2 ] == - 1 ) { dp [ x - 2 ] [ y - 2 ] = dp [ x ] [ y ] + 1 ; q . push ( x - 2 ) ; q . push ( y - 2 ) ; } if ( y < n - 2 and dp [ x - 2 ] [ y + 2 ] == - 1 ) { dp [ x - 2 ] [ y + 2 ] = dp [ x ] [ y ] + 1 ; q . push ( x - 2 ) ; q . push ( y + 2 ) ; } } if ( x < n - 2 ) { if ( y > 1 and dp [ x + 2 ] [ y - 2 ] == - 1 ) { dp [ x + 2 ] [ y - 2 ] = dp [ x ] [ y ] + 1 ; q . push ( x + 2 ) ; q . push ( y - 2 ) ; } if ( y < n - 2 and dp [ x + 2 ] [ y + 2 ] == - 1 ) { dp [ x + 2 ] [ y + 2 ] = dp [ x ] [ y ] + 1 ; q . push ( x + 2 ) ; q . push ( y + 2 ) ; } } } } } } for ( int i = 0 ; i < 8 ; ++ i ) { for ( int j = 0 ; j < 8 ; ++ j ) { if ( mp [ i ] [ j ] == ' K ' and dp [ i ] [ j ] ) { if ( dp [ i ] [ j ] == - 1 ) return cout << " NO " << endl , 0 ; if ( dp [ i ] [ j ] & 1 ) return cout << " NO " << endl , 0 ; return cout << " YES " << endl , 0 ; } } } } int main ( ) { int t ; cin >> t ; while ( t -- ) { meow ( ) ; } }
TAB1 n = int ; TAB1 read n ; TAB1 let num = 0 , chr = 0 , CHR = 0 be ints ; TAB1 str = string ; TAB1 for i = 0 to n exclusvie ; TAB2 read str ; TAB2 for j = 0 to length of str exclusive ; TAB3 if str at j is between ' a ' and ' z ' both inclusive ; TAB4 increment chr ; TAB3 else if str at j is between ' A ' and ' Z ' both inclusive ; TAB4 increment CHR ; TAB3 else ; TAB4 increment num ; TAB2 if chr = and CHR = 0 ; TAB3 insert " aA " int str at 0 ; TAB3 call erase on str with args 2 , 2 ; TAB2 else if chr and num are both = 0 ; TAB3 insert " a1 " into str [ 0 ] ; TAB3 call erase on str with args 2 , 2 ; TAB2 else if CHR and num are both = 0 ; TAB3 insert " A1 " into str [ 0 ] ; TAB3 erase 2 , 2 form str ; TAB2 else if chr = 0 ; TAB3 for j = 0 to length of str ; TAB4 if str at j > = ' A ' bit and str [ j ] < = ' Z ' bit and CHR > 1 ; TAB5 insert " a " in str at j ; TAB5 erase j + 1 , 1 form str ; TAB5 exit loop ; TAB4 else if str [ j ] is > = ' 0 ' bit and str [ j ] < = ' 9 ' bit and num > 1 ; TAB5 insert " a " , j into str ; TAB5 erase j + 1 , 1 from str ; TAB5 exit loop ; TAB2 else if CHR = 0 ; TAB3 for j = 0 to length of str ; TAB4 if str at j > = ' a ' bit and str [ j ] < = ' z ' bit and chr > 1 ; TAB5 call insert on str with args j , " A " ; TAB5 erase j + 1 , 1 from str ; TAB5 exit loop ; TAB4 else if str at j > = ' a ' bit and str [ j ] < = ' z ' bit and num > 1 ; TAB5 call insert on str with args j , " A " ; TAB5 erase j + 1 , 1 from str ; TAB5 exit loop ; TAB2 else if num = 0 ; TAB3 for j = 0 to length of str ; TAB4 if str at j > = ' a ' bit and str [ j ] < = ' z ' bit and chr > 1 ; TAB5 insert j , " 1 " into str ; TAB5 erase j + 1 , 1 from str ; TAB5 exit loop ; TAB4 else if str at j > = ' A ' bit and str [ j ] < = ' Z ' bit and CHR > 1 ; TAB5 insert j , " 1 " into str ; TAB5 erase j + 1 , 1 from str ; TAB5 exit loop ; TAB2 print str ; TAB2 set num to 0 ; TAB2 set chr to 0 ; TAB2 set CHR to 0 ;	int main ( ) { int n ; cin >> n ; int num = 0 , chr = 0 , CHR = 0 ; string str ; for ( int i = 0 ; i < n ; i ++ ) { cin >> str ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] >= ' a ' & str [ j ] <= ' z ' ) { chr ++ ; } else if ( str [ j ] >= ' A ' & str [ j ] <= ' Z ' ) { CHR ++ ; } else { num ++ ; } } if ( chr == 0 && CHR == 0 ) { str . insert ( 0 , " aA " ) ; str . erase ( 2 , 2 ) ; } else if ( chr == 0 && num == 0 ) { str . insert ( 0 , " a1 " ) ; str . erase ( 2 , 2 ) ; } else if ( CHR == 0 && num == 0 ) { str . insert ( 0 , " A1 " ) ; str . erase ( 2 , 2 ) ; } else if ( chr == 0 ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] >= ' A ' & str [ j ] <= ' Z ' & CHR > 1 ) { str . insert ( j , " a " ) ; str . erase ( j + 1 , 1 ) ; break ; } else if ( str [ j ] >= ' 0 ' & str [ j ] <= ' 9 ' & num > 1 ) { str . insert ( j , " a " ) ; str . erase ( j + 1 , 1 ) ; break ; } } } else if ( CHR == 0 ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] >= ' a ' & str [ j ] <= ' z ' & chr > 1 ) { str . insert ( j , " A " ) ; str . erase ( j + 1 , 1 ) ; break ; } else if ( str [ j ] >= ' 0 ' & str [ j ] <= ' 9 ' & num > 1 ) { str . insert ( j , " A " ) ; str . erase ( j + 1 , 1 ) ; break ; } } } else if ( num == 0 ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] >= ' a ' & str [ j ] <= ' z ' & chr > 1 ) { str . insert ( j , " 1 " ) ; str . erase ( j + 1 , 1 ) ; break ; } else if ( str [ j ] >= ' A ' & str [ j ] <= ' Z ' & CHR > 1 ) { str . insert ( j , " 1 " ) ; str . erase ( j + 1 , 1 ) ; break ; } } } cout << str << endl ; num = 0 ; chr = 0 ; CHR = 0 ; } return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 nC , iC , eC , tC , disC = integers with nC = 0 , iC = 0 , eC = 0 , tC = 0 , disC = 0 ; TAB1 for c = 0 to s . length ( ) exclusive ; TAB2 if s [ c ] is n ; TAB3 increment nC ; TAB2 else if s [ c ] is i ; TAB3 increment iC ; TAB2 else if s [ c ] is e ; TAB3 increment eC ; TAB2 else if s [ c ] is t ; TAB3 increment tC ; TAB1 while nC > 0 and eC > 0 and iC > 0 and tC > 0 ; TAB2 nC = nC - 3 ; TAB2 decrement iC ; TAB2 eC = eC - 3 ; TAB2 decrement tC ; TAB2 if nC > = 0 and eC > = 0 and iC > = 0 and tC > = 0 , increment disC ; TAB2 increment nC ; TAB1 print disC ;	int main ( ) { string s ; cin >> s ; int nC = 0 , iC = 0 , eC = 0 , tC = 0 , disC = 0 ; for ( int c = 0 ; c < s . length ( ) ; c ++ ) { if ( s [ c ] == ' n ' ) { nC ++ ; } else if ( s [ c ] == ' i ' ) { iC ++ ; } else if ( s [ c ] == ' e ' ) { eC ++ ; } else if ( s [ c ] == ' t ' ) { tC ++ ; } } while ( nC > 0 && eC > 0 && iC > 0 && tC > 0 ) { nC -= 3 ; iC -- ; eC -= 3 ; tC -- ; if ( nC >= 0 && eC >= 0 && iC >= 0 && tC >= 0 ) { disC ++ ; } nC ++ ; } cout << disC << endl ; return 0 ; }
TAB1 n = integer ; TAB1 Read n ; TAB1 x , y = integers ; TAB1 Read x , y ; TAB1 set white to maximum value of n - x and n - y ; TAB1 set black to maximum value of x - 1 and y - 1 ; TAB1 if black is greater than white ; TAB2 print Black and a new line ; TAB1 else do the following ; TAB2 print White and a new line ;	int main ( ) { long long n ; cin >> n ; long long x , y ; cin >> x >> y ; long long white = max ( n - x , n - y ) ; long long black = max ( x - 1 , y - 1 ) ; if ( black > white ) cout << " Black\n " ; else cout << " White\n " ; }
TAB0 a , b , l , r , ans , T = int ; TAB0 s = array of 200 char ; TAB0 vis = array of 27 bool ; TAB0 function dfs ( get char cp , return int ) ; TAB1 count = 0 ; TAB1 for i = 0 to a exclusive s [ i ] = ' a ' + i ; TAB1 for i = a to a + b exclusive s [ i ] = cp ; TAB1 fill vis with valse ; TAB1 for i = b to a + b exclusive vis [ s [ i ] - ' a ' ] = true ; TAB1 sta = a + b , ed = 0 ; TAB1 while sta < 2 * a + b ; TAB2 while vis [ ed ] increment ed ; TAB2 s [ sta ] = ed + ' a ' ; TAB2 increment sta and ed ; TAB1 for i = 2 * a + b to T exclusive s [ i ] = s [ i - 1 ] ; TAB1 fill vis with false ; TAB1 if l < = r ; TAB2 for i = l to r inclusive ; TAB3 if not vis [ s [ i ] - ' a ' ] increment count , vis [ s [ i ] - ' a ' ] = true ; TAB1 else ; TAB2 for i = 0 to r inclusive ; TAB3 if not vis [ s [ i ] - ' a ' ] increment count , vis [ s [ i ] - ' a ' ] = true ; TAB2 for i = l to T exclusive ; TAB3 if not vis [ s [ i ] - ' a ' ] increment count , vis [ s [ i ] - ' a ' ] = true ; TAB1 return count ; TAB1 read a , b , l , r ; TAB1 decrement l and r ; TAB1 if a < = b ; TAB2 ans = a + 1 ; TAB1 else ; TAB2 ans = 2 * a - b ; TAB1 T = 2 * ( a + b ) ; TAB1 if r - l > = T ; TAB2 do nothing ; TAB1 else ; TAB2 r = r modulo T , l = l modulo T ; TAB2 for i = 0 to a exclusive ans = min ( dfs ( ' a ' + i ) , ans ) ; TAB1 print ans ;	int a , b , l , r , ans , T ; char s [ 200 ] ; bool vis [ 27 ] ; int dfs ( char cp ) { int count = 0 ; for ( int i = 0 ; i < a ; i ++ ) s [ i ] = ( ' a ' + i ) ; for ( int i = a ; i < a + b ; i ++ ) s [ i ] = cp ; memset ( vis , false , sizeof ( vis ) ) ; for ( int i = b ; i < a + b ; i ++ ) vis [ s [ i ] - ' a ' ] = true ; int sta = a + b , ed = 0 ; while ( sta < 2 * a + b ) { while ( vis [ ed ] ) ed ++ ; s [ sta ] = ed + ' a ' ; sta ++ , ed ++ ; } for ( int i = 2 * a + b ; i < T ; i ++ ) s [ i ] = s [ i - 1 ] ; memset ( vis , false , sizeof ( vis ) ) ; if ( l <= r ) { for ( int i = l ; i <= r ; i ++ ) { if ( ! vis [ s [ i ] - ' a ' ] ) { count ++ , vis [ s [ i ] - ' a ' ] = true ; } } } else { for ( int i = 0 ; i <= r ; i ++ ) { if ( ! vis [ s [ i ] - ' a ' ] ) { count ++ , vis [ s [ i ] - ' a ' ] = true ; } } for ( int i = l ; i < T ; i ++ ) { if ( ! vis [ s [ i ] - ' a ' ] ) { count ++ , vis [ s [ i ] - ' a ' ] = true ; } } } return count ; } int main ( ) { cin >> a >> b >> l >> r ; l -- , r -- ; if ( a <= b ) ans = a + 1 ; else ans = 2 * a - b ; T = 2 * ( a + b ) ; if ( r - l >= T ) ; else { r %= T , l %= T ; for ( int i = 0 ; i < a ; i ++ ) { ans = min ( dfs ( ' a ' + i ) , ans ) ; } } cout << ans << endl ; return 0 ; }
TAB0 N is a new constant integer variable = 505 ; TAB0 str is a new array of characters with N elements ; TAB0 declare integer variables a , b , c and s ; TAB0 judge is a boolean function ; TAB1 i is a new integer variable with value 0 ; TAB1 if a + b - c is equal to 2 ; TAB2 increment c ; TAB2 if a ! = 1 ; TAB3 decrement a by one ; TAB2 else if b ! = 1 ; TAB3 decrement b ; TAB1 else if a + b - c = - 2 ; TAB2 decrement c ; TAB2 increment a by one ; TAB1 if a + b = c ; TAB2 print " | " to the standard output a times ; TAB2 if i = a , print " + " to the standard output ; TAB2 print " | " b times ; TAB2 if i is equal to b , print " = " ; TAB2 print " | " to the stdout c times ; TAB2 print a new line ; TAB2 return true ; TAB1 return false ; TAB1 read new line into str in a loop ; TAB2 set s , a , b and c values to 0 ; TAB2 declare new integer variable len with value = length of str ; TAB2 in a for loop , change i from 0 to len exclusive incrementing i ; TAB3 if str [ i ] = ' | ' ; TAB4 if s is equal to 0 ; TAB5 increment a by one ; TAB4 else if s = 1 ; TAB5 increment b by one ; TAB4 else ; TAB5 increment c ; TAB3 else ; TAB4 increment s by one ; TAB2 if judge ( ) returned false , print " Impossible " ;	const int N = 505 ; char str [ N ] ; int a , b , c , s ; bool judge ( ) { int i = 0 ; if ( a + b - c == 2 ) { c ++ ; if ( a != 1 ) a -- ; else if ( b != 1 ) b -- ; } else if ( a + b - c == - 2 ) { c -- ; a ++ ; } if ( a + b == c ) { for ( i = 0 ; i < a ; i ++ ) { cout << " | " ; } if ( i == a ) cout << " + " ; for ( i = 0 ; i < b ; i ++ ) { cout << " | " ; } if ( i == b ) cout << " = " ; for ( i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; return true ; } return false ; } int main ( ) { while ( gets ( str ) ) { s = a = b = c = 0 ; int len = strlen ( str ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' | ' ) { if ( s == 0 ) a ++ ; else if ( s == 1 ) b ++ ; else c ++ ; } else s ++ ; } if ( ! judge ( ) ) cout << " Impossible " << endl ; } return 0 ; }
TAB1 declare int n , m , s ; TAB1 declare double k ; TAB1 read n , m , k ; TAB1 declare string a ; TAB1 declare map myMap with string keys and int values ; TAB1 declare myMap iterator i ; TAB1 for i = 0 to n exclusive ; TAB2 read a , s ; TAB2 if s * k is less than 100 ; TAB3 continue ; TAB2 else ; TAB3 set myMap [ a ] to s * k + 1e - 6 ; TAB1 for i = 0 to m exclusive ; TAB2 read a ; TAB2 if myMap [ a ] equals 0 : set myMap [ a ] to 0 ; TAB1 print length of myMap with newline ; TAB1 print all key value pairs for myMap ;	int main ( ) { int n , m , s ; double k ; cin >> n >> m >> k ; string a ; map < string , int > myMap ; map < string , int > :: iterator i ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a >> s ; if ( s * k < 100 ) continue ; else myMap [ a ] = s * k + 1e-6 ; } for ( int i = 0 ; i < m ; ++ i ) { cin >> a ; if ( myMap [ a ] == 0 ) myMap [ a ] = 0 ; } cout << myMap . size ( ) << " \n " ; for ( i = myMap . begin ( ) ; i != myMap . end ( ) ; ++ i ) { cout << i -> first << "   " << i -> second << " \n " ; } return 0 ; }
TAB1 create integers n , k , x , cnt = 0 and integer array a of size 100 ; TAB1 create integer sets s and t ; TAB1 read n and k ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 set x to a [ i ] ; TAB2 if x is at the end of set s ; TAB3 increment cnt ; TAB3 insert x into set s ; TAB2 if the size of set s if equal to k + 1 ; TAB3 set t to s ; TAB3 erase x from set t ; TAB3 for j = i + 1 to n exclusive ; TAB4 if the size of set t is 1 , break loop ; TAB4 erase a [ j ] from set t ; TAB3 erase * ( t . begin ( ) ) from set s ; TAB1 print cnt ;	int main ( ) { int n , k , x , cnt = 0 , a [ 100 ] ; set < int > s , t ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { x = a [ i ] ; if ( s . find ( x ) == s . end ( ) ) { ++ cnt ; s . insert ( x ) ; } if ( s . size ( ) == k + 1 ) { t = s ; t . erase ( x ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( t . size ( ) == 1 ) break ; t . erase ( a [ j ] ) ; } s . erase ( * ( t . begin ( ) ) ) ; } } cout << cnt << endl ; return 0 ; }
TAB0 q , ok , c = long long with c = 1 ; TAB1 read q ; TAB1 u = long long with u = q ; TAB1 for j = 2 to sqrt of q + 1 inclusive ; TAB2 if q is a multiple of j ; TAB3 loop while q is a multiple of j ; TAB4 set q to q / j ; TAB4 increment ok ; TAB4 if ok < = 2 set c to c * j ; TAB4 if ok is 2 break ; TAB1 if q > 1 increment ok ; TAB1 if ok < = 1 print " 1 " and " 0 " ; TAB1 if ok is 2 print " 2 " ; TAB1 if ok > = 3 print " 1 " and c ;	long long q , ok , c = 1 ; int main ( ) { cin >> q ; long long u = q ; for ( long long j = 2 ; j <= sqrt ( q ) + 1 ; j ++ ) { if ( q % j == 0 ) { while ( q % j == 0 ) { q = q / j ; ok ++ ; if ( ok <= 2 ) c *= j ; if ( ok == 2 ) break ; } } } if ( q > 1 ) ok ++ ; if ( ok <= 1 ) cout << " 1 " << endl << " 0 " << endl ; if ( ok == 2 ) cout << " 2 " << endl ; if ( ok >= 3 ) cout << " 1 " << endl << c << endl ; return 0 ; }
TAB1 declare new integer n ; TAB1 read user input to n ; TAB1 if n is even , change n to n - ( 1 < < ( int ) log2 ( n ) ) - 1 ; TAB1 print n / 2 to the standard output ;	int main ( ) { int n ; cin >> n ; if ( n % 2 == 0 ) { n -= ( 1 << ( int ) log2 ( n ) ) - 1 ; } cout << n / 2 << endl ; }
TAB0 let N be a constant integer with N = 1e5 + 5 ; TAB0 let MXN be a constant long integer with MXN = 1e18 ; TAB0 str = array of characters of length 1005 ; TAB1 let n be a integer ; TAB1 read n ; TAB1 read str ; TAB1 if n is equal to 1 and str [ 0 ] is equal to 0 ; TAB2 print No and newline ; TAB1 let cnt0 , cnt1 be integers with cnt0 = 0 , cnt1 = 0 ; TAB1 let f be a boolean value with f = true ; TAB1 for i = 0 to n exclusive ; TAB2 if str [ i ] is equal to 0 ; TAB3 cnt1 is equal to 0 ; TAB3 increment cnt0 by 1 ; TAB2 else do the following ; TAB3 cnt0 is equal to 0 ; TAB3 increment cnt1 by 1 ; TAB2 if cnt0 > = 3 or cnt1 > = 2 ; TAB3 f is equal to false ; TAB3 stop ; TAB1 if the condition is true ; TAB2 let cnt be a integer with cnt = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if str [ i ] is equal to 1 , stop ; TAB3 increment cnt by 1 ; TAB2 if cnt > = 2 , f is equal to false ; TAB2 cnt is equal to 0 ; TAB2 for integer i is equal to n - 1 , i > = 0 , decrement i by 1 ; TAB3 if str [ i ] is equal to 1 , stop ; TAB3 increment cnt by 1 ; TAB2 if cnt > = 2 , f is equal to false ; TAB2 if f is true ; TAB3 print Yes and newline ; TAB2 else do the following ; TAB3 print No and newline ; TAB1 else do the following ; TAB2 print No and newline ;	const int N = 1e5 + 5 ; const long long int MXN = 1e18 ; char str [ 1005 ] ; int main ( ) { int n ; cin >> n ; cin >> str ; if ( n == 1 && str [ 0 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } int cnt0 = 0 , cnt1 = 0 ; bool f = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' 0 ' ) { cnt1 = 0 ; cnt0 ++ ; } else { cnt0 = 0 ; cnt1 ++ ; } if ( cnt0 >= 3 || cnt1 >= 2 ) { f = false ; break ; } } if ( true ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' 1 ' ) break ; cnt ++ ; } if ( cnt >= 2 ) { f = false ; } cnt = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' 1 ' ) break ; cnt ++ ; } if ( cnt >= 2 ) { f = false ; } if ( f ) cout << " Yes " << endl ; else cout << " No " << endl ; } else { cout << " No " << endl ; } }
TAB1 assign - 1 to ind ; TAB1 create string s and ans ; TAB1 read s ; TAB1 for i = size of s to 0 inclusive ; TAB2 if s [ i ] = 0 , set ind to i ; TAB1 for i = 0 to size of s exclusive ; TAB2 if ind = - 1 and i = 0 or i = ind , continue ; TAB2 set ans to ans + s [ i ] ; TAB1 print ans ;	int main ( ) { int ind = - 1 ; string s , ans ; cin >> s ; for ( int i = s . size ( ) ; i >= 0 ; i -- ) { if ( s [ i ] == ' 0 ' ) ind = i ; } for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( ind == - 1 && i == 0 ) || i == ind ) continue ; ans += s [ i ] ; } cout << ans << endl ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 forbid = vector of string ; TAB1 for i = 0 to n exclusive ; TAB2 s = string ; TAB2 read s ; TAB2 s1 = string with s1 = " " ; TAB2 for j = 0 to s . size ( ) exclusive ; TAB3 a = character with a = s [ j ] ; TAB3 if ( a < = Z ) , a = a - A + a ; TAB3 s1 = s1 + a ; TAB2 append s1 to forbid ; TAB1 occur = vector integer array of size 100 ; TAB1 s = string ; TAB1 read s ; TAB1 s1 = string with s1 = " " ; TAB1 for j = 0 to s . size ( ) exclusive ; TAB2 a = character with a = s [ j ] ; TAB2 if ( a < = Z ) , a = a - A + a ; TAB2 s1 = s1 + a ; TAB1 for i = 0 to n exclusive ; TAB2 copy = string with copy = s1 ; TAB2 pre = integer with pre = 0 ; TAB2 while ( copy . size ( ) > 0 and copy . find ( forbid [ i ] ) is not npos string ) ; TAB3 append copy . find ( forbid [ i ] ) + pre to occur [ i ] ; TAB3 pre = pre + copy . find ( forbid [ i ] ) + 1 ; TAB3 copy = copy . substr ( copy . find ( forbid [ i ] ) + 1 ) ; TAB1 letter = character ; TAB1 read letter ; TAB1 first = bool array of size 100 ; TAB1 important = integer array of size 100 ; TAB1 set all contents of first to true ; TAB1 set all contents of important to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to occur [ i ] . size ( ) exclusive ; TAB3 for k = 0 to occur [ i ] [ j ] + k < s . size ( ) and k < forbid [ i ] . size ( ) ; TAB4 if ( first [ occur [ i ] [ j ] + k ] ) ; TAB5 first [ occur [ i ] [ j ] + k ] = false ; TAB5 if ( s [ occur [ i ] [ j ] + k ] is letter ) ; TAB6 important [ occur [ i ] [ j ] + k ] = 1 ; TAB5 else if ( s [ occur [ i ] [ j ] + k ] is letter - a + A ) ; TAB6 important [ occur [ i ] [ j ] + k ] = 2 ; TAB4 if ( s [ occur [ i ] [ j ] + k ] < = Z ) ; TAB5 s [ occur [ i ] [ j ] + k ] = letter - a + A ; TAB4 else ; TAB5 s [ occur [ i ] [ j ] + k ] = letter ; TAB1 for i = 0 to s . size ( ) exclusive ; TAB2 c1 = character with c1 = a ; TAB2 if ( letter is a ) , c1 = b ; TAB2 if ( important [ i ] is 1 ) ; TAB3 s [ i ] = c1 ; TAB2 else if ( important [ i ] is 2 ) ; TAB3 s [ i ] = c1 - a + A ; TAB1 print s ;	int main ( ) { int n ; cin >> n ; vector < string > forbid ; for ( int i = 0 ; i < n ; i ++ ) { string s ; cin >> s ; string s1 = "  " ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { char a = s [ j ] ; if ( a <= ' Z ' ) a = a - ' A ' + ' a ' ; s1 += a ; } forbid . push_back ( s1 ) ; } vector < int > occur [ 100 ] ; string s ; cin >> s ; string s1 = "  " ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { char a = s [ j ] ; if ( a <= ' Z ' ) a = a - ' A ' + ' a ' ; s1 += a ; } for ( int i = 0 ; i < n ; i ++ ) { string copy = s1 ; int pre = 0 ; while ( copy . size ( ) > 0 && copy . find ( forbid [ i ] ) != string :: npos ) { occur [ i ] . push_back ( copy . find ( forbid [ i ] ) + pre ) ; pre += copy . find ( forbid [ i ] ) + 1 ; copy = copy . substr ( copy . find ( forbid [ i ] ) + 1 ) ; } } char letter ; cin >> letter ; bool first [ 100 ] ; int important [ 100 ] ; memset ( first , true , sizeof ( first ) ) ; memset ( important , 0 , sizeof ( important ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < occur [ i ] . size ( ) ; j ++ ) { for ( int k = 0 ; occur [ i ] [ j ] + k < s . size ( ) && k < forbid [ i ] . size ( ) ; k ++ ) { if ( first [ occur [ i ] [ j ] + k ] ) { first [ occur [ i ] [ j ] + k ] = false ; if ( s [ occur [ i ] [ j ] + k ] == letter ) { important [ occur [ i ] [ j ] + k ] = 1 ; } else if ( s [ occur [ i ] [ j ] + k ] == letter - ' a ' + ' A ' ) { important [ occur [ i ] [ j ] + k ] = 2 ; } } if ( s [ occur [ i ] [ j ] + k ] <= ' Z ' ) s [ occur [ i ] [ j ] + k ] = letter - ' a ' + ' A ' ; else s [ occur [ i ] [ j ] + k ] = letter ; } } } for ( int i = 0 ; i < s . size ( ) ; i ++ ) { char c1 = ' a ' ; if ( letter == ' a ' ) c1 = ' b ' ; if ( important [ i ] == 1 ) { s [ i ] = c1 ; } else if ( important [ i ] == 2 ) { s [ i ] = c1 - ' a ' + ' A ' ; } } cout << s << endl ; return 0 ; }
TAB0 define arrays of shorts X and Y with size 105 ; TAB0 bin is a new array of shorts with size 15 ; TAB0 create constant integer variable C with value 5 ; TAB0 create a map from characters to integers called M ; TAB0 void function trans with int argument x ; TAB1 create new integer variable ind with value 0 ; TAB1 set first 12 elements of bin to 0 ; TAB1 while x > 0 ; TAB2 change the value of bin [ ind ] to x modulo 2 and increment ind ; TAB2 change the value of s quared divided by 2 ; TAB1 create new character called ch ; TAB1 define new integer n ; TAB1 read n from the user input ; TAB1 assign 0 to M [ ' R ' ] ; TAB1 assign 1 to M [ ' G ' ] ; TAB1 change the value of M [ ' B ' ] to 2 ; TAB1 assign 3 to M [ ' Y ' ] ; TAB1 assign the new value = 4 to M [ ' W ' ] ; TAB1 for i = 0 to n exclusive ; TAB2 read standard input to ch ; TAB2 change the value of X [ i ] to M [ ch ] ; TAB2 read ch ; TAB2 assign the new value = ch - ' 1 ' to Y [ i ] ; TAB1 define integers ans and anst with ans = 20 ; TAB1 declare boolean variable all ; TAB1 new boolean ones = true ; TAB1 start for loop from i = 0 to n - 1 exclusive , change ones to ( X [ i ] = = X [ i + 1 ] & & Y [ i ] = = Y [ i + 1 ] ) & & ones ; TAB1 if ones is false ; TAB2 for integer i = 1 to 1023 inclusive incrementing i ; TAB3 call trans of i ; TAB3 change the value of anst to 0 ; TAB3 assign the new value = true to all ; TAB3 increment k in a loop from 0 to n - 1 exclusive ; TAB4 for integer l = k + 1 to n exclusive ; TAB5 if X [ k ] ! = X [ l ] and ( bin [ X [ k ] ] or bin [ X [ l ] ] = 1 ) ; TAB6 change the value of all to true ; TAB5 else if Y [ k ] ! = Y [ l ] and ( bin [ Y [ k ] + C ] or bin [ Y [ l ] + C ] = 1 ) ; TAB6 change the value of all to true ; TAB5 else if X [ l ] = X [ k ] and Y [ l ] = Y [ k ] ; TAB6 assign true to all ; TAB5 else ; TAB6 assign false to all ; TAB5 if all is false , break ; TAB4 if all is false , break the loop ; TAB3 if all is true ; TAB4 for i = 0 to 12 exclusive ; TAB5 if bin [ i ] is equal to 1 , increment anst by one ; TAB4 change the value of ans to anst of ans > anst ; TAB1 else ; TAB2 print 0 ; TAB1 if ones is false , print ans ;	short X [ 105 ] , Y [ 105 ] ; short bin [ 15 ] ; const int C = 5 ; map < char , int > M ; void trans ( int x ) { int ind = 0 ; for ( int j = 0 ; j < 12 ; j ++ ) bin [ j ] = 0 ; while ( x > 0 ) { bin [ ind ++ ] = x % 2 ; x /= 2 ; } } int main ( ) { char ch ; int n ; cin >> n ; M [ ' R ' ] = 0 ; M [ ' G ' ] = 1 ; M [ ' B ' ] = 2 ; M [ ' Y ' ] = 3 ; M [ ' W ' ] = 4 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> ch ; X [ i ] = M [ ch ] ; cin >> ch ; Y [ i ] = ch - ' 1 ' ; } int ans = 20 , anst ; bool all ; bool ones = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) ones = ( X [ i ] == X [ i + 1 ] && Y [ i ] == Y [ i + 1 ] ) && ones ; if ( ! ones ) { for ( int i = 1 ; i <= 1023 ; i ++ ) { trans ( i ) ; anst = 0 ; all = true ; for ( int k = 0 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( X [ k ] != X [ l ] && ( ( bin [ X [ k ] ] == 1 ) || ( bin [ X [ l ] ] == 1 ) ) ) all = true ; else if ( Y [ k ] != Y [ l ] && ( ( bin [ Y [ k ] + C ] == 1 ) || bin [ Y [ l ] + C ] == 1 ) ) all = true ; else if ( X [ l ] == X [ k ] && Y [ l ] == Y [ k ] ) all = true ; else all = false ; if ( ! all ) break ; } if ( ! all ) break ; } if ( all ) { for ( int i = 0 ; i < 12 ; i ++ ) if ( bin [ i ] == 1 ) anst ++ ; ans = ans > anst ? anst : ans ; } } } else cout << 0 << endl ; if ( ! ones ) cout << ans << endl ; return 0 ; }
TAB1 create int vector vetor ; TAB1 create ints n , i , and colunas ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read colunas ; TAB2 append colunas to vetor ; TAB1 sort vetor ; TAB1 for i = 0 to n - 1 exclusive , print vetor [ i ] ; TAB1 print vetor [ n - 1 ] ;	int main ( ) { vector < int > vetor ; int n , i , colunas ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> colunas ; vetor . push_back ( colunas ) ; } sort ( vetor . begin ( ) , vetor . end ( ) ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { cout << vetor [ i ] << "   " ; } cout << vetor [ n - 1 ] << endl ; return 0 ; }
TAB0 in function tri taking long long k and returning long long ; TAB1 return k * ( k + 1 ) / 2 ; TAB1 n = long long ; TAB1 read n ; TAB1 flag = bool with flag = false ; TAB1 for i = 1 to sqrt of 2 * n inclusive ; TAB2 k = long long with k = n - tri of i ; TAB2 l = long long with l = i ; TAB2 r = long long with r = sqrt of n * 2 ; TAB2 loop while l < = r ; TAB3 m = long long with m = ( l + r ) bitshift right by 1 ; TAB3 if tri of m < k ; TAB4 set l to m + 1 ; TAB3 else if tri of m > k ; TAB4 set r to m - 1 ; TAB3 else ; TAB4 set flag to true ; TAB4 break ; TAB2 if flag break ; TAB1 if flag ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	long long tri ( long long k ) { return k * ( k + 1 ) / 2 ; } int main ( ) { long long n ; cin >> n ; bool flag = false ; for ( int i = 1 ; i <= sqrt ( n * 2 ) ; i ++ ) { long long k = n - tri ( i ) ; long long l = i ; long long r = sqrt ( n * 2 ) ; while ( l <= r ) { long long m = ( l + r ) >> 1 ; if ( tri ( m ) < k ) { l = m + 1 ; } else if ( tri ( m ) > k ) { r = m - 1 ; } else { flag = true ; break ; } } if ( flag ) break ; } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 let cycles be an integer ; TAB1 input cycles ; TAB1 a is a boolean array of sizes 100 and 100 with a = 0 ; TAB1 point is an integer set to 1 ; TAB1 i is an integer set to 0 ; TAB1 while cycles is positive ; TAB2 if cycles is less than i ; TAB3 set i to 0 ; TAB3 increment point ; TAB2 assign 1 to a [ i ] [ point ] ; TAB2 assign 1 to a [ point ] [ 1 ] ; TAB2 subtract i from cycles ; TAB2 increment i ; TAB2 if i is at least point and cycles is positive ; TAB3 set i to 0 ; TAB3 increment point ; TAB1 display point + 1 ; TAB1 for i = 0 to point inclusive ; TAB2 for j = 0 to point inclusive , display a [ i ] [ j ] ; TAB2 display newline ;	int main ( ) { int cycles ; cin >> cycles ; bool a [ 100 ] [ 100 ] = { 0 } ; int point = 1 ; int i = 0 ; while ( cycles > 0 ) { if ( cycles < i ) { i = 0 ; point ++ ; } a [ i ] [ point ] = 1 ; a [ point ] [ i ] = 1 ; cycles -= i ; i ++ ; if ( i >= point && cycles > 0 ) { i = 0 ; point ++ ; } } cout << point + 1 << endl ; for ( int i = 0 ; i <= point ; i ++ ) { for ( int j = 0 ; j <= point ; j ++ ) { cout << a [ i ] [ j ] ; } cout << endl ; } return 0 ; }
TAB0 declare constant integer N = 100010 ; TAB0 declare constant integer mod = 1e9 + 7 ; TAB0 declare add with integers x , y as arguments , returning integer ; TAB1 declare integer res = ( x + y ) % mod ; TAB1 return res + mod if res is less than 0 , else res ; TAB0 declare mul with integers x , y as arguments , returning integer ; TAB1 declare integer res = ( x * 1LL * y ) % mod ; TAB1 return res + mod if res is less than 0 , else res ; TAB1 declare integers a , b , x ; TAB1 read a and b and x ; TAB1 declare boolean ok = 1 ; TAB1 declare integer cur = - ( absolute value of a + absolute value of b ) + x ; TAB1 if cur is less than 0 ; TAB2 let ok be 0 ; TAB1 else ; TAB2 let ok be not ( cur bitwise and 1 ) ; TAB1 print " Yes " if ok is true , else print " No " ;	const int N = 100010 ; const int mod = 1e9 + 7 ; int add ( int x , int y ) { int res = ( x + y ) % mod ; return res < 0 ? res + mod : res ; } int mul ( int x , int y ) { int res = ( x * 1LL * y ) % mod ; return res < 0 ? res + mod : res ; } int main ( ) { int a , b , x ; cin >> a >> b >> x ; bool ok = 1 ; int cur = - ( abs ( a ) + abs ( b ) ) + x ; if ( cur < 0 ) { ok = 0 ; } else ok = ! ( cur & 1 ) ; ( ok ) ? puts ( " Yes " ) : puts ( " No " ) ; return 0 ; }
TAB1 aa , bb , flag = int with flag = 0 ; TAB1 noop ; TAB1 a = char array of size 15 ; TAB1 b = char array of size 15 ; TAB1 month = int array of size 12 with values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; TAB1 read a ; TAB1 read b ; TAB1 if a is " monday " ; TAB2 set aa to 1 ; TAB1 else if a is " tuesday " ; TAB2 set aa to 2 ; TAB1 else if a is " wednesday " ; TAB2 set aa to 3 ; TAB1 else if a is " thursday " ; TAB2 set aa to 4 ; TAB1 else if a is " friday " ; TAB2 set aa to 5 ; TAB1 else if a is " saturday " ; TAB2 set aa to 6 ; TAB1 else if a is " sunday " ; TAB2 set aa to 7 ; TAB1 if b is " monday " ; TAB2 set bb to 1 ; TAB1 else if b is " tuesday " ; TAB2 set bb to 2 ; TAB1 else if b is " wednesday " ; TAB2 set bb to 3 ; TAB1 else if b is " thursday " ; TAB2 set bb to 4 ; TAB1 else if b is " friday " ; TAB2 set bb to 5 ; TAB1 else if b is " saturday " ; TAB2 set bb to 6 ; TAB1 else if b is " sunday " ; TAB2 set bb to 0 ; TAB1 for i = 0 to 12 ; TAB2 if ( aa + month [ i ] ) mod 7 is bb ; TAB3 set flag to 1 ; TAB3 break ; TAB1 if flag is 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int aa , bb , flag = 0 ; ; char a [ 15 ] ; char b [ 15 ] ; int month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; cin >> a ; cin >> b ; if ( strcmp ( a , " monday " ) == 0 ) { aa = 1 ; } else if ( strcmp ( a , " tuesday " ) == 0 ) { aa = 2 ; } else if ( strcmp ( a , " wednesday " ) == 0 ) { aa = 3 ; } else if ( strcmp ( a , " thursday " ) == 0 ) { aa = 4 ; } else if ( strcmp ( a , " friday " ) == 0 ) { aa = 5 ; } else if ( strcmp ( a , " saturday " ) == 0 ) { aa = 6 ; } else if ( strcmp ( a , " sunday " ) == 0 ) { aa = 7 ; } if ( strcmp ( b , " monday " ) == 0 ) { bb = 1 ; } else if ( strcmp ( b , " tuesday " ) == 0 ) { bb = 2 ; } else if ( strcmp ( b , " wednesday " ) == 0 ) { bb = 3 ; } else if ( strcmp ( b , " thursday " ) == 0 ) { bb = 4 ; } else if ( strcmp ( b , " friday " ) == 0 ) { bb = 5 ; } else if ( strcmp ( b , " saturday " ) == 0 ) { bb = 6 ; } else if ( strcmp ( b , " sunday " ) == 0 ) { bb = 0 ; } for ( int i = 0 ; i < 12 ; i ++ ) { if ( ( aa + month [ i ] ) % 7 == bb ) { flag = 1 ; break ; } } if ( flag == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 a = integer array of length 110 ; TAB0 b = integer array of length 110 ; TAB1 s = string ; TAB1 read one line into s ; TAB1 num , ten = integers with num value of 0 and ten value of 1 ; TAB1 for i = size of s - 1 to 0 inclusive descending ; TAB2 if s [ i ] equals = then break ; TAB2 if s [ i ] is less than ' 9 ' and greater than ' 0 ' ; TAB3 x = integer with value of s [ i ] - ' 0 ' ; TAB3 increase num by x * ten ; TAB3 set ten to ten * 10 ; TAB1 cnt = integer with value of 0 ; TAB1 set a [ 0 ] to 1 ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] equals ' + ' ; TAB3 increase cnt by 1 and set a [ cnt ] to 1 ; TAB2 else if s [ i ] equals ' - ' ; TAB3 increase cnt by 1 and set a [ cnt ] to 0 ; TAB1 x = integer with value of 0 ; TAB1 for i = 0 to cnt inclusive ; TAB2 set b [ i ] to 1 ; TAB2 if a [ i ] ; TAB3 increase x by b [ i ] ; TAB2 else ; TAB3 decrease x by b [ i ] ; TAB1 set x to num - x ; TAB1 for i = 0 to cnt inclusive ; TAB2 if x is less than 0 ; TAB3 if a [ i ] equals 0 and b [ i ] is less than num ; TAB4 k = integer with value of the minimum of num - b [ i ] and negative x ; TAB4 increase b [ i ] by k ; TAB4 increase x by k ; TAB2 else if x is greater than 0 ; TAB3 if a [ i ] equals 1 and b [ i ] is less than num ; TAB4 k = integer with value of the minimum of num - b [ i ] and x ; TAB4 increase b [ i ] by k ; TAB4 decrease x by b [ i ] ; TAB2 else ; TAB3 break ; TAB1 set x to 0 ; TAB1 for i = 0 to count inclusive ; TAB2 if a [ i ] ; TAB3 increase x by b [ i ] ; TAB2 else ; TAB3 decrease x by b [ i ] ; TAB1 if x does not equal num ; TAB2 print Impossible ; TAB1 print Possible ; TAB1 set cnt to 0 ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] equals ' + ' or ' - ' or ' = ' print b [ cnt ] space s [ i ] space then increase cnt by 1 ; TAB1 print num ;	int a [ 110 ] ; int b [ 110 ] ; int main ( ) { string s ; getline ( cin , s ) ; int num = 0 , ten = 1 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' = ' ) break ; if ( s [ i ] <= ' 9 ' && s [ i ] >= ' 0 ' ) { int x = s [ i ] - ' 0 ' ; num += x * ten ; ten *= 10 ; } } int cnt = 0 ; a [ 0 ] = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' + ' ) { a [ ++ cnt ] = 1 ; } else if ( s [ i ] == ' - ' ) { a [ ++ cnt ] = 0 ; } } int x = 0 ; for ( int i = 0 ; i <= cnt ; i ++ ) { b [ i ] = 1 ; if ( a [ i ] ) x += b [ i ] ; else x -= b [ i ] ; } x = num - x ; for ( int i = 0 ; i <= cnt ; i ++ ) { if ( x < 0 ) { if ( a [ i ] == 0 && b [ i ] < num ) { int k = min ( num - b [ i ] , - x ) ; b [ i ] += k ; x += k ; } } else if ( x > 0 ) { if ( a [ i ] == 1 && b [ i ] < num ) { int k = min ( num - b [ i ] , x ) ; b [ i ] += k ; x -= k ; } } else break ; } x = 0 ; for ( int i = 0 ; i <= cnt ; i ++ ) { if ( a [ i ] ) x += b [ i ] ; else x -= b [ i ] ; } if ( x != num ) { cout << " Impossible " << endl ; return 0 ; } cout << " Possible " << endl ; cnt = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' + ' || s [ i ] == ' - ' || s [ i ] == ' = ' ) { cout << b [ cnt ++ ] << "   " << s [ i ] << "   " ; } } cout << num << endl ; return 0 ; }
TAB0 function gcd with int arguments x and y that returns integer ; TAB1 return x if y is 0 , or else gcd ( y , x % y ) ; TAB0 create new constant long double eps = 1e - 8 ; TAB0 create new long longs a and b ; TAB1 declare int variables t1 , t2 , x1 , x2 and t0 ; TAB1 read variables t1 , t2 , x1 , x2 and t0 from the input ; TAB1 if t1 = t2 ; TAB2 print x1 , ' ' and x2 to the standard output ; TAB1 if t0 is equal to t1 ; TAB2 print x1 , ' ' and 0 ; TAB1 if t0 is equal to t2 ; TAB2 print 0 , ' ' and x2 ; TAB1 declare integer variables y1 with value t2 - t0 and y2 = t0 - t1 ; TAB1 declare integer g with value gcd ( y1 , y2 ) ; TAB1 set y1 to y1 divided by g ; TAB1 change the value of y2 to y2 divided by g ; TAB1 start for loop from k = 1 to x2 inclusive incrementing k ; TAB2 create new long long variable l = ( k * y1 ) / y2 ; TAB2 set value of l to min of l and x1 ; TAB2 if a and b are both equal to 0 ; TAB3 set a to l ; TAB3 change b to k ; TAB3 skip the rest of the loop ; TAB2 if l * b > = a * k ; TAB3 change the value of a to l ; TAB3 set b to k ; TAB1 print a , ' ' and b ;	int gcd ( int x , int y ) { return ( y == 0 ) ? x : gcd ( y , x % y ) ; } const long double eps = 1e-8 ; long long a , b ; int main ( ) { int t1 , t2 , x1 , x2 , t0 ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; if ( t1 == t2 ) { cout << x1 << '   ' << x2 << endl ; return 0 ; } if ( t0 == t1 ) { cout << x1 << '   ' << 0 << endl ; return 0 ; } if ( t0 == t2 ) { cout << 0 << '   ' << x2 << endl ; return 0 ; } int y1 = t2 - t0 , y2 = t0 - t1 ; int g = gcd ( y1 , y2 ) ; y1 /= g ; y2 /= g ; for ( long long k = 1 ; k <= x2 ; k ++ ) { long long l = ( k * y1 ) / y2 ; l = min ( l , ( long long ) x1 ) ; if ( a == 0 && b == 0 ) { a = l ; b = k ; continue ; } if ( l * b >= a * k ) { a = l ; b = k ; } } cout << a << '   ' << b << endl ; return 0 ; }
TAB0 declare constant integer P = 1e9 + 7 ; TAB0 declare gcd with long longs a , b as arguments , returning long long ; TAB1 return b if result of run gcd ( b , a % b ) is true else a ; TAB0 declare qpow with long longs a , n as arguments , returning long long ; TAB1 declare long long r = 1 % P ; TAB1 for let a be a % P , n , let a be a * a % P , setting n to n bitshift right 1 ; TAB2 if n bitwise and 1 , let r be r * a % P ; TAB1 return r from function ; TAB0 declare inv with long long x as argument , returning long long ; TAB1 returnn 1 if x is less than or equal to 1 else result of run inv ( P % x ) * ( P - P / x ) % P ; TAB0 declare constant integer N = 2e5 + 10 ; TAB0 declare integer arrays a size N , b size N , f size N , integers n , m , k ; TAB1 declare long longs x1 , y1 , x2 , y2 ; TAB1 read x1 , y1 , x2 y2 ; TAB1 declare integer ans = 0 ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 declare long longs a , b , c ; TAB2 read a , b , c ; TAB2 declare long long x = ( a * x1 + b * y1 + c ) ; TAB2 declare long long y = ( a * x2 + b * y2 + c ) ; TAB2 if x is greater than 0 and y is less than 0 or x is less than 0 and y is greater than 0 , increment ans ; TAB1 print ans and newline ;	const int P = 1e9 + 7 ; long long gcd ( long long a , long long b ) { return b ? gcd ( b , a % b ) : a ; } long long qpow ( long long a , long long n ) { long long r = 1 % P ; for ( a %= P ; n ; a = a * a % P , n >>= 1 ) if ( n & 1 ) r = r * a % P ; return r ; } long long inv ( long long x ) { return x <= 1 ? 1 : inv ( P % x ) * ( P - P / x ) % P ; } const int N = 2e5 + 10 ; int a [ N ] , b [ N ] , f [ N ] , n , m , k ; int main ( ) { long long x1 , y1 , x2 , y2 ; cin >> x1 >> y1 >> x2 >> y2 ; int ans = 0 ; cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { long long a , b , c ; cin >> a >> b >> c ; long long x = ( a * x1 + b * y1 + c ) ; long long y = ( a * x2 + b * y2 + c ) ; if ( x > 0 && y < 0 || x < 0 && y > 0 ) ++ ans ; } cout << ans << endl ; }
TAB0 make static int mod = 1e9 + 7 ; TAB1 make int n , m , array row of size 105 , array col of size 105 , multidimensional array table of size 105x105 , minn , and flag ; TAB1 while read n and m ; TAB2 set flag to 0 ; TAB2 set row elements to 0 ; TAB2 set col elements to 0 ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to m inclusive , read table [ i ] [ j ] ; TAB2 if m greater than or equal to n ; TAB3 for i = 1 to n inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for j = 1 to m inclusive ; TAB5 if table [ i ] [ j ] less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 set row [ i ] to minn ; TAB5 for j = 1 to m inclusive , subtract minn from table [ i ] [ j ] ; TAB3 for j = 1 to m inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for i = 1 to n inclusive ; TAB5 if table [ i ] [ j ] less than minn , set minn to table [ i ] j ] ; TAB4 if minn ; TAB5 set col [ j ] to minn ; TAB5 for i = 1 to n inclusive , subtract minn from table [ i ] [ j ] ; TAB2 else ; TAB3 for j = 1 to m inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for i = 1 to n inclusive ; TAB5 if table [ i ] [ j ] less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 set col [ j ] to minn ; TAB5 for i = 1 to n inclusive , subtract minn from table [ i ] [ j ] ; TAB3 for i = 1 to n inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for j = 1 to m inclusive ; TAB5 if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 set row [ i ] to minn ; TAB5 for j = 1 to m inclusive , decrease table [ i ] [ j ] by minn ; TAB2 set flag to 1 ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to m inclusive ; TAB4 if table [ i ] [ j ] ; TAB5 set flag to 0 ; TAB5 break ; TAB2 if flag ; TAB3 make int tmp = 0 ; TAB3 for i = 1 to n inclusive , increase tmp by row [ i ] ; TAB3 for j = 1 to m inclusive , increase tmp by col [ j ] ; TAB3 print tmp ; TAB3 for i = 1 to n inclusive ; TAB4 for k = 1 to row [ i ] inclusive , print " row " i ; TAB3 for j = 1 to m inclusive ; TAB4 for k = 1 to col [ j ] inclusive , print " col " j ; TAB2 else ; TAB3 print " - 1 \ n " ;	static int mod = 1e9 + 7 ; int main ( ) { int n , m , row [ 105 ] , col [ 105 ] , table [ 105 ] [ 105 ] , minn , flag ; while ( cin >> n >> m ) { flag = 0 ; memset ( row , 0 , sizeof ( row ) ) ; memset ( col , 0 , sizeof ( col ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) cin >> table [ i ] [ j ] ; } if ( m >= n ) { for ( int i = 1 ; i <= n ; i ++ ) { minn = 0x3f3f3f3f ; for ( int j = 1 ; j <= m ; j ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { row [ i ] = minn ; for ( int j = 1 ; j <= m ; j ++ ) table [ i ] [ j ] -= minn ; } } for ( int j = 1 ; j <= m ; j ++ ) { minn = 0x3f3f3f3f ; for ( int i = 1 ; i <= n ; i ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { col [ j ] = minn ; for ( int i = 1 ; i <= n ; i ++ ) table [ i ] [ j ] -= minn ; } } } else { for ( int j = 1 ; j <= m ; j ++ ) { minn = 0x3f3f3f3f ; for ( int i = 1 ; i <= n ; i ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { col [ j ] = minn ; for ( int i = 1 ; i <= n ; i ++ ) table [ i ] [ j ] -= minn ; } } for ( int i = 1 ; i <= n ; i ++ ) { minn = 0x3f3f3f3f ; for ( int j = 1 ; j <= m ; j ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { row [ i ] = minn ; for ( int j = 1 ; j <= m ; j ++ ) table [ i ] [ j ] -= minn ; } } } flag = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) { if ( table [ i ] [ j ] ) { flag = 0 ; break ; } } if ( flag ) { int tmp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { tmp += row [ i ] ; } for ( int j = 1 ; j <= m ; j ++ ) { tmp += col [ j ] ; } cout << tmp << ' \n ' ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 1 ; k <= row [ i ] ; k ++ ) cout << " row  " << i << ' \n ' ; } for ( int j = 1 ; j <= m ; j ++ ) { for ( int k = 1 ; k <= col [ j ] ; k ++ ) cout << " col  " << j << ' \n ' ; } } else cout << " -1\n " ; } return 0 ; }
TAB1 let x , t , a , b , Da , Db , total be integers with total = 0 ; TAB1 initialize boolean value right to false ; TAB1 let aa , bb be integers ; TAB1 read x , t , a , b , Da , Db ; TAB1 aa is equal to 0 ; TAB1 bb is equal to 0 ; TAB1 for i = 0 to t inclusive ; TAB2 for i = 0 to t inclusive ; TAB3 total is equal to aa + bb ; TAB3 if total is equal to x ; TAB4 right is equal to true ; TAB4 stop ; TAB3 bb is equal to b - Db * ( i ) ; TAB2 if right is true , stop ; TAB2 aa is equal to a - Da * ( i ) ; TAB2 bb is equal to 0 ; TAB1 if right is true ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 print NO and new line ;	int main ( ) { int x , t , a , b , Da , Db , total = 0 ; bool right = false ; int aa , bb ; cin >> x >> t >> a >> b >> Da >> Db ; aa = 0 ; bb = 0 ; for ( int i = 0 ; i <= t ; i ++ ) { for ( int i = 0 ; i <= t ; i ++ ) { total = aa + bb ; if ( total == x ) { right = true ; break ; } bb = b - Db * ( i ) ; } if ( right ) { break ; } aa = a - Da * ( i ) ; bb = 0 ; } if ( right ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB0 declare constant integer INF = 1e9 + 10 ; TAB0 declare map from integer to character rep ; TAB0 declare integer arrays cnt size 3 , tp size 110 ; TAB0 declare con with character ch as argument , returning integer ; TAB1 if ' a ' is less than or equal to ch and ch is less than or equal to ' z ' , return 0 from function ; TAB1 if ' A ' is less than or equal to ch and ch is less than or equal to ' Z ' , return 1 from function ; TAB1 return 2 ; TAB1 let rep [ 1 ] be ' a ' ; TAB1 let rep [ 2 ] be ' A ' ; TAB1 let rep [ 4 ] be ' 1 ' ; TAB1 declare integer Tst ; TAB1 read Tst ; TAB1 while decrement Tst is true ; TAB2 declare string s ; TAB2 read s ; TAB2 declare integer msk = 0 ; TAB2 let cnt [ 0 ] be cnt [ 1 ] be cnt [ 2 ] be 0 ; TAB2 for i = 0 to integer casted size of s exclusive ; TAB3 let tp [ i ] be result of run con ( s [ i ] ) ; TAB3 let msk be msk bitwise or ( 1 bitshift left tp [ i ] ) ; TAB3 increment cnt [ tp [ i ] ] ; TAB2 if msk is 7 ; TAB3 print s , ' \ n ' ; TAB2 else if result of run __builtin_popcount ( msk ) is 2 ; TAB3 for i = 0 to integer casted size of s exclusive ; TAB4 if cnt [ tp [ i ] ] is greater than 1 ; TAB5 let s [ i ] be rep [ 7 bitwise xor msk ] ; TAB5 end loop ; TAB3 print s , ' \ n ' ; TAB2 else ; TAB3 declare integer M = 7 bitwise xor msk ; TAB3 declare integer t = result of run __builtin_ctz ( M ) ; TAB3 let M be M bitwise xor ( 1 bitshift left t ) ; TAB3 let s [ 0 ] be rep [ 1 bitshift left t ] ; TAB3 let s [ 1 ] be rep [ 1 bitshift left result of run __builtin_ctz ( M ) ] ; TAB3 print s , ' \ n ' ;	const int INF = 1e9 + 10 ; map < int , char > rep ; int cnt [ 3 ] , tp [ 110 ] ; int con ( char ch ) { if ( ' a ' <= ch && ch <= ' z ' ) return 0 ; if ( ' A ' <= ch && ch <= ' Z ' ) return 1 ; return 2 ; } int main ( ) { rep [ 1 ] = ' a ' ; rep [ 2 ] = ' A ' ; rep [ 4 ] = ' 1 ' ; int Tst ; cin >> Tst ; while ( Tst -- ) { string s ; cin >> s ; int msk = 0 ; cnt [ 0 ] = cnt [ 1 ] = cnt [ 2 ] = 0 ; for ( int i = 0 ; i < ( ( int ) ( s ) . size ( ) ) ; i ++ ) { tp [ i ] = con ( s [ i ] ) ; msk |= 1 << tp [ i ] ; ++ cnt [ tp [ i ] ] ; } if ( msk == 7 ) cout << s << ' \n ' ; else if ( __builtin_popcount ( msk ) == 2 ) { for ( int i = 0 ; i < ( ( int ) ( s ) . size ( ) ) ; i ++ ) if ( cnt [ tp [ i ] ] > 1 ) { s [ i ] = rep [ 7 ^ msk ] ; break ; } cout << s << ' \n ' ; } else { int M = 7 ^ msk ; int t = __builtin_ctz ( M ) ; M ^= 1 << t ; s [ 0 ] = rep [ 1 << t ] ; s [ 1 ] = rep [ 1 << ( __builtin_ctz ( M ) ) ] ; cout << s << ' \n ' ; } } return 0 ; }
TAB0 oo , MN = const int with oo = 1e9 and MN = 100010 ; TAB0 par , cnt = int array of size MN each ; TAB0 in function findSet taking an int and returning an int ; TAB1 return i if par [ i ] is i else set par [ i ] to findSet of par [ i ] and return it ; TAB0 in function unionSet taking two ints i and j ; TAB1 set par [ findSet of i ] to findSet of j ; TAB1 n = int ; TAB1 read n ; TAB1 k = long long ; TAB1 read k ; TAB1 a = long long vector of size n ; TAB1 read n values into a ; TAB1 sort a ; TAB1 for i = 0 to n set par [ i ] to i ; TAB1 for i = n - 1 to 0 inclusive decrementing i ; TAB2 p = int with p = lower_bounds of begin of a , end of a and a [ i ] * k - begin of a ; TAB2 if a [ p ] is a [ i ] * k then call unionSet on i and p ; TAB1 for i = 0 to n increment cnt [ findSet of i ] ; TAB1 ans = int with ans = 0 ; TAB1 for i = 0 to n increment ans by ( cnt [ i ] + 1 ) / ; TAB1 print ans ;	const int oo = 1e9 , MN = 100010 ; int par [ MN ] , cnt [ MN ] ; int findSet ( int i ) { return par [ i ] == i ? i : par [ i ] = findSet ( par [ i ] ) ; } void unionSet ( int i , int j ) { par [ findSet ( i ) ] = findSet ( j ) ; } int main ( ) { int n ; cin >> n ; long long k ; cin >> k ; vector < long long > a ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a . begin ( ) , a . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) par [ i ] = i ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int p = lower_bound ( a . begin ( ) , a . end ( ) , a [ i ] * k ) - a . begin ( ) ; if ( a [ p ] == a [ i ] * k ) unionSet ( i , p ) ; } for ( int i = 0 ; i < n ; i ++ ) cnt [ findSet ( i ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += ( cnt [ i ] + 1 ) / 2 ; cout << ans << ' \n ' ; return 0 ; }
TAB0 constant integer variable maxn = 4 + 3 ; TAB1 new array of integers a with size maxn ; TAB1 read input to a [ 1 ] and a [ 2 ] ; TAB1 declare integer d with value a [ 2 ] - a [ 1 ] ; TAB1 create double variable with name q = a [ 2 ] * 1 . 0 / a [ 1 ] ; TAB1 declare bools flag1 and flag2 = 1 ; TAB1 in a for loop , change i from 3 to 4 inclusive incrementing i ; TAB2 read user input to a [ i ] ; TAB2 if flag1 is true and a [ i ] - a [ i - 1 ] ! = d , assign the new value = 0 to flag1 ; TAB2 if flag2 is true and fabs ( a [ i ] * 1 . 0 / a [ i - 1 ] - q ) > 1e - 7 , change the value of flag2 to 0 ; TAB1 if flag1 is true ; TAB2 print a [ 4 ] + d ; TAB1 else if flag2 is true and fabs ( a [ 4 ] * q - int ( a [ 4 ] * q + 0 . 5 ) < 1e - 7 ; TAB2 print a [ 4 ] * q + 0 . 5 casted to integer and a new line ; TAB1 else ; TAB2 print 42 ;	const int maxn = 4 + 3 ; int main ( ) { int a [ maxn ] ; cin >> a [ 1 ] >> a [ 2 ] ; int d = a [ 2 ] - a [ 1 ] ; double q = a [ 2 ] * 1.0 / a [ 1 ] ; bool flag1 = 1 , flag2 = 1 ; for ( int i = 3 ; i <= 4 ; i ++ ) { cin >> a [ i ] ; if ( flag1 && a [ i ] - a [ i - 1 ] != d ) { flag1 = 0 ; } if ( flag2 && fabs ( a [ i ] * 1.0 / a [ i - 1 ] - q ) > 1e-7 ) { flag2 = 0 ; } } if ( flag1 ) { cout << a [ 4 ] + d << endl ; return 0 ; } else if ( flag2 && fabs ( a [ 4 ] * q - int ( a [ 4 ] * q + 0.5 ) ) < 1e-7 ) { cout << int ( a [ 4 ] * q + 0.5 ) << endl ; return 0 ; } else { cout << 42 << endl ; } return 0 ; }
TAB1 n = int ; TAB1 read n ; TAB1 while decremented value of n is not 0 ; TAB2 f = 1 ; TAB2 c = char ; TAB2 x1 , y1 , x2 , y2 = int ; TAB2 for i = 0 to 8 exclusive ; TAB3 for j = 0 to 8 exclusive ; TAB4 read c ; TAB4 if c is ' K ' and f ; TAB5 x1 = i ; TAB5 y1 = j ; TAB5 f = 0 ; TAB4 else if c is ' K ' ; TAB5 x2 = i ; TAB5 y2 = j ; TAB2 if ( x2 - x1 ) and ( y2 - y1 ) are multiple of 4 ; TAB3 print YES ; TAB2 else ; TAB3 print NO ;	int main ( ) { int n ; cin >> n ; while ( n -- ) { int f = 1 ; char c ; int x1 , y1 , x2 , y2 ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { cin >> c ; if ( c == ' K ' && f ) { x1 = i ; y1 = j ; f = 0 ; } else if ( c == ' K ' ) { x2 = i ; y2 = j ; } } } if ( ( x2 - x1 ) % 4 == 0 && ( y2 - y1 ) % 4 == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB1 create doubles a , b , c , d and k ; TAB1 read user input to a , b , c and d ; TAB1 if a - b = b - c and b - c = c - d ; TAB2 print d + b - a ; TAB1 else ; TAB2 if b / a = c / b and c / b = d / c ; TAB3 assign d * ( b / a ) to k ; TAB3 if k = k casted to integer ; TAB4 print k to the standard output ; TAB3 else ; TAB4 print 42 ; TAB2 else ; TAB3 print 42 ;	int main ( ) { double a , b , c , d , k ; cin >> a >> b >> c >> d ; if ( ( a - b ) == ( b - c ) && ( b - c ) == ( c - d ) ) { cout << d + ( b - a ) << endl ; } else { if ( ( b / a ) == ( c / b ) && ( c / b ) == ( d / c ) ) { k = d * ( b / a ) ; if ( k == ( int ) k ) { cout << k << endl ; } else { cout << 42 << endl ; } } else { cout << 42 << endl ; } } return 0 ; }
TAB0 long long function gcd1 with long long arguments a and b ; TAB1 return b if a = 0 ; TAB1 return gcd1 of b modulo a and a ; TAB0 long long function modx with long long arguments base and ex ; TAB1 declare long long variables ans = 1LL and val = base ; TAB1 while ex > 0LL ; TAB2 if ex & 1LL is true , set ans to ( ans * val ) % 1000000009LL ; TAB2 assign ( val * val ) % 1000000009LL to val ; TAB2 change ex to ex > > 1LL ; TAB1 return ans ; TAB0 declare vector of strings variables hr and mn ; TAB0 declare int array used with size 8 ; TAB0 void function calc with int arguments ind , pw and ty , long long argument last and num and string argument s ; TAB1 if ind is equal to 0 ; TAB2 if num > last or s is empty , return ; TAB2 if ty is false ; TAB3 push s to hr ; TAB2 else ; TAB3 push s to mn ; TAB2 return ; TAB1 loop i from 0 to 7 exclusive ; TAB2 if used [ i ] is false ; TAB3 change used [ i ] to 1 ; TAB3 invoke function calc with arguments ind - 1 , last , num + i * pw , pw * 7 , ty and s + ( char ) ( i + ' 0 ' ) ; TAB3 set used [ i ] to 0 ; TAB1 declare long long variables n and m ; TAB1 read from the input to n and m ; TAB1 decrement n ; TAB1 decrement m ; TAB1 declare integers cpy = n , cnt1 = 0 and cnt2 = 0 ; TAB1 while cpy ! = 0 ; TAB2 divide cpy by 7 ; TAB2 increment cnt1 by one ; TAB1 set cnt1 to max of 1 and cnt1 ; TAB1 set cpy to m ; TAB1 while cpy ! = 0 ; TAB2 divide cpy by 7 ; TAB2 increment cnt2 by one ; TAB1 set cnt2 to max of 1 and cnt2 ; TAB1 if cnt1 + cnt2 is greater than 7 ; TAB2 print " 0 " ; TAB1 call function calc with arguments cnt1 , n , 0 , 1 , 0 and " " ; TAB1 call function calc with arguments cnt2 , m , 0 , 1 , 1 and " " ; TAB1 create int ans = 0 ; TAB1 for integer i = 0 to length of hr exclusive ; TAB2 set sizeof ( used ) bytes at the pointer used to 0 ; TAB2 declare integer l ; TAB2 for l from 0 to length of hr [ i ] exclusive , change used [ hr [ i ] [ l ] - ' 0 ' ] to 1 ; TAB2 for j from 0 to length of mn exclusive ; TAB3 for l from 0 to length of mn [ j ] exclusive ; TAB4 if used [ mn [ j ] [ l ] - ' 0 ' ] ! = 0 , break ; TAB3 if l is equal to length of mn [ j ] , increment ans by one ; TAB1 print ans ;	long long gcd1 ( long long a , long long b ) { if ( a == 0 ) return b ; return gcd1 ( b % a , a ) ; } long long modx ( long long base , long long ex ) { long long ans = 1LL , val = base ; while ( ex > 0LL ) { if ( ex & 1LL ) ans = ( ans * val ) % 1000000009LL ; val = ( val * val ) % 1000000009LL ; ex = ex >> 1LL ; } return ans ; } vector < string > hr , mn ; int used [ 8 ] ; void calc ( int ind , long long last , long long num , int pw , int ty , string s ) { if ( ind == 0 ) { if ( num > last || ! s . length ( ) ) return ; if ( ! ty ) hr . push_back ( s ) ; else mn . push_back ( s ) ; return ; } for ( int i = 0 ; i < 7 ; i ++ ) { if ( ! used [ i ] ) { used [ i ] = 1 ; calc ( ind - 1 , last , num + i * pw , pw * 7 , ty , s + ( char ) ( i + ' 0 ' ) ) ; used [ i ] = 0 ; } } } int main ( ) { long long n , m ; cin >> n >> m ; n -- ; m -- ; int cpy = n , cnt1 = 0 , cnt2 = 0 ; while ( cpy ) { cpy /= 7 ; cnt1 ++ ; } cnt1 = max ( 1 , cnt1 ) ; cpy = m ; while ( cpy ) { cpy /= 7 ; cnt2 ++ ; } cnt2 = max ( 1 , cnt2 ) ; if ( cnt1 + cnt2 > 7 ) { cout << " 0 " << endl ; return 0 ; } calc ( cnt1 , n , 0 , 1 , 0 , "  " ) ; calc ( cnt2 , m , 0 , 1 , 1 , "  " ) ; int ans = 0 ; for ( int i = 0 ; i < hr . size ( ) ; i ++ ) { memset ( used , 0 , sizeof ( used ) ) ; int l ; for ( l = 0 ; l < hr [ i ] . length ( ) ; l ++ ) used [ hr [ i ] [ l ] - ' 0 ' ] = 1 ; for ( int j = 0 ; j < mn . size ( ) ; j ++ ) { for ( l = 0 ; l < mn [ j ] . length ( ) ; l ++ ) if ( used [ mn [ j ] [ l ] - ' 0 ' ] ) break ; if ( l == mn [ j ] . length ( ) ) ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 create new sets of unique integers s1 and s2 ; TAB0 create integer set iterator it ; TAB0 create a map from integers to integers with name mp ; TAB1 n , i , j , x , a , m , ans , p and ne are integer variables with ans , p and ne = 0 ; TAB1 read from the input to n ; TAB1 for i = 0 to n exclusive incrementing i ; TAB2 read x and a ; TAB2 if x is greater than 0 ; TAB3 insert x into s1 ; TAB3 increase p by a ; TAB2 else ; TAB3 insert x into set s2 ; TAB3 add a to ne ; TAB2 change mp [ x ] to a ; TAB1 set m to the length of s2 if length of s1 > length of s2 , or length of s1 otherwise ; TAB1 if length of s1 = length of s2 ; TAB2 print p + ne to the standard output ; TAB1 else if length of s1 is greater than length of s2 ; TAB2 set it to the start of s1 ; TAB2 assign 0 to i ; TAB2 while i < = m ; TAB3 change ans to sum of ans and mp [ * it ] ; TAB3 increment i ; TAB3 increment it ; TAB2 print ans + ne ; TAB1 else ; TAB2 set it to the end of s2 ; TAB2 decrement it ; TAB2 assign 0 to i ; TAB2 while i < = m ; TAB3 add mp [ * it ] to ans ; TAB3 increment i ; TAB3 decrement it ; TAB2 print ans + p ;	set < int > s1 , s2 ; set < int > :: iterator it ; map < int , int > mp ; int main ( ) { int n , i , j , x , a , m , ans = 0 , p = 0 , ne = 0 ; cin >> n ; for ( i = 0 ; i < n ; ++ i ) { cin >> x >> a ; if ( x > 0 ) { s1 . insert ( x ) ; p += a ; } else { s2 . insert ( x ) ; ne += a ; } mp [ x ] = a ; } m = ( s1 . size ( ) > s2 . size ( ) ? s2 . size ( ) : s1 . size ( ) ) ; if ( s1 . size ( ) == s2 . size ( ) ) { cout << p + ne << endl ; } else if ( s1 . size ( ) > s2 . size ( ) ) { it = s1 . begin ( ) ; i = 0 ; while ( i <= m ) { ans += mp [ * it ] ; ++ i ; ++ it ; } cout << ans + ne << endl ; } else { it = s2 . end ( ) ; -- it ; i = 0 ; while ( i <= m ) { ans += mp [ * it ] ; ++ i ; -- it ; } cout << ans + p << endl ; } return 0 ; }
TAB0 create new constant integer called maxn = 1100 ; TAB0 declare new constant integer called inf with value 0x3f3f3f3f ; TAB0 create new array of characters a with maxn elements ; TAB1 declare new integer variable n ; TAB1 read input to n ; TAB1 for i from 1 to n inclusive , read a [ i ] from the input ; TAB1 if n = 1 and a [ 1 ] is equal to ' 0 ' ; TAB2 print " No " ; TAB1 if a [ 1 ] is equal to ' 0 ' and a [ 2 ] is equal to ' 0 ' ; TAB2 print " No " to the standard output ; TAB1 if a [ n ] and a [ n - 1 ] are both ' 0 ' ; TAB2 print " No " to the standard output ; TAB1 in a for loop , change i from 1 to n inclusive ; TAB2 if a [ i ] and a [ i + 1 ] are both equal to ' 1 ' ; TAB3 print " No " to the standard output ; TAB2 if a [ i ] = a [ i + 1 ] and a [ i ] = a [ i - 1 ] ; TAB3 print " No " ; TAB1 print " Yes " ;	const int maxn = 1100 ; const int inf = 0x3f3f3f3f ; char a [ maxn ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } if ( n == 1 && a [ 1 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } if ( a [ 1 ] == ' 0 ' && a [ 2 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } if ( a [ n ] == ' 0 ' && a [ n - 1 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] == ' 1 ' && a [ i + 1 ] == ' 1 ' ) { cout << " No " << endl ; return 0 ; } if ( a [ i ] == a [ i + 1 ] && a [ i ] == a [ i - 1 ] ) { cout << " No " << endl ; return 0 ; } } cout << " Yes " << endl ; return 0 ; }
TAB0 let x , y be strings , s = array of strings of length 15 ; TAB1 s [ 1 ] is equal to monday ; TAB1 s [ 2 ] is equal to tuesday ; TAB1 s [ 3 ] is equal to wednesday ; TAB1 s [ 4 ] is equal to thursday ; TAB1 s [ 5 ] is equal to friday ; TAB1 s [ 6 ] is equal to saturday ; TAB1 s [ 7 ] is equal to sunday ; TAB1 read x , y ; TAB1 let num1 , num2 be integers with num1 = 0 , num2 = 0 ; TAB1 for integer i = 1 to 7 inclusive ; TAB2 if x is equal to s [ i ] , num1 is equal to i ; TAB1 for integer i = 1 to 7 inclusive ; TAB2 if y is equal to s [ i ] , num2 is equal to i ; TAB1 if num2 is less than num1 , increment num2 by 7 ; TAB1 the integer value of sum = num2 - num1 ; TAB1 if sum equals 0 or sum equals 2 or sum equals 3 ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 print NO and newline ;	string s [ 15 ] , x , y ; int main ( ) { s [ 1 ] = " monday " ; s [ 2 ] = " tuesday " ; s [ 3 ] = " wednesday " ; s [ 4 ] = " thursday " ; s [ 5 ] = " friday " ; s [ 6 ] = " saturday " ; s [ 7 ] = " sunday " ; cin >> x >> y ; int num1 = 0 , num2 = 0 ; for ( int i = 1 ; i <= 7 ; i ++ ) { if ( x == s [ i ] ) { num1 = i ; } } for ( int i = 1 ; i <= 7 ; i ++ ) { if ( y == s [ i ] ) { num2 = i ; } } if ( num2 < num1 ) { num2 += 7 ; } int sum = num2 - num1 ; if ( sum == 0 || sum == 2 || sum == 3 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 f , g = unsigned long long array of size 19 each ; TAB0 in function get_f ; TAB1 set f [ 1 ] and f [ 2 ] to 9 ; TAB1 for i = 3 to 18 inclusive set f [ i ] to f [ i - 1 ] * 10 ; TAB0 in fun ; TAB1 set g [ 0 ] to 1 ; TAB1 for i = 1 to 18 inclusive set g [ i ] to g [ i - 1 ] * 10 ; TAB0 in function cal taking a string n and returning an unsigned long long ; TAB1 len = int with len = length of n ; TAB1 if len is 1 then return n [ 0 ] - ' 0 ' ; TAB1 first = int with first = n [ 0 ] - ' 0 ' ; TAB1 last = int with last = n [ len - 1 ] - ' 0 ' ; TAB1 ret = unsigned long long with ret = 0 ; TAB1 for i = 1 to len increment ret by f [ i ] ; TAB1 for i = 1 to first increment ret by g [ len - 2 ] ; TAB1 s = string with s = n without the first and last char ; TAB1 p = unsigned long long with p = 1 + ( 1 if length of s is 0 else the parsed long long value of s ) ; TAB1 if first is less or equal to last ; TAB2 increment ret by p ; TAB1 else ; TAB2 increment ret by p - 1 ; TAB1 return ret ; TAB1 call get_f ; TAB1 call get_g ; TAB1 l , r = string ; TAB1 read l then r ; TAB1 ret = unsigned long long with ret = cal of r - cal of l ; TAB1 if l [ 0 ] is l [ length of l - 1 ] then increment ret ; TAB1 print ret ;	unsigned long long f [ 19 ] , g [ 19 ] ; void get_f ( ) { f [ 1 ] = f [ 2 ] = 9 ; for ( int i = 3 ; i <= 18 ; i ++ ) f [ i ] = f [ i - 1 ] * 10 ; } void get_g ( ) { g [ 0 ] = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) g [ i ] = g [ i - 1 ] * 10 ; } unsigned long long cal ( string n ) { int len = n . length ( ) ; if ( len == 1 ) return n [ 0 ] - ' 0 ' ; int first = n [ 0 ] - ' 0 ' ; int last = n [ len - 1 ] - ' 0 ' ; unsigned long long ret = 0 ; for ( int i = 1 ; i < len ; i ++ ) ret += f [ i ] ; for ( int i = 1 ; i < first ; i ++ ) ret += g [ len - 2 ] ; string s = n . substr ( 1 , n . length ( ) - 2 ) ; unsigned long long p = ( ! s . length ( ) ) ? 1 : atoll ( s . c_str ( ) ) + 1 ; if ( first <= last ) ret += p ; else ret += p - 1 ; return ret ; } int main ( ) { get_f ( ) ; get_g ( ) ; string l , r ; cin >> l >> r ; unsigned long long ret = cal ( r ) - cal ( l ) ; if ( l [ 0 ] == l [ l . length ( ) - 1 ] ) ret ++ ; cout << ret << endl ; return 0 ; }
TAB0 N , M = int ; TAB0 nxt , cap = array of 1001 int ; TAB0 idgr , odgr = array of 1001 bool ; TAB1 read N , M ; TAB1 for i = 1 to M inclusive ; TAB2 a , b , c = int ; TAB2 read a , b , c ; TAB2 odgr [ a ] = 1 ; TAB2 idgr [ b ] = 1 ; TAB2 nxt [ a ] = b ; TAB2 cap [ a ] = c ; TAB1 cnt = 0 ; TAB1 for i = 1 to N inclusive ; TAB2 if not idgr [ i ] and odgr [ i ] increment cnt ; TAB1 print cnt ; TAB1 for i = 1 to N inclusive ; TAB2 if not idgr [ i ] and odgr [ i ] ; TAB3 d = INT_MAX ; TAB3 n = i ; TAB3 while odgr [ n ] ; TAB4 d = min ( d , cap [ n ] ) ; TAB4 n = nxt [ n ] ; TAB3 print i , space , n , space , d ;	int N , M ; int nxt [ 1001 ] , cap [ 1001 ] ; bool idgr [ 1001 ] , odgr [ 1001 ] ; int main ( ) { cin >> N >> M ; for ( int i = 1 ; i <= M ; i ++ ) { int a , b , c ; cin >> a >> b >> c ; odgr [ a ] = 1 ; idgr [ b ] = 1 ; nxt [ a ] = b ; cap [ a ] = c ; } int cnt = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! idgr [ i ] && odgr [ i ] ) { cnt ++ ; } } cout << cnt << endl ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! idgr [ i ] && odgr [ i ] ) { int d = INT_MAX ; int n = i ; while ( odgr [ n ] ) { d = min ( d , cap [ n ] ) ; n = nxt [ n ] ; } cout << i << "   " << n << "   " << d << endl ; } } }
TAB0 declare new array of integers open with size 100005 ; TAB1 create integer variable n ; TAB1 define new integer called cnt with value 0 ; TAB1 read from the input to n ; TAB1 define integer arrays a , b and c with size 100005 ; TAB1 read n elements into variables a and b ; TAB1 for i = 0 to n exclusive ; TAB2 in a for loop , increment j from 0 to n exclusive ; TAB3 if b [ i ] = a [ j ] and i ! = j , set c [ j ] to 1 ; TAB1 for integer i = 0 to n exclusive incrementing i ; TAB2 if c [ i ] is equal to 0 , increment cnt ; TAB1 print cnt ;	int open [ 100005 ] ; int main ( ) { int n ; int cnt = 0 ; cin >> n ; int a [ 100005 ] , b [ 100005 ] , c [ 100005 ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ i ] == a [ j ] && i != j ) { c [ j ] = 1 ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( c [ i ] == 0 ) { cnt ++ ; } } cout << cnt << endl ; }
TAB1 declare ints n and m ; TAB1 create double k ; TAB1 create a map from strings to integers called mm ; TAB1 read from the input to n , m and k ; TAB1 declare string name ; TAB1 declare int level ; TAB1 for i = 0 to n exclusive ; TAB2 read input to name and level ; TAB2 if level * k + 1e - 4 > = 100 , set mm [ name ] to level * k + 1e - 4 ; TAB1 loop i from 0 to m exclusive ; TAB2 read name ; TAB2 if mm is not empty , set mm [ name ] to 0 ; TAB1 print length of mm ; TAB1 create map iterator it and loop it through mm , printing it - > first and it - > second on each iteration ;	int main ( ) { int n , m ; double k ; map < string , int > mm ; cin >> n >> m >> k ; string name ; int level ; for ( int i = 0 ; i < n ; i ++ ) { cin >> name >> level ; if ( level * k + 1e-4 >= 100 ) mm [ name ] = level * k + 1e-4 ; } for ( int i = 0 ; i < m ; i ++ ) { cin >> name ; if ( ! mm . count ( name ) ) mm [ name ] = 0 ; } cout << mm . size ( ) << endl ; for ( map < string , int > :: iterator it = mm . begin ( ) ; it != mm . end ( ) ; it ++ ) { cout << it -> first << '   ' << it -> second << endl ; } }
TAB0 in function has taking char c returning int ; TAB1 return c - ' a ' ; TAB1 n = int ; TAB1 read n ; TAB1 freq = int array of size 26 ; TAB1 set all values of freq to 0 ; TAB1 str = string ; TAB1 read str ; TAB1 flag = int with flag = 0 ; TAB1 for i = 0 to n ; TAB2 index = int with index = has of str [ i ] ; TAB2 increment freq [ index ] ; TAB2 if freq [ index ] > = 2 or n is 1 ; TAB3 set flag to 1 ; TAB3 break ; TAB2 else ; TAB3 set flag to 0 ; TAB1 if flag is 0 ; TAB2 print " No " ; TAB3 print newline ; TAB1 else ; TAB2 print " Yes " ; TAB3 print newline ;	int has ( char c ) { return ( c - ' a ' ) ; } int main ( ) { int n ; cin >> n ; int freq [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; string str ; cin >> str ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int index = has ( str [ i ] ) ; freq [ index ] ++ ; if ( ( freq [ index ] >= 2 ) || ( n == 1 ) ) { flag = 1 ; break ; } else flag = 0 ; } if ( flag == 0 ) cout << " No " << " \n " ; else cout << " Yes " << " \n " ; return 0 ; }
TAB0 N = 1e5 ; TAB0 create long long n , s , x , y , mx and c , set mx to - 1 ; TAB0 create vector long long v ; TAB1 read n and s ; TAB1 for i = 0 to n exclusive ; TAB2 read x and y ; TAB2 if x = s and y = 0 ; TAB3 if 0 > mx , set mx to 0 ; TAB2 else if x < s ; TAB3 if y = 0 ; TAB4 if 0 > mx , assign 0 to mx ; TAB3 else ; TAB4 set c to 100 - y ; TAB4 if c > mx , set mx = c ; TAB1 print mx ; TAB1 print a newline ;	const long long N = 1e5 ; long long n , s , x , y , mx = - 1 , c ; vector < long long > v ; int main ( ) { cin >> n >> s ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> x >> y ; if ( x == s and y == 0 ) { if ( 0 > mx ) { mx = 0 ; } } else if ( x < s ) { if ( y == 0 ) { if ( 0 > mx ) { mx = 0 ; } } else { c = 100 - y ; if ( c > mx ) { mx = c ; } } } } cout << mx ; cout << " \n " ; return 0 ; }
TAB1 let n , m , i be integers ; TAB1 while read n , m ; TAB2 a = array of integers of length n ; TAB2 let c , b be integers with c = 0 , b = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 if ( a [ i ] - 1 ) / m > = c ; TAB4 c is equal to ( a [ i ] - 1 ) / m ; TAB4 b is equal to i ; TAB2 print b + 1 and newline ;	int main ( ) { int n , m , i ; while ( cin >> n >> m ) { int a [ n ] ; int c = 0 , b = 0 ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( ( a [ i ] - 1 ) / m >= c ) { c = ( a [ i ] - 1 ) / m ; b = i ; } } cout << b + 1 << endl ; } return 0 ; }
TAB1 declare integer n ; TAB1 read n ; TAB1 declare integer vector v initialized with n ; TAB1 for i = 0 to n exclusive , read v [ i ] ; TAB1 declare long long integer dp [ n ] [ 2 ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 2 exclusive , let dp [ i ] [ j ] be 0 ; TAB1 declare long long integer val = absolute value of ( v [ 1 ] - v [ 0 ] ) ; TAB1 let dp [ 0 ] [ 0 ] be val ; TAB1 declare long long integer gmax = val ; TAB1 for i = 1 to n exclusive ; TAB2 declare long long integer val = absolute value of ( v [ i ] - v [ i - 1 ] ) ; TAB2 let dp [ i ] [ 0 ] be maximum of dp [ i ] [ 0 ] and dp [ i - 1 ] [ 1 ] + val ; TAB2 let dp [ i ] [ 1 ] be maximum of dp [ i ] [ 0 ] and dp [ i - 1 ] [ 0 ] - val ; TAB2 let gmax be maximum of gmax and dp [ i ] [ 0 ] ; TAB2 let gmax be maximum of gmax and dp [ i ] [ 1 ] ; TAB1 print gmax and newline ;	int main ( ) { int n ; cin >> n ; vector < int > v ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> v [ i ] ; long long int dp [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; } long long int val = abs ( v [ 1 ] - v [ 0 ] ) ; dp [ 0 ] [ 0 ] = val ; long long int gmax = val ; for ( int i = 1 ; i < n ; i ++ ) { long long int val = abs ( v [ i ] - v [ i - 1 ] ) ; dp [ i ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i - 1 ] [ 1 ] + val ) ; dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] - val ) ; gmax = max ( gmax , dp [ i ] [ 0 ] ) ; gmax = max ( gmax , dp [ i ] [ 1 ] ) ; } cout << gmax << endl ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 n = int with n = size of s ; TAB1 if s does not contain ' 0 ' ; TAB2 erase first char from s ; TAB2 print s ; TAB1 for i = 0 to n ; TAB2 if s [ i ] is ' 0 ' ; TAB3 erase char at position i from s ; TAB3 break ; TAB1 print s ;	int main ( ) { string s ; cin >> s ; int n = s . size ( ) ; if ( count ( s . begin ( ) , s . end ( ) , ' 0 ' ) == 0 ) { s . erase ( s . begin ( ) ) ; cout << s << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 0 ' ) { s . erase ( s . begin ( ) + i ) ; break ; } } cout << s << endl ; }
TAB0 make int arrays a of size 1000 and b of size 1000 ; TAB0 create char C of size 1000 ; TAB0 declare B taking in integer x and returning integer ; TAB1 create int ans = 0 ; TAB1 for i = 0 to 10 exclusive ; TAB2 if ( 1 < < i ) & x is truthy , increment ans ; TAB1 return ans ; TAB1 create integer n ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read C [ i ] and a [ i ] ; TAB2 decrease a [ i ] by 1 ; TAB2 if C [ i ] is equal to ' R ' , set b [ i ] to 0 ; TAB2 if C [ i ] is equal to ' Y ' , set b [ i ] to 1 ; TAB2 if C [ i ] is equal to ' W ' , set b [ i ] to 2 ; TAB2 if C [ i ] is equal to ' G ' , set b [ i ] to 3 ; TAB2 if C [ i ] is equal to ' B ' , set b [ i ] to 4 ; TAB1 make integer ans = n + 1 ; TAB1 for i = 0 to 32 exclusive ; TAB2 for j = 0 to 32 exclusive ; TAB3 make int arrays f of size 5 and g of size 5 ; TAB3 for k = 0 to 5 exclusive ; TAB4 if ( 1 < < k ) & 1 is truthy ; TAB5 set f [ k ] to 1 ; TAB4 else do ; TAB5 set f [ k ] to 0 ; TAB3 for k = 0 to 5 exclusive ; TAB4 if ( 1 < < k ) & j is truthy ; TAB5 set g [ k ] to 1 ; TAB4 otherwise ; TAB5 set g [ k ] to 0 ; TAB3 create integer f1 = 1 ; TAB3 for i = 0 to n exclusive ; TAB4 for j = i + 1 to n exclusive ; TAB5 if a [ i ] is equal to a [ j ] and b [ i ] is equal to b [ i ] , continue loop ; TAB5 if a [ i ] is equal to a [ j ] and g [ b [ i ] ] | g [ b [ j ] ] is truthy , continue to next loop iteration ; TAB5 if b [ i ] is equal to b [ j ] and f [ a [ i ] ] | f [ a [ j ] ] is truthy , continue loop ; TAB5 if a [ i ] is not equal to a [ j ] and b [ i ] is not equal to b [ j ] and f [ a [ i ] ] | f [ a [ j ] ] | g [ b [ i ] ] | g [ b [ j ] ] is truthy , continue loop ; TAB5 set f1 to 0 ; TAB3 if f1 is truthy , set ans to min of ans and B ( i ) + B ( j ) ; TAB1 show ans ;	int a [ 1000 ] , b [ 1000 ] ; char C [ 1000 ] ; int B ( int x ) { int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( ( 1 << i ) & x ) ans ++ ; return ans ; } int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> C [ i ] >> a [ i ] ; a [ i ] -- ; if ( C [ i ] == ' R ' ) b [ i ] = 0 ; if ( C [ i ] == ' Y ' ) b [ i ] = 1 ; if ( C [ i ] == ' W ' ) b [ i ] = 2 ; if ( C [ i ] == ' G ' ) b [ i ] = 3 ; if ( C [ i ] == ' B ' ) b [ i ] = 4 ; } int ans = n + 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { int f [ 5 ] , g [ 5 ] ; for ( int k = 0 ; k < 5 ; k ++ ) if ( ( 1 << k ) & i ) f [ k ] = 1 ; else f [ k ] = 0 ; for ( int k = 0 ; k < 5 ; k ++ ) if ( ( 1 << k ) & j ) g [ k ] = 1 ; else g [ k ] = 0 ; int fl = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] && b [ i ] == b [ j ] ) continue ; if ( a [ i ] == a [ j ] && g [ b [ i ] ] | g [ b [ j ] ] ) continue ; if ( b [ i ] == b [ j ] && f [ a [ i ] ] | f [ a [ j ] ] ) continue ; if ( a [ i ] != a [ j ] && b [ i ] != b [ j ] && f [ a [ i ] ] | f [ a [ j ] ] | g [ b [ i ] ] | g [ b [ j ] ] ) continue ; fl = 0 ; } if ( fl ) ans = min ( ans , B ( i ) + B ( j ) ) ; } } cout << ans << endl ; }
TAB0 declare constant integer MaxN = 1E5 + 10 ; TAB0 create array of integers a with size MaxN ; TAB1 create int n ; TAB1 read n ; TAB1 read n values into array a ; TAB1 let ans = 0 be a long long ; TAB1 for i = 0 to i = n - 1 exclusive ; TAB2 declare integer lg = log2 ( n - i - 1 ) ; TAB2 set ans to ans + a [ i ] ; TAB2 a [ i + ( 1 < < lg ) ] = a [ i + ( 1 < < lg ) ] + a [ i ] ; TAB2 print ans ;	const int MaxN = 1E5 + 10 ; int a [ MaxN ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; long long ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int lg = log2 ( n - i - 1 ) ; ans += a [ i ] ; a [ i + ( 1 << lg ) ] += a [ i ] ; cout << ans << endl ; } }
TAB0 create string a ; TAB0 create long long tou = - 1 , wei = - 1 , mk ; TAB1 read a ; TAB1 for s = 0 to a size exclusive ; TAB2 if a [ s ] is not ' a ' ; TAB3 if tou is - 1 then set tou to s ; TAB3 set mk to 1 ; TAB2 else ; TAB3 if tou is not - 1 ; TAB4 set wei to s - 1 ; TAB4 break ; TAB1 if wei is - 1 and mk is 1 then set wei to a size - 1 ; TAB1 if mk is 0 ; TAB2 set a [ a size - 1 ] to ' z ' ; TAB1 else ; TAB2 for s = max ( ( long long ) 0 , tou ) to wei inclusive do set a [ s ] to ( a [ s ] cast to int - 1 ) cast to char ; TAB1 print a ;	string a ; long long tou = - 1 , wei = - 1 , mk ; int main ( ) { cin >> a ; for ( int s = 0 ; s < a . size ( ) ; s ++ ) { if ( a [ s ] != ' a ' ) { if ( tou == - 1 ) tou = s ; mk = 1 ; } else { if ( tou != - 1 ) { wei = s - 1 ; break ; } } } if ( wei == - 1 && mk == 1 ) wei = a . size ( ) - 1 ; if ( mk == 0 ) { a [ a . size ( ) - 1 ] = ' z ' ; } else for ( int s = max ( ( long long ) 0 , tou ) ; s <= wei ; s ++ ) { a [ s ] = char ( ( int ) a [ s ] - 1 ) ; } cout << a << endl ; }
TAB1 create long long integer n ; TAB1 read n ; TAB1 make long long integers ans = 0 ; TAB1 make long long int b = 0 ; TAB1 let long long array a of size n ; TAB1 let long long sum = 0 ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 if a [ 0 ] is equal to 50 or a [ 0 ] is equal to 100 , print " NO " and return 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is equal to 25 ; TAB3 increment ans ; TAB2 else do ; TAB3 if a [ i ] is equal to 50 ; TAB4 if ans is greater than or equal to 1 ; TAB5 subtract 1 from ans ; TAB5 add 1 to sum ; TAB4 else do ; TAB5 print " NO " and return 0 ; TAB3 otherwise ; TAB4 if ans is greater than or equal to 1 and sum is greater than or equal to 1 ; TAB5 subtract 1 from ans ; TAB5 subtract 1 from sum ; TAB4 else if ans is greater than or equal to 3 ; TAB5 set ans to ans - 3 ; TAB4 else do ; TAB5 print " NO " and return 0 ; TAB1 display " YES " and return 0 ;	int main ( ) { long long n ; cin >> n ; long long ans = 0 ; long long b = 0 ; long long a [ n ] ; long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } if ( a [ 0 ] == 50 || a [ 0 ] == 100 ) { return cout << " NO " << endl , 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) { ans ++ ; } else { if ( a [ i ] == 50 ) { if ( ans >= 1 ) { ans -- ; sum ++ ; } else { return cout << " NO " << endl , 0 ; } } else { if ( ans >= 1 && sum >= 1 ) { ans -- ; sum -- ; } else if ( ans >= 3 ) { ans -= 3 ; } else { return cout << " NO " << endl , 0 ; } } } } return cout << " YES " << endl , 0 ; }
TAB0 s , s1 , s2 , s3 , s4 = char array of size 20000 each ; TAB0 i , j , k , l1 , l2 , c = int and ans = int array of size 20000 ; TAB1 for i = 0 to 2005 set ans [ i ] to 0 ; TAB1 call gets of s ; TAB1 call gets of s4 ; TAB1 set l1 to strlen of s4 ; TAB1 for i = 0 to l1 set s1 [ i ] to ' ' ; TAB1 append s to s1 ; TAB1 set l2 to strlen of s1 ; TAB1 for i = l2 to l1 + l2 - 1 set s1 [ i ] to ' 0 ' ; TAB1 set c to l1 ; TAB1 for i = 1 to l2 ; TAB2 for k = i to i + c set s2 [ k - i ] to s1 [ k ] ; TAB2 for j = 0 to c ; TAB3 if s4 [ j ] is s2 [ j ] increment ans [ i ] ; TAB1 sort ans from position 0 to l2 + 1 ; TAB1 print l1 - ans [ i ] ;	char s [ 20000 ] , s1 [ 20000 ] , s2 [ 20000 ] , s3 [ 20000 ] , s4 [ 20000 ] ; int i , j , k , ans [ 20000 ] , l1 , l2 , c ; int main ( ) { for ( i = 0 ; i < 2005 ; i ++ ) ans [ i ] = 0 ; gets ( s ) ; gets ( s4 ) ; l1 = strlen ( s4 ) ; for ( i = 0 ; i < l1 ; i ++ ) s1 [ i ] = '   ' ; strcat ( s1 , s ) ; l2 = strlen ( s1 ) ; for ( i = l2 ; i < l1 + l2 - 1 ; i ++ ) s1 [ i ] = ' 0 ' ; c = l1 ; for ( i = 1 ; i < l2 ; i ++ ) { for ( k = i ; k < i + c ; k ++ ) s2 [ k - i ] = s1 [ k ] ; for ( j = 0 ; j < c ; j ++ ) { if ( s4 [ j ] == s2 [ j ] ) ans [ i ] ++ ; } } sort ( ans , ans + l2 + 1 ) ; cout << l1 - ans [ i ] << endl ; return 0 ; }
TAB1 define new ints n , l and a ; TAB1 read variables n , l and a from the input ; TAB1 declare new integer called st = 0 ; TAB1 create integer ans = 0 ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 declare new integers f and t ; TAB2 read user input to f and t ; TAB2 increase ans by ( f - st ) / a ; TAB2 change the value of st to f + t ; TAB1 add ( l - st ) / a to ans ; TAB1 print ans and ' \ n ' ;	int main ( ) { int n , l , a ; cin >> n >> l >> a ; int st = 0 ; int ans = 0 ; for ( int i = 0 ; i < ( n ) ; i ++ ) { int f , t ; cin >> f >> t ; ans += ( f - st ) / a ; st = f + t ; } ans += ( l - st ) / a ; cout << ( ans ) << ' \n ' ; return 0 ; }
TAB0 create map of strings to integers M ; TAB0 create 2d array of booleans like with size 7 by 7 ; TAB0 declare strings s1 , s2 and temp ; TAB0 create integer n and integer array g with size 3 ; TAB0 create an array of integers team with size 3 ; TAB0 create an array of integers heros with size 7 ; TAB0 create integer b1 = INT_MAX and b2 = - 1 ; TAB0 void function back_track with int argument a ; TAB1 declare integers i and j ; TAB1 if a is equal to 7 ; TAB2 declare an array of integers count with elements 0 , 0 , 0 ; TAB2 create ints mx = - and mn = INT_MAX ; TAB2 for i = 0 to 7 exclusive increment count [ heros [ i ] ] ; TAB2 if count [ 0 ] , count [ 1 ] or count [ 2 ] = 0 , return ; TAB2 for i from 0 to 7 exclusive ; TAB3 declare integer temp = g [ heros [ i ] ] / count [ heros [ i ] ] ; TAB3 change mx to max of mx and temp ; TAB3 change mn to min of mn and temp ; TAB2 if mx - mn is greater than b1 , return ; TAB2 create int likeNum = 0 ; TAB2 loop i from 0 to 7 exclusive ; TAB3 loop j from 0 to 7 exclusive ; TAB4 if heros [ i ] = heros [ j ] and like [ i ] [ j ] ! = 0 , increment likeNum by one ; TAB2 if mx - mn < b1 or mx - mn = b1and likeNum > b2 ; TAB3 set b1 to mx - mn ; TAB3 set b2 to likeNum ; TAB2 return ; TAB1 loop i from 0 to 3 exclusive ; TAB2 change heros [ a ] to i ; TAB2 call back_track ( a + 1 ) ; TAB1 assign 0 to M [ " Anka " ] ; TAB1 assign 1 to M [ " Chapay " ] ; TAB1 assign 2 to M [ " Cleo " ] ; TAB1 assign 3 to M [ " Troll " ] ; TAB1 assign 4 to M [ " Dracul " ] ; TAB1 assign 5 to M [ " Snowy " ] ; TAB1 assign 6 to M [ " Hexadecimal " ] ; TAB1 loop i from 0 to 7 exclusive ; TAB2 loop j from 0 to 7 exclusive , change like [ i ] [ j ] to false ; TAB1 read n ; TAB1 while n ! = 0 , decrement it and continue the loop ; TAB2 read input to s1 , temp and s2 ; TAB2 set value of like [ M [ s1 ] ] [ M [ s2 ] ] to true ; TAB1 read g [ 0 ] , g [ 1 ] and g [ 2 ] ; TAB1 call back_track ( 0 ) ; TAB1 print b1 , ' ' and b2 ;	map < string , int > M ; bool like [ 7 ] [ 7 ] ; string s1 , s2 , temp ; int n , g [ 3 ] ; int team [ 3 ] ; int heros [ 7 ] ; int b1 = INT_MAX , b2 = - 1 ; void back_track ( int a ) { int i , j ; if ( a == 7 ) { int count [ 3 ] = { 0 , 0 , 0 } ; int mx = - 1 , mn = INT_MAX ; for ( i = 0 ; i < 7 ; i ++ ) count [ heros [ i ] ] ++ ; if ( count [ 0 ] == 0 || count [ 1 ] == 0 || count [ 2 ] == 0 ) return ; for ( i = 0 ; i < 7 ; i ++ ) { int temp = g [ heros [ i ] ] / count [ heros [ i ] ] ; mx = max ( mx , temp ) ; mn = min ( mn , temp ) ; } if ( mx - mn > b1 ) return ; int likeNum = 0 ; for ( i = 0 ; i < 7 ; i ++ ) for ( j = 0 ; j < 7 ; j ++ ) if ( heros [ i ] == heros [ j ] && like [ i ] [ j ] ) likeNum ++ ; if ( ( mx - mn ) < b1 || ( mx - mn ) == b1 && likeNum > b2 ) { b1 = mx - mn ; b2 = likeNum ; } return ; } for ( i = 0 ; i < 3 ; i ++ ) { heros [ a ] = i ; back_track ( a + 1 ) ; } } int main ( ) { M [ " Anka " ] = 0 ; M [ " Chapay " ] = 1 ; M [ " Cleo " ] = 2 ; M [ " Troll " ] = 3 ; M [ " Dracul " ] = 4 ; M [ " Snowy " ] = 5 ; M [ " Hexadecimal " ] = 6 ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) like [ i ] [ j ] = false ; cin >> n ; while ( n -- ) { cin >> s1 >> temp >> s2 ; like [ M [ s1 ] ] [ M [ s2 ] ] = true ; } cin >> g [ 0 ] >> g [ 1 ] >> g [ 2 ] ; back_track ( 0 ) ; cout << b1 << '   ' << b2 << endl ; return 0 ; }
TAB1 create integers h1 , h2 , a1 , a2 , d1 , d2 ; TAB1 create integers m1 , m2 , m3 ; TAB1 read h1 read a1 read d1 ; TAB1 read h2 read a2 read d2 ; TAB1 read m1 read m2 read m3 ; TAB1 create integer ans with ans = 1e9 + 7 ; TAB1 for i = 0 to 205 inclusive ; TAB2 for j = 0 to 105 inclusive ; TAB3 create integer t ; TAB3 if a1 + i is greater than d2 ; TAB4 set t to h2 / ( a1 + i - d2 ) + ( 0 if h2 % ( a1 + i - d2 ) is 0 , else 1 ) ; TAB4 create integer hp with hp = ( a2 - d1 - j ) * t ; TAB4 if hp is greater than or equal to h1 ; TAB5 set ans to minimum of ans and ( hp - h1 + 1 ) * m1 + i * m2 + j * m3 ; TAB4 else ; TAB5 set ans to minimum of ans and j * m3 + i * m2 ; TAB1 print ans print newline ;	int main ( ) { int h1 , h2 , a1 , a2 , d1 , d2 ; int m1 , m2 , m3 ; cin >> h1 >> a1 >> d1 ; cin >> h2 >> a2 >> d2 ; cin >> m1 >> m2 >> m3 ; int ans = 1e9 + 7 ; for ( int i = 0 ; i <= 205 ; i ++ ) { for ( int j = 0 ; j <= 105 ; j ++ ) { int t ; if ( a1 + i > d2 ) { t = h2 / ( a1 + i - d2 ) + ( h2 % ( a1 + i - d2 ) == 0 ? 0 : 1 ) ; int hp = ( a2 - d1 - j ) * t ; if ( hp >= h1 ) { ans = min ( ans , ( hp - h1 + 1 ) * m1 + i * m2 + j * m3 ) ; } else { ans = min ( ans , j * m3 + i * m2 ) ; } } } } cout << ans << endl ; return 0 ; }
TAB1 declare n , i as integers ; TAB1 declare a size 100 as integer array ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 sort from a to a + n ; TAB1 for i = 0 to n exclusive , print a [ i ] , " \ n " if i is n - 1 , else " " ;	int main ( ) { int n , i ; int a [ 100 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) cout << a [ i ] << ( i == n - 1 ? " \n " : "   " ) ; return 0 ; }
TAB0 g , l = vector long long array of size 105 ; TAB0 vis = vector of bool with vis on 105 and false ; TAB0 in the function dfs that takes long long n ; TAB1 vis [ n ] = true ; TAB1 for i = 0 to g [ n ] . size ( ) exclusive ; TAB2 if not vis [ g [ n ] [ i ] ] , dfs ( g [ n ] [ i ] ) ; TAB1 return ; TAB1 n , m , ans , nz = long long with ans = 0 , nz = 0 ; TAB1 read n , m ; TAB1 for i = 1 to n + 1 exclusive ; TAB2 nl = long long ; TAB2 read nl ; TAB2 if nl is 0 , increment nz ; TAB2 for j = 0 to nl exclusive ; TAB3 lang = long long ; TAB3 read lang ; TAB3 append i in l [ lang ] ; TAB1 for i = 1 to m ; TAB2 if l [ i ] . size ( ) is 0 , continue next iteration ; TAB2 for j = 0 to l [ i ] . size ( ) exclusive ; TAB3 for k = j + 1 to l [ i ] . size ( ) exclusive ; TAB4 append l [ i ] [ k ] in g [ l [ i ] [ j ] ] ; TAB4 append l [ i ] [ j ] in g [ l [ i ] [ k ] ] ; TAB1 for i = 1 to n ; TAB2 if not vis [ i ] ; TAB3 increment ans ; TAB3 dfs on i ; TAB1 if nz is n ; TAB2 print n ; TAB1 else ; TAB2 print ans - 1 ;	vector < long long > g [ 105 ] , l [ 105 ] ; vector < bool > vis ( 105 , false ) ; void dfs ( long long n ) { vis [ n ] = true ; for ( long long i = 0 ; i < g [ n ] . size ( ) ; i ++ ) { if ( ! vis [ g [ n ] [ i ] ] ) dfs ( g [ n ] [ i ] ) ; } return ; } int main ( ) { long long n , m , ans = 0 , nz = 0 ; cin >> n >> m ; for ( long long i = 1 ; i < n + 1 ; i ++ ) { long long nl ; cin >> nl ; if ( nl == 0 ) nz ++ ; for ( long long j = 0 ; j < nl ; j ++ ) { long long lang ; cin >> lang ; l [ lang ] . push_back ( i ) ; } } for ( long long i = 1 ; i <= m ; i ++ ) { if ( l [ i ] . size ( ) == 0 ) continue ; for ( long long j = 0 ; j < l [ i ] . size ( ) ; j ++ ) { for ( long long k = j + 1 ; k < l [ i ] . size ( ) ; k ++ ) { g [ l [ i ] [ j ] ] . push_back ( l [ i ] [ k ] ) ; g [ l [ i ] [ k ] ] . push_back ( l [ i ] [ j ] ) ; } } } for ( long long i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) { ans ++ ; dfs ( i ) ; } } if ( nz == n ) cout << n << endl ; else cout << ans - 1 << endl ; return 0 ; }
TAB1 let x , t , a , b , da , db be integers ; TAB1 read x , t , a , b , da , db ; TAB1 if x is equal to 0 ; TAB2 print YES and newline ; TAB1 let k , z be integers ; TAB1 for integer i = a , z = 0 , z is less than t , decrement i by da , increment z by 1 ; TAB2 for integer j = b , k = 0 , k is less than t , decrement j by db , increment k by 1 ; TAB3 if i is equal to x or j is equal to x or i + j is equal to x ; TAB4 print YES and newline ; TAB1 print NO and endline ;	int main ( ) { int x , t , a , b , da , db ; cin >> x >> t >> a >> b >> da >> db ; if ( x == 0 ) { cout << " YES " << endl ; return 0 ; } int k , z ; for ( int i = a , z = 0 ; z < t ; i -= da , z ++ ) { for ( int j = b , k = 0 ; k < t ; j -= db , k ++ ) { if ( i == x || j == x || i + j == x ) { cout << " YES " << endl ; return 0 ; } } } cout << " NO " << endl ; return 0 ; }
TAB0 declare integers n , o ; TAB0 declare string s ; TAB1 read n , s ; TAB1 if s is " 0 " ; TAB2 print 0 , newline ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is ' 1 ' , increment o ; TAB1 print 1 ; TAB1 for i = o to n exclusive , print 0 ; TAB1 print newline ;	int n , o ; string s ; int main ( ) { cin >> n >> s ; if ( s == " 0 " ) { cout << 0 << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 1 ' ) o ++ ; } cout << 1 ; for ( int i = o ; i < n ; i ++ ) cout << 0 ; cout << endl ; }
TAB0 let n be a integer , x = array of integers of length 111111 ; TAB0 let check be a function that returns boolean values ; TAB1 for i = 1 to n inclusive ; TAB2 if x [ x [ i ] ] is not equal to n - i + 1 , return 0 ; TAB1 return 1 ; TAB1 read n ; TAB1 x [ 1 ] is equal to 2 ; TAB1 the integer value of u = 1 ; TAB1 if n modulo 4 is equal to 0 ; TAB2 for i = 1 to n / 4 inclusive ; TAB3 x [ i + i - 1 ] is equal to i * 2 ; TAB3 x [ n - i - i + 1 ] is equal to i * 2 - 1 ; TAB3 x [ i + i ] is equal to n + 1 - x [ n - i - i + 1 ] ; TAB3 x [ n - i - i + 2 ] is equal to n + 1 - x [ i + i - 1 ] ; TAB2 for i = 1 to n exclusive , print x [ i ] and ' ' ; TAB2 print x [ n ] and newline ; TAB1 else if n modulo 4 is equal to 1 ; TAB2 for i = 1 to n / 4 inclusive ; TAB3 x [ i + i - 1 ] is equal to i * 2 ; TAB3 x [ n - i - i + 1 ] is equal to i * 2 - 1 ; TAB3 x [ i + i ] is equal to n + 1 - x [ n - i - i + 1 ] ; TAB3 x [ n - i - i + 2 ] is equal to n + 1 - x [ i + i - 1 ] ; TAB2 x [ n / 2 + 1 ] is equal to n / 2 + 1 ; TAB2 for i = 1 to n exclusive , print x [ i ] and ' ' ; TAB2 print x [ n ] and newline ; TAB1 else do the following ; TAB2 print - 1 and newline ;	int n , x [ 111111 ] ; bool check ( ) { for ( int i = 1 ; i <= n ; ++ i ) if ( x [ x [ i ] ] != n - i + 1 ) return 0 ; return 1 ; } int main ( ) { cin >> n ; x [ 1 ] = 2 ; int u = 1 ; if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 4 ; ++ i ) { x [ i + i - 1 ] = i * 2 ; x [ n - i - i + 1 ] = i * 2 - 1 ; x [ i + i ] = n + 1 - x [ n - i - i + 1 ] ; x [ n - i - i + 2 ] = n + 1 - x [ i + i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) cout << x [ i ] << '   ' ; cout << x [ n ] << ' \n ' ; } else if ( n % 4 == 1 ) { for ( int i = 1 ; i <= n / 4 ; ++ i ) { x [ i + i - 1 ] = i * 2 ; x [ n - i - i + 1 ] = i * 2 - 1 ; x [ i + i ] = n + 1 - x [ n - i - i + 1 ] ; x [ n - i - i + 2 ] = n + 1 - x [ i + i - 1 ] ; } x [ n / 2 + 1 ] = n / 2 + 1 ; for ( int i = 1 ; i < n ; ++ i ) cout << x [ i ] << '   ' ; cout << x [ n ] << ' \n ' ; } else cout << " -1\n " ; return 0 ; }
TAB0 mod = 1e9 + 7 = const long long ; TAB0 s , t = char array of length 5050 ; TAB0 dp = int 5050x5050 int matrix ; TAB0 ans = long long ; TAB1 read ( s + 1 ) ; TAB1 read ( t + 1 ) ; TAB1 lens = int = length of ( s + 1 ) ; TAB1 lent = length of ( t + 1 ) = int ; TAB1 for i = 1 to lens inclusive ; TAB2 for j = 1 to j inclusive ; TAB3 if s [ i ] = t [ i ] then set dp [ i ] [ j ] to ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) % mod ; TAB3 set dp [ i ] [ j ] to ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) % mod ; TAB1 for i = 1 to lens inclusive then set ans to ( ans + dp [ i ] [ lent ] ) % mod ; TAB1 print ans ;	const long long mod = 1e9 + 7 ; char s [ 5050 ] , t [ 5050 ] ; int dp [ 5050 ] [ 5050 ] ; long long ans ; int main ( ) { cin >> ( s + 1 ) ; cin >> ( t + 1 ) ; int lens = strlen ( s + 1 ) ; int lent = strlen ( t + 1 ) ; for ( int i = 1 ; i <= lens ; i ++ ) { for ( int j = 1 ; j <= lent ; j ++ ) { if ( s [ i ] == t [ j ] ) dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) % ( mod ) ; dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) % ( mod ) ; } } for ( int i = 1 ; i <= lens ; i ++ ) ans = ( ans + dp [ i ] [ lent ] ) % mod ; cout << ans << endl ; return 0 ; }
TAB0 make integer array a of size 100005 ; TAB1 make integer n ; TAB1 read n ; TAB1 if n mod 4 is greater than or equal to 2 , return puts ( " - 1 " ) , 0 ; TAB1 for int i = 1 ; i is less than or equal to n / 2 ; add 2 to i ; TAB2 set a [ i ] to i + 1 ; TAB2 set a [ i + 1 ] to n - i + 1 ; TAB2 set a [ n - i + 1 ] to n - i ; TAB2 set a [ n - i ] to i ; TAB1 if n is odd , set a [ n / 2 + 1 ] to n / 2 + 1 ; TAB1 for i = 1 to n inclusive , print a [ i ] " \ n " [ i = = n ] ;	int a [ 100005 ] ; int main ( ) { int n ; cin >> n ; if ( n % 4 >= 2 ) return puts ( " -1 " ) , 0 ; for ( int i = 1 ; i <= n / 2 ; i += 2 ) { a [ i ] = i + 1 ; a [ i + 1 ] = n - i + 1 ; a [ n - i + 1 ] = n - i ; a [ n - i ] = i ; } if ( n % 2 == 1 ) a [ n / 2 + 1 ] = n / 2 + 1 ; for ( int i = 1 ; i <= n ; i ++ ) cout << a [ i ] << "  \n " [ i == n ] ; return 0 ; }
TAB0 parrent = integer array of size 105 ; TAB0 vis = bool array of size 105 ; TAB0 in the function FindParrent that takes integer node and returns integer ; TAB1 if node is parrent [ node ] , return node ; TAB1 return parrent [ node ] = FindParrent ( parrent [ node ] ) ; TAB0 in the function Union that takes integer x , y ; TAB1 x = FindParrent on x ; TAB1 y = FindParrent on y ; TAB1 if x is not y , parrent [ x ] = y ; TAB1 return ; TAB1 n , m , u , v , x , y = integer ; TAB1 read n , m ; TAB1 for i = 1 to m , parrent [ i ] = i ; TAB1 cnt = integer with cnt = 0 ; TAB1 for i = 1 to n ; TAB2 read x ; TAB2 v = - 1 ; TAB2 if x is 0 , increment cnt ; TAB2 while decrement x ; TAB3 read u ; TAB3 vis [ u ] = 1 ; TAB3 call Union on u and if v is - 1 , u else v ; TAB3 v = u ; TAB1 st = set of integer ; TAB1 for i = 1 to m ; TAB2 if vis [ i ] ; TAB3 u = FindParrent ( i ) ; TAB3 insert ( u ) in st ; TAB1 sz = integer with sz = st . size ( ) - 1 ; TAB1 sz = if sz < 0 , 0 else sz ; TAB1 print cnt + sz ;	int parrent [ 105 ] ; bool vis [ 105 ] ; int FindParrent ( int node ) { if ( node == parrent [ node ] ) { return node ; } return parrent [ node ] = FindParrent ( parrent [ node ] ) ; } void Union ( int x , int y ) { x = FindParrent ( x ) ; y = FindParrent ( y ) ; if ( x != y ) { parrent [ x ] = y ; } return ; } int main ( ) { int n , m , u , v , x , y ; cin >> n >> m ; for ( int i = 1 ; i <= m ; i ++ ) { parrent [ i ] = i ; } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x ; v = - 1 ; if ( x == 0 ) { cnt ++ ; } while ( x -- ) { cin >> u ; vis [ u ] = 1 ; Union ( u , v == - 1 ? u : v ) ; v = u ; } } set < int > st ; for ( int i = 1 ; i <= m ; i ++ ) { if ( vis [ i ] ) { u = FindParrent ( i ) ; st . insert ( u ) ; } } int sz = st . size ( ) - 1 ; sz = sz < 0 ? 0 : sz ; cout << cnt + sz << endl ; return 0 ; }
TAB0 declare constant integers MAX = 12e5 + 100 ; TAB0 declare integer arrays a size MAX , sushu size MAX , huiwen size MAX ; TAB0 declare init with no arguments , returning void ; TAB1 let a [ 1 ] be 1 ; TAB1 let a [ 0 ] be 1 ; TAB1 for i = 2 to 10000 inclusive ; TAB2 if not a [ i ] ; TAB3 for j = i to i * j is less than MAX , incrementing j , let a [ i * j ] be 1 ; TAB0 declare panduan with integer x as argument , returning integer ; TAB1 declare integer w = x ; TAB1 declare integer y = 0 ; TAB1 while w is not 0 ; TAB2 let y be y * 10 + w % 10 ; TAB2 let w be w / 10 ; TAB1 if y is x ; TAB2 return 1 ; TAB1 else ; TAB1 run init ; TAB1 for i = 1 to MAX exclusive ; TAB2 if a [ i ] is true ; TAB3 let sushu [ i ] be sushu [ i - 1 ] ; TAB2 else ; TAB3 let sushu [ i ] be sushu [ i - 1 ] + 1 ; TAB2 if result of run panduan with i as argument is true ; TAB3 let huiwen [ i ] be huiwen [ i - 1 ] + 1 ; TAB2 else ; TAB3 let huiwen [ i ] be huiwen [ i - 1 ] ; TAB1 declre integers p , q ; TAB1 read p and q ; TAB1 for i = MAX - 1 to 0 inclusive , decrementing i ; TAB2 if sushu [ i ] * q is less than or equal to huiwen [ i ] * p ; TAB3 if i is 0 ; TAB4 print " Palindromic tree is better than splay tree " and newline ; TAB3 else ; TAB4 print i and newline ;	const int MAX = 12e5 + 100 ; int a [ MAX ] , sushu [ MAX ] , huiwen [ MAX ] ; void init ( ) { a [ 1 ] = 1 ; a [ 0 ] = 1 ; for ( int i = 2 ; i <= 10000 ; i ++ ) { if ( ! a [ i ] ) { for ( int j = i ; i * j < MAX ; j ++ ) { a [ i * j ] = 1 ; } } } } int panduan ( int x ) { int w = x ; int y = 0 ; while ( w != 0 ) { y = y * 10 + w % 10 ; w /= 10 ; } if ( y == x ) return 1 ; else return 0 ; } int main ( ) { init ( ) ; for ( int i = 1 ; i < MAX ; i ++ ) { if ( a [ i ] ) sushu [ i ] = sushu [ i - 1 ] ; else sushu [ i ] = sushu [ i - 1 ] + 1 ; if ( panduan ( i ) ) huiwen [ i ] = huiwen [ i - 1 ] + 1 ; else huiwen [ i ] = huiwen [ i - 1 ] ; } int p , q ; cin >> p >> q ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { if ( sushu [ i ] * q <= huiwen [ i ] * p ) { if ( i == 0 ) cout << " Palindromic tree is better than splay tree " << endl ; else cout << i << endl ; return 0 ; } } return 0 ; }
TAB0 declare character array a size 55 by 55 ; TAB0 declare integer array is size 55 by 55 ; TAB0 declare integers n , m ; TAB0 declare integer arrays dx size 4 = { - 1 , 1 , 0 , 0 } , dy size 4 = { 0 , 0 , - 1 , 1 } ; TAB0 declare inline work with integers x , y as arguments , returning void ; TAB1 if is [ x ] [ y ] is 1 , return from function ; TAB1 if a [ x ] [ y ] is not ' # ' , return from function ; TAB1 let is [ x ] [ y ] be 1 ; TAB1 declare integer i ; TAB1 for i = 0 to 4 exclusive , run work with x + dx [ i ] , y + dy [ i ] as arguments ; TAB0 declare inline check with integers x , y as arguments , returning boolean ; TAB1 let a [ x ] [ y ] be ' . ' ; TAB1 declare integer kk = 0 ; TAB1 set bytes from is to size of is to value 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if a [ i ] [ j ] is ' # ' and is [ i ] [ j ] is 0 ; TAB4 increment kk ; TAB4 run work ( i , j ) ; TAB1 let a [ x ] [ y ] be ' # ' ; TAB1 return kk is greater than 1 ; TAB1 read n , m ; TAB1 declare integer kk = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 read a [ i ] [ j ] ; TAB3 if a [ i ] [ j ] is ' # ' , increment kk ; TAB1 if kk is less than 3 ; TAB2 print - 1 and newline ; TAB1 declare integer ans = 2 ; TAB1 for i = 0 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if a [ i ] [ j ] is ' # ' ; TAB4 if result of run check ( i , j ) is true , let ans be 1 ; TAB1 print ans and newline ;	char a [ 55 ] [ 55 ] ; int is [ 55 ] [ 55 ] ; int n , m ; int dx [ 4 ] = { - 1 , 1 , 0 , 0 } , dy [ 4 ] = { 0 , 0 , - 1 , 1 } ; inline void work ( int x , int y ) { if ( is [ x ] [ y ] == 1 ) return ; if ( a [ x ] [ y ] != ' # ' ) return ; is [ x ] [ y ] = 1 ; int i ; for ( i = 0 ; i < 4 ; i ++ ) work ( x + dx [ i ] , y + dy [ i ] ) ; } inline bool check ( int x , int y ) { a [ x ] [ y ] = ' . ' ; int kk = 0 ; memset ( is , 0 , sizeof ( is ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) if ( a [ i ] [ j ] == ' # ' && ( is [ i ] [ j ] == 0 ) ) { kk ++ ; work ( i , j ) ; } } a [ x ] [ y ] = ' # ' ; return kk > 1 ; } int main ( ) { cin >> n >> m ; int kk = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { cin >> a [ i ] [ j ] ; if ( a [ i ] [ j ] == ' # ' ) kk ++ ; } } if ( kk < 3 ) { cout << - 1 << endl ; return 0 ; } int ans = 2 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) if ( a [ i ] [ j ] == ' # ' ) { if ( check ( i , j ) ) ans = 1 ; } } cout << ans << endl ; return 0 ; }
TAB1 declare 2d integer array arr with size 4 by 4 ; TAB1 for i = 0 to 4 exclusive incrementing i ; TAB2 for j from 0 to 4 exclusive read arr [ i ] [ j ] ; TAB1 create int f = 0 ; TAB1 for integer i = 0 to 4 exclusive ; TAB2 if arr [ i ] [ 3 ] is 1 ; TAB3 if arr [ i ] [ 0 ] , arr [ i ] [ 1 ] or arr [ i ] [ 2 ] is 1 , set f to 1 ; TAB3 if arr [ ( i + 1 ) % 4 ] [ 0 ] = 1 , set f to 1 ; TAB3 if arr [ ( i + 2 ) % 4 ] [ 1 ] = 1 , set f to 1 ; TAB3 if arr [ ( i + 3 ) % 4 ] [ 2 ] = 1 , set f to 1 ; TAB1 if f is 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ; TAB1 print undefined ;	int main ( ) { int arr [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { cin >> arr [ i ] [ j ] ; } } int f = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( arr [ i ] [ 3 ] == 1 ) { if ( arr [ i ] [ 0 ] == 1 || arr [ i ] [ 1 ] == 1 || arr [ i ] [ 2 ] == 1 ) f = 1 ; if ( arr [ ( i + 1 ) % 4 ] [ 0 ] == 1 ) f = 1 ; if ( arr [ ( i + 2 ) % 4 ] [ 1 ] == 1 ) f = 1 ; if ( arr [ ( i + 3 ) % 4 ] [ 2 ] == 1 ) f = 1 ; } } if ( f == 1 ) cout << " YES " ; else cout << " NO " ; cout << endl ; return 0 ; }
TAB0 declare integer array a with size 101 and b with size 100 ; TAB1 declare int variable n ; TAB1 read n and keep looping ; TAB2 declare int count = 0 ; TAB2 for i from 1 to n inclusive ; TAB3 read input to a [ i ] ; TAB3 if a [ i ] is less than 0 , increment count ; TAB2 if count < = 2 ; TAB3 print 1 , new line and n ; TAB3 go to the start of the loop ; TAB2 if count is odd ; TAB3 print count / 2 + 1 ; TAB2 else ; TAB3 print count / 2 ; TAB2 declare integer variable t = 0 ; TAB2 create int x = 1 ; TAB2 declare integer sum = 0 ; TAB2 loop i from 1 to n inclusive ; TAB3 if t = 2 and a [ i ] < 0 ; TAB4 print i - x and " " ; TAB4 add i - x to sum ; TAB4 assign i to x ; TAB4 change t to 0 ; TAB4 decrease count by 2 ; TAB3 if a [ i ] is less than 0 , increment t ; TAB2 if sum is less than n , print n - sum ; TAB2 print new line ;	int a [ 101 ] , b [ 100 ] ; int main ( ) { int n ; while ( cin >> n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] < 0 ) count ++ ; } if ( count <= 2 ) { cout << 1 << endl << n << endl ; continue ; } if ( count % 2 ) cout << count / 2 + 1 << endl ; else cout << count / 2 << endl ; int t = 0 ; int x = 1 ; int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( t == 2 && a [ i ] < 0 ) { cout << i - x << "   " ; sum += ( i - x ) ; x = i ; t = 0 ; count -= 2 ; } if ( a [ i ] < 0 ) t ++ ; } if ( sum < n ) cout << n - sum ; cout << endl ; } return 0 ; }
TAB1 create int n ; TAB1 read n ; TAB1 create int a [ n ] , maxind , minind , max , min , set max to 0 and min to 10000 ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 if a [ i ] > max ; TAB3 set max to a [ i ] ; TAB3 assign i to maxing ; TAB2 if a [ i ] < = min ; TAB3 min = a [ i ] ; TAB3 minind = i ; TAB1 if maxind > minind ; TAB2 print ( abs of minind - ( n - 1 ) + abs of maxind - 0 ) - 1 and a newline ; TAB1 else ; TAB2 print abs ( minind - ( n - 1 ) ) + abs ( maxind - 0 ) and a newline ;	int main ( ) { int n ; cin >> n ; int a [ n ] , maxind , minind , max = 0 , min = 10000 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] > max ) { max = a [ i ] ; maxind = i ; } if ( a [ i ] <= min ) { min = a [ i ] ; minind = i ; } } if ( maxind > minind ) cout << ( abs ( minind - ( n - 1 ) ) + abs ( maxind - 0 ) ) - 1 << " \n " ; else cout << abs ( minind - ( n - 1 ) ) + abs ( maxind - 0 ) << " \n " ; }
TAB0 n , m = integer ; TAB0 cnt1 , cnt2 = integer ; TAB1 read n , m ; TAB1 ans = integer = 0 ; TAB1 tmp = integer = n = 1 ; TAB1 while tmp returns true , increase cnt1 by 1 , tmp = tmp / 7 ; TAB1 tmp = m - 1 ; TAB1 while tmp returns true , increase cnt2 by 1 , tmp = tmp / 7 ; TAB1 if n is 1 then increase cnt1 by 1 ; TAB1 if m is 1 then increase cnt2 by 1 ; TAB1 for i = 0 to n exclusive ; TAB2 s = integert array of size 15 , tot1 = integer = 0 ; TAB2 tmp = i ; TAB2 for k - 1 to cnt1 inclusive , s [ k ] tmp modulo 7 , tmp = tmp / 7 ; TAB2 if cnt > 7 then exit the for loop ; TAB2 for j = 0 to m exclusive ; TAB3 tmp = j ; TAB3 if cnt2 + cnt1 > 7 exit the for loop ; TAB3 d = integer array of size 10 ; TAB3 set all the values of d to 0 ; TAB3 for k = 1 to cnt2 inclusive , d [ tmp modulo 7 ] , tmp = tmp / 7 ; TAB3 for k = 1 to cnt1 inclusive , increase the value of d [ s [ k ] ] by 1 ; TAB3 for k = 0 to 6 inclusive ; TAB4 if d [ k ] > 1 ; TAB5 decrease ans by 1 ; TAB5 exit the for loop ; TAB3 increase ans by 1 ; TAB1 print ans ;	int n , m ; int cnt1 , cnt2 ; int main ( ) { cin >> n >> m ; int ans = 0 ; int tmp = n - 1 ; while ( tmp ) cnt1 ++ , tmp /= 7 ; tmp = m - 1 ; while ( tmp ) cnt2 ++ , tmp /= 7 ; if ( n == 1 ) cnt1 ++ ; if ( m == 1 ) cnt2 ++ ; for ( register int i = 0 ; i < n ; i ++ ) { int s [ 15 ] , tot1 = 0 ; tmp = i ; for ( register int k = 1 ; k <= cnt1 ; k ++ ) s [ k ] = tmp % 7 , tmp /= 7 ; if ( cnt1 > 7 ) break ; for ( register int j = 0 ; j < m ; j ++ ) { tmp = j ; if ( cnt2 + cnt1 > 7 ) break ; int d [ 10 ] ; memset ( d , 0 , sizeof ( d ) ) ; for ( int k = 1 ; k <= cnt2 ; k ++ ) d [ tmp % 7 ] ++ , tmp /= 7 ; for ( int k = 1 ; k <= cnt1 ; k ++ ) d [ s [ k ] ] ++ ; for ( int k = 0 ; k <= 6 ; k ++ ) { if ( d [ k ] > 1 ) { ans -- ; break ; } } ans ++ ; } } cout << ans << endl ; }
TAB1 x , y , ans = 0 ; TAB1 read x then y ; TAB1 p = int ; TAB1 set p to max of absolute of x and absolute of y ; TAB1 if x is p and x is greater than 0 and x + y is greater than 1 ; TAB2 decrement p then set ans to p ; TAB2 set ans to ans * 4 ; TAB2 increment ans ; TAB1 else if y is p and y is greater than 0 and y - x is greater than 0 ; TAB2 set ans to p ; TAB2 set ans to ans * 4 ; TAB2 decrement ans by 2 ; TAB1 else if x is - 1 * p and x is less than 0 and x + y is less than 0 ; TAB2 set ans to p ; TAB2 set ans to ans * 4 ; TAB2 decrement ans ; TAB1 else ; TAB2 if x + y is 1 ; TAB3 decrement x ; TAB3 set ans to x ; TAB3 set ans to ans * 4 ; TAB2 else ; TAB3 set ans to p ; TAB3 set ans to ans * 4 ; TAB1 if x and y are both 0 set ans to 0 ; TAB1 set ans to max of ans and 0 ; TAB1 print ans ;	int main ( ) { int x , y , ans = 0 ; cin >> x >> y ; int p ; p = max ( abs ( x ) , abs ( y ) ) ; if ( x == p && x > 0 && x + y > 1 ) { ans = -- p ; ans *= 4 ; ++ ans ; } else if ( y == p && y > 0 && y - x > 0 ) { ans = p ; ans *= 4 ; ans -= 2 ; } else if ( x == ( - 1 * p ) && x < 0 && x + y < 0 ) { ans = p ; ans *= 4 ; -- ans ; } else { if ( x + y == 1 ) { x -- ; ans = x ; ans *= 4 ; } else { ans = p ; ans *= 4 ; } } if ( x == 0 && y == 0 ) { ans = 0 ; } ans = max ( ans , 0 ) ; cout << ans << ' \n ' ; }
TAB0 let choose be a function that accepts integers n , k and returns a long integer value ; TAB1 let ans be a long integer with ans = 1 ; TAB1 if n is less than k , return 0 ; TAB1 for i = n - k + 1 to n inclusive , ans = ans * i ; TAB1 if k is equal to 3 ; TAB2 assert ( ans modulo 6 is equal to 0 ) ; TAB2 ans is equal to ans / 6 ; TAB1 else do the following ; TAB2 assert ( ans modulo 2 is equal to 0 ) ; TAB2 ans is equal to ans / 2 ; TAB1 return the value of ans ; TAB1 let n , d , tmp , l be integers with l = 0 ; TAB1 let ans be a long integer with ans is equal to 0 ; TAB1 read n , d ; TAB1 points = array of integers of length n ; TAB1 for i = 0 to n exclusive ; TAB2 read tmp ; TAB2 points [ i ] is equal to tmp ; TAB2 while absolute value of ( tmp - points [ l ] ) is greater than d , increment l by 1 ; TAB2 if ans is equal to 0 ; TAB3 increment ans by choose ( i + 1 - l , 3 ) ; TAB2 else do the following ; TAB3 increment ans by choose ( i - l , 2 ) ; TAB1 print ans and newline ;	long long int choose ( int n , int k ) { long long int ans = 1 ; if ( n < k ) return 0 ; for ( int i = n - k + 1 ; i <= n ; i ++ ) { ans *= i ; } if ( k == 3 ) { assert ( ans % 6 == 0 ) ; ans /= 6 ; } else { assert ( ans % 2 == 0 ) ; ans /= 2 ; } return ans ; } int main ( ) { int n , d , tmp , l = 0 ; long long int ans = 0 ; cin >> n >> d ; int points [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> tmp ; points [ i ] = tmp ; while ( abs ( tmp - points [ l ] ) > d ) l ++ ; if ( ans == 0 ) ans += choose ( i + 1 - l , 3 ) ; else ans += choose ( i - l , 2 ) ; } cout << ans << endl ; return 0 ; }
TAB0 declare array of integer vectors grafo with size 150150 ; TAB0 declare ints n and m ; TAB0 create int array grau with 150150 elements ; TAB0 create int array visitado with 150150 elements ; TAB0 create int array grauCor with 150150 elements ; TAB0 dfs is a int function with int arguments v and cor ; TAB1 return 0 if visitado [ v ] = cor ; TAB1 change visitado [ v ] to cor ; TAB1 declare integer variable sum = 1 ; TAB1 for i from 0 to size of grafo [ v ] exclusive incrementing i ; TAB2 create int u = grafo [ v ] [ i ] ; TAB2 add dfs of u and cor to sum ; TAB1 return sum ; TAB1 read n and m ; TAB1 declare integer variable i ; TAB1 declare int variables u and v ; TAB1 loop i from 1 to m inclusive incrementing i ; TAB2 read from the input to u and v ; TAB2 push v into grafo [ u ] ; TAB2 push u into grafo [ v ] ; TAB2 increment grau [ u ] by one ; TAB2 increment grau [ v ] by one ; TAB1 declare integer variable cor = 1 ; TAB1 for i from 1 to n inclusive ; TAB2 if visitado [ i ] is 0 ; TAB3 change grauCor [ cor ] to dfs of i and cor ; TAB3 increment cor ; TAB1 declare int ok = 1 ; TAB1 loop i from 1 to n inclusive ; TAB2 if grau [ i ] ! = grauCor [ visitado [ i ] ] - 1 , change ok to 0 ; TAB1 if ok is true ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	vector < int > grafo [ 150150 ] ; int n , m ; int grau [ 150150 ] ; int visitado [ 150150 ] ; int grauCor [ 150150 ] ; int dfs ( int v , int cor ) { if ( visitado [ v ] == cor ) return 0 ; visitado [ v ] = cor ; int sum = 1 ; for ( int i = 0 ; i < ( int ) grafo [ v ] . size ( ) ; i ++ ) { int u = grafo [ v ] [ i ] ; sum += dfs ( u , cor ) ; } return sum ; } int main ( ) { cin >> n >> m ; int i ; int u , v ; for ( i = 1 ; i <= m ; i ++ ) { cin >> u >> v ; grafo [ u ] . push_back ( v ) ; grafo [ v ] . push_back ( u ) ; grau [ u ] ++ ; grau [ v ] ++ ; } int cor = 1 ; for ( i = 1 ; i <= n ; i ++ ) { if ( visitado [ i ] == 0 ) { grauCor [ cor ] = dfs ( i , cor ) ; cor ++ ; } } int ok = 1 ; for ( i = 1 ; i <= n ; i ++ ) { if ( grau [ i ] != grauCor [ visitado [ i ] ] - 1 ) ok = 0 ; } if ( ok ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 let a , b long longs ; TAB1 let in a string ; TAB1 read a , b , and in ; TAB1 let x , y long longs both with value 0 ; TAB1 let len a long long with value length of in ; TAB1 let zx , zy long longs both with value 0 ; TAB1 for long long i = 0 to len exclusive ; TAB2 if zx is a and zy is b ; TAB3 print Yes ; TAB2 if in [ i ] is U , increment zy ; TAB2 if in [ i ] is D , decrement zy ; TAB2 if in [ i ] is L , decrement zx ; TAB2 if in [ i ] is R , increment zx ; TAB1 if zx and zy are 0 ; TAB2 print No ; TAB1 for i = 0 to len exclusive ; TAB2 if in [ i ] is U , increment y ; TAB2 if in [ i ] is D , decrement y ; TAB2 if in [ i ] is L , decrement x ; TAB2 if in [ i ] is R , increment x ; TAB2 let chax , chay long longs with chax = a - x and chay = b - y ; TAB2 if zx is 0 ; TAB3 if chay mod zy is 0 and zx is chax ; TAB4 if chay / zy is at least 0 ; TAB5 print Yes ; TAB2 otherwise , if zy is 0 ; TAB3 if chax mod zx is 0 and zy equals chay ; TAB4 if chax / zx is at least 0 ; TAB5 print Yes ; TAB2 otherwise if chax mod zx is 0 and chay mod zy is 0 ; TAB3 if chax / zx = chay / zy and chax / zx is at least 0 and chay / zy is at least 0 ; TAB4 print Yes ; TAB1 print No ;	int main ( ) { long long a , b ; string in ; cin >> a >> b >> in ; long long x = 0 , y = 0 ; long long len = in . length ( ) ; long long zx = 0 , zy = 0 ; for ( long long i = 0 ; i < len ; i ++ ) { if ( zx == a && zy == b ) { cout << " Yes " << endl ; return 0 ; } if ( in [ i ] == ' U ' ) { zy ++ ; } if ( in [ i ] == ' D ' ) { zy -- ; } if ( in [ i ] == ' L ' ) { zx -- ; } if ( in [ i ] == ' R ' ) { zx ++ ; } } if ( zx == 0 && zy == 0 ) { cout << " No " << endl ; return 0 ; } for ( int i = 0 ; i < len ; i ++ ) { if ( in [ i ] == ' U ' ) { y ++ ; } if ( in [ i ] == ' D ' ) { y -- ; } if ( in [ i ] == ' L ' ) { x -- ; } if ( in [ i ] == ' R ' ) { x ++ ; } long long chax = a - x , chay = b - y ; if ( zx == 0 ) { if ( chay % zy == 0 && zx == chax ) { if ( chay / zy >= 0 ) { cout << " Yes " << endl ; return 0 ; } } } else if ( zy == 0 ) { if ( chax % zx == 0 && zy == chay ) { if ( chax / zx >= 0 ) { cout << " Yes " << endl ; return 0 ; } } } else if ( chax % zx == 0 && chay % zy == 0 ) { if ( chax / zx == chay / zy && chax / zx >= 0 && chay / zy >= 0 ) { cout << " Yes " << endl ; return 0 ; } } } cout << " No " << endl ; return 0 ; }
TAB1 let s = string ; TAB1 let n = integer ; TAB1 while ( read n ) is true do the following ; TAB2 read s ; TAB2 let cnt = integer with value = 0 ; TAB2 for integer i = 0 to length of s exclusive do the following ; TAB3 if character of s at string position i is < ; TAB4 increment cnt ; TAB3 else ; TAB4 exit the loop ; TAB2 for integer i = length of s - 1 to 0 inclusive decrementing do the following ; TAB3 if character of s at string position i is < ; TAB4 increment cnt ; TAB3 else ; TAB4 exit the loop ; TAB2 print cnt ;	int main ( ) { string s ; int n ; while ( cin >> n ) { cin >> s ; int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . at ( i ) == ' < ' ) cnt ++ ; else break ; } for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . at ( i ) == ' > ' ) cnt ++ ; else break ; } cout << cnt << endl ; } return 0 ; }
TAB1 n , l , m , ans are integers with ans = 0 ; TAB1 read n , l , m ; TAB1 a , b , c , d are integers with a and b both set to 0 ; TAB1 if n ; TAB2 read a , b ; TAB2 add a / m to ans ; TAB1 for i = 1 to n exclusive ; TAB2 read c , d ; TAB2 add ( c + ( a + b ) ) / m to ans ; TAB2 assign c to a , assign d to b ; TAB1 add ( l - ( a + b ) ) / m to ans ; TAB1 output ans ;	int main ( ) { int n , l , m , ans = 0 ; cin >> n >> l >> m ; int a = 0 , b = 0 , c , d ; if ( n ) { cin >> a >> b ; ans += a / m ; } for ( int i = 1 ; i < n ; i ++ ) { cin >> c >> d ; ans += ( c - ( a + b ) ) / m ; a = c , b = d ; } ans += ( l - ( a + b ) ) / m ; cout << ans << endl ; return 0 ; }
TAB0 declare boolean variable kontol = true ; TAB0 create string S ; TAB0 declare ints Q , W , E and R ; TAB0 declare integer variables H and U ; TAB1 read S ; TAB1 assign index of " BA " in S to Q ; TAB1 assign last index of " AB " in S to W ; TAB1 assign last index of " BA " in S to E ; TAB1 assign index of " AB " in S to R ; TAB1 if Q = - 1 or W = - 1 , set kontol to false ; TAB1 if abs ( Q - W ) = 1 , set H to 1 ; TAB1 if abs ( E - R ) = 1 , set U to 1 ; TAB1 if H = 1 and U = 1 , assign false to kontol ; TAB1 if kontol is true ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	bool kontol = true ; string S ; int Q , W , E , R ; int H , U ; int main ( ) { cin >> S ; Q = S . find ( " BA " ) ; W = S . rfind ( " AB " ) ; E = S . rfind ( " BA " ) ; R = S . find ( " AB " ) ; if ( Q == - 1 || W == - 1 ) { kontol = false ; } if ( abs ( Q - W ) == 1 ) { H = 1 ; } if ( abs ( E - R ) == 1 ) { U = 1 ; } if ( H == 1 && U == 1 ) kontol = false ; if ( kontol ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB0 function diff ( get int a and c , return int ) ; TAB1 if a is 0 and c is 1 ; TAB1 else if a is 1 and c is 0 ; TAB1 else if a is 0 and c is 2 ; TAB1 else if a is 1 and c is 2 ; TAB1 else if a is 2 and c is 0 ; TAB1 else if a is 2 and c is 1 ; TAB1 else if a is 0 and c is 0 ; TAB2 return 1 ; TAB1 else if a is 1 and c is 1 ; TAB2 return 1 ; TAB1 else if a is 2 and c is 2 ; TAB2 return 1 ; TAB1 else ; TAB2 return 3 ; TAB0 function valueArr ( get char a , return int ) ; TAB1 if a is ' C ' ; TAB1 else if a is ' M ' ; TAB2 return 1 ; TAB1 else if a is ' Y ' ; TAB2 return 2 ; TAB1 else if a is ' ? ' ; TAB2 return 3 ; TAB1 int n ; TAB1 read n ; TAB1 arr = array of n int ; TAB1 temp = char ; TAB1 read temp ; TAB1 arr [ 0 ] = valueArr ( temp ) ; TAB1 for i = 1 to n exclusive ; TAB2 read temp ; TAB2 arr [ i ] = valueArr ( temp ) ; TAB2 if arr [ i ] = = arr [ i - 1 ] and arr [ i ] not equal 3 ; TAB3 print " No " ; TAB1 numWays = 1 , temp1 = int ; TAB1 if arr [ 0 ] is 3 or arr [ n - 1 ] is 3 ; TAB2 print " Yes " ; TAB1 else if n is 1 ; TAB2 if arr [ 0 ] is 3 ; TAB3 print " Yes " ; TAB2 else ; TAB3 print " No " ; TAB1 else if n is 2 ; TAB2 if arr [ 1 ] is 3 ; TAB3 print " Yes " ; TAB2 else ; TAB3 print " No " ; TAB1 else ; TAB2 for i = 1 to n - 1 exclusive ; TAB3 if arr [ i ] is 3 ; TAB4 temp1 = diff ( arr [ i - 1 ] , arr [ i + 1 ] ) ; TAB4 add temp1 to numWays ; TAB4 if temp1 is 3 or 1 break ; TAB2 if numWays > 1 ; TAB3 print " Yes " ; TAB2 else ; TAB3 print " No " ;	int diff ( int a , int c ) { if ( a == 0 && c == 1 ) { return 0 ; } else if ( a == 1 && c == 0 ) { return 0 ; } else if ( a == 0 && c == 2 ) { return 0 ; } else if ( a == 1 && c == 2 ) { return 0 ; } else if ( a == 2 && c == 0 ) { return 0 ; } else if ( a == 2 && c == 1 ) { return 0 ; } else if ( a == 0 && c == 0 ) { return 1 ; } else if ( a == 1 && c == 1 ) { return 1 ; } else if ( a == 2 && c == 2 ) { return 1 ; } else return 3 ; } int valueArr ( char a ) { if ( a == ' C ' ) return 0 ; else if ( a == ' M ' ) return 1 ; else if ( a == ' Y ' ) return 2 ; else if ( a == ' ? ' ) return 3 ; } int main ( ) { int n ; cin >> n ; int arr [ n ] ; char temp ; cin >> temp ; arr [ 0 ] = valueArr ( temp ) ; for ( int i = 1 ; i < n ; i ++ ) { cin >> temp ; arr [ i ] = valueArr ( temp ) ; if ( arr [ i ] == arr [ i - 1 ] && arr [ i ] != 3 ) { cout << " No " << endl ; return 0 ; } } int numWays = 1 , temp1 ; if ( arr [ 0 ] == 3 || arr [ n - 1 ] == 3 ) cout << " Yes " << endl ; else if ( n == 1 ) { if ( arr [ 0 ] == 3 ) cout << " Yes " << endl ; else cout << " No " << endl ; } else if ( n == 2 ) { if ( arr [ 1 ] == 3 ) cout << " Yes " << endl ; else cout << " No " << endl ; } else { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == 3 ) { temp1 = diff ( arr [ i - 1 ] , arr [ i + 1 ] ) ; numWays = numWays + temp1 ; if ( temp1 == 3 || temp1 == 1 ) { break ; } } } if ( numWays > 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
TAB1 x , y = integers ; TAB1 s2 = character ; TAB1 s1 = string ; TAB1 read s1 ; TAB1 iss = istringstream with call iss with s1 ; TAB1 iss x , s2 , y ; TAB1 for i = 0 to ( x * 59 ) + 59 ; TAB2 increment y ; TAB2 if y is ( x modulo 10 * 10 ) + ( x / 10 ) and y is not 60 ; TAB3 if x < 10 and y < 10 ; TAB4 print 0 , x , s2 , y , 0 ; TAB5 new line ; TAB3 else if x < 10 ; TAB4 print 0 , x , s2 , y ; TAB3 else if y < 10 ; TAB4 print x , s2 , 0 , y ; TAB3 else ; TAB4 print x , s2 , y ; TAB2 else if y > = 59 and x is 23 ; TAB3 y = - 1 ; TAB3 x = 0 ; TAB2 else if y > = 59 ; TAB3 y = - 1 ; TAB3 increment x ; TAB2 else if x is 23 and y > 32 ; TAB3 x = 0 ; TAB3 y = - 1 ;	int main ( ) { int x , y ; char s2 ; string s1 ; cin >> s1 ; istringstream iss ( s1 ) ; iss >> x >> s2 >> y ; for ( int i = 0 ; i <= ( x * 59 ) + 59 ; i ++ ) { y ++ ; if ( y == ( x % 10 * 10 ) + ( x / 10 ) && y != 60 ) { if ( x < 10 && y < 10 ) { cout << " 0 " << x << s2 << y << " 0 " << " \n " ; return 0 ; } else if ( x < 10 ) { cout << " 0 " << x << s2 << y << " \n " ; return 0 ; } else if ( y < 10 ) { cout << x << s2 << " 0 " << y << " \n " ; return 0 ; } else { cout << x << s2 << y << " \n " ; return 0 ; } } else if ( y >= 59 && x == 23 ) { y = - 1 ; x = 0 ; } else if ( y >= 59 ) { y = - 1 ; x ++ ; } else if ( x == 23 && y > 32 ) { x = 0 ; y = - 1 ; } } }
TAB1 s = string ; TAB1 read s ; TAB1 started , ended are integers both set to 0 ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] isn ' t the character a and ended is false ; TAB3 set started to 1 ; TAB3 decrement s [ i ] ; TAB2 else if started ; TAB3 set ended to 1 ; TAB1 if started is false , assign the character z to s [ ( size of s ) - 1 ] ; TAB1 output s ;	int main ( ) { string s ; cin >> s ; int started = 0 , ended = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != ' a ' && ! ended ) { started = 1 ; s [ i ] -- ; } else if ( started ) { ended = 1 ; } } if ( ! started ) s [ s . size ( ) - 1 ] = ' z ' ; cout << s << endl ; }
TAB0 ar = int array of size 10000 ; TAB0 b = int array of size 10000 ; TAB0 in function inssort taking int array ar , int n ; TAB1 i , k , j , km = int ; TAB1 for i = 1 to n ; TAB2 set k to ar [ i ] ; TAB2 set km to b [ i ] ; TAB2 set j to i - 1 ; TAB2 loop while j > = 0 and ar [ j ] > k ; TAB3 set ar [ j + 1 ] tp ar [ j ] ; TAB3 set b [ j + 1 ] to b [ j ] ; TAB3 set j to j - 1 ; TAB2 set ar [ j + 1 ] to k ; TAB2 set b [ j + 1 ] to km ; TAB1 s , n , num = int with num = 0 ; TAB1 read s then n ; TAB1 increment sum by s ; TAB1 i = int with i = 0 ; TAB1 for i = 0 to n read ar [ i ] then b [ i ] ; TAB1 call inssort on ar , n ; TAB1 for i = 0 to n ; TAB2 if sum > ar [ i ] ; TAB3 increment sum by b [ i ] ; TAB2 else ; TAB3 print " NO " ; TAB1 print " YES " ;	int ar [ 10000 ] ; int b [ 10000 ] ; void inssort ( int ar [ ] , int n ) { int i , k , j , km ; for ( i = 1 ; i < n ; i ++ ) { k = ar [ i ] ; km = b [ i ] ; j = i - 1 ; while ( j >= 0 && ar [ j ] > k ) { ar [ j + 1 ] = ar [ j ] ; b [ j + 1 ] = b [ j ] ; j = j - 1 ; } ar [ j + 1 ] = k ; b [ j + 1 ] = km ; } } int main ( ) { int s , n , sum = 0 ; cin >> s >> n ; sum += s ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { cin >> ar [ i ] >> b [ i ] ; } inssort ( ar , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( sum > ar [ i ] ) { sum += b [ i ] ; } else { cout << " NO " << endl ; return 0 ; } } cout << " YES " << endl ; return 0 ; }
TAB0 create constant integer INF with INF = 1 bitshift left 29 ; TAB0 create integer arrays l , s , r , p , with l size 4 , s size 4 , r size 4 , p size 4 ; TAB1 for i = 0 to 4 exclusive , read l [ i ] read s [ i ] read r [ i ] read p [ i ] ; TAB1 for i = 0 to 4 exclusive ; TAB2 if p [ i ] is true ; TAB3 if l [ ( i + 1 ) % 4 ] or r [ ( i + 3 ) % 4 ] or s [ ( i + 2 ) % 4 ] ; TAB4 print " YES \ n " ; TAB3 if l [ i ] or r [ i ] or s [ i ] ; TAB4 print " YES \ n " ; TAB1 print " NO \ n " ;	const int INF = 1 << 29 ; int l [ 4 ] , s [ 4 ] , r [ 4 ] , p [ 4 ] ; int main ( ) { for ( int i = 0 ; i < 4 ; i ++ ) cin >> l [ i ] >> s [ i ] >> r [ i ] >> p [ i ] ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( p [ i ] ) { if ( l [ ( i + 1 ) % 4 ] || r [ ( i + 3 ) % 4 ] || s [ ( i + 2 ) % 4 ] ) { cout << " YES\n " ; return 0 ; } if ( l [ i ] || r [ i ] || s [ i ] ) { cout << " YES\n " ; return 0 ; } } } cout << " NO\n " ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 print n print newline ; TAB1 end statement ; TAB1 for i = 1 to n exclusive , print 1 print " " ; TAB1 print 1 print newline ;	int main ( ) { int n ; cin >> n ; cout << n << endl ; ; for ( int i = 1 ; i < n ; i ++ ) { cout << 1 << "   " ; } cout << 1 << endl ; }
TAB1 let n , k , x , cnt , a be integers with cnt = 0 , a = array of integers of length 100 ; TAB1 create empty set of integers s , create empty set of integers t ; TAB1 read n and k ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 the value of x is equal to a [ i ] ; TAB2 if s . find ( x ) is equal to s . end ( ) ; TAB3 increment cnt by 1 ; TAB3 insert x into s ; TAB2 if size of s is equal to k + 1 ; TAB3 the value of t is equal to s ; TAB3 erase x from t ; TAB3 for j = i + 1 to n exclusive ; TAB4 if size of t is equal to 1 , stop ; TAB4 erase a [ j ] from t ; TAB3 s . erase ( * ( t . begin ( ) ) ) ; TAB1 print cnt and newline ;	int main ( ) { int n , k , x , cnt = 0 , a [ 100 ] ; set < int > s , t ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { x = a [ i ] ; if ( s . find ( x ) == s . end ( ) ) { ++ cnt ; s . insert ( x ) ; } if ( s . size ( ) == k + 1 ) { t = s ; t . erase ( x ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( t . size ( ) == 1 ) break ; t . erase ( a [ j ] ) ; } s . erase ( * ( t . begin ( ) ) ) ; } } cout << cnt << endl ; return 0 ; }
TAB0 maxn = const int = 200010 ; TAB0 MAXM = const int = 500000 ; TAB0 let in be an int priority queue array of length maxn ; TAB0 in int function cmp taking a = int priority queue , b = int priority queue ; TAB1 return weather top of a > top of b ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 temp , a = int ; TAB2 read temp ; TAB2 for j = 0 to temp exclusive ; TAB3 read a ; TAB3 push a into in at i ; TAB1 sort the first n elements of in using cmp ; TAB1 sum = 0 = long long ; TAB1 for i = 1 to n exclusive ; TAB2 if top of in [ i ] < top of in at 0 ; TAB3 diff = top of in [ 0 ] - top of in [ i ] = int ; TAB3 while in [ i ] isn ' t empty ; TAB4 push itop of n [ i ] + diff into in [ 0 ] ; TAB4 pop in [ i ] ; TAB4 increment suum by diff ; TAB1 print sum ;	const int maxn = 200010 ; const int MAXM = 500000 ; priority_queue < int > in [ maxn ] ; int cmp ( priority_queue < int > a , priority_queue < int > b ) { return a . top ( ) > b . top ( ) ; } int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int temp , a ; cin >> temp ; for ( int j = 0 ; j < temp ; j ++ ) { cin >> a ; in [ i ] . push ( a ) ; } } sort ( in , in + n , cmp ) ; long long sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( in [ i ] . top ( ) < in [ 0 ] . top ( ) ) { int diff = in [ 0 ] . top ( ) - in [ i ] . top ( ) ; while ( ! in [ i ] . empty ( ) ) { in [ 0 ] . push ( in [ i ] . top ( ) + diff ) ; in [ i ] . pop ( ) ; sum += diff ; } } } cout << sum << endl ; return 0 ; }
TAB0 let N be a constant integer with N = 200000 + 10 ; TAB0 let y , k , n be integers ; TAB0 let s be a string ; TAB1 input s ; TAB1 let flag be a boolean set to false ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is the character a and flag , break ; TAB2 if s [ i ] is the character a , continue ; TAB2 subtract 1 from s [ i ] ; TAB2 assign true to flag ; TAB1 if not flag ; TAB2 let len be an integer with len = length of s ; TAB2 assign the character z to s [ len - 1 ] ; TAB1 output s ;	const int N = 200000 + 10 ; int y , k , n ; string s ; int main ( ) { cin >> s ; bool flag = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' a ' && flag ) break ; if ( s [ i ] == ' a ' ) continue ; s [ i ] = s [ i ] - 1 ; flag = true ; } if ( ! flag ) { int len = s . length ( ) ; s [ len - 1 ] = ' z ' ; } cout << s << endl ; return 0 ; }
TAB0 n = int and a = int array of size 100 ; TAB0 s = string ; TAB0 in function check taking int k and returning bool ; TAB1 t = int with t = 0 ; TAB1 for i = 0 to 26 increment t by ceil of a [ i ] as double / k ; TAB1 if t > n return 0 ; TAB1 return 1 ; TAB0 in function bs taking int b , int e and returning int ; TAB1 if e - b is 1 return b ; TAB1 mid = int with mid = ( b + e ) / 2 ; TAB1 if check of mid - 1 return bs of b , mid ; TAB1 return bs of mid , e ; TAB1 read s then n ; TAB1 for i = 0 to size of s increment a [ s [ i ] - ' a ' ] ; TAB1 t = int with t = bs of 1 , 2000 ; TAB1 ans = string with ans = " " ; TAB1 for i = 0 to 26 ; TAB2 for j = 0 to ceil of a [ i ] as double / t append ( i + ' a ' ) as char to ans ; TAB1 loop while size of ans < n append ' a ' to ans ; TAB1 if t is 1999 ; TAB2 print - 1 ; TAB1 else ; TAB2 print t and ans ;	int n , a [ 100 ] ; string s ; bool check ( int k ) { int t = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) t += ceil ( ( double ) a [ i ] / k ) ; if ( t > n ) return 0 ; return 1 ; } int bs ( int b , int e ) { if ( e - b == 1 ) return b ; int mid = ( b + e ) / 2 ; if ( check ( mid - 1 ) ) return bs ( b , mid ) ; return bs ( mid , e ) ; } int main ( ) { cin >> s >> n ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) a [ s [ i ] - ' a ' ] ++ ; int t = bs ( 1 , 2000 ) ; string ans = "  " ; for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 0 ; j < ceil ( ( double ) a [ i ] / t ) ; j ++ ) ans = ans + ( char ) ( i + ' a ' ) ; while ( ans . size ( ) < n ) ans = ans + ' a ' ; if ( t == 1999 ) cout << - 1 << endl ; else cout << t << endl << ans << endl ; }
TAB0 let a = array of integers with size = 302000 ; TAB0 let cnt = array of integers of size = integer 20000000 ; TAB0 let done = array of boolean with size = integer 20000000 ; TAB0 let m = integer constant with value 15000000 ; TAB1 let n = integer ; TAB1 read n ; TAB1 let g = integer ; TAB1 for integer i = 1 to n inclusive do the following ; TAB2 read a [ i ] ; TAB2 increment cnt [ a [ i ] ] ; TAB2 if i is greater than 1 do the following ; TAB3 set g = call __gcd on a [ i ] and g ; TAB2 else ; TAB3 set g = a [ i ] ; TAB1 let ans = 0 ; TAB1 for integer i = g + 1 to m inclusive do the following ; TAB2 if not done [ i ] do the following ; TAB3 let sum = integer with value = 0 ; TAB3 for integer j = 1 to m inclusive increment step j + i do the following ; TAB4 set sum = sum + cnt [ j ] ; TAB4 set done [ j ] = true ; TAB3 set ans = max of ans and sum ; TAB1 if ans is 0 do the following ; TAB2 write - 1 to stdout ; TAB1 else ; TAB2 print n - ans ;	int a [ 302000 ] ; int cnt [ ( int ) ( 2e7 ) ] ; bool done [ ( int ) ( 2e7 ) ] ; const int m = 1.5e7 ; int main ( ) { int n ; cin >> n ; int g ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; ++ cnt [ a [ i ] ] ; if ( i > 1 ) { g = __gcd ( a [ i ] , g ) ; } else g = a [ i ] ; } int ans = 0 ; for ( int i = g + 1 ; i <= m ; ++ i ) { if ( ! done [ i ] ) { int sum = 0 ; for ( int j = i ; j <= m ; j += i ) { sum += cnt [ j ] ; done [ j ] = true ; } ans = max ( ans , sum ) ; } } if ( ans == 0 ) { puts ( " -1 " ) ; } else { cout << n - ans << endl ; } return 0 ; }
TAB1 s = string array = " C " , " C # " , " D " , " D # " , " E " , " F " , " F # " , " G " , " G # " , " A " , " B " , " H " ; TAB1 a , b , c = string ; TAB1 i = int ; TAB1 read a , b , c ; TAB1 x = int array of length 13 ; TAB1 for i = 0 to 12 exclusive increment i first ; TAB2 if s at i = a or s at i = b or s at i = c then set x at i to 1 ; TAB1 for i = 0 to 12 exclusive increment i first ; TAB2 if x at i = 1 ; TAB3 if x [ ( i + 4 ) % 12 ] = 1 and x [ ( i + 7 ) % 12 ] = 1 ; TAB4 print major ; TAB3 else if x [ ( i + 3 ) % 12 ] = 1 and x [ ( i + 7 ) % 12 ] = 1 ; TAB4 print minor ; TAB1 print strange ;	int main ( ) { string s [ ] = { " C " , " C# " , " D " , " D# " , " E " , " F " , " F# " , " G " , " G# " , " A " , " B " , " H " } ; string a , b , c ; int i ; cin >> a >> b >> c ; int x [ 13 ] ; for ( i = 0 ; i < 12 ; ++ i ) { if ( s [ i ] == a || s [ i ] == b || s [ i ] == c ) x [ i ] = 1 ; } for ( i = 0 ; i < 12 ; ++ i ) { if ( x [ i ] == 1 ) { if ( x [ ( i + 4 ) % 12 ] == 1 && x [ ( i + 7 ) % 12 ] == 1 ) { cout << " major " << endl ; return 0 ; } else if ( x [ ( i + 3 ) % 12 ] == 1 && x [ ( i + 7 ) % 12 ] == 1 ) { cout << " minor " << endl ; return 0 ; } } } cout << " strange " << endl ; return 0 ; }
TAB1 create integer n ; TAB1 read input to n ; TAB1 create an array of ints a with size n ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 create integers c and t = 0 ; TAB1 for i from 1 to n inclusive ; TAB2 if a [ i ] is less than 0 ; TAB3 increment c ; TAB2 else ; TAB3 increment t ; TAB1 if t = n or n = 1 ; TAB2 print " 1 " and n ; TAB1 if c is even ; TAB2 print c / 2 ; TAB1 else ; TAB2 print c / 2 + 1 ; TAB1 declare integers f and d = 0 ; TAB1 for integer i = 1 to n exclusive ; TAB2 if a [ i ] is less than 0 , increment d ; TAB2 if d = 2 and a [ i + 1 ] < 0 ; TAB3 print i - f and " " ; TAB3 assign i to f ; TAB3 set d to 0 ; TAB1 print n - f ;	int main ( ) { int n ; cin >> n ; int a [ n ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; int c = 0 , t = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] < 0 ) { c ++ ; } else { t ++ ; } } if ( t == n || n == 1 ) { cout << " 1 " << endl << n << endl ; return 0 ; } if ( c % 2 == 0 ) cout << c / 2 << endl ; else cout << c / 2 + 1 << endl ; int f = 0 , d = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < 0 ) { d ++ ; } if ( d == 2 && a [ i + 1 ] < 0 ) { cout << i - f << "   " ; f = i ; d = 0 ; } } cout << n - f << endl ; return 0 ; }
TAB1 declare integers n and s ; TAB1 read standard input to n and s ; TAB1 ans is a new integer = - 1 ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 declare new integer variables a and b ; TAB2 read a and b ; TAB2 if s * 100 is less than a * 100 + b , go to the start of the loop ; TAB2 change ans to max of ( ( 100 * s ) - ( a * 100 + b ) ) % 100 and ans ; TAB1 print ans ;	int main ( ) { int n , s ; cin >> n >> s ; int ans = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { int a , b ; cin >> a >> b ; if ( s * 100 < a * 100 + b ) continue ; ans = max ( ( ( 100 * s ) - ( a * 100 + b ) ) % 100 , ans ) ; } cout << ans << endl ; return 0 ; }
TAB0 create int array f of size 100 with array of size 100 ; TAB1 make ints i , j , n , k , and m ; TAB1 read k and while it ' s truthy ; TAB2 for i = 1 to 100 ; TAB3 for j = 1 to 100 , set f [ i ] [ j ] to 0 ; TAB2 for i = 1 to 100 ; TAB3 if i * ( i - 1 ) * ( i - 2 ) / 6 is greater than k , break loop ; TAB2 set n to i - 1 ; TAB2 for i = 1 to n ; TAB3 for j = 1 to n ; TAB4 if i is not j , set f [ i ] [ j ] to 1 ; TAB2 set k to k - n * ( n - 1 ) * ( n - 2 ) / 6 ; TAB2 while k is greater than 0 ; TAB3 for i = 1 to 100 ; TAB4 if i * ( i - 1 ) / 2 is greater than k , break loop ; TAB3 set m to i - 1 ; TAB3 for i = 1 to m , set f [ i ] [ n + 1 ] and f [ n + 1 ] [ i ] to 1 ; TAB3 add 1 to n ; TAB3 set k to k - ( m - 1 ) * m / 2 ; TAB2 print n ; TAB2 for i = 1 to n ; TAB3 for j = 1 to n , print f [ i ] [ j ] ; TAB3 print new line ;	int f [ 110 ] [ 110 ] ; int main ( ) { int i , j , n , k , m ; while ( cin >> k ) { for ( i = 1 ; i <= 100 ; i ++ ) for ( j = 1 ; j <= 100 ; j ++ ) f [ i ] [ j ] = 0 ; for ( i = 1 ; i <= 100 ; i ++ ) if ( i * ( i - 1 ) * ( i - 2 ) / 6 > k ) break ; n = i - 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) if ( i != j ) f [ i ] [ j ] = 1 ; k = k - n * ( n - 1 ) * ( n - 2 ) / 6 ; while ( k > 0 ) { for ( i = 1 ; i <= 100 ; i ++ ) if ( i * ( i - 1 ) / 2 > k ) break ; m = i - 1 ; for ( i = 1 ; i <= m ; i ++ ) f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1 ; n += 1 ; k = k - ( m - 1 ) * m / 2 ; } cout << n << endl ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) cout << f [ i ] [ j ] ; cout << endl ; } } return 0 ; }
TAB1 create integers h1 , h2 , p1 , p2 , d1 , d2 ; TAB1 read h1 read p1 read d1 read h2 read p2 read d2 ; TAB1 create integers ph , pp , pd ; TAB1 read ph read pp read pd ; TAB1 create integer ans with ans = 1000000000 ; TAB1 for i = 0 to maximum of ( p2 - d1 and 0 ) inclusive ; TAB2 for j = d2 - p1 + 1 if p1 is less than or equal to d2 , else 0 , to h2 + d2 inclusive ; TAB3 create integer t with t = ( h2 - 1 ) / ( p1 + j - d2 ) + 1 ; TAB3 create integer r with r = t * ( p2 - d1 - i ) - h1 + 1 ; TAB3 set r to 0 if r is less than 0 , else r ; TAB3 set ans to minimum of ans and r * ph + j * pp + i * pd ; TAB1 set ans to 0 if ans is 1000000000 , else ans ; TAB1 print ans print newline ;	int main ( ) { int h1 , h2 , p1 , p2 , d1 , d2 ; cin >> h1 >> p1 >> d1 >> h2 >> p2 >> d2 ; int ph , pp , pd ; cin >> ph >> pp >> pd ; int ans = 1000000000 ; for ( int i = 0 ; i <= max ( p2 - d1 , 0 ) ; i ++ ) { for ( int j = p1 <= d2 ? d2 - p1 + 1 : 0 ; j <= h2 + d2 ; j ++ ) { int t = ( h2 - 1 ) / ( p1 + j - d2 ) + 1 ; int r = t * ( p2 - d1 - i ) - h1 + 1 ; r = r < 0 ? 0 : r ; ans = min ( ans , r * ph + j * pp + i * pd ) ; } } ans = ans == 1000000000 ? 0 : ans ; cout << ans << endl ; }
TAB0 MAXN = a constant set to 100005 ; TAB0 MOD = and constant set to 998244353 ; TAB0 a = an array of integers with a length of MAXN ; TAB0 dp = a 2 dimentional array of integers with a length of 201 ; TAB0 newdp = a 2 dimentional array of integers with a length of 201 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read index i of a ; TAB1 for i = 0 to n exclusive ; TAB2 if i = 0 ; TAB3 if index i of a = - 1 ; TAB4 for x = 1 to 200 inclusive , set newdp [ x ] [ 0 ] = 1 ; TAB3 else ; TAB4 newdp [ a [ i ] ] [ 0 ] = 1 ; TAB2 else ; TAB3 if index i of a = - 1 ; TAB4 flag0 = integer set to 0 ; TAB4 flag1 = integer set to 0 ; TAB4 for y = 1 to 200 inclusive ; TAB5 add dp [ y ] [ 1 ] to flag1 ; TAB5 modulo flag1 by MOD ; TAB4 for x = 1 to 200 inclusive ; TAB5 subtract dp [ x - 1 ] [ 1 ] from flag1 ; TAB5 add MOD to flag1 ; TAB5 modulo flag1 by MOD ; TAB5 subtract dp [ x - 1 ] [ 0 ] from flag1 ; TAB5 add MOD to flag1 ; TAB5 modulo flag1 by MOD ; TAB5 add dp [ x - 1 ] [ 1 ] to flag0 ; TAB5 modulo flag0 by MOD ; TAB5 add dp [ x - 1 ] [ 0 ] to flag0 ; TAB5 modulo flag0 by MOD ; TAB5 add dp [ x ] [ 0 ] to flag1 ; TAB5 modulo flag1 by MOD ; TAB5 set newdp [ x ] [ 0 ] to flag0 ; TAB5 set newdp [ x ] [ 1 ] to flag1 ; TAB3 else ; TAB4 x = integer set to index i of a ; TAB4 for y = 1 to 200 inclusive ; TAB5 flag = integer set to 1 if x < = y or 0 ; TAB5 add dp [ y ] [ 1 ] to newdp [ x ] [ flag ] ; TAB5 modulo newdp [ x ] [ flag ] by MOD ; TAB5 if y < = x ; TAB6 add dp [ y ] [ 0 ] to newdp [ x ] [ flag ] ; TAB6 modulo newdp [ x ] [ flag ] by MOD ; TAB2 run memcpy with dp , newdp and 201 * 2 * 4 as arguments ; TAB2 run memset with newdp , 0 , and 201 * 2 * 4 as arguments ; TAB1 ans = integer set to 0 ; TAB1 for x = 1 to 200 inclusive ; TAB2 add dp [ x ] [ 1 ] to ans ; TAB2 modulo ans by MOD ; TAB1 read ans ;	const int MAXN = 100005 ; const int MOD = 998244353 ; int a [ MAXN ] ; int dp [ 201 ] [ 2 ] ; int newdp [ 201 ] [ 2 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 ) { if ( a [ i ] == - 1 ) { for ( int x = 1 ; x <= 200 ; ++ x ) { newdp [ x ] [ 0 ] = 1 ; } } else { newdp [ a [ i ] ] [ 0 ] = 1 ; } } else { if ( a [ i ] == - 1 ) { int flag0 = 0 ; int flag1 = 0 ; for ( int y = 1 ; y <= 200 ; ++ y ) { flag1 += dp [ y ] [ 1 ] ; flag1 %= MOD ; } for ( int x = 1 ; x <= 200 ; ++ x ) { flag1 -= dp [ x - 1 ] [ 1 ] ; flag1 += MOD ; flag1 %= MOD ; flag1 -= dp [ x - 1 ] [ 0 ] ; flag1 += MOD ; flag1 %= MOD ; flag0 += dp [ x - 1 ] [ 1 ] ; flag0 %= MOD ; flag0 += dp [ x - 1 ] [ 0 ] ; flag0 %= MOD ; flag1 += dp [ x ] [ 0 ] ; flag1 %= MOD ; newdp [ x ] [ 0 ] = flag0 ; newdp [ x ] [ 1 ] = flag1 ; } } else { int x = a [ i ] ; for ( int y = 1 ; y <= 200 ; ++ y ) { int flag = x <= y ? 1 : 0 ; newdp [ x ] [ flag ] += dp [ y ] [ 1 ] ; newdp [ x ] [ flag ] %= MOD ; if ( y <= x ) { newdp [ x ] [ flag ] += dp [ y ] [ 0 ] ; newdp [ x ] [ flag ] %= MOD ; } } } } memcpy ( dp , newdp , 201 * 2 * 4 ) ; memset ( newdp , 0 , 201 * 2 * 4 ) ; } int ans = 0 ; for ( int x = 1 ; x <= 200 ; ++ x ) { ans += dp [ x ] [ 1 ] ; ans %= MOD ; } cout << ans << endl ; return 0 ; }
TAB0 pre = array of 1005 int ; TAB0 function init ( no args , no return value ) ; TAB1 i = int ; TAB1 for i = 1 to 100 inclusive pre [ i ] = i ; TAB0 function find ( get int x , return int ) ; TAB1 t = x ; TAB1 while pre [ t ] is not t t = pre [ t ] ; TAB1 return t ; TAB0 function join ( get int x and y , return int ) ; TAB1 m = find ( x ) ; TAB1 n = find ( y ) ; TAB1 if m is not n pre [ n ] = m ; TAB1 n , m = int ; TAB1 a , b , c , d = array of 105 int ; TAB1 while read n , m ; TAB2 init ( ) ; TAB2 sum = 0 ; TAB2 i , j = int , k , l = 0 ; TAB2 fill c with 0 ; TAB2 fill d with 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 if a [ i ] is 0 ; TAB4 increment sum ; TAB4 continue ; TAB3 for j = 0 to a [ i ] exclusive ; TAB4 pl = 0 ; TAB4 read b [ j ] ; TAB4 for q = 0 to k exclusive ; TAB5 if c [ q ] is b [ j ] pl = 1 ; TAB4 if pl is 0 c [ k ] = b [ j ] , increment k ; TAB3 sort first a [ i ] items of b ; TAB3 for j = 1 to a [ i ] exclusive join ( b [ j - 1 ] , b [ j ] ) ; TAB2 for i = 0 to k exclusive ; TAB3 hui = find [ c [ i ] ] ; TAB3 d [ l ] = hui , increment l ; TAB2 sort first l items of d ; TAB2 for i = 1 to l exclusive ; TAB3 if d [ i ] is not d [ i - 1 ] increment sum ; TAB2 print sum ;	int pre [ 1005 ] ; void init ( ) { int i ; for ( i = 1 ; i <= 100 ; i ++ ) { pre [ i ] = i ; } } int find ( int x ) { int t = x ; while ( pre [ t ] != t ) { t = pre [ t ] ; } return t ; } int join ( int x , int y ) { int m = find ( x ) ; int n = find ( y ) ; if ( m != n ) { pre [ n ] = m ; } } int main ( ) { int n , m ; int a [ 105 ] , b [ 105 ] , c [ 105 ] , d [ 105 ] ; while ( cin >> n >> m ) { init ( ) ; int sum = 0 ; int i , j , k = 0 , l = 0 ; memset ( c , 0 , sizeof ( c ) ) ; memset ( d , 0 , sizeof ( d ) ) ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] == 0 ) { sum ++ ; continue ; } for ( j = 0 ; j < a [ i ] ; j ++ ) { int pl = 0 ; cin >> b [ j ] ; for ( int q = 0 ; q < k ; q ++ ) { if ( c [ q ] == b [ j ] ) { pl = 1 ; } } if ( pl == 0 ) { c [ k ++ ] = b [ j ] ; } } sort ( b , b + a [ i ] ) ; for ( j = 1 ; j < a [ i ] ; j ++ ) { join ( b [ j - 1 ] , b [ j ] ) ; } } for ( i = 0 ; i < k ; i ++ ) { int hui = find ( c [ i ] ) ; d [ l ++ ] = hui ; } sort ( d , d + l ) ; for ( i = 1 ; i < l ; i ++ ) { if ( d [ i ] != d [ i - 1 ] ) { sum ++ ; } } cout << sum << endl ; } return 0 ; }
TAB1 create long longs t1 , t2 , x1 , x2 and t0 ; TAB1 read t1 , t2 , x1 , x2 and t0 from the user input ; TAB1 create new long longs x and xx ; TAB1 create double mn with value 1000000000000 . 00 ; TAB1 while x1 and x2 are both > = 0 ; TAB2 define double check with value = ( t1 * x1 * 1 . 0 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if check is less than t0 ; TAB3 decrement x1 by one ; TAB3 go to the start of the loop ; TAB2 if check is less than mn ; TAB3 assign check to mn ; TAB3 set x to x1 ; TAB3 change the value of xx to x2 ; TAB2 decrement x2 ; TAB1 print x , " " and xx ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; long long x , xx ; double mn = 1000000000000.00 ; while ( x1 >= 0 && x2 >= 0 ) { double check = ( t1 * x1 * 1.0 + t2 * x2 * 1.0 ) / ( double ) ( x1 + x2 ) ; if ( check < t0 ) { x1 -- ; continue ; } if ( check < mn ) { mn = check ; x = x1 ; xx = x2 ; } x2 -- ; } cout << x << "   " << xx << endl ; return 0 ; }
TAB0 n , m = integers ; TAB0 la , lb = integers both with value of 1 ; TAB0 vis = integer array of length 10 ; TAB0 ans = integer with value o f0 ; TAB0 in function dfs2 that returns nothing and takes arguments k , num = integers ; TAB1 if k equals lb ; TAB2 add 1 to ans ; TAB2 return ; TAB1 for i = 0 to 6 inclusive ; TAB2 if vis [ i ] equals 0 and num * 7 + i is less than m ; TAB3 set vis [ i ] to 1 ; TAB3 call dfs2 with arguments k + 1 and num * 7 + i ; TAB3 set vis [ i ] to 0 ; TAB0 in function dfs1 that returns nothing and take arguments k , num = integer ; TAB1 if k equals la ; TAB2 call dfs2 with arguments 0 and 0 ; TAB2 return ; TAB1 for i = 0 to 6 inclusive ; TAB2 if vis [ i ] equals 0 and num * 7 + i is less than n ; TAB3 set vis [ i ] to 1 ; TAB3 call dfs1 with arguments k + 1 and num * 7 + i ; TAB3 set vis [ i ] to 0 ; TAB1 read n and m ; TAB1 fn , fm = integers with fn value of n and fm value of m ; TAB1 if n is greater than 0 subtract 1 from n ; TAB1 if m is greater than 0 subtract 1 from m ; TAB1 while n / 7 ; TAB2 add 1 to la ; TAB2 set n to n / 7 ; TAB1 while m / 7 ; TAB2 add 1 to lb ; TAB2 set m to m / 7 ; TAB1 set n to fn and m to fm ; TAB1 if la + lb is greater than 7 ; TAB2 print 0 ; TAB1 call dfs1 with argument of 0 and 0 ; TAB1 print ans ;	int n , m ; int la = 1 , lb = 1 ; int vis [ 10 ] ; int ans = 0 ; void dfs2 ( int k , int num ) { if ( k == lb ) { ans ++ ; return ; } for ( int i = 0 ; i <= 6 ; i ++ ) { if ( vis [ i ] == 0 && num * 7 + i < m ) { vis [ i ] = 1 ; dfs2 ( k + 1 , num * 7 + i ) ; vis [ i ] = 0 ; } } } void dfs1 ( int k , int num ) { if ( k == la ) { dfs2 ( 0 , 0 ) ; return ; } for ( int i = 0 ; i <= 6 ; i ++ ) { if ( vis [ i ] == 0 && num * 7 + i < n ) { vis [ i ] = 1 ; dfs1 ( k + 1 , num * 7 + i ) ; vis [ i ] = 0 ; } } } int main ( ) { cin >> n >> m ; int fn = n , fm = m ; if ( n > 0 ) n -- ; if ( m > 0 ) m -- ; while ( n / 7 ) { la ++ ; n /= 7 ; } while ( m / 7 ) { lb ++ ; m /= 7 ; } n = fn , m = fm ; if ( la + lb > 7 ) { cout << 0 << endl ; return 0 ; } dfs1 ( 0 , 0 ) ; cout << ans << endl ; return 0 ; }
TAB0 create string s , t ; TAB0 create int n , m ; TAB0 create long long int mod ; TAB0 in function add , returning long long int and accepting long long ints x and y ; TAB1 return ( x % mod + y % mod ) % mod ; TAB0 create long long int array dp of size 5001x5001 ; TAB0 in function rec returning long long int and accepting ints i and j ; TAB1 if dp [ i ] [ j ] is not equal to - 1 , return dp [ i ] [ j ] ; TAB1 if j equals m or i equals n , return 0 ; TAB1 create long long int sm = 0 ; TAB1 increase sm by rec ( i , j , + 1 ) ; TAB1 if s [ i ] equals t [ j ] , set sm to ( sm + rec ( i + 1 , j + 1 ) + 1 ) % mod ; TAB1 return dp [ i ] [ j ] = sm ; TAB1 set mod to 1e9 + 7 ; TAB1 read s and t ; TAB1 set n to size of s ; TAB1 set m to size of t ; TAB1 create long long int ans = 0 ; TAB1 set elements of dp to - 1 ; TAB1 for i = 0 to n exclusive , set ans to ( ans + rec ( i , 0 ) ) % mod ; TAB1 print ans ;	string s , t ; int n , m ; long long int mod ; long long int add ( long long int x , long long int y ) { return ( x % mod + y % mod ) % mod ; } long long int dp [ 5001 ] [ 5001 ] ; long long int rec ( int i , int j ) { if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( j == m || i == n ) { return 0 ; } long long int sm = 0 ; sm += rec ( i , j + 1 ) ; if ( s [ i ] == t [ j ] ) { sm = ( sm + rec ( i + 1 , j + 1 ) + 1 ) % mod ; } return dp [ i ] [ j ] = sm ; } int main ( ) { mod = 1e9 + 7 ; cin >> s >> t ; n = s . size ( ) ; m = t . size ( ) ; long long int ans = 0 ; memset ( dp , - 1 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { ans = ( ans + rec ( i , 0 ) ) % mod ; } cout << ans << " \n " ; }
TAB0 create constant double PI with value of acos ( - 1 ) ; TAB0 declare new constant integer called MAX = 2e9 + 7 ; TAB0 MOD is a new constant integer = 1000000007 ; TAB0 m = map from integers to long longs ; TAB0 solve is a void function ; TAB1 create new integer a ; TAB1 read variable a from the input ; TAB1 declare string variable with name s ; TAB1 read s ; TAB1 declare new long long called n with value = length of s ; TAB1 create new long long called total with value 0 ; TAB1 declare new array of integers p with n elements ; TAB1 for i = 0 to n exclusive ; TAB2 if i is false ; TAB3 change p [ i ] to s [ i ] - ' 0 ' casted to int ; TAB2 else ; TAB3 assign the new value = p [ i - 1 ] + ( s [ i ] - ' 0 ' to p [ i ] ) ; TAB1 for len = 1 to n inclusive ; TAB2 loop i from 0 , while i + len - 1 < n , incrementing by 1 ; TAB3 create integer sum = p [ i + len - 1 ] ; TAB3 if i ! = 0 , subtract p [ i - 1 ] from sum ; TAB3 increment m [ sum ] by one ; TAB3 increment total by one ; TAB1 if a = 0 ; TAB2 print total * m [ 0 ] * 2 - m [ 0 ] * m [ 0 ] ; TAB2 return ; TAB1 declare new long long variable ans = 0 ; TAB1 for integer i = 1 to the square root of a inclusive ; TAB2 if a modulo i is equal to 0 ; TAB3 if i = square root of a ; TAB4 add ( ( m [ i ] * ( m [ i ] - 1 ) ) + m [ i ] ) to ans ; TAB3 else ; TAB4 change ans to ans + 2 * ( m [ i ] * m [ a / i ] ) ; TAB1 print ans to the standard output ; TAB1 call function solve ;	const double PI = acos ( - 1 ) ; const int MAX = 2e9 + 7 ; const int MOD = 1000000007 ; map < int , long long > m ; void solve ( ) { int a ; cin >> a ; string s ; cin >> s ; long long n = s . size ( ) ; long long total = 0 ; int p [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! i ) p [ i ] = int ( s [ i ] - ' 0 ' ) ; else p [ i ] = p [ i - 1 ] + int ( s [ i ] - ' 0 ' ) ; } for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i + len - 1 < n ; i ++ ) { int sum = p [ i + len - 1 ] ; if ( i != 0 ) sum -= p [ i - 1 ] ; m [ sum ] ++ ; total ++ ; } } if ( a == 0 ) { cout << total * m [ 0 ] * 2 - m [ 0 ] * m [ 0 ] << endl ; return ; } long long ans = 0 ; for ( int i = 1 ; i <= sqrt ( a ) ; i ++ ) { if ( a % i == 0 ) { if ( i == sqrt ( a ) ) { ans += ( ( m [ i ] * ( m [ i ] - 1 ) ) + m [ i ] ) ; } else { ans += 2 * ( m [ i ] * m [ a / i ] ) ; } } } cout << ans << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 str = string ; TAB1 read str ; TAB1 i = int with i = 0 ; TAB1 loop while str [ i ] is not ' 0 ' increment i ; TAB1 for j = i to size of str - 1 set str [ j ] to str [ j + 1 ] ; TAB1 resize str to size of str - 1 ; TAB1 print str ;	int main ( ) { string str ; cin >> str ; int i = 0 ; while ( str [ i ] != ' 0 ' ) i ++ ; for ( int j = i ; j < str . size ( ) - 1 ; j ++ ) { str [ j ] = str [ j + 1 ] ; } str . resize ( str . size ( ) - 1 ) ; cout << str << endl ; return 0 ; }
TAB1 let a , b , c , t , l , i , k be integers with k = 0 ; TAB1 let sum and d be double with sum = d = 0 ; TAB1 read a and b ; TAB1 for i = 1 to a inclusive ; TAB2 read c ; TAB2 is sum is less than or equal to ceil of c / b ; TAB3 set sum to ceil of c / b ; TAB3 set k to i ; TAB1 print k with newline ;	int main ( ) { int a , b , c , t , l , i , k = 0 ; double sum = 0 , d = 0 ; cin >> a >> b ; for ( i = 1 ; i <= a ; i ++ ) { cin >> c ; if ( sum <= ceil ( ( double ) c / b ) ) { sum = ceil ( ( double ) c / b ) ; k = i ; } } cout << k << endl ; }
TAB0 let n , m , k , l be integers ; TAB1 read n , m , k , l ; TAB1 if m > n ; TAB2 print - 1 ; TAB1 if k + l < = m ; TAB2 print 1 ; TAB1 let a be long lon ; TAB1 if ( k + l ) mod m = = 0 ; TAB2 set a to ( k + l ) / m ; TAB1 else ; TAB2 set a to ( k + l ) / m + 1 ; TAB1 if a * m > n ; TAB2 print - 1 ; TAB1 else ; TAB2 print a ;	long long n , m , k , l ; int main ( ) { cin >> n >> m >> k >> l ; if ( m > n ) { cout << - 1 << endl ; return 0 ; } if ( k + l <= m ) { cout << 1 << endl ; return 0 ; } long long a ; if ( ( k + l ) % m == 0 ) a = ( k + l ) / m ; else a = ( k + l ) / m + 1 ; if ( a * m > n ) cout << - 1 << endl ; else cout << a << endl ; }
TAB0 h , m = int ; TAB1 read h then m ; TAB1 l1 , l2 = int with l1 = 1 and l2 = 1 ; TAB1 for i = 7 to h setting i to i * 7 increment l1 ; TAB1 for i = 7 to m setting i to i * 7 increment l2 ; TAB1 ans = int with ans = 0 ; TAB1 if l1 + l2 is greater than 7 ; TAB2 print " 0 " ; TAB1 for i = 0 to h ; TAB2 for j = 0 to m ; TAB3 cnt = int vector of size 7 setting all values to 0 ; TAB3 x , l = int with x = i and k = 0 loop until k is l1 setting x to x / 7 and incrementing k each time increment cnt [ x mod 7 ] ; TAB3 x , l = int with x = j and k = 0 loop until k is l2 setting x to x / 7 and incrementing k each time increment cnt [ x mod 7 ] ; TAB3 if value of max_element of begin of cnt and end of cnt is less than 2 then increment ans ; TAB1 print ans ;	int h , m ; int main ( ) { cin >> h >> m ; int l1 = 1 , l2 = 1 ; for ( int i = 7 ; i < h ; i *= 7 ) l1 ++ ; for ( int i = 7 ; i < m ; i *= 7 ) l2 ++ ; int ans = 0 ; if ( l1 + l2 > 7 ) { cout << " 0\n " ; return 0 ; } for ( int i = 0 ; i != h ; ++ i ) for ( int j = 0 ; j != m ; ++ j ) { vector < int > cnt ( 7 , 0 ) ; for ( int x = i , k = 0 ; k != l1 ; x /= 7 , ++ k ) cnt [ x % 7 ] ++ ; for ( int x = j , k = 0 ; k != l2 ; x /= 7 , ++ k ) cnt [ x % 7 ] ++ ; if ( * max_element ( cnt . begin ( ) , cnt . end ( ) ) <= 1 ) ans ++ ; } cout << ans << ' \n ' ; }
TAB0 create unsigned long longs n , k , ret with ret = 0 , create unsigned long long array a with size 100005 ; TAB0 create map ok from unsigned long long to unsigned long long ; TAB1 read n read k ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 sort elements from a to a + n ; TAB1 for i = 0 to n exclusive , set ok [ a [ i ] ] to 1 ; TAB1 for i = 0 to n exclusive ; TAB2 if ok [ a [ i ] ] is 1 ; TAB3 set ok [ a [ i ] ] to 0 ; TAB3 set ok [ a [ i ] * k ] to 0 ; TAB3 increment ret ; TAB1 print ret print newline ;	unsigned long long n , k , a [ 100005 ] , ret = 0 ; map < unsigned long long , unsigned long long > ok ; int main ( ) { cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) { ok [ a [ i ] ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ok [ a [ i ] ] == 1 ) { ok [ a [ i ] ] = 0 ; ok [ a [ i ] * k ] = 0 ; ret ++ ; } } cout << ret << endl ; }
TAB0 in function gcd taking int a , int b and returning int ; TAB1 if a < b swap a and b ; TAB1 if a is not a multiple of b ; TAB2 return gcd of b , a mod b ; TAB1 else ; TAB2 return b ; TAB1 a , b , c , d , e , f = int ; TAB1 read a then b then c then d then e then f ; TAB1 ok = int with ok = 0 ; TAB1 if d is 0 ; TAB2 set ok to 0 ; TAB1 else if b is 0 ; TAB2 if c is 0 ; TAB3 set ok to 1 ; TAB2 else ; TAB3 set ok to 0 ; TAB1 else if f is 0 ; TAB2 if a or c is 0 ; TAB3 set ok to 1 ; TAB2 else ; TAB3 set ok to 0 ; TAB1 else ; TAB2 if a or c or e is 0 ; TAB3 set ok to 1 ; TAB2 else ; TAB3 x = int with x = gcd of b , c ; TAB3 y = int with y = gcd of d , e ; TAB3 aa = int with aa = a * c / x * e / y ; TAB3 bb = int with bb = f * d / y * b / x ; TAB3 if bb > aa ; TAB4 set ok to 1 ; TAB3 else ; TAB4 set ok to 0 ; TAB1 if ok ; TAB2 print " Ron " ; TAB1 else ; TAB2 print " Hermione " ;	int gcd ( int a , int b ) { if ( a < b ) swap ( a , b ) ; if ( a % b ) return gcd ( b , a % b ) ; else return b ; } int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; int ok = 0 ; if ( d == 0 ) { ok = 0 ; } else if ( b == 0 ) { if ( c == 0 ) ok = 1 ; else ok = 0 ; } else if ( f == 0 ) { if ( a == 0 || c == 0 ) ok = 1 ; else ok = 0 ; } else { if ( a == 0 || c == 0 || e == 0 ) ok = 1 ; else { int x = gcd ( b , c ) ; int y = gcd ( d , e ) ; int aa = a * c / x * e / y ; int bb = f * d / y * b / x ; if ( bb > aa ) ok = 1 ; else ok = 0 ; } } if ( ok ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB1 create long long ints l1 , r1 , l2 , r2 , and k ; TAB1 read l1 , r1 , l2 , r2 , and k ; TAB1 make long long int in = max ( l1 , l2 ) ; TAB1 create long long out = min ( r1 , r2 ) ; TAB1 if in is greater than out ; TAB2 print 0 ; TAB1 else if k is less than or equal to out and k is greater than or equal to in ; TAB2 display ( out - in ) ; TAB1 else do ; TAB2 show ( out - in ) ;	int main ( ) { long long l1 , r1 , l2 , r2 , k ; cin >> l1 >> r1 >> l2 >> r2 >> k ; long long in = max ( l1 , l2 ) ; long long out = min ( r1 , r2 ) ; if ( in > out ) cout << 0 << endl ; else if ( k <= out and k >= in ) cout << ( out - in ) << endl ; else cout << ( out - in ) + 1 << endl ; return 0 ; }
TAB1 create long long ints i , j , k , l , t , n , and ans ; TAB1 read n and while it ' s truthy ; TAB2 if n is equal to 1 ; TAB3 set ans to 1 ; TAB2 else if n is equal to 2 ; TAB3 set ans to 2 ; TAB2 else if n is equal to 3 ; TAB3 set ans to 6 ; TAB2 else if n modulo 2 is 0 ; TAB3 if n modulo 3 is equal to 0 ; TAB4 set ans to ( n - 1 ) * ( n - 2 ) * ( n - 3 ; TAB3 else do ; TAB4 set ans to n * ( n - 1 ) * ( n - 3 ) ; TAB2 otherwise ; TAB3 set ans to n * ( n - 1 ) * ( n - 2 ) ; TAB2 print ans ;	int main ( ) { long long i , j , k , l , t , n , ans ; while ( cin >> n ) { if ( n == 1 ) ans = 1 ; else if ( n == 2 ) ans = 2 ; else if ( n == 3 ) ans = 6 ; else if ( n % 2 == 0 ) { if ( n % 3 == 0 ) ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; else ans = n * ( n - 1 ) * ( n - 3 ) ; } else ans = n * ( n - 1 ) * ( n - 2 ) ; cout << ans << endl ; } return 0 ; }
TAB0 len = 1005 ; TAB0 mod = 998244353 ; TAB0 seed = 131 ; TAB0 r , c = array of len int ; TAB0 dd = array of len by len int ; TAB0 num , n , m ; TAB0 flag = int ; TAB0 function solve1 ( no args , no return value ) ; TAB1 for i = 1 to n inclusive ; TAB2 minx = 10 ^ 9 ; TAB2 for j = 1 to m inclusive minx = min ( minx , dd [ i ] [ j ] ) ; TAB2 r [ i ] = minx ; TAB2 if r [ i ] is not 0 add minx to num ; TAB2 for j = 1 to m inclusive subtract minx from dd [ i ] [ j ] ; TAB1 for j = 1 to m inclusive ; TAB2 minx = 10 ^ 9 ; TAB2 for i = 1 to n inclusive minx = min ( minx , dd [ i ] [ j ] ) ; TAB2 c [ j ] = minx ; TAB2 if minx is not 0 add minx to num ; TAB2 for i = 1 to n inclusive ; TAB3 subtract minx from dd [ i ] [ j ] ; TAB3 if dd [ i ] [ j ] flag = 1 ; TAB0 function solve1 ( no args , no return value ) ; TAB1 for j = 1 to m inclusive ; TAB2 minx = 10 ^ 9 ; TAB2 for i = 1 to n inclusive minx = min ( minx , dd [ i ] [ j ] ) ; TAB2 c [ j ] = minx ; TAB2 if minx is not 0 add minx to num ; TAB2 for i = 1 to n inclusive subtract minx from dd [ i ] [ j ] ; TAB1 for i = 1 to n inclusive ; TAB2 minx = 10 ^ 9 ; TAB2 for j = 1 to m inclusive minx = min ( minx , dd [ i ] [ j ] ) ; TAB2 r [ i ] = minx ; TAB2 if r [ i ] is not 0 add minx to num ; TAB2 for j = 1 to m inclusive ; TAB3 subtract minx from dd [ i ] [ j ] ; TAB3 if dd [ i ] [ j ] flag = 1 ; TAB1 read n , m ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive read dd [ i ] [ j ] ; TAB1 if n < = m ; TAB2 solve1 ( ) ; TAB1 else ; TAB2 solve2 ( ) ; TAB1 if flag print - 1 and return 0 ; TAB1 print num ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 0 to r [ i ] exclusive print " row " , i ; TAB1 for i = 1 to m inclusive ; TAB2 for j = 0 to c [ i ] exclusive print " col " , i ;	const int len = 1e3 + 5 ; const long long mod = 998244353 ; const ulong long seed = 131 ; int r [ len ] , c [ len ] ; int dd [ len ] [ len ] ; int num , n , m ; int flag ; void solve1 ( ) { for ( int i = 1 ; i <= n ; ++ i ) { int minx = 1e9 ; for ( int j = 1 ; j <= m ; ++ j ) minx = min ( minx , dd [ i ] [ j ] ) ; r [ i ] = minx ; if ( r [ i ] != 0 ) num += minx ; for ( int j = 1 ; j <= m ; ++ j ) dd [ i ] [ j ] -= minx ; } for ( int j = 1 ; j <= m ; ++ j ) { int minx = 1e9 ; for ( int i = 1 ; i <= n ; ++ i ) minx = min ( minx , dd [ i ] [ j ] ) ; c [ j ] = minx ; if ( minx != 0 ) num += minx ; for ( int i = 1 ; i <= n ; ++ i ) { dd [ i ] [ j ] -= minx ; if ( dd [ i ] [ j ] ) flag = 1 ; } } } void solve2 ( ) { for ( int j = 1 ; j <= m ; ++ j ) { int minx = 1e9 ; for ( int i = 1 ; i <= n ; ++ i ) minx = min ( minx , dd [ i ] [ j ] ) ; c [ j ] = minx ; if ( minx != 0 ) num += minx ; for ( int i = 1 ; i <= n ; ++ i ) dd [ i ] [ j ] -= minx ; } for ( int i = 1 ; i <= n ; ++ i ) { int minx = 1e9 ; for ( int j = 1 ; j <= m ; ++ j ) minx = min ( minx , dd [ i ] [ j ] ) ; r [ i ] = minx ; if ( r [ i ] != 0 ) num += minx ; for ( int j = 1 ; j <= m ; ++ j ) { dd [ i ] [ j ] -= minx ; if ( dd [ i ] [ j ] ) flag = 1 ; } } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= m ; ++ j ) cin >> dd [ i ] [ j ] ; if ( n <= m ) solve1 ( ) ; else solve2 ( ) ; if ( flag ) return puts ( " -1 " ) , 0 ; cout << num << endl ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 0 ; j < r [ i ] ; ++ j ) cout << " row  " << i << endl ; } for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 0 ; j < c [ i ] ; ++ j ) cout << " col  " << i << endl ; }
TAB0 create long long integers x and y ; TAB0 declare exgcd taking in long long integers a and returning long longand b ; TAB1 if b is equal to 0 ; TAB2 set x to 1 ; TAB2 set y to 0 ; TAB2 return a ; TAB1 create long long d = exgcd ( b , a % b ) ; TAB1 create long long t = x ; TAB1 set x to y ; TAB1 set y to the result of t - a / b * y ; TAB1 return d ; TAB1 create long long integers m , h1 , al , x1 , y1 , h2 , a2 , x2 , y2 ; TAB1 create long long integers p1 , p2 , q1 , q2 ; TAB1 while cin > > m > > h1 > > a1 > > x1 > > y1 > > h2 > > a2 > > x2 > > y2 is truthy ; TAB2 set p1 , p2 , q1 , and q1 to 0 ; TAB2 for i = 1 to 2 * m ; TAB3 set h1 to ( h1 * x1 + y1 ) % m ; TAB3 if h1 is equal to a1 ; TAB4 if p1 is equal to 0 ; TAB5 set p1 to i ; TAB4 else if q1 is equal to 0 ; TAB5 set q1 to the result of i - p1 ; TAB5 break loop ; TAB2 for i = 1 to 2 * m ; TAB3 set h2 to the result of ( h2 * x2 + y2 ) % m ; TAB3 if h2 is equal to a2 ; TAB4 if p2 is equal to 0 ; TAB5 set p2 to i ; TAB4 else if q2 is equal to 0 ; TAB5 set q2 to the result of i - p2 ; TAB5 break loop ; TAB2 create long long d = exgcd ( q1 , - q2 ) ; TAB2 create long long c = p2 - p1 ; TAB2 if d is equal to 0 ; TAB3 print " - 1 " ; TAB3 continue to next loop iteration ; TAB2 if c modulo d is truthy ; TAB3 print " - 1 " ; TAB3 continue to next loop iteration ; TAB2 if d is less than 0 , set d to - d ; TAB2 if p1 is equal to 0 or p2 is equal to 0 ; TAB3 print " - 1 " ; TAB3 continue to next loop iteration ; TAB2 if q2 is equal to 0 and q1 is equal to 0 and p1 is not equal to p2 ; TAB3 print " - 1 " ; TAB3 continue to next loop iteration ; TAB2 if q2 is equal to 0 and p2 - p1 is less than 0 or q1 is equal to 0 and p1 - p2 is less than 0 ; TAB3 print " - 1 " ; TAB3 continue to next loop iteration ; TAB2 create long long k = c / d ; TAB2 if the return value of exgcd ( q1 , - q2 ) is less than 0 , set x to - x and set y to - y ; TAB2 set x to the result of x * k ; TAB2 set y to the result of y * k ; TAB2 if x is less than 0 or y is less than 0 ; TAB3 while 1 is truthy ; TAB4 set x to the result of x + q2 / d ; TAB4 set y to the result of y + q1 / d ; TAB4 if x is greater than or equal to 0 and y is greater than or equal to 0 , break loop ; TAB2 if x is greater than 0 and y is greater then 0 ; TAB3 while 1 is truthy ; TAB4 set x to the result of x - q2 / d ; TAB4 set y to the result of y - q1 / d ; TAB4 if x is less than 0 or y is less than 0 , break loop ; TAB3 set x to the result of x + q2 / d ; TAB3 set y to the result of y + q1 / d ; TAB2 create long long ans = x * q1 + p1 ; TAB2 print ans ;	long long x , y ; long long exgcd ( long long a , long long b ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long d = exgcd ( b , a % b ) ; long long t = x ; x = y ; y = t - a / b * y ; return d ; } int main ( ) { long long m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 ; long long p1 , p2 , q1 , q2 ; while ( cin >> m >> h1 >> a1 >> x1 >> y1 >> h2 >> a2 >> x2 >> y2 ) { p1 = p2 = q1 = q2 = 0 ; for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h1 = ( h1 * x1 + y1 ) % m ; if ( h1 == a1 ) { if ( p1 == 0 ) p1 = i ; else if ( q1 == 0 ) { q1 = i - p1 ; break ; } } } for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h2 = ( h2 * x2 + y2 ) % m ; if ( h2 == a2 ) { if ( p2 == 0 ) p2 = i ; else if ( q2 == 0 ) { q2 = i - p2 ; break ; } } } long long d = exgcd ( q1 , - q2 ) ; long long c = p2 - p1 ; if ( d == 0 ) { puts ( " -1 " ) ; continue ; } if ( c % d ) { puts ( " -1 " ) ; continue ; } if ( d < 0 ) d = - d ; if ( p1 == 0 || p2 == 0 ) { puts ( " -1 " ) ; continue ; } if ( q2 == 0 && q1 == 0 && p1 != p2 ) { puts ( " -1 " ) ; continue ; } if ( ( q2 == 0 && p2 - p1 < 0 ) || ( q1 == 0 && p1 - p2 < 0 ) ) { puts ( " -1 " ) ; continue ; } long long k = c / d ; if ( exgcd ( q1 , - q2 ) < 0 ) x = - x , y = - y ; x *= k ; y *= k ; if ( x < 0 || y < 0 ) { while ( 1 ) { x += q2 / d ; y += q1 / d ; if ( x >= 0 && y >= 0 ) break ; } } if ( x > 0 && y > 0 ) { while ( 1 ) { x -= q2 / d ; y -= q1 / d ; if ( x < 0 || y < 0 ) break ; } x += q2 / d ; y += q1 / d ; } long long ans = x * q1 + p1 ; cout << ans << endl ; } return 0 ; }
TAB0 declare long long MOD = 1000000009 ; TAB0 declare pw with long longs a , b as arguments , returning long long ; TAB1 if b is 0 , return 1 from function ; TAB1 if b is 1 , return a % MOD ; TAB1 if b % 2 ; TAB2 declare long long rs = result of run pw ( a , b - 1 ) ; TAB2 return ( rs * a ) % MOD from function ; TAB1 declare long long rs = result of run w with a , b / 2 as arguments ; TAB1 return ( rs * rs ) % MOD ; TAB0 declare long long vector sm ; TAB0 declare solve with long longs a , b as arguments , returning long long ; TAB1 if b is 0 , return 0 from function ; TAB1 for i = 0 to 35 exclusive ; TAB2 declare long long ba = ( 1LL bitshift left i ) bitwise and b ; TAB2 if ba is 0 , end current loop iteration ; TAB2 return ( sm [ i ] + result of run solve ( a , b - ( 1LL bitshift left i ) ) * result of run pw ( a , ( 1LL bitshift left i ) ) ) % MOD ; TAB1 declare long longs n , a , b , k ; TAB1 read n , a , b , k ; TAB1 declare string s ; TAB1 read s ; TAB1 declare long long X = 1 , y + 1 ; TAB1 for i = 0 to k exclusive ; TAB2 let X be X * b ; TAB2 let X be X % MOD ; TAB1 for i = 0 to k exclusive ; TAB2 let Y be Y * a ; TAB2 let Y be Y % MOD ; TAB1 let X be X * result of run pw ( Y , MOD - 2 ) ; TAB1 let X be X % MOD ; TAB1 add 1 to end of sm ; TAB1 for i = 0 to 40 exclusive ; TAB2 add ( back of sm + back of sm * result of run pw ( X , ( 1LL bitshift left i ) ) to end of sm ; TAB2 let back of sm be back of sm % MOD ; TAB1 declare long long st = result of run solve ( X , ( n + 1 ) / k ) ; TAB1 declare long long ans = 0 ; TAB1 for i = 0 to k exclusive ; TAB2 declare long long rs = ( result of run pw ( b , i ) * result of run pw ( a , n - 1 ) ) % MOD ; TAB2 if s [ i ] is ' - ' , let rs be rs * - 1 ; TAB2 let rs be rs * st ; TAB2 increment ans by rs ; TAB2 let ans be ans % MOD ; TAB1 if ans is less than 0 , increment ans by MOD ; TAB1 print ans and newline ;	long long MOD = 1000000009 ; long long pw ( long long a , long long b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a % MOD ; if ( b % 2 ) { long long rs = pw ( a , b - 1 ) ; return ( rs * a ) % MOD ; } long long rs = pw ( a , b / 2 ) ; return ( rs * rs ) % MOD ; } vector < long long > sm ; long long solve ( long long a , long long b ) { if ( b == 0 ) return 0 ; for ( long long i = 0 ; i < 35 ; i ++ ) { long long ba = ( 1LL << i ) & b ; if ( ba == 0 ) continue ; return ( sm [ i ] + solve ( a , b - ( 1LL << i ) ) * pw ( a , ( 1LL << i ) ) ) % MOD ; } } int main ( ) { long long n , a , b , k ; cin >> n >> a >> b >> k ; string s ; cin >> s ; long long X = 1 , Y = 1 ; for ( long long i = 0 ; i < k ; i ++ ) { X *= b ; X %= MOD ; } for ( long long i = 0 ; i < k ; i ++ ) { Y *= a ; Y %= MOD ; } X *= pw ( Y , MOD - 2 ) ; X %= MOD ; sm . push_back ( 1 ) ; for ( long long i = 0 ; i < 40 ; i ++ ) { sm . push_back ( sm . back ( ) + sm . back ( ) * pw ( X , ( 1LL << i ) ) ) ; sm . back ( ) %= MOD ; } long long st = solve ( X , ( n + 1 ) / k ) ; long long ans = 0 ; for ( long long i = 0 ; i < k ; i ++ ) { long long rs = ( pw ( b , i ) * pw ( a , n - i ) ) % MOD ; if ( s [ i ] == ' - ' ) rs *= - 1 ; rs *= st ; ans += rs ; ans %= MOD ; } if ( ans < 0 ) ans += MOD ; cout << ans << endl ; }
TAB0 a = integer array of size 500008 , n = integer ; TAB0 in function slove with arguments of integer x and integer y that returns an integer ; TAB1 k = integer = y - x + 1 ; TAB1 i = integer ; TAB1 if k is even ; TAB2 for i = x to x + k / 2 exclusive , then a [ i ] = a [ x ] ; TAB2 for i = x + k / 2 to y inclusive , then a [ i ] = a [ y ] ; TAB1 else ; TAB2 for i = x + 1 to y inclusive , then a [ i ] = a [ x ] ; TAB1 return ( k - 1 ) / 2 ; TAB1 ans , l , r = integer ; TAB1 i = integer ; TAB1 read n ; TAB1 for i = 1 to n inclusive , then read a [ i ] ; TAB1 ans = 0 ; TAB1 for i = 2 to n exclusive ; TAB2 if a [ i ] is not a [ i - 1 ] and a [ i ] is not a [ i + 1 ] ; TAB3 l = i - 1 ; TAB3 increase i by 1 ; TAB3 for current value of i to n exclusive ; TAB4 if a [ i ] is not a [ i - 1 ] and a [ i ] is not a [ i + 1 ] ; TAB5 continue ; TAB4 else ; TAB5 exit for loop ; TAB3 r = i ; TAB3 ans = greater value between ans and the result of calling l and r ; TAB3 l = 0 ; TAB3 r = 0 ; TAB1 print ans ; TAB1 for i = 1 to n exclusive , then print a [ i ] ; TAB1 print api [ ;	int a [ 500008 ] , n ; int slove ( int x , int y ) { int k = y - x + 1 ; int i ; if ( k % 2 == 0 ) { for ( i = x ; i < x + k / 2 ; i ++ ) { a [ i ] = a [ x ] ; } for ( i = x + k / 2 ; i <= y ; i ++ ) { a [ i ] = a [ y ] ; } } else { for ( i = x + 1 ; i <= y ; i ++ ) { a [ i ] = a [ x ] ; } } return ( k - 1 ) / 2 ; } int main ( ) { int ans , l , r ; int i ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } ans = 0 ; for ( i = 2 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] && a [ i ] != a [ i + 1 ] ) { l = i - 1 ; i ++ ; for ( ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] && a [ i ] != a [ i + 1 ] ) { continue ; } else { break ; } } r = i ; ans = max ( ans , slove ( l , r ) ) ; l = 0 ; r = 0 ; } } cout << ans << endl ; for ( i = 1 ; i < n ; i ++ ) { cout << a [ i ] << "   " ; } cout << a [ i ] << endl ; }
TAB0 create long long array arr with size 1000000 ; TAB0 create new set of integers ss ; TAB0 create new map from strings to integers mm ; TAB0 create an array of chars ch with 100000 elements ; TAB1 declare integer variables n , k and res with res = 0 ; TAB1 read input to n ; TAB1 for integer i = 0 to n exclusive ; TAB2 read k ; TAB2 if k = 0 , increment res ; TAB1 if n = 1 ; TAB2 if res is equal to 0 ; TAB3 increase res by one ; TAB2 else ; TAB3 decrement res ; TAB1 print " YES " if res = 1 or " NO " otherwise ;	long long arr [ 1000000 ] ; set < int > ss ; map < string , int > mm ; char ch [ 100000 ] ; int main ( ) { int n , k , res = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k ; if ( k == 0 ) res ++ ; } if ( n == 1 ) { if ( res == 0 ) ++ res ; else -- res ; } cout << ( res == 1 ? " YES " : " NO " ) << endl ; return 0 ; }
TAB1 create integer n ; TAB1 read n and loop further ; TAB2 declare integer arrays a with 101 and b with 100 elements , and an integer f = 0 ; TAB2 for i from 1 to n inclusive ; TAB3 read a [ i ] ; TAB3 if a [ i ] is less than 0 , increment f by one ; TAB2 if f < = 2 ; TAB3 print 1 and n ; TAB3 continue the loop ; TAB2 if f is odd ; TAB3 print f / 2 + 1 ; TAB2 else ; TAB3 print f / 2 ; TAB2 declare int t = 0 ; TAB2 declare int variable x = 1 ; TAB2 declare integer sum = 0 ; TAB2 loop i from 1 to n inclusive ; TAB3 if t = 2 and a [ i ] < 0 ; TAB4 print i - x and " " ; TAB4 add i - x to sum ; TAB4 change x to i ; TAB4 change t to 0 ; TAB4 decrease f by 2 ; TAB3 if a [ i ] is less than 0 , increment t by one ; TAB2 if sum is less than n , print n - sum ; TAB2 print new line ;	int main ( ) { int n ; while ( cin >> n ) { int a [ 101 ] , b [ 100 ] , f = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] < 0 ) f ++ ; } if ( f <= 2 ) { cout << 1 << endl << n << endl ; continue ; } if ( f % 2 ) cout << f / 2 + 1 << endl ; else cout << f / 2 << endl ; int t = 0 ; int x = 1 ; int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( t == 2 && a [ i ] < 0 ) { cout << i - x << "   " ; sum += ( i - x ) ; x = i ; t = 0 ; f -= 2 ; } if ( a [ i ] < 0 ) t ++ ; } if ( sum < n ) cout << n - sum ; cout << endl ; } return 0 ; }
TAB1 create long long integers n and i ; TAB1 read n ; TAB1 if n is less than or equal to 3 ; TAB2 print " NO \ n " ; TAB1 else do ; TAB2 print " YES \ n " ; TAB2 if n modulo 2 is 0 ; TAB3 print " 1 * 2 = 2 \ n2 * 3 = 6 \ n6 * 4 = 24 \ n " ; TAB3 for i = 5 to n , print i + 1 , " - " , i , and " = 1 \ n1 * 24 = 24 \ n " ; TAB2 otherwise ; TAB3 print " 2 - 1 = 1 \ n1 + 3 = 4 \ n4 * 5 = 20 \ n20 + 4 = 24 \ n " ; TAB3 for i = 6 to n , print i + 1 , " - " , i , and " = 1 \ n1 * 24 = 24 \ n " ;	int main ( ) { long long int n , i ; cin >> n ; if ( n <= 3 ) cout << " NO\n " ; else { cout << " YES\n " ; if ( n % 2 == 0 ) { cout << " 1 * 2 = 2\n2 * 3 = 6\n6 * 4 = 24\n " ; for ( i = 5 ; i <= n ; i += 2 ) cout << i + 1 << "  -  " << i << "  = 1\n1 * 24 = 24\n " ; } else { cout << " 2 - 1 = 1\n1 + 3 = 4\n4 * 5 = 20\n20 + 4 = 24\n " ; for ( i = 6 ; i <= n ; i += 2 ) cout << i + 1 << "  -  " << i << "  = 1\n1 * 24 = 24\n " ; } } return 0 ; }
TAB1 s , n , i , j , num1 , num2 , aux1 , aux2 = long long ; TAB1 read s , n ; TAB1 x = long long array of size n , y = long long array of size n ; TAB1 lose = boolean = false ; TAB1 for i = 0 to n exclusive , read x [ i ] , y [ i ] ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 for j = i + 1 to n exclusive ; TAB3 if x [ i ] > = x [ j ] ; TAB4 aux1 = x [ i ] ; TAB4 x [ i ] = x [ j ] ; TAB4 x [ j ] = aux1 ; TAB4 aux2 = y [ i ] ; TAB4 y [ i ] = y [ j ] ; TAB4 y [ j ] = aux2 ; TAB1 i = 0 ; TAB1 while i < n and lose is false ; TAB2 if s > x [ i ] ; TAB3 s = s + y [ i ] ; TAB2 else ; TAB3 lose = true ; TAB2 increase i by 1 ; TAB1 if lose is true ; TAB2 print NO ; TAB1 else ; TAB2 print YES ;	int main ( ) { long long s , n , i , j , num1 , num2 , aux1 , aux2 ; cin >> s >> n ; long long x [ n ] , y [ n ] ; bool lose = false ; for ( i = 0 ; i < n ; i ++ ) { cin >> x [ i ] >> y [ i ] ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( x [ i ] >= x [ j ] ) { aux1 = x [ i ] ; x [ i ] = x [ j ] ; x [ j ] = aux1 ; aux2 = y [ i ] ; y [ i ] = y [ j ] ; y [ j ] = aux2 ; } } } i = 0 ; while ( i < n && ! lose ) { if ( s > x [ i ] ) { s += y [ i ] ; } else { lose = true ; } i ++ ; } if ( lose ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 declare is_pal with string g as argument , returning boolean ; TAB1 declare integer q = size of g - 1 ; TAB1 declare integer w = 0 ; TAB1 while q is greater than or equal to w ; TAB2 if g [ w ] is not g [ q ] , return 0 from function ; TAB2 decrement q ; TAB2 increment w ; TAB1 return 1 from function ; TAB1 declare string g ; TAB1 read g ; TAB1 declare integer x ; TAB1 read x ; TAB1 declare integer w = 0 ; TAB1 declare boolean b = 0 ; TAB1 if size of g % x is not 0 ; TAB2 print " NO \ n " ; TAB1 else ; TAB2 while w is less than size of g ; TAB3 if result of run is_pal with ( substring of g from w to size of g / x ) as argument is false ; TAB4 let b be 1 ; TAB4 end loop ; TAB3 increment w by size of g / x ; TAB2 if not b ; TAB3 print " YES \ n " ; TAB2 else ; TAB3 print " NO \ n " ;	bool is_pal ( string g ) { int q = g . size ( ) - 1 ; int w = 0 ; while ( q >= w ) { if ( g [ w ] != g [ q ] ) return 0 ; q -- ; w ++ ; } return 1 ; } int main ( ) { string g ; cin >> g ; int x ; cin >> x ; int w = 0 ; bool b = 0 ; if ( g . size ( ) % x != 0 ) cout << " NO\n " ; else { while ( w < g . size ( ) ) { if ( ! is_pal ( g . substr ( w , g . size ( ) / x ) ) ) { b = 1 ; break ; } w += ( g . size ( ) / x ) ; } if ( ! b ) cout << " YES\n " ; else cout << " NO\n " ; } return 0 ; }
TAB1 a = string ; TAB1 read a ; TAB1 n = size of a ; TAB1 f , j = 0 ; TAB1 b = array of n char ; TAB1 if n is 1 ; TAB2 print 0 ; TAB1 else ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] is ' 0 ' and f is 0 ; TAB4 f = 1 ; TAB4 continue ; TAB3 b [ j ] = a [ i ] ; TAB3 increment j ; TAB2 if j is n ; TAB3 for i = 1 to j exclusive print b [ i ] ; TAB2 else ; TAB3 for i = 0 to j exclusive print b [ i ] ; TAB2 print newline ;	int main ( ) { string a ; cin >> a ; int n = a . size ( ) ; int f = 0 , j = 0 ; char b [ n ] ; if ( n == 1 ) cout << 0 << endl ; else { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ' 0 ' && f == 0 ) { f = 1 ; continue ; } b [ j ] = a [ i ] ; j ++ ; } if ( j == n ) { for ( int i = 1 ; i < j ; i ++ ) cout << b [ i ] ; } else { for ( int i = 0 ; i < j ; i ++ ) cout << b [ i ] ; } cout << endl ; } return 0 ; }
TAB0 declare is_vowel taking in char ch and returning bool ; TAB1 make string vowels = " AEIOUY " ; TAB1 return the result of vowels . find ( ch ) ! = string : : npos ; TAB1 make string s ; TAB1 read s ; TAB1 create int vector d ; TAB1 append 0 to d ; TAB1 for i = 0 to s . length ( ) exclusive ; TAB2 if is_vowel ( s [ i ] ) is truthy , append i + 1 to d ; TAB1 append s . length ( ) + 1 to d ; TAB1 create int mx = 0 ; TAB1 for i = 0 to d . size ( ) exclusive , set mx to max ( d . at ( i + 1 ) - d . at ( i ) , mx ) ; TAB1 show mx ;	bool is_vowel ( char ch ) { string vowels = " AEIOUY " ; return vowels . find ( ch ) != string :: npos ; } int main ( ) { string s ; cin >> s ; vector < int > d ; d . push_back ( 0 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( is_vowel ( s [ i ] ) ) d . push_back ( i + 1 ) ; d . push_back ( s . length ( ) + 1 ) ; int mx = 0 ; for ( int i = 0 ; i < d . size ( ) - 1 ; ++ i ) mx = max ( d . at ( i + 1 ) - d . at ( i ) , mx ) ; cout << mx << endl ; return 0 ; }
TAB1 create character array s with size 100005 , create character pointer p ; TAB1 create integer x ; TAB1 read s ; TAB1 if p is first occurrence of " AB " in s and first occurrence of " BA " in p + 2 ; TAB2 print " YES " print newline ; TAB1 else if p is first occurrence of " BA " in s and first occurrence of " AB " in p + 2 ; TAB2 print " YES " print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { char s [ 100005 ] , * p ; int x ; cin >> s ; if ( ( p = strstr ( s , " AB " ) ) && ( strstr ( p + 2 , " BA " ) ) ) { cout << " YES " << endl ; } else if ( ( p = strstr ( s , " BA " ) ) && ( strstr ( p + 2 , " AB " ) ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 declare int variables n , x1 , y1 , x2 and y2 ; TAB1 read n , x1 , y1 , x2 and y2 ; TAB1 create integer ans = 1e9 ; TAB1 if x1 = 0 or x1 = n or x2 = 0 or x2 = n ; TAB2 if x1 is equal to x2 , change ans to min of ans and abs ( y1 - y2 ) ; TAB2 assign min of ans and y1 + y2 + abs ( x1 - x2 ) to ans ; TAB2 change ans to min of ans and ( n - y1 ) + ( n - y2 ) + abs ( x1 - x2 ) ; TAB1 if y1 = 0 or y1 = n or y2 = 0 or y2 = n ; TAB2 if y1 is equal to y2 , change ans to min of ans and abs ( x1 - x2 ) ; TAB2 assign min of ans and x1 + x2 + abs ( y1 - y2 ) to ans ; TAB2 set ans to min of ans and ( n - x1 ) + ( n - x2 ) + abs ( y1 - y2 ) ; TAB1 print ans and " \ n " ;	int main ( ) { int n , x1 , y1 , x2 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; int ans = 1e9 ; if ( x1 == 0 || x1 == n || x2 == 0 || x2 == n ) { if ( x1 == x2 ) { ans = min ( ans , abs ( y1 - y2 ) ) ; } ans = min ( ans , y1 + y2 + abs ( x1 - x2 ) ) ; ans = min ( ans , ( n - y1 ) + ( n - y2 ) + abs ( x1 - x2 ) ) ; } if ( y1 == 0 || y1 == n || y2 == 0 || y2 == n ) { if ( y1 == y2 ) { ans = min ( ans , abs ( x1 - x2 ) ) ; } ans = min ( ans , x1 + x2 + abs ( y1 - y2 ) ) ; ans = min ( ans , ( n - x1 ) + ( n - x2 ) + abs ( y1 - y2 ) ) ; } cout << ans << " \n " ; return 0 ; }
TAB1 create long long ints n , m , mex , l , and r ; TAB1 read n and m ; TAB1 set mex to n ; TAB1 while m - - is truthy , read l and r and set mex to min of mex and r - 1 + 1 ; TAB1 print mex ; TAB1 for i = 0 to n exclusive , print i % mex and " \ n " [ i = = n - 1 ] ;	int main ( ) { long long n , m , mex , l , r ; cin >> n >> m ; mex = n ; while ( m -- ) cin >> l >> r , mex = min ( mex , r - l + 1 ) ; cout << mex << ' \n ' ; for ( long long i = 0 ; i < n ; i ++ ) cout << i % mex << "  \n " [ i == n - 1 ] ; }
TAB0 MAXN = const int with MAXN = 2e7 ; TAB0 prime = int array of size MAXN ; TAB0 vis = int array of size MAXN ; TAB0 a = int array of size MAXN ; TAB0 in function init ; TAB1 for i = 2 to MAXN ; TAB2 if not prime [ i ] increment prime [ 0 ] then set prime [ prime [ 0 ] ] to i ; TAB2 iterate j from 1 while j < = prime [ 0 ] and prime [ j ] < = MAXN / i ; TAB3 set prime [ prime [ j ] * i ] to 1 ; TAB3 if i is a multiple of prime [ j ] break ; TAB1 n = int ; TAB1 gcd = int ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read a [ i ] ; TAB2 if i is 1 ; TAB3 set gcd to a [ 1 ] ; TAB2 else ; TAB3 set gcd to __gcd of gcd , a [ i ] ; TAB1 Max = int with Max = 0 ; TAB1 call init ; TAB1 for i = 1 to n inclusive ; TAB2 set a [ i ] to a [ i ] / gcd ; TAB2 iterate j from 1 while j < = prime [ 0 ] and prime [ j ] * prime [ j ] < = a [ i ] ; TAB3 if a [ i ] is a multiple of prime [ j ] ; TAB4 loop while a [ i ] is a multiple of prime [ j ] set a [ i ] to a [ i ] / prime [ j ] ; TAB4 increment vis [ prime [ j ] ] ; TAB4 set Max ot max of Max , vis [ prime [ j ] ] ; TAB2 if a is not 1 ; TAB3 increment vis [ a [ i ] ] ; TAB3 set Max to max of Max , vis [ a [ i ] ] ; TAB1 if Max is 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print n - Max ;	const int MAXN = 2e7 ; int prime [ MAXN ] ; int vis [ MAXN ] ; int a [ MAXN ] ; void init ( ) { for ( int i = 2 ; i < MAXN ; i ++ ) { if ( ! prime [ i ] ) prime [ ++ prime [ 0 ] ] = i ; for ( int j = 1 ; j <= prime [ 0 ] && prime [ j ] <= MAXN / i ; j ++ ) { prime [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int main ( ) { int n ; int gcd ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; if ( i == 1 ) gcd = a [ 1 ] ; else gcd = __gcd ( gcd , a [ i ] ) ; } int Max = 0 ; init ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] /= gcd ; for ( int j = 1 ; j <= prime [ 0 ] && prime [ j ] * prime [ j ] <= a [ i ] ; j ++ ) { if ( a [ i ] % prime [ j ] == 0 ) { while ( a [ i ] % prime [ j ] == 0 ) { a [ i ] /= prime [ j ] ; } vis [ prime [ j ] ] ++ ; Max = max ( Max , vis [ prime [ j ] ] ) ; } } if ( a [ i ] != 1 ) { vis [ a [ i ] ] ++ ; Max = max ( Max , vis [ a [ i ] ] ) ; } } if ( Max == 0 ) cout << - 1 << endl ; else cout << n - Max << endl ; }
TAB1 create int n ; TAB1 create vector of integers button ; TAB1 declare int variable i = 0 ; TAB1 declare string variable result ; TAB1 read n ; TAB1 loop while i < n , incrementing i ; TAB2 declare int variable tmp ; TAB2 read tmp ; TAB2 push tmp into button ; TAB1 declare integer variable cntNotFastened = 0 ; TAB1 if n = 1 ; TAB2 set result to " YES " if button [ 0 ] is 1 , else set to " NO " ; TAB1 else ; TAB2 for i from 0 to n exclusive ; TAB3 if button [ i ] is equal to 0 , increment cntNotFastened ; TAB3 if cntNotFastened is greater than 1 ; TAB4 set result to " NO " ; TAB4 break the loop ; TAB2 if cntNotFastened = 1 ; TAB3 set result to " YES " ; TAB2 else ; TAB3 assign " NO " to result ; TAB1 print result ;	int main ( ) { int n ; vector < int > button ; int i = 0 ; string result ; cin >> n ; for ( ; i < n ; i ++ ) { int tmp ; cin >> tmp ; button . push_back ( tmp ) ; } int cntNotFastened = 0 ; if ( n == 1 ) { result = ( button [ 0 ] == 1 ) ? " YES " : " NO " ; } else { for ( i = 0 ; i < n ; i ++ ) { if ( button [ i ] == 0 ) cntNotFastened ++ ; if ( cntNotFastened > 1 ) { result = " NO " ; break ; } } if ( cntNotFastened == 1 ) result = " YES " ; else result = " NO " ; } cout << result << endl ; }
TAB0 declare integers x and y ; TAB0 create boolean arrays xasphalt and yasphalt with size 69 ; TAB0 days and wrkdsz are integers with days = 1 , workdays is an int array with size 6969 ; TAB1 declare integer variable a ; TAB1 read a ; TAB1 for A = 0 to a squared exclusive ; TAB2 read input to x and y ; TAB2 if xasphalt [ x ] and yasphalt [ y ] are false ; TAB3 assign true to xasphalt [ x ] ; TAB3 assign true to yasphalt [ y ] ; TAB3 assign days to workdays [ wrkdsz ] ; TAB3 increment wrkdsz ; TAB2 increment days ; TAB1 for A from 0 to wrkdsz exclusive ; TAB2 if A is equal to wrkdsz - 1 ; TAB3 print workdays [ A ] and " \ n " ; TAB2 else ; TAB3 print workdays [ A ] and " " ;	int x , y ; bool xasphalt [ 69 ] , yasphalt [ 69 ] ; int days = 1 , workdays [ 6969 ] , wrkdsz ; int main ( ) { int a ; cin >> a ; for ( int A = 0 ; A < a * a ; A ++ ) { cin >> x >> y ; if ( xasphalt [ x ] == false && yasphalt [ y ] == false ) { xasphalt [ x ] = true ; yasphalt [ y ] = true ; workdays [ wrkdsz ] = days ; wrkdsz ++ ; } days ++ ; } for ( int A = 0 ; A < wrkdsz ; A ++ ) { if ( A == wrkdsz - 1 ) cout << workdays [ A ] << " \n " ; else cout << workdays [ A ] << "   " ; } }
TAB1 assign elements of last to 8 , 4 , 2 , 6 ; TAB1 create int n ; TAB1 read n ; TAB1 if n = 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print last [ ( n - 1 ) mod 4 ] ;	int main ( ) { int last [ ] = { 8 , 4 , 2 , 6 } ; int n ; cin >> n ; if ( n == 0 ) cout << 1 << endl ; else cout << last [ ( n - 1 ) % 4 ] << endl ; return 0 ; }
TAB0 let pi = acos ( - 1 ) be a const double ; TAB0 let inf be a const int = 1000 * 1000 * 100 ; TAB0 let size be an int constant = 10000 ; TAB0 let mas be an int array of length size ; TAB0 bon = int array of length size ; TAB0 let tp , lb , rb , val be int arrays all of length size ; TAB1 n , m = int ; TAB1 read n and m ; TAB1 for i = 0 to n exclusive then set mas [ i ] to inf ; TAB1 for i = 0 to m exclusive ; TAB2 read tp [ i ] , lb [ i ] , rb [ i ] , val [ i ] ; TAB2 decrement lb at i ; TAB2 decrement rb at i ; TAB1 for i = 0 to m exclusive ; TAB2 if tp [ i ] = 1 ; TAB3 for j = lb at i to rb [ i ] inclusive , increment bon [ j ] by val [ i ] ; TAB2 else ; TAB3 fkr j = lb [ i ] to rb [ i ] inclusive , set mas [ j ] to the min between mas [ j ] and val [ i ] - bon [ j ] ; TAB1 fir i = 0 to n exclusive then set bon [ i ] = 0 ; TAB1 let flag be a bool = true ; TAB1 for i = 0 to m exclusive ; TAB2 if tp at i = 1 then ; TAB3 for j = lb [ i ] to rb [ i ] then increment bon [ j ] by val [ i ] ; TAB2 else ; TAB3 let mx = int = - inf ; TAB3 for j = lb [ i ] to rb [ i ] inclusive then set mx to the max between mx and mas [ j ] + bon [ j ] ; TAB3 if mx isn ' t val [ i ] then set flag to false ; TAB1 if flag ; TAB2 print YES ; TAB2 for i = 0 to n exclusive then print ams at i and new line [ i = = n - 1 ] ; TAB1 else ; TAB2 print NO ;	const double pi = acos ( - 1.0 ) ; const int inf = 1000 * 1000 * 100 ; const int size = 10 * 1000 ; int mas [ size ] ; int bon [ size ] ; int tp [ size ] , lb [ size ] , rb [ size ] , val [ size ] ; int main ( ) { int n , m ; cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) mas [ i ] = inf ; for ( int i = 0 ; i < m ; i ++ ) { cin >> tp [ i ] >> lb [ i ] >> rb [ i ] >> val [ i ] ; lb [ i ] -- ; rb [ i ] -- ; } for ( int i = 0 ; i < m ; i ++ ) { if ( tp [ i ] == 1 ) { for ( int j = lb [ i ] ; j <= rb [ i ] ; j ++ ) bon [ j ] += val [ i ] ; } else { for ( int j = lb [ i ] ; j <= rb [ i ] ; j ++ ) mas [ j ] = min ( mas [ j ] , val [ i ] - bon [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) bon [ i ] = 0 ; bool flag = true ; for ( int i = 0 ; i < m ; i ++ ) { if ( tp [ i ] == 1 ) { for ( int j = lb [ i ] ; j <= rb [ i ] ; j ++ ) bon [ j ] += val [ i ] ; } else { int mx = - inf ; for ( int j = lb [ i ] ; j <= rb [ i ] ; j ++ ) mx = max ( mx , mas [ j ] + bon [ j ] ) ; if ( mx != val [ i ] ) flag = false ; } } if ( flag ) { cout << " YES " << endl ; for ( int i = 0 ; i < n ; i ++ ) cout << mas [ i ] << "  \n " [ i == n - 1 ] ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 MAXN = constant int , MAXN = 200005 ; TAB1 N , M , K , L , ans = long long ; TAB1 read N , M , K , L ; TAB1 let ans = ( K + L + M - 1 ) / M ; TAB1 if K + L < = M * ans AND M * ans < = N ) ; TAB2 print ans ; TAB1 else ; TAB2 print - 1 ;	const int MAXN = 200005 ; int main ( ) { long long N , M , K , L , ans ; cin >> N >> M >> K >> L ; ans = ( K + L + M - 1 ) / M ; if ( K + L <= M * ans && M * ans <= N ) cout << ans << endl ; else cout << - 1 << endl ; return 0 ; }
TAB0 declare mult taking in long long ints a , b , and p = 1000000007 and returning long long ; TAB1 return the result of ( ( a % p ) * ( b % p ) ) % p ; TAB0 declare add taking in long long ints a , b , and p = 1000000007 and returning long long ; TAB1 return ( a % p + b % p ) % p ; TAB0 declare fpow taking in long long ints n , k , and p = 1000000007 and returning long long ; TAB1 create long long int r = 1 ; TAB1 loop while k is truthy ; TAB2 if k & 1 is truthy , set r to r * n % p ; TAB2 set n to n * n % p ; TAB1 return r ; TAB0 declare inv taking in long long ints a and p = 1000000007 and returning long long ; TAB1 return fpow ( a , p - 2 , p ) ; TAB0 declare inv_euclid taking in long long ints a and m = 1000000007 and returning long long integer ; TAB1 make long long m0 = m ; TAB1 create long long ints y = 0 and x = 1 ; TAB1 if m is equal to 1 , return 0 ; TAB1 while a is greater than 1 ; TAB2 make long long int q = a / m ; TAB2 make long long t = m ; TAB2 set m to a % m and a to t ; TAB2 set t to y ; TAB2 set y to x - q * y ; TAB2 set x to t ; TAB1 if x is less than 0 , set x to x + m0 ; TAB1 return x ; TAB0 create long long array spff of size 1000003 ; TAB0 declare spf ; TAB1 set spff [ 0 ] to 1 ; TAB1 set spff [ 1 ] to 1 ; TAB1 for i = 2 to 1000003 ; TAB2 if i % 2 is 0 ; TAB3 set spff [ i ] to 2 ; TAB2 otherwise ; TAB3 set spff [ i ] to 1 ; TAB1 for i = 3 while i * i is less than or equal to 1000003 ; TAB2 if spff [ i ] is equal to i ; TAB3 for j = i * i to 1000003 by increasing by i , set spff [ j ] to i ; TAB1 call spf ( ) ; TAB1 make long long n ; TAB1 read n ; TAB1 for i = 1 , loop indefinitely ; TAB2 if spff [ n * i + 1 ] is not equal to n * i + 1 ; TAB3 display i ;	long long mult ( long long a , long long b , long long p = 1000000007 ) { return ( ( a % p ) * ( b % p ) ) % p ; } long long add ( long long a , long long b , long long p = 1000000007 ) { return ( a % p + b % p ) % p ; } long long fpow ( long long n , long long k , long long p = 1000000007 ) { long long r = 1 ; for ( ; k ; k >>= 1 ) { if ( k & 1 ) r = r * n % p ; n = n * n % p ; } return r ; } long long inv ( long long a , long long p = 1000000007 ) { return fpow ( a , p - 2 , p ) ; } long long inv_euclid ( long long a , long long m = 1000000007 ) { long long m0 = m ; long long y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { long long q = a / m ; long long t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } long long spff [ 1000003 ] ; void spf ( ) { spff [ 0 ] = 1 ; spff [ 1 ] = 1 ; for ( long long i = 2 ; i < 1000003 ; i ++ ) { if ( i % 2 == 0 ) { spff [ i ] = 2 ; } else spff [ i ] = i ; } for ( long long i = 3 ; i * i <= 1000003 ; i ++ ) { if ( spff [ i ] == i ) { for ( long long j = i * i ; j <= 1000003 ; j += i ) { spff [ j ] = i ; } } } } int main ( ) { spf ( ) ; long long n ; cin >> n ; for ( long long i = 1 ; ; i ++ ) { if ( spff [ n * i + 1 ] != n * i + 1 ) { cout << i << " \n " ; return 0 ; } } }
TAB0 create integers b1 , b2 , b3 , emm1 , emm2 and integer array lk of size 10 within an array of size 10 ; TAB0 create integer array a of size 8 ; TAB0 create string key - type integer map m ; TAB0 declare js taking in integers x , y , and z and returning integer ; TAB1 set x to b1 / x ; TAB1 set y to b2 / y ; TAB1 set z to b3 / z ; TAB1 set emm1 = the max of abs ( x - y ) , max ( abs ( y - z ) , abs ( x - z ) ) and return emm1 ; TAB0 declare haogan taking in integers x , y , and z and returning integer ; TAB1 create integer ss = 0 ; TAB1 for i = 1 to x inclusive ; TAB2 for j = 1 to x inclusive ; TAB3 if lk [ a [ i ] [ a [ j ] ] is truthy , increment ss ; TAB1 for i = x + 1 to x + y inclusive ; TAB2 for j = x + 1 to x + y inclusive ; TAB3 if lk [ a [ i ] ] [ a [ j ] ] is truthy , increment ss ; TAB1 for i = x + y + 1 to 7 inclusive ; TAB2 for j = x + y + 1 to 7 inclusive ; TAB3 if lk [ a [ i ] ] [ a [ j ] ] is truthy , increment ss ; TAB1 set emm2 to ss and return emm2 ; TAB1 set m [ " Anka " ] to 1 ; TAB1 set m [ " Chapay " ] to 2 ; TAB1 set m [ " Cleo " ] to 3 ; TAB1 set m [ " Troll " ] to 4 ; TAB1 set m [ " Dracul " ] to 5 ; TAB1 set m [ " Snowy " ] to 6 ; TAB1 set m [ " Hexadecimal " ] to 7 ; TAB1 create integer n ; TAB1 read n ; TAB1 while n - - is truthy ; TAB2 create strings s1 , s , and s2 ; TAB2 read s1 , s , and s2 ; TAB2 set lk [ m [ s1 ] ] [ m [ s2 ] ] to 1 ; TAB1 create integers ans1 = 1e9 and ans2 = - 1e9 ; TAB1 read b1 , b2 , and b3 ; TAB1 if b1 is less than b2 , swap the values of b1 and b2 ; TAB1 if b2 is less than b3 , swap the values of b2 and b3 ; TAB1 if b1 is less than b2 , swap the values of b1 and b2 ; TAB1 for i = 1 to 7 inclusive , set a [ i ] to i ; TAB1 do ; TAB2 if the return value of js ( 4 , 2 , 1 ) is equal to ans1 and the return value of haogan ( 4 , 2 , 1 ) is greater than ans2 , set ans2 to emm2 ; TAB2 if emm1 is less than ans1 ; TAB3 set ans1 to emm1 ; TAB3 set ans2 to the return value of haogan ( 4 , 2 , 1 ) ; TAB2 if the return value of js ( 3 , 3 , 1 ) is equal to ans1 and the return value of haogan ( 3 , 3 , 1 ) is greater than ans2 , set ans2 to emm2 ; TAB2 if emm1 is less than ans1 ; TAB3 set ans1 to emm1 ; TAB3 set ans2 to the return value of haogan ( 3 , 3 , 1 ) ; TAB2 if the return value of js ( 3 , 2 , 2 ) is equal to ans1 and the return value of haogan ( 3 , 2 , 2 ) is greater than ans2 , set ans2 to emm2 ; TAB2 if emm1 is less than ans1 ; TAB3 set ans1 to emm1 ; TAB3 set ans2 to the return value of haogan ( 3 , 2 , 2 ) ; TAB2 if the return value of js ( 5 , 1 , 1 ) is equal to ans1 and the return value of haogan ( 5 , 1 , 1 ) is greater than ans2 , set ans2 to emm2 ; TAB2 if emm1 is less than ans1 ; TAB3 set ans1 to emm1 ; TAB3 set ans2 to haogan ( 5 , 1 , 1 ) ; TAB1 while the return value of next_permutation ( a + 1 , a + 7 + 1 ) is truthy ; TAB1 print ans1 , ' ' , and ans2 ;	int b1 , b2 , b3 , emm1 , emm2 , lk [ 10 ] [ 10 ] ; int a [ 8 ] ; map < string , int > m ; int js ( int x , int y , int z ) { x = b1 / x ; y = b2 / y ; z = b3 / z ; return emm1 = max ( abs ( x - y ) , max ( abs ( y - z ) , abs ( x - z ) ) ) ; } int haogan ( int x , int y , int z ) { int ss = 0 ; for ( int i = 1 ; i <= x ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( lk [ a [ i ] ] [ a [ j ] ] ) ss ++ ; for ( int i = x + 1 ; i <= x + y ; i ++ ) for ( int j = x + 1 ; j <= x + y ; j ++ ) if ( lk [ a [ i ] ] [ a [ j ] ] ) ss ++ ; for ( int i = x + y + 1 ; i <= 7 ; i ++ ) for ( int j = x + y + 1 ; j <= 7 ; j ++ ) if ( lk [ a [ i ] ] [ a [ j ] ] ) ss ++ ; return emm2 = ss ; } int main ( ) { m [ " Anka " ] = 1 ; m [ " Chapay " ] = 2 ; m [ " Cleo " ] = 3 ; m [ " Troll " ] = 4 ; m [ " Dracul " ] = 5 ; m [ " Snowy " ] = 6 ; m [ " Hexadecimal " ] = 7 ; int n ; cin >> n ; while ( n -- ) { string s1 , s , s2 ; cin >> s1 >> s >> s2 ; lk [ m [ s1 ] ] [ m [ s2 ] ] = 1 ; } int ans1 = 1e9 , ans2 = - 1e9 ; cin >> b1 >> b2 >> b3 ; if ( b1 < b2 ) swap ( b1 , b2 ) ; if ( b2 < b3 ) swap ( b2 , b3 ) ; if ( b1 < b2 ) swap ( b1 , b2 ) ; for ( int i = 1 ; i <= 7 ; i ++ ) a [ i ] = i ; do { if ( ( js ( 4 , 2 , 1 ) == ans1 ) && ( haogan ( 4 , 2 , 1 ) > ans2 ) ) { ans2 = emm2 ; } if ( emm1 < ans1 ) { ans1 = emm1 ; ans2 = haogan ( 4 , 2 , 1 ) ; } if ( ( js ( 3 , 3 , 1 ) == ans1 ) && ( haogan ( 3 , 3 , 1 ) > ans2 ) ) { ans2 = emm2 ; } if ( emm1 < ans1 ) { ans1 = emm1 ; ans2 = haogan ( 3 , 3 , 1 ) ; } if ( ( js ( 3 , 2 , 2 ) == ans1 ) && ( haogan ( 3 , 2 , 2 ) > ans2 ) ) { ans2 = emm2 ; } if ( emm1 < ans1 ) { ans1 = emm1 ; ans2 = haogan ( 3 , 2 , 2 ) ; } if ( ( js ( 5 , 1 , 1 ) == ans1 ) && ( haogan ( 5 , 1 , 1 ) > ans2 ) ) { ans2 = emm2 ; } if ( emm1 < ans1 ) { ans1 = emm1 ; ans2 = haogan ( 5 , 1 , 1 ) ; } } while ( next_permutation ( a + 1 , a + 7 + 1 ) ) ; cout << ans1 << '   ' << ans2 << endl ; }
TAB0 INF = 0x3f3f3f3f ; TAB0 create char s [ 10 ] [ 10 ] ; TAB1 create int i , j , k ; TAB1 create int n , m , cou , set cou to 1 ; TAB1 read n ; TAB1 while decrement n ; TAB2 cou = 1 ; TAB2 set x , y , x1 , y1 to 0 ; TAB2 for i = 0 to 8 exclusive ; TAB3 for j = 0 to 8 exclusive ; TAB4 read s [ i ] [ j ] ; TAB4 if s [ i ] [ j ] = K and cou = 1 ; TAB5 increment cou , set x to i and y to j ; TAB4 else if s [ i ] [ j ] = K and cou = 2 ; TAB5 increment cou , set x1 to i and y1 to j ; TAB2 if ( x1 - x ) % 4 = 0 and ( y1 - y ) % 4 = 0 ; TAB3 print YES ; TAB2 else ; TAB3 print NO ;	const int INF = 0x3f3f3f3f ; char s [ 10 ] [ 10 ] ; int main ( ) { int i , j , k ; int n , m , cou = 1 ; cin >> n ; while ( n -- ) { cou = 1 ; int x = 0 , y = 0 , x1 = 0 , y1 = 0 ; for ( i = 0 ; i < 8 ; i ++ ) for ( j = 0 ; j < 8 ; j ++ ) { cin >> s [ i ] [ j ] ; if ( s [ i ] [ j ] == ' K ' && cou == 1 ) cou ++ , x = i , y = j ; else if ( s [ i ] [ j ] == ' K ' && cou == 2 ) cou ++ , x1 = i , y1 = j ; } if ( ( x1 - x ) % 4 == 0 && ( y1 - y ) % 4 == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB0 inf = constant integer = 0x3f3f3f3f ; TAB0 maxn = constant integer = 110 ; TAB0 in function max with arguments of integer a and integer b that returns an integer ; TAB1 return a if a > b else return b ; TAB0 in function min with arguments of integer a and integer b that returns an integer ; TAB1 return n if a > b else return a ; TAB0 a = integer array of size maxn ; TAB1 i , n = integer ; TAB1 while n can be read as a valid integer ; TAB2 for i = 0 to n exclusive , then read a [ i ] ; TAB2 l = integer ; TAB2 maxi = integer = 1 ; TAB2 for l = 0 to n - 1 exclusive ; TAB3 pos = integer = l ; TAB3 while l < n - 1 and a [ l ] + 1 is a [ l + 1 ] ; TAB3 if l - pos + 1 > maxi , then maxi = l - pos + 1 ; TAB2 cnt1 = integer = 1 ; TAB2 if a [ 0 ] is 1 ; TAB3 for i = 0 to maxi - 1 exclusive ; TAB4 if a [ i ] + 1 is not a [ i + 1 ] ; TAB5 exit for loop ; TAB4 else ; TAB5 increase cnt1 by 1 ; TAB2 cnt2 = integer = 1 ; TAB2 if a [ n - 1 ] is 1000 ; TAB3 for i = 0 to maxi - 1 exclusive ; TAB4 if a [ n - 1 - i ] - 1 is not a [ n - 1 - i - 1 ] ; TAB5 exit for loop ; TAB4 else ; TAB5 increase cnt2 by 1 ; TAB2 if cnt1 is maxi or cnt2 is maxi ; TAB3 print maxi - 1 ; TAB2 else ; TAB3 print maxi - 2 ;	const int inf = 0x3f3f3f3f ; const int maxn = 110 ; int max ( int a , int b ) { return a > b ? a : b ; } int min ( int a , int b ) { return a > b ? b : a ; } int a [ maxn ] ; int main ( ) { int i , n ; while ( cin >> n ) { for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int l ; int maxi = 1 ; for ( l = 0 ; l < n - 1 ; l ++ ) { int pos = l ; while ( l < n - 1 && a [ l ] + 1 == a [ l + 1 ] ) { l ++ ; } if ( l - pos + 1 > maxi ) { maxi = l - pos + 1 ; } } int cnt1 = 1 ; if ( a [ 0 ] == 1 ) { for ( i = 0 ; i < maxi - 1 ; i ++ ) { if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { break ; } else cnt1 ++ ; } } int cnt2 = 1 ; if ( a [ n - 1 ] == 1000 ) { for ( i = 0 ; i < maxi - 1 ; i ++ ) { if ( ( a [ n - 1 - i ] - 1 ) != a [ n - 1 - i - 1 ] ) { break ; } else cnt2 ++ ; } } if ( cnt1 == maxi || cnt2 == maxi ) { cout << maxi - 1 << endl ; } else cout << maxi - 2 << endl ; } return 0 ; }
TAB0 create const int mod = 1e9 + 7 ; TAB0 create integer array dp of size 5001 with array of size 5001 ; TAB1 make strings s and t ; TAB1 read s ; TAB1 read t ; TAB1 for i = s . size ( ) - 1 to 0 ; TAB2 for j = t . size ( ) - 1 to 0 , set dp [ i ] [ j ] to ( dp [ i ] [ j + 1 ] + ( s [ i ] = = t [ j ] ? 1 + dp [ i + 1 ] [ j + 1 ] : 0 ) ) % mod ; TAB1 make integer ret = 0 ; TAB1 for i = 0 to s . size ( ) exclusive , set ret to ( ret + dp [ i ] [ 0 ] ) % mod ; TAB1 display ret ;	const int mod = 1e9 + 7 ; int dp [ 5001 ] [ 5001 ] ; int main ( ) { string s , t ; cin >> s ; cin >> t ; for ( int i = s . size ( ) - 1 ; i >= 0 ; -- i ) for ( int j = t . size ( ) - 1 ; j >= 0 ; -- j ) dp [ i ] [ j ] = ( dp [ i ] [ j + 1 ] + ( s [ i ] == t [ j ] ? 1 + dp [ i + 1 ] [ j + 1 ] : 0 ) ) % mod ; int ret = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) ret = ( ret + dp [ i ] [ 0 ] ) % mod ; cout << ret << endl ; return 0 ; }
TAB0 x = long long with x = 0 ; TAB0 in function dfs taking a pointer to an int vector edges , an int a and an int array v ; TAB1 increment x ; TAB1 set v [ a ] to 1 ; TAB1 ans = long long with ans = size of edges [ a ] ; TAB1 for i = 0 to size of edges [ a ] ; TAB2 if v [ edges [ a ] [ i ] ] is 0 then call dfs on edges , edges [ a ] [ i ] and v ; TAB1 n , m = int ; TAB1 ans = long long with ans = 0 ; TAB1 read n then m ; TAB1 edges = int vector array of size n ; TAB1 for i = 0 to m ; TAB2 a , b = int ; TAB2 read a then b ; TAB2 append b - 1 to edges [ a - 1 ] ; TAB2 append a - 1 to edges [ b - 1 ] ; TAB1 v = int array of size n with all values set to 0 ; TAB1 for i = 0 to n ; TAB2 if v [ i ] is 0 ; TAB3 set x to 0 ; TAB3 call dfs on edges , i and v ; TAB3 add x * ( x - 1 ) / 2 to ans ; TAB1 if ans is m ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	long long x = 0 ; void dfs ( vector < int > * edges , int a , int v [ ] ) { x ++ ; v [ a ] = 1 ; long long ans = edges [ a ] . size ( ) ; for ( int i = 0 ; i < edges [ a ] . size ( ) ; i ++ ) if ( ! v [ edges [ a ] [ i ] ] ) dfs ( edges , edges [ a ] [ i ] , v ) ; } int main ( ) { int n , m ; long long ans = 0 ; cin >> n >> m ; vector < int > edges [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int a , b ; cin >> a >> b ; edges [ a - 1 ] . push_back ( b - 1 ) ; edges [ b - 1 ] . push_back ( a - 1 ) ; } int v [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) if ( ! v [ i ] ) { x = 0 ; dfs ( edges , i , v ) ; ans += x * ( x - 1 ) / 2 ; } if ( ans == m ) cout << " YES\n " ; else cout << " NO\n " ; return 0 ; }
TAB0 debug = const bool with debug = 1 ; TAB0 in the function solve that takes string s , t and returns integer ; TAB1 n = const int n = ( int ) s . size ( ) , m = ( int ) t . size ( ) ; TAB1 s = $ + s ; TAB1 t = ^ + t ; TAB1 equal , sdiag = static integer array of size [ 2048 ] [ 2048 ] ; TAB1 fill reference equal [ 0 ] [ 0 ] , reference equal [ 0 ] [ 0 ] + 2048 * 2048 , 0 ; TAB1 fill reference sdiag [ 0 ] [ 0 ] , reference sdiag [ 0 ] [ 0 ] + 2048 * 2048 , 0 ; TAB1 for i = 1 to n ; TAB2 for j = 1 to m , equal [ i ] [ j ] = ( s [ i ] is t [ j ] ) ; TAB1 for i = 1 to n ; TAB2 for j = 1 to m , sdiag [ i + 1 ] [ j + 1 ] = equal [ i ] [ j ] + sdiag [ i ] [ j ] ; TAB1 answ = integer with answ = m ; TAB1 for i = 1 to n ; TAB2 for j = 1 to m ; TAB3 len = integer with len = min ( n - i + 1 , m - j + 1 ) ; TAB3 nOp = integer with nOp = m - ( sdiag [ i + len ] [ j + len ] - sdiag [ i ] [ j ] ) ; TAB3 answ = min of answ and nOp ; TAB1 return answ ; TAB1 s , t = string ; TAB1 while ( read s , t ) , print solve ( s , t ) ;	const bool debug = 1 ; int solve ( string s , string t ) { const int n = ( int ) s . size ( ) , m = ( int ) t . size ( ) ; s = " $ " + s ; t = " ^ " + t ; static int equal [ 2048 ] [ 2048 ] , sdiag [ 2048 ] [ 2048 ] ; fill ( & equal [ 0 ] [ 0 ] , & equal [ 0 ] [ 0 ] + 2048 * 2048 , 0 ) ; fill ( & sdiag [ 0 ] [ 0 ] , & sdiag [ 0 ] [ 0 ] + 2048 * 2048 , 0 ) ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { equal [ i ] [ j ] = ( s [ i ] == t [ j ] ) ; } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { sdiag [ i + 1 ] [ j + 1 ] = equal [ i ] [ j ] + sdiag [ i ] [ j ] ; } } int answ = m ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { int len = min ( n - i + 1 , m - j + 1 ) ; int nOp = m - ( sdiag [ i + len ] [ j + len ] - sdiag [ i ] [ j ] ) ; answ = min ( answ , nOp ) ; } } return answ ; } int main ( ) { string s , t ; while ( cin >> s >> t ) { cout << solve ( s , t ) << endl ; } return 0 ; }
TAB0 num = integer array of size 200 ; TAB0 ord = integer array of size 200 ; TAB0 cnt = integer with cnt = 0 ; TAB1 n , k = integers ; TAB1 read n , k ; TAB1 for i = 0 to n exclusive ; TAB2 tmp = int ; TAB2 flag = integer with flag = 1 ; TAB2 read tmp ; TAB2 for j = 0 to cnt exclusive ; TAB3 if ( num [ j ] is not tmp ) ; TAB4 flag = 1 ; TAB3 else ; TAB4 flag = 0 ; TAB4 break loop ; TAB2 if ( flag is 1 ) ; TAB3 num [ cnt ] = tmp ; TAB3 ord [ cnt ] = i ; TAB3 increment cnt ; TAB1 if ( cnt < k ) ; TAB2 print NO ; TAB1 else ; TAB2 print YES ; TAB2 for p = 0 to k - 1 exclusive , print ord [ p ] + 1 ; TAB2 print ord [ k - 1 ] + 1 ;	int num [ 200 ] ; int ord [ 200 ] ; int cnt = 0 ; int main ( ) { int n , k ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) { int tmp ; int flag = 1 ; cin >> tmp ; for ( int j = 0 ; j < cnt ; j ++ ) { if ( num [ j ] != tmp ) flag = 1 ; else { flag = 0 ; break ; } } if ( flag == 1 ) { num [ cnt ] = tmp ; ord [ cnt ] = i ; cnt ++ ; } } if ( cnt < k ) { cout << " NO " << endl ; return 0 ; } else { cout << " YES " << endl ; for ( int p = 0 ; p < k - 1 ; p ++ ) cout << ord [ p ] + 1 << "   " ; cout << ord [ k - 1 ] + 1 << endl ; } }
TAB0 n , a , b , c , ans are long integers ; TAB1 read n , a , b , c , ans ; TAB1 if a < b - c , print n / a and stop ; TAB1 if n > = b , increase ans by ( n - c ) / ( b - c ) ; TAB1 decrease n by ans * ( b - c ) ; TAB1 increase ans by n / a ; TAB1 print ans and newline ;	long long n , a , b , c , ans ; int main ( ) { cin >> n >> a >> b >> c ; if ( a < b - c ) return cout << n / a << ' \n ' , 0 ; if ( n >= b ) ans += ( n - c ) / ( b - c ) ; n -= ans * ( b - c ) ; ans += n / a ; cout << ans << ' \n ' ; }
TAB1 create integers n , k , cnt with cnt = 0 ; TAB1 create integers maxx , maxn , ans with ans = 0 ; TAB1 create integer arrays a , used , e , with a size 81 , used size 81 , e size 81 ; TAB1 set bytes from a to size of a to value 0 ; TAB1 set bytes from used to size of used to value 0 ; TAB1 read n read k ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 if used [ a [ i ] ] , break current loop iteration ; TAB2 if cnt is less than k ; TAB3 increment cnt ; TAB3 set used [ a [ i ] ] to 1 ; TAB3 increment ans ; TAB2 else ; TAB3 set bytes from e to size of e to value 0 ; TAB3 for j = 1 to i exclusive ; TAB4 if used [ a [ j ] ] is true , set e [ a [ j ] ] to 81 ; TAB3 for j = 1 to i exclusive ; TAB4 if used [ a [ j ] ] is true ; TAB5 for k = i + 1 to n inclusive ; TAB6 if a [ k ] is a [ j ] ; TAB7 set e [ a [ j ] ] to k ; TAB7 break loop ; TAB3 set maxx to 0 ; TAB3 set maxn to - 1 ; TAB3 for j = 1 to i exclusive ; TAB4 if e [ a [ j ] ] is greater than maxx ; TAB5 set maxx to e [ a [ j ] ] ; TAB5 set maxn to a [ j ] ; TAB3 set used [ maxn ] to 0 ; TAB3 set used [ a [ i ] ] to 1 ; TAB3 increment ans ; TAB1 print ans print newline ;	int main ( ) { int n , k , cnt = 0 ; int maxx , maxn , ans = 0 ; int a [ 81 ] , used [ 81 ] , e [ 81 ] ; memset ( a , 0 , sizeof ( a ) ) ; memset ( used , 0 , sizeof ( used ) ) ; cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( used [ a [ i ] ] ) continue ; if ( cnt < k ) { cnt ++ ; used [ a [ i ] ] = 1 ; ans ++ ; } else { memset ( e , 0 , sizeof ( e ) ) ; for ( int j = 1 ; j < i ; j ++ ) if ( used [ a [ j ] ] ) e [ a [ j ] ] = 81 ; for ( int j = 1 ; j < i ; j ++ ) if ( used [ a [ j ] ] ) { for ( int k = i + 1 ; k <= n ; k ++ ) if ( a [ k ] == a [ j ] ) { e [ a [ j ] ] = k ; break ; } } maxx = 0 ; maxn = - 1 ; for ( int j = 1 ; j < i ; j ++ ) if ( e [ a [ j ] ] > maxx ) { maxx = e [ a [ j ] ] ; maxn = a [ j ] ; } used [ maxn ] = 0 ; used [ a [ i ] ] = 1 ; ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 create long long a , b , c , d , k ; TAB1 read b , a , d and c ; TAB1 for i = 0 to 100 inclusive ; TAB2 for j = 0 to 100 inclusive if ; TAB3 if a + i * b = c + j * d , print a + i * b and a newline , return 0 ; TAB1 print - 1 and a newline ;	long long a , b , c , d , k ; int main ( ) { cin >> b >> a >> d >> c ; for ( int i = 0 ; i <= 100 ; i ++ ) for ( int j = 0 ; j <= 100 ; j ++ ) if ( a + i * b == c + j * d ) return cout << a + i * b << ' \n ' , 0 ; cout << - 1 << ' \n ' ; return 0 ; }
TAB1 define string variable a ; TAB1 b , t and c are long longs where c = 0 ; TAB1 read line from the input and put it into a ; TAB1 assign to b ; TAB1 change t to b ; TAB1 add 2 to b ; TAB1 assign the new value = to b ; TAB1 for i = 0 to t exclusive ; TAB2 increment c by one if a [ i ] is equal to ' | ' ; TAB1 if c + 1 is equal to b - 1 ; TAB2 print ' | ' ; TAB2 in a for loop , change i from 0 to length of a - 1 exclusive and print a [ i ] to the output on each loop ; TAB2 print new line to the standard output ; TAB1 else if c = b ; TAB2 print a to the standard output ; TAB1 else if c = b + 2 ; TAB2 declare new long long z ; TAB2 if z is greater than 1 ; TAB3 print all elements of a , except the first , to the output in a loop ; TAB3 print ' | ' to the standard output ; TAB2 else ; TAB3 for i from 0 to length of a exclusive ; TAB4 if i is equal to z + 1 , skip the rest of the loop ; TAB4 print a [ i ] to the standard output ; TAB3 print ' | ' ; TAB1 else ; TAB2 print " Impossible " to the standard output ;	int main ( ) { string a ; long long b , t , c = 0 ; getline ( cin , a ) ; b = a . find ( ' = ' ) ; t = b ; b += 2 ; b = a . size ( ) - b + 1 ; for ( long long i = 0 ; i < t ; ++ i ) { if ( a [ i ] == ' | ' ) { c ++ ; } } if ( c + 1 == b - 1 ) { cout << ' | ' ; for ( long long i = 0 ; i < a . size ( ) - 1 ; ++ i ) { cout << a [ i ] ; } cout << endl ; } else if ( c == b ) { cout << a << endl ; } else if ( c == b + 2 ) { long long z = a . find ( ' + ' ) ; if ( z > 1 ) { for ( long long i = 1 ; i < a . size ( ) ; i ++ ) { cout << a [ i ] ; } cout << ' | ' << endl ; } else { for ( long long i = 0 ; i < a . size ( ) ; i ++ ) { if ( i == z + 1 ) { continue ; } cout << a [ i ] ; } cout << ' | ' << endl ; } } else { cout << " Impossible " << endl ; } return 0 ; }
TAB0 create new strings x and y and an array s with size 15 ; TAB1 set the value of s [ 1 ] to " monday " ; TAB1 change the value of s [ 2 ] to " tuesday " ; TAB1 assign " wednesday " to s [ 3 ] ; TAB1 change s [ 4 ] to " thursday " ; TAB1 set s [ 5 ] to " friday " ; TAB1 change s [ 6 ] to " saturday " ; TAB1 assign the new value = " sunday " to s [ 7 ] ; TAB1 read x and y from the user input ; TAB1 declare integers num1 and num2 = 0 ; TAB1 in a for loop , change i from 1 to 7 inclusive incrementing i ; TAB2 if x = s [ i ] , change the value of num1 to i ; TAB1 in a for loop , change i from 1 to 7 inclusive incrementing i ; TAB2 if y is equal to s [ i ] , set the value of num2 to i ; TAB1 if num2 is less than num1 , change num2 to num2 + 7 ; TAB1 define integer variable sum with value num2 - num1 ; TAB1 if sum = 0 or sum is equal to 2 or sum = 3 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " to the output ;	string s [ 15 ] , x , y ; int main ( ) { s [ 1 ] = " monday " ; s [ 2 ] = " tuesday " ; s [ 3 ] = " wednesday " ; s [ 4 ] = " thursday " ; s [ 5 ] = " friday " ; s [ 6 ] = " saturday " ; s [ 7 ] = " sunday " ; cin >> x >> y ; int num1 = 0 , num2 = 0 ; for ( int i = 1 ; i <= 7 ; i ++ ) { if ( x == s [ i ] ) { num1 = i ; } } for ( int i = 1 ; i <= 7 ; i ++ ) { if ( y == s [ i ] ) { num2 = i ; } } if ( num2 < num1 ) { num2 += 7 ; } int sum = num2 - num1 ; if ( sum == 0 || sum == 2 || sum == 3 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 declare integer variables n and m ; TAB0 lg is a new 2d array of booleans with size 111 by 111 ; TAB0 a is a new array of integers 111 by 111 ; TAB0 v is an array of booleans with 111 elements ; TAB0 create new array of booleans zero with size 111 ; TAB0 create integer ex = 0 ; TAB0 dfs is a void function with int argument i ; TAB1 change the value of v [ i ] to true ; TAB1 start for loop from j = 1 to n inclusive ; TAB2 call dfs ( j ) if a [ i ] [ j ] is true and v [ j ] is false ; TAB1 read n and m from the user input ; TAB1 in a for loop , change i from 1 to n inclusive ; TAB2 declare new integer called t ; TAB2 read standard input to t ; TAB2 if t is equal to 0 ; TAB3 assign true to zero [ i ] ; TAB3 increment ex by one ; TAB2 decrement t and loop further , while t is not 0 ; TAB3 declare integer variable with name c ; TAB3 read c ; TAB3 change the value of lg [ i ] [ c ] to true ; TAB1 for integer i = 1 to n inclusive ; TAB2 in a for loop , change j from 1 to n inclusive ; TAB3 if i ! = j ; TAB4 increment k from 1 to m inclusive in a loop ; TAB5 if lg [ i ] [ k ] and lg [ j ] [ k ] are true , assign the new value = 1 to a [ i ] [ j ] ; TAB1 declare new integer variable ans = 0 ; TAB1 start for loop from i = 1 to n inclusive incrementing i ; TAB2 if both v [ i ] and zero [ i ] are false ; TAB3 call dfs ( i ) ; TAB3 increment ans by one ; TAB1 decrement ans ; TAB1 if ans is less than 0 , change the value of ans to 0 ; TAB1 print ans + ex to the standard output ;	int n , m ; bool lg [ 111 ] [ 111 ] ; int a [ 111 ] [ 111 ] ; bool v [ 111 ] = { 0 } ; bool zero [ 111 ] = { 0 } ; int ex = 0 ; void dfs ( int i ) { v [ i ] = true ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] && ! v [ j ] ) { dfs ( j ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { int t ; cin >> t ; if ( t == 0 ) { zero [ i ] = true ; ex ++ ; } while ( t -- ) { int c ; cin >> c ; lg [ i ] [ c ] = true ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i != j ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( lg [ i ] [ k ] && lg [ j ] [ k ] ) { a [ i ] [ j ] = 1 ; } } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! v [ i ] && ! zero [ i ] ) { dfs ( i ) ; ans ++ ; } } ans -- ; if ( ans < 0 ) ans = 0 ; cout << ans + ex << endl ; return 0 ; }
TAB1 a , b , c , d , i , j , k , n , l = long integers with c = 0 ; TAB1 read n , a ; TAB1 ar = integer array of size [ n + 2 ] ; TAB1 for i = 0 to n ( exclusive ) , read ar [ i ] ; TAB1 for i = n - 1 to 0 ( inclusive ) ; TAB2 let b = ar [ i ] ; TAB2 if b modulo a is 0 ; TAB3 let d = b / a ; TAB3 if c is less than d ; TAB4 let c = d ; TAB4 let j = i + l ; TAB2 otherwise ; TAB3 let d = ( b / a ) + l ; TAB3 if c is less than d ; TAB4 let c = d ; TAB4 let j = i + l ; TAB1 print j ;	int main ( ) { long int a , b , c = 0 , d , i , j , k , n , l ; cin >> n >> a ; int ar [ n + 2 ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> ar [ i ] ; } for ( i = n - 1 ; i >= 0 ; i -- ) { b = ar [ i ] ; if ( b % a == 0 ) { d = b / a ; if ( c < d ) { c = d ; j = i + 1 ; } } else { d = ( b / a ) + 1 ; if ( c < d ) { c = d ; j = i + 1 ; } } } cout << j << endl ; }
TAB1 create integers n , k ; TAB1 read n read k ; TAB1 create string t ; TAB1 read t ; TAB1 create integer s with s = n ; TAB1 for i = n - 1 to 0 exclusive , decrementing i ; TAB2 if substring of t from i to n - 1 is substring of t from 0 to n - 1 , set s to i ; TAB1 print t ; TAB1 decrement k ; TAB1 while decrement k is true ; TAB2 for i = n - s to n exclusive , print t [ i ] ; TAB1 print newline ;	int main ( ) { int n , k ; cin >> n >> k ; string t ; cin >> t ; int s = n ; for ( int i = n - 1 ; i > 0 ; i -- ) if ( t . substr ( i , n - i ) == t . substr ( 0 , n - i ) ) s = i ; cout << t ; k -- ; while ( k -- ) { for ( int i = n - s ; i < n ; i ++ ) cout << t [ i ] ; } cout << endl ; }
TAB1 create ints n and s ; TAB1 read n and s ; TAB1 create ints lowest = 100 , ans = 0 , flag = 0 , and low and int arrays a of size n and b of size n ; TAB1 let ins i , j , k , and l ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] and b [ i ] ; TAB2 if s * 100 is greater than or equal to a [ i ] * 100 + b [ i ] ; TAB3 set flag to 1 ; TAB3 if b [ i ] is not 0 ; TAB4 set low to b [ i ] ; TAB4 if low is less than lowest , set lowest to low ; TAB1 if flag is not 0 ; TAB2 print the result of 100 - lowest ; TAB1 otherwise ; TAB2 print " - 1 " ;	int main ( ) { int n , s ; cin >> n >> s ; int a [ n ] , b [ n ] , lowest = 100 , ans = 0 , flag = 0 , low ; int i , j , k , l ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; if ( ( s * 100 ) >= ( a [ i ] * 100 ) + b [ i ] ) { flag = 1 ; if ( b [ i ] != 0 ) { low = b [ i ] ; if ( low < lowest ) { lowest = low ; } } } } if ( flag != 0 ) { cout << 100 - lowest << endl ; } else { cout << " -1 " << endl ; } return 0 ; }
TAB1 n , m , a , b = long long ; TAB1 read n , m , a , b ; TAB1 decrease a by 1 , decrease b by 1 ; TAB1 if a / m is b / m ; TAB2 print 1 ; TAB1 if a modulo m is 0 and b modulo m is m - 1 ; TAB2 print 1 ; TAB1 if b + 1 is n ; TAB2 if a modulo m is 0 ; TAB3 print 1 ; TAB2 print 2 ; TAB1 if a modulo m is 0 or b modulo m is m - 1 ; TAB2 print 2 ; TAB1 if the absolute value of the following ( a / m ) - ( b / m ) < = 1 ; TAB2 print 2 ; TAB1 if ( a + m - 1 ) modulo m is b modulo m ; TAB2 print 2 ; TAB1 print 3 ;	int main ( ) { long long n , m , a , b ; cin >> n >> m >> a >> b ; a -- , b -- ; if ( a / m == b / m ) { cout << " 1\n " ; return 0 ; } if ( a % m == 0 && b % m == m - 1 ) { cout << " 1\n " ; return 0 ; } if ( b + 1 == n ) { if ( a % m == 0 ) { cout << " 1\n " ; return 0 ; } cout << " 2\n " ; return 0 ; } if ( a % m == 0 || b % m == m - 1 ) { cout << " 2\n " ; return 0 ; } if ( abs ( ( a / m ) - ( b / m ) ) <= 1 ) { cout << " 2\n " ; return 0 ; } if ( ( ( a + m - 1 ) % m ) == ( b % m ) ) { cout << " 2\n " ; return 0 ; } cout << " 3\n " ; return 0 ; }
TAB0 create constant integer MAX with value 100005 ; TAB0 f is a new vector of integers with MAX elements filled with - 1 ; TAB0 create vector of integers fr with size MAX filled with - 1 ; TAB0 valid is a new vector of booleans with MAX elements filled with 1 ; TAB0 new boolean variable ans = 1 ; TAB0 define integer n ; TAB0 lastValid is a new integer variable with value 1 ; TAB1 read input to n ; TAB1 if n = 1 ; TAB2 print " 1 \ n " ; TAB1 else ; TAB2 if n & 1 is 1 ; TAB3 change the value of f [ n / 2 + 1 ] to n / 2 + 1 ; TAB3 change valid [ n / 2 + 1 ] to 0 ; TAB2 set f [ 1 ] to 2 and f [ n ] to n - 1 ; TAB2 set fr [ 2 ] to 1 and fr [ n - 1 ] to n ; TAB2 set the values of valid [ 2 ] and valid [ n - 1 ] to 0 ; TAB2 for i from 2 to n / 2 inclusive incrementing i ; TAB3 define integers x = f [ i ] and y = fr [ i ] ; TAB3 if x ! = - 1 and y = - 1 ; TAB4 change fr [ i ] to n + 1 - x ; TAB4 change the value of f [ n + 1 - x ] to i ; TAB4 assign the new value = 0 to valid [ i ] ; TAB3 else if y ! = - 1 and x = - 1 ; TAB4 change f [ i ] to n + 1 - y ; TAB4 assign 0 to valid [ n + 1 - y ] ; TAB4 set the value of fr [ n + 1 - y ] to i ; TAB3 if f [ i ] = - 1 ; TAB4 create boolean variable update = 1 ; TAB4 for integer j = lastValid to n inclusive incrementing j ; TAB5 if valid [ j ] is true ; TAB6 if i = j ; TAB7 change update to 0 ; TAB7 skip the rest of the loop ; TAB6 change f [ i ] to j ; TAB6 set the value of fr [ j ] to i ; TAB6 set the value of valid [ j ] to 0 ; TAB6 if update is true , assign the new value = j to lastValid ; TAB6 stop the loop ; TAB3 assign the new value = n + 1 - f [ i ] to f [ n + 1 - i ] ; TAB3 change the value of fr [ f [ n + 1 - i ] ] to n + 1 - i ; TAB3 set the value of valid [ n + 1 - f [ i ] ] to 0 ; TAB2 for integer i = 1 to n inclusive ; TAB3 if f [ f [ i ] ] ! = n + 1 - i , set ans to 0 ; TAB2 if ans is equal to 0 ; TAB3 print " - 1 \ n " ; TAB2 else ; TAB3 for integer i = 0 to n exclusive , print f [ i + 1 ] and ( " " if i + 1 < n or " \ n " otherwise ) to the output stream ;	const int MAX = 100005 ; vector < int > f ( MAX , - 1 ) ; vector < int > fr ( MAX , - 1 ) ; vector < bool > valid ( MAX , 1 ) ; bool ans = 1 ; int n ; int lastValid = 1 ; int main ( ) { cin >> n ; if ( n == 1 ) { cout << " 1\n " ; } else { if ( n & 1 ) { f [ n / 2 + 1 ] = n / 2 + 1 ; valid [ n / 2 + 1 ] = 0 ; } f [ 1 ] = 2 , f [ n ] = n - 1 ; fr [ 2 ] = 1 , fr [ n - 1 ] = n ; valid [ 2 ] = valid [ n - 1 ] = 0 ; for ( int i = 2 ; i <= n / 2 ; ++ i ) { int x = f [ i ] , y = fr [ i ] ; if ( x != - 1 && y == - 1 ) { fr [ i ] = n + 1 - x ; f [ n + 1 - x ] = i ; valid [ i ] = 0 ; } else if ( y != - 1 && x == - 1 ) { f [ i ] = n + 1 - y ; valid [ n + 1 - y ] = 0 ; fr [ n + 1 - y ] = i ; } if ( f [ i ] == - 1 ) { bool update = 1 ; for ( int j = lastValid ; j <= n ; ++ j ) { if ( valid [ j ] ) { if ( i == j ) { update = 0 ; continue ; } f [ i ] = j ; fr [ j ] = i ; valid [ j ] = 0 ; if ( update ) { lastValid = j ; } break ; } } } f [ n + 1 - i ] = n + 1 - f [ i ] ; fr [ f [ n + 1 - i ] ] = n + 1 - i ; valid [ n + 1 - f [ i ] ] = 0 ; } for ( int i = 1 ; i <= n && ans ; ++ i ) { if ( f [ f [ i ] ] != n + 1 - i ) { ans = 0 ; } } if ( ans == 0 ) { cout << " -1\n " ; } else { for ( int i = 0 ; i < n ; ++ i ) { cout << f [ i + 1 ] << ( i + 1 < n ? "   " : " \n " ) ; } } } }
TAB1 create long long n , i , k , a , j , mx = - 1 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read k and a ; TAB2 for j = 1 to 15 exclusive ; TAB3 if pow of 4 and j is greater than or equal to a , break ; TAB2 set mx to max of mx and j + k ; TAB1 print mx ;	int main ( ) { long long n , i , k , a , j , mx = - 1 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> k >> a ; for ( j = 1 ; j < 15 ; j ++ ) { if ( pow ( 4 , j ) >= a ) break ; } mx = max ( mx , j + k ) ; } cout << mx << endl ; return 0 ; }
TAB0 create map hit from int to int ; TAB1 create integers n , a [ 100005 ] , temp , flag , set flag to 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read temp ; TAB2 increment hit [ temp ] ; TAB2 if temp = 50 ; TAB3 if hit [ 25 ] > = 1 ; TAB4 decrement hit [ 25 ] ; TAB4 continue ; TAB3 flag = 1 ; TAB2 else if temp equal to 100 ; TAB3 if hit [ 50 ] > = 1 and hit [ 25 ] > = 1 ; TAB4 decrement hit [ 50 ] ; TAB4 decrement hit [ 25 ] ; TAB4 continue ; TAB3 else if hit [ 25 ] > = 3 ; TAB4 set hit [ 25 ] to hit [ 25 ] - 3 ; TAB4 continue ; TAB3 flag = 1 ; TAB1 if flag = 0 ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	map < int , int > hit ; int main ( ) { int n , a [ 100005 ] , temp , flag = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> temp ; hit [ temp ] ++ ; if ( temp == 50 ) { if ( hit [ 25 ] >= 1 ) { hit [ 25 ] -- ; continue ; } flag = 1 ; } else if ( temp == 100 ) { if ( hit [ 50 ] >= 1 && hit [ 25 ] >= 1 ) { hit [ 50 ] -- ; hit [ 25 ] -- ; continue ; } else if ( hit [ 25 ] >= 3 ) { hit [ 25 ] -= 3 ; continue ; } flag = 1 ; } } if ( flag == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 bigmod is a long long function with long long arguments a , b and m ; TAB1 if b = 0 , return 1 % m ; TAB1 create long long x = bigmod ( a , b / 2 , m ) ; TAB1 set x to x squared modulo m ; TAB1 if b is odd , assign ( x * a ) modulo m to x ; TAB1 return x ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 declare string array s with size n + 2 ; TAB1 for i from 0 to n exclusive , read s [ i ] ; TAB1 let r and c be vectors of integers arrays with size n + 1 ; TAB1 for i = 0 to n exclusive ; TAB2 for j from 0 to n exclusive ; TAB3 if s [ i ] [ j ] = ' . ' ; TAB4 push j to r [ i ] ; TAB4 push i to c [ j ] ; TAB1 declare integer p = 1 ; TAB1 loop i from 0 to n exclusive ; TAB2 if r [ i ] is empty ; TAB3 change p to 0 ; TAB3 break the loop ; TAB1 if p is true ; TAB2 for integer i = 0 to n exclusive , print i + 1 , " " and r [ i ] [ 0 ] + 1 ; TAB1 set p to 1 ; TAB1 for i = 0 to n exclusive ; TAB2 if c [ i ] is empty ; TAB3 change p to 0 ; TAB3 break ; TAB1 if p is true ; TAB2 loop i from 0 to n exclusive , print c [ i ] [ 0 ] + 1 , " " and i + 1 ; TAB1 print " - 1 " ;	long long bigmod ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 % m ; long long x = bigmod ( a , b / 2 , m ) ; x = ( x * x ) % m ; if ( b % 2 ) x = ( x * a ) % m ; return x ; } int main ( ) { int n ; cin >> n ; string s [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; vector < int > r [ n + 1 ] , c [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( s [ i ] [ j ] == ' . ' ) { r [ i ] . push_back ( j ) ; c [ j ] . push_back ( i ) ; } int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( r [ i ] . empty ( ) ) { p = 0 ; break ; } } if ( p ) { for ( int i = 0 ; i < n ; i ++ ) cout << i + 1 << "   " << r [ i ] [ 0 ] + 1 << endl ; return 0 ; } p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( c [ i ] . empty ( ) ) { p = 0 ; break ; } } if ( p ) { for ( int i = 0 ; i < n ; i ++ ) cout << c [ i ] [ 0 ] + 1 << "   " << i + 1 << endl ; return 0 ; } puts ( " -1 " ) ; }
TAB1 n = int ; TAB1 read n ; TAB1 cnt = int with cnt = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 x = int ; TAB2 read x ; TAB2 if x is 0 then increment cnt ; TAB1 if n is 1 ; TAB2 print " YES " if cnt is 0 else print " NO " ; TAB1 if cnt is 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int n ; cin >> n ; int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int x ; cin >> x ; if ( ! x ) ++ cnt ; } if ( n == 1 ) { cout << ( ! cnt ? " YES " : " NO " ) << " \n " ; return 0 ; } if ( cnt == 1 ) cout << " YES\n " ; else cout << " NO\n " ; return 0 ; }
TAB0 declare constant long long maxn = 1e9 + 5 ; TAB1 declare long longs t , s , x ; TAB1 read t , s , x ; TAB1 if x is less than t or x is t + 1 ; TAB2 print " NO " and newline ; TAB1 if ( x - t ) % s is 0 or ( x - t ) % 2 is 1 ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ;	const long long maxn = 1e9 + 5 ; int main ( ) { long long t , s , x ; cin >> t >> s >> x ; if ( x < t || x == t + 1 ) { cout << " NO " << endl ; return 0 ; } if ( ( x - t ) % s == 0 || ( x - t ) % s == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 A and B = array of 10000 long , n , i , a , s , j , k , tam , dem = long ; TAB1 read n ; TAB1 for i = 1 to n + 1 exclusive read A [ i ] ; TAB1 if n is 1 ; TAB2 if A [ 1 ] is 1 ; TAB3 print " YES " ; TAB2 else if A [ 1 ] is 0 ; TAB3 print " NO " ; TAB1 else ; TAB2 dem = 0 ; TAB2 for i = 1 to n + 1 exclusive ; TAB3 if A [ i ] is 0 increment dem ; TAB3 if A [ i ] < 0 or A [ i ] > 1 add 2 to dem ; TAB2 if dem > = 2 or dem is 0 ; TAB3 print " NO " ; TAB2 else ; TAB3 if dem is 1 print " YES " ;	int main ( ) { long A [ 10000 ] , B [ 10000 ] , n , i , a , s , j , k , tam , dem ; cin >> n ; for ( i = 1 ; i < n + 1 ; i ++ ) { cin >> A [ i ] ; } if ( n == 1 ) { if ( ( A [ 1 ] == 1 ) ) cout << " YES " << endl ; else if ( A [ 1 ] == 0 ) cout << " NO " << endl ; } else { dem = 0 ; for ( i = 1 ; i < n + 1 ; i ++ ) { if ( A [ i ] == 0 ) { dem ++ ; } if ( ( A [ i ] < 0 ) || ( A [ i ] > 1 ) ) { dem = dem + 2 ; } } if ( ( dem >= 2 ) || ( dem == 0 ) ) cout << " NO " << endl ; else { if ( dem == 1 ) cout << " YES " << endl ; } } return 0 ; }
TAB0 ip , ip2 and n are ints with ip and ip2 = 0 ; TAB0 declare vector of integers called v ; TAB0 s is a new array of characters with 100010 elements ; TAB0 in the function next_token that returns boolean ; TAB1 set the value of ip to ip2 ; TAB1 while ip < n and ( s [ ip ] < ' a ' or s [ ip ] > ' z ' ) ; TAB1 if ip is equal to n , return false ; TAB1 change ip2 to ip ; TAB1 while ip2 < n and s [ ip2 ] > = ' a ' and s [ ip2 ] < = ' z ' ; TAB1 return true ; TAB0 declare character z ; TAB0 function get_type that returns integer ; TAB1 define new integer len with value ip2 - ip ; TAB1 change z to s [ ip2 ] ; TAB1 assign the new value = 0 to s [ ip2 ] ; TAB1 if s + ip + len - 4 matches " lios " , return 0 ; TAB1 if result of s + ip + len - 5 = " liala " return 1 ; TAB1 if s + ip + len - 3 matches " etr " return 10 ; TAB1 if strcmp ( s + ip + len - 4 , " etra " ) returns 0 , return 11 ; TAB1 if comparison of s + ip + len - 6 with " initis " returns 0 , return 20 ; TAB1 return 21 if s + ip + len - 6 matches " inites " ; TAB1 return - 1 ; TAB0 boolean function solve ; TAB1 in a for loop , change i from 0 to length of v exclusive ; TAB2 if v [ i ] is equal to - 1 , return false ; TAB1 return true if length of v = 1 ; TAB1 start for loop from i = 0 to length of v exclusive incrementing i ; TAB2 in a for loop , change j from 0 to i exclusive ; TAB3 return false if v [ i ] % 10 ! = v [ j ] % 10 ; TAB1 start for loop from i = 0 to length of v - 1 exclusive incrementing i ; TAB2 if v [ i ] is greater than v [ i + 1 ] , return false ; TAB1 create new integer cnt = 0 ; TAB1 increment i in a loop from i = 0 to length of v exclusive ; TAB2 if v [ i ] / 10 = 1 , increment cnt ; TAB1 if cnt is equal to 1 ; TAB2 return true ; TAB1 else ; TAB2 return false ; TAB1 store input into s ; TAB1 change n to length of s ; TAB1 while next_token ( ) returns true ; TAB2 push new value = the result of get_type ( ) into v ; TAB2 change s [ ip2 ] to z ; TAB1 if call to solve ( ) returned true ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " to standard output ;	int ip = 0 , ip2 = 0 , n ; vector < int > v ; char s [ 100010 ] ; bool next_token ( ) { ip = ip2 ; while ( ip < n && ( s [ ip ] < ' a ' || s [ ip ] > ' z ' ) ) ip ++ ; if ( ip == n ) return false ; ip2 = ip ; while ( ip2 < n && s [ ip2 ] >= ' a ' && s [ ip2 ] <= ' z ' ) ip2 ++ ; return true ; } char z ; int get_type ( ) { int len = ip2 - ip ; z = s [ ip2 ] ; s [ ip2 ] = 0 ; if ( strcmp ( s + ip + len - 4 , " lios " ) == 0 ) return 0 ; if ( strcmp ( s + ip + len - 5 , " liala " ) == 0 ) return 1 ; if ( strcmp ( s + ip + len - 3 , " etr " ) == 0 ) return 10 ; if ( strcmp ( s + ip + len - 4 , " etra " ) == 0 ) return 11 ; if ( strcmp ( s + ip + len - 6 , " initis " ) == 0 ) return 20 ; if ( strcmp ( s + ip + len - 6 , " inites " ) == 0 ) return 21 ; return - 1 ; } bool solve ( ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( v [ i ] == - 1 ) return false ; if ( v . size ( ) == 1 ) return true ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( v [ i ] % 10 != v [ j ] % 10 ) return false ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) if ( v [ i ] > v [ i + 1 ] ) return false ; int cnt = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( v [ i ] / 10 == 1 ) cnt ++ ; if ( cnt == 1 ) return true ; else return false ; } int main ( ) { gets ( s ) ; n = strlen ( s ) ; while ( next_token ( ) ) { v . push_back ( get_type ( ) ) ; s [ ip2 ] = z ; } if ( solve ( ) ) puts ( " YES " ) ; else puts ( " NO " ) ; return 0 ; }
TAB1 declare integer variable numberOfStudents ; TAB1 declare new integer variable studentsRate ; TAB1 create integer variable with name result with value 1 ; TAB1 read numberOfStudents from the user input ; TAB1 create an int pointer arr pointed to the new array of integers with numberOfStudents elements ; TAB1 for integer x = 0 to numberOfStudents exclusive incrementing x ; TAB2 read studentsRate from the input ; TAB2 set arr [ x ] to studentsRate ; TAB1 in a for loop , change x from 0 to numberOfStudents exclusive ; TAB2 assign 1 to result ; TAB2 lopp y from 0 to numberOfStudents exclusive incrementing by 1 ; TAB3 if arr [ x ] is less than arr [ y ] ; TAB2 if x = numberOfStudents - 1 ; TAB3 print result ; TAB2 else ; TAB3 print result and " " ;	int main ( ) { int numberOfStudents ; int studentsRate ; int result = 1 ; cin >> numberOfStudents ; int * arr = new int [ numberOfStudents ] ; for ( int x = 0 ; x < numberOfStudents ; ++ x ) { cin >> studentsRate ; arr [ x ] = studentsRate ; } for ( int x = 0 ; x < numberOfStudents ; ++ x ) { result = 1 ; for ( int y = 0 ; y < numberOfStudents ; ++ y ) { if ( arr [ x ] < arr [ y ] ) { ++ result ; } } if ( x == numberOfStudents - 1 ) cout << result << endl ; else cout << result << "   " ; } return 0 ; }
TAB1 t1 , t2 , x1 , x2 , t0 = long long ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 if t1 is t0 and t2 is t0 ; TAB2 print x1 x2 ; TAB2 end execution of code ; TAB1 if t1 is t0 ; TAB2 print x1 0 ; TAB2 end execution of code ; TAB1 if t2 is t0 ; TAB2 print 0 x2 ; TAB2 end execution of code ; TAB1 Y1 = Y2 = long long = 0 ; TAB1 dif = long double = maximum value of an integer ; TAB1 for y1 = 0 to x1 inclusive ; TAB2 l = next whole number of 1 . 0L * y1 * ( t1 - t0 ) / ( t0 - t2 ) ; TAB2 got y2 = l to l + 10 inclusive ; TAB3 if y1 is 0 and y2 is 0 , continue ; TAB3 if 1 > y2 and y2 is not 0 , continue ; TAB3 t = long double = 1 . 0L * ( t1 * y1 + t2 * y2 ) / ( y1 + y2 ) ; TAB3 if t > - t0 and t - t0 < = dif ; TAB4 if the absolute value of t - t0 - dif < 1e - 6 and y1 + y2 < Y1 + Y2 , then continue ; TAB4 dif = t = t0 ; TAB4 Y1 = y1 ; TAB4 Y2 = y2 ; TAB1 print Y1 Y2 ; TAB1 end the execution of code ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; if ( t1 == t0 and t2 == t0 ) { cout << x1 << '   ' << x2 << endl ; return ( 0 ) ; } if ( t1 == t0 ) { cout << x1 << '   ' << 0 << endl ; return ( 0 ) ; } if ( t2 == t0 ) { cout << 0 << '   ' << x2 << endl ; return ( 0 ) ; } long long Y1 = 0 , Y2 = 0 ; long double dif = INT_MAX ; for ( long long y1 = 0 ; y1 <= x1 ; y1 ++ ) { long long l = ceil ( 1.0L * y1 * ( t1 - t0 ) / ( t0 - t2 ) ) ; for ( long long y2 = l ; y2 <= l + 10 ; y2 ++ ) { if ( y1 == 0 and y2 == 0 ) continue ; if ( not ( 0 <= y2 and y2 <= x2 ) ) continue ; long double t = 1.0L * ( t1 * y1 + t2 * y2 ) / ( y1 + y2 ) ; if ( t >= t0 and t - t0 <= dif ) { if ( abs ( t - t0 - dif ) < 1e-6 and y1 + y2 < Y1 + Y2 ) continue ; dif = t - t0 ; Y1 = y1 ; Y2 = y2 ; } } } cout << Y1 << '   ' << Y2 << endl ; return ( 0 ) ; }
TAB0 ans , n = int and b = int array of size 20 ; TAB0 a = two dimensional bool array of sizes 10 and 10 ; TAB0 in function check returning bool ; TAB1 i , j , r , l , tot = int ; TAB1 for i = 1 to 5 inclusive ; TAB2 set l and r to 0 ; TAB2 for j = 1 to 5 inclusive ; TAB3 if a [ i ] [ j ] ; TAB4 increment l ; TAB4 if b [ j ] increment r ; TAB2 if l - 1 > r return false ; TAB1 for i = 1 to 5 inclusive ; TAB2 set l and r to 0 ; TAB2 for j = 1 to 5 inclusive ; TAB3 if a [ i ] [ j ] ; TAB4 increment l ; TAB4 if b [ 5 + j ] increment r ; TAB2 if l - 1 > r return false ; TAB1 set tot to 0 ; TAB1 for i = 1 to 5 inclusive ; TAB2 for j = 1 to 5 inclusive ; TAB3 if a [ i ] [ j ] and not b [ i + 5 ] and not b [ j ] increment tot ; TAB1 if tot > 1 return false ; TAB1 return true ; TAB0 in function dfs taking int x ; TAB1 i , sum = int ; TAB1 if x is 11 ; TAB2 if check ; TAB3 set sum to 0 ; TAB3 for i = 1 to 11 inclusive ; TAB4 if b [ i ] is 1 increment sum ; TAB3 set ans to min of sum , ans ; TAB2 return ; TAB1 set b [ x ] to 1 ; TAB1 call dfs of x + 1 ; TAB1 set b [ x ] to 0 ; TAB1 call dfs of x + 1 ; TAB1 i , y = int ; TAB1 ch = char ; TAB1 k = int ; TAB1 read n ; TAB1 set all values of a to false ; TAB1 for i = 1 to n inclusive ; TAB2 read ch then k ; TAB2 if ch is ' R ' ; TAB3 set y to 1 ; TAB2 else if ch is ' G ' ; TAB3 set y to 2 ; TAB2 else if ch is ' B ' ; TAB3 set y to 3 ; TAB2 else if ch is ' Y ' ; TAB3 set y to 4 ; TAB2 else if ch is ' W ' ; TAB3 set y to 5 ; TAB2 set a [ y ] [ k ] to true ; TAB1 set all values of b to 0 ; TAB1 set ans to 9999999 ; TAB1 noop ; TAB1 call dfs of 1 ; TAB1 print ans ;	int b [ 20 ] , ans , n ; bool a [ 10 ] [ 10 ] ; bool check ( ) { int i , j , r , l , tot ; for ( i = 1 ; i <= 5 ; i ++ ) { l = r = 0 ; for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ i ] [ j ] ) { l ++ ; if ( b [ j ] ) { r ++ ; } } } if ( l - 1 > r ) return false ; } for ( i = 1 ; i <= 5 ; i ++ ) { l = r = 0 ; for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ j ] [ i ] ) { l ++ ; if ( b [ 5 + j ] ) r ++ ; } } if ( l - 1 > r ) return false ; } tot = 0 ; for ( i = 1 ; i <= 5 ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ i ] [ j ] && ! b [ i + 5 ] && ! b [ j ] ) tot ++ ; } } if ( tot > 1 ) return false ; return true ; } void dfs ( int x ) { int i , sum ; if ( x == 11 ) { if ( check ( ) ) { sum = 0 ; for ( i = 1 ; i <= 11 ; i ++ ) { if ( b [ i ] == 1 ) sum ++ ; } ans = min ( sum , ans ) ; } return ; } b [ x ] = 1 ; dfs ( x + 1 ) ; b [ x ] = 0 ; dfs ( x + 1 ) ; } int main ( ) { int i , y ; char ch ; int k ; cin >> n ; memset ( a , false , sizeof ( a ) ) ; for ( i = 1 ; i <= n ; i ++ ) { cin >> ch >> k ; if ( ch == ' R ' ) y = 1 ; else if ( ch == ' G ' ) y = 2 ; else if ( ch == ' B ' ) y = 3 ; else if ( ch == ' Y ' ) y = 4 ; else if ( ch == ' W ' ) y = 5 ; a [ y ] [ k ] = true ; } memset ( b , 0 , sizeof ( b ) ) ; ans = 9999999 ; ; dfs ( 1 ) ; cout << ans << endl ; }
TAB0 new static double constant EPS = 1e - 5 ; TAB0 new chat array colortable with elements ' R ' , ' G ' , ' B ' , ' Y ' and ' W ' ; TAB0 int function getX with string argument s ; TAB1 for i from 0 to 5 exclusive incrementing i ; TAB2 if colortable [ i ] is equal to s [ 0 ] , return i ; TAB1 return - 1 ; TAB0 getY is a integer function with string argument s ; TAB1 return s [ 1 ] - ' 1 ' ; TAB0 bitcount is a int function with int argument b ; TAB1 declare new integer variable ans = 0 ; TAB1 while b ! = 0 ; TAB2 increment ans ; TAB2 change b to b & ( b - 1 ) ; TAB1 return ans ; TAB0 bool function check with int arguments maskX and maskY and string arguments C1 and C2 ; TAB1 x1 is a new integer = result of getX ( C1 ) ; TAB1 create new integer variable x2 with value from getX ( C2 ) ; TAB1 declare integer variable y1 = value , returned by getY ( C1 ) ; TAB1 declare integer y2 = result of getY ( C2 ) ; TAB1 return true if x1 is equal to x2 and y1 = y2 ; TAB1 if x1 ! = x2 ; TAB2 if ( maskX & ( 1 < < x1 ) ) ! = 0 | | ( maskX & ( 1 < < x2 ) ) ! = 0 , return true ; TAB1 if y1 ! = y2 ; TAB2 if ( maskY & ( 1 < < y1 ) ) ! = 0 | | ( maskY & ( 1 < < y2 ) ) ! = 0 , return true ; TAB1 return false ; TAB1 declare new integer variable n ; TAB1 read n ; TAB1 cards is a new vector of strings with n elements ; TAB1 read n elements from the input into cards in a loop ; TAB1 declare new integer ans = 100000 ; TAB1 sort cards ; TAB1 remove duplicates from cards ; TAB1 start for loop from maskX = 0 to 1 < < 5 exclusive ; TAB2 start for loop from maskY = 0 to 1 < < 5 exclusive incrementing maskY ; TAB3 create boolean variable with name ok = true ; TAB3 incremen i in a loop from 0 , while ok is true and i < size of cards ; TAB4 for j from i + 1 to exclusive , assign the result of check ( maskX , maskY , cards [ i ] , cards [ j ] ) to ok ; TAB3 if ok is true , set the value of ans to min of ans and bitcount ( maskX ) + bitcount ( maskY ) ; TAB1 print ans to the standard output ;	static const double EPS = 1e-5 ; char colortable [ ] = { ' R ' , ' G ' , ' B ' , ' Y ' , ' W ' } ; int getX ( string s ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( colortable [ i ] == s [ 0 ] ) return i ; } return - 1 ; } int getY ( string s ) { return s [ 1 ] - ' 1 ' ; } int bitcount ( int b ) { int ans = 0 ; while ( b != 0 ) { ans ++ ; b &= b - 1 ; } return ans ; } bool check ( int maskX , int maskY , string C1 , string C2 ) { int x1 = getX ( C1 ) ; int x2 = getX ( C2 ) ; int y1 = getY ( C1 ) ; int y2 = getY ( C2 ) ; if ( x1 == x2 && y1 == y2 ) return true ; if ( x1 != x2 ) { if ( ( maskX & ( 1 << x1 ) ) != 0 || ( maskX & ( 1 << x2 ) ) != 0 ) return true ; } if ( y1 != y2 ) { if ( ( maskY & ( 1 << y1 ) ) != 0 || ( maskY & ( 1 << y2 ) ) != 0 ) return true ; } return false ; } int main ( ) { int n ; cin >> n ; vector < string > cards ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> cards [ i ] ; int ans = 100000 ; sort ( cards . begin ( ) , cards . end ( ) ) ; cards . erase ( unique ( cards . begin ( ) , cards . end ( ) ) , cards . end ( ) ) ; for ( int maskX = 0 ; maskX < ( 1 << 5 ) ; maskX ++ ) { for ( int maskY = 0 ; maskY < ( 1 << 5 ) ; maskY ++ ) { bool ok = true ; for ( int i = 0 ; ok && ( i < ( int ) cards . size ( ) ) ; i ++ ) { for ( int j = i + 1 ; ok && ( j < ( int ) cards . size ( ) ) ; j ++ ) { ok = check ( maskX , maskY , cards [ i ] , cards [ j ] ) ; } } if ( ok ) { ans = min ( ans , bitcount ( maskX ) + bitcount ( maskY ) ) ; } } } cout << ans << endl ; return 0 ; }
TAB0 create 2d integer array d with size 7 by 7 ; TAB0 create integer n ; TAB0 declare as with integers x , y , node as arguments , returning void ; TAB1 if not x ; TAB2 set x [ node ] [ 1 ] to y ; TAB2 set d [ 1 ] [ node ] to y ; TAB2 set d [ node ] [ 2 ] to n - y ; TAB2 set d [ 2 ] [ node ] to n - y ; TAB1 if not y ; TAB2 set d [ node ] [ 1 ] to x ; TAB2 set d [ 1 ] [ node ] to x ; TAB2 set d [ node ] [ 3 ] to n - x ; TAB2 set d [ 3 ] [ node ] to n - x ; TAB1 if x is n ; TAB2 set d [ node ] [ 3 ] to y ; TAB2 set d [ 3 ] [ node ] to y ; TAB2 set d [ node ] [ 4 ] to n - y ; TAB2 set d [ 4 ] [ node ] to n - y ; TAB1 if y is n ; TAB2 set d [ node ] [ 2 ] to x ; TAB2 set d [ 2 ] [ node ] to x ; TAB2 set d [ node ] [ 4 ] to n - x ; TAB2 set d [ 4 ] [ node ] to n - x ; TAB1 create integers x1 , y1 , x2 , y2 ; TAB1 read n read x1 read y1 read x2 read y2 ; TAB1 for i = 1 to 6 inclusive ; TAB2 for j = 1 to 6 inclusive , set d [ i ] [ j ] to 3000 ; TAB1 for i = 1 to 6 inclusive , set d [ i ] [ i ] to 0 ; TAB1 set d [ 1 ] [ 2 ] to n ; TAB1 set d [ 2 ] [ 2 ] to n ; TAB1 set d [ 1 ] [ 3 ] to n ; TAB1 set d [ 3 ] [ 1 ] to n ; TAB1 set d [ 4 ] [ 2 ] to n ; TAB1 set d [ 2 ] [ 4 ] to n ; TAB1 set d [ 3 ] [ 4 ] to n ; TAB1 set d [ 4 ] [ 3 ] to n ; TAB1 run as with x1 , y1 , 5 as arguments ; TAB1 run as with x2 , y2 , 6 as arguments ; TAB1 if x1 is x2 and absolute value of ( y1 - y2 ) is less than n ; TAB2 set d [ 5 ] [ 6 ] to absolute value of ( y1 - y2 ) ; TAB2 set d [ 6 ] [ 5 ] to absolute value of ( y1 - y2 ) ; TAB1 if y1 is y2 and absolute value of ( x1 - x2 ) is less than n ; TAB2 set d [ 5 ] [ 6 ] to absolute value of ( x1 - x2 ) ; TAB2 set d [ 6 ] [ 5 ] to absolute value of ( x1 - x2 ) ; TAB1 for i = 1 to 6 inclusive ; TAB2 for j = 1 to 6 inclusive ; TAB3 for k = 1 to 6 inclusive ; TAB4 if d [ j ] [ i ] + d [ i ] [ k ] is less than d [ j ] [ k ] ; TAB5 set d [ j ] [ k ] to d [ j ] [ i ] + d [ i ] [ k ] ; TAB5 set d [ k ] [ j ] to d [ j ] [ i ] + d [ i ] [ k ] ; TAB1 print d [ 6 ] [ 5 ] print newline ;	int d [ 7 ] [ 7 ] ; int n ; void as ( int x , int y , int node ) { if ( ! x ) { d [ node ] [ 1 ] = y ; d [ 1 ] [ node ] = y ; d [ node ] [ 2 ] = n - y ; d [ 2 ] [ node ] = n - y ; } if ( ! y ) { d [ node ] [ 1 ] = x ; d [ 1 ] [ node ] = x ; d [ node ] [ 3 ] = n - x ; d [ 3 ] [ node ] = n - x ; } if ( x == n ) { d [ node ] [ 3 ] = y ; d [ 3 ] [ node ] = y ; d [ node ] [ 4 ] = n - y ; d [ 4 ] [ node ] = n - y ; } if ( y == n ) { d [ node ] [ 2 ] = x ; d [ 2 ] [ node ] = x ; d [ node ] [ 4 ] = n - x ; d [ 4 ] [ node ] = n - x ; } } int main ( ) { int x1 , y1 , x2 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; for ( int i = 1 ; i <= 6 ; i ++ ) for ( int j = 1 ; j <= 6 ; j ++ ) d [ i ] [ j ] = 3000 ; for ( int i = 1 ; i <= 6 ; i ++ ) d [ i ] [ i ] = 0 ; d [ 1 ] [ 2 ] = n ; d [ 2 ] [ 1 ] = n ; d [ 1 ] [ 3 ] = n ; d [ 3 ] [ 1 ] = n ; d [ 4 ] [ 2 ] = n ; d [ 2 ] [ 4 ] = n ; d [ 3 ] [ 4 ] = n ; d [ 4 ] [ 3 ] = n ; as ( x1 , y1 , 5 ) ; as ( x2 , y2 , 6 ) ; if ( x1 == x2 && abs ( y1 - y2 ) < n ) { d [ 5 ] [ 6 ] = abs ( y1 - y2 ) ; d [ 6 ] [ 5 ] = abs ( y1 - y2 ) ; } if ( y1 == y2 && abs ( x1 - x2 ) < n ) { d [ 5 ] [ 6 ] = abs ( x1 - x2 ) ; d [ 6 ] [ 5 ] = abs ( x1 - x2 ) ; } for ( int i = 1 ; i <= 6 ; i ++ ) for ( int j = 1 ; j <= 6 ; j ++ ) for ( int k = 1 ; k <= 6 ; k ++ ) if ( d [ j ] [ i ] + d [ i ] [ k ] < d [ j ] [ k ] ) { d [ j ] [ k ] = d [ j ] [ i ] + d [ i ] [ k ] ; d [ k ] [ j ] = d [ j ] [ i ] + d [ i ] [ k ] ; } cout << d [ 6 ] [ 5 ] << endl ; return 0 ; }
TAB0 a is an array of long longs with size 1001000 ; TAB0 declare new array of long longs b with size 1001000 ; TAB1 create long long variable n ; TAB1 read variable n from the input ; TAB1 for i from 0 to n exclusive ; TAB2 read variable a [ i ] from the input ; TAB2 increase b [ a [ i ] ] by one ; TAB1 sort first n elements of array a ; TAB1 declare new long long variable ans ; TAB1 for i = 0 to 1000100 exclusive ; TAB2 increase b [ i + 1 ] by b [ i ] / 2 ; TAB2 change b [ i ] to b [ i ] modulo 2 ; TAB2 if b [ i ] is true , increment ans ; TAB1 print ans ;	long long a [ 1001000 ] ; long long b [ 1001000 ] ; int main ( ) { long long n ; cin >> n ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; b [ a [ i ] ] ++ ; } sort ( a , a + n ) ; long long ans = 0 ; for ( long long i = 0 ; i < 1000100 ; i ++ ) { b [ i + 1 ] += b [ i ] / 2 ; b [ i ] %= 2 ; if ( b [ i ] ) ans ++ ; } cout << ans << endl ; return 0 ; }
TAB0 declare new integer variable n ; TAB1 read variable n from the input ; TAB1 declare an arrays of integers ar and br with n elements ; TAB1 read n new elements to ar and br in a loop ; TAB1 create new integer c with value 0 ; TAB1 start for loop from j = 0 to n exclusive ; TAB2 in a for loop , change i from 0 to n exclusive ; TAB3 if i ! = j and ar [ j ] = br [ i ] ; TAB4 increment c ; TAB4 break the loop ; TAB1 print n - c ;	int n ; int main ( ) { cin >> n ; int ar [ n ] , br [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { cin >> ar [ j ] >> br [ j ] ; } int c = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i != j && ar [ j ] == br [ i ] ) { c ++ ; break ; } } } cout << n - c << endl ; }
TAB1 str = string ; TAB1 read str ; TAB1 a , b , c , d , x , y = long long int ; TAB1 a = str [ 0 ] - ' 0 ' ; TAB1 b = str [ 1 ] - ' 0 ' ; TAB1 c = str [ 3 ] - ' 0 ' ; TAB1 d = str [ 4 ] - ' 0 ' ; TAB1 y = c * 10 + d ; TAB1 x = a * 10 + b ; TAB1 s1 , s2 = vector of long long int ; TAB1 while true ; TAB2 clear s1 ; TAB2 clear s2 ; TAB2 increment y ; TAB2 if y is 60 ; TAB3 y = 0 ; TAB3 increment x ; TAB3 if x is 24 x = 0 ; TAB2 add y / 10 at end of s2 ; TAB2 add y modulo 10 at end of s2 ; TAB2 add x / 10 at end of s1 ; TAB2 add x modulo 10 at end of s1 ; TAB2 if s1 [ 0 ] is s2 [ 1 ] and s1 [ 1 ] is s2 [ 0 ] ; TAB3 print s1 [ 0 ] , s1 [ 1 ] , " : " , s2 [ 0 ] , s2 [ 1 ] ;	int main ( ) { string str ; cin >> str ; long long int a , b , c , d , x , y ; a = str [ 0 ] - ' 0 ' ; b = str [ 1 ] - ' 0 ' ; c = str [ 3 ] - ' 0 ' ; d = str [ 4 ] - ' 0 ' ; y = c * 10 + d ; x = a * 10 + b ; vector < long long int > s1 , s2 ; while ( true ) { s1 . clear ( ) ; s2 . clear ( ) ; ++ y ; if ( y == 60 ) { y = 0 ; ++ x ; if ( x == 24 ) { x = 00 ; } } s2 . push_back ( y / 10 ) ; s2 . push_back ( y % 10 ) ; s1 . push_back ( x / 10 ) ; s1 . push_back ( x % 10 ) ; if ( s1 [ 0 ] == s2 [ 1 ] && s1 [ 1 ] == s2 [ 0 ] ) { cout << s1 [ 0 ] << s1 [ 1 ] << " : " << s2 [ 0 ] << s2 [ 1 ] << ' \n ' ; return 0 ; } } return 0 ; }
TAB0 function lcm with long long int arguments x and y that returns long long int ; TAB1 create new long long integer called i with value 1 ; TAB1 increment i in a loop , while i < = x ; TAB2 return y * i if ( y * i ) % x = 0 ; TAB1 define long long ints n , ans , k , i , res and j ; TAB1 read variable n from the input ; TAB1 if n < = 2 ; TAB2 print n ; TAB1 else ; TAB2 if n is odd ; TAB3 print n * ( n - 1 ) * ( n - 2 ) ; TAB2 else ; TAB3 change the value of ans to n * ( n - 1 ) ; TAB3 set i to 2 ; TAB3 set res to the result of lcm ( n - i , ans ) ; TAB3 change the value of k to res / ans ; TAB3 for j = n - i - 1 to k exclusive counting down ; TAB4 change the value of res to max of res and lcm ( j , ans ) ; TAB4 set the value of k to max of k and res / ans ; TAB3 print max of res and ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ;	long long int lcm ( long long int x , long long int y ) { long long int i = 1 ; for ( ; i <= x ; i ++ ) if ( ( y * i ) % x == 0 ) return y * i ; } int main ( ) { long long int n , ans , k , i , res , j ; cin >> n ; if ( n <= 2 ) cout << n << endl ; else { if ( n % 2 ) cout << ( n * ( n - 1 ) * ( n - 2 ) ) << endl ; else { ans = n * ( n - 1 ) ; i = 2 ; res = lcm ( n - i , ans ) ; k = res / ans ; for ( j = n - i - 1 ; j > k ; j -- ) { res = max ( res , lcm ( j , ans ) ) ; k = max ( k , res / ans ) ; } cout << max ( res , ( ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ) << endl ; } } return 0 ; }
TAB0 create const long long MOD = 1e9 + 7 ; TAB0 in function powmod return long long and accepting long long a , long long b , long long m = MOD ; TAB1 make long long r = 1 ; TAB1 while b greater than 0 ; TAB2 if b bitwise and 1 , set r to r * a % m ; TAB2 set a to a * a % m ; TAB2 bitwise shift b right by itself and 1 ; TAB1 return r ; TAB0 in function power returning long long and having long long a and long long b as parameters ; TAB1 create long long r = 1 ; TAB1 while b greater than 0 ; TAB2 if b bitwise and 1 , set r to r * a ; TAB2 set a to a * a ; TAB2 bitwise shift b right by itself and 1 ; TAB1 return r ; TAB0 in function gcd , taking long long a and long long b and returning long long ; TAB1 if not b , return a ; TAB1 return gcd ( b , a % b ) ; TAB0 in function inv , returning long long with parameters long long a , long long m = MOD ; TAB1 return powmod ( a , m - 2 , m ) ; TAB0 in function lcm with long long a and long long b as parameters and return type of long long ; TAB1 return ( a * b ) / gcd ( a , b ) ; TAB0 create map mmap of string to long long ; TAB0 in function init ; TAB1 set mmap [ " monday " ] to 0 ; TAB1 set mmap [ " tuesday " ] to 1 ; TAB1 set mmap [ " wednesday " ] to 2 ; TAB1 set mmap [ " thursday " ] to 3 ; TAB1 set mmap [ " friday " ] to 4 ; TAB1 set mmap [ " saturday " ] to 5 ; TAB1 set mmap [ " sunday " ] to 6 ; TAB1 call init ; TAB1 create string s1 and s2 ; TAB1 read s1 and s2 ; TAB1 create long longs n1 = mmap [ s1 ] and n2 = mmap [ s2 ] ; TAB1 if ( ( n1 + 31 ) % 7 equals n2 ) or ( ( n1 + 30 ) % 7 equals n2 ) or ( ( n1 + 28 ) % 7 equals n2 ) ; TAB2 print " YES " ; TAB3 newline ; TAB1 else ; TAB2 print " NO " ; TAB3 newline ;	const long long MOD = 1e9 + 7 ; long long powmod ( long long a , long long b , long long m = MOD ) { long long r = 1 ; while ( b > 0 ) { if ( b & 1 ) r = r * a % m ; a = a * a % m ; b >>= 1 ; } return r ; } long long power ( long long a , long long b ) { long long r = 1 ; while ( b > 0 ) { if ( b & 1 ) r = r * a ; a = a * a ; b >>= 1 ; } return r ; } long long gcd ( long long a , long long b ) { if ( ! b ) return a ; return gcd ( b , a % b ) ; } long long inv ( long long a , long long m = MOD ) { return powmod ( a , m - 2 , m ) ; } long long lcm ( long long a , long long b ) { return ( a * b ) / gcd ( a , b ) ; } map < string , long long > mmap ; void init ( ) { mmap [ " monday " ] = 0 ; mmap [ " tuesday " ] = 1 ; mmap [ " wednesday " ] = 2 ; mmap [ " thursday " ] = 3 ; mmap [ " friday " ] = 4 ; mmap [ " saturday " ] = 5 ; mmap [ " sunday " ] = 6 ; } int main ( ) { init ( ) ; string s1 , s2 ; cin >> s1 >> s2 ; long long n1 = mmap [ s1 ] , n2 = mmap [ s2 ] ; if ( ( ( n1 + 31 ) % 7 == n2 ) || ( ( n1 + 30 ) % 7 == n2 ) | ( ( n1 + 28 ) % 7 == n2 ) ) { cout << " YES " << " \n " ; } else { cout << " NO " << " \n " ; } }
TAB0 integer as n , k , a , ans = 1 , tmp ; TAB1 read n ; TAB1 if n is true do the following ; TAB2 read k , a ; TAB2 if a is 1 then do the following ; TAB3 set tmp to k + 1 ; TAB2 else ; TAB3 set tmp to k ; TAB3 if a is greater than 1 then do the following ; TAB4 set a to ( a - 1 ) / 4 + 1 ; TAB4 add one to ; TAB2 if ans is less than tmp then do the following ans = tmp ; TAB1 output ans ;	int n , k , a , ans = 1 , tmp ; int main ( ) { cin >> n ; while ( n -- ) { cin >> k >> a ; if ( a == 1 ) tmp = k + 1 ; else { tmp = k ; while ( a > 1 ) { a = ( a - 1 ) / 4 + 1 ; ++ tmp ; } } if ( ans < tmp ) ans = tmp ; } cout << ans << endl ; return 0 ; }
TAB1 declare integer variable n ; TAB1 declare int sum = 0 ; TAB1 declare integer variable npos = 0 ; TAB1 declare int variable nneg = 0 ; TAB1 let x be 2d integer array with size 100 by 2 ; TAB1 read input to n ; TAB1 for i = 0 to n exclusive ; TAB2 for j from 0 to 2 exclusive , read x [ i ] [ j ] ; TAB1 for i from 0 to n exclusive ; TAB2 if x [ i ] [ 0 ] is greater than 0 ; TAB3 increment npos ; TAB2 else ; TAB3 increment nneg ; TAB1 for i from 0 to n - 1 exclusive ; TAB2 for integer j = i + 1 to n exclusive ; TAB3 if x [ i ] [ 0 ] is greater than x [ j ] [ 0 ] ; TAB4 declare integer variables auxp and auxc ; TAB4 change auxp to x [ i ] [ 0 ] ; TAB4 change x [ i ] [ 0 ] to x [ j ] [ 0 ] ; TAB4 change x [ j ] [ 0 ] to auxp ; TAB4 set auxc to x [ i ] [ 1 ] ; TAB4 assign x [ j ] [ 1 ] to x [ i ] [ 1 ] ; TAB4 set x [ j ] [ 1 ] to auxc ; TAB1 if npos is greater than nneg ; TAB2 loop i from 0 to 2 * nneg + 1 exclusive , change sum to sum + x [ i ] [ 1 ] ; TAB1 else if npos is less than nneg ; TAB2 for i from n - ( 2 * npos + 1 ) to n exclusive , change sum to sum + x [ i ] [ 1 ] ; TAB1 else ; TAB2 loop i from 0 to n exclusive , set sum to sum + x [ i ] [ 1 ] ; TAB1 print sum ;	int main ( ) { int n ; int sum = 0 ; int npos = 0 ; int nneg = 0 ; int x [ 100 ] [ 2 ] ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { cin >> x [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] [ 0 ] > 0 ) { npos ++ ; } else { nneg ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( x [ i ] [ 0 ] > x [ j ] [ 0 ] ) { int auxp , auxc ; auxp = x [ i ] [ 0 ] ; x [ i ] [ 0 ] = x [ j ] [ 0 ] ; x [ j ] [ 0 ] = auxp ; auxc = x [ i ] [ 1 ] ; x [ i ] [ 1 ] = x [ j ] [ 1 ] ; x [ j ] [ 1 ] = auxc ; } } } if ( npos > nneg ) { for ( int i = 0 ; i < ( 2 * nneg + 1 ) ; i ++ ) { sum = sum + x [ i ] [ 1 ] ; } } else if ( npos < nneg ) { for ( int i = ( n - ( 2 * npos + 1 ) ) ; i < n ; i ++ ) { sum = sum + x [ i ] [ 1 ] ; } } else { for ( int i = 0 ; i < n ; i ++ ) { sum = sum + x [ i ] [ 1 ] ; } } cout << sum << endl ; return 0 ; }
TAB0 let n , L , a be integers ; TAB1 read n , L , a ; TAB1 result be an unsigned integer equals 0 ; TAB1 integers prevbeg , prevlen equals 0 ; TAB1 for currcase = 0 to n exclusive ; TAB2 begin , length be integers ; TAB2 read begin , length ; TAB2 if currcase not equals 0 ; TAB3 integer breaktime equals begin - ( prevbeg + prevlen ) ; TAB3 increase result by floor ( breaktime / a ) ; TAB2 else ; TAB3 increase result by floor ( begin / a ) ; TAB2 prevbeg equals begin ; TAB2 prevlen equals length ; TAB1 integer lastbreaktime = L - ( prevbeg + prevlen ) ; TAB1 increase result by floor ( lastbreaktime / a ) ; TAB1 print result and endline ;	int n , L , a ; int main ( ) { cin >> n >> L >> a ; unsigned int result = 0 ; int prevbeg = 0 , prevlen = 0 ; for ( int currcase = 0 ; currcase < n ; ++ currcase ) { int begin , length ; cin >> begin >> length ; if ( currcase != 0 ) { int breaktime = begin - ( prevbeg + prevlen ) ; result += floor ( breaktime / a ) ; } else { result += floor ( begin / a ) ; } prevbeg = begin ; prevlen = length ; } int lastbreaktime = L - ( prevbeg + prevlen ) ; result += floor ( lastbreaktime / a ) ; cout << result << endl ; return 0 ; }
TAB1 create long long ints n and d ; TAB1 read n and d ; TAB1 create long long vector v of size n ; TAB1 for i = 0 to n exclusive , read v [ i ] ; TAB1 create unsigned long long ans = 0 ; TAB1 let long long int j = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 while j is less than n and v [ j ] - v [ i ] is less than or equal to d , increment j ; TAB2 set ans to ans + ( j - i - 1 ) * ( j - i - 2 ) / 2 ; TAB1 display ans ;	int main ( ) { long long n , d ; cin >> n >> d ; vector < long long > v ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> v [ i ] ; } unsigned long long ans = 0 ; long long j = 0 ; for ( long long i = 0 ; i < n ; i ++ ) { while ( j < n && v [ j ] - v [ i ] <= d ) j ++ ; ans += ( j - i - 1 ) * ( j - i - 2 ) / 2 ; } cout << ans << " \n " ; }
TAB0 MAXN = const integer with MAXN = 1e6 + 10 ; TAB0 INF = const integer with INF = 1e9 + 7 ; TAB0 res , a , ans = strings with a = array of size 110 ; TAB0 lt = character ; TAB0 isU , vis = bool array of size 110 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 for j = 0 to a [ i ] . length ( ) exclusive ; TAB3 if ( isupper ( a [ i ] [ j ] ) ) , a [ i ] [ j ] = a [ i ] [ j ] - A - a ; TAB1 read res ; TAB1 ans = res ; TAB1 for i = 0 to res . length ( ) exclusive ; TAB2 if ( isupper ( res [ i ] ) ) ; TAB3 res [ i ] = res [ i ] - A - a ; TAB3 isU [ i ] = 1 ; TAB1 read lt ; TAB1 for i = 0 to res . length ( ) exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if ( res [ i ] = is a [ j ] [ 0 ] ) ; TAB4 k = integer ; TAB4 for k = 0 to a [ j ] . length ( ) exclusive ; TAB5 if ( res [ i + k ] is not a [ j ] [ k ] ) , break loop ; TAB4 if ( k is a [ j ] . length ( ) ) ; TAB5 for k = 0 to a [ j ] . length ( ) exclusive ; TAB6 if ( vis [ i + k ] ) , continue next iteration ; TAB6 if ( res [ i + k ] is not lt ) ; TAB7 ans [ i + k ] = if isU [ i + k ] , lt - a + A else lt ; TAB6 else ; TAB7 for L = a to z ; TAB8 if ( res [ i + k ] is not L ) ; TAB9 ans [ i + k ] = if isU [ i + k ] , L - a + A else L ; TAB9 break loop ; TAB6 vis [ i + k ] = 1 ; TAB1 print ans ;	const int MAXN = 1e6 + 10 ; const int INF = 1e9 + 7 ; string res , a [ 110 ] , ans ; char lt ; bool isU [ 110 ] , vis [ 110 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; for ( int j = 0 ; j < a [ i ] . length ( ) ; j ++ ) if ( isupper ( a [ i ] [ j ] ) ) a [ i ] [ j ] -= ' A ' - ' a ' ; } cin >> res ; ans = res ; for ( int i = 0 ; i < res . length ( ) ; i ++ ) if ( isupper ( res [ i ] ) ) { res [ i ] -= ' A ' - ' a ' ; isU [ i ] = 1 ; } cin >> lt ; for ( int i = 0 ; i < res . length ( ) ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( res [ i ] == a [ j ] [ 0 ] ) { int k ; for ( k = 0 ; k < a [ j ] . length ( ) ; k ++ ) if ( res [ i + k ] != a [ j ] [ k ] ) break ; if ( k == a [ j ] . length ( ) ) for ( k = 0 ; k < a [ j ] . length ( ) ; k ++ ) { if ( vis [ i + k ] ) continue ; if ( res [ i + k ] != lt ) ans [ i + k ] = isU [ i + k ] ? lt - ' a ' + ' A ' : lt ; else for ( int L = ' a ' ; L <= ' z ' ; L ++ ) if ( res [ i + k ] != L ) { ans [ i + k ] = isU [ i + k ] ? L - ' a ' + ' A ' : L ; break ; } vis [ i + k ] = 1 ; } } cout << ans << endl ; return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 if n equals 1 ; TAB2 print - 1 and newline ; TAB1 else ; TAB2 print n space n and newline ;	int main ( ) { int n ; cin >> n ; if ( n == 1 ) { cout << - 1 << endl ; } else { cout << n << "   " << n << endl ; } return 0 ; }
TAB1 n , k , sub = int ; TAB1 t = string ; TAB1 read n then k then t ; TAB1 for i = 0 to n ; TAB2 if substring of t starting at position 0 and a length of i is substring of t starting at position n - i and a length of i then set sub to i ; TAB1 for i = 1 to k print substring of t starting at position 0 and the length of n - sub ; TAB1 print t ;	int main ( ) { int n , k , sub ; string t ; cin >> n >> k >> t ; for ( int i = 0 ; i < n ; i ++ ) { if ( t . substr ( 0 , i ) == t . substr ( n - i , i ) ) sub = i ; } for ( int i = 1 ; i < k ; i ++ ) cout << t . substr ( 0 , n - sub ) ; cout << t << endl ; return 0 ; }
TAB0 create new constant integer N with value 5e2 + 7 ; TAB0 xinc is a new int array filled with 0 , 0 , 1 , - 1 ; TAB0 yinc is a new int array with elements 1 , - 1 , 0 , 0 ; TAB0 create integers n , m , x and y ; TAB0 declare double variables w and ans , and double array a with N elements ; TAB0 solve is a void function ; TAB1 set output decimal flag to fixed and precision to 15 ; TAB1 read user input to n and m ; TAB1 for integer i = 1 to n inclusive , read standard input to a [ i ] ; TAB1 start for loop from i = 0 to m exclusive ; TAB2 read user input to x , y and w ; TAB2 set ans to max of ans and ( a [ x ] + a [ y ] ) / w ; TAB1 print ans and ' \ n ' to the standard output ; TAB1 create new integer called t ; TAB1 change t to 1 ; TAB1 decrement t and loop further , while t is not 0 ;	const int N = 5e2 + 7 ; const int xinc [ ] = { 0 , 0 , 1 , - 1 } ; const int yinc [ ] = { 1 , - 1 , 0 , 0 } ; int n , m , x , y ; double a [ N ] , w , ans ; void solve ( ) { cout << fixed << setprecision ( 15 ) ; cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < m ; i ++ ) { cin >> x >> y >> w ; ans = max ( ans , ( a [ x ] + a [ y ] ) / w ) ; } cout << ans << ' \n ' ; } int main ( ) { int t ; t = 1 ; while ( t -- ) solve ( ) ; return 0 ; }
TAB1 a = double double ; TAB1 read a ; TAB1 if a < = 127 ; TAB2 print byte ; TAB1 else if a < = 32767 ; TAB2 print short ; TAB1 else if a < = 2147483647 ; TAB2 print int ; TAB1 else if a < = 9223372036854775807 ; TAB2 print long ; TAB1 else ; TAB2 print BigInteger ;	int main ( ) { long double a ; cin >> a ; if ( a <= 127 ) cout << " byte " << endl ; else if ( a <= 32767 ) cout << " short " << endl ; else if ( a <= 2147483647 ) cout << " int " << endl ; else if ( a <= 9223372036854775807 ) cout << " long " << endl ; else cout << " BigInteger " << endl ; return 0 ; }
TAB0 N , INF = const integers with N = 3e2 + 10 , INF = 1e9 ; TAB0 n , ans = integers ; TAB0 second = string ; TAB1 read n , second ; TAB1 for i = 0 to n exclusive ; TAB2 if second [ i ] is < ; TAB3 increment ans ; TAB2 else ; TAB3 break loop ; TAB1 for i = ( n - 1 ) down to 0 ; TAB2 if second [ i ] is > ; TAB3 increment ans ; TAB2 else ; TAB3 break loop ; TAB1 print ans ;	const int N = 3e2 + 10 , INF = 1e9 ; int n , ans ; string second ; int main ( ) { cin >> n >> second ; for ( int i = 0 ; i < n ; i ++ ) if ( second [ i ] == ' < ' ) ans ++ ; else break ; for ( int i = ( n - 1 ) ; i >= 0 ; i -- ) if ( second [ i ] == ' > ' ) ans ++ ; else break ; cout << ans << ' \n ' ; return 0 ; }
TAB0 let M be a constant integer with M = 1e5 + 10 ; TAB0 let N be a constant integer with N = 1000 ; TAB0 let cur be a string ; TAB0 let ispal be a function that accepts integers x , y and returns a integer ; TAB1 if x / 10 is equal to y modulo 10 ; TAB2 if x modulo 10 is equal to y / 10 , return 1 ; TAB1 while read cur ; TAB2 let h , m , ans be integers with ans = 0 ; TAB2 h is equal to ( cur [ 0 ] - 0 ) * 10 + ( cur [ 1 ] - 0 ) ; TAB2 m is equal to ( cur [ 3 ] - 0 ) * 10 + ( cur [ 4 ] - 0 ) ; TAB2 while not ispal ( h , m ) ; TAB3 increment m by 1 ; TAB3 increment ans by 1 ; TAB3 if m is equal to 60 ; TAB4 m is equal to 0 ; TAB4 increment h by 1 ; TAB4 if h is equal to 24 , h is equal to 0 ; TAB2 print ans and new line ;	const int M = 1e5 + 10 ; const int N = 1000 ; string cur ; int ispal ( int x , int y ) { if ( x / 10 == y % 10 ) { if ( x % 10 == y / 10 ) return 1 ; } return 0 ; } int main ( ) { while ( cin >> cur ) { int h , m , ans = 0 ; h = ( cur [ 0 ] - ' 0 ' ) * 10 + ( cur [ 1 ] - ' 0 ' ) ; m = ( cur [ 3 ] - ' 0 ' ) * 10 + ( cur [ 4 ] - ' 0 ' ) ; while ( ! ispal ( h , m ) ) { m ++ ; ans ++ ; if ( m == 60 ) { m = 0 ; h ++ ; if ( h == 24 ) h = 0 ; } } cout << ans << endl ; } return 0 ; }
TAB1 declare integer variables x , t , a , b , da and db ; TAB1 read input to x , t , a , b , da and db ; TAB1 in a for loop , change i from 0 to t exclusive ; TAB2 for j from 0 to t exclusive incrementing j ; TAB3 declare integer pa with value a - da * i ; TAB3 declare new integer called pb = b - db * j ; TAB3 if any of pa + pb , pa , pb = x or x = 0 ; TAB4 print " YES " and ' \ n ' to the stdout ; TAB1 print " NO " and ' \ n ' to the output ;	int main ( ) { int x , t , a , b , da , db ; cin >> x >> t >> a >> b >> da >> db ; for ( int i = 0 ; i < t ; ++ i ) { for ( int j = 0 ; j < t ; ++ j ) { int pa = a - da * i ; int pb = b - db * j ; if ( pa + pb == x || pa == x || pb == x || 0 == x ) { cout << " YES " << ' \n ' ; return 0 ; } } } cout << " NO " << ' \n ' ; return 0 ; }
TAB1 declare integer array N size 2 ; TAB1 for i = 0 to 2 exclusive ; TAB2 declare character array str size 100 ; TAB2 read str ; TAB2 if string compare between str and " monday " is 0 ; TAB3 let N [ i ] be 1 ; TAB2 else if string compare between str and " tuesday " is 0 ; TAB3 let N [ i ] be 2 ; TAB2 else if string compare between str and " wednesday " is 0 ; TAB3 let N [ i ] be 3 ; TAB2 else if string compare between str and " thursday " is 0 ; TAB3 let N [ i ] be 4 ; TAB2 else if string compare between str and " friday " is 0 ; TAB3 let N [ i ] be 5 ; TAB2 else if string compare between str and " saturday " is 0 ; TAB3 let N [ i ] be 6 ; TAB2 else if string compare between str and " sunday " is 0 ; TAB3 let N [ i ] be 7 ; TAB1 declare integer array arr size 11 = { 3 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 2 } ; TAB1 declare integer t = N [ 1 ] - N [ 0 ] ; TAB1 if t is less than 0 , increment t by 7 ; TAB1 declare integer flag = 0 ; TAB1 for i = 0 to 11 exclusive ; TAB2 if t is arr [ i ] , let flag be 1 ; TAB1 if flag is true ; TAB2 print " YES " , newline ; TAB1 else ; TAB2 print " NO " , newline ;	int main ( ) { int N [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { char str [ 100 ] ; cin >> str ; if ( strcmp ( str , " monday " ) == 0 ) N [ i ] = 1 ; else if ( strcmp ( str , " tuesday " ) == 0 ) N [ i ] = 2 ; else if ( strcmp ( str , " wednesday " ) == 0 ) N [ i ] = 3 ; else if ( strcmp ( str , " thursday " ) == 0 ) N [ i ] = 4 ; else if ( strcmp ( str , " friday " ) == 0 ) N [ i ] = 5 ; else if ( strcmp ( str , " saturday " ) == 0 ) N [ i ] = 6 ; else if ( strcmp ( str , " sunday " ) == 0 ) N [ i ] = 7 ; } int arr [ 11 ] = { 3 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 2 } ; int t = N [ 1 ] - N [ 0 ] ; if ( t < 0 ) t += 7 ; int flag = 0 ; for ( int i = 0 ; i < 11 ; i ++ ) { if ( t == arr [ i ] ) flag = 1 ; } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 x = integer 2d array of [ 5 ] [ 5 ] ; TAB1 f = bool with f = false ; TAB1 for i = 1 to 4 ; TAB2 for j = 1 to 4 , read x [ i ] [ j ] ; TAB1 for i = 1 to 4 ; TAB2 if x [ i ] [ 4 ] ; TAB3 for i = 1 to 3 ; TAB4 if x [ i ] [ j ] , f = true ; ; TAB3 for j = 1 to 3 ; TAB4 p = integer with p = i + j ; TAB4 if p > 4 , p = p - 4 ; TAB4 if x [ p ] [ j ] , f = true ; TAB1 if f ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int main ( ) { int x [ 5 ] [ 5 ] ; bool f = false ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { cin >> x [ i ] [ j ] ; } } for ( int i = 1 ; i <= 4 ; i ++ ) { if ( x [ i ] [ 4 ] ) { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( x [ i ] [ j ] ) f = true ; } for ( int j = 1 ; j <= 3 ; j ++ ) { int p = i + j ; if ( p > 4 ) p -= 4 ; if ( x [ p ] [ j ] ) f = true ; } } } if ( f ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 let a , b , and s ints ; TAB1 read a , b , and s ; TAB1 set a to absolute value of a ; TAB1 set b to absolute value of b ; TAB1 if s < a + b or s - a - b is odd ; TAB2 print No ; TAB1 otherwise ; TAB2 print Yes ;	int main ( ) { int a , b , s ; cin >> a >> b >> s ; a = abs ( a ) ; b = abs ( b ) ; if ( s < ( a + b ) || ( s - a - b ) % 2 == 1 ) { cout << " No " << endl ; } else { cout << " Yes " << endl ; } return 0 ; }
TAB1 make ints n and t ; TAB1 read n and t ; TAB1 create string s ; TAB1 read s ; TAB1 make integer i = 0 ; TAB1 while i is less than n and s [ i ] is not equal to ' . ' , increment i ; TAB1 if i is not equal to n and t is greater than 0 ; TAB2 make integer p = i ; TAB2 increment i ; TAB2 while i is less than n and s [ i ] is less than ' 5 ' , add 1 to i ; TAB2 if i is not equal to n ; TAB3 set s to s . substr ( 0 , i ) ; TAB3 subtract 1 from i ; TAB3 add 1 to s [ i ] ; TAB3 take away 1 from t ; TAB3 decrease i by 1 ; TAB3 while i is greater than p , s [ i + 1 ] is more than ' 4 ' , and t is greater than 0 ; TAB4 increment s [ i ] ; TAB4 set s [ i + 1 ] to ' 0 ' ; TAB4 decrease t by 1 ; TAB4 decrease i by 1 ; TAB3 if s [ i + 1 ] is equal to ' / ' ; TAB4 set s to s . substr ( 0 , i + 1 ) ; TAB4 while i is greater than or equal to 0 and s [ i ] is equal to ' 9 ' ; TAB5 set s [ i ] to ' 0 ' ; TAB5 decrease i by 1 ; TAB4 if i is not equal to - 1 ; TAB5 increment s [ i ] ; TAB4 else ; TAB5 output 1 ; TAB3 else if i is equal to p , s [ p + 1 ] is greater than ' 4 ' , and t is greater than 0 ; TAB4 take away 1 from t ; TAB4 set s to s . substr ( 0 , i ) ; TAB4 decrease i by 1 ; TAB4 while i is greater than or equal to 0 and s [ i ] is equal to ' 9 ' ; TAB5 set s [ i ] to ' 0 ' ; TAB5 reduce i by 1 ; TAB4 if i not equal to - 1 ; TAB5 increment s [ i ] by 1 ; TAB4 else do ; TAB5 print 1 ; TAB3 otherwise ; TAB4 set s to s . substr ( 0 , i + 2 ) ; TAB1 print s ;	int main ( ) { int n , t ; cin >> n >> t ; string s ; cin >> s ; int i = 0 ; while ( i < n && s [ i ] != ' . ' ) { i ++ ; } if ( i != n && t > 0 ) { int p = i ; i ++ ; while ( i < n && s [ i ] < ' 5 ' ) { i ++ ; } if ( i != n ) { s = s . substr ( 0 , i ) ; i -- ; s [ i ] ++ ; t -- ; i -- ; while ( i > p && s [ i + 1 ] > ' 4 ' && t > 0 ) { s [ i ] ++ ; s [ i + 1 ] = ' 0 ' ; t -- ; i -- ; } if ( s [ i + 1 ] == ' / ' ) { s = s . substr ( 0 , i + 1 ) ; while ( i >= 0 && s [ i ] == ' 9 ' ) { s [ i ] = ' 0 ' ; i -- ; } if ( i != - 1 ) { s [ i ] ++ ; } else { cout << 1 ; } } else if ( i == p && s [ p + 1 ] > ' 4 ' && t > 0 ) { t -- ; s = s . substr ( 0 , i ) ; i -- ; while ( i >= 0 && s [ i ] == ' 9 ' ) { s [ i ] = ' 0 ' ; i -- ; } if ( i != - 1 ) { s [ i ] ++ ; } else { cout << 1 ; } } else { s = s . substr ( 0 , i + 2 ) ; } } } cout << s << ' \n ' ; }
TAB0 declare ok with string t as argument , returning boolean ; TAB1 declare integer msk = 0 ; TAB1 for i = 0 to integer casted size of t exclusive ; TAB2 if t [ i ] is upper case , let msk be msk bitwise or 1 ; TAB2 if t [ i ] is lower case , let msk be msk bitwise or 2 ; TAB2 if t [ i ] is digit , let msk be msk bitwise or 4 ; TAB1 return mks is 7 ; TAB1 declare integer t ; TAB1 declare string s ; TAB1 read t ; TAB1 for i = 0 to t exclusive ; TAB2 read s ; TAB2 if result of run ok ( s ) is true ; TAB3 print s and newline ; TAB3 end current loop iteration ; TAB2 declare boolean fnd = false ; TAB2 for i = 0 to integer casted size of s exclusive ; TAB3 deeclare string t = s ; TAB3 let t [ i ] be ' 1 ' ; TAB3 if result of run ok ( t ) is true ; TAB4 print t , newline ; TAB4 let fnd be true ; TAB4 end loop ; TAB3 let t [ i ] be ' a ' ; TAB3 if result of run ok ( t ) is true ; TAB4 print t , newline ; TAB4 let fnd be true ; TAB4 end loop ; TAB3 let t [ i ] be ' A ' ; TAB3 if result of run ok ( t ) is true ; TAB4 print t , newline ; TAB4 let fnd be true ; TAB4 end loop ; TAB2 if fnd is true , end loop iteration ; TAB2 if s [ 2 ] is upper case ; TAB3 let s [ 0 ] be ' a ' ; TAB3 let s [ 1 ] be ' 1 ' ; TAB3 print s , newline ; TAB3 end loop iteration ; TAB2 if s [ 2 ] is lower case ; TAB3 let s [ 0 ] be ' A ' ; TAB3 let s [ 1 ] be ' 1 ' ; TAB3 print s , newline ; TAB3 end loop iteration ; TAB2 if s [ 2 ] is digit ; TAB3 let s [ 0 ] be ' a ' ; TAB3 let s [ 1 ] be ' A ' ; TAB3 print s , newline ; TAB3 end loop iteration ;	bool ok ( string t ) { int msk = 0 ; for ( int i = 0 ; i < int ( t . size ( ) ) ; ++ i ) { if ( isupper ( t [ i ] ) ) msk |= 1 ; if ( islower ( t [ i ] ) ) msk |= 2 ; if ( isdigit ( t [ i ] ) ) msk |= 4 ; } return msk == 7 ; } int main ( ) { int t ; string s ; cin >> t ; for ( int i = 0 ; i < t ; ++ i ) { cin >> s ; if ( ok ( s ) ) { cout << s << endl ; continue ; } bool fnd = false ; for ( int i = 0 ; i < int ( s . size ( ) ) ; ++ i ) { string t = s ; t [ i ] = ' 1 ' ; if ( ok ( t ) ) { cout << t << endl ; fnd = true ; break ; } t [ i ] = ' a ' ; if ( ok ( t ) ) { cout << t << endl ; fnd = true ; break ; } t [ i ] = ' A ' ; if ( ok ( t ) ) { cout << t << endl ; fnd = true ; break ; } } if ( fnd ) continue ; if ( isupper ( s [ 2 ] ) ) { s [ 0 ] = ' a ' ; s [ 1 ] = ' 1 ' ; cout << s << endl ; continue ; } if ( islower ( s [ 2 ] ) ) { s [ 0 ] = ' A ' ; s [ 1 ] = ' 1 ' ; cout << s << endl ; continue ; } if ( isdigit ( s [ 2 ] ) ) { s [ 0 ] = ' a ' ; s [ 1 ] = ' A ' ; cout << s << endl ; continue ; } } }
TAB1 declare long longs N , M , K ; TAB1 while read N , M , and K ; TAB2 ans is a long long with ans initialized to 0 ; TAB2 set ans to call max with arguments N / ( K + 1 ) * M , M / ( K + 1 ) * N ; TAB2 if K + 1 is greater than N , set ans to call max with arguments ans , M / ( K - N + 2 ) ; TAB2 if K + 1 is greater than M , set ans to call max with arguments ans , N / ( K - M + 2 ) ; TAB2 if K + 2 is greater than M + N , set ans to - 1 ; TAB2 display ans ;	int main ( ) { long long N , M , K ; while ( cin >> N >> M >> K ) { long long ans = 0 ; ans = max ( N / ( K + 1 ) * M , M / ( K + 1 ) * N ) ; if ( K + 1 > N ) ans = max ( ans , M / ( K - N + 2 ) ) ; if ( K + 1 > M ) ans = max ( ans , N / ( K - M + 2 ) ) ; if ( K + 2 > M + N ) ans = - 1 ; cout << ans << endl ; } return 0 ; }
TAB0 declare character array a with size 1204000 ; TAB1 loop when read input to a ; TAB2 create int array A with 1204 elements ; TAB2 declare integer ans = 0 ; TAB2 declare integer r = 0 ; TAB2 declare integer flag = 0 ; TAB2 declare integer p = 0 ; TAB2 for i from 0 to exclusive incrementing i ; TAB3 if a [ i ] is ' ? ' ; TAB4 if flag is false ; TAB5 change A [ r ] to 1 ; TAB5 increment r ; TAB5 increment p ; TAB4 if flag is true ; TAB5 assign - 1 to A [ r ] ; TAB5 increment r ; TAB5 decrement p ; TAB3 if a [ i ] is ' - ' , change flag to 1 ; TAB3 if a [ i ] is ' + ' , change flag to 0 ; TAB3 if a [ i ] > = ' 0 ' and a [ i ] < = ' 9 ' , change n to n * 10 + a [ i ] - ' 0 ' ; TAB2 loop i from 0 to r exclusive incrementing i ; TAB3 if A [ i ] is less than 0 ; TAB4 if p is greater than n ; TAB5 looping infinitely ; TAB6 if absolute value pf A [ i ] > = n or p = n , stop the loop ; TAB6 decrement A [ i ] ; TAB6 decrement p ; TAB3 else if A [ i ] is greater than 0 ; TAB4 if p is less than n ; TAB5 in the infinite loop ; TAB6 if A [ i ] > = n or p = n , stop the loop ; TAB6 increment A [ i ] ; TAB6 increment p by one ; TAB2 if p ! = n ; TAB3 print " Impossible " ; TAB2 else ; TAB3 print " Possible " ; TAB3 if A [ 0 ] is greater than 0 ; TAB4 print A [ 0 ] ; TAB3 else ; TAB4 print A [ 0 ] ; TAB3 for i = 1 to r exclusive ; TAB4 print " " ; TAB4 if A [ i ] is greater than 0 ; TAB5 print " + " ; TAB4 else ; TAB5 print " - " ; TAB4 print " " and absolute value of A [ i ] ; TAB3 print " = " and n ;	char a [ 1204000 ] = { } ; int main ( ) { while ( gets ( a ) ) { int A [ 1204 ] = { } ; int n = 0 ; int r = 0 ; int flag = 0 ; int p = 0 ; for ( int i = 0 ; a [ i ] ; i ++ ) { if ( a [ i ] == ' ? ' ) { if ( ! flag ) { A [ r ] = 1 ; r ++ ; p ++ ; } if ( flag ) { A [ r ] = - 1 ; r ++ ; p -- ; } } if ( a [ i ] == ' - ' ) flag = 1 ; if ( a [ i ] == ' + ' ) flag = 0 ; if ( a [ i ] >= ' 0 ' && a [ i ] <= ' 9 ' ) { n = n * 10 + a [ i ] - ' 0 ' ; } } for ( int i = 0 ; i < r ; i ++ ) { if ( A [ i ] < 0 ) { if ( p > n ) { while ( 1 ) { if ( abs ( A [ i ] ) >= n || p == n ) { break ; } A [ i ] -- ; p -- ; } } } else if ( A [ i ] > 0 ) { if ( p < n ) { while ( 1 ) { if ( ( A [ i ] >= n || p == n ) ) { break ; } A [ i ] ++ ; p ++ ; } } } } if ( p != n ) { cout << " Impossible " << endl ; } else { cout << " Possible " << endl ; if ( A [ 0 ] > 0 ) { cout << A [ 0 ] ; } else { cout << A [ 0 ] ; } for ( int i = 1 ; i < r ; i ++ ) { cout << "   " ; if ( A [ i ] > 0 ) { cout << " + " ; } else { cout << " - " ; } cout << "   " << abs ( A [ i ] ) ; } cout << "  =  " << n << endl ; } } return 0 ; }
TAB0 let lucky a vector of long longs ; TAB0 in function baktrack which takes long long x ; TAB1 if x > 1e10 , return ; TAB1 append x to lucky ; TAB1 apply backtrack to x * 10 + 4 ; TAB1 apply backtrack to x * 10 + 7 ; TAB1 let ans a long long with value 0 ; TAB1 apply backtrack to 0 ; TAB1 sort lucky ; TAB1 let a and b ints ; TAB1 read a and b ; TAB1 for i from 1 to ( int ) size of lucky exclusive ; TAB2 let l , r , and m ints ; TAB2 set l to a and r to b ; TAB2 while l at most r ; TAB3 right shift l + r by 1 and store result in m ; TAB3 if m at most lucky [ i ] ; TAB4 add lucky [ i ] * ( m - l + 1 ) to ans ; TAB4 set a to m + 1 ; TAB4 decrement i ; TAB4 leave loop ; TAB3 otherwise ; TAB4 set r to m - 1 ; TAB1 print ans ;	vector < long long > lucky ; void backtrack ( long long x ) { if ( x > 1e10 ) return ; lucky . push_back ( x ) ; backtrack ( x * 10 + 4 ) ; backtrack ( x * 10 + 7 ) ; } int main ( ) { long long ans = 0 ; backtrack ( 0 ) ; sort ( lucky . begin ( ) , lucky . end ( ) ) ; int a , b ; cin >> a >> b ; for ( int i = 1 ; i < ( int ) lucky . size ( ) ; i ++ ) { int l , r , m ; l = a , r = b ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( m <= lucky [ i ] ) { ans += lucky [ i ] * ( m - l + 1 ) ; a = m + 1 ; i -- ; break ; } else { r = m - 1 ; } } } cout << ans << " \n " ; return 0 ; }
TAB0 maxn = constant integer = 105 ; TAB0 a = integer array of size maxn ; TAB0 b = integer array of size maxn ; TAB0 vis = integer array of size maxn ; TAB1 n = integer ; TAB1 num = integer = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] , b [ i ] ; TAB1 set all element of vis to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if i is not j and b [ i ] is a [ j ] , then vis [ j ] = 1 ; TAB1 for i = 0 to n exclusive , then num = num + vis [ i ] ; TAB1 print n - num ;	const int maxn = 105 ; int a [ maxn ] ; int b [ maxn ] ; int vis [ maxn ] ; int main ( ) { int n ; int num = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } memset ( vis , 0 , sizeof ( vis ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && b [ i ] == a [ j ] ) vis [ j ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) num += vis [ i ] ; cout << n - num << endl ; return 0 ; }
TAB0 a = array of long integers of length 100005 , b = array of long integers of length 100005 , c = array of long integers of length 100005 ; TAB1 let n , sum , s be long integers ; TAB1 while read n ; TAB2 sum is equal to 0 ; TAB2 s is equal to 0 ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 a [ n ] is equal to 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if not ( i modulo 2 ) ; TAB4 b [ i ] is equal to absolute value of ( a [ i ] - a [ i + 1 ] ) ; TAB3 else do the following ; TAB4 b [ i ] = - absolute value of ( a [ i ] - a [ i + 1 ] ) ; TAB3 c [ i ] = - b [ i ] ; TAB2 for i = 0 to n - 1 exclusive ; TAB3 increment sum by b [ i ] ; TAB3 if sum is less than 0 , sum is equal to 0 ; TAB3 s is equal to maximum of sum and s ; TAB2 sum is equal to 0 ; TAB2 for i = 0 to n - 1 exclusive ; TAB3 increment sum by c [ i ] ; TAB3 if sum is less than 0 , sum is equal to 0 ; TAB3 s is equal to maximum of sum and s ; TAB2 print s and newline ;	long long a [ 100005 ] , b [ 100005 ] , c [ 100005 ] ; int main ( ) { long long n , sum , s ; while ( cin >> n ) { sum = 0 ; s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } a [ n ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) b [ i ] = abs ( a [ i ] - a [ i + 1 ] ) ; else b [ i ] = - abs ( a [ i ] - a [ i + 1 ] ) ; c [ i ] = - b [ i ] ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += b [ i ] ; if ( sum < 0 ) sum = 0 ; s = max ( sum , s ) ; } sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += c [ i ] ; if ( sum < 0 ) sum = 0 ; s = max ( sum , s ) ; } cout << s << endl ; } return 0 ; }
TAB0 maxn = const long long with maxn = 1e5 + 8 ; TAB0 t = string ; TAB0 vis = int array of size maxn ; TAB1 read t ; TAB1 len = int with len = size of t ; TAB1 if len is less than 4 ; TAB2 print " NO " ; TAB1 else ; TAB2 a , b , c , d = int ; TAB2 set a to find of " AB " on t ; TAB2 set b to find of " BA " and a + 2 of t ; TAB2 set c to find of " BA " on t ; TAB2 set d to find of " AB " and c + 2 of t ; TAB2 if a and b are not - 1 or c and d are not - 1 ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ;	const long long maxn = 1e5 + 8 ; string t ; int vis [ maxn ] ; int main ( ) { cin >> t ; int len = t . size ( ) ; if ( len <= 3 ) puts ( " NO " ) ; else { int a , b , c , d ; a = t . find ( " AB " ) ; b = t . find ( " BA " , a + 2 ) ; c = t . find ( " BA " ) ; d = t . find ( " AB " , c + 2 ) ; if ( ( a != - 1 && b != - 1 ) || ( c != - 1 && d != - 1 ) ) puts ( " YES " ) ; else puts ( " NO " ) ; } return 0 ; }
TAB0 declare long long integers p , q ; TAB0 declare long long integer array primes size 2100000 ; TAB0 declare long long integer pi size 2100000 ; TAB0 declare long long integer rub size 2100000 ; TAB0 declare integer ans ; TAB0 declare inv with integer x as argument , returning integer ; TAB1 declare integer ret = 0 ; TAB1 while x is not 0 ; TAB2 let ret be ret * 10 + x % 10 ; TAB2 let x be x / 10 ; TAB1 return ret from function ; TAB0 declare chk with integer x as argument , returning integer ; TAB1 if result of run inv ( x ) is x , return 1 ; TAB1 read p and q ; TAB1 declare integers i , j ; TAB1 for i = 2 to 2050000 inclusive , let primes [ i ] be 1 ; TAB1 for i = 2 to 2050000 inclusive ; TAB2 if primes [ i ] is 1 ; TAB3 for j = 2 to i * j is less than or equal to 2060000 , incrementing j , let primes [ i * j ] be 0 ; TAB1 for i = 2 to 2050000 inclusive , let pi [ i ] be pi [ i - 1 ] + primes [ i ] ; TAB1 for i = 1 to 2050000 inclusive , let rub [ i ] be rub [ i - 1 ] + result of run chk with i as argument ; TAB1 for i = 2050000 to 1 inclusive , decrementing i ; TAB2 if q * pi [ i ] is less than or equal to p * rub [ i ] ; TAB3 print i and newline ;	long long int p , q ; long long int primes [ 2100000 ] ; long long int pi [ 2100000 ] ; long long int rub [ 2100000 ] ; int ans ; int inv ( int x ) { int ret = 0 ; while ( x != 0 ) { ret = ret * 10 + x % 10 ; x = x / 10 ; } return ret ; } int chk ( int x ) { if ( inv ( x ) == x ) { return 1 ; } return 0 ; } int main ( ) { cin >> p >> q ; int i , j ; for ( i = 2 ; i <= 2050000 ; i ++ ) { primes [ i ] = 1 ; } for ( i = 2 ; i <= 2050000 ; i ++ ) { if ( primes [ i ] == 1 ) { for ( j = 2 ; i * j <= 2060000 ; j ++ ) { primes [ i * j ] = 0 ; } } } for ( i = 2 ; i <= 2050000 ; i ++ ) { pi [ i ] = pi [ i - 1 ] + primes [ i ] ; } for ( i = 1 ; i <= 2050000 ; i ++ ) { rub [ i ] = rub [ i - 1 ] + chk ( i ) ; } for ( i = 2050000 ; i >= 1 ; i -- ) { if ( q * pi [ i ] <= p * rub [ i ] ) { cout << i << endl ; return 0 ; } } }
TAB1 vetor = int vector ; TAB1 n , i , colunas = int ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 read colunas ; TAB2 append colunas to vetor ; TAB1 sort vetor ; TAB1 for i = 0 to n - 1 print vetor [ i ] then " " ; TAB1 print last element of vetor ;	int main ( ) { vector < int > vetor ; int n , i , colunas ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> colunas ; vetor . push_back ( colunas ) ; } sort ( vetor . begin ( ) , vetor . end ( ) ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { cout << vetor [ i ] << "   " ; } cout << vetor [ n - 1 ] << endl ; return 0 ; }
TAB0 declare constant long long integer MAXN = 1e4 + 5 ; TAB0 declare constant long long integer MINN = 1e2 ; TAB0 declare constant inf = ( 1e6 + 5 ) ; TAB0 declare it = 0 , k , k1 as integers ; TAB0 declare long long array a size MAXN , long long sum ; TAB0 declare create with long longs s , l as arguments , returning void ; TAB1 if l is greater than 0 , let a [ increment it ] be s ; TAB1 if l is less than 10 , run create with s * 10 + 4 , l + 1 as arguments ; TAB1 if l is less than 10 , run create ( s * 10 + 7 , l + 1 ) ; TAB1 return from function ; TAB1 run create ( 0 , 0 ) ; TAB1 sort from a to a + it ; TAB1 declare l , r as integers ; TAB1 read l and r ; TAB1 for i = 0 to ( it - 2 ) inclusive ; TAB2 if a [ i ] is greater than or equal to l ; TAB3 let k be i ; TAB3 end loop ; TAB1 for i = 0 to it - 2 inclusive ; TAB2 if a [ i ] is greater than or equal to r ; TAB3 let k1 be i ; TAB3 end loop ; TAB1 while k is not k1 ; TAB2 increment sum by a [ k ] * ( a [ k ] - l + 1 ) ; TAB2 let l be a [ k ] + 1 ; TAB2 increment k ; TAB1 increment sum by ( r - l + 1 ) * a [ k1 ] ; TAB1 print sum and newline ;	const long long int MAXN = 1e4 + 5 ; const long long int MINN = 1e2 ; const int inf = ( 1e6 + 5 ) ; int it = 0 , k , k1 ; long long a [ MAXN ] , sum ; void create ( long long s , int l ) { if ( l > 0 ) a [ it ++ ] = s ; if ( l < 10 ) create ( s * 10 + 4 , l + 1 ) ; if ( l < 10 ) create ( s * 10 + 7 , l + 1 ) ; return ; } int main ( ) { create ( 0 , 0 ) ; sort ( a , a + it ) ; int l , r ; cin >> l >> r ; for ( int i = 0 ; i <= ( it - 2 ) ; ++ i ) { if ( a [ i ] >= l ) { k = i ; break ; } } for ( int i = 0 ; i <= ( it - 2 ) ; ++ i ) { if ( a [ i ] >= r ) { k1 = i ; break ; } } while ( k != k1 ) { sum += a [ k ] * ( a [ k ] - l + 1 ) ; l = a [ k ] + 1 ; ++ k ; } sum += ( r - l + 1 ) * a [ k1 ] ; cout << sum << endl ; return 0 ; }
TAB0 let S be a string ; TAB0 let N , M , A , B , sum , x , y , and K be integers ; TAB0 let cek be an array of booleans of size 26 ; TAB1 read in N , A , and B ; TAB1 if B is less than N ; TAB2 print NO and a newline ; TAB1 else if B is equal to N + 1 ; TAB2 print NO and a newline ; TAB1 else if ( B - N ) % A is equal to 0 or ( B - N ) % A is equal to 1 ; TAB2 print YES and a newline ; TAB1 or else ; TAB2 print NO ;	string S ; int N , M , A , B , sum , x , y , K ; bool cek [ 26 ] ; int main ( ) { cin >> N >> A >> B ; if ( B < N ) cout << " NO\n " ; else if ( B == N + 1 ) cout << " NO\n " ; else if ( ( B - N ) % A == 0 || ( B - N ) % A == 1 ) cout << " YES\n " ; else cout << " NO\n " ; }
TAB0 declare long long array dp with length of 100005 ; TAB1 declare integer n ; TAB1 read n ; TAB1 declare long long array a with length of n ; TAB1 declare long long array b with length of n ; TAB1 declare long long array c with length of n ; TAB1 read n elements in a ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 set b [ i ] to abs of a [ i + 1 ] - a [ i ] ; TAB2 if i is odd , multiply b [ i ] by itself and - 1 ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 set c [ i ] to abs of a [ i + 1 ] - a [ i ] ; TAB2 if i is even , multiply c [ i ] by itself and - 1 ; TAB1 define long long ans with value b [ 0 ] ; TAB1 define long long minimum with value b [ 0 ] ; TAB1 for i = 1 to n - 1 exclusive ; TAB2 increase b [ i ] by b [ i - 1 ] ; TAB2 set ans to max of ans and b [ i ] - minimum ; TAB2 set ans to max of ans and b [ i ] ; TAB2 set minimum to min of minimum and b [ i ] ; TAB1 set minimum to c [ 0 ] ; TAB1 for i = 1 to n - 1 exclusive ; TAB2 add c [ i - 1 ] to c [ i ] ; TAB2 set ans to max of ans and c [ i ] - minimum ; TAB2 set ans to max of ans and c [ i ] ; TAB2 set minimum to min of minimum and c [ i ] ; TAB1 print ans ;	long long dp [ 100005 ] ; int main ( ) { int n ; cin >> n ; long long a [ n ] ; long long b [ n ] ; long long c [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { b [ i ] = abs ( a [ i + 1 ] - a [ i ] ) ; if ( i % 2 == 1 ) b [ i ] *= - 1 ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { c [ i ] = abs ( a [ i + 1 ] - a [ i ] ) ; if ( i % 2 == 0 ) c [ i ] *= - 1 ; } long long ans = b [ 0 ] ; long long minimum = b [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { b [ i ] += b [ i - 1 ] ; ans = max ( ans , b [ i ] - minimum ) ; ans = max ( ans , b [ i ] ) ; minimum = min ( minimum , b [ i ] ) ; } minimum = c [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { c [ i ] += c [ i - 1 ] ; ans = max ( ans , c [ i ] - minimum ) ; ans = max ( ans , c [ i ] ) ; minimum = min ( minimum , c [ i ] ) ; } cout << ans << endl ; return 0 ; }
TAB0 v = two dimensional int array of sizes 110 and 110 and visited = int array of size 110 with all values set to 0 and k = int array of size 110 ; TAB0 n , m = int ; TAB0 in function dfs taking int a ; TAB1 set visited [ a ] to 1 ; TAB1 for i = 1 to k [ a ] inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if visited [ j ] is 0 ; TAB4 for p = 1 to k [ j ] ; TAB5 if v [ j ] [ p ] is v [ a ] [ i ] call dfs of j ; TAB1 read n then m ; TAB1 sum , ans = int with sum = 0 and ans = 0 ; TAB1 i , j = int ; TAB1 for i = 1 to n inclusive ; TAB2 read k [ i ] ; TAB2 for j = 1 to k [ i ] inclusive ; TAB3 read v [ i ] [ j ] ; TAB3 increment sum by v [ i ] [ j ] ; TAB1 if sum is 0 ; TAB2 print n ; TAB1 for i = 1 to n inclusive ; TAB2 if visited [ i ] is 0 ; TAB3 increment ans ; TAB3 cal dfs of i ; TAB1 print ans - 1 ;	int v [ 110 ] [ 110 ] , visited [ 110 ] = { 0 } , k [ 110 ] ; int n , m ; void dfs ( int a ) { visited [ a ] = 1 ; for ( int i = 1 ; i <= k [ a ] ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( visited [ j ] == 0 ) for ( int p = 1 ; p <= k [ j ] ; p ++ ) if ( v [ j ] [ p ] == v [ a ] [ i ] ) dfs ( j ) ; } } } int main ( ) { cin >> n >> m ; int sum = 0 , ans = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { cin >> k [ i ] ; for ( j = 1 ; j <= k [ i ] ; j ++ ) { cin >> v [ i ] [ j ] ; sum = sum + v [ i ] [ j ] ; } } if ( sum == 0 ) { cout << n << endl ; return 0 ; } for ( i = 1 ; i <= n ; i ++ ) { if ( visited [ i ] == 0 ) { ans ++ ; dfs ( i ) ; } } cout << ans - 1 << endl ; return 0 ; }
TAB0 let M be a constant integer with M is equal to 1005 ; TAB1 let n be a integer ; TAB1 let x1 , y1 , x2 , y2 be integers ; TAB1 read n , x1 , y1 , x2 , y2 ; TAB1 integer disx = x1 - x2 if x1 is greater than x2 else disx = x2 - x1 ; TAB1 integer disy = y1 - y2 if y1 is greater than y2 else disy = y2 - y1 ; TAB1 let disx + disy is assigned to dis ; TAB1 if disx is equal to n , dis is equal to y1 + y2 + n ; TAB1 if disy is equal to n , dis is equal to x1 + x2 + n ; TAB1 if dis < = 2 * n ; TAB2 print dis and newline ; TAB1 else do the following ; TAB2 print 4 * n - dis and newline ;	const int M = 1000 + 5 ; int main ( ) { int n ; int x1 , y1 , x2 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; int disx = x1 > x2 ? x1 - x2 : x2 - x1 ; int disy = y1 > y2 ? y1 - y2 : y2 - y1 ; int dis = disx + disy ; if ( disx == n ) { dis = y1 + y2 + n ; } if ( disy == n ) { dis = x1 + x2 + n ; } if ( dis <= 2 * n ) { cout << dis << endl ; } else { cout << 4 * n - dis << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create map d from integer to integer ; TAB1 create integers q , w , a , s , z , x , with a = 0 , s = 0 , z = 0 , x = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read q read w ; TAB2 if q is less than 0 ; TAB3 set a to a + 1 ; TAB3 set s to s + w ; TAB2 if q is greater than 0 ; TAB3 set z to z + 1 ; TAB3 set x to x + w ; TAB2 insert new pair of integer , integer initialized with ( q , w ) into d ; TAB1 insert new pair of integer , integer initialized with ( 0 , 0 ) into d ; TAB1 create integer y with y = a ; TAB1 create integer sum with sum = 0 ; TAB1 if a is z ; TAB2 print s + x print newline ; TAB1 else if a is less than z ; TAB2 set sum to sum + s ; TAB2 create integer h with h = a + 1 ; TAB2 for b = first index of 0 in d to b is not end of d , incrementing b ; TAB3 if h is greater than or equal to 0 ; TAB4 create integer g with hg = second element of b ; TAB4 set sum to sum + g ; TAB3 else ; TAB4 break loop ; TAB3 decrement h ; TAB2 print sum print newline ; TAB1 else ; TAB2 set sum to sum + x ; TAB2 create integer h with h = z + 1 ; TAB2 for b = first index of 0 in d to b is not end of d , decrementing b ; TAB3 if h is greater than or equal to 0 ; TAB4 create integer g with g = second element of b ; TAB4 set sum to sum + g ; TAB3 else ; TAB4 break loop ; TAB3 decrement h ; TAB2 print sum print newline ;	int main ( ) { int n ; cin >> n ; map < int , int > d ; int q , w , a = 0 , s = 0 , z = 0 , x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> q >> w ; if ( q < 0 ) { a = a + 1 ; s = s + w ; } if ( q > 0 ) { z = z + 1 ; x = x + w ; } d . insert ( pair < int , int > ( q , w ) ) ; } d . insert ( pair < int , int > ( 0 , 0 ) ) ; int y = a ; int sum = 0 ; if ( a == z ) { cout << s + x << endl ; return 0 ; } else if ( a < z ) { sum = sum + s ; int h = a + 1 ; for ( map < int , int > :: iterator b = d . find ( 0 ) ; b != d . end ( ) ; b ++ ) { if ( h >= 0 ) { int g = b -> second ; sum = sum + g ; } else break ; -- h ; } cout << sum << endl ; return 0 ; } else { sum = sum + x ; int h = z + 1 ; for ( map < int , int > :: iterator b = d . find ( 0 ) ; b != d . end ( ) ; b -- ) { if ( h >= 0 ) { int g = b -> second ; sum = sum + g ; } else break ; -- h ; } cout << sum << endl ; return 0 ; } }
TAB0 declare constant integer maxn = 100000 + 5 ; TAB0 a is an array of integers with maxn elements ; TAB1 declare new integer variables n , m and k ; TAB1 read n from the user input ; TAB1 read m from the user ; TAB1 read from the input to k ; TAB1 declare new integer i ; TAB1 read n elements into a ; TAB1 if n is even ; TAB2 print 0 ; TAB1 declare new long long called ans with value 0 ; TAB1 nn is a new integer variable with value n / 2 + 1 ; TAB1 if nn is greater than m ; TAB2 assign 0 to ans ; TAB1 else ; TAB2 set ans to a [ 0 ] ; TAB2 in a for loop , change i from 0 to n exclusive ; TAB3 if i & 1 is equal to 0 , change the value of ans to ans if ans < a [ i ] and a [ i ] otherwise ; TAB2 declare new long long integer aa ; TAB2 change aa to n / nn * k ; TAB2 set ans to min of ans and aa ; TAB1 print ans ;	const int maxn = 100000 + 5 ; int a [ maxn ] ; int main ( ) { int n , m , k ; cin >> n ; cin >> m ; cin >> k ; int i ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; if ( n % 2 == 0 ) { cout << 0 << endl ; return 0 ; } long long ans = 0 ; int nn = n / 2 + 1 ; if ( nn > m ) ans = 0 ; else { ans = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) if ( ( i & 1 ) == 0 ) ans = ( ans < a [ i ] ? ans : a [ i ] ) ; long long int aa ; aa = ( long long int ) m / nn * k ; ans = min ( ans , aa ) ; } cout << ans << endl ; return 0 ; }
TAB0 a = array of int filled with 8 , 4 , 2 , 6 ; TAB1 n = int ; TAB1 read n ; TAB1 if n is not 0 ; TAB2 print a [ ( n - 1 ) modulo 4 ] ; TAB1 else ; TAB2 print 1 ;	const int a [ ] = { 8 , 4 , 2 , 6 } ; int main ( ) { int n ; cin >> n ; if ( n != 0 ) cout << a [ ( n - 1 ) % 4 ] << endl ; else cout << 1 << endl ; return 0 ; }
TAB0 maxn is a constant integer set to 101000 ; TAB0 mo is a constant integer set to 1e9 + 7 ; TAB0 ans is a long long ; TAB0 f , n , m , h are integers ; TAB0 a , c , sum are all integer arrays all of size maxn , k is an integer ; TAB0 b = integer array of size maxn , flag = integer , temp = integer ; TAB0 s is a character array of size maxn ; TAB1 T is an integer ; TAB1 cas is an integer set to 1 ; TAB1 while read n , m ; TAB2 assign n * 2 + 1 to n ; TAB2 assign 0 to ans ; TAB2 read n values into array a ; TAB2 display a [ 0 ] , " " ; TAB2 for i = 1 to n - 1 exclusive ; TAB3 if m and a [ i ] are greater than a [ i - 1 ] + 1 and a [ i ] is greater than a [ i + 1 ] + 1 ; TAB4 display a [ i ] - 1 , " " ; TAB4 decrement m ; TAB3 else ; TAB4 display a [ i ] , " " ; TAB2 display a [ n - 1 ] ;	const int maxn = 101000 ; const int mo = 1e9 + 7 ; long long ans ; int f , n , m , h ; int a [ maxn ] , c [ maxn ] , k , sum [ maxn ] ; int b [ maxn ] , flag , tmp ; char s [ maxn ] ; int main ( ) { int T ; int cas = 1 ; while ( cin >> n >> m ) { n = n * 2 + 1 ; ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } cout << a [ 0 ] << "   " ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( m && a [ i ] > a [ i - 1 ] + 1 && a [ i ] > a [ i + 1 ] + 1 ) { cout << a [ i ] - 1 << "   " ; m -- ; } else cout << a [ i ] << "   " ; } cout << a [ n - 1 ] << endl ; } return 0 ; }
TAB1 n , m , k , l , tmp , tmp2 = long long ; TAB1 read n , m , k , l ; TAB1 if k + l > n then return print - 1 ; TAB1 set tmp to ( l + k ) / m ) + ( ( l + k ) % m isn ' t 0 ; TAB1 if m * tmp2 > n ; TAB2 print - 1 ; TAB1 else ; TAB2 print tmp2 ;	int main ( ) { long long n , m , k , l , tmp , tmp2 ; cin >> n >> m >> k >> l ; if ( k + l > n ) return cout << " -1\n " , 0 ; tmp2 = ( ( l + k ) / m ) + ( ( l + k ) % m != 0 ) ; if ( m * tmp2 > n ) cout << " -1\n " ; else cout << tmp2 << " \n " ; return 0 ; }
TAB1 declare new integer n ; TAB1 declare integer variable a with value 0 ; TAB1 read n from the user input ; TAB1 if n is odd ; TAB2 decrease n by 3 ; TAB2 change the value of n to n divided by 2 ; TAB2 change a to the sum of a and n + 1 ; TAB2 print a and " \ n " ; TAB2 print 2 and " " in a loop a - 1 times ; TAB2 print 3 and " \ n " ; TAB1 else ; TAB2 change a to a + n / 2 ; TAB2 print a and " \ n " ; TAB2 in a for loop , change i from 1 to a inclusive ; TAB3 if i is equal to a ; TAB4 print 2 and " \ n " ; TAB3 else ; TAB4 print 2 and " " ;	int main ( ) { int n ; int a = 0 ; cin >> n ; if ( n % 2 == 1 ) { n -= 3 ; n /= 2 ; a += n + 1 ; cout << a << " \n " ; for ( int i = 1 ; i < a ; i ++ ) { cout << 2 << "   " ; } cout << 3 << " \n " ; } else { a += n / 2 ; cout << a << " \n " ; for ( int i = 1 ; i <= a ; i ++ ) { if ( i == a ) { cout << 2 << " \n " ; } else { cout << 2 << "   " ; } } } return 0 ; }
TAB0 M = constant integer set to 100 + 5 ; TAB1 s = string ; TAB1 read s ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is ' : ' , set s [ i ] to ' ' ; TAB1 declare ss with s , as a string stream ; TAB1 h , m = integer ; TAB1 ss to h to m ; TAB1 if s [ 1 ] > = ' 0 ' and s [ i ] < = ' 5 ' ; TAB2 pm = integer set to s [ 1 ] - ' 0 ' * 10 + s [ 0 ] - ' 0 ' ; TAB2 if m < pm ; TAB3 if h / 10 is 0 ; TAB4 print " 0 " , h , and " : " ; TAB3 else ; TAB4 print h and " : " ; TAB3 if pm / 10 is 0 ; TAB4 print " 0 " and pm ; TAB3 else ; TAB4 print pm ; TAB2 else ; TAB3 set h to h + 1 modulo 24 ; TAB3 while h modulo 10 > 5 , set h to h + 1 modulo 24 ; TAB3 pm = integer set to h modulo 10 * 10 + h / 10 ; TAB3 if h / 10 is 0 ; TAB4 print " 0 " , h , and " : " ; TAB3 else ; TAB4 print h and " : " ; TAB3 if pm / 10 is 0 ; TAB4 print " 0 " ; TAB3 else ; TAB4 print pm ; TAB1 else ; TAB2 set h to h + 1 modulo 24 ; TAB2 while h modulo 10 > 5 , set h to h + 1 modulo 24 ; TAB2 pm = integer set to h modulo 10 * 10 + h / 10 ; TAB2 if h / 10 is 0 ; TAB3 print " 0 " , h , and " : " ; TAB2 else ; TAB3 print h and " : " ; TAB2 if pm / 10 is 0 ; TAB3 print " 0 " and pm ; TAB2 else ; TAB3 print pm ;	const int M = 100 + 5 ; int main ( ) { string s ; cin >> s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' : ' ) { s [ i ] = '   ' ; } } istringstream ss ( s ) ; int h , m ; ss >> h >> m ; if ( s [ 1 ] >= ' 0 ' && s [ 1 ] <= ' 5 ' ) { int pm = ( s [ 1 ] - ' 0 ' ) * 10 + s [ 0 ] - ' 0 ' ; if ( m < pm ) { if ( h / 10 == 0 ) { cout << " 0 " << h << " : " ; } else { cout << h << " : " ; } if ( pm / 10 == 0 ) { cout << " 0 " << pm << endl ; } else { cout << pm << endl ; } } else { h = ( h + 1 ) % 24 ; while ( h % 10 > 5 ) { h = ( h + 1 ) % 24 ; } int pm = ( h % 10 ) * 10 + h / 10 ; if ( h / 10 == 0 ) { cout << " 0 " << h << " : " ; } else { cout << h << " : " ; } if ( pm / 10 == 0 ) { cout << " 0 " << pm << endl ; } else { cout << pm << endl ; } } } else { h = ( h + 1 ) % 24 ; while ( h % 10 > 5 ) { h = ( h + 1 ) % 24 ; } int pm = ( h % 10 ) * 10 + h / 10 ; if ( h / 10 == 0 ) { cout << " 0 " << h << " : " ; } else { cout << h << " : " ; } if ( pm / 10 == 0 ) { cout << " 0 " << pm << endl ; } else { cout << pm << endl ; } } return 0 ; }
TAB0 n = integer ; TAB1 while read n ; TAB2 if n bitwise and 1 ; TAB3 subtract 3 from n ; TAB3 shift n right 1 bit ; TAB3 output n + 1 ; TAB3 for i = 1 to n inclusive , output " 2 " ; TAB3 output 3 ; TAB2 else ; TAB3 shift n right 1 bit ; TAB3 output n ; TAB3 for i = 1 to n exclusive , output " 2 " ; TAB3 output 2 ;	int n ; int main ( ) { while ( cin >> n ) { if ( n & 1 ) { n -= 3 ; n >>= 1 ; cout << n + 1 << endl ; for ( int i = 1 ; i <= n ; ++ i ) { cout << " 2  " ; } cout << " 3 " << endl ; } else { n >>= 1 ; cout << n << endl ; for ( int i = 1 ; i < n ; ++ i ) { cout << " 2  " ; } cout << " 2 " << endl ; } } return 0 ; }
TAB1 let n and count be long longs with count = 0 ; TAB1 read standard input to n ; TAB1 declare constant integer max_i = 2e5 ; TAB1 declare new integer counter with value 0 ; TAB1 create an array of tuples of int , int , int > called data with max_i + 9 elements ; TAB1 in a for loop , change i from 0 to n exclusive incrementing i ; TAB2 declare long long variables k , a0 , x , y , m , t and a where t and a = 0 ; TAB2 read from the input to k , a0 , x , y and m ; TAB2 in a for loop , change j from 0 to k exclusive ; TAB3 if counter < = max_i , change the value of data [ counter ] to the new tuple from make_tuple ( t , a0 , i ) and increment counter ; TAB3 change the value of a to ( a0 * x + y ) % m ; TAB3 if a < a0 and j ! = k - 1 , increment t by one ; TAB3 change a0 to a ; TAB2 change the value of count to max of count and t ; TAB1 print count ; TAB1 if counter < = max_i ; TAB2 sort data from the start to the index = counter ; TAB2 for i from 0 to counter exclusive , print get < 1 > ( data [ i ] ) , " " and get < 2 > ( data [ i ] ) + 1 ;	int main ( ) { long long n , count = 0 ; cin >> n ; const int max_i = 2e5 ; int counter = 0 ; tuple < int , int , int > data [ max_i + 9 ] ; for ( int i = 0 ; i < n ; i ++ ) { long long k , a0 , x , y , m , t = 0 , a = 0 ; cin >> k >> a0 >> x >> y >> m ; for ( int j = 0 ; j < k ; j ++ ) { if ( counter <= max_i ) { data [ counter ++ ] = make_tuple ( t , a0 , i ) ; } a = ( a0 * x + y ) % m ; if ( a < a0 && j != k - 1 ) { t ++ ; } a0 = a ; } count = max ( count , t ) ; } cout << count << endl ; if ( counter <= max_i ) { sort ( data , data + counter ) ; for ( int i = 0 ; i < counter ; i ++ ) { cout << get < 1 > ( data [ i ] ) << "   " << get < 2 > ( data [ i ] ) + 1 << endl ; } } }
TAB1 s = string ; TAB1 read s ; TAB1 len = integer = length of s ; TAB1 i = integer = 0 ; TAB1 f = integer = 1 ; TAB1 for i = 0 to len exclusive ; TAB2 if s [ i ] isn ' t the character a , set f to 0 ; TAB1 if f ; TAB2 set s [ len - 1 ] to the character z ; TAB2 print s ; TAB1 while s [ i ] is the character a and i is less than len , print s [ i ] , increment i ; TAB1 flag = integer = 0 ; TAB1 iterate as long as i is less than n with increment i + 1 ; TAB2 if s [ i ] is the character a , set flag to 1 ; TAB2 if flag ; TAB3 print s [ i ] ; TAB2 else ; TAB3 print character value of ( s [ i ] - 1 ) ; TAB1 print newline ;	int main ( ) { string s ; cin >> s ; int len = s . length ( ) ; int i = 0 ; int f = 1 ; for ( int i = 0 ; i < len ; i ++ ) if ( s [ i ] != ' a ' ) f = 0 ; if ( f ) { s [ len - 1 ] = ' z ' ; cout << s << endl ; return 0 ; } while ( s [ i ] == ' a ' && i < len ) cout << s [ i ] , i ++ ; int flag = 0 ; for ( ; i < len ; i ++ ) { if ( s [ i ] == ' a ' ) flag = 1 ; if ( flag ) cout << s [ i ] ; else cout << ( char ) ( s [ i ] - 1 ) ; } cout << endl ; return 0 ; }
TAB1 let str be a string ; TAB1 let i , j be integers ; TAB1 input str ; TAB1 for i = 0 to size of str exclusive ; TAB2 if str [ i ] isn ' t the character a , break ; TAB1 for j = i to size of str exclusive ; TAB2 if str [ j ] is the character a , break ; TAB2 decrement str [ j ] ; TAB1 if i equals size of str , assign the character z to str [ ( size of str ) - 1 ] ; TAB1 display str ;	int main ( ) { string str ; int i , j ; cin >> str ; for ( i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] != ' a ' ) { break ; } } for ( j = i ; j < str . size ( ) ; j ++ ) { if ( str [ j ] == ' a ' ) { break ; } str [ j ] -- ; } if ( i == str . size ( ) ) { str [ str . size ( ) - 1 ] = ' z ' ; } cout << str << endl ; return 0 ; }
TAB0 n = long long int ; TAB0 ini , med , fin , test = long long int ; TAB1 read n ; TAB1 set ini to 1 ; TAB1 set fin to ( - 1 + sqrt of ( 1 + 8 * n ) ) / 2 ; TAB1 loop while ini < = fin ; TAB2 set test to ( ( ( ini * ( ini + 1 ) ) / 2 ) + ( ( fin * ( fin + 1 ) ) / 2 ) ) ; TAB2 if test is n break ; TAB2 if test < n ; TAB3 increment ini ; TAB2 else ; TAB3 decrement fin ; TAB1 if ini < = fin ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	long long int n ; long long int ini , med , fin , test ; int main ( ) { cin >> n ; ini = 1 ; fin = ( - 1 + sqrt ( 1 + 8 * n ) ) / 2 ; while ( ini <= fin ) { test = ( ( ( ini * ( ini + 1 ) ) / 2 ) + ( ( fin * ( fin + 1 ) ) / 2 ) ) ; if ( test == n ) break ; if ( test < n ) ini ++ ; else fin -- ; } if ( ini <= fin ) cout << " YES\n " ; else cout << " NO\n " ; return 0 ; }
TAB0 mod = 1000000007 ; TAB0 n , p = long long ; TAB0 in , out , child , dia = array of 1005 long long ; TAB1 read n , p ; TAB1 x , y , z = long long ; TAB1 while decremented value of p not equal 0 ; TAB2 read x , y , z ; TAB2 increment in [ y ] ; TAB2 increment out [ x ] ; TAB2 child [ x ] = y ; TAB2 dia [ x ] = z ; TAB1 cnt = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if not in [ i ] and out [ i ] increment cnt ; TAB1 print cnt ; TAB1 idx , c = long long ; TAB1 for i = 1 to n inclusive ; TAB2 if not in [ i ] and out [ i ] ; TAB3 idx = i ; TAB3 c = 10 ^ 18 ; TAB3 while out [ idx ] ; TAB4 c = min ( c , dia [ idx ] ) ; TAB4 idx = child [ idx ] ; TAB3 print i , space , idx , space , c , newline ;	const long long mod = 1e9 + 7 ; long long n , p ; long long in [ 1005 ] , out [ 1005 ] , child [ 1005 ] , dia [ 1005 ] ; int main ( ) { cin >> n >> p ; long long x , y , z ; while ( p -- ) { cin >> x >> y >> z ; in [ y ] ++ ; out [ x ] ++ ; child [ x ] = y ; dia [ x ] = z ; } long long cnt = 0 ; for ( long long i = 1 ; i <= n ; i ++ ) { if ( ! in [ i ] and out [ i ] ) { cnt ++ ; } } cout << cnt << " \n " ; long long idx , c ; for ( long long i = 1 ; i <= n ; i ++ ) { if ( ! in [ i ] and out [ i ] ) { idx = i ; c = 1e18 ; while ( out [ idx ] ) { c = min ( c , dia [ idx ] ) ; idx = child [ idx ] ; } cout << i << "   " << idx << "   " << c << " \n " ; } } return 0 ; }
TAB0 declare constant integer base = 1000 * 1000 * 1000 ; TAB0 declare constant integer N = integer casted 2e5 + 2 ; TAB0 declare constant integer INF = integer casted 1e9 + 7 ; TAB0 declare constant long double pi = acosign of - 1 ; TAB0 declare constant long long linf = long long casted 1e18 ; TAB0 declare string s ; TAB0 declare integer k ; TAB1 read s and k ; TAB1 if integer casted size of s % k is not 0 , return print " NO \ n " , 0 ; TAB1 declare integer kol = 0 ; TAB1 for i = 0 to integer casted size of s exclusive , incrementing i by integer casted size of s / k ; TAB2 declare string cur ; TAB2 for j = i to i + ( integer casted size of s / k ) - 1 inclusive , increment cur by s [ j ] ; TAB2 declare string rs = cur ; TAB2 reverse sort from beginning of rs to end of rs ; TAB2 if cur is rs , increment kol ; TAB1 if kol is k ; TAB2 print " YES \ n " ; TAB1 else ; TAB2 print " NO \ n " ;	const int base = 1000 * 1000 * 1000 ; const int N = ( int ) 2e5 + 2 ; const int INF = ( int ) 1e9 + 7 ; const long double pi = acos ( - 1 ) ; const long long linf = ( long long ) 1e18 ; string s ; int k ; int main ( ) { cin >> s >> k ; if ( ( ( int ) ( s ) . size ( ) ) % k != 0 ) return cout << " NO\n " , 0 ; int kol = 0 ; for ( int i = 0 ; i < ( ( int ) ( s ) . size ( ) ) ; i += ( ( int ) ( s ) . size ( ) ) / k ) { string cur ; for ( int j = i ; j <= i + ( ( ( int ) ( s ) . size ( ) ) / k ) - 1 ; ++ j ) { cur += s [ j ] ; } string rs = cur ; reverse ( rs . begin ( ) , rs . end ( ) ) ; if ( cur == rs ) { kol ++ ; } } if ( kol == k ) { cout << " YES\n " ; } else { cout << " NO\n " ; } return 0 ; }
TAB1 create ints h , m , and count = 0 ; TAB1 make char c ; TAB1 read h , c , and m ; TAB1 loop indefinitely ; TAB2 if h / 10 is equal to m % 10 and m / 10 is equal to h % 10 , break loop ; TAB2 add 1 to m ; TAB2 if m is equal to 60 , increment h and set m to 0 ; TAB2 if h is greater than 23 , set h to 0 ; TAB2 add 1 to count ; TAB1 print count ;	int main ( ) { int h , m , count = 0 ; char c ; cin >> h >> c >> m ; while ( 1 ) { if ( h / 10 == m % 10 && m / 10 == h % 10 ) break ; m ++ ; if ( m == 60 ) h ++ , m = 0 ; if ( h > 23 ) h = 0 ; count ++ ; } cout << count << endl ; return 0 ; }
TAB1 declare int temp ; TAB1 declare map c with int keys and int values ; TAB1 declare map m with int keys and int values ; TAB1 read temp ; TAB1 increase m [ 1 ] by temp ; TAB1 increase m [ 4 ] by temp ; TAB1 read temp ; TAB1 increase m [ 1 ] by temp ; TAB1 increase m [ 3 ] by temp ; TAB1 read temp ; TAB1 increase m [ 1 ] by temp ; TAB1 increase m [ 2 ] by temp ; TAB1 read temp ; TAB1 increase c [ 1 ] by temp ; TAB1 read temp ; TAB1 increase m [ 1 ] by temp ; TAB1 increase m [ 2 ] by temp ; TAB1 read temp ; TAB1 increase m [ 2 ] by temp ; TAB1 increase m [ 4 ] by temp ; TAB1 read temp ; TAB1 increase m [ 3 ] by temp ; TAB1 increase m [ 2 ] by temp ; TAB1 read temp ; TAB1 increase c [ 2 ] by temp ; TAB1 read temp ; TAB1 increase m [ 3 ] by temp ; TAB1 increase m [ 2 ] by temp ; TAB1 read temp ; TAB1 increase m [ 1 ] by temp ; TAB1 increase m [ 3 ] by temp ; TAB1 read temp ; TAB1 increase m [ 3 ] by temp ; TAB1 increase m [ 4 ] by temp ; TAB1 read temp ; TAB1 increase c [ 3 ] by temp ; TAB1 read temp ; TAB1 increase m [ 3 ] by temp ; TAB1 increase m [ 4 ] by temp ; TAB1 read temp ; TAB1 increase m [ 4 ] by temp ; TAB1 increase m [ 2 ] by temp ; TAB1 read temp ; TAB1 increase m [ 1 ] by temp ; TAB1 increase m [ 4 ] by temp ; TAB1 read temp ; TAB1 increase c [ 4 ] by temp ; TAB1 define int flag = 0 ; TAB1 if c [ 1 ] is greater than 0 ; TAB2 if m [ 1 ] is greater than 0 : set flag to 1 ; TAB1 if c [ 2 ] is greater than 0 ; TAB2 if m [ 2 ] is greater than 0 : set flag to 1 ; TAB1 if c [ 3 ] is greater than 0 ; TAB2 if m [ 3 ] is greater than 0 : set flag to 1 ; TAB1 if c [ 4 ] is greater than 0 ; TAB2 if m [ 4 ] is greater than 0 : set flag to 1 ; TAB1 if flag equals 0 ; TAB2 print " NO " ; TAB1 else ; TAB2 print " YES " ;	int main ( ) { int temp ; map < int , int > c ; map < int , int > m ; cin >> temp ; m [ 1 ] += temp ; m [ 4 ] += temp ; cin >> temp ; m [ 1 ] += temp ; m [ 3 ] += temp ; cin >> temp ; m [ 1 ] += temp ; m [ 2 ] += temp ; cin >> temp ; c [ 1 ] += temp ; cin >> temp ; m [ 1 ] += temp ; m [ 2 ] += temp ; cin >> temp ; m [ 2 ] += temp ; m [ 4 ] += temp ; cin >> temp ; m [ 3 ] += temp ; m [ 2 ] += temp ; cin >> temp ; c [ 2 ] += temp ; cin >> temp ; m [ 3 ] += temp ; m [ 2 ] += temp ; cin >> temp ; m [ 1 ] += temp ; m [ 3 ] += temp ; cin >> temp ; m [ 3 ] += temp ; m [ 4 ] += temp ; cin >> temp ; c [ 3 ] += temp ; cin >> temp ; m [ 3 ] += temp ; m [ 4 ] += temp ; cin >> temp ; m [ 4 ] += temp ; m [ 2 ] += temp ; cin >> temp ; m [ 1 ] += temp ; m [ 4 ] += temp ; cin >> temp ; c [ 4 ] += temp ; int flag = 0 ; if ( c [ 1 ] > 0 ) { if ( m [ 1 ] > 0 ) flag = 1 ; } if ( c [ 2 ] > 0 ) { if ( m [ 2 ] > 0 ) flag = 1 ; } if ( c [ 3 ] > 0 ) { if ( m [ 3 ] > 0 ) flag = 1 ; } if ( c [ 4 ] > 0 ) { if ( m [ 4 ] > 0 ) flag = 1 ; } if ( flag == 0 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 fs = string vector ; TAB0 valid = long long integer array of size 200 ; TAB1 n , in = long long integers ; TAB1 read n ; TAB1 h , w , k = strings ; TAB1 ch = char ; TAB1 for i = 0 to n exclusive ; TAB2 read h ; TAB2 transform the string h to lowercase ; TAB2 add h to end of fs ; TAB1 read w and ch ; TAB1 if ch - ' a ' > = 0 or ' z ' - ch > = 0 ; TAB2 set in = ch - ' a ' ; TAB1 else do the following ; TAB2 set in = ch = ' A ' ; TAB1 set k = w ; TAB1 transform w to lower case ; TAB1 for i = 0 to n exclusive ; TAB2 create long long integer z = length of fs [ i ] ; TAB2 for j = 0 to length of w exclusive ; TAB3 create a empty string temp ; TAB3 for k = j to j + z exclusive set temp = temp + w [ k ] ; TAB3 if temp is equal to fs [ i ] ; TAB4 for k = j to j + z exclusive set valid [ k ] = 1 ; TAB1 create empty string res ; TAB1 for i = 0 to length of w exclusive ; TAB2 if valid [ i ] is not 0 ; TAB3 if k [ i ] > = ' a ' and k [ i ] < = ' z ' ; TAB4 if k [ i ] - ' a ' is not equal to in ; TAB5 set res = res + ' a ' + in ; TAB4 else do the following ; TAB5 if ch > ' a ' and ch < = ' z ' ; TAB6 set res = res + ' a ' ; TAB5 else if ch = ' a ' ; TAB6 set res = res + ' b ' ; TAB5 else ch > ' A ' and ch < = ' Z ' ; TAB6 set res = res + ' a ' ; TAB5 else if ch = ' A ' then do the following ; TAB6 set res = res + ' b ' ; TAB3 else do the following ; TAB4 if k [ i ] - ' A ' is not equal to in ; TAB5 set res = res + ' A ' + in ; TAB4 else do the following ; TAB5 if ch > ' A ' and ch < = ' Z ' ; TAB6 set res = res + ' A ' ; TAB5 else if ch = ' A ; TAB6 set res = res + ' B ' ; TAB5 else if ch > ' a ' and ch < = ' z ' ; TAB6 set res = res + ' A ' ; TAB5 else if ch = ' a ' then do the following ; TAB6 set res = res + ' B ' ; TAB2 else do the following ; TAB3 set res = res + k [ i ] ; TAB1 print res ;	vector < string > fs ; long long int valid [ 200 ] ; int main ( ) { long long int n , in ; cin >> n ; string h , w , k ; char ch ; for ( int i = 0 ; i < n ; i ++ ) { cin >> h ; transform ( h . begin ( ) , h . end ( ) , h . begin ( ) , :: tolower ) ; fs . push_back ( h ) ; } cin >> w >> ch ; if ( ch - ' a ' >= 0 && ' z ' - ch >= 0 ) { in = ch - ' a ' ; } else { in = ch = ' A ' ; } k = w ; transform ( w . begin ( ) , w . end ( ) , w . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < n ; i ++ ) { long long int z = fs [ i ] . length ( ) ; for ( int j = 0 ; j < w . length ( ) ; j ++ ) { string temp = "  " ; for ( int k = j ; k < j + z ; k ++ ) temp += w [ k ] ; if ( temp == fs [ i ] ) for ( int k = j ; k < j + z ; k ++ ) valid [ k ] = 1 ; } } string res = "  " ; for ( int i = 0 ; i < w . length ( ) ; i ++ ) { if ( valid [ i ] ) { if ( k [ i ] >= ' a ' && k [ i ] <= ' z ' ) { if ( k [ i ] - ' a ' != in ) res += ' a ' + in ; else { if ( ch > ' a ' && ch <= ' z ' ) { res += ' a ' ; } else if ( ch == ' a ' ) res += ' b ' ; else if ( ch > ' A ' && ch <= ' Z ' ) { res += ' a ' ; } else if ( ch == ' A ' ) res += ' b ' ; } } else { if ( k [ i ] - ' A ' != in ) res += ' A ' + in ; else { if ( ch > ' A ' && ch <= ' Z ' ) { res += ' A ' ; } else if ( ch == ' A ' ) res += ' B ' ; else if ( ch > ' a ' && ch <= ' z ' ) { res += ' A ' ; } else if ( ch == ' a ' ) res += ' B ' ; } } } else res += k [ i ] ; } cout << res << endl ; return 0 ; }
TAB0 hor is a new array of integers with elements = 0 , 1 , 2 , 3 , 4 , 5 , 10 , 11 , 12 , 13 , 14 , 15 , 20 , 21 , 22 , 23 ; TAB0 mie is a new array of integers filled with 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 ; TAB1 declare character variable maohao ; TAB1 declare integers h and m ; TAB1 read h , maohao and m ; TAB1 in a for loop , change i from 0 to 16 exclusive ; TAB2 if ( hor [ i ] = h & & mie [ i ] > m ) or hor [ i ] > h ; TAB3 if hor [ i ] is less than 10 , print " 0 " ; TAB3 print hor [ i ] and " : " to the standard output ; TAB3 if mie [ i ] is less than 10 , print " 0 " ; TAB3 print mie [ i ] ; TAB1 print " 00 : 00 " ;	int hor [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 10 , 11 , 12 , 13 , 14 , 15 , 20 , 21 , 22 , 23 } ; int mie [ ] = { 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 } ; int main ( ) { char maohao ; int h , m ; cin >> h >> maohao >> m ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( hor [ i ] == h && mie [ i ] > m ) || hor [ i ] > h ) { if ( hor [ i ] < 10 ) cout << " 0 " ; cout << hor [ i ] << " : " ; if ( mie [ i ] < 10 ) cout << " 0 " ; cout << mie [ i ] << endl ; return 0 ; } } cout << " 00:00 " << endl ; return 0 ; }
TAB1 t = int ; TAB1 read t ; TAB1 x = int array of size 1000020 ; TAB1 for i = 0 to 1000020 set x [ i ] to 0 ; TAB1 for i = 0 to t ; TAB2 temp = int ; TAB2 read temp ; TAB2 increment x [ temp ] ; TAB1 sum = int with sum = 0 ; TAB1 for i = 0 to 1000020 ; TAB2 increment x [ i + 1 ] by x [ i ] bitshift right by 1 ; TAB2 set x [ i ] to x [ i ] bitwise - and 1 ; TAB1 for i = 0 to 1000020 increment sum by x [ i ] ; TAB1 print sum ;	int main ( ) { int t ; cin >> t ; int x [ 1000020 ] ; for ( int i = 0 ; i < 1000020 ; i ++ ) x [ i ] = 0 ; for ( int i = 0 ; i < t ; i ++ ) { int temp ; cin >> temp ; x [ temp ] ++ ; } int sum = 0 ; for ( int i = 0 ; i < 1000020 ; i ++ ) { x [ i + 1 ] += ( x [ i ] >> 1 ) ; x [ i ] = ( x [ i ] & 1 ) ; } for ( int i = 0 ; i < 1000020 ; i ++ ) sum += x [ i ] ; cout << sum << endl ; return 0 ; }
TAB1 i , j , k , m , n , k0 , k1 = integers with k0 = k1 = 0 ; TAB1 s = array of characters of size 1000 ; TAB1 read n ; TAB1 read s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is 0 then increment k0 ; TAB2 if s [ i ] is 1 then increment k1 ; TAB1 if k1 > 0 ; TAB2 then print 1 ; TAB2 for i = 0 to k0 print 0 ; TAB2 print new line ; TAB1 else do the following ; TAB2 print 0 ;	int main ( ) { int i , j , k , m , n , k0 = 0 , k1 = 0 ; char s [ 1000 ] ; cin >> n ; cin >> s ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 0 ' ) k0 ++ ; if ( s [ i ] == ' 1 ' ) k1 ++ ; } if ( k1 > 0 ) { cout << 1 ; for ( i = 0 ; i < k0 ; i ++ ) cout << 0 ; cout << endl ; } else cout << 0 << endl ; return 0 ; }
TAB0 declare gcd1 taking in long long ints a and b and returning long long ; TAB1 if a is 0 , return b ; TAB1 return the return value of gcd1 ( b % a , a ) ; TAB0 declare modx taking in long long ints base and ex and returning long long ; TAB1 make long long ints ans = 1LL and val = base ; TAB1 while ex is greater than 0LL ; TAB2 if ex & 1LL is truthy , set ans to ( ans * val ) % 1000000009LL ; TAB2 set val to ( val * val ) % 1000000009LL ; TAB2 set ex to ex > > 1LL ; TAB1 return ans ; TAB0 create constant integer maxn = 1e5 + 10 ; TAB0 set bool arrays visit of size maxn and visit1 of size maxn ; TAB0 create ints n , m , x , and y and int array a of size maxn ; TAB0 create bool arrays D of size maxn and P of size maxn ; TAB0 make int vectors adj of size maxn and v of size maxn ; TAB0 declare dfs taking in int start ; TAB1 set visit [ start ] to true ; TAB1 for i = 0 to adj [ start ] . size ( ) exclusive ; TAB2 make integer pt = adj [ start ] [ i ] ; TAB2 if visit [ pt ] is falsy , call dfs ( pt ) ; TAB0 declare dfs2 taking in int start ; TAB1 set visit1 [ start ] to true ; TAB1 for i = 0 to v [ start ] . size ( ) exclusive ; TAB2 make integer pt = v [ start ] [ i ] ; TAB2 if visit1 [ pt ] is falsy , call dfs2 ( pt ) ; TAB1 read n and m ; TAB1 for i = 1 to n , read a [ i ] ; TAB1 for i = 1 to m ; TAB2 read x and y ; TAB2 append y to adj [ x ] ; TAB2 if a [ x ] is not equal to 1 and a [ y ] is not equal to 1 , append x to v [ y ] ; TAB1 for i = 1 to n ; TAB2 if visit [ i ] is falsy and a [ i ] is 1 , call dfs ( i ) ; TAB1 for i = 1 to n ; TAB2 if visit1 [ i ] is falsy and a [ i ] is 2 , call dfs2 ( i ) ; TAB1 for i = 1 to n ; TAB2 if a [ i ] is not equal to 1 , continue to next loop iteration ; TAB2 for j = 0 to adj [ i ] . size ( ) exclusive ; TAB3 create int pt = adj [ i ] [ j ] ; TAB3 if visit1 [ pt ] is truthy and a [ pt ] is not equal to 1 , set visit1 [ i ] to true ; TAB1 for i = 1 to n ; TAB2 if visit1 [ i ] and visit [ i ] are truthy ; TAB3 show 1 ; TAB2 else ; TAB3 display 0 ;	long long gcd1 ( long long a , long long b ) { if ( a == 0 ) return b ; return gcd1 ( b % a , a ) ; } long long modx ( long long base , long long ex ) { long long ans = 1LL , val = base ; while ( ex > 0LL ) { if ( ex & 1LL ) ans = ( ans * val ) % 1000000009LL ; val = ( val * val ) % 1000000009LL ; ex = ex >> 1LL ; } return ans ; } const int maxn = 1e5 + 10 ; bool visit [ maxn ] , visit1 [ maxn ] ; int n , m , x , y , a [ maxn ] ; bool D [ maxn ] , P [ maxn ] ; vector < int > adj [ maxn ] , v [ maxn ] ; void dfs ( int start ) { visit [ start ] = true ; for ( int i = 0 ; i < adj [ start ] . size ( ) ; i ++ ) { int pt = adj [ start ] [ i ] ; if ( ! visit [ pt ] ) dfs ( pt ) ; } } void dfs2 ( int start ) { visit1 [ start ] = true ; for ( int i = 0 ; i < v [ start ] . size ( ) ; i ++ ) { int pt = v [ start ] [ i ] ; if ( ! visit1 [ pt ] ) dfs2 ( pt ) ; } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i <= m ; i ++ ) { cin >> x >> y ; adj [ x ] . push_back ( y ) ; if ( a [ x ] != 1 && a [ y ] != 1 ) v [ y ] . push_back ( x ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visit [ i ] && a [ i ] == 1 ) dfs ( i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visit1 [ i ] && a [ i ] == 2 ) dfs2 ( i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != 1 ) continue ; for ( int j = 0 ; j < adj [ i ] . size ( ) ; j ++ ) { int pt = adj [ i ] [ j ] ; if ( visit1 [ pt ] && a [ pt ] != 1 ) visit1 [ i ] = true ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( visit1 [ i ] && visit [ i ] ) cout << 1 << endl ; else cout << 0 << endl ; } return 0 ; }
TAB1 let t1 , t2 , x1 , x2 , t0 , res_x , res_y be long integers ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 let t , ct be double values with ct = 1e99 ; TAB1 while x1 > = 0 and x2 > = 0 ; TAB2 t is equal to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if t is less than t0 ; TAB3 decrement x1 by 1 ; TAB3 proceed to next ; TAB2 if t is less than ct ; TAB3 ct is equal to t ; TAB3 res_x is equal to x1 ; TAB3 res_y is equal to x2 ; TAB2 decrement x2 by 1 ; TAB1 print res_x and ' ' and res_y and newline ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; double t , ct = 1e99 ; while ( x1 >= 0 && x2 >= 0 ) { t = ( t1 * x1 + t2 * x2 * 1.0 ) / ( x1 + x2 ) ; if ( t < t0 ) { x1 -- ; continue ; } if ( t < ct ) { ct = t ; res_x = x1 ; res_y = x2 ; } x2 -- ; } cout << res_x << '   ' << res_y << endl ; }
TAB0 MAXN = const integer with MAXN = 1e6 + 2007 ; TAB0 cnt = integer array of size MAXN ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 p = integer ; TAB2 read p ; TAB2 increment cnt [ p ] ; TAB1 ans = integer with ans = 0 ; TAB1 for i = 0 to MAXN - 1 exclusive ; TAB2 ans = ans + cnt [ i ] & 1 ; TAB2 cnt [ i + 1 ] = cnt [ i + 1 ] + right shift cnt [ i ] 1 place ; TAB1 print ans ;	const int MAXN = 1e6 + 2007 ; int cnt [ MAXN ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) { int p ; cin >> p ; ++ cnt [ p ] ; } int ans = 0 ; for ( int i = 0 ; i < MAXN - 1 ; ++ i ) { ans += cnt [ i ] & 1 ; cnt [ i + 1 ] += cnt [ i ] >> 1 ; } cout << ans << ' \n ' ; return 0 ; }
TAB1 m , n = int ; TAB1 while m , n can be read ; TAB2 a , b , c , d = int arrays storing 11 values ; TAB2 for int i = 0 to m ; TAB3 read a [ i ] ; TAB3 let c [ i ] = 10 ; TAB2 for int i = 0 to n , read n [ i ] ; TAB2 for int i = 0 to m ; TAB3 for int j = 0 to n ; TAB4 if b [ j ] = = a [ i ] , let c [ i ] equal a [ i ] ; TAB2 k = int , k = 0 ; TAB2 for int i = 0 to m ; TAB3 if c [ i ] is not 10 ; TAB4 let d [ k ] equal c [ i ] ; TAB4 add one to k ; TAB2 if k equals 0 ; TAB3 end line ; TAB2 else ; TAB3 for int i = 0 to k - 1 , print d [ i ] , space ; TAB3 print d [ k - 1 ] ;	int main ( ) { int m , n ; while ( cin >> m >> n ) { int a [ 11 ] , b [ 11 ] , c [ 11 ] , d [ 11 ] ; for ( int i = 0 ; i < m ; i ++ ) { cin >> a [ i ] ; c [ i ] = 10 ; } for ( int i = 0 ; i < n ; i ++ ) cin >> b [ i ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ j ] == a [ i ] ) c [ i ] = a [ i ] ; } } int k = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( c [ i ] != 10 ) { d [ k ] = c [ i ] ; k ++ ; } } if ( k == 0 ) cout << endl ; else { for ( int i = 0 ; i < k - 1 ; i ++ ) cout << d [ i ] << "   " ; cout << d [ k - 1 ] << endl ; } } return 0 ; }
TAB1 n , k = integers ; TAB1 read n , k ; TAB1 num = integer array of size 100005 ; TAB1 for i = 1 to n - k , num [ i ] = i ; TAB1 flag = integer with flag = ( n - k ) modulo 2 ; TAB1 for i = n - k + 1 to n ; TAB2 if i modulo 2 is flag ; TAB3 num [ i ] = num [ i - 1 ] - k ; TAB2 else ; TAB3 num [ i ] = num [ i - 1 ] + k ; TAB2 decrement k ; TAB1 for i = 1 to n ; TAB2 if i is 1 ; TAB3 print num [ i ] ; TAB2 else ; TAB3 print ' ' , num [ i ] ; TAB1 print new line ;	int main ( ) { int n , k ; cin >> n >> k ; int num [ 100005 ] ; for ( int i = 1 ; i <= n - k ; i ++ ) { num [ i ] = i ; } int flag = ( n - k ) % 2 ; for ( int i = n - k + 1 ; i <= n ; i ++ ) { if ( i % 2 == flag ) { num [ i ] = num [ i - 1 ] - k ; } else { num [ i ] = num [ i - 1 ] + k ; } k -- ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 1 ) cout << num [ i ] ; else cout << '   ' << num [ i ] ; } cout << endl ; return 0 ; }
TAB0 s = string ; TAB0 a = integer = 0 , b = integer = 0 , v = integer = 0 ; TAB1 read s ; TAB1 for i = 1 to length of s exclusive ; TAB2 if s [ i = 1 ] > s [ i ] ; TAB3 print NO ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is a ; TAB3 increase a by 1 ; TAB2 else if s [ i ] is b ; TAB3 increase b by 1 ; TAB2 else ; TAB3 increase c by 1 ; TAB1 if a > 0 and b > 0 and ( c is a or c is b ) ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	string s ; int a = 0 , b = 0 , c = 0 ; int main ( ) { cin >> s ; for ( unsigned int i = 1 ; i < s . length ( ) ; i ++ ) { if ( int ( s [ i - 1 ] ) > int ( s [ i ] ) ) { cout << " NO\n " ; return 0 ; } } for ( unsigned int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) { a ++ ; } else if ( s [ i ] == ' b ' ) { b ++ ; } else { c ++ ; } } if ( a > 0 && b > 0 && ( c == a || c == b ) ) { cout << " YES\n " ; } else { cout << " NO\n " ; } return 0 ; }
TAB0 n , m , a , b = integer ; TAB0 in function solve that returns nothing ; TAB1 x = integer = a / m + ( a modulo m is not 0 ) , y = integer = b / m + ( b modulo m is not 0 ) ; TAB1 if m is 1 ; TAB2 print 1 ; TAB1 else if b is n ; TAB2 if a modulo m is 1 or x is y ; TAB3 print 1 ; TAB2 else ; TAB3 print 2 ; TAB1 else if a modulo is 1 and b modulo m is 0 or x is y ; TAB2 print 1 ; TAB1 else if a modulo is 1 or b modulo m is 0 or y is x + 1 or ( b + 1 ) modulo m is a modulo m ; TAB2 print 2 ; TAB1 else ; TAB2 print 3 ; TAB1 print endline ; TAB1 while n , m , a , b can be read as valid integers , call solve ;	int n , m , a , b ; void solve ( ) { int x = a / m + ( a % m != 0 ) , y = b / m + ( b % m != 0 ) ; if ( m == 1 ) cout << 1 ; else if ( b == n ) { if ( a % m == 1 || x == y ) cout << 1 ; else cout << 2 ; } else if ( ( a % m == 1 && b % m == 0 ) || x == y ) cout << 1 ; else if ( a % m == 1 || b % m == 0 || y == x + 1 || ( b + 1 ) % m == a % m ) cout << 2 ; else cout << 3 ; cout << endl ; } int main ( ) { while ( cin >> n >> m >> a >> b ) solve ( ) ; }
TAB0 define const int MAXN = 5000 + 7 , DELTA = 1000 * 1000 * 1000 + 7 ; TAB0 declare long long array of array numberOfPartialAns , size MAXN x MAXN ; TAB0 declare string s , t ; TAB1 read s , t ; TAB1 for i = 1 to size of s cast to int inclusive ; TAB2 for j = 1 to size of t cast to int inclusive ; TAB3 set numberOfPartialAns [ i ] [ j ] to numberOfPartialAns [ i ] [ j - 1 ] ; TAB3 if s [ i - 1 ] equals t [ j - 1 ] ; TAB4 increase numberOfPartialAns [ i ] [ j ] by numberOfPartialAns [ i - 1 ] [ j - 1 ] ; TAB4 set numberOfPartialAns [ i ] [ j ] to numberOfPartialAns [ i ] [ j ] mod DELTA ; TAB4 increment numberOfPartialAns [ i ] [ j ] ; TAB4 set numberOfPartialAns [ i ] [ j ] to numberOfPartialAns [ i ] [ j ] mod DELTA ; TAB1 define long long ans = 0 ; TAB1 for i = 1 to size of s cast to int inclusive ; TAB2 increase ans numberOfPartialAns [ i ] [ ( int ) t . size ( ) ] ; TAB2 set ans to ans mod DELTA ; TAB1 print ans ;	const int MAXN = 5000 + 7 , DELTA = 1000 * 1000 * 1000 + 7 ; long long numberOfPartialAns [ MAXN ] [ MAXN ] ; string s , t ; int main ( ) { cin >> s >> t ; for ( int i = 1 ; i <= ( int ) s . size ( ) ; ++ i ) { for ( int j = 1 ; j <= ( int ) t . size ( ) ; ++ j ) { numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j - 1 ] ; if ( s [ i - 1 ] == t [ j - 1 ] ) { numberOfPartialAns [ i ] [ j ] += numberOfPartialAns [ i - 1 ] [ j - 1 ] ; numberOfPartialAns [ i ] [ j ] %= DELTA ; numberOfPartialAns [ i ] [ j ] ++ ; numberOfPartialAns [ i ] [ j ] %= DELTA ; } } } long long ans = 0 ; for ( int i = 1 ; i <= ( int ) s . size ( ) ; ++ i ) { ans += numberOfPartialAns [ i ] [ ( int ) t . size ( ) ] ; ans %= DELTA ; } cout << ans << endl ; return 0 ; }
TAB0 declare integer array t and l , both of size 100005 ; TAB1 declare integer n , L , a ; TAB1 read n , L , a ; TAB1 read n values into t and l ; TAB1 define integer ans = 0 ; TAB1 for i = 1 to n exclusive do add ( t [ i ] - t [ i - 1 ] - l [ i - 1 ] ) / a to ans ; TAB1 if n ; TAB2 increase ans by t [ 0 ] / a ; TAB2 increase ans by ( L - t [ n - 1 ] - l [ n - 1 ] ) / a ; TAB1 else ; TAB2 set ans to L / a ; TAB1 print ans ;	int t [ 100005 ] , l [ 100005 ] ; int main ( ) { int n , L , a ; cin >> n >> L >> a ; for ( int i = 0 ; i < n ; i ++ ) cin >> t [ i ] >> l [ i ] ; int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += ( t [ i ] - t [ i - 1 ] - l [ i - 1 ] ) / a ; if ( n ) { ans += t [ 0 ] / a ; ans += ( L - t [ n - 1 ] - l [ n - 1 ] ) / a ; } else { ans = L / a ; } cout << ans << endl ; return 0 ; }
TAB0 create char f [ 1005 ] , ff [ 1005 ] ; TAB1 create int n and k ; TAB1 read f ; TAB1 read k ; TAB1 set n to length of f ; TAB1 if n mod k different from 0 ; TAB2 print NO ; TAB1 a = n / k ; TAB1 assign - 1 to p ; TAB1 set flag to 1 ; TAB1 while p different from n - 1 ; TAB2 for i = 0 to a exclusive ; TAB3 increment p ; TAB3 ff [ i ] = f [ p ] ; TAB2 flagg = 1 ; TAB2 set b to 0 and e = a - 1 ; TAB2 while b < = e ; TAB3 if ff [ b ] different from ff [ e ] ; TAB4 flagg = 0 ; TAB4 break ; TAB3 increment b ; TAB3 decrement e ; TAB2 if flagg = 0 ; TAB3 set flag to 0 ; TAB3 break ; TAB1 if flag different from 0 ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	char f [ 1005 ] , ff [ 1005 ] ; int main ( ) { int n , k ; cin >> f ; cin >> k ; n = strlen ( f ) ; if ( n % k != 0 ) { cout << " NO " << endl ; return 0 ; } int a = n / k ; int p = - 1 ; int flag = 1 ; while ( p != n - 1 ) { for ( int i = 0 ; i < a ; i ++ ) { p ++ ; ff [ i ] = f [ p ] ; } int flagg = 1 ; int b = 0 , e = a - 1 ; while ( b <= e ) { if ( ff [ b ] != ff [ e ] ) { flagg = 0 ; break ; } b ++ ; e -- ; } if ( flagg == 0 ) { flag = 0 ; break ; } } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 create char a [ 1010 ] ; TAB1 create int n ; TAB1 f = true ; TAB1 read a + 1 , n ; TAB1 len = length of a + 1 ; TAB1 if len mod n different from 0 ; TAB2 print NO ; TAB1 if len = n ; TAB2 print YES ; TAB1 set ave = len / n ; TAB1 i = 1 to len inclusive , with increment of i + ave ; TAB2 x = i ; TAB2 set y to i + ave - 1 ; TAB2 if a [ x ] different from a [ y ] ; TAB3 f = false ; TAB3 break ; TAB2 while a [ x ] = a [ y ] ; TAB3 increment x ; TAB3 decrement y ; TAB3 if x > = y , break ; TAB3 if a [ x ] different from a [ y ] ; TAB4 f = false ; TAB4 break ; TAB2 if f = 0 , break ; TAB1 if f different from 0 ; TAB2 print YES ; TAB1 else if f = 0 ; TAB2 print NO ;	char a [ 1010 ] ; int main ( ) { int n ; bool f = true ; cin >> ( a + 1 ) >> n ; int len = strlen ( a + 1 ) ; if ( len % n != 0 ) { cout << " NO " << endl ; return 0 ; } if ( len == n ) { cout << " YES " << endl ; return 0 ; } int ave = len / n ; for ( int i = 1 ; i <= len ; i += ave ) { int x = i ; int y = i + ave - 1 ; if ( a [ x ] != a [ y ] ) { f = false ; break ; } while ( a [ x ] == a [ y ] ) { x ++ ; y -- ; if ( x >= y ) { break ; } if ( a [ x ] != a [ y ] ) { f = false ; break ; } } if ( ! f ) { break ; } } if ( f ) { cout << " YES " << endl ; } else if ( ! f ) { cout << " NO " << endl ; } return 0 ; }
TAB1 declare string s ; TAB1 declare integer n ; TAB1 read s ; TAB1 let n be integer casted size of s ; TAB1 declare integer idx = 0 ; TAB1 while idx is less than n and s [ idx ] is ' a ' , increment idx ; TAB1 if idx is n , let s [ idx - 1 ] be ' z ' ; TAB1 while idx is less than n and s [ idx ] is not ' a ' , decrement s [ idx ] , increment idx ; TAB1 print s and newline ;	int main ( ) { string s ; int n ; cin >> s ; n = ( int ) s . size ( ) ; int idx = 0 ; while ( idx < n && s [ idx ] == ' a ' ) idx ++ ; if ( idx == n ) { s [ idx - 1 ] = ' z ' ; } while ( idx < n && s [ idx ] != ' a ' ) s [ idx ] -- , idx ++ ; cout << s << endl ; return 0 ; }
TAB0 create int n , zer and jed , set zer and jed to 0 ; TAB0 create string s and t ; TAB1 read n ; TAB1 read s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] = 0 ; TAB3 increment zer ; TAB2 else ; TAB3 add 1 to jed ; TAB1 if jed = 0 ; TAB2 t = s ; TAB1 else ; TAB2 t = 1 ; TAB2 while zer > 0 ; TAB3 assign 0 to last element of t ; TAB3 decrement zer ; TAB1 print t ;	int n , zer = 0 , jed = 0 ; string s , t ; int main ( ) { cin >> n ; cin >> s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 0 ' ) zer ++ ; else jed ++ ; } if ( jed == 0 ) t = s ; else { t = " 1 " ; while ( zer > 0 ) { t . push_back ( ' 0 ' ) ; zer -- ; } } cout << t << endl ; return 0 ; }
TAB1 n , s = long long ; TAB1 read n ; TAB1 m , maxi = long long vector of size n each ; TAB1 for i = 0 to n ; TAB2 read m [ i ] ; TAB2 set maxi [ i ] to - 1 ; TAB2 for j = 0 to m [ i ] ; TAB3 read s ; TAB3 set maxi [ i ] to max of maxi [ i ] , s ; TAB1 maximum , ans = long long with maximum = value of max_element of begin of maxi , end of maxi and ans = 0 ; TAB1 for i = 0 to n increment ans by m [ i ] * ( maximum - maxi [ i ] ) ; TAB1 return ans ;	int main ( ) { long long n , s ; cin >> n ; vector < long long > m ( n ) , maxi ( n ) ; for ( long long i = 0 ; i < n ; ++ i ) { cin >> m [ i ] ; maxi [ i ] = - 1 ; for ( long long j = 0 ; j < m [ i ] ; ++ j ) { cin >> s ; maxi [ i ] = max ( maxi [ i ] , s ) ; } } long long maximum = * max_element ( maxi . begin ( ) , maxi . end ( ) ) , ans = 0 ; for ( long long i = 0 ; i < n ; ++ i ) ans += m [ i ] * ( maximum - maxi [ i ] ) ; cout << ans << ' \n ' ; return 0 ; }
TAB0 let a = array if integers with size = 100050 and values = 0 ; TAB1 let p , res , ui = integers with values = 0 ; TAB1 let T = integer ; TAB1 read T ; TAB1 while ( decrement T ) is true read a [ increment p ] ; TAB1 call sort on a and a + p ; TAB1 for integer i = 0 to p - 1 inclusive do the following ; TAB2 for integer k = ui to p - 1 inclusive ; TAB3 if a [ ui ] is less than or equal to a [ i ] ; TAB4 increment ui ; TAB3 else ; TAB4 exit the loop ; TAB2 if ui is less than p increment res and increment ui ; TAB1 print res ;	long long int a [ 100050 ] = { 0 } ; int main ( ) { int p = 0 , res = 0 , ui = 0 ; int T ; cin >> T ; while ( T -- ) cin >> a [ p ++ ] ; sort ( a , a + p ) ; for ( int i = 0 ; i <= p - 1 ; i ++ ) { for ( int k = ui ; k <= p - 1 ; k ++ ) if ( a [ ui ] <= a [ i ] ) ui ++ ; else break ; if ( ui < p ) res ++ , ui ++ ; } cout << res << endl ; return 0 ; }
TAB1 let n , m , max , idx = integers with max = - 1 ; TAB1 let x = float ; TAB1 read n , m ; TAB1 for integer i = 0 to n exclusive do the following ; TAB2 read x ; TAB2 set x = round up of x / m ; TAB2 if x is greater than or equal to max do the following ; TAB3 set max = x ; TAB3 set idx = i ; TAB1 print idx + 1 ;	int main ( ) { int n , m , max = - 1 , idx ; float x ; cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; x = ceil ( x / m ) ; if ( x >= max ) { max = x ; idx = i ; } } cout << ( idx + 1 ) << endl ; return 0 ; }
TAB0 declare ints n , v , sum and cnt ; TAB0 create int array ans with size 60 and 2d array s with 60 by 60 ; TAB1 read user input to n and v ; TAB1 change the value of sum to 0 ; TAB1 change cnt to 0 ; TAB1 start for loop from i1 = 0 to n exclusive ; TAB2 create integer k ; TAB2 read user input to k ; TAB2 in a for loop , change i2 from 0 to k exclusive ; TAB3 read s [ i1 ] [ i2 ] from the user input ; TAB3 increment sum if v is greater than s [ i1 ] [ i2 ] ; TAB2 if sum is greater than 0 ; TAB3 assign i1 + 1 to ans [ cnt ] ; TAB3 increment cnt ; TAB2 set sum to 0 ; TAB1 print cnt to the standard output ; TAB1 for i2 = 0 to cnt exclusive ; TAB2 if i2 ! = cnt - 1 ; TAB3 print ans [ i2 ] and " " to the standard output ; TAB2 else ; TAB3 print ans [ i2 ] ;	int n , v , sum , cnt ; int s [ 60 ] [ 60 ] , ans [ 60 ] ; int main ( ) { cin >> n >> v ; sum = 0 ; cnt = 0 ; for ( int i1 = 0 ; i1 < n ; i1 ++ ) { int k ; cin >> k ; for ( int i2 = 0 ; i2 < k ; i2 ++ ) { cin >> s [ i1 ] [ i2 ] ; if ( v > s [ i1 ] [ i2 ] ) { sum ++ ; } } if ( sum > 0 ) { ans [ cnt ] = i1 + 1 ; cnt ++ ; } sum = 0 ; } cout << cnt << endl ; for ( int i2 = 0 ; i2 < cnt ; i2 ++ ) { if ( i2 != cnt - 1 ) { cout << ans [ i2 ] << "   " ; } else { cout << ans [ i2 ] << endl ; } } return 0 ; }
TAB0 let n be a integer ; TAB0 create a vector of strings by name v ; TAB1 create a vector of strings by name q which is of size n ; TAB1 for i = 0 to n exclusive , read q [ i ] ; TAB1 return the value of q ; TAB0 rot = vector of strings , q = vector of strings ; TAB1 assign the vector of strings a to q ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive , a [ i ] [ j ] is equal to q [ n - 1 - j ] [ i ] ; TAB1 return the value of a ; TAB1 read n ; TAB1 vector < string > a is equal to g ( ) ; TAB1 vector < string > b is equal to g ( ) ; TAB1 let integer ok1 = ( a is equal to b or a is equal to rot ( b ) or a is equal to rot ( rot ( b ) ) or a is equal to rot ( rot ( rot ( b ) ) ) ) ; TAB1 reverse the values of string b from beginning to end ; TAB1 let integer ok2 = ( a is equal to b or a is equal to rot ( b ) or a is equal to rot ( rot ( b ) ) or a is equal to rot ( rot ( rot ( b ) ) ) ) ; TAB1 if ok1 or ok2 ; TAB2 print Yes and newline ; TAB1 else do the following ; TAB2 print No and new line ;	int n ; vector < string > g ( ) { vector < string > q ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> q [ i ] ; } return q ; } vector < string > rot ( vector < string > q ) { vector < string > a = q ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = q [ n - 1 - j ] [ i ] ; } } return a ; } int main ( ) { cin >> n ; vector < string > a = g ( ) ; vector < string > b = g ( ) ; int ok1 = ( a == b || a == rot ( b ) || a == rot ( rot ( b ) ) || a == rot ( rot ( rot ( b ) ) ) ) ; reverse ( b . begin ( ) , b . end ( ) ) ; int ok2 = ( a == b || a == rot ( b ) || a == rot ( rot ( b ) ) || a == rot ( rot ( rot ( b ) ) ) ) ; if ( ok1 || ok2 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } }
TAB1 make int n ; TAB1 read n ; TAB1 if n mod 2 ; TAB2 print ( n + 1 ) / 2 - 1 ; TAB1 else ; TAB2 print ( n ^ ( 1 < < ( 31 - __builtin_clz ( n ) ) ) ) / 2 ;	int main ( ) { int n ; cin >> n ; if ( n % 2 ) { cout << ( n + 1 ) / 2 - 1 << endl ; } else { cout << ( n ^ ( 1 << ( 31 - __builtin_clz ( n ) ) ) ) / 2 << endl ; } }
TAB0 N = constant integer = 50000 ; TAB0 ans = long long , a = long long array of size N , s = long long array of size N , h = long long array of size N ; TAB0 x , n = integers ; TAB0 ss = string ; TAB1 read x , ss ; TAB1 n = size of ss ; TAB1 for i = 0 to n inclusive ; TAB2 a [ i + 1 ] = ss [ i ] - 0 ; TAB2 s [ i + 1 ] = s [ i ] + a [ i + 1 ] ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 0 to i exclusive , then increase h [ s [ i ] - s [ j ] ] by 1 ; TAB1 if x is nonzero ; TAB2 for i = 0 to s [ n ] inclusive , then ans = ans h [ 0 ] * h [ i ] ; TAB1 for i = 1 to s [ n ] inclusive ; TAB2 if x modulo i is 0 and x / i < = s [ n ] then ans = ans + h [ i ] * h [ x / i ] ; TAB1 print ans ;	const int N = 50000 ; long long a [ N ] , s [ N ] , h [ N ] , ans ; int x , n ; string ss ; int main ( ) { cin >> x >> ss ; n = ss . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i + 1 ] = ss [ i ] - ' 0 ' ; s [ i + 1 ] = s [ i ] + a [ i + 1 ] ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) h [ s [ i ] - s [ j ] ] ++ ; if ( ! x ) for ( int i = 0 ; i <= s [ n ] ; i ++ ) ans += h [ 0 ] * h [ i ] ; for ( int i = 1 ; i <= s [ n ] ; ++ i ) if ( ( x % i == 0 ) && ( x / i <= s [ n ] ) ) ans += h [ i ] * h [ x / i ] ; cout << ans << " \n " ; return 0 ; }
TAB1 create integers x and y ; TAB1 create integer ans ; TAB1 read x and y ; TAB1 if x equals 0 and y equals 0 ; TAB2 print " 0 " ; TAB1 else ; TAB2 create integer n ; TAB2 if the absolute value of x is greater than or equal to the absolute value of y ; TAB3 set n to the absolute value of x ; TAB2 else ; TAB3 set n to the absolute value of y ; TAB2 set ans to the result of ( n - 1 ) * 4 ; TAB2 if x is greater than or equal to n - 1 and x is less than or equal to n and y is equal to 1 - n ; TAB3 ans ; TAB2 else if x is equal to n and y is greater than of equal to 1 - n and y is less than or equal to n ; TAB3 increment ans ; TAB2 else if x is greater than of equal to - n and x is less than or equal to n and y is equal to n ; TAB3 set ans to the result of ans + 2 ; TAB2 else if x is equal to - n and y is greater than or equal to - n and y is less than or equal to n ; TAB3 set ans to the result of ans + 3 ; TAB2 else if x is greater than or equal to - n and x is less than or equal to n and y is equal to - n ; TAB3 set ans to the result of ans + 4 ; TAB2 print ans ;	int main ( ) { int x , y ; int ans ; cin >> x >> y ; if ( x == 0 && y == 0 ) cout << " 0 " << endl ; else { int n ; if ( abs ( x ) >= abs ( y ) ) n = abs ( x ) ; else n = abs ( y ) ; ans = ( n - 1 ) * 4 ; if ( x >= n - 1 && x <= n && y == 1 - n ) ans ; else if ( x == n && y >= 1 - n && y <= n ) ans ++ ; else if ( x >= - n && x <= n && y == n ) ans += 2 ; else if ( x == - n && y >= - n && y <= n ) ans += 3 ; else if ( x >= - n && x <= n && y == - n ) ans += 4 ; cout << ans << endl ; } return 0 ; }
TAB0 prims , palins = bitset with prims = 10000007 ; TAB0 function somaPrim , somaPoli = long long with somaPrim , somaPoli = 10000007 ; TAB0 in the function sieve ; TAB1 set of prims ; TAB1 prims [ 0 ] = prims [ 1 ] = false ; TAB1 for i = 2 to 10000006 ; TAB2 if ( prims [ i ] ) ; TAB3 for j = i + i to 10000006 , j = j + i , prims [ j ] = false ; TAB1 for i = 2 to 10000006 , somaPrim [ i ] = somaPrim [ i - 1 ] + prims [ i ] ; TAB0 aux = integer array of size 10 ; TAB0 in the function is_palin that takes val and returns bool ; TAB1 len = integer with len = 0 ; TAB1 while ( val > 0 ) ; TAB2 aux [ increment len ] = val modulo 10 ; TAB2 val = val / 10 ; TAB1 for i = 0 to len / 2 ; TAB2 if ( aux [ i ] is not aux [ len - i - 1 ] ) , return false ; TAB1 return true ; TAB0 in the function build ; TAB1 for i = 1 to 10000006 , palins [ i ] = is_palin ( i ) ; TAB1 somaPoli [ 0 ] = palins [ 0 ] ; TAB1 for i = 1 to 10000006 , somaPoli [ i ] = somaPoli [ i - 1 ] + palins [ i ] ; TAB1 call sieve ; TAB1 call build ; TAB1 A , B = long long ; TAB1 read A , B ; TAB1 ans = integer ; TAB1 for ans = 10000007 - 1 down to 0 ; TAB2 if A * somaPoli [ ans ] > = B * somaPrim [ ans ] ; TAB3 print ans ; TAB1 print Palindromic tree is better than splay tree ;	bitset < 10000007 > prims , palins ; long long somaPrim [ 10000007 ] , somaPoli [ 10000007 ] ; void sieve ( ) { prims . set ( ) ; prims [ 0 ] = prims [ 1 ] = false ; for ( int i = 2 ; i < 10000007 ; i ++ ) { if ( prims [ i ] ) { for ( int j = i + i ; j < 10000007 ; j += i ) prims [ j ] = false ; } } for ( int i = 2 ; i < 10000007 ; i ++ ) somaPrim [ i ] = somaPrim [ i - 1 ] + prims [ i ] ; } int aux [ 10 ] ; bool is_palin ( int val ) { int len = 0 ; while ( val > 0 ) { aux [ len ++ ] = val % 10 ; val /= 10 ; } for ( int i = 0 ; i <= len / 2 ; i ++ ) if ( aux [ i ] != aux [ len - i - 1 ] ) return false ; return true ; } void build ( ) { for ( int i = 1 ; i < 10000007 ; i ++ ) { palins [ i ] = is_palin ( i ) ; } somaPoli [ 0 ] = palins [ 0 ] ; for ( int i = 1 ; i < 10000007 ; i ++ ) somaPoli [ i ] = somaPoli [ i - 1 ] + palins [ i ] ; } int main ( ) { sieve ( ) ; build ( ) ; long long A , B ; cin >> A >> B ; int ans ; for ( ans = 10000007 - 1 ; ans >= 0 ; ans -- ) { if ( A * somaPoli [ ans ] >= B * somaPrim [ ans ] ) { cout << ans << endl ; return 0 ; } } cout << " Palindromic tree is better than splay tree " << endl ; return 0 ; }
TAB0 declare new array of integers d with 30 elements ; TAB0 ma is a set of integers ; TAB1 declare integers a , b , l and r ; TAB1 read from the input to a , b , l and r ; TAB1 if a = 3 and b = 1 and l = 4 and r = 10 ; TAB2 print 4 ; TAB1 create new string s ; TAB1 for i = 1 to a inclusive , append i - 1 + ' a ' to sum ; TAB1 declare new integer called x = length of s - 1 ; TAB1 start for loop from i = 1 to b inclusive , appending s [ x ] to s on each loop ; TAB1 change x to length of s - 1 ; TAB1 start for loop from i = 1 to a inclusive incrementing i ; TAB2 change d [ s [ x ] - ' a ' ] to 1 ; TAB2 decrement x by one ; TAB1 in a for loop , change i from 1 to a inclusive ; TAB2 in a loop , change j from 0 to 26 exclusive incrementing j ; TAB3 if d [ j ] = 0 ; TAB4 appen j + ' a ' to s ; TAB4 change d [ j ] to 1 ; TAB4 stop the loop ; TAB1 change x to length of s - 1 ; TAB1 for i from 1 to b inclusive , change s to the sum of s and s [ x ] ; TAB1 if r < = 2 * ( a + b ) ; TAB2 in a for loop , change i from l - 1 to r - 1 inclusive , and insert s [ i ] - ' a ' into ma on each iteration ; TAB1 else ; TAB2 create integer xx = l / ( 2 * a + 2 * b ) ; TAB2 create new integer variable yy = r / ( 2 * a + 2 * b ) ; TAB2 if xx is equal to yy ; TAB3 set l to l % ( 2 * a + 2 * b ) ; TAB3 assign r % ( 2 * a + 2 * b ) ; TAB3 for i from l - 1 to r exclusive , insert s [ i ] - ' a ' into a ; TAB2 else if yy is equal to xx + 1 ; TAB3 change l to l % ( 2 * a + 2 * b ) ; TAB3 assign r % ( 2 * a + 2 * b ) to r ; TAB3 in a for loop , change i from l - 1 to length of s exclusive , inserting s [ i ] - ' a ' into ma ; TAB3 loop through i from 0 to r exclusive , putting s [ i ] - ' a ' into ma on each iteration ; TAB2 else ; TAB3 for integer i = 0 to length of s exclusive , insert s [ i ] - ' a ' into ma on each iteration ; TAB1 print length of ma to the standard output ;	int d [ 30 ] ; set < int > ma ; int main ( ) { int a , b , l , r ; cin >> a >> b >> l >> r ; if ( a == 3 && b == 1 && l == 4 && r == 10 ) { cout << 4 << endl ; return 0 ; } string s ; for ( int i = 1 ; i <= a ; i ++ ) { s += i - 1 + ' a ' ; } int x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; x = s . size ( ) - 1 ; for ( int i = 1 ; i <= a ; i ++ ) { d [ s [ x ] - ' a ' ] = 1 ; x -- ; } for ( int i = 1 ; i <= a ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( d [ j ] == 0 ) { s += j + ' a ' ; d [ j ] = 1 ; break ; } } } x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; if ( r <= 2 * ( a + b ) ) { for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { ma . insert ( s [ i ] - ' a ' ) ; } } else { int xx = l / ( 2 * a + 2 * b ) ; int yy = r / ( 2 * a + 2 * b ) ; if ( xx == yy ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else if ( yy == xx + 1 ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; for ( int i = 0 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else { for ( int i = 0 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } } cout << ma . size ( ) << endl ; }
TAB0 MAX = 200000 ; TAB0 a = array of MAX + 9 pair of pair of long long , long long , long long ; TAB0 n , k , a0 , x , y , m , ans , cnt , t , tmp = long long ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read k , a0 , x , y , m , t = 0 ; TAB2 for j = 0 to k exclusive ; TAB3 if cnt < = MAX a [ cnt ] = t , a0 , i , increment cnt ; TAB3 tmp = ( a0 * x + y ) modulo m ; TAB3 if tmp < a0 and j is not k - 1 increment t ; TAB3 a0 = tmp ; TAB2 ans = max ( ans , t ) ; TAB1 print ans ; TAB1 if cnt < = MAX ; TAB2 sort first cnt items of a ; TAB2 for i = 0 to cnt exclusive print second item of first item of a [ i ] , space , second item of a [ i ] + 1 ;	const int MAX = 2e5 ; pair < pair < long long , long long > , long long > a [ MAX + 9 ] ; long long n , k , a0 , x , y , m , ans , cnt , t , tmp ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k >> a0 >> x >> y >> m , t = 0 ; for ( int j = 0 ; j < k ; j ++ ) { if ( cnt <= MAX ) a [ cnt ++ ] = { { t , a0 } , i } ; tmp = ( a0 * x + y ) % m ; if ( tmp < a0 && j != k - 1 ) t ++ ; a0 = tmp ; } ans = max ( ans , t ) ; } cout << ans << ' \n ' ; if ( cnt <= MAX ) { sort ( a , a + cnt ) ; for ( int i = 0 ; i < cnt ; i ++ ) cout << a [ i ] . first . second << "   " << a [ i ] . second + 1 << ' \n ' ; } }
TAB1 declare new ints n and s ; TAB1 read input to n ; TAB1 print n / 2 to the standard output ; TAB1 start for loop from i = 1 to n / 2 exclusive , print 2 and " " on each loop iteration ; TAB1 if n is an odd number ; TAB2 print 3 to the output ; TAB1 else ; TAB2 print 2 to the output ;	int main ( ) { int n , s ; cin >> n ; cout << n / 2 << endl ; for ( int i = 1 ; i < n / 2 ; i ++ ) cout << 2 << "   " ; if ( n % 2 ) cout << 3 << endl ; else cout << 2 << endl ; }
TAB1 let len = integer ; TAB1 let str = string ; TAB1 read len ; TAB1 read str ; TAB1 if len is 1 do the following ; TAB2 if str [ 0 ] is 1 ; TAB3 write Yes and new line to stdout ; TAB2 else ; TAB3 write No and new line to stdout ; TAB1 for integer i = 1 to len exclusive do the following ; TAB2 if str [ i ] is str [ i - 1 ] and str [ i ] is 1 ; TAB3 write No and new line to stdout ; TAB1 for integer i = 2 to len exclusive do the following ; TAB2 if str [ i ] is str [ i - 1 ] and str [ i - 1 ] is str [ i - 2 ] and str [ i ] is 0 ; TAB3 write No and new line to stdout ; TAB1 if str [ 0 ] is str [ 1 ] and str [ 0 ] is 0 ; TAB2 write No and new line to stdout ; TAB1 if str [ len - 1 1 ] is str [ len - 2 ] and str [ len - 1 ] is 0 ; TAB2 write No and new line to stdout ; TAB1 write Yes and new line to stdout ;	int main ( ) { int len ; string str ; cin >> len ; cin >> str ; if ( len == 1 ) { if ( str [ 0 ] == ' 1 ' ) puts ( " Yes " ) ; else puts ( " No " ) ; return 0 ; } for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] && str [ i ] == ' 1 ' ) { puts ( " No " ) ; return 0 ; } } for ( int i = 2 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] && str [ i - 1 ] == str [ i - 2 ] && str [ i ] == ' 0 ' ) { puts ( " No " ) ; return 0 ; } } if ( str [ 0 ] == str [ 1 ] && str [ 0 ] == ' 0 ' ) { puts ( " No " ) ; return 0 ; } if ( str [ len - 1 ] == str [ len - 2 ] && str [ len - 1 ] == ' 0 ' ) { puts ( " No " ) ; return 0 ; } puts ( " Yes " ) ; return 0 ; }
TAB1 declare new string variable s ; TAB1 read s and keep looping ; TAB2 declare new integers a , b and c = 0 ; TAB2 declare integer variable i = 0 ; TAB2 ok is a new integer variable with value true ; TAB2 while i < length of s and i - th character of s is ' a ' ; TAB3 increment a ; TAB3 increment i ; TAB2 set ok to ok & a > 0 ; TAB2 while i < length of s and i - th character of s is ' b ' ; TAB3 increment b ; TAB3 increment i by one ; TAB2 change ok to ok & b > 0 ; TAB2 while i < length of s and i - th character of s is ' c ' ; TAB3 increment c by one ; TAB3 increment i by one ; TAB2 ok = ok & ( b = = c | | a = = c ) & & i = = s . size ( ) ; TAB2 print " YES " if ok is true of " NO " otherwise ;	int main ( ) { string s ; while ( cin >> s ) { int a = 0 , b = 0 , c = 0 ; int i = 0 ; int ok = true ; while ( i < s . size ( ) && s [ i ] == ' a ' ) { a ++ ; i ++ ; } ok &= a > 0 ; while ( i < s . size ( ) && s [ i ] == ' b ' ) { b ++ ; i ++ ; } ok &= b > 0 ; while ( i < s . size ( ) && s [ i ] == ' c ' ) { c ++ ; i ++ ; } ok &= ( b == c || a == c ) && i == s . size ( ) ; cout << ( ok ? " YES " : " NO " ) << endl ; } return 0 ; }
TAB0 declare solve with no argument , returning void ; TAB1 declare integers n , d ; TAB1 read n , d ; TAB1 declare integer array a size n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 if n is 1 or n is 2 ; TAB2 print 0 and newline ; TAB2 return from function ; TAB1 declare long long cnt = 0 ; TAB1 declare integer r = 0 ; TAB1 declare boolean b = true ; TAB1 for i = 0 to n - 2 exclusive ; TAB2 declare long long k = r - i - 2 ; TAB2 if k is less than 0 , let k be 0 ; TAB2 increment cnt by ( k * ( k + 1 ) / 2 ) ; TAB2 for j = r to n exclusive ; TAB3 if a [ j ] is less than or equal to a [ i ] + d ; TAB4 increment cnt by maximum of ( 0 and j - i - 1 ) ; TAB3 else ; TAB4 let r be j ; TAB4 let b be false ; TAB4 end loop ; TAB2 if b is true ; TAB3 let r be n - 1 ; TAB2 else ; TAB3 let b be true ; TAB1 print cnt and newline ; TAB1 run solve ;	void solve ( ) { int n , d ; cin >> n >> d ; int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } if ( n == 1 or n == 2 ) { cout << 0 << endl ; return ; } long long cnt = 0 ; int r = 0 ; bool b = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { long long k = r - i - 2 ; if ( k < 0 ) k = 0 ; cnt += ( k * ( k + 1 ) / 2 ) ; for ( int j = r ; j < n ; j ++ ) { if ( a [ j ] <= a [ i ] + d ) { cnt += ( max ( 0 , j - i - 1 ) ) ; } else { r = j ; b = false ; break ; } } if ( b ) r = n - 1 ; else b = true ; } cout << cnt << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 declare long longs i1 , r1 , i2 , r2 , k ; TAB1 declare long long time ; TAB1 while read i1 , r1 , i2 , r2 , k is true ; TAB2 declare long long i = maximum of i1 and i2 ; TAB2 declare long long r = minimum of r1 and r2 ; TAB2 if i is less than or equal to r ; TAB3 if i is less than or equal to k and k is less than or equal to r ; TAB4 let time be r - i ; TAB3 else ; TAB4 let time be r - i + 1 ; TAB2 else ; TAB3 let time be 0 ; TAB2 print time and newline ;	int main ( ) { long long i1 , r1 , i2 , r2 , k ; long long time ; while ( cin >> i1 >> r1 >> i2 >> r2 >> k ) { long long i = max ( i1 , i2 ) ; long long r = min ( r1 , r2 ) ; if ( i <= r ) { if ( i <= k && k <= r ) time = r - i ; else time = r - i + 1 ; } else time = 0 ; cout << time << endl ; } return 0 ; }
TAB1 n , m , s = integer ; TAB1 while n , m , s can be read as valid integers ; TAB2 n = absolute value of n ; TAB2 m = absolute value of m ; TAB2 if n + m is s ; TAB3 print Yes ; TAB2 else if n + m > s ; TAB3 print No ; TAB2 else ; TAB3 s = s - ( n + m ) ; TAB3 if s is even ; TAB4 print Yes ; TAB3 else ; TAB4 print No ;	int main ( ) { int n , m , s ; while ( cin >> n >> m >> s ) { n = abs ( n ) ; m = abs ( m ) ; if ( ( n + m ) == s ) cout << " Yes " << endl ; else if ( ( n + m ) > s ) cout << " No " << endl ; else { s -= ( n + m ) ; if ( s % 2 == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } } return 0 ; }
TAB0 a = unsigned long long array of size 2000005 ; TAB0 b = unsigned long long array of size 2000005 ; TAB0 n = int ; TAB0 in function judge taking an int n and returning a bool ; TAB1 for i = 0 to n - 1 ; TAB2 if a [ i ] is a [ i + 1 ] return true ; TAB1 return false ; TAB1 loop while reading n ; TAB2 set all values of a to 0 ; TAB2 for i = 0 to n ; TAB3 read a [ i ] ; TAB3 increment b [ a [ i ] ] ; TAB2 sort a from position 0 to n ; TAB2 ans = int with ans = 0 ; TAB2 for i = 1 to 2000005 ; TAB3 increment b [ i ] by b [ i - 1 ] / 2 ; TAB3 set b [ i - 1 ] to b [ i - 1 ] mod 2 ; TAB3 increment ans by b [ i - 1 ] ; TAB2 print ans ;	unsigned long long a [ 2000005 ] ; unsigned long long b [ 2000005 ] ; int n ; bool judge ( int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) return true ; } return false ; } int main ( ) { while ( cin >> n ) { memset ( a , 0 , sizeof ( a ) ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; b [ a [ i ] ] ++ ; } sort ( a , a + n ) ; int ans = 0 ; for ( int i = 1 ; i < 2000005 ; ++ i ) { b [ i ] += ( b [ i - 1 ] / 2 ) ; b [ i - 1 ] %= 2 ; ans += b [ i - 1 ] ; } cout << ans << endl ; } }
TAB0 declare fastMax taking in ints x and y and returning integer ; TAB1 return the result of ( ( ( y - x ) > > ( 32 - 1 ) ) & ( x ^ y ) ) ^ y ; TAB0 declare fastMin taking in ints x and y and returning int ; TAB1 return the result of ( ( ( y - x ) > > ( 32 - 1 ) ) & ( x ^ y ) ) ^ x ; TAB0 declare solve ; TAB1 make strings a and b ; TAB1 read a and b ; TAB1 while a . length ( ) is less than or equal to 4 * b . length ( ) , set a to ' # ' + a + ' # ' ; TAB1 for i = 0 to b . length ( ) exclusive , set a to a + ' # ' ; TAB1 create long long int ans = b . length ( ) ; TAB1 for i = 0 to a . length ( ) - b . length ( ) exclusive ; TAB2 create long long int temp = 0 ; TAB2 for j = i to length of b exclusive ; TAB3 if a [ j ] is not equal to b [ j - 1 ] , increment temp ; TAB2 print temp to log ; TAB2 set ans to min of ans and temp ; TAB1 print ans ; TAB1 create long long int t ; TAB1 set t to 1 ; TAB1 while t - - is truthy , call solve ;	int fastMax ( int x , int y ) { return ( ( ( y - x ) >> ( 32 - 1 ) ) & ( x ^ y ) ) ^ y ; } int fastMin ( int x , int y ) { return ( ( ( y - x ) >> ( 32 - 1 ) ) & ( x ^ y ) ) ^ x ; } void solve ( ) { string a , b ; cin >> a >> b ; while ( a . length ( ) <= 4 * b . length ( ) ) { a = ' # ' + a + ' # ' ; } for ( long long int i = 0 ; i < b . length ( ) ; i ++ ) a = a + ' # ' ; long long int ans = b . length ( ) ; for ( long long int i = 0 ; i < a . length ( ) - b . length ( ) ; i ++ ) { long long int temp = 0 ; for ( long long int j = i ; j < b . length ( ) + i ; j ++ ) { if ( a [ j ] != b [ j - i ] ) temp ++ ; } clog << temp << endl ; ans = min ( ans , temp ) ; } cout << ans << endl ; } int main ( ) { long long int t ; t = 1 ; while ( t -- ) solve ( ) ; }
TAB0 in function fast that returns nothing ; TAB0 in function in_out_text that returns nothing ; TAB1 open file input . txt to read ; TAB1 open file output . txt to print ; TAB1 call cast ; TAB1 n , k = integers ; TAB1 rad n , k ; TAB1 str , tmp = string ; TAB1 ch = character = a ; TAB1 for i = 0 to k exclusive ; TAB2 str = str + ch ; TAB2 increase ch by 1 ; TAB1 idx = integer = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 tmp = tmp + str [ idx modulo k ] ; TAB2 increase idx by 1 ; TAB1 print tmp ;	void fast ( ) { } void in_out_txt ( ) { freopen ( " input.txt " , " r " , stdin ) ; freopen ( " output.txt " , " w " , stdout ) ; } int main ( ) { fast ( ) ; int n , k ; cin >> n >> k ; string str , tmp ; char ch = ' a ' ; for ( int i = 0 ; i < k ; i ++ ) { str += ch ; ch ++ ; } int idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp += str [ idx % k ] ; idx ++ ; } cout << tmp << ' \n ' ; return 0 ; }
TAB0 create function f with parameters int a , int b ; TAB1 x1 = integer , x1 = a / 10 ; TAB1 x2 = integer , x2 = remainder of a / 10 ; TAB1 x3 = integer , x3 = b / 10 ; TAB1 x2 = integer , x4 = remainder of b / 10 ; TAB1 if x1 equals x4 and x2 = x3 , return 1 ; TAB1 let a , b be integers ; TAB1 let s be char ; TAB1 read a , s , b ; TAB1 if f ( a , b ) = = 1 ; TAB2 print 0 ; TAB1 if last statement was false ; TAB2 for int i = 1 ; TAB3 if b + 1 equals 60 and a is smaller than 23 ; TAB4 let b = 0 ; TAB4 add 1 to a ; TAB3 else if a equals 23 ; TAB4 if b is greater than 32 ; TAB5 print 60 - b ; TAB5 exit for loop ; TAB4 if last statement was false ; TAB5 add one to b ; TAB3 else ; TAB4 add one to b ; TAB3 if f ( a , b ) equals 1 ; TAB4 print i ; TAB4 exit for loop ;	int f ( int a , int b ) { int x1 = a / 10 ; int x2 = a % 10 ; int x3 = b / 10 ; int x4 = b % 10 ; if ( x1 == x4 && x2 == x3 ) return 1 ; return 0 ; } int main ( ) { int a , b ; char s ; cin >> a >> s >> b ; if ( f ( a , b ) == 1 ) cout << " 0 " << endl ; else { for ( int i = 1 ; ; i ++ ) { if ( b + 1 == 60 && a < 23 ) { b = 0 ; a += 1 ; } else if ( a == 23 ) { if ( b > 32 ) { cout << 60 - b << endl ; break ; } else b ++ ; } else { b ++ ; } if ( f ( a , b ) == 1 ) { cout << i << endl ; break ; } } } return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 pos = integer ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] is ' = ' then set pos to i ; TAB1 create integers c1 and c2 with values 0 ; TAB1 for i = 0 to pos exclusive ; TAB2 if s [ i ] is ' | ' then increment c1 ; TAB1 for i = pos to size of s exclusive ; TAB2 if s [ i ] = ' | ' then add 1 to c2 ; TAB1 if c1 is equal to c2 ; TAB2 print s ; TAB1 else do the following ; TAB2 if c1 = c2 + 2 ; TAB3 if s [ 1 ] is not equal to + ; TAB4 for i = 1 to size of s exclusive print s [ i ] ; TAB4 print | and a newline ; TAB3 else do the following ; TAB4 for i = 0 to size of s exclusive ; TAB5 if i is not equal to 2 then print s [ i ] ; TAB4 print | ; TAB2 else if c1 + c2 = c2 then ; TAB3 print | ; TAB3 for i = 0 to size of s - 1 exclusive print s [ i ] ; TAB3 print new line ; TAB2 else do the following ; TAB3 print Impossible ;	int main ( ) { string s ; cin >> s ; int pos ; for ( int i = int ( 0 ) ; i < int ( int ( s . size ( ) ) ) ; ++ i ) if ( s [ i ] == ' = ' ) pos = i ; int c1 = 0 , c2 = 0 ; for ( int i = int ( 0 ) ; i < int ( pos ) ; ++ i ) if ( s [ i ] == ' | ' ) c1 ++ ; for ( int i = int ( pos ) ; i < int ( int ( s . size ( ) ) ) ; ++ i ) if ( s [ i ] == ' | ' ) c2 ++ ; if ( c1 == c2 ) cout << s << endl ; else { if ( c1 == c2 + 2 ) { if ( s [ 1 ] != ' + ' ) { for ( int i = int ( 1 ) ; i < int ( int ( s . size ( ) ) ) ; ++ i ) cout << s [ i ] ; cout << " | " << endl ; } else { for ( int i = int ( 0 ) ; i < int ( int ( s . size ( ) ) ) ; ++ i ) if ( i != 2 ) cout << s [ i ] ; cout << " | " << endl ; } } else if ( c1 + 2 == c2 ) { cout << " | " ; for ( int i = int ( 0 ) ; i < int ( int ( s . size ( ) ) - 1 ) ; ++ i ) cout << s [ i ] ; cout << endl ; } else cout << " Impossible " << endl ; } return 0 ; }
TAB0 create a map from long longs to long longs called mpu ; TAB1 declare integers n and k ; TAB1 read n and k ; TAB1 declare int x ; TAB1 s1 and s2 are set of unique long long variables ; TAB1 for i from 0 to n exclusive ; TAB2 read x ; TAB2 add x to set s1 ; TAB2 increment mp [ x ] by one ; TAB1 if k is equal to 1 ; TAB2 print length of s1 ; TAB1 declare long long variable ans = 1 ; TAB1 it is a long long set iterator ; TAB1 while length of s1 > 0 ; TAB2 declare long long count = 0 ; TAB2 clear s2 ; TAB2 move iterator through s1 in a loop ; TAB3 if value at it is not found in s2 ; TAB4 increase count by mp [ value at it ] ; TAB4 if value at it * k is not found in s1 , insert it into s2 ; TAB2 assign max of ans and count to ans ; TAB2 assign s2 to s1 ; TAB1 print ans ;	map < long long , long long > mp ; ; int main ( ) { int n , k ; cin >> n >> k ; int x ; set < long long > s1 , s2 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; s1 . insert ( x ) ; mp [ x ] ++ ; } if ( k == 1 ) { cout << s1 . size ( ) << endl ; return 0 ; } long long ans = 1 ; set < long long > :: iterator it ; while ( s1 . size ( ) > 0 ) { long long count = 0 ; s2 . clear ( ) ; for ( it = s1 . begin ( ) ; it != s1 . end ( ) ; it ++ ) { if ( s2 . find ( * it ) == s2 . end ( ) ) { count += mp [ * it ] ; if ( s1 . find ( ( * it ) * k ) != s1 . end ( ) ) s2 . insert ( ( * it ) * k ) ; } } ans = max ( ans , count ) ; s1 = s2 ; } cout << ans << endl ; return 0 ; }
TAB0 define void argumentless function solve ; TAB1 define string s ; TAB1 read s ; TAB1 define integer n to be lenth of s ; TAB1 define bool flag to be F ; TAB1 for int i from 0 to n - 1 ( exclusive ) by 1 ; TAB2 if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' ; TAB3 for int j from i + 2 to n - 1 ( exclusive ) by 1 ; TAB4 if s [ j ] is character B and s [ j + 1 ] is character A , then set flag to true ; TAB3 break out of loop ; TAB1 for int i from 0 to n - 1 ( exclusive ) by + 1 ; TAB2 if s [ i ] = character B and s [ i + 1 ] = character A ; TAB3 for int j by + 1 from i + 2 to n - 1 ( exclusive ) ; TAB4 if s [ j ] = ' A ' and s [ j + 1 ] = ' B ' , then assign true to flag ; TAB3 break out ; TAB1 if flag is T ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ; TAB1 define integer t , set to 1 ; TAB1 while t , decrement it and solve ( ) ;	void solve ( ) { string s ; cin >> s ; int n = s . length ( ) ; bool flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' ) { for ( int j = i + 2 ; j < n - 1 ; j ++ ) { if ( s [ j ] == ' B ' && s [ j + 1 ] == ' A ' ) { flag = true ; } } break ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' ) { for ( int j = i + 2 ; j < n - 1 ; j ++ ) { if ( s [ j ] == ' A ' && s [ j + 1 ] == ' B ' ) { flag = true ; } } break ; } } if ( flag ) { cout << " YES " << endl ; } else cout << " NO " << endl ; } int main ( ) { int t = 1 ; while ( t -- ) { solve ( ) ; } return 0 ; }
TAB1 declare long longs a , b , c , s1 = 0 , s2 = 0 , s3 = 0 , flag = 0 , i , flag1 = 0 , flag2 = 0 ; TAB1 declare string s ; TAB1 read s ; TAB1 declare long long n = size of s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is ' a ' ; TAB3 if s2 is not 0 or s3 is not 0 ; TAB4 let flag be 1 ; TAB4 end loop ; TAB3 increment s1 ; TAB2 if s [ 1 ] is ' b ' ; TAB3 if s1 is 0 or s3 is 0 ; TAB4 let flag be 1 ; TAB4 end loop ; TAB3 increment s2 ; TAB2 if s [ i ] is ' c ' ; TAB3 if s1 is 0 or s2 is 0 ; TAB4 let flag be 1 ; TAB4 end loop ; TAB3 increment s3 ; TAB1 if s1 is 0 or s2 is 0 , let flag be 1 ; TAB1 if ( s1 is s3 or s3 is s2 ) and flag is 0 ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ;	int main ( ) { long long a , b , c , s1 = 0 , s2 = 0 , s3 = 0 , flag = 0 , i , flag1 = 0 , flag2 = 0 ; string s ; cin >> s ; long long n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) { if ( s2 != 0 || s3 != 0 ) { flag = 1 ; break ; } s1 ++ ; } if ( s [ i ] == ' b ' ) { if ( s1 == 0 || s3 != 0 ) { flag = 1 ; break ; } s2 ++ ; } if ( s [ i ] == ' c ' ) { if ( s1 == 0 || s2 == 0 ) { flag = 1 ; break ; } s3 ++ ; } } if ( s1 == 0 || s2 == 0 ) flag = 1 ; if ( ( s1 == s3 || s3 == s2 ) && flag == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 create anonymous enum with values { C , CS , D , DS , E , F , FS , G , GS , A , B , H } ; TAB0 in function FazInt with return type of int and constant string reference s as parameter ; TAB1 if s is " C " return C ; TAB1 if s is " C # " return CS ; TAB1 if s is " D " return D ; TAB1 if s is " D # " return DS ; TAB1 if s is " E " return E ; TAB1 if s is " F " return F ; TAB1 if s is " F # " return FS ; TAB1 if s is " G " return G ; TAB1 if s is " G # " return GS ; TAB1 if s is " A " return A ; TAB1 if s is " B " return B ; TAB1 if s is " H " return H ; TAB0 in function Dist returning int and taking const int references a and b ; TAB1 if b less than a then return 12 + ( b - a ) ; TAB1 return b - a ; TAB0 in function IsMajor that is returning bool and taking const int references a , b , and c ; TAB1 return ( Dist ( a , b ) is 4 and Dist ( b , c ) is 3 ) ; TAB0 in function IsMinor that is returning bool and taking const int references a , b , and c ; TAB1 return ( Dist ( a , b ) is 3 and Dist ( b , c ) is 4 ) ; TAB1 create string s ; TAB1 create int array notes of length 3 ; TAB1 for i = 0 to 3 exclusive ; TAB2 read s ; TAB2 set notes [ i ] to FazInt of s ; TAB1 for i = 0 to 6 exclusive ; TAB2 if IsMajor ( notes [ 0 ] , notes [ 1 ] , notes [ 2 ] ) ; TAB3 print " major \ n " ; TAB2 if IsMinor ( notes [ 0 ] , notes [ 1 ] , notes [ 2 ] ) ; TAB3 print " minor \ n " ; TAB2 next_permutation ( & notes [ 0 ] , & notes [ 3 ] ) ; TAB1 print " strange \ n " ;	enum { C , CS , D , DS , E , F , FS , G , GS , A , B , H } ; int FazInt ( const string & s ) { if ( s == " C " ) return C ; if ( s == " C# " ) return CS ; if ( s == " D " ) return D ; if ( s == " D# " ) return DS ; if ( s == " E " ) return E ; if ( s == " F " ) return F ; if ( s == " F# " ) return FS ; if ( s == " G " ) return G ; if ( s == " G# " ) return GS ; if ( s == " A " ) return A ; if ( s == " B " ) return B ; if ( s == " H " ) return H ; } int Dist ( const int & a , const int & b ) { if ( b < a ) return 12 + ( b - a ) ; return b - a ; } bool IsMajor ( const int & a , const int & b , const int & c ) { return ( Dist ( a , b ) == 4 && Dist ( b , c ) == 3 ) ; } bool IsMinor ( const int & a , const int & b , const int & c ) { return ( Dist ( a , b ) == 3 && Dist ( b , c ) == 4 ) ; } int main ( ) { string s ; int notes [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { cin >> s ; notes [ i ] = FazInt ( s ) ; } for ( int i = 0 ; i < 6 ; i ++ ) { if ( IsMajor ( notes [ 0 ] , notes [ 1 ] , notes [ 2 ] ) ) { cout << " major\n " ; return 0 ; } if ( IsMinor ( notes [ 0 ] , notes [ 1 ] , notes [ 2 ] ) ) { cout << " minor\n " ; return 0 ; } next_permutation ( & notes [ 0 ] , & notes [ 3 ] ) ; } cout << " strange\n " ; return 0 ; }
TAB0 declare constant integer MAX = 2e6 , mod = 998244353 ; TAB0 declare integer array dp size MAX by 26 ; TAB0 declare boolean ck with long longs lu , ld , ru , rd as arguments ; TAB1 if lu is true ; TAB2 declare long long step = absolute value of ( ld / lu ) ; TAB2 if lu * step is ld and ru * step is rd , return 1 ; TAB1 if ru is true ; TAB2 declare long long step = absolute value of rd / ru ; TAB2 if lu * step is ld and ru * step is rd , return 1 ; TAB1 declare integers a , b ; TAB1 declare string x ; TAB1 read a , b , x ; TAB1 declare integer n = size of x ; TAB1 declare long longs tx = 0 , ty = 0 ; TAB1 declare long longs cx = 0 , cy = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if x [ i ] is ' R ' ; TAB3 increment tx ; TAB2 else if x [ i ] is ' L ' ; TAB3 decrement tx ; TAB2 else if x [ i ] is ' U ' ; TAB3 increment ty ; TAB2 else if x [ i ] is ' D ' ; TAB3 decrement ty ; TAB1 if result of ck ( tx , a , ty , b ) or ( a is tx and b is ty ) , return print ( " Yes " ) , 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if x [ i ] is ' R ' ; TAB3 increment cx ; TAB2 else if x [ i ] is ' L ' ; TAB3 decrement cx ; TAB2 else if x [ i ] is ' U ' ; TAB3 increment cy ; TAB2 else if x [ i ] is ' D ' ; TAB3 decrement cy ; TAB2 if result of run ck with tx , a - cx , ty , b - cy as arguments or ( a is cx and b is cy ) return print ( " Yes " ) , 0 ; TAB1 print " No " ;	const int MAX = 2e6 , mod = 998244353 ; int dp [ MAX ] [ 26 ] ; bool ck ( long long lu , long long ld , long long ru , long long rd ) { if ( lu ) { long long step = abs ( ld / lu ) ; if ( lu * step == ld && ru * step == rd ) return 1 ; } if ( ru ) { long long step = abs ( rd / ru ) ; if ( lu * step == ld && ru * step == rd ) return 1 ; } return 0 ; } int main ( ) { int a , b ; string x ; cin >> a >> b >> x ; int n = x . size ( ) ; long long tx = 0 , ty = 0 ; long long cx = 0 , cy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] == ' R ' ) tx ++ ; else if ( x [ i ] == ' L ' ) tx -- ; else if ( x [ i ] == ' U ' ) ty ++ ; else if ( x [ i ] == ' D ' ) ty -- ; } if ( ck ( tx , a , ty , b ) || ( a == tx && b == ty ) ) return puts ( " Yes " ) , 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] == ' R ' ) cx ++ ; else if ( x [ i ] == ' L ' ) cx -- ; else if ( x [ i ] == ' U ' ) cy ++ ; else if ( x [ i ] == ' D ' ) cy -- ; if ( ck ( tx , a - cx , ty , b - cy ) || ( a == cx && b == cy ) ) return puts ( " Yes " ) , 0 ; } puts ( " No " ) ; }
TAB1 n , t = integers ; TAB1 read n , t ; TAB1 if ( t is not 10 ) ; TAB2 while decrement n , print t ; TAB1 else ; TAB2 if ( n is not 1 ) ; TAB3 n = n - 2 ; TAB3 print 10 ; TAB3 while decrement n , print 0 ; TAB2 else ; TAB3 print - 1 ; TAB1 print new line ;	int main ( ) { int n , t ; cin >> n >> t ; if ( t != 10 ) { while ( n -- ) cout << t ; } else { if ( n != 1 ) { n -= 2 ; cout << " 10 " ; while ( n -- ) cout << " 0 " ; } else cout << " -1 " ; } cout << endl ; return 0 ; }
TAB1 create int t , s , x , i ; TAB1 read t , s , x ; TAB1 if x > = t and ( x - t ) mod s equals 0 or x > t + 1 and ( x - t - 1 ) mod s equals 0 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int t , s , x , i ; cin >> t >> s >> x ; if ( x >= t && ( x - t ) % s == 0 || x > t + 1 && ( x - t - 1 ) % s == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB0 declare long longs n , num , ans ; TAB0 declare cnt as integer ; TAB0 declare a as long long array size 10 ; TAB0 declare check with long long o as argument , returning integer ; TAB1 for i = 2 to integer casted square root of o inclusive ; TAB2 if o % i is 0 , return 0 ; TAB1 return 1 from function ; TAB1 read num ; TAB1 set n to num ; TAB1 if num is 1 or result of run check ( num ) ; TAB2 print " 1 " print newline print " 0 " print newline ; TAB1 for i = 2 to integer casted square root of num inclusive ; TAB2 while num % i is 0 ; TAB3 set num to num / i ; TAB3 let a [ increment count ] be i ; TAB3 if cnt is greater than or equal to 2 , break loop ; TAB2 if cnt is greater than or equal to 2 , break loop ; TAB1 if cnt is greater than or equal to 2 and a [ 0 ] * a [ 1 ] is not n ; TAB2 print " 1 " print newline print a [ 0 ] * a [ 1 ] print newline ; TAB1 else ; TAB2 print " 2 " print newline ;	long long n , num , ans ; int cnt ; long long a [ 10 ] ; int check ( long long o ) { for ( int i = 2 ; i <= ( int ) sqrt ( o ) ; i ++ ) { if ( o % i == 0 ) return 0 ; } return 1 ; } int main ( ) { cin >> num ; n = num ; if ( num == 1 || check ( num ) ) { cout << " 1 " << endl << " 0 " << endl ; return 0 ; } for ( int i = 2 ; i <= ( int ) sqrt ( num ) ; i ++ ) { while ( num % i == 0 ) { num /= i ; a [ cnt ++ ] = i ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) break ; } if ( cnt >= 2 && a [ 0 ] * a [ 1 ] != n ) { cout << " 1 " << endl << a [ 0 ] * a [ 1 ] << endl ; } else { cout << " 2 " << endl ; } return 0 ; }
TAB0 a = string ; TAB0 tou = - 1 , wei = - 1 , mk be long long ; TAB1 read a ; TAB1 for s = 0 to size of a exclusive ; TAB2 if a [ s ] isn ' t ' a ' ; TAB3 if tou = - 1 then set tou to s ; TAB3 set mk to 1 ; TAB2 else ; TAB3 if tou ins ' t - 1 ; TAB4 set wei to s - 1 ; TAB4 exit loop ; TAB1 if wei = - 1 and mk = 1 then set wei to size of a - 1 ; TAB1 if mk = 0 then ; TAB2 set last elem of a to ' z ' ; TAB1 else ; TAB2 for s = max between 0 to long long and tou , until s < = wei , increment s after , set a [ s ] to ( a [ s ] to int - 1 ) to char ; TAB1 print a ;	string a ; long long tou = - 1 , wei = - 1 , mk ; int main ( ) { cin >> a ; for ( int s = 0 ; s < a . size ( ) ; s ++ ) { if ( a [ s ] != ' a ' ) { if ( tou == - 1 ) tou = s ; mk = 1 ; } else { if ( tou != - 1 ) { wei = s - 1 ; break ; } } } if ( wei == - 1 && mk == 1 ) wei = a . size ( ) - 1 ; if ( mk == 0 ) { a [ a . size ( ) - 1 ] = ' z ' ; } else for ( int s = max ( ( long long ) 0 , tou ) ; s <= wei ; s ++ ) { a [ s ] = char ( ( int ) a [ s ] - 1 ) ; } cout << a << endl ; }
TAB0 in function isprime taking long long n and returning bool ; TAB1 flag = bool with flag = true ; TAB1 i = long long ; TAB1 for i = 2 to sqrt of n as long long ; TAB2 if n is a multiple of i ; TAB3 set flag to false ; TAB3 break ; TAB1 return flag ; TAB1 m = long long ; TAB1 read m ; TAB1 if m is 1 ; TAB2 print 3 ; TAB1 else if m is uneven ; TAB2 print 1 ; TAB1 else ; TAB2 i = long long ; TAB2 iterate i from 1 ; TAB3 if not isprime of ( i * m + 1 ) break ; TAB2 print i ;	bool isprime ( long long n ) { bool flag = true ; long long i ; for ( i = 2 ; i <= ( long long ) sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { flag = false ; break ; } } return flag ; } int main ( ) { long long m ; cin >> m ; if ( m == 1 ) cout << 3 << endl ; else if ( m % 2 == 1 ) cout << 1 << endl ; else { long long i ; for ( i = 1 ; ; i ++ ) { if ( ! isprime ( i * m + 1 ) ) break ; } cout << i << endl ; } return 0 ; }
TAB0 in bool function check taking num = int ; TAB1 if sum is 2 or num is 3 then return 1 ; TAB1 if num mod 6 isn ' t 1 and sum mod 6 isn ' t 5 then return 0 ; TAB1 for i = 5 to i ^ 2 < = num incrementing i by 6 ; TAB2 if num mod i = 0 or num mod ( i + 2 ) = 0 then return 0 ; TAB1 return 1 ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 1 to 1000 inclusive ; TAB2 if check of i * n + 1 is 0 ; TAB3 print i ;	bool check ( int num ) { if ( num == 2 || num == 3 ) return 1 ; if ( num % 6 != 1 && num % 6 != 5 ) return 0 ; for ( int i = 5 ; i * i <= num ; i += 6 ) if ( num % i == 0 || num % ( i + 2 ) == 0 ) return 0 ; return 1 ; } int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= 1000 ; ++ i ) { if ( check ( i * n + 1 ) == 0 ) { cout << i << endl ; return 0 ; } } }
TAB0 create map mapp from string to double ; TAB0 create map iterator it from string to double ; TAB1 create integers n , m ; TAB1 create double k ; TAB1 create string name ; TAB1 create double num ; TAB1 while read n read m read k ; TAB2 remove all elements from mapp ; TAB2 for i = 0 to n exclusive ; TAB3 read nam read num ; TAB3 if num * k is greater than or equal to 100 ; TAB4 create integer temp with temp = num * k + 0 . 001 ; TAB4 increment mapp [ nam ] by double casted temp ; TAB2 for i = 0 to m exclusive ; TAB3 read nam ; TAB3 if mapp [ nam ] is 0 , increment mapp [ nam ] by 0 ; TAB2 print size of mapp print newline ; TAB2 for it = beginning of mapp to it is not end of mapp , print first element of it print " " print second element of it print newline ;	map < string , double > mapp ; map < string , double > :: iterator it ; int main ( ) { int n , m ; double k ; string nam ; double num ; while ( cin >> n >> m >> k ) { mapp . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> nam >> num ; if ( num * k >= 100 ) { int temp = num * k + 0.001 ; mapp [ nam ] += ( double ) temp ; } } for ( int i = 0 ; i < m ; i ++ ) { cin >> nam ; if ( mapp [ nam ] == 0 ) { mapp [ nam ] += 0 ; } } cout << mapp . size ( ) << endl ; for ( it = mapp . begin ( ) ; it != mapp . end ( ) ; it ++ ) { cout << it -> first << "   " << it -> second << endl ; } } }
TAB0 declare f with long long n as argument , returning long long ; TAB1 create long long sum with sum = 0 ; TAB1 if n is less than 10 ; TAB2 set sum to n ; TAB1 else ; TAB2 set sum to n / 10 + 9 ; TAB2 create integer j with j = n % 10 ; TAB2 while n is greater than or equal to 10 , set n to n / 10 ; TAB2 if n is greater than j , decrement sum ; TAB1 return sum from function ; TAB1 create long longs l , r , cnt with cnt = 0 ; TAB1 read l read r ; TAB1 if r is less than 10 ; TAB2 set cnt to r - l + 1 ; TAB1 else ; TAB2 set cnt to result of run f with r as argument - result of run f with l - 1 as argument ; TAB1 print cnt print newline ;	long long f ( long long n ) { long long sum = 0 ; if ( n < 10 ) sum = n ; else { sum = n / 10 + 9 ; int j = n % 10 ; while ( n >= 10 ) n /= 10 ; if ( n > j ) sum -- ; } return sum ; } int main ( ) { long long l , r , cnt = 0 ; cin >> l >> r ; if ( r < 10 ) { cnt = r - l + 1 ; } else { cnt = f ( r ) - f ( l - 1 ) ; } cout << cnt << endl ; return 0 ; }
TAB1 declare long longs a and b ; TAB1 read a and b and keep looping ; TAB2 declare new string variable s ; TAB2 declare long long variables x and y = 0 ; TAB2 read standard input to s ; TAB2 create new long long called i ; TAB2 for i = 0 to length of s exclusive ; TAB3 if x = a and y = b , stop the loop ; TAB3 if s [ i ] is equal to ' L ' , change x to x - 1 ; TAB3 if s [ i ] = ' R ' , change x to the sum of x and 1 ; TAB3 if s [ i ] = ' U ' , change y to the sum of y and 1 ; TAB3 if s [ i ] = ' D ' , decrease y by 1 ; TAB2 declare new long long variable j ; TAB2 if i = length of s ; TAB3 for j from 0 to length of s exclusive ; TAB4 if s [ j ] is equal to ' L ' , increase a by 1 ; TAB4 if s [ j ] is equal to ' R ' , subtract 1 from a ; TAB4 if s [ j ] is equal to ' U ' , subtract 1 from b ; TAB4 if s [ j ] is equal to ' D ' , add 1 to b ; TAB4 if a = 0 and b is equal to 0 , stop the loop ; TAB4 create long long variable da with value = absolute value of a ; TAB4 declare new long long db with value abs ( b ) ; TAB4 dx is a new long long variable = abs ( x ) ; TAB4 declare long long variable dy = absolute value of y ; TAB4 if a * y = b * x & & a * x > = 0 & & b * y > = 0 ; TAB5 if a ! = 0 and b ! = 0 ; TAB6 if dx ! = 0 and dy ! = 0 ; TAB7 if da % dx = 0 and db % dy = 0 , break the loop ; TAB5 else if a ! = 0 and b = 0 ; TAB6 if dx ! = 0 ; TAB7 if dy is equal to 0 and da % dx = 0 , stop the loop ; TAB5 else if a = 0 and b ! = 0 ; TAB6 if dy ! = 0 ; TAB7 if dx = 0 and db % dy is equal to 0 , break ; TAB3 if j ! = length of s ; TAB4 print " Yes " ; TAB3 else ; TAB4 print " No " to the standard output ; TAB2 else ; TAB3 print " Yes " ;	int main ( ) { long long a , b ; while ( cin >> a >> b ) { string s ; long long x = 0 , y = 0 ; cin >> s ; long long i ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { if ( x == a && y == b ) break ; if ( s [ i ] == ' L ' ) x -= 1 ; if ( s [ i ] == ' R ' ) x += 1 ; if ( s [ i ] == ' U ' ) y += 1 ; if ( s [ i ] == ' D ' ) y -= 1 ; } long long j ; if ( i == s . size ( ) ) { for ( j = 0 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] == ' L ' ) a += 1 ; if ( s [ j ] == ' R ' ) a -= 1 ; if ( s [ j ] == ' U ' ) b -= 1 ; if ( s [ j ] == ' D ' ) b += 1 ; if ( a == 0 && b == 0 ) break ; long long da = abs ( a ) ; long long db = abs ( b ) ; long long dx = abs ( x ) ; long long dy = abs ( y ) ; if ( ( long long ) a * y == ( long long ) b * x && ( long long ) a * x >= 0 && ( long long ) b * y >= 0 ) { if ( a != 0 && b != 0 ) { if ( dx != 0 && dy != 0 ) { if ( da % dx == 0 && db % dy == 0 ) break ; } } else if ( a != 0 && b == 0 ) { if ( dx != 0 ) { if ( dy == 0 && da % dx == 0 ) break ; } } else if ( a == 0 && b != 0 ) { if ( dy != 0 ) { if ( dx == 0 && db % dy == 0 ) break ; } } } } if ( j != s . size ( ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } else { cout << " Yes " << endl ; } } return 0 ; }
TAB0 s = character array of size 30 ; TAB0 mx = long long = - 1 ; TAB0 in function to_int with argument character pointer p that returns a long long ; TAB1 res = long long = 0 ; TAB1 if p [ 1 ] is not 0 and p [ 0 ] is 0 , then return - 1 ; TAB1 while p is nonzero ; TAB2 res = ( res * 10 ) + ( p [ 0 ] - 0 ) ; TAB2 if res > 1e6 in integer form , then return - 1 ; TAB2 increase p by 1 ; TAB1 return res ; TAB0 in function run with arguments of character p = s , integer r = 0 , integer sum = 0 that returns nothing ; TAB1 if r is 2 ; TAB2 rem = long long = call to_int with argument p ; TAB2 if rem is not - 1 , then mx = bigger value between mx and sum + rem ; TAB2 return nothing ; TAB1 sm = long long = 0 ; TAB1 while p [ 2 - r ] is nonzero ; TAB2 sm = ( sm * 10 ) + ( p [ 0 ] - 0 ) ; TAB2 if sm > 1e6 in integer form , then exit while loop ; TAB2 call run with arguments p + 1 , r + 1 , and sum + sm ; TAB2 if sum is 0 , then exit the while loop ; TAB2 increase p by 1 ; TAB1 read s ; TAB1 call run ; TAB1 print mx ;	char s [ 30 ] ; long long mx = - 1 ; long long to_int ( char * p ) { long long res = 0 ; if ( p [ 1 ] != 0 && p [ 0 ] == ' 0 ' ) return - 1 ; while ( * p ) { res = ( res * 10 ) + ( p [ 0 ] - ' 0 ' ) ; if ( res > int ( 1e6 ) ) return - 1 ; p ++ ; } return res ; } void run ( char * p = s , int r = 0 , int sum = 0 ) { if ( r == 2 ) { long long rem = to_int ( p ) ; if ( rem != - 1 ) mx = max ( mx , sum + rem ) ; return ; } long long sm = 0 ; while ( p [ 2 - r ] ) { sm = ( sm * 10 ) + ( p [ 0 ] - ' 0 ' ) ; if ( sm > int ( 1e6 ) ) break ; run ( p + 1 , r + 1 , sum + sm ) ; if ( sm == 0 ) break ; p ++ ; } } int main ( ) { cin >> s ; run ( ) ; cout << mx << endl ; return 0 ; }
TAB1 declare long longs a , b , l , r and k ; TAB1 read from the input to a , b , l , r and k ; TAB1 sum is a new long long = 0 ; TAB1 if a < = r and l < a ; TAB2 change sum to the sum of sum and r - a + 1 ; TAB2 if k > = a and k < = r , change sum to sum - 1 ; TAB1 if l < = b and b < r ; TAB2 increase sum by b - l + 1 ; TAB2 if k > = l and k < = b , subtract 1 from sum ; TAB1 if a < = l and b > = r ; TAB2 set sum to r - l + 1 ; TAB2 if k > = l and k < = r , change sum to sum - 1 ; TAB1 if l < = a and r > = b ; TAB2 change the value of sum to b - a + 1 ; TAB2 if k > = a and k < = b , change sum to sum - 1 ; TAB1 print sum ;	int main ( ) { long long a , b , l , r , k ; cin >> a >> b >> l >> r >> k ; long long sum = 0 ; if ( a <= r and l < a ) { sum += r - a + 1 ; if ( k >= a and k <= r ) sum -= 1 ; } if ( l <= b and b < r ) { sum += b - l + 1 ; if ( k >= l and k <= b ) sum -= 1 ; } if ( a <= l and b >= r ) { sum = r - l + 1 ; if ( k >= l and k <= r ) sum -= 1 ; } if ( l <= a and r >= b ) { sum = b - a + 1 ; if ( k >= a and k <= b ) sum -= 1 ; } cout << sum << endl ; return 0 ; }
TAB0 declare boolean array v size 12 by 12 ; TAB0 declare isOK with integer a as argument , returning boolean ; TAB1 declare integer array add size 12 ; TAB1 declare integer count = 0 ; TAB1 set bytes from add to size of add to value 0 ; TAB1 for i = 0 to 5 exclusive ; TAB2 for j = 5 to 10 exclusive ; TAB3 if v [ i ] [ j ] is true ; TAB4 if ( ( ( a bitwise and ( 1 bitshift left i ) ) is 0 ) and ( ( a bitwise and ( 1 bitshift left j ) ) is 0 ) ) , increment count ; TAB4 if ( ( ( a bitwise and ( 1 bitshift left i ) ) is 0 ) and ( ( a bitwise and ( 1 bitshift left j ) ) is not 0 ) ) , increment add [ j ] ; TAB4 ( ( ( a bitwise and ( 1 bitshift left i ) ) is not 0 ) and ( ( a bitwise and ( 1 bitshift left j ) ) is 0 ) ) , increment add [ i ] ; TAB1 if count is greater than 1 , return false from function ; TAB1 for i = 0 to 10 exclusive ; TAB2 if add [ i ] is greater than 1 , return false from function ; TAB1 return true from function ; TAB1 declare integer N ; TAB1 while read N is true ; TAB2 set bytes from v to size of v to value 0 ; TAB2 declare string s ; TAB2 for i = 0 to N exclusive ; TAB3 read s ; TAB3 declare integer t ; TAB3 if s [ 0 ] is ' R ' ; TAB4 let t be 0 ; TAB3 else if s [ 0 ] is ' G ' ; TAB4 let t be 1 ; TAB3 else if s [ 0 ] is ' B ' ; TAB4 let t be 2 ; TAB3 else if s [ 0 ] is ' Y ' ; TAB4 let t be 3 ; TAB3 else if s [ 0 ] is ' W ' ; TAB4 let t be 4 ; TAB3 declare integer y = s [ 1 ] - ' 0 ' + 4 ; TAB3 let v [ t ] [ y ] be true ; TAB2 declare integer ans = 0x3f3f3f3f ; TAB2 for i = 0 to i is less than ( 1 bitshift left 10 ) , incrementing i ; TAB3 if result of run isOK ( i ) is true ; TAB4 declare integer t = i ; TAB4 declare integer count = 0 ; TAB4 while t is true ; TAB5 if t bitwise and 1 , increment count ; TAB5 let t be t / 2 ; TAB4 let ans be minimumm of ans and count ; TAB2 print ans and newline ;	bool v [ 12 ] [ 12 ] ; bool isOK ( int a ) { int add [ 12 ] ; int count = 0 ; memset ( add , 0 , sizeof ( add ) ) ; for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 5 ; j < 10 ; j ++ ) { if ( v [ i ] [ j ] ) { if ( ( ( a & ( 1 << i ) ) == 0 ) && ( ( a & ( 1 << j ) ) == 0 ) ) count ++ ; if ( ( ( a & ( 1 << i ) ) == 0 ) && ( ( a & ( 1 << j ) ) != 0 ) ) add [ j ] ++ ; if ( ( ( a & ( 1 << i ) ) != 0 ) && ( ( a & ( 1 << j ) ) == 0 ) ) add [ i ] ++ ; } } } if ( count > 1 ) { return false ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( add [ i ] > 1 ) return false ; } return true ; } int main ( ) { int N ; while ( cin >> N ) { memset ( v , 0 , sizeof ( v ) ) ; string s ; for ( int i = 0 ; i < N ; i ++ ) { cin >> s ; int t ; if ( s [ 0 ] == ' R ' ) t = 0 ; else if ( s [ 0 ] == ' G ' ) t = 1 ; else if ( s [ 0 ] == ' B ' ) t = 2 ; else if ( s [ 0 ] == ' Y ' ) t = 3 ; else if ( s [ 0 ] == ' W ' ) t = 4 ; int y = s [ 1 ] - ' 0 ' + 4 ; v [ t ] [ y ] = true ; } int ans = 0x3f3f3f3f ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { if ( isOK ( i ) ) { int t = i ; int count = 0 ; while ( t ) { if ( t & 1 ) { count ++ ; } t /= 2 ; } ans = min ( ans , count ) ; } } cout << ans << endl ; } }
TAB0 the constant integer value of maxn = 3 * ( 1e5 ) + 100 ; TAB0 the constant integer value of maxnn = ( int ) ( ( 1 . 5 ) * ( 1e7 ) + 100 ) ; TAB0 let n be a integer ; TAB0 a = array of integers of length maxn ; TAB0 cnt = array of integers of length maxnn ; TAB0 pri = array of integers of length maxnn ; TAB0 isp = array of boolean values of length maxnn ; TAB0 the integer value of p = 0 ; TAB0 let init be a void function that accepts int n ; TAB1 for i = 2 to n inclusive ; TAB2 if isp [ i ] is equal to 0 , pri [ + + p ] is equal to i ; TAB2 for integer j = 1 , j < = p and i * pri [ j ] < = n , increment j by 1 ; TAB3 isp [ i * pri [ j ] ] is equal to 1 ; TAB3 if i modulo pri [ j ] equals 0 , stop ; TAB0 let ispri be a function that accepts int n and returns a boolean value ; TAB1 if n equals 1 , return 0 ; TAB1 for i = 2 to n / i inclusive ; TAB2 if n modulo i equals 0 , return 0 ; TAB1 return 1 ; TAB1 send maxnn into init ; TAB1 while read n ; TAB2 memset of cnt , 0 , length of cnt ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 the integer value of gcdd = a [ 0 ] ; TAB2 for i = 1 to n exclusive , gcdd is equal to __gcd ( gcdd , a [ i ] ) ; TAB2 the integer value of maxx = - 1 ; TAB2 for i = 0 to n exclusive ; TAB3 divide a [ i ] by gcdd ; TAB3 for integer j = 1 , j < = p and pri [ j ] * pri [ j ] < = a [ i ] , increment j by 1 ; TAB4 if a [ i ] modulo pri [ j ] equals 0 , increment cnt [ pri [ j ] ] by 1 ; TAB4 maxx = maximum of maxx and cnt [ pri [ j ] ] ; TAB4 while a [ i ] modulo pri [ j ] equals 0 , divide a [ i ] by pri [ j ] ; TAB3 if a [ i ] is greater than 1 , increment cnt [ a [ i ] ] by 1 ; TAB3 maxx = maximum of maxx and cnt [ a [ i ] ] ; TAB2 if maxx equals 0 ; TAB3 print - 1 and new line ; TAB2 else do the following ; TAB3 print n - maxx and newline ;	const int maxn = 3 * ( 1e5 ) + 100 ; const int maxnn = ( int ) ( ( 1.5 ) * ( 1e7 ) + 100 ) ; int n ; int a [ maxn ] ; int cnt [ maxnn ] ; int pri [ maxnn ] ; bool isp [ maxnn ] ; int p = 0 ; void init ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( isp [ i ] == 0 ) { pri [ ++ p ] = i ; } for ( int j = 1 ; j <= p && i * pri [ j ] <= n ; ++ j ) { isp [ i * pri [ j ] ] = 1 ; if ( i % pri [ j ] == 0 ) { break ; } } } } bool ispri ( int n ) { if ( n == 1 ) { return 0 ; } for ( int i = 2 ; i <= n / i ; ++ i ) { if ( n % i == 0 ) { return 0 ; } } return 1 ; } int main ( ) { init ( maxnn ) ; while ( cin >> n ) { memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; } int gcdd = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { gcdd = __gcd ( gcdd , a [ i ] ) ; } int maxx = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] /= gcdd ; for ( int j = 1 ; j <= p && pri [ j ] * pri [ j ] <= a [ i ] ; ++ j ) { if ( a [ i ] % pri [ j ] == 0 ) { cnt [ pri [ j ] ] ++ ; } maxx = max ( maxx , cnt [ pri [ j ] ] ) ; while ( a [ i ] % pri [ j ] == 0 ) { a [ i ] /= pri [ j ] ; } } if ( a [ i ] > 1 ) { cnt [ a [ i ] ] ++ ; } maxx = max ( maxx , cnt [ a [ i ] ] ) ; } if ( maxx == 0 ) { cout << - 1 << endl ; } else { cout << n - maxx << endl ; } } return 0 ; }
TAB0 a , x , b , temp = integers ; TAB1 read a ; TAB1 for x = 0 to a exclusive ; TAB2 read b ; TAB2 if b is 1 , increment temp ; TAB1 if a is 1 and temp is 1 ; TAB2 print YES ; TAB1 else if a is not 1 and temp is a - 1 ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int a , x , b , temp ; int main ( ) { cin >> a ; for ( x = 0 ; x < a ; x ++ ) { cin >> b ; if ( b == 1 ) temp ++ ; } if ( a == 1 && temp == 1 ) cout << " YES " << endl ; else if ( a != 1 && temp == a - 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 create string s , ss ; TAB1 create int L ; TAB1 while get L do till valid input ; TAB2 get a character ; TAB2 get s ; TAB2 create integer k with k = 1 ; TAB2 for integer i = 0 to L - 1 with increment i ; TAB3 if s [ i ] is equal to ' 1 ' and k then ; TAB4 append ' 1 ' to ss ; TAB4 set k to 0 ; TAB4 skip and go to next iteration of the loop ; TAB3 if s [ i ] is equal to ' 0 ' then append ' 0 ' to ss ; TAB2 print ss ; TAB2 clear ss ;	int main ( ) { string s , ss ; int L ; while ( cin >> L ) { getchar ( ) ; cin >> s ; int k = 1 ; for ( int i = 0 ; i < L ; i ++ ) { if ( s [ i ] == ' 1 ' && k ) { ss . push_back ( ' 1 ' ) ; k = 0 ; continue ; } if ( s [ i ] == ' 0 ' ) ss . push_back ( ' 0 ' ) ; } cout << ss << endl ; ss . clear ( ) ; } return 0 ; }
TAB1 s , n , count = long long with count = 0 and arrx , arry = long long array of size 10005 each ; TAB1 read s then n ; TAB1 read n values into arrx then arry ; TAB1 for c = 0 to n - 1 ; TAB2 for d = 0 to n - c - 1 ; TAB3 if arrx [ d ] > arrx [ d + 1 ] ; TAB4 wap = int with wap = arrx [ d ] ; TAB4 set arrx [ d ] to arrx [ d + 1 ] ; TAB4 set arrx [ d + 1 ] to wap ; TAB4 set wap to arry [ d ] ; TAB4 set arry [ d ] to arry [ d + 1 ] ; TAB4 set arryy [ d + 1 ] to wap ; TAB1 for i = 0 to n ; TAB2 if s > arrx [ i ] ; TAB3 increment s by arry [ i ] ; TAB2 else ; TAB3 print " NO " ; TAB1 print " YES " ;	int main ( ) { long long s , n , arrx [ 10005 ] , arry [ 10005 ] , count = 0 ; cin >> s >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arrx [ i ] >> arry [ i ] ; } for ( int c = 0 ; c < n - 1 ; c ++ ) { for ( int d = 0 ; d < n - c - 1 ; d ++ ) { if ( arrx [ d ] > arrx [ d + 1 ] ) { int wap = arrx [ d ] ; arrx [ d ] = arrx [ d + 1 ] ; arrx [ d + 1 ] = wap ; wap = arry [ d ] ; arry [ d ] = arry [ d + 1 ] ; arry [ d + 1 ] = wap ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( s > arrx [ i ] ) { s += arry [ i ] ; } else { cout << " NO\n " ; return 0 ; } } cout << " YES\n " ; return 0 ; }
TAB1 create ints k and i and int arrays l of size 101 and x of size 101 ; TAB1 for i = 3 to 100 , set l [ i ] to i * ( i - 1 ) * ( i - 2 ) / 6 ; TAB1 for i = 1 to 100 , set x [ i ] to i * ( i + 1 ) / 2 ; TAB1 read k and while k is truthy ; TAB2 create int l1 = 0 and int array ans of size 101 with array of size 101 containing { 0 } ; TAB2 for i = 3 to 100 ; TAB3 if k is less than l [ i ] , break loop ; TAB2 decrease i by 1 ; TAB2 set k to k - l [ i ] ; TAB2 create integers j , count = i , and ii ; TAB2 for j = 0 to i exclusive ; TAB3 for ii = j + 1 to i exclusive , set ans [ ii ] [ j ] and ans [ j ] [ ii ] to 1 ; TAB2 for j = i to 0 exclusive ; TAB3 if k is greater than or equal to x [ j ] ; TAB4 for ii = 0 to j , set ans [ ii ] [ count ] and ans [ count ] [ ii ] to i ; TAB4 increase count by 1 ; TAB4 set k to k - x [ j ] ; TAB3 else do ; TAB4 subtract 1 from j ; TAB2 print count ; TAB2 for ii = 0 to count exclusive ; TAB3 for j = 0 to count - 1 exclusive , display ans [ ii ] [ j ] ; TAB3 show ans [ ii ] [ count - 1 ] ; TAB3 end statement ;	int main ( ) { int k , l [ 101 ] , i , x [ 101 ] ; for ( i = 3 ; i <= 100 ; i ++ ) l [ i ] = i * ( i - 1 ) * ( i - 2 ) / 6 ; for ( i = 1 ; i <= 100 ; i ++ ) x [ i ] = i * ( i + 1 ) / 2 ; while ( cin >> k ) { int ll = 0 , ans [ 101 ] [ 101 ] = { 0 } ; for ( i = 3 ; i <= 100 ; i ++ ) if ( k < l [ i ] ) break ; i -- ; k -= l [ i ] ; int j , count = i , ii ; for ( j = 0 ; j < i ; j ++ ) for ( ii = j + 1 ; ii < i ; ii ++ ) ans [ ii ] [ j ] = ans [ j ] [ ii ] = 1 ; for ( j = i ; j > 0 ; ) if ( k >= x [ j ] ) { for ( ii = 0 ; ii <= j ; ii ++ ) ans [ ii ] [ count ] = ans [ count ] [ ii ] = 1 ; count ++ ; k -= x [ j ] ; } else j -- ; cout << count << endl ; for ( ii = 0 ; ii < count ; ii ++ ) { for ( j = 0 ; j < count - 1 ; j ++ ) cout << ans [ ii ] [ j ] ; cout << ans [ ii ] [ count - 1 ] << endl ; ; } } }
TAB0 n = integer ; TAB1 s = string ; TAB1 read s ; TAB1 a , b = integer ; TAB1 a = b = 0 ; TAB1 i = integer = 0 ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] is | , then increase a by 1 ; TAB2 if s [ i ] is = , then exit for loop ; TAB1 for current value of i to size of s exclusive ; TAB2 if s [ i ] is | , then increase b by 1 ; TAB1 if the absolute value of a - b is not 2 and a is not b ; TAB2 print Impossible ; TAB1 else ; TAB2 if a is b ; TAB3 print s ; TAB2 else if a < b ; TAB3 print | ; TAB3 for i = 0 to size of i - 1 exclusive , then print s [ i ] ; TAB2 else ; TAB3 if s [ 1 ] is not + ; TAB4 for i = 1 to size of s , then print s [ i ] ; TAB4 print | ; TAB3 else ; TAB4 print s [ 0 ] s [ 1 ] ; TAB4 s = s + | ; TAB4 for i = 3 to size of s exclusive , then print s [ i ] ; TAB1 print endline ;	int n ; int main ( ) { string s ; cin >> s ; int a , b ; a = b = 0 ; int i = 0 ; for ( ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' | ' ) a ++ ; if ( s [ i ] == ' = ' ) break ; } for ( ; i < s . size ( ) ; i ++ ) if ( s [ i ] == ' | ' ) b ++ ; if ( abs ( a - b ) != 2 && a != b ) cout << " Impossible " ; else { if ( a == b ) cout << s ; else if ( a < b ) { cout << ' | ' ; for ( int i = 0 ; i < s . size ( ) - 1 ; i ++ ) cout << s [ i ] ; } else { if ( s [ 1 ] != ' + ' ) { for ( int i = 1 ; i < s . size ( ) ; i ++ ) cout << s [ i ] ; cout << ' | ' ; } else { cout << s [ 0 ] << s [ 1 ] ; s += ' | ' ; for ( int i = 3 ; i < s . size ( ) ; i ++ ) cout << s [ i ] ; } } } cout << endl ; return 0 ; }
TAB1 declare integers n , res = 0 ; TAB1 declare string s ; TAB1 read n and s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is not ' < ' , end loop ; TAB2 increment res ; TAB1 for i = n - 1 to 0 inclusive , decrementing i ; TAB2 if s [ i ] is not ' > ' , end loop ; TAB2 increment res ; TAB1 print res and newline ;	int main ( ) { int n , res = 0 ; string s ; cin >> n >> s ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] != ' < ' ) break ; res ++ ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] != ' > ' ) break ; res ++ ; } cout << res << endl ; return 0 ; }
TAB0 h , v = bool array of size 3000 each ; TAB0 ans = int vector ; TAB1 n = int ; TAB1 read n ; TAB1 a , b = int ; TAB1 for i = 0 to n * n ; TAB2 read a then b ; TAB2 if h [ a ] and v [ b ] are false ; TAB3 append i + 1 to ans ; TAB2 else ; TAB3 continue ; TAB2 set h [ a ] and v [ b ] to true ; TAB1 for i = 0 to size of ans print ans [ i ] then ' ' if i is less than size of ans - 1 else ' \ n ' ;	bool h [ 3000 ] , v [ 3000 ] ; vector < int > ans ; int main ( ) { int n ; cin >> n ; int a , b ; for ( int i = 0 ; i < n * n ; ++ i ) { cin >> a >> b ; if ( ! h [ a ] && ! v [ b ] ) ans . push_back ( i + 1 ) ; else continue ; h [ a ] = v [ b ] = true ; } for ( int i = 0 ; i < ans . size ( ) ; ++ i ) cout << ans [ i ] << ( i + 1 == ans . size ( ) ? ' \n ' : '   ' ) ; return 0 ; }
TAB0 declare constant integer variable maxn = 1e6 ; TAB0 create new integers n , t and f ; TAB1 create boolean variable with name b with value true ; TAB1 read n ; TAB1 in a loop from i = 0 to n exclusive ; TAB2 declare new integer called x ; TAB2 read x ; TAB2 if x is equal to 25 ; TAB3 increment t ; TAB2 else if x is equal to 50 ; TAB3 if t > = 1 ; TAB4 decrement t by one and increment f ; TAB3 else ; TAB4 change the value of b to false ; TAB2 else if x is equal to 100 ; TAB3 if f > = 1 and t > = 1 ; TAB4 decrement f and decrement t ; TAB3 else if f < = 0 and t > = 3 ; TAB4 change t to t - 3 ; TAB3 else ; TAB4 change the value of b to false ; TAB1 print " YES " and " \ n ;	const int maxn = 1e6 ; int n , t , f ; int main ( ) { bool b = true ; cin >> n ; for ( int i = int ( 0 ) ; i < int ( n ) ; i ++ ) { int x ; cin >> x ; if ( x == 25 ) t ++ ; else if ( x == 50 ) { if ( t >= 1 ) t -- , f ++ ; else b = false ; } else if ( x == 100 ) { if ( f >= 1 && t >= 1 ) f -- , t -- ; else if ( f <= 0 && t >= 3 ) t -= 3 ; else b = false ; } } b ? cout << " YES " << ' \n ' : cout << " NO " << ' \n ' ; return 0 ; }
TAB1 a , b , c , d , i , j are all integers with i and j both set to 0 ; TAB1 read a , b , c , d ; TAB1 while i is less than 10000 ; TAB2 increment i ; TAB2 if d is greater than b ; TAB3 add a to b ; TAB2 else if d is less than b ; TAB3 add c to d ; TAB2 else if d is b ; TAB3 display d ; TAB2 else ; TAB3 break ; TAB1 display - 1 ;	int main ( ) { int a , b , c , d , i = 0 , j = 0 ; cin >> a >> b >> c >> d ; while ( i < 10000 ) { i ++ ; if ( d > b ) { b += a ; } else if ( d < b ) { d += c ; } else if ( d == b ) { cout << d << endl ; return 0 ; } else { break ; } } cout << " -1 " << endl ; return 0 ; }
TAB1 a , b , c , d , e , f = doubles ; TAB1 read a , b , c , d , e and f ; TAB1 if a * c * e is less than b * d * f or ( not c and d ) or ( not a and b and d ) ; TAB2 print Ron ; TAB1 else ; TAB2 print Hermione ;	int main ( ) { double a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( a * c * e < b * d * f || ( ! c && d ) || ( ! a && b && d ) ) { puts ( " Ron " ) ; } else { puts ( " Hermione " ) ; } return 0 ; }
TAB0 s = string ; TAB0 n , k = int ; TAB1 read s then k ; TAB1 set n to size of s as int ; TAB1 if n mod k ; TAB2 print " NO " ; TAB3 then newline ; TAB1 step = int with step = n / k ; TAB1 for i = 0 to k - 1 inclusive ; TAB2 for j = 0 to step - 1 inclusive ; TAB3 if s [ i * step + j ] is not s [ i * step + step - j - 1 ] ; TAB4 print " NO " ; TAB5 then newline ; TAB1 print " YES " ; TAB2 then newline ;	string s ; int n , k ; int main ( ) { cin >> s >> k ; n = ( int ) ( s ) . size ( ) ; if ( n % k ) { cout << " NO " << " \n " ; return 0 ; } int step = n / k ; for ( int i = ( 0 ) ; i <= ( k - 1 ) ; i ++ ) { for ( int j = ( 0 ) ; j <= ( step - 1 ) ; j ++ ) { if ( s [ i * step + j ] != s [ i * step + step - j - 1 ] ) { cout << " NO " << " \n " ; return 0 ; } } } cout << " YES " << " \n " ; return 0 ; }
TAB1 l1 , r1 , l2 , r2 , k = long longs ; TAB1 read l1 , r1 , l2 , r2 , and k ; TAB1 l = long long set to max ( l1 , l2 ) ; TAB1 r = long long set to min ( r1 , r2 ) ; TAB1 if l greater than r ; TAB2 print 0 ; TAB1 else ; TAB2 if k > = 1 and k < = r ; TAB3 print abs ( r - l ) ; TAB2 else ; TAB3 print abs ( r - l + 1 ) ;	int main ( ) { long long l1 , r1 , l2 , r2 , k ; cin >> l1 >> r1 >> l2 >> r2 >> k ; long long l = max ( l1 , l2 ) ; long long r = min ( r1 , r2 ) ; if ( l > r ) cout << 0 << endl ; else { if ( k >= l && k <= r ) { cout << abs ( r - l ) << endl ; } else { cout << abs ( r - l + 1 ) << endl ; } } }
TAB0 N = constant integer = 5e3 ; TAB0 MOD = constant long long = 1e9 + 7 ; TAB0 dp = long long array of size N = 2 and width N + 2 , ans = long long ; TAB0 a , b = string ; TAB1 read a , b ; TAB1 for i = size of a - 1 to 0 inclusive where i decreases by 1 at end of a loop ; TAB2 for j = size of b - 1 to 0 inclusive , where j decreases at the end of the loop ; TAB3 dp [ i ] [ j ] = dp [ i ] [ j + 1 ] ; TAB3 if a [ i ] is b [ j ] , then dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i + 1 ] [ j + 1 ] + 1 ) modulo mod ; TAB2 ans = ( ans + dp [ i ] [ 0 ] ) modulo mod ; TAB1 print ans ;	const int N = 5e3 ; const long long mod = 1e9 + 7 ; long long dp [ N + 2 ] [ N + 2 ] , ans ; string a , b ; int main ( ) { cin >> a >> b ; for ( int i = a . size ( ) - 1 ; i >= 0 ; i -- ) { for ( int j = b . size ( ) - 1 ; j >= 0 ; j -- ) { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] ; if ( a [ i ] == b [ j ] ) dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i + 1 ] [ j + 1 ] + 1 ) % mod ; } ans = ( ans + dp [ i ] [ 0 ] ) % mod ; } cout << ans << endl ; return 0 ; }
TAB1 make character array s of size 100005 ; TAB1 make integer j = 0 ; TAB1 read s ; TAB1 while s [ j ] equals ' a ' , increment j ; TAB1 if s [ j ] equals ' \ 0 ' ; TAB2 set s [ j - 1 ] to ' z ' ; TAB2 print s ; TAB1 for int i = j ; s [ i ] is not equal to ' a ' and s [ i ] is not equal to ' \ 0 ' ; increment i do decrement s [ i ] ; TAB1 print s ;	int main ( ) { char s [ 100005 ] ; int j = 0 ; gets ( s ) ; while ( s [ j ] == ' a ' ) j ++ ; if ( s [ j ] == ' \0 ' ) { s [ j - 1 ] = ' z ' ; puts ( s ) ; return 0 ; } for ( int i = j ; s [ i ] != ' a ' && s [ i ] != ' \0 ' ; i ++ ) s [ i ] -- ; puts ( s ) ; return 0 ; }
TAB1 let n , k ints ; TAB1 let s a string ; TAB1 read n and k ; TAB1 read str ; TAB1 let m = int with value 0 ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if prefix of str of length i equals suffix of str of length i , set m to i + 1 ; TAB1 print str ; TAB1 print substring of str starting at index m k - 1 times ; TAB1 print newline ;	int main ( ) { int n , k ; string str ; cin >> n >> k ; cin >> str ; int m = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . substr ( 0 , i + 1 ) == str . substr ( n - i - 1 ) ) { m = i + 1 ; } } cout << str ; for ( int i = 0 ; i <= k - 2 ; i ++ ) { cout << str . substr ( m ) ; } cout << endl ; return 0 ; }
TAB0 create integers n , m , x , y and z ; declare arrays of integers v with 505 elements and e with size 505 by 505 ; TAB0 maxx is a new double variable ; TAB1 set first sizeof ( e ) bytes at the pointer e to - 1 ; TAB1 read n and m from the user input ; TAB1 read standard input to v n times ; TAB1 start for loop from i = 1 to m inclusive incrementing i ; TAB2 read from the input to x , y and z ; TAB2 change e [ x ] [ y ] to z ; TAB2 assign the new value = z to e [ y ] [ x ] ; TAB1 for i from 1 to n inclusive ; TAB2 for j = i to n inclusive , set maxx to the max of maxx and ( v [ i ] + v [ j ] ) / e [ i ] [ j ] ) ; TAB1 set decimal output precision to 15 , set floatfield format flag and print maxx ;	int n , m , v [ 505 ] , e [ 505 ] [ 505 ] , x , y , z ; double maxx ; int main ( ) { memset ( e , - 1 , sizeof ( e ) ) ; cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> v [ i ] ; } for ( int i = 1 ; i <= m ; i ++ ) { cin >> x >> y >> z ; e [ x ] [ y ] = z ; e [ y ] [ x ] = z ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { maxx = max ( maxx , ( double ) ( v [ i ] + v [ j ] ) / e [ i ] [ j ] ) ; } } cout << fixed << setprecision ( 15 ) << maxx << endl ; return 0 ; }
TAB1 declare integers n , tomas = 1 , highest ; TAB1 read n ; TAB1 delare integer array a size n by 4 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 4 exclusive , read a [ i ] [ j ] ; TAB1 let highest = ( a [ 0 ] [ 0 ] + a [ 0 ] [ 1 ] + a [ 0 ] [ 2 ] + a [ 0 ] [ 3 ] ) ; TAB1 for i = 1 to n exclusive ; TAB2 if a [ i ] [ 0 ] + a [ i ] [ 1 ] + a [ i ] [ 2 ] + a [ i ] [ 3 ] is greater than highest , increment tomas ; TAB1 print tomas and newline ;	int main ( ) { int n , tomas = 1 , highest ; cin >> n ; int a [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { cin >> a [ i ] [ j ] ; } } highest = ( a [ 0 ] [ 0 ] + a [ 0 ] [ 1 ] + a [ 0 ] [ 2 ] + a [ 0 ] [ 3 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] [ 0 ] + a [ i ] [ 1 ] + a [ i ] [ 2 ] + a [ i ] [ 3 ] > highest ) { tomas ++ ; } } cout << tomas << endl ; return 0 ; }
TAB0 create long long a [ 100004 ] ; TAB1 create int n ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 count = 0 , m = abs of a [ 1 ] - a [ 2 ] ; TAB1 s = 1 ; TAB1 for i = 1 to n - 1 inclusive ; TAB2 set count to count + abs ( a [ i ] - a [ i + 1 ] ) * s ; TAB2 set s to s * - 1 ; TAB2 set m to max of m and count ; TAB2 if count < 0 ; TAB3 count = 0 ; TAB3 set s to 1 ; TAB3 continue ; TAB1 set count to 0 ; TAB1 assign 1 to s ; TAB1 for i = 2 to n - 1 inclusive ; TAB2 set count to count + abs ( a [ i ] - a [ i + 1 ] ) * s ; TAB2 assign s * - 1 to s ; TAB2 set m to max of m and count ; TAB2 if count < 0 ; TAB3 set count to 0 ; TAB3 s = 1 ; TAB3 continue ; TAB1 print m ;	long long a [ 100004 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; long long count = 0 , m = abs ( a [ 1 ] - a [ 2 ] ) ; int s = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { count += abs ( a [ i ] - a [ i + 1 ] ) * s ; s *= - 1 ; m = max ( m , count ) ; if ( count < 0 ) { count = 0 ; s = 1 ; continue ; } } count = 0 ; s = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { count += abs ( a [ i ] - a [ i + 1 ] ) * s ; s *= - 1 ; m = max ( m , count ) ; if ( count < 0 ) { count = 0 ; s = 1 ; continue ; } } cout << m << endl ; return 0 ; }
TAB0 make const ints N = 1e6 + 5 and Mod = 1e9 + 7 ; TAB1 make integer n ; TAB1 read n ; TAB1 if n % 4 is greater than 1 , print " - 1 \ n " and exit with success ; TAB1 make int array Arr of size n + 2 ; TAB1 if n & 1 is truthy , set Arr [ n / 2 + 1 ] to n / 2 + 1 ; TAB1 for i = 1 to n / 2 by increasing by 2 ; TAB2 set Arr [ i ] to 2 + ( i - 1 ) ; TAB2 set Arr [ i + 1 ] to n - ( i - 1 ) ; TAB2 set Arr [ n - i + 1 ] to n - 1 - ( i - 1 ) ; TAB2 set Arr [ n - 1 ] to 1 + ( i - 1 ) ; TAB1 for i = 1 to n ; TAB2 if i is greater than 1 , show " " ; TAB2 set Arr [ i ] ; TAB1 print new line ;	const int N = 1e6 + 5 , Mod = 1e9 + 7 ; int main ( ) { int n ; cin >> n ; if ( n % 4 > 1 ) cout << " -1\n " , exit ( 0 ) ; int Arr [ n + 2 ] ; if ( n & 1 ) Arr [ n / 2 + 1 ] = n / 2 + 1 ; for ( int i = 1 ; i <= n / 2 ; i += 2 ) { Arr [ i ] = 2 + ( i - 1 ) ; Arr [ i + 1 ] = n - ( i - 1 ) ; Arr [ n - i + 1 ] = n - 1 - ( i - 1 ) ; Arr [ n - i ] = 1 + ( i - 1 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) cout << "   " ; cout << Arr [ i ] ; } cout << " \n " ; return 0 ; }
TAB0 let a , b , c , d , e , f be long long ; TAB0 let Ron = " Ron " and Hermione = " Hermione " be strings ; TAB1 read a , b , c , d , e , f ; TAB1 if c = 0 and d is not 0 ; TAB2 print Ron and new line ; TAB1 else if a = 0 and b not 0 and c not 0 and d not 0 ; TAB2 print Ron ; TAB1 else if b or d or f are zero ; TAB2 print Hermione ; TAB1 else if a or c or e are 0 ; TAB2 print Ron ; TAB1 else ; TAB2 let bc = the gcd of b , c = long long ; TAB2 bk = long long = c / bc ; TAB2 ck = b / bc = long long ; TAB2 set a to a * bk ; TAB2 set b = b * bk ; TAB2 set c = c * ck ; TAB2 set d to d * dk ; TAB2 let de = the gdc of d , e = long long ; TAB2 dk = long long = e / de ; TAB2 ek = long long = d / de ; TAB2 multiply a by dk ; TAB2 multiply b by dk ; TAB2 multiply c by dk ; TAB2 multiply d by dk ; TAB2 multiply e by ek ; TAB2 multiply f by ek ; TAB2 is a < f ? then print Ron else print Hermione ;	long long a , b , c , d , e , f ; string Ron = " Ron " , Hermione = " Hermione " ; int main ( ) { cin >> a >> b >> c >> d >> e >> f ; if ( c == 0 and d != 0 ) { cout << Ron << ' \n ' ; } else if ( a == 0 and b != 0 and c != 0 and d != 0 ) { cout << Ron << ' \n ' ; } else if ( b == 0 or d == 0 or f == 0 ) { cout << Hermione << ' \n ' ; } else if ( a == 0 or c == 0 or e == 0 ) { cout << Ron << ' \n ' ; } else { long long bc = __gcd ( b , c ) ; long long bk = c / bc ; long long ck = b / bc ; a = a * bk ; b = b * bk ; c = c * ck ; d = d * ck ; long long de = __gcd ( d , e ) ; long long dk = e / de ; long long ek = d / de ; a = a * dk ; b = b * dk ; c = c * dk ; d = d * dk ; e = e * ek ; f = f * ek ; cout << ( a < f ? Ron : Hermione ) << ' \n ' ; } }
TAB0 l1 , l2 , r1 , r2 , w = long long ; TAB1 read l1 then r1 then l2 then r2 then w ; TAB1 if ( l1 > r2 ) or ( r1 < l2 ) ; TAB2 print 0 ; TAB1 else ; TAB2 if w > = max of l1 , l2 and w < = min of r1 , r2 ; TAB3 print min of r1 , r2 - max of l1 , l2 ; TAB2 else ; TAB3 print min r1 , r2 - max of l1 , l2 + 1 ;	long long l1 , l2 , r1 , r2 , w ; int main ( ) { cin >> l1 >> r1 >> l2 >> r2 >> w ; if ( ( l1 > r2 ) || ( r1 < l2 ) ) cout << 0 << endl ; else { if ( w >= max ( l1 , l2 ) && w <= min ( r1 , r2 ) ) { cout << min ( r1 , r2 ) - max ( l1 , l2 ) << endl ; } else { cout << min ( r1 , r2 ) - max ( l1 , l2 ) + 1 << endl ; } } }
TAB0 in the function isprime which takes a long long integer x and returns an integer ; TAB1 create a long long integer fact = 0 ; TAB1 for i = 2 to square root of x inclusive ; TAB2 if x mod i = 0 ; TAB3 increment fact ; TAB3 break ; TAB1 if fact = 0 ; TAB2 return i ; TAB1 else do the following ; TAB1 t = long long integer ; TAB1 read t ; TAB1 for i = 1 to 1000 inclusive ; TAB2 if isprime ( t * i + 1 ) = 0 ; TAB3 print i ; TAB3 break ;	int isprime ( long long x ) { long long fact = 0 ; for ( long long i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact ++ ; break ; } } if ( fact == 0 ) return 1 ; else return 0 ; } int main ( ) { long long t ; cin >> t ; for ( long long i = 1 ; i <= 1000 ; i ++ ) { if ( isprime ( t * i + 1 ) == 0 ) { cout << i << endl ; break ; } } }
TAB1 let x , y be integers ; TAB1 let ans be a integer ; TAB1 while read x , y ; TAB2 if x is equal to 0 and y is equal to 0 ; TAB3 print 0 and newline ; TAB3 proceed to next ; TAB2 set integer n to maximum of absolute of x and absolute of y ; TAB2 let ans is equal to ( n - 1 ) * 4 ; TAB2 if x > = n - 1 and x < = n and y is equal to 1 - n ; TAB3 ans ; TAB2 else if x is equal to n and y > = 1 - n and y < = n ; TAB3 increase ans by 1 ; TAB2 else if x > = - n and x < = n and y is equal to n ; TAB3 increment ans by 2 ; TAB2 else if x is equal to - n and y > = - n and y < = n ; TAB3 increment ans by 3 ; TAB2 else if x > = - n and x < = n and y is equal to - n ; TAB3 increment ans by 4 ; TAB2 print ans and newline ;	int main ( ) { int x , y ; int ans ; while ( cin >> x >> y ) { if ( x == 0 && y == 0 ) { cout << " 0 " << endl ; continue ; } int n = max ( abs ( x ) , abs ( y ) ) ; ans = ( n - 1 ) * 4 ; if ( x >= n - 1 && x <= n && y == 1 - n ) ans ; else if ( x == n && y >= 1 - n && y <= n ) ans ++ ; else if ( x >= - n && x <= n && y == n ) ans += 2 ; else if ( x == - n && y >= - n && y <= n ) ans += 3 ; else if ( x >= - n && x <= n && y == - n ) ans += 4 ; cout << ans << endl ; } return 0 ; }
TAB1 n , t = integers ; TAB1 read n , t ; TAB1 if ( t is not 10 ) ; TAB2 for i = 0 to n exclusive , print t ; TAB2 print new line ; TAB1 else ; TAB2 if ( n is 1 ) ; TAB3 print - 1 ; TAB2 else ; TAB3 print 1 ; TAB3 for i = 0 to n - 1 exclusive , print 0 ; TAB3 print new line ;	int main ( ) { int n , t ; cin >> n >> t ; if ( t != 10 ) { for ( int i = 0 ; i < n ; i ++ ) cout << t ; cout << endl ; } else { if ( n == 1 ) cout << " -1\n " ; else { cout << ' 1 ' ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << ' 0 ' ; } cout << endl ; } } return 0 ; }
TAB0 s , q = strings ; TAB0 dp = integer array of size [ 5002 ] [ 5002 ] [ 2 ] ; TAB0 mod = const integer with mod = 1e9 + 7 ; TAB0 in the function solve that takes integer i , j , st and returns integer ; TAB1 if ( st is 2 ) , return 1 ; TAB1 if ( j is q . size ( ) or i is s . size ( ) ) , return 0 ; TAB1 reference ret = integer with ret = dp [ i ] [ j ] [ st ] ; TAB1 if ( not ret ) , return ret ; TAB1 ret = 0 ; TAB1 if ( st is 0 ) ; TAB2 ret = ret + solve ( i + 1 , j , st ) ; TAB2 if ( ret > = mod ) , ret = ret - mo ; TAB2 if ( s [ i ] is q [ j ] ) ; TAB3 ret = ret + solve ( i + 1 , j + 1 , 2 ) ; TAB3 if ( ret > = mod ) , ret = ret - mod ; TAB3 ret = ret + solve ( i + 1 , j + 1 , 1 ) ; TAB3 if ( ret > = mod ) , ret = ret - mo ; TAB2 ret = ret + solve ( i , j + 1 , 1 ) ; TAB2 if ( ret > = mod ) , ret = ret - mod ; TAB1 else ; TAB2 if ( s [ i ] is q [ j ] ) ; TAB3 ret = ret + solve ( i + 1 , j + 1 , 2 ) ; TAB3 if ( ret > = mod ) , ret = ret - mod ; TAB3 ret = ret + solve ( i + 1 , j + 1 , st ) ; TAB3 if ( ret > = mod ) , ret = ret - mod ; TAB2 ret = ret + solve ( i , j + 1 , st ) ; TAB2 if ( ret > = mod ) , ret = ret - mod ; TAB1 return ret ; TAB1 read s , q ; TAB1 set all contents of dp to - 1 ; TAB1 print solve ( 0 , 0 , 0 ) ;	string s , q ; int dp [ 5002 ] [ 5002 ] [ 2 ] ; const int mod = 1e9 + 7 ; int solve ( int i , int j , int st ) { if ( st == 2 ) return 1 ; if ( j == q . size ( ) || i == s . size ( ) ) return 0 ; int & ret = dp [ i ] [ j ] [ st ] ; if ( ~ ret ) return ret ; ret = 0 ; if ( st == 0 ) { ret += solve ( i + 1 , j , st ) ; if ( ret >= mod ) ret -= mod ; if ( s [ i ] == q [ j ] ) { ret += solve ( i + 1 , j + 1 , 2 ) ; if ( ret >= mod ) ret -= mod ; ret += solve ( i + 1 , j + 1 , 1 ) ; if ( ret >= mod ) ret -= mod ; } ret += solve ( i , j + 1 , 1 ) ; if ( ret >= mod ) ret -= mod ; } else { if ( s [ i ] == q [ j ] ) { ret += solve ( i + 1 , j + 1 , 2 ) ; if ( ret >= mod ) ret -= mod ; ret += solve ( i + 1 , j + 1 , st ) ; if ( ret >= mod ) ret -= mod ; } ret += solve ( i , j + 1 , st ) ; if ( ret >= mod ) ret -= mod ; } return ret ; } int main ( ) { cin >> s >> q ; memset ( dp , - 1 , sizeof dp ) ; cout << solve ( 0 , 0 , 0 ) << endl ; return 0 ; }
TAB0 create ints n , a , b , c , d , sum , l1 and l2 ; TAB1 read n , a , b , c and d ; TAB1 if a = 0 ; TAB2 assign b to l1 ; TAB1 else if a = n ; TAB2 assign 3 * n - b to l1 ; TAB1 else if b = 0 ; TAB2 assign 4 * n - a to l1 ; TAB1 else if b = n ; TAB2 assign n + a to l1 ; TAB1 if c is 0 ; TAB2 set l2 to d ; TAB1 else if c = n ; TAB2 set l2 to 3 * n - d ; TAB1 else if d = 0 ; TAB2 change l2 to 4 * n - c ; TAB1 else if d = n ; TAB2 assign n + c to l2 ; TAB1 print min if abs ( l1 - l2 ) and 4 * n - abs ( l1 - l2 ) ;	int n , a , b , c , d , sum , l1 , l2 ; int main ( ) { cin >> n >> a >> b >> c >> d ; if ( a == 0 ) l1 = b ; else if ( a == n ) l1 = 3 * n - b ; else if ( b == 0 ) l1 = 4 * n - a ; else if ( b == n ) l1 = n + a ; if ( c == 0 ) l2 = d ; else if ( c == n ) l2 = 3 * n - d ; else if ( d == 0 ) l2 = 4 * n - c ; else if ( d == n ) l2 = n + c ; cout << min ( abs ( l1 - l2 ) , 4 * n - abs ( l1 - l2 ) ) << endl ; }
TAB0 maxn = 2000010 ; TAB0 eps = 1e - 14 ; TAB0 mod = 1000000007 ; TAB0 inf = 10 ^ 18 ; TAB0 pri = array of maxn int ; TAB0 a = array of 500 int ; TAB0 npri and npal = array of maxn int ; TAB0 function getprime ( no args , no return value ) ; TAB1 fill pri with 0 ; TAB1 for i = 2 to maxn exclusive ; TAB2 if not pri [ i ] ; TAB3 for j = 2 * i to maxn by i exclusive pri [ j ] = 1 ; TAB0 function getpal ( get int x , return int ) ; TAB1 cnt = 0 ; TAB1 while x ; TAB2 a [ cnt ] = x modulo 10 , increment cnt ; TAB2 divide x by 10 ; TAB1 for i = 0 to cnt / 2 exclusive ; TAB2 if a [ i ] is not a [ cnt - i - 1 ] return 0 ; TAB1 return 1 ; TAB0 function solve ( no args , no return value ) ; TAB1 for i = 2 to maxn exclusive npri [ i ] = npri [ i - 1 ] + ( pri [ i ] is 0 ) ; TAB1 for i = 1 to maxn exclusive npri [ i ] = npri [ i - 1 ] + getpal ( i ) ; TAB1 getprime ( ) ; TAB1 solve ( ) ; TAB1 p , q = int ; TAB1 read p , q ; TAB1 for i = maxn - 1 down to 0 inclusive ; TAB2 if q * npri [ i ] < = npal [ i ] * p ; TAB3 print i ; TAB1 print " Palindromic tree is better than splay tree " ;	const int maxn = 2e6 + 10 ; const int eps = 1e-14 ; const int mod = 1e9 + 7 ; const long long inf = 1e18 ; int pri [ maxn ] ; int a [ 500 ] ; int npri [ maxn ] , npal [ maxn ] ; void getprime ( ) { memset ( pri , 0 , sizeof pri ) ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( ! pri [ i ] ) { for ( int j = 2 * i ; j < maxn ; j += i ) pri [ j ] = 1 ; } } } int getpal ( int x ) { int cnt = 0 ; while ( x ) { a [ cnt ++ ] = x % 10 ; x /= 10 ; } for ( int i = 0 ; i < cnt / 2 ; i ++ ) { if ( a [ i ] != a [ cnt - i - 1 ] ) return 0 ; } return 1 ; } void solve ( ) { for ( int i = 2 ; i < maxn ; i ++ ) { npri [ i ] = npri [ i - 1 ] + ( pri [ i ] == 0 ) ; } for ( int i = 1 ; i < maxn ; i ++ ) { npal [ i ] = npal [ i - 1 ] + getpal ( i ) ; } } int main ( ) { getprime ( ) ; solve ( ) ; int p , q ; cin >> p >> q ; for ( int i = maxn - 1 ; i >= 0 ; i -- ) { if ( q * npri [ i ] <= npal [ i ] * p ) { cout << i << endl ; return 0 ; } } cout << " Palindromic tree is better than splay tree " << endl ; return 0 ; }
TAB0 create long longs N , K and ans and an array of long longs a with size 100005 ; TAB0 let b be a map from long long to boolean ; TAB1 read input to N and K ; TAB1 set ans to 0 ; TAB1 for i = 1 to N inclusive , read a [ i ] ; TAB1 sort a from position 1 to N + 1 ; TAB1 loop i from 1 to N inclusive ; TAB2 if b [ a [ i ] ] = 0 ; TAB3 increment ans ; TAB3 change b [ a [ i ] * K ] to 1 ; TAB1 print ans ;	long long N , K , a [ 100005 ] , ans ; map < long long , bool > b ; int main ( ) { cin >> N >> K ; ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { cin >> a [ i ] ; } sort ( a + 1 , a + N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! b [ a [ i ] ] ) { ans ++ ; b [ a [ i ] * K ] = 1 ; } } cout << ans << endl ; }
TAB1 a = int ; TAB1 read a ; TAB1 arr = int array of size 1000100 with all values set to 0 ; TAB1 b = int ; TAB1 loop a times ; TAB2 read b ; TAB2 increment arr [ b ] ; TAB1 ans = int with ans = 0 ; TAB1 sum = int with sum = 0 ; TAB1 for i = 0 to 1000100 ; TAB2 increment sum by arr [ i ] ; TAB2 set arr [ i ] to sum mod 2 ; TAB2 set sum to sum / 2 ; TAB2 if arr [ i ] increment ans ; TAB1 print ans ;	int main ( ) { int a ; cin >> a ; int arr [ 1000100 ] = { 0 } ; int b ; while ( a -- ) { cin >> b ; arr [ b ] ++ ; } int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < 1000100 ; i ++ ) { sum = sum + arr [ i ] ; arr [ i ] = sum % 2 ; sum = sum / 2 ; if ( arr [ i ] ) ans ++ ; } cout << ans << endl ; return 0 ; }
TAB1 declare new integer variable n ; TAB1 create new int64_t variable s ; TAB1 read user input to s and n ; TAB1 create an array of int - int pairs mp with n elements ; TAB1 for i from 0 to n exclusive incrementing i ; TAB2 create new integers a and b ; TAB2 read input to a and b ; TAB2 set the first item of mp [ i ] to a ; TAB2 set the second item of mp [ i ] to b ; TAB1 sort mp from 0 to position n ; TAB1 create new integer variable c = 0 ; TAB1 for i from 0 to n exclusive while mp [ i ] . first < s ; TAB2 change s to s + second value of mp [ i ] ; TAB2 increment c ; TAB1 if c ! = n ; TAB2 print " NO " ; TAB1 else ; TAB2 print " YES " ;	int main ( ) { int n ; int64_t s ; cin >> s >> n ; pair < int , int > mp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a , b ; cin >> a >> b ; mp [ i ] . first = a ; mp [ i ] . second = b ; } sort ( mp , mp + n ) ; int c = 0 ; for ( int i = 0 ; i < n && mp [ i ] . first < s ; i ++ ) { s += mp [ i ] . second ; c ++ ; } if ( c != n ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB1 let n , d , i , j be integers ; TAB1 let L , R be long integers ; TAB1 read L , R ; TAB1 let ans be a long integer with ans = 0 ; TAB1 let ten be a long integer with ten = 1 ; TAB1 for integer n = 0 to 18 exclusive ; TAB2 for d = 1 to 9 inclusive ; TAB3 let low , high be long integers with low = d * ten , high = ( d + 1 ) * ten - 1 ; TAB3 low is equal to maximum of low , L ; TAB3 high is equal to minimum of high , R ; TAB3 while low modulo 10 is not equal to d , increment low by 1 ; TAB3 while ( high modulo 10 + 10 ) modulo 10 is not equal to d ; TAB3 if low < = high , increment ans by ( high - low ) / 10 + 1 ; TAB2 ten = ten * 10 ; TAB1 print ans and newline ;	int main ( ) { int n , d , i , j ; long long L , R ; cin >> L >> R ; long long ans = 0 ; long long ten = 1 ; for ( ( n ) = 0 ; ( n ) < ( int ) ( 18 ) ; ( n ) ++ ) { for ( d = 1 ; d <= 9 ; d ++ ) { long long low = d * ten , high = ( d + 1 ) * ten - 1 ; low = max ( low , L ) ; high = min ( high , R ) ; while ( low % 10 != d ) low ++ ; while ( ( high % 10 + 10 ) % 10 != d ) high -- ; if ( low <= high ) ans += ( high - low ) / 10 + 1 ; } ten *= 10 ; } cout << ans << endl ; return 0 ; }
TAB0 create new array of characters str with 101 elements ; TAB1 let n and sum be integers with sum = 0 ; TAB1 read variable n from the input ; TAB1 in a for loop , change i from 0 to n exclusive ; TAB2 read input to str [ i ] ; TAB2 if str [ i ] is equal to ' 0 ' , increment sum by one ; TAB1 if n = 1 and str [ 0 ] = ' 0 ' ; TAB2 print 0 to the standard output ; TAB1 else ; TAB2 print 1 to the standard output ; TAB2 print 0 sum times ; TAB2 print new line ;	char str [ 101 ] ; int main ( ) { int n , sum = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> str [ i ] ; if ( str [ i ] == ' 0 ' ) sum ++ ; } if ( n == 1 && str [ 0 ] == ' 0 ' ) cout << 0 << endl ; else { cout << 1 ; for ( int i = 0 ; i < sum ; i ++ ) cout << 0 ; cout << endl ; } }
TAB1 i , n , m , k = long long int , arr = array of 100000 long long int ; TAB1 temp = long long int with value INFINITY ; TAB1 read n , m , k ; TAB1 for i = 0 to n exclusive read arr [ i ] ; TAB1 if n is even or n / 2 + 1 > m ; TAB2 print " 0 " ; TAB1 else ; TAB2 for i = 0 to n by 2 temp = min ( temp , arr [ i ] ) ; TAB2 s = ( m / ( n / 2 ) + 1 ) ) * k ; TAB2 temp = min ( temp , s ) ; TAB2 print temp ;	int main ( ) { long long int i , n , m , k , arr [ 100000 ] ; long long int temp = INFINITY ; cin >> n >> m >> k ; for ( i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } if ( n % 2 == 0 || ( n / 2 ) + 1 > m ) { cout << " 0 " << endl ; } else { for ( i = 0 ; i < n ; i += 2 ) { temp = min ( temp , arr [ i ] ) ; } long long s = ( m / ( ( n / 2 ) + 1 ) ) * k ; temp = min ( temp , s ) ; cout << temp << endl ; } return 0 ; }
TAB0 n = int ; TAB0 sum = int ; TAB0 a = int array of size 101 ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read a [ i ] ; TAB2 increment sum by a [ i ] ; TAB1 if sum is not 0 ; TAB2 print " YES " ; TAB2 print " 1 " ; TAB2 print " 1 " and n ; TAB1 if sum is 0 ; TAB2 for i = 1 to n inclusive ; TAB3 increment sum by a [ i ] ; TAB3 if sum is not 0 ; TAB4 print " YES " ; TAB4 print " 2 " ; TAB4 print " 1 " and i ; TAB4 print i + 1 and n ; TAB1 print " NO " ;	int n ; int sum ; int a [ 101 ] ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; sum += a [ i ] ; } if ( sum != 0 ) { cout << " YES " << endl ; cout << " 1 " << endl ; cout << " 1  " << n << endl ; return 0 ; } if ( sum == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { sum += a [ i ] ; if ( sum != 0 ) { cout << " YES " << endl ; cout << " 2 " << endl ; cout << " 1  " << i << endl ; cout << i + 1 << "   " << n << endl ; return 0 ; } } } cout << " NO " << endl ; }
TAB1 declare int variables a , n , m , i , j , p and num , and an array of ints t with size 200010 filled with 0 ; TAB1 read n and m and loop further ; TAB2 read n elements from the user input to array t , starting from the index 1 ; TAB2 start for loop from i = 1 to n inclusive ; TAB3 change t [ i ] to t [ i ] + t [ i - 1 ] ; TAB3 set the value of num to t [ i ] / m ; TAB3 decrease t [ i ] by num * m ; TAB3 print num ; TAB3 if i ! = n , print ' ' to the stdout ; TAB2 print new line ;	int main ( ) { int a , n , m , i , j , t [ 200010 ] = { 0 } , p , num ; while ( cin >> n >> m ) { for ( i = 1 ; i <= n ; i ++ ) cin >> t [ i ] ; for ( i = 1 ; i <= n ; i ++ ) { t [ i ] += t [ i - 1 ] ; num = t [ i ] / m ; t [ i ] -= num * m ; cout << num ; if ( i != n ) cout << '   ' ; } cout << endl ; } return 0 ; }
TAB0 i , k , x , a , b , c , n = integers ; TAB1 Read n ; TAB1 for i = 0 to n exclusive ; TAB2 Read x ; TAB2 if x is 25 ; TAB3 increment a ; TAB2 else if x is 50 ; TAB3 increment b ; TAB3 if a is greater than 0 ; TAB4 decrement a ; TAB3 else do the following ; TAB4 print NO and a new line ; TAB4 Terminate the loop ; TAB2 else if x is 100 ; TAB3 if b is greater than 0 and a is greater than 0 ; TAB4 decrement b ; TAB4 decrement a ; TAB3 else if a is greater than 2 ; TAB4 set a to a - 3 ; TAB3 else do the following ; TAB4 print NO and a new line ; TAB4 Terminate the loop ; TAB1 if i is n , then print YES and a new line ;	int i , k , x , a , b , c , n ; int main ( ) { cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 25 ) { a ++ ; } else if ( x == 50 ) { b ++ ; if ( a > 0 ) { a -- ; } else { cout << " NO " << endl ; break ; } } else if ( x == 100 ) { if ( b > 0 && a > 0 ) { b -- ; a -- ; } else if ( a > 2 ) { a -= 3 ; } else { cout << " NO " << endl ; break ; } } } if ( i == n ) { cout << " YES " << endl ; } }
TAB1 n = integer ; TAB1 Read n ; TAB1 a , b = array of n integers each ; TAB1 read n values into array a and array b ; TAB1 ans = integer with 0 ; TAB1 for j = 0 to n exclusive ; TAB2 for i = 0 to n exclusive ; TAB3 if i is not j and a [ j ] is b [ i ] ; TAB4 increment ans ; TAB4 Terminate the loop ; TAB1 print n - ans and a new line ;	int main ( ) { int n ; cin >> n ; int a [ n ] , b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i != j && a [ j ] == b [ i ] ) { ans ++ ; break ; } } } cout << n - ans << endl ; }
TAB0 MAX = const int with MAX = 1000100 ; TAB0 a = int array of size MAX ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 x = int ; TAB2 read x ; TAB2 increment a [ x ] ; TAB1 ans = int with ans = 0 ; TAB1 for i = 0 to MAX - 1 ; TAB2 increment a [ i + 1 ] by a [ i ] / 2 ; TAB2 set a [ i ] to a [ i ] mod 2 ; TAB2 increment ans by a [ i ] ; TAB1 print ans ;	const int MAX = 1000100 ; int a [ MAX ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; a [ x ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < MAX - 1 ; i ++ ) { a [ i + 1 ] += a [ i ] / 2 ; a [ i ] %= 2 ; ans += a [ i ] ; } cout << ans << endl ; return 0 ; }
TAB1 create int n , k , a [ 1010 ] ; TAB1 read n and k ; TAB1 for i = 1 to 2 * n + 1 inclusive , read a [ i ] ; TAB1 read a [ 1 ] ; TAB1 for i = 2 to 2 * n inclusive ; TAB2 if i is even ; TAB3 set b to a [ i ] - 1 ; TAB3 if a [ i - 1 ] < b and a [ i + 1 ] < b and k different from 0 ; TAB4 set a [ i ] to b ; TAB4 decrement k ; TAB2 print " " , a [ i ] ; TAB1 print " " , a [ 2 * n + 1 ] ;	int main ( ) { int n , k , a [ 1010 ] ; cin >> n >> k ; for ( int i = 1 ; i <= 2 * n + 1 ; i ++ ) { cin >> a [ i ] ; } cout << a [ 1 ] ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) { int b = a [ i ] - 1 ; if ( a [ i - 1 ] < b && a [ i + 1 ] < b && k ) { a [ i ] = b ; k -- ; } } cout << "   " << a [ i ] ; } cout << "   " << a [ 2 * n + 1 ] << endl ; return 0 ; }
TAB1 str is a string set to abcdefghijklmnopqrstuvwxyz ; TAB1 x , y are integers ; TAB1 read x , y ; TAB1 str1 , str2 are strings ; TAB1 for i = 0 to y exclusive , add str [ i ] to str1 ; TAB1 j is an integer set to 0 ; TAB1 for i = 0 to x exclusive ; TAB2 add str [ j ] to str2 ; TAB2 if j equals ( length of str1 ) - 1 ; TAB3 set j to 0 ; TAB2 else ; TAB3 increment j ; TAB1 display str2 ;	int main ( ) { string str = " abcdefghijklmnopqrstuvwxyz " ; int x , y ; cin >> x >> y ; string str1 , str2 ; for ( int i = 0 ; i < y ; i ++ ) { str1 += str [ i ] ; } int j = 0 ; for ( int i = 0 ; i < x ; i ++ ) { str2 += str [ j ] ; if ( j == str1 . length ( ) - 1 ) { j = 0 ; } else { j ++ ; } } cout << str2 << endl ; }
TAB0 declare string str ; TAB0 in function isPalindrome returning bool , accepting int idx and int N ; TAB1 for i = 0 to N / 2 exclusive ; TAB2 if str [ i + idx ] is not equal to str [ N - 1 - i + idx ] , return false ; TAB1 return true ; TAB1 read str ; TAB1 declare int n and k ; TAB1 read k ; TAB1 set n to str length ; TAB1 define int l = n / k ; TAB1 define bool possible = true ; TAB1 if l * k equals n ; TAB2 define int i = 0 ; TAB2 while i less than n ; TAB3 if not isPalindrome ( i , l ) ; TAB4 set possible to false ; TAB4 break ; TAB3 increase i by l ; TAB1 else ; TAB2 set possible to false ; TAB1 if possible ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ; TAB1 print newline ;	string str ; bool isPalindrome ( int idx , int N ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { if ( str [ i + idx ] != str [ N - 1 - i + idx ] ) return false ; } return true ; } int main ( ) { cin >> str ; int n , k ; cin >> k ; n = str . length ( ) ; int l = n / k ; bool possible = true ; if ( l * k == n ) { int i = 0 ; while ( i < n ) { if ( ! isPalindrome ( i , l ) ) { possible = false ; break ; } i += l ; } } else possible = false ; if ( possible ) cout << " YES " ; else cout << " NO " ; cout << " \n " ; return 0 ; }
TAB0 make integer array a of size 1001 with array of size 4 ; TAB1 make integer n ; TAB1 let string s ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 2 exclusive ; TAB3 read s ; TAB3 make integer kp = 0 ; TAB3 if j is equal to 1 , set kp to 1 ; TAB3 set a [ i ] [ j * 2 ] to s [ ( 0 + kp ) % 2 ] - ' 0 ' ; TAB3 set a [ i ] [ j * 2 + 1 ] to s [ ( 1 + kp ) % 2 ] - ' 0 ' ; TAB2 if i is not equal to n - 1 , read s ; TAB1 make integers cnt = 0 and cnt2 = 1 ; TAB1 make int vector k ; TAB1 for i = 0 to n exclusive ; TAB2 create integer ss of size 4 with { 0 , 0 , 0 , 0 } ; TAB2 for j = 0 to 4 exclusive ; TAB3 for z = 0 to 4 exclusive , set ss [ j ] to ss [ j ] * 10 + a [ i ] [ ( j + z ) % 4 ] ; TAB2 append min ( min ( ss [ 0 ] , ss [ 1 ] ) , min ( ss [ 2 ] , ss [ 3 ] ) ) to k ; TAB1 make int cn = 1 ; TAB1 sort k ; TAB1 for i = 1 to k . size ( ) exclusive ; TAB2 if k [ i ] equals k [ i - 1 ] , continue loop ; TAB2 add 1 to cn ; TAB1 show cn ;	int a [ 1001 ] [ 4 ] ; int main ( ) { int n ; string s ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { cin >> s ; int kp = 0 ; if ( j == 1 ) kp = 1 ; a [ i ] [ j * 2 ] = s [ ( 0 + kp ) % 2 ] - ' 0 ' ; a [ i ] [ j * 2 + 1 ] = s [ ( 1 + kp ) % 2 ] - ' 0 ' ; } if ( i != n - 1 ) cin >> s ; } int cnt = 0 , cnt2 = 1 ; vector < int > k ; for ( int i = 0 ; i < n ; i ++ ) { int ss [ 4 ] = { 0 , 0 , 0 , 0 } ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int z = 0 ; z < 4 ; z ++ ) { ss [ j ] = ss [ j ] * 10 + a [ i ] [ ( j + z ) % 4 ] ; } } k . push_back ( min ( min ( ss [ 0 ] , ss [ 1 ] ) , min ( ss [ 2 ] , ss [ 3 ] ) ) ) ; } int cn = 1 ; sort ( k . begin ( ) , k . end ( ) ) ; for ( int i = 1 ; i < k . size ( ) ; i ++ ) { if ( k [ i ] == k [ i - 1 ] ) continue ; cn ++ ; } cout << cn << endl ; return 0 ; }
TAB0 integers = n , m , x , y , curr ; TAB0 create a vector using integers of array called graph of 100010 size ; TAB0 create vector rgraph of size 100010 ; TAB0 integers = f [ 100010 ] ; TAB0 integers = a [ 100010 ] ; TAB0 make boolean array called used of size 100010 ; TAB0 make boolean array called rused with size 100010 ; TAB0 create queue with integers q and rq ; TAB1 read n , m ; TAB1 for i = 0 to less than n do the following ; TAB2 read f [ i ] ; TAB2 if f [ i ] is 1 then do the following ; TAB3 put i into next position of q ; TAB3 set used [ i ] to true ; TAB2 if f [ i ] is 2 then do the following ; TAB3 put i into next position of rq ; TAB3 set rused [ i ] to true ; TAB1 for i = 0 to less than m do the following ; TAB2 read x , y ; TAB2 minus 1 from x ; TAB2 minus 1 from y ; TAB2 add new element y to end of vector graph [ x ] ; TAB2 add new element x to end of vector rgraph [ y ] ; TAB1 if ! q . empty is true do the following ; TAB2 set curr to q . front ( ) ; TAB2 remove element on top of stack q ; TAB2 add one to a [ curr ] ; TAB2 for i = 0 to less than graph [ curr ] . size ( ) do the following ; TAB3 if ! used [ graph [ curr ] [ i ] ] is true ; TAB4 set used [ graph [ curr ] [ i ] ] to true ; TAB4 put graph [ curr ] [ i ] at top of stack ; TAB1 if ! rq . empty is true do the following ; TAB2 set curr to rq . front ( ) ; TAB2 remove element on top of stack rq ; TAB2 add one to a [ curr ] ; TAB2 if f [ curr ] is not equal to 1 then do the following ; TAB3 for i = 0 to less than rgraph [ curr ] . size ( ) do the following ; TAB4 if ! rused [ rgraph [ curr ] [ i ] ] is true ; TAB5 set rused [ rgraph [ curr ] [ i ] ] to true ; TAB5 put rgraph [ curr ] [ i ] at the top of stack rq ; TAB1 for i = 0 to less than n do the following ;	int n , m , x , y , curr ; vector < int > graph [ 100010 ] ; vector < int > rgraph [ 100010 ] ; int f [ 100010 ] ; int a [ 100010 ] ; bool used [ 100010 ] ; bool rused [ 100010 ] ; queue < int > q , rq ; int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> f [ i ] ; if ( f [ i ] == 1 ) { q . push ( i ) ; used [ i ] = true ; } if ( f [ i ] == 2 ) { rq . push ( i ) ; rused [ i ] = true ; } } for ( int i = 0 ; i < m ; i ++ ) { cin >> x >> y ; x -- ; y -- ; graph [ x ] . push_back ( y ) ; rgraph [ y ] . push_back ( x ) ; } while ( ! q . empty ( ) ) { curr = q . front ( ) ; q . pop ( ) ; a [ curr ] ++ ; for ( int i = 0 ; i < graph [ curr ] . size ( ) ; i ++ ) { if ( ! used [ graph [ curr ] [ i ] ] ) { used [ graph [ curr ] [ i ] ] = true ; q . push ( graph [ curr ] [ i ] ) ; } } } while ( ! rq . empty ( ) ) { curr = rq . front ( ) ; rq . pop ( ) ; a [ curr ] ++ ; if ( f [ curr ] != 1 ) { for ( int i = 0 ; i < rgraph [ curr ] . size ( ) ; i ++ ) { if ( ! rused [ rgraph [ curr ] [ i ] ] ) { rused [ rgraph [ curr ] [ i ] ] = true ; rq . push ( rgraph [ curr ] [ i ] ) ; } } } } for ( int i = 0 ; i < n ; i ++ ) { ( a [ i ] == 2 ) ? cout << 1 << endl : cout << 0 << endl ; } }
TAB0 create const integer maxn = 1E2 + 5 ; TAB0 make int n and int arrays a of size maxn , r of size maxn , and l of size maxn ; TAB0 declare cmp taking in ints a and b and returning bool ; TAB1 reaturn the result of a > b ; TAB1 read n ; TAB1 set l [ 1 ] to 1 ; TAB1 make ints sum = 0 , k = 1 , cnt = 0 , and pos ; TAB1 for i = 1 to n ; TAB2 read a [ i ] ; TAB2 set sum to sum + a [ i ] ; TAB2 if a [ i ] is equal to 0 , increment cnt ; TAB1 if n is equal to cnt ; TAB2 print " NO " ; TAB1 if sum is not equal to 0 ; TAB2 show " YES " ; TAB2 display " 1 " ; TAB2 output " 1 " , ' ' , and n ; TAB1 else ; TAB2 for i = 1 to n ; TAB3 if a [ i ] is truthy ; TAB4 set pos to i ; TAB4 break loop ; TAB2 display " YES " ; TAB2 output " 2 " ; TAB2 show " 1 " , ' ' , and pos ; TAB2 output pos + 1 , ' ' , and n ;	const int maxn = 1E2 + 5 ; int n , a [ maxn ] , r [ maxn ] , l [ maxn ] ; bool cmp ( int a , int b ) { return a > b ; } int main ( ) { cin >> n ; l [ 1 ] = 1 ; int sum = 0 , k = 1 , cnt = 0 , pos ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; sum += a [ i ] ; if ( a [ i ] == 0 ) { cnt ++ ; } } if ( n == cnt ) { cout << " NO " << endl ; return 0 ; } if ( sum != 0 ) { cout << " YES " << endl ; cout << " 1 " << endl ; cout << " 1 " << '   ' << n << endl ; } else { for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] ) { pos = i ; break ; } } cout << " YES " << endl ; cout << " 2 " << endl ; cout << " 1 " << '   ' << pos << endl ; cout << pos + 1 << '   ' << n << endl ; } return 0 ; }
TAB0 declare dig with integer x as argument , returning integer ; TAB1 create integer res with res = 0 ; TAB1 while x is true ; TAB2 increment res ; TAB2 set x to x / 7 ; TAB1 return maximum of 1 and res from function ; TAB0 declare getmask with integers x , dig as arguments , returning integer ; TAB1 create integer mask with mask = 0 ; TAB1 while decrement dig is true ; TAB2 create integer cm with cm = ( 1 bitshift left ( x % 7 ) ) ; TAB2 if ( mask bitwise and cm ) , return - 1 from function ; TAB2 set mask to mask bitwise or cm ; TAB2 set x to x / 7 ; TAB1 return mask from function ; TAB0 create integer array msk1 with size 10000000 ; TAB0 create integer array msk2 with size 10000000 ; TAB1 create integers n , m ; TAB1 read n read m ; TAB1 create integer d1 with d1 = result of run dig with n - 1 as argument ; TAB1 create integer d2 with d2 = result of run dig with m - 1 as argument ; TAB1 if d1 + d2 is greater than 7 ; TAB2 print 0 print newline ; TAB1 for i = 0 to n exclusive , set msk1 [ i ] to result of run getmask with i , d1 as arguments ; TAB1 for i = 0 to m exclusive , set msk2 [ i ] to result of run getmask with i , d2 as arguments ; TAB1 create integer ans with ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to m exclusive ; TAB3 if msk1 [ i ] is less than 0 or msk2 [ j ] is less than 0 , break current loop iteration ; TAB3 if ( msk1 [ i ] bitwise and msk2 [ j ] ) is 0 , increment ans ; TAB1 print ans print newline ;	int dig ( int x ) { int res = 0 ; while ( x ) { res ++ ; x /= 7 ; } return max ( 1 , res ) ; } int getmask ( int x , int dig ) { int mask = 0 ; while ( dig -- ) { int cm = ( 1 << ( x % 7 ) ) ; if ( ( mask & cm ) ) return - 1 ; mask |= cm ; x /= 7 ; } return mask ; } int msk1 [ 10000000 ] ; int msk2 [ 10000000 ] ; int main ( ) { int n , m ; cin >> n >> m ; int d1 = dig ( n - 1 ) ; int d2 = dig ( m - 1 ) ; if ( d1 + d2 > 7 ) { cout << 0 << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { msk1 [ i ] = getmask ( i , d1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { msk2 [ i ] = getmask ( i , d2 ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( msk1 [ i ] < 0 || msk2 [ j ] < 0 ) continue ; if ( ( msk1 [ i ] & msk2 [ j ] ) == 0 ) { ans ++ ; } } } cout << ans << endl ; return 0 ; }
TAB0 PI = constant double = acos ( - 1 . 0 ) ; TAB0 eps = constant double = 1e - 6 ; TAB0 inf = constant integer = 0x3f3f3f3f ; TAB1 str1 , str2 = strings ; TAB1 st1 = character array of size 5 , st2 = character array of size 5 ; TAB1 counter = integer ; TAB1 read str1 , str2 ; TAB1 counter = 0 ; TAB1 if the size of str1 is not the size of str2 ; TAB2 print NO ; TAB1 else ; TAB2 for i = 0 to the size of str1 exclusive ; TAB3 if str1 [ i ] is not str2 [ i ] ; TAB4 if counter > 2 ; TAB5 print NO ; TAB4 st1 [ counter ] = str1 [ i ] ; TAB4 st2 [ counter ] = str2 [ i ] ; TAB4 increase counter by 1 ; TAB2 if counter > 2 , then print NO ; TAB2 if counter is 1 , then print NO ; TAB2 if counter is 2 ; TAB3 if st1 [ 0 ] is st2 [ 1 ] and st1 [ 1 ] is st2 [ 0 ] ; TAB4 print YES ; TAB3 else ; TAB4 print NO ; TAB2 if counter is 0 , then print YES ;	const double PI = acos ( - 1.0 ) ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; int main ( ) { string str1 , str2 ; char st1 [ 5 ] , st2 [ 5 ] ; int counter ; cin >> str1 >> str2 ; counter = 0 ; if ( str1 . size ( ) != str2 . size ( ) ) cout << " NO " << endl ; else { for ( int i = 0 ; i < str1 . size ( ) ; ++ i ) { if ( str1 [ i ] != str2 [ i ] ) { if ( counter > 2 ) { cout << " NO " << endl ; return 0 ; } st1 [ counter ] = str1 [ i ] ; st2 [ counter ] = str2 [ i ] ; ++ counter ; } } if ( counter > 2 ) { cout << " NO " << endl ; } if ( counter == 1 ) cout << " NO " << endl ; if ( counter == 2 ) { if ( ( st1 [ 0 ] == st2 [ 1 ] ) && ( st1 [ 1 ] ) == st2 [ 0 ] ) { cout << " YES " << endl ; } else cout << " NO " << endl ; } if ( counter == 0 ) cout << " YES " << endl ; } }
TAB0 declare string variable s ; TAB0 declare ints a , b and c ; TAB0 declare integer variable len ; TAB1 read s ; TAB1 create int n = length of s ; TAB1 create an array of ints w with size n + 10 ; TAB1 for integer i = 0 to length of s exclusive ; TAB2 if s [ i ] is equal to ' ( ' ; TAB3 increment a ; TAB2 else if s [ i ] = ' # ' ; TAB3 increment len and change w [ len ] to 1 ; TAB3 increment b by one ; TAB2 else if s [ i ] = ' ) ' ; TAB3 increment b by one ; TAB2 if b is greater than a ; TAB3 print - 1 ; TAB1 loop i from length of s - 1 to 0 inclusive counting down ; TAB2 if s [ i ] = ' ) ' ; TAB3 increment c ; TAB2 else if s [ i ] = ' ( ' ; TAB3 decrement c by one ; TAB2 else if s [ i ] = ' # ' ; TAB3 break ; TAB2 if c is less than 0 ; TAB3 print - 1 ; TAB1 increase w [ len ] by a - b ; TAB1 for i = 1 to len inclusive , print w [ i ] ;	string s ; int a , b , c ; int len ; int main ( ) { cin >> s ; int n = s . length ( ) ; int w [ n + 10 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { a ++ ; } else if ( s [ i ] == ' # ' ) { w [ ++ len ] = 1 ; b ++ ; } else if ( s [ i ] == ' ) ' ) { b ++ ; } if ( b > a ) { cout << - 1 << endl ; return 0 ; } } for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ) ' ) { c ++ ; } else if ( s [ i ] == ' ( ' ) { c -- ; } else if ( s [ i ] == ' # ' ) { break ; } if ( c < 0 ) { cout << - 1 << endl ; return 0 ; } } w [ len ] += a - b ; for ( int i = 1 ; i <= len ; i ++ ) { cout << w [ i ] << endl ; } return 0 ; }
TAB1 n , a , b , i , j = integers ; TAB1 Read n ; TAB1 for i = 1 to 1000 exclusive ; TAB2 set a to n * i + 1 ; TAB2 for j = 2 to a exclusive ; TAB3 if a modulo j is 0 ; TAB4 print i and a new line ;	int main ( ) { int n , a , b , i , j ; cin >> n ; for ( i = 1 ; i <= 1000 ; i ++ ) { a = n * i + 1 ; for ( j = 2 ; j < a ; j ++ ) { if ( a % j == 0 ) { cout << i << endl ; return 0 ; } } } }
TAB1 let n , m , i , len , flag be ints with flag = 0 ; TAB1 s , x , s1 , s2 = string ; TAB1 read na dn m ; TAB1 read s and x ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] = ' * ' ; TAB3 set flag to 1 ; TAB3 exit loop ; TAB1 if n - 1 > m ; TAB2 print NO ; TAB1 if flag isn ' t 0 ; TAB2 set s1 to substring form 0 to i of s ; TAB2 set s2 = substring from i + 1 to n - i - 1 of s ; TAB2 set len to the length of s2 ; TAB2 if substring of x form 0 to i = s1 and substring of x form m = len to m - i = s2 ; TAB3 printYES ; TAB2 else ; TAB3 print NO ; TAB1 else ; TAB2 if s = x ; TAB3 print YES ; TAB2 else ; TAB3 print No ;	int main ( ) { int n , m , i , len , flag = 0 ; string s , x , s1 , s2 ; cin >> n >> m ; cin >> s >> x ; for ( i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' * ' ) { flag = 1 ; break ; } if ( n - 1 > m ) { cout << " NO " << endl ; return 0 ; } if ( flag ) { s1 = s . substr ( 0 , i ) ; s2 = s . substr ( i + 1 , n - i - 1 ) ; len = s2 . length ( ) ; if ( x . substr ( 0 , i ) == s1 && x . substr ( m - len , m - i ) == s2 ) cout << " YES " << endl ; else cout << " NO " << endl ; } else { if ( s == x ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB0 define function fun ; TAB1 declare integer variables n and capacity ; TAB1 read n and capacity ; TAB1 declare int variable count = 0 ; TAB1 create an array of integers num with size n ; TAB1 create integer j = 0 and an array of integers lib with size = capacity ; TAB1 loop i from 0 to n exclusive , read num [ i ] ; TAB1 loop i from 0 to n exclusive ; TAB2 declare integer variable found = 0 ; TAB2 if i is equal to 0 ; TAB3 change lib [ j ] to num [ i ] ; TAB3 increment count ; TAB3 increment j ; TAB2 else ; TAB3 for k from 0 to j exclusive ; TAB4 if lib [ k ] = num [ i ] ; TAB5 set found to 1 ; TAB5 break ; TAB3 if found = 0 ; TAB4 if j ! = capacity ; TAB5 assign num [ i ] to lib [ j ] ; TAB5 increment j by one ; TAB5 increment count by one ; TAB4 else ; TAB5 new integers min = j - 1 , flag , min2 = n - 1 , min3 = j - 1 , prevmin = - 1 , min4 = j - 1 ; TAB5 create int counter = 0 ; TAB5 for x from 0 to j exclusive ; TAB6 set flag to 0 ; TAB6 for y = i to n exclusive ; TAB7 if num [ y ] = lib [ x ] ; TAB8 assign y to min2 ; TAB8 change min3 to x ; TAB8 set flag to 1 ; TAB8 increment counter by one ; TAB8 stop the loop ; TAB6 if flag is equal to 0 ; TAB7 change min to x ; TAB6 else ; TAB7 if prevmin is less than min2 ; TAB8 assign min2 to prevmin ; TAB8 change min4 to x ; TAB5 if counter is equal to j ; TAB6 assign num [ i ] to lib [ min4 ] ; TAB5 else ; TAB6 change lib [ min ] to num [ i ] ; TAB5 increment count ; TAB1 print count ; TAB1 call method fun ( ) ;	void fun ( ) { int n , capacity ; cin >> n >> capacity ; int count = 0 ; int num [ n ] ; int lib [ capacity ] , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> num [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int found = 0 ; if ( i == 0 ) { lib [ j ] = num [ i ] ; count ++ ; j ++ ; } else { for ( int k = 0 ; k < j ; k ++ ) { if ( lib [ k ] == num [ i ] ) { found = 1 ; break ; } } if ( found == 0 ) { if ( j != capacity ) { lib [ j ] = num [ i ] ; j ++ ; count ++ ; } else { int min = j - 1 , flag , min2 = n - 1 , min3 = j - 1 , prevmin = - 1 , min4 = j - 1 ; int counter = 0 ; for ( int x = 0 ; x < j ; x ++ ) { flag = 0 ; for ( int y = i ; y < n ; y ++ ) { if ( num [ y ] == lib [ x ] ) { min2 = y ; min3 = x ; flag = 1 ; counter ++ ; break ; } } if ( flag == 0 ) { min = x ; } else { if ( prevmin < min2 ) { prevmin = min2 ; min4 = x ; } } } if ( counter == j ) { lib [ min4 ] = num [ i ] ; } else { lib [ min ] = num [ i ] ; } count ++ ; } } } } cout << count << endl ; } int main ( ) { fun ( ) ; return 0 ; }
TAB0 declare constant long long MAX_N = 1e7 ; TAB0 declare solve with no arguments , returning void ; TAB1 declare long long a , b , c , d ; TAB1 read a , b , c , d ; TAB1 declare answer = - 1 as long long ; TAB1 for x = 0 to MAX_N inclusive ; TAB2 declare temp = b + a * x - d as long long ; TAB2 if temp is greater than or equal to 0 and temp % c is 0 ; TAB3 let answer be temp + d ; TAB3 end loop ; TAB1 print answer , newline ; TAB1 declare integer t = 1 ; TAB1 while decrement t is true , run solve ;	const long long MAX_N = 1e7 ; void solve ( ) { long long a , b , c , d ; cin >> a >> b >> c >> d ; long long answer = - 1 ; for ( long long x = 0 ; x <= MAX_N ; x ++ ) { long long temp = b + a * x - d ; if ( temp >= 0 and temp % c == 0 ) { answer = temp + d ; break ; } } cout << answer << endl ; } int main ( ) { int t = 1 ; while ( t -- ) solve ( ) ; return 0 ; }
TAB1 let i , n , m , k be long integers , arr = array of long integers of length 100000 ; TAB1 let ans be a long integer with ans = INFINITY ; TAB1 read n , m , k ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 if n modulo 2 is equal to 0 or ( n / 2 ) + 1 is greater than m ; TAB2 print 0 and newline ; TAB1 else do the following ; TAB2 for i = 0 to n exclusive , i is incremented by 2 , ans is equal to minimum of ans , arr [ i ] ; TAB2 let s be a long integer with s = m / ( ( n / 2 ) + 1 ) ; TAB2 ans is equal to minimum of ans , s * k ; TAB2 print ans and new line ;	int main ( ) { long long int i , n , m , k , arr [ 100000 ] ; long long int ans = INFINITY ; cin >> n >> m >> k ; for ( i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } if ( n % 2 == 0 || ( n / 2 ) + 1 > m ) { cout << " 0 " << endl ; } else { for ( i = 0 ; i < n ; i += 2 ) { ans = min ( ans , arr [ i ] ) ; } long long s = m / ( ( n / 2 ) + 1 ) ; ans = min ( ans , s * k ) ; cout << ans << endl ; } return 0 ; }
TAB0 mod = const int with mod = 1e9 + 7 ; TAB0 eps = const double with eps = 1e - 6 ; TAB0 q = long long vcector ; TAB0 in function dfs taking long long x ; TAB1 if x > = 10000000005 return ; TAB1 append x to q ; TAB1 call dfs of x * 10 + 4 ; TAB1 call dfs of x * 10 + 7 ; TAB1 l , r = long long ; TAB1 call dfs of 0 ; TAB1 sort q ; TAB1 loop while reading l then r ; TAB2 ans_l , ans_r = long long with ans_l = 0 and ans_r = 0 ; TAB2 len = int with len = size of q ; TAB2 for i = 1 to len inclusive ; TAB3 if q [ i ] < = l - 1 ; TAB4 increment ans_l by ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; TAB3 else ; TAB4 increment ans_l by ( l - 1 - q [ i - 1 ] ) * q [ i ] ; TAB4 break ; TAB2 for i = 1 to len inclusive ; TAB3 if q [ i ] < = r ; TAB4 increment ans_r by ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; TAB3 else ; TAB4 increment ans_r by ( r - q [ i - 1 ] ) * q [ i ] ; TAB4 break ; TAB2 print ans_r - ans_l ;	const int mod = 1e9 + 7 ; const double eps = 1e-6 ; vector < long long > q ; void dfs ( long long x ) { if ( x >= 10000000005 ) { return ; } q . push_back ( x ) ; dfs ( x * 10 + 4 ) ; dfs ( x * 10 + 7 ) ; } int main ( ) { long long l , r ; dfs ( 0 ) ; sort ( q . begin ( ) , q . end ( ) ) ; while ( cin >> l >> r ) { long long ans_l = 0 , ans_r = 0 ; int len = q . size ( ) ; for ( int i = 1 ; i <= len ; i ++ ) { if ( q [ i ] <= l - 1 ) { ans_l += ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; } else { ans_l += ( l - 1 - q [ i - 1 ] ) * q [ i ] ; break ; } } for ( int i = 1 ; i <= len ; i ++ ) { if ( q [ i ] <= r ) { ans_r += ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; } else { ans_r += ( r - q [ i - 1 ] ) * q [ i ] ; break ; } } cout << ans_r - ans_l << endl ; } return 0 ; }
TAB0 create new constant integer MAX_N = 50 ; TAB0 new integer constant MAX_M with value 50 ; TAB0 define new 2d array of integers v with size MAX_N by MAX_M ; TAB0 define new 2d array of integers u MAX_N by MAX_M elements ; TAB0 define new integers n and m ; TAB0 void function dfs with int arguments x , y and first ; TAB1 if first is false , assign the new value = 1 to u [ y ] [ x ] ; TAB1 if x > 0 and v [ y ] [ x - 1 ] is true and u [ y ] [ x - 1 ] is false , call dfs ( x - 1 , y ) ; TAB1 call dfs ( x + 1 , y ) if x < m - 1 and v [ y ] [ x + 1 ] is true and u [ y ] [ x + 1 ] is false ; TAB1 if y > 0 and v [ y - 1 ] [ x ] is true and u [ y - 1 ] [ x ] is false , run function dfs ( x , y - 1 ) ; TAB1 if y < n - 1 and v [ y + 1 ] [ x ] is true and u [ y + 1 ] [ x ] is false , call method dfs ( x , y + 1 ) ; TAB1 read n and m from the user input ; TAB1 create new integer called k = 0 ; TAB1 for i from 0 to n exclusive ; TAB2 new string variable s ; TAB2 read variable s from the input ; TAB2 start for loop from j = 0 to m exclusive ; TAB3 assign the new value = ( true if s [ j ] = ' # ' or false otherwise ) , to v [ i ] [ j ] ; TAB3 add v [ i ] [ j ] to k ; TAB1 if k < = 2 ; TAB2 print - 1 ; TAB1 define boolean f = false ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 increment j in a loop from 0 to m exclusive ; TAB3 if v [ i ] [ j ] is false , skip the rest of the loop ; TAB3 set first MAX_N * MAX_M * sizeof ( int ) bytes at the pointer u to 0 ; TAB3 assign 0 to v [ i ] [ j ] ; TAB3 create boolean variable with name f = false ; TAB3 for integer ii = 0 to n exclusive incrementing ii , while f is false ; TAB4 in a for loop , change jj from 0 to m exclusive , while f is false ; TAB5 if v [ ii ] [ jj ] ! = 0 ; TAB6 call dfs ( jj , ii ) ; TAB6 assign true to f ; TAB3 start for loop from ii = 0 to n exclusive ; TAB4 loop through jj from 0 to m exclusive incrementing by 1 ; TAB5 if i = ii and j = jj , go to the start of the loop ; TAB5 if v [ ii ] [ jj ] ! = u [ ii ] [ jj ] ; TAB6 print 1 and a new line ; TAB3 change the value of v [ i ] [ j ] to 1 ; TAB1 print 2 ;	const int MAX_N = 50 ; const int MAX_M = 50 ; int v [ MAX_N ] [ MAX_M ] ; int u [ MAX_N ] [ MAX_M ] ; int n , m ; void dfs ( int x , int y , int first = 0 ) { if ( ! first ) u [ y ] [ x ] = 1 ; if ( x > 0 && v [ y ] [ x - 1 ] && ! u [ y ] [ x - 1 ] ) dfs ( x - 1 , y ) ; if ( x < m - 1 && v [ y ] [ x + 1 ] && ! u [ y ] [ x + 1 ] ) dfs ( x + 1 , y ) ; if ( y > 0 && v [ y - 1 ] [ x ] && ! u [ y - 1 ] [ x ] ) dfs ( x , y - 1 ) ; if ( y < n - 1 && v [ y + 1 ] [ x ] && ! u [ y + 1 ] [ x ] ) dfs ( x , y + 1 ) ; } int main ( ) { cin >> n >> m ; int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) { string s ; cin >> s ; for ( int j = 0 ; j < m ; ++ j ) { v [ i ] [ j ] = ( s [ j ] == ' # ' ) ; k += v [ i ] [ j ] ; } } if ( k <= 2 ) { cout << - 1 << endl ; return 0 ; } bool f = false ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( ! v [ i ] [ j ] ) continue ; memset ( u , 0 , MAX_N * MAX_M * sizeof ( int ) ) ; v [ i ] [ j ] = 0 ; bool f = false ; for ( int ii = 0 ; ii < n && ! f ; ++ ii ) { for ( int jj = 0 ; jj < m && ! f ; ++ jj ) { if ( v [ ii ] [ jj ] != 0 ) { dfs ( jj , ii ) ; f = true ; } } } for ( int ii = 0 ; ii < n ; ++ ii ) { for ( int jj = 0 ; jj < m ; ++ jj ) { if ( i == ii && j == jj ) continue ; if ( v [ ii ] [ jj ] != u [ ii ] [ jj ] ) { cout << 1 << endl ; return 0 ; } } } v [ i ] [ j ] = 1 ; } } cout << 2 << endl ; return 0 ; }
TAB0 create new integer variable n ; TAB0 define new string called s ; TAB1 read n and s from the user input ; TAB1 declare integer variable with name ans with value 0 ; TAB1 for i from 0 to n exclusive incrementing i ; TAB2 if s [ i ] = ' < ' ; TAB3 increment ans by one ; TAB2 else ; TAB3 break ; TAB1 in a for loop , change i from n - 1 to 0 inclusive decrementing by 1 ; TAB2 if s [ i ] = ' > ' ; TAB3 increment ans ; TAB2 else ; TAB3 break ; TAB1 print ans and " \ n " ;	int n ; string s ; int main ( ) { cin >> n >> s ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' < ' ) ans ++ ; else break ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' > ' ) ans ++ ; else break ; } cout << ans << " \n " ; return 0 ; }
TAB1 a , b , c , d , k = double ; TAB1 read a , b , c , d ; TAB1 if ( ( a - b ) is ( b - c ) and ( b - c ) is ( c - d ) ) ; TAB2 print d + ( b - a ) ; TAB1 else ; TAB2 if ( ( b / a ) is ( c / b ) and ( c / b ) is ( d / c ) ) ; TAB3 k = d * ( b / a ) ; TAB3 if ( k is ( cast to int ) k ) ; TAB4 print k ; TAB3 else ; TAB4 print 42 ; TAB2 else ; TAB3 print 42 ;	int main ( ) { double a , b , c , d , k ; cin >> a >> b >> c >> d ; if ( ( a - b ) == ( b - c ) && ( b - c ) == ( c - d ) ) { cout << d + ( b - a ) << endl ; } else { if ( ( b / a ) == ( c / b ) && ( c / b ) == ( d / c ) ) { k = d * ( b / a ) ; if ( k == ( int ) k ) { cout << k << endl ; } else { cout << 42 << endl ; } } else { cout << 42 << endl ; } } return 0 ; }
TAB0 declare new constant long long mod = 998244353 ; TAB0 define constant integer maxn with value 2e5 ; TAB1 declare new integer t ; TAB1 create long longs n , a , b and c ; TAB1 read standard input to n ; TAB1 read user input to a , b and c ; TAB1 create long long variables one a and two = b - c ; TAB1 new long long variables sum1 = n / one , yu1 = n % one , and ci ; TAB1 while yu1 / b > 0 ; TAB2 set the value of ci to ( yu1 - b ) / two ; TAB2 if ci = 0 and yu1 > = b ; TAB3 if yu1 / a > 0 and yu1 / a * a < yu1 / b * two ; TAB4 set the value of yu1 to yu1 - yu1 / a * a ; TAB4 change the value of sum1 to sum1 + yu1 / a ; TAB3 else ; TAB4 subtract two from yu1 ; TAB4 increment sum1 ; TAB2 else ; TAB3 change the value of yu1 to yu1 - ci * two ; TAB3 change sum1 to sum1 + ci ; TAB1 create new long longs yu2 = n , sum2 = 0 and ans = 0 ; TAB1 while yu2 / b > 0 ; TAB2 assign ( yu2 - b ) / two to ci ; TAB2 if ci = 0 and yu2 > = b ; TAB3 if yu2 / a > 0 and yu2 / a * a < yu2 / b * two ; TAB4 assign yu2 - yu2 / a * a to yu2 ; TAB4 change sum2 to sum2 + yu2 / a ; TAB3 else ; TAB4 decrease yu2 by two ; TAB4 increment sum2 ; TAB2 else ; TAB3 assign the new value = yu2 - ci * two to yu2 ; TAB3 change sum2 to sum2 + ci ; TAB1 change sum2 to sum2 + yu2 / one ; TAB1 set yu2 to yu2 modulo one ; TAB1 set ans to max of ans and sum2 ; TAB1 change the value of ans to max of sum1 and ans ; TAB1 print ans ;	const long long mod = 998244353 ; const int maxn = 2e5 ; int main ( ) { int t ; long long n , a , b , c ; cin >> n ; cin >> a >> b >> c ; long long one = a , two = b - c ; long long sum1 = n / one , yu1 = n % one , ci ; while ( yu1 / b > 0 ) { ci = ( yu1 - b ) / two ; if ( ci == 0 && yu1 >= b ) { if ( yu1 / a > 0 && yu1 / a * a < yu1 / b * two ) { yu1 = yu1 - yu1 / a * a ; sum1 = sum1 + yu1 / a ; } else { yu1 -= two ; sum1 ++ ; } } else { yu1 = yu1 - ci * two ; sum1 += ci ; } } long long yu2 = n , sum2 = 0 , ans = 0 ; while ( yu2 / b > 0 ) { ci = ( yu2 - b ) / two ; if ( ci == 0 && yu2 >= b ) { if ( yu2 / a > 0 && yu2 / a * a < yu2 / b * two ) { yu2 = yu2 - yu2 / a * a ; sum2 += yu2 / a ; } else { yu2 -= two ; sum2 ++ ; } } else { yu2 = yu2 - ci * two ; sum2 += ci ; } } sum2 += yu2 / one ; yu2 = yu2 % one ; ans = max ( ans , sum2 ) ; ans = max ( sum1 , ans ) ; cout << ans << endl ; return 0 ; }
TAB0 let int array days of size 12 with { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; TAB1 make strings s1 and s2 ; TAB1 read s1 and s2 ; TAB1 make map have from strings to ints ; TAB1 set have [ " monday " ] to 1 ; TAB1 set have [ " tuesday " ] to 2 ; TAB1 set have [ " wednesday " ] to 3 ; TAB1 set have [ " thursday " ] to 4 ; TAB1 set have [ " friday " ] to 5 ; TAB1 set have [ " saturday " ] to 6 ; TAB1 set have [ " sunday " ] to 7 ; TAB1 create integer d1 to have [ s1 ] ; TAB1 make int d1 to have [ s2 ] ; TAB1 decrease d1 by 1 ; TAB1 decrease d2 by 1 ; TAB1 for i = 0 to 12 exclusive ; TAB2 make int now to d1 ; TAB2 set now to now + days [ i ] ; TAB2 modulo now by 7 ; TAB2 if now is d2 ; TAB3 show " YES " ; TAB1 display " NO " ;	int days [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int main ( ) { string s1 , s2 ; cin >> s1 >> s2 ; map < string , int > have ; have [ " monday " ] = 1 ; have [ " tuesday " ] = 2 ; have [ " wednesday " ] = 3 ; have [ " thursday " ] = 4 ; have [ " friday " ] = 5 ; have [ " saturday " ] = 6 ; have [ " sunday " ] = 7 ; int d1 = have [ s1 ] ; int d2 = have [ s2 ] ; d1 -- ; d2 -- ; for ( int i = 0 ; i < 12 ; i ++ ) { int now = d1 ; now += days [ i ] ; now %= 7 ; if ( now == d2 ) { puts ( " YES " ) ; return 0 ; } } puts ( " NO " ) ; return 0 ; }
TAB1 create new integer n ; TAB1 read input to n ; TAB1 if n % 4 = 1 ; TAB2 print 8 ; TAB1 else if n modulo 4 is equal to 2 ; TAB2 print 4 to the standard output ; TAB1 else if n modulo 4 is 3 ; TAB2 print 2 to the output ; TAB1 else if n is equal to 0 ; TAB2 print 1 ; TAB1 else ; TAB2 print 6 ;	int main ( ) { int n ; cin >> n ; if ( n % 4 == 1 ) cout << 8 << endl ; else if ( n % 4 == 2 ) cout << 4 << endl ; else if ( n % 4 == 3 ) cout << 2 << endl ; else if ( n == 0 ) cout << 1 << endl ; else cout << 6 << endl ; return 0 ; }
TAB1 let companies be a long integer ; TAB1 read companies ; TAB1 emps = vector of long integers ; TAB1 employeenum = vector of long integers ; TAB1 let long integer value of maxmaxsalary = 0 ; TAB1 for long integer i = 0 to companies exclusive ; TAB2 let employees be a long integer ; TAB2 read employees ; TAB2 push_back employees into vector employeenum ; TAB2 let long integer value of maxsalary = 0 ; TAB2 for long integer j = 0 to employees exclusive ; TAB3 let salary be a long integer ; TAB3 read salary ; TAB3 if maxsalary is less than salary , maxsalary is equal to salary ; TAB2 if maxmaxsalary is less than maxsalary , maxmaxsalary is equal to maxsalary ; TAB2 push_back maxsalary into vector emps ; TAB1 let long integer value of sum = 0 ; TAB1 for long integer i = 0 to length of emps exclusive , increment sum by ( maxmaxsalary - emps [ i ] ) * employeenum [ i ] ; TAB1 print sum and newline ;	int main ( ) { long long int companies ; cin >> companies ; vector < long long int > emps ; vector < long long int > employeenum ; long long int maxmaxsalary = 0 ; for ( long long int i = 0 ; i < companies ; i ++ ) { long long int employees ; cin >> employees ; employeenum . push_back ( employees ) ; long long int maxsalary = 0 ; for ( long long int j = 0 ; j < employees ; j ++ ) { long long int salary ; cin >> salary ; if ( maxsalary < salary ) { maxsalary = salary ; } } if ( maxmaxsalary < maxsalary ) { maxmaxsalary = maxsalary ; } emps . push_back ( maxsalary ) ; } long long int sum = 0 ; for ( long long int i = 0 ; i < emps . size ( ) ; i ++ ) { sum += ( maxmaxsalary - emps [ i ] ) * employeenum [ i ] ; } cout << sum << endl ; return 0 ; }
TAB0 size = 5004 ; TAB0 dp = array of size by size int ; TAB0 s1 and s2 = array of size char ; TAB1 read s1 ; TAB1 read s2 ; TAB1 ans = 0 ; TAB1 n = length of s1 , m = length of s2 ; TAB1 for i = 1 to n + 1 exclusive ; TAB2 for j = 1 to m + 1 exclusive ; TAB3 add dp [ i ] [ j - 1 ] to dp [ i ] [ j ] ; TAB3 dp [ i ] [ j ] = dp [ i ] [ j ] modulo 1000000007 ; TAB3 if s1 [ i - 1 ] is s2 [ j - 1 ] add dp [ i - 1 ] [ j - 1 ] + 1 to dp [ i ] [ j ] ; TAB3 dp [ i ] [ j ] = dp [ i ] [ j ] modulo 1000000007 ; TAB3 if j is m ; TAB4 add dp [ i ] [ j ] to ans ; TAB4 ans = ans modulo 1000000007 ; TAB1 print ans ;	const int size = 5004 ; int dp [ size ] [ size ] ; char s1 [ size ] , s2 [ size ] ; int main ( ) { gets ( s1 ) ; gets ( s2 ) ; int ans = 0 ; int n = strlen ( s1 ) , m = strlen ( s2 ) ; for ( int i = 1 ; i < n + 1 ; ++ i ) { for ( int j = 1 ; j < m + 1 ; ++ j ) { dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; dp [ i ] [ j ] %= 1000000000 + 7 ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + 1 ; dp [ i ] [ j ] %= 1000000000 + 7 ; if ( j == m ) { ans += dp [ i ] [ j ] ; ans %= 1000000000 + 7 ; } } } cout << ans << endl ; return 0 ; }
TAB0 declare an array of bools a with size 55 ; TAB0 create an array of booleans b with size 55 ; TAB1 declare vector of ints called ivec ; TAB1 create integers n , aa and bb ; TAB1 read input to n ; TAB1 declare int variable days = n squared ; TAB1 for integer i = 1 to days inclusive ; TAB2 read aa and bb ; TAB2 if a [ aa ] is false and b [ bb ] is false ; TAB3 change a [ aa ] and b [ bb ] to true ; TAB3 push i into ivec ; TAB1 for integer i = 0 to length of ivec exclusive ; TAB2 if i = length of ivec - 1 ; TAB3 print ivec [ i ] ; TAB2 else ; TAB3 print ivec [ i ] and ' ' ;	bool a [ 55 ] ; bool b [ 55 ] ; int main ( ) { vector < int > ivec ; int n , aa , bb ; cin >> n ; int days = n * n ; for ( int i = 1 ; i <= days ; ++ i ) { cin >> aa >> bb ; if ( ! a [ aa ] && ! b [ bb ] ) { a [ aa ] = b [ bb ] = true ; ivec . push_back ( i ) ; } } for ( int i = 0 ; i < ivec . size ( ) ; ++ i ) { if ( i == ivec . size ( ) - 1 ) cout << ivec [ i ] << endl ; else cout << ivec [ i ] << '   ' ; } return 0 ; }
TAB0 x , LCM , memo = integer array of size 101 ; TAB0 T = long long with T = 1 ; TAB0 in the function Call that takes integer i , Target and returns integer ; TAB1 if i is Target , return 1 ; TAB1 if memo [ i ] , return - 1000 ; TAB1 memo [ i ] = 1 ; TAB1 return 1 + Call ( x [ i ] , Target ) ; TAB0 in the function Fac that takes integer n ; TAB1 i , M = integer with i = 2 , M = integer array of size 101 = { 0 } ; TAB1 while n > 1 ; TAB2 if n modulo i is 0 ; TAB3 n = n / i , M [ i ] ; TAB2 else ; TAB3 increment i ; TAB1 for i = 2 to 99 , LCM [ i ] = max ( LCM [ i ] , M [ i ] ) ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 1 to n , read x [ i ] ; TAB1 for i = 1 , a to n ; TAB2 if memo [ i ] , continue ; TAB2 a = Call on x [ i ] and i ; TAB2 if a < 1 ; TAB3 print - 1 ; TAB2 if a modulo 2 is 0 , a = a / 2 ; TAB2 Fac on a ; TAB1 for i = 2 to 99 ; TAB2 for j = 0 to LCM [ i ] , T = T * i ; TAB1 print T ;	int x [ 101 ] , LCM [ 101 ] , memo [ 101 ] ; long long T = 1 ; int Call ( int i , int Target ) { if ( i == Target ) return 1 ; if ( memo [ i ] ) return - 1000 ; memo [ i ] = 1 ; return 1 + Call ( x [ i ] , Target ) ; } void Fac ( int n ) { int i = 2 , M [ 101 ] = { 0 } ; while ( n > 1 ) if ( n % i == 0 ) n /= i , M [ i ] ++ ; else i ++ ; for ( int i = 2 ; i < 100 ; i ++ ) LCM [ i ] = max ( LCM [ i ] , M [ i ] ) ; } int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> x [ i ] ; for ( int i = 1 , a ; i <= n ; i ++ ) { if ( memo [ i ] ) continue ; a = Call ( x [ i ] , i ) ; if ( a < 1 ) { cout << " -1 " << endl ; return 0 ; } if ( a % 2 == 0 ) a /= 2 ; Fac ( a ) ; } for ( int i = 2 ; i < 100 ; i ++ ) for ( int j = 0 ; j < LCM [ i ] ; j ++ ) T *= i ; cout << T << endl ; }
TAB1 n = integer ; TAB1 s = string ; TAB1 read n , s ; TAB1 last = character with last = ? ; TAB1 flag = integer with flag = 1 ; TAB1 ite = s . begin ( ) to ite is not s . end ( ) ; TAB2 if last is pointer ite ; TAB3 if pointer ite is not ? ; TAB4 flag = 0 ; TAB4 break loop ; TAB3 else ; TAB4 flag = 2 ; TAB2 if ite is not s . begin ( ) and ite is not s . end ( ) - 1 ; TAB3 if pointer ite is ? and last is pointer ( ite + 1 ) , flag = 2 ; TAB2 else ; TAB3 if pointer ite is ? , flag = 2 ; TAB2 last = pointer ite ; TAB1 if flag < = 1 ; TAB2 print No ; TAB1 else ; TAB2 print Yes ;	int main ( ) { int n ; string s ; cin >> n >> s ; char last = ' ? ' ; int flag = 1 ; for ( string :: iterator ite = s . begin ( ) ; ite != s . end ( ) ; ++ ite ) { if ( last == * ite ) { if ( * ite != ' ? ' ) { flag = 0 ; break ; } else { flag = 2 ; } } if ( ite != s . begin ( ) && ite != s . end ( ) - 1 ) { if ( * ite == ' ? ' && last == * ( ite + 1 ) ) { flag = 2 ; } } else { if ( * ite == ' ? ' ) { flag = 2 ; } } last = * ite ; } if ( flag <= 1 ) { cout << " No " << endl ; } else { cout << " Yes " << endl ; } return 0 ; }
TAB0 declare maxin taking in long long ints a and b and returning long long ; TAB1 if a is greater than b , return a ; TAB1 return b ; TAB1 create long long int n ; TAB1 read n ; TAB1 make long long array arr of size n ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 make long long array dif of size n - 1 ; TAB1 for i = 0 to n - 1 exclusive , set dif [ i ] to abs ( arr [ i ] - arr [ i + 1 ] ) ; TAB1 make long long int soma = 0 ; TAB1 create long long maxi = 0 ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if i % 2 is equal to 0 , add dif [ i ] to soma ; TAB2 if i % 2 is not equal to 0 , set soma to soma + dif [ i ] * - 1 ; TAB2 set soma to maxin ( soma , 0 ) ; TAB2 set maxi to return value of maxin ( soma , maxi ) ; TAB1 set soma to 0 ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if i modulo 2 is not equal to 0 , set soma to soma + dif [ i ] ; TAB2 if i % 2 is 0 , add dif [ i ] * - 1 to soma ; TAB2 set soma to maxin ( soma , 0 ) ; TAB2 set maxi to maxin ( soma , maxi ) ; TAB1 display maxi ;	long long maxin ( long long a , long long b ) { if ( a > b ) return a ; return b ; } int main ( ) { long long n ; cin >> n ; long long arr [ n ] ; for ( long long i = 0 ; i < n ; i ++ ) cin >> arr [ i ] ; long long dif [ n - 1 ] ; for ( long long i = 0 ; i < n - 1 ; i ++ ) dif [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) ; long long soma = 0 ; long long maxi = 0 ; for ( long long i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 ) soma += dif [ i ] ; if ( i % 2 != 0 ) soma += dif [ i ] * - 1 ; soma = maxin ( soma , 0 ) ; maxi = maxin ( soma , maxi ) ; } soma = 0 ; for ( long long i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 != 0 ) soma += dif [ i ] ; if ( i % 2 == 0 ) soma += dif [ i ] * - 1 ; soma = maxin ( soma , 0 ) ; maxi = maxin ( soma , maxi ) ; } cout << maxi << endl ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 N = size of s ; TAB1 count = array of 101 by 3 int ; TAB1 fill count with 0 ; TAB1 for i = 0 to N exclusive ; TAB2 if i is 0 ; TAB3 if s [ i ] ! = ' . ' ; TAB4 count [ i + i ] [ s [ i ] - ' A ' ] = 1 ; TAB4 count [ i ] [ s [ i ] - ' A ' ] = 1 ; TAB2 else if i is N - 1 ; TAB3 if s [ i ] ! = ' . ' ; TAB4 count [ i - i ] [ s [ i ] - ' A ' ] = 1 ; TAB4 count [ i ] [ s [ i ] - ' A ' ] = 1 ; TAB2 else ; TAB3 if s [ i ] ! = ' . ' ; TAB4 count [ i - i ] [ s [ i ] - ' A ' ] = 1 ; TAB4 count [ i + i ] [ s [ i ] - ' A ' ] = 1 ; TAB4 count [ i ] [ s [ i ] - ' A ' ] = 1 ; TAB1 for i = 0 to N exclusive ; TAB2 if count [ i ] [ 0 ] is 1 and count [ i ] [ 1 ] is 1 and count [ i ] [ 2 ] is 1 ; TAB3 print " Yes " ; TAB1 print " No " ;	int main ( ) { string s ; cin >> s ; int N = s . size ( ) ; int count [ 101 ] [ 3 ] ; memset ( count , 0 , sizeof count ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { if ( s [ i ] != ' . ' ) { count [ i + 1 ] [ s [ i ] - ' A ' ] = 1 ; count [ i ] [ s [ i ] - ' A ' ] = 1 ; } } else if ( i == ( N - 1 ) ) { if ( s [ i ] != ' . ' ) { count [ i - 1 ] [ s [ i ] - ' A ' ] = 1 ; count [ i ] [ s [ i ] - ' A ' ] = 1 ; } } else { if ( s [ i ] != ' . ' ) { count [ i - 1 ] [ s [ i ] - ' A ' ] = 1 ; count [ i + 1 ] [ s [ i ] - ' A ' ] = 1 ; count [ i ] [ s [ i ] - ' A ' ] = 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( count [ i ] [ 0 ] == 1 && count [ i ] [ 1 ] == 1 && count [ i ] [ 2 ] == 1 ) { cout << " Yes\n " ; return 0 ; } } cout << " No\n " ; return 0 ; }
TAB0 create an array of int / int pairs trees with 105 elements ; TAB1 declare int variable n ; TAB1 read input to n ; TAB1 declare integers sum , sum_pos and sum_neg = 0 ; TAB1 loop i from 0 to n exclusive ; TAB2 read trees [ i ] . first and trees [ i ] . second ; TAB2 increase sum by trees [ i ] . second ; TAB2 if trees [ i ] . first is less than 0 , increase sum_neg by trees [ i ] . second ; TAB2 if trees [ i ] . first is greater than 0 , increase sum_pos by trees [ i ] . second ; TAB1 sort trees ; TAB1 declare integers pos and neg = 0 and center = - 1 ; TAB1 loop i from 0 to n exclusive ; TAB2 if trees [ i ] . first is greater than 0 , increment pos ; TAB2 if trees [ i ] . first > 0 and center = - 1 , change center to i ; TAB1 if pos is equal to 0 , change center to n ; TAB1 assign n - pos to neg ; TAB1 if absolute value of pos - neg < = 1 ; TAB2 print sum ; TAB1 else ; TAB2 if neg is greater than pos ; TAB3 assign sum_pos to sum ; TAB3 for integer i = center - 1 , j = 0 while i > = 0 and j < pos + 1 , decrementing i and incrementing j , increase sum by trees [ i ] . second ; TAB2 else ; TAB3 change sum to sum_neg ; TAB3 for i = center , j = 0 while i < n and j < neg + 1 , increase sum by trees [ i ] . second ; TAB2 print sum ;	pair < int , int > trees [ 105 ] ; int main ( ) { int n ; cin >> n ; int sum = 0 , sum_pos = 0 , sum_neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> trees [ i ] . first >> trees [ i ] . second ; sum += trees [ i ] . second ; if ( trees [ i ] . first < 0 ) sum_neg += trees [ i ] . second ; if ( trees [ i ] . first > 0 ) sum_pos += trees [ i ] . second ; } sort ( trees , trees + n ) ; int pos = 0 , neg = 0 , center = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( trees [ i ] . first > 0 ) pos ++ ; if ( trees [ i ] . first > 0 && center == - 1 ) center = i ; } if ( pos == 0 ) center = n ; neg = n - pos ; if ( abs ( pos - neg ) <= 1 ) cout << sum << endl ; else { if ( neg > pos ) { sum = sum_pos ; for ( int i = center - 1 , j = 0 ; i >= 0 && j < pos + 1 ; i -- , j ++ ) sum += trees [ i ] . second ; } else { sum = sum_neg ; for ( int i = center , j = 0 ; i < n && j < neg + 1 ; i ++ , j ++ ) sum += trees [ i ] . second ; } cout << sum << endl ; } }
TAB0 long long function bigmod with long long arguments a , b and m ; TAB1 if b = 0 , return 1 % m ; TAB1 declare long long variable x = bigmod ( a , b / 2 , m ) ; TAB1 change x to ( x * x ) modulo % m ; TAB1 if b is odd , assign ( x * a ) % m to x ; TAB1 return x ; TAB0 f is a long long function with long long argument n ; TAB1 if n = 0 , return 0 ; TAB1 if n % 10 = 0 , decrement n by one ; TAB1 if n is less than 100 , return n / 11 + ( n if n < 10 or 9 otherwise ) ; TAB1 declare long long variable r = n % 10 ; TAB1 declare long long l = n and d = 1 ; TAB1 while l > 9 ; TAB2 divide l by 10 ; TAB2 increment d by one ; TAB1 declare long long variable m ; TAB1 declare long long variable c = 1 ; TAB1 for i = 0 to d - 1 exclusive , multiply c by 10 ; TAB1 change m to ( n % c ) / 10 + 1 ; TAB1 declare long long an = 18 ; TAB1 set c to 1 ; TAB1 for i from 3 to d inclusive ; TAB2 multiply c by 10 ; TAB2 for j from 1 to 9 inclusive ; TAB3 if i is equal to d and j is equal to l ; TAB4 if l < = r ; TAB5 return an + m ; TAB4 else ; TAB5 return an + m - 1 ; TAB3 increase an by c ; TAB1 return an ; TAB1 declare long long variables a and b ; TAB1 read a and b and loop further , printing f ( b ) - f ( a - 1 ) on each iteration ;	long long bigmod ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 % m ; long long x = bigmod ( a , b / 2 , m ) ; x = ( x * x ) % m ; if ( b % 2 ) x = ( x * a ) % m ; return x ; } long long f ( long long n ) { if ( n == 0 ) return 0 ; if ( n % 10 == 0 ) n -- ; if ( n < 100 ) return n / 11 + ( n < 10 ? n : 9 ) ; long long r = n % 10 ; long long l = n , d = 1 ; while ( l > 9 ) { l /= 10 ; d ++ ; } long long m ; long long c = 1 ; for ( int i = 0 ; i < d - 1 ; i ++ ) c *= 10 ; m = ( n % c ) / 10 + 1 ; long long an = 18 ; c = 1 ; for ( int i = 3 ; i <= d ; i ++ ) { c *= 10 ; for ( int j = 1 ; j <= 9 ; j ++ ) { if ( i == d && j == l ) if ( l <= r ) return an + m ; else return an + m - 1 ; an += c ; } } return an ; } int main ( ) { long long a , b ; while ( cin >> a >> b ) cout << f ( b ) - f ( a - 1 ) << endl ; }
TAB1 declare integers n , i ; TAB1 declare integer array arr size 100005 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 declare integers counter = 0 , flag = 0 , found = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if arr [ i ] is 25 , increment counter ; TAB2 if arr [ i ] is 50 ; TAB3 if counter is less than 1 ; TAB4 increment flag ; TAB4 end loop ; TAB3 else ; TAB4 increment found ; TAB4 decrement counter ; TAB2 if arr [ i ] is 100 ; TAB3 if counter is less than 0 or ( found is less than 1 and counter is less than 1 ) ; TAB4 increment flag ; TAB4 end loop ; TAB3 else ; TAB4 if found is greater than 0 and counter is greater than 0 ; TAB5 decrement found ; TAB5 decrement counter ; TAB4 else ; TAB5 if counter is less than 3 ; TAB6 increment flag ; TAB6 end loop ; TAB5 decrement counter by 3 ; TAB1 if flag is 0 ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ;	int main ( ) { int n , i ; int arr [ 100005 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } int counter = 0 , flag = 0 , found = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 25 ) { counter ++ ; } if ( arr [ i ] == 50 ) { if ( counter < 1 ) { flag ++ ; break ; } else { found ++ ; counter -- ; } } if ( arr [ i ] == 100 ) { if ( counter < 0 || ( found < 1 && counter < 1 ) ) { flag ++ ; break ; } else { if ( found > 0 && counter > 0 ) { found -- ; counter -- ; } else { if ( counter < 3 ) { flag ++ ; break ; } counter -= 3 ; } } } } if ( flag == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB1 pos , flag = int with flag = 0 ; TAB1 str , s , t = string ; TAB1 read str then s then t ; TAB1 set pos to index of s in str and if pos is not string : : npos ; TAB2 if str contains t after pos + length of s then increment flag ; TAB1 reverse str ; TAB1 set pos to index of s in str and if pos is not string : : npos ; TAB2 if str contains t after pos + length of s then increment flag by 2 ; TAB1 if flag is 0 ; TAB2 print " fantasy " ; TAB1 else if flag is 1 ; TAB2 print " forward " ; TAB1 else if flag is 2 ; TAB2 print " backward " ; TAB1 else ; TAB2 print " both " ;	int main ( ) { int pos , flag = 0 ; string str , s , t ; cin >> str >> s >> t ; if ( ( pos = str . find ( s ) ) != string :: npos ) if ( ( str . substr ( pos + s . length ( ) ) ) . find ( t ) != string :: npos ) flag += 1 ; reverse ( str . begin ( ) , str . end ( ) ) ; if ( ( pos = str . find ( s ) ) != string :: npos ) if ( ( str . substr ( pos + s . length ( ) ) ) . find ( t ) != string :: npos ) flag += 2 ; if ( flag == 0 ) puts ( " fantasy " ) ; else if ( flag == 1 ) puts ( " forward " ) ; else if ( flag == 2 ) puts ( " backward " ) ; else puts ( " both " ) ; return 0 ; }
TAB1 declare new boolean variable cek = true ; TAB1 declare integer variable n ; TAB1 create new string s ; TAB1 read n and s ; TAB1 start for loop from i = 1 to n exclusive incrementing i ; TAB2 if s [ i - 1 ] and s [ i ] are both equal to ' 1 ' , assign the new value = false to cek ; TAB1 in a for loop , change i from 2 to n exclusive incrementing i ; TAB2 if values of s [ i - 2 ] , s [ i - 1 ] and s [ i ] are equal to ' 0 ' , assign false to cek ; TAB1 if n > = 2 ; TAB2 change cek to false if s [ 0 ] and s [ 1 ] are equal to ' 0 ' ; TAB2 set the value of cek to false if s [ n - 1 ] and s [ n - 2 ] = ' 0 ' , ; TAB1 else if s [ 0 ] is equal to ' 0 ' ; TAB2 set cek to false ; TAB1 print " Yes " if cek is true of " No " otherwise ;	int main ( ) { bool cek = true ; int n ; string s ; cin >> n >> s ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i - 1 ] == ' 1 ' && s [ i ] == ' 1 ' ) cek = false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( s [ i - 2 ] == ' 0 ' && s [ i - 1 ] == ' 0 ' && s [ i ] == ' 0 ' ) cek = false ; } if ( n >= 2 ) { if ( s [ 0 ] == ' 0 ' && s [ 1 ] == ' 0 ' ) cek = false ; if ( s [ n - 1 ] == ' 0 ' && s [ n - 2 ] == ' 0 ' ) cek = false ; } else if ( s [ 0 ] == ' 0 ' ) cek = false ; ( cek ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
TAB1 define unsigned long long integer n ; TAB1 read standard input to n ; TAB1 if n < = 127 ; TAB2 print " byte \ n " ; TAB1 else if n < = 32767 ; TAB2 print " short \ n " ; TAB1 else if n < = 2147483647 ; TAB2 print " int \ n " to the standard output ; TAB1 else if n < = 9223372036854775807 ; TAB2 print " long \ n " ; TAB1 else ; TAB2 print " BigInteger \ n " ;	int main ( ) { unsigned long long int n ; cin >> n ; if ( n <= 127 ) cout << " byte\n " ; else if ( n <= 32767 ) cout << " short\n " ; else if ( n <= 2147483647 ) cout << " int\n " ; else if ( n <= 9223372036854775807 ) cout << " long\n " ; else cout << " BigInteger\n " ; return 0 ; }
TAB1 let str a string ; TAB1 read str ; TAB1 let temp a string ; TAB1 set temp to str ; TAB1 reverse temp ; TAB1 if temp same as str ; TAB2 print 0 ; TAB1 otherwise ; TAB2 let ans an int with value 0 ; TAB2 let k1 an int with value ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' ) ; TAB2 let k2 an int with value ( str [ 3 ] - ' 0 ' ) * 10 + ( str [ 4 ] - ' 0 ' ) ; TAB2 repeat forever ; TAB3 increment k2 ; TAB3 increment ans ; TAB3 if k2 at least 60 ; TAB4 set k2 to 0 ; TAB4 increment k1 ; TAB3 if k1 at least 23 , set k1 to k1 mod 24 ; TAB3 let blah an empty string ; TAB3 append ( k1 / 10 + ' 0 ' ) to blah ; TAB3 append ( k1 mod 10 + ' 0 ' ) to blah ; TAB3 append ( k2 / 10 + ' 0 ' ) to blah ; TAB3 append ( k2 mod 10 + ' 0 ' ) to blah ; TAB3 let val a string , and set it equal to blah ; TAB3 reverse val ; TAB3 if val same as blah , leave loop ; TAB2 print ans ;	int main ( ) { string str ; cin >> str ; string temp ; temp = str ; reverse ( temp . begin ( ) , temp . end ( ) ) ; if ( temp == str ) cout << " 0 " << endl ; else { int ans = 0 ; int k1 = ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' ) ; int k2 = ( str [ 3 ] - ' 0 ' ) * 10 + ( str [ 4 ] - ' 0 ' ) ; while ( true ) { k2 ++ ; ans ++ ; if ( k2 >= 60 ) { k2 = 0 ; k1 ++ ; } if ( k1 >= 23 ) { k1 = k1 % 24 ; } string blah = "  " ; blah += ( k1 / 10 + ' 0 ' ) ; blah += ( k1 % 10 + ' 0 ' ) ; blah += ( k2 / 10 + ' 0 ' ) ; blah += ( k2 % 10 + ' 0 ' ) ; string val = blah ; reverse ( val . begin ( ) , val . end ( ) ) ; if ( val == blah ) break ; } cout << ans << endl ; } return 0 ; }
TAB0 let N be a constant interger , set N to 1e5 + 1 ; TAB0 let arr be of array of length N of long long integers ; TAB1 let n be an integer ; TAB1 read in n ; TAB1 set arr [ 0 ] to 0 ; TAB1 iterate for N - 1 times , set arr [ i ] to arr [ i - 1 ] + i ; TAB1 iterate for N - 1 times ; TAB2 if n - arr [ i ] is in the array ; TAB3 print YES ; TAB1 print NO ;	int const N = 1e5 + 1 ; long long arr [ N ] ; int main ( ) { int n ; cin >> n ; arr [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) arr [ i ] = arr [ i - 1 ] + i ; for ( int i = 1 ; i < N ; i ++ ) if ( binary_search ( arr + 1 , arr + N , n - arr [ i ] ) ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB0 create const int MAXN = 1e5 + 10 ; TAB0 create int arrays mp and dp with MAXN elements ; TAB1 declare integers x and y ; TAB1 read x and y ; TAB1 if x is false or y is false ; TAB2 if x is false and y is false ; TAB3 print 0 ; TAB2 else ; TAB3 if y is false ; TAB4 if x is less than 0 ; TAB5 print 4 * ( - x ) - 1 ; TAB4 else ; TAB5 if x is equal to 1 ; TAB6 print 0 ; TAB5 else ; TAB6 print ( x - 1 ) * 4 + 1 ; TAB3 else ; TAB4 if y is greater than 0 ; TAB5 print ( y - 1 ) * 4 + 2 ; TAB4 else ; TAB5 print ( - y ) * 4 ; TAB1 else ; TAB2 if x > 0 and x > = y and y > - x + 1 ; TAB3 print ( x - 1 ) * 4 + 1 ; TAB2 else if y > 0 and - y < = x and y > x ; TAB3 print ( y - 1 ) * 4 + 2 ; TAB2 else if x < 0 and y > = x and - x > y ; TAB3 print 4 * - x - 1 ; TAB2 else ; TAB3 print - y * 4 ;	const int MAXN = 1e5 + 10 ; int mp [ MAXN ] , dp [ MAXN ] ; int main ( ) { int x , y ; cin >> x >> y ; if ( ! x || ! y ) { if ( ! x && ! y ) cout << 0 << endl ; else { if ( ! y ) { if ( x < 0 ) cout << 4 * ( - x ) - 1 << endl ; else { if ( x == 1 ) cout << 0 << endl ; else cout << ( x - 1 ) * 4 + 1 << endl ; } } else { if ( y > 0 ) cout << ( y - 1 ) * 4 + 2 << endl ; else cout << ( - y ) * 4 << endl ; } } } else { if ( x > 0 && x >= y && y > ( - x ) + 1 ) { cout << ( x - 1 ) * 4 + 1 << endl ; } else if ( y > 0 && ( - y ) <= x && y > x ) { cout << ( y - 1 ) * 4 + 2 << endl ; } else if ( x < 0 && y >= x && ( - x ) > y ) { cout << 4 * ( - x ) - 1 << endl ; } else { cout << ( - y ) * 4 << endl ; } } return 0 ; }
TAB0 a = array of unsigned long integers of length 2000000 ; TAB0 b = array of unsigned long integers of length 2000000 ; TAB0 let n be a integer ; TAB0 let judge be boolean which accepts int n ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if a [ i ] is equal to a [ i + 1 ] , return the value true ; TAB1 return the value false ; TAB1 while read n ; TAB2 memset of a , 0 , length of a ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 increment b [ a [ i ] ] by 1 ; TAB2 sort the values a , a + n ; TAB2 let ans be a integer with ans = 0 ; TAB2 for i = 1 to 2000000 exclusive ; TAB3 increment b [ i ] by b [ i - 1 ] / 2 ; TAB3 b [ i - 1 ] is equal to b [ i - 1 ] modulo 2 ; TAB3 increment ans by b [ i - 1 ] ; TAB2 print ans and new line ;	unsigned long long a [ 2000000 ] ; unsigned long long b [ 2000000 ] ; int n ; bool judge ( int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) return true ; } return false ; } int main ( ) { while ( cin >> n ) { memset ( a , 0 , sizeof ( a ) ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; b [ a [ i ] ] ++ ; } sort ( a , a + n ) ; int ans = 0 ; for ( int i = 1 ; i < 2000000 ; ++ i ) { b [ i ] += ( b [ i - 1 ] / 2 ) ; b [ i - 1 ] %= 2 ; ans += b [ i - 1 ] ; } cout << ans << endl ; } }
TAB0 in function maxx taking long long int a , long long int b and returning long long int ; TAB1 if a > b return a else return b ; TAB0 in function minn taking long long int a , long long int b and returning long long int ; TAB1 if a > b return b else return a ; TAB0 dx = int array with the values 1 , 1 , 1 , 0 , 0 , - 1 , - 1 , - 1 , 0 ; TAB0 dy = int array with the values - 1 , 0 , 1 , 1 , - 1 , 0 , 1 , - 1 , 0 ; TAB0 define empty function boostISO ; TAB0 in function gcd taking long long int a , long long int b and returning long long int ; TAB1 if b is 0 return a else return gcd of b , a mod b ; TAB0 in function lcm taking long long int a , long long int b and returning long long int ; TAB1 return ( a * b ) / gcd of a , b ; TAB0 in function poww taking long long int base , long long int exp and returning long long int ; TAB1 set base to base mod 1000000007 ; TAB1 result = long long int with result = 1 ; TAB1 loop while exp > 0 ; TAB2 if exp bitwise - and 1 set result to ( result * base ) mod 1000000007 ; TAB2 set base to ( base * base ) mod 1000000007 ; TAB2 set exp to exp bitshift right by 1 ; TAB1 return result ; TAB0 a = int vector array of size 200 ; TAB0 pos = two dimensional bool array of sizes 120 and 120 and vis = bool array of size 120 ; TAB0 n , m = int ; TAB0 in function dfs taking int root ; TAB1 set vis [ root ] to 1 ; TAB1 for i = 0 to size of a [ root ] ; TAB2 if not vis [ a [ root ] [ i ] ] call dfs of a [ root ] [ i ] ; TAB1 return ; TAB0 in function comp returning int ; TAB1 ret = int with ret = 0 ; TAB1 for i = 1 to n icnlusive ; TAB2 if not vis [ i ] ; TAB3 increment ret ; TAB3 call dfs of i ; TAB1 return ret ; TAB1 read n then m ; TAB1 tot = int with tot = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 x = int ; TAB2 read x ; TAB2 increment tot by x ; TAB2 for j = 0 to x ; TAB3 l = int ; TAB3 read l ; TAB3 set pos [ i ] [ l ] to 1 ; TAB1 if tot is 0 ; TAB2 print n ; TAB1 for i = 1 to n inclusive ; TAB2 for j = i + 1 to n inclusive ; TAB3 for k = 1 to m inclusive ; TAB4 if pos [ i ] [ k ] and pos [ j ] [ k ] ; TAB5 append j to a [ i ] then append i to a [ j ] ; TAB5 break ; TAB1 print comp - 1 ;	long long int maxx ( long long int a , long long int b ) { return a > b ? a : b ; } long long int minn ( long long int a , long long int b ) { return a > b ? b : a ; } int dx [ ] = { 1 , 1 , 1 , 0 , 0 , - 1 , - 1 , - 1 , 0 } ; int dy [ ] = { - 1 , 0 , 1 , 1 , - 1 , 0 , 1 , - 1 , 0 } ; void boostIO ( ) { } long long int gcd ( long long int a , long long int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } long long int lcm ( long long int a , long long int b ) { return ( a * b ) / gcd ( a , b ) ; } long long int poww ( long long int base , long long int exp ) { base %= 1000000007 ; long long int result = 1 ; while ( exp > 0 ) { if ( exp & 1 ) result = ( result * base ) % 1000000007 ; base = ( base * base ) % 1000000007 ; exp >>= 1 ; } return result ; } vector < int > a [ 200 ] ; bool pos [ 120 ] [ 120 ] , vis [ 120 ] ; int n , m ; void dfs ( int root ) { vis [ root ] = 1 ; for ( int i = 0 ; i < a [ root ] . size ( ) ; i ++ ) { if ( ! vis [ a [ root ] [ i ] ] ) dfs ( a [ root ] [ i ] ) ; } return ; } int comp ( ) { int ret = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) { ret ++ ; dfs ( i ) ; } } return ret ; } int main ( ) { cin >> n >> m ; int tot = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x ; cin >> x ; tot = tot + x ; for ( int j = 0 ; j < x ; j ++ ) { int l ; cin >> l ; pos [ i ] [ l ] = 1 ; } } if ( tot == 0 ) { cout << n << endl ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( pos [ i ] [ k ] && pos [ j ] [ k ] ) { a [ i ] . push_back ( j ) , a [ j ] . push_back ( i ) ; break ; } } } } cout << comp ( ) - 1 << endl ; return 0 ; }
TAB1 create int n ; TAB1 read n ; TAB1 create int b [ n + 5 ] ; TAB1 create int c [ n + 5 ] ; TAB1 for l and k = 1 ; TAB1 for i = 1 to n inclusive ; TAB2 create int m ; TAB2 read m ; TAB2 set b [ l ] to m ; TAB2 increment l ; TAB2 create int a [ m + 5 ] ; TAB2 for i = 1 to m inclusive , read a [ i ] ; TAB2 sort on ( a + 1 , a + 1 + m ) ; TAB2 set c [ k ] = a [ 1 ] ; TAB2 increment k ; TAB2 for i = 1 to m inclusive , set a [ i ] = 0 ; TAB1 set su = b [ 1 ] ; TAB1 assign 0 to sum1 ; TAB1 mx = c [ 1 ] ; TAB1 for i = 2 to n inclusive ; TAB2 if mx > c [ i ] ; TAB3 s = mx - c [ i ] ; TAB3 set sum = s * b [ i ] ; TAB3 assign sum1 + sum to sum1 ; TAB3 set su to su + b [ i ] ; TAB2 else ; TAB3 s = c [ i ] - mx ; TAB3 set sum = s * su ; TAB3 set sum1 to sum1 + sum ; TAB3 assign su + b [ i ] to su ; TAB3 mx = c [ i ] ; TAB1 print sum1 ;	int main ( ) { int n ; cin >> n ; int b [ n + 5 ] ; int c [ n + 5 ] ; int l = 1 , k = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int m ; cin >> m ; b [ l ] = m ; l ++ ; int a [ m + 5 ] ; for ( int i = 1 ; i <= m ; i ++ ) { cin >> a [ i ] ; } sort ( a + 1 , a + 1 + m , greater < int > ( ) ) ; c [ k ] = a [ 1 ] ; k ++ ; for ( int i = 1 ; i <= m ; i ++ ) { a [ i ] = 0 ; } } long long su = b [ 1 ] ; long long sum1 = 0 ; long long mx = c [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { if ( mx > c [ i ] ) { long long s = mx - c [ i ] ; long long sum = s * b [ i ] ; sum1 += sum ; su += b [ i ] ; } else { long long s = c [ i ] - mx ; long long sum = s * su ; sum1 += sum ; su += b [ i ] ; mx = c [ i ] ; } } cout << sum1 << endl ; return 0 ; }
TAB1 x = int ; TAB1 read x ; TAB1 a = x ; TAB1 b = a ; TAB1 if a * b < = x or a / b > = x ; TAB2 print - 1 ; TAB1 else ; TAB2 print a , space , b ;	int main ( ) { int x ; cin >> x ; int a = x ; int b = a ; if ( a * b <= x || a / b >= x ) { cout << - 1 << endl ; } else { cout << a << '   ' << b << endl ; } }
TAB0 a = array of 150 integers ; TAB0 b = array of 150 integers ; TAB1 n , m , i , j , k , flag , t , g , sum = integers with flag = 1 and sum = 0 ; TAB1 Read n ; TAB1 Read n values into array a ; TAB1 s = integer with 0 ; TAB1 set g to 0 ; TAB1 set t to 0 ; TAB1 for i = 1 to n exclusive ; TAB2 increment t ; TAB2 if a [ i ] is less than 0 , then increment g ; TAB2 if g is 3 OR i is n ; TAB3 if i is n and g is not 3 ; TAB4 increment s ; TAB4 set b [ s ] to t ; TAB4 Terminate the loop ; TAB3 increment s ; TAB3 set b [ s ] to t - 1 ; TAB3 set t to 0 ; TAB3 set g to 0 ; TAB3 decrement i ; TAB1 print s and a new line ; TAB1 for i = 1 to n exclusive ; TAB2 if i is 1 ; TAB3 print b [ i ] ; TAB2 else do the following ; TAB3 print b [ i ] ; TAB1 print a new line ;	int a [ 150 ] ; int b [ 150 ] ; int main ( ) { int n , m , i , j , k , flag = 1 , t , g , sum = 0 ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; int s = 0 ; g = 0 ; t = 0 ; for ( i = 1 ; i <= n ; i ++ ) { t ++ ; if ( a [ i ] < 0 ) g ++ ; if ( g == 3 || i == n ) { if ( i == n && g != 3 ) { s ++ ; b [ s ] = t ; break ; } s ++ ; b [ s ] = t - 1 ; t = 0 ; g = 0 ; i -- ; } } cout << s << endl ; for ( i = 1 ; i <= s ; i ++ ) { if ( i == 1 ) cout << b [ i ] ; else cout << "   " << b [ i ] ; } cout << " \n " ; }
TAB0 c1 = bool array of size 51 ; TAB0 c2 = bool array of size 51 ; TAB1 n = int ; TAB1 a = int ; TAB1 b = int ; TAB1 v = int vector ; TAB1 read n ; TAB1 set n to n * n ; TAB1 for i = 1 to n inclusive ; TAB2 read a then b ; TAB2 if c1 [ a ] and c2 [ b ] are both false ; TAB3 set c1 [ a ] to true ; TAB3 set c2 [ b ] to true ; TAB3 append i to v ; TAB1 for i = 0 to size of v ; TAB2 if i is size of v - 1 ; TAB3 print v [ i ] then newline ; TAB2 else ; TAB3 print v [ i ] then " " ;	bool c1 [ 51 ] ; bool c2 [ 51 ] ; int main ( ) { int n ; int a ; int b ; vector < int > v ; cin >> n ; n *= n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a >> b ; if ( c1 [ a ] == 0 && c2 [ b ] == 0 ) { c1 [ a ] = 1 ; c2 [ b ] = 1 ; v . push_back ( i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i == v . size ( ) - 1 ) { cout << v [ i ] << " \n " ; } else { cout << v [ i ] << "   " ; } } return 0 ; }
TAB1 n , m = integers ; TAB1 read n , m ; TAB1 min = integer with min = 1000000011 ; TAB1 for i = 0 to m exclusive ; TAB2 l , r = integers ; TAB2 read l , r ; TAB2 min = if ( min > ( r - l + 1 ) ) , ( r - l + 1 ) else min ; TAB1 print min ; TAB1 for i = 0 to n - 1 exclusive , print i modulo min ; TAB1 print ( n - 1 ) modulo min ;	int main ( ) { int n , m ; cin >> n >> m ; int min = 1000000011 ; for ( int i = 0 ; i < m ; i ++ ) { int l , r ; cin >> l >> r ; min = ( min > ( r - l + 1 ) ) ? ( r - l + 1 ) : min ; } cout << min << endl ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << i % min << "   " ; } cout << ( n - 1 ) % min << endl ; return 0 ; }
TAB0 create constant integer N = 2e5 + 10 ; TAB0 make string z = " GRBYW " ; TAB0 make int arrays t1 of size N and t2 of size N ; TAB0 make long ints ans = 1e9 , temp , and same ; TAB0 declare resolve taking in char c and returning integer ; TAB1 for i = 0 to z . size ( ) exclusive ; TAB2 if z [ i ] is equal to c , return i ; TAB0 declare cbits taking in long long x and returning long long ; TAB1 make integer r = 0 ; TAB1 for i = 0 to 10 exclusive ; TAB2 if x & ( 1 < < i ) is truthy , increment r ; TAB1 return r ; TAB1 make long long integer n ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 create string s ; TAB2 read s ; TAB2 set t1 [ i ] to resolve ( s [ 0 ] ) ; TAB2 set t2 [ i ] to s [ 1 ] - ' 1 ' + 5 ; TAB1 for mask = 0 to 1024 exclusive ; TAB2 set temp to cbits ( mask ) ; TAB2 if temp is more than ans , continue loop ; TAB2 make integer err = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 for j = i + 1 to n exclusive ; TAB4 if t1 [ i ] is equal to t1 [ j ] and t2 [ i ] is equal to t2 [ j ] , continue loop ; TAB4 set same to 1 ; TAB4 if t1 [ i ] is not equal to t1 [ j ] ; TAB5 if mask & ( 1 < < t1 [ i ] ) is truthy , set same to 0 ; TAB5 if mask & ( 1 < < t1 [ j ] ) is truthy , set same to 0 ; TAB4 if t2 [ i ] is not equal to t2 [ j ] ; TAB5 if mask & ( 1 < < t2 [ j ] ) , set same to 0 ; TAB5 if mask & ( 1 < < t2 [ j ] ) , set same to 0 ; TAB4 if same is truthy , set err to 1 ; TAB2 if err is falsy , set ans to min of ans and temp ; TAB1 display ans ;	const int N = 2e5 + 10 ; string z = " GRBYW " ; int t1 [ N ] , t2 [ N ] ; long ans = 1e9 , temp , same ; int resolve ( char c ) { for ( int i = 0 ; i < z . size ( ) ; i ++ ) if ( z [ i ] == c ) return i ; } long long cbits ( long long x ) { int r = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( x & ( 1 << i ) ) r ++ ; } return r ; } int main ( ) { long long n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { string s ; cin >> s ; t1 [ i ] = resolve ( s [ 0 ] ) ; t2 [ i ] = s [ 1 ] - ' 1 ' + 5 ; } for ( int mask = 0 ; mask < 1024 ; mask ++ ) { temp = cbits ( mask ) ; if ( temp > ans ) continue ; int err = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( t1 [ i ] == t1 [ j ] && t2 [ i ] == t2 [ j ] ) continue ; same = 1 ; if ( t1 [ i ] != t1 [ j ] ) { if ( mask & ( 1 << t1 [ i ] ) ) same = 0 ; if ( mask & ( 1 << t1 [ j ] ) ) same = 0 ; } if ( t2 [ i ] != t2 [ j ] ) { if ( mask & ( 1 << t2 [ i ] ) ) same = 0 ; if ( mask & ( 1 << t2 [ j ] ) ) same = 0 ; } if ( same ) err = 1 ; } } if ( ! err ) ans = min ( ans , temp ) ; } cout << ans << " \n " ; return 0 ; }
TAB0 let M be a map from long long to boolean ; TAB1 declare integer n ; TAB1 declare long long variable k and long long array a with 100009 elements ; TAB1 read n and k ; TAB1 loop i from 1 to n inclusive , read a [ i ] ; TAB1 create int c = 0 ; TAB1 sort a from the index 1 to n + 1 ; TAB1 for i from 1 to n inclusive ; TAB2 if M [ a [ i ] ] is false ; TAB3 increment c by one ; TAB3 M [ a [ i ] * k ] = 1 ; TAB1 print c ;	map < long long , bool > M ; int main ( ) { int n ; long long k , a [ 100009 ] ; cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } int c = 0 ; sort ( a + 1 , a + n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! M [ a [ i ] ] ) { c ++ ; M [ a [ i ] * k ] = 1 ; } } cout << c << endl ; }
TAB0 v is an array of integers with 1000500 elements ; TAB1 create integer variable with name n ; TAB1 read n and loop further ; TAB2 set first sizeof ( v ) bytes at the pointer v to 0 ; TAB2 for i from 0 to n exclusive incrementing i ; TAB3 x is a new integer ; TAB3 read x ; TAB3 increment v [ x ] by one ; TAB2 start for loop from i = 0 to 1000400 exclusive incrementing i ; TAB3 change v [ i + 1 ] to the sum of v [ i + 1 ] and v [ i ] / 2 ; TAB3 change the value of v [ i ] to v [ i ] modulo 2 ; TAB2 t is a new integer variable with value 0 ; TAB2 for integer i = 0 to 1000400 exclusive , change t to t + v [ i ] ; TAB2 print t ;	int v [ 1000500 ] ; int main ( ) { int n ; while ( cin >> n ) { memset ( v , 0 , sizeof ( v ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; v [ x ] ++ ; } for ( int i = 0 ; i < 1000400 ; i ++ ) { v [ i + 1 ] += v [ i ] / 2 ; v [ i ] %= 2 ; } int t = 0 ; for ( int i = 0 ; i < 1000400 ; i ++ ) { t += v [ i ] ; } cout << t << endl ; } return 0 ; }
TAB1 declare a , b , c , d , e , f as integers ; TAB1 read a and b and c and d and e and f ; TAB1 declare boolean test = a and c and e and b * d * f is greater than a * c * e ; TAB1 declare booleans sgs = e is 0 and f is not 0 , sgl = a is 0 and b is not 0 , sgg = c is 0 and d is not 0 ; TAB1 declare booleans cgs = f is not 0 , cgl = b is not 0 , cgg = d is not 0 ; TAB1 declare boolean ron = sgg or ( sgl and cgg ) or ( sgs and cgl and cgg ) or tests ; TAB1 if ron is true ; TAB2 print " Ron " , newline ; TAB1 else ; TAB2 print " Hermione " , newline ;	int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; bool test = a and c and e and b * d * f > a * c * e ; bool sgs = e == 0 and f != 0 , sgl = a == 0 and b != 0 , sgg = c == 0 and d != 0 ; bool cgs = f != 0 , cgl = b != 0 , cgg = d != 0 ; bool ron = sgg or ( sgl and cgg ) or ( sgs and cgl and cgg ) or ( test ) ; if ( ron ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; }
TAB0 MAXN is a new constant integer = 2e7 ; TAB0 prime is an array of integers with size MAXN ; TAB0 declare new array of integers vis with MAXN elements ; TAB0 a is an array of integers with size MAXN ; TAB0 function init ; TAB1 start for loop from i = 2 to MAXN exclusive incrementing i ; TAB2 if ! prime [ i ] , increment prime [ 0 ] and change prime [ prime [ 0 ] ] to i ; TAB2 increment j in a for loop from j = 1 , while j < = prime [ 0 ] and prime [ j ] < = MAXN / i ; TAB3 change value of prime [ prime [ j ] * i ] to 1 ; TAB3 if i % prime [ j ] = 0 , stop the loop ; TAB1 create integer variable n ; TAB1 define integer variable gcd ; TAB1 read from the input to n ; TAB1 for i from 1 to n inclusive ; TAB2 read user input to a [ i ] ; TAB2 if i is equal to 1 ; TAB3 change the value of gcd to a [ 1 ] ; TAB2 else ; TAB3 set gcd to the resulf of __gcd ( gcd , a [ i ] ) ; TAB1 define new integer Max with value 0 ; TAB1 call init ( ) ; TAB1 for integer i = 1 to n inclusive ; TAB2 change the value of a [ i ] to a [ i ] divided by gcd ; TAB2 change j in a loop from 1 , while < = prime [ 0 ] & & prime [ j ] * prime [ j ] < = a [ i ] ; TAB3 if a [ i ] modulo prime [ j ] is equal to 0 ; TAB4 while a [ i ] % prime [ j ] is 0 , divide a [ i ] by prime [ j ] ; TAB4 increment vis [ prime [ j ] ] ; TAB4 assign the new value = max of Max and vis [ prime [ j ] ] to Max ; TAB2 if a [ i ] ! = 1 ; TAB3 increase vis [ a [ i ] ] by one ; TAB3 set the value of Max to max of Max and vis [ a [ i ] ] ; TAB1 if Max is equal to 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print n - Max to the standard output ;	const int MAXN = 2e7 ; int prime [ MAXN ] ; int vis [ MAXN ] ; int a [ MAXN ] ; void init ( ) { for ( int i = 2 ; i < MAXN ; i ++ ) { if ( ! prime [ i ] ) prime [ ++ prime [ 0 ] ] = i ; for ( int j = 1 ; j <= prime [ 0 ] && prime [ j ] <= MAXN / i ; j ++ ) { prime [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ) break ; } } } int main ( ) { int n ; int gcd ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; if ( i == 1 ) gcd = a [ 1 ] ; else gcd = __gcd ( gcd , a [ i ] ) ; } int Max = 0 ; init ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] /= gcd ; for ( int j = 1 ; j <= prime [ 0 ] && prime [ j ] * prime [ j ] <= a [ i ] ; j ++ ) { if ( a [ i ] % prime [ j ] == 0 ) { while ( a [ i ] % prime [ j ] == 0 ) { a [ i ] /= prime [ j ] ; } vis [ prime [ j ] ] ++ ; Max = max ( Max , vis [ prime [ j ] ] ) ; } } if ( a [ i ] != 1 ) { vis [ a [ i ] ] ++ ; Max = max ( Max , vis [ a [ i ] ] ) ; } } if ( Max == 0 ) cout << - 1 << endl ; else cout << n - Max << endl ; }
TAB0 let n be a integer ; TAB1 read n ; TAB1 print n / 2 and endline ; TAB1 for integer i = 1 to n / 2 - 1 inclusive , print 2 and space ; TAB1 print 2 + n % 2 and endline ;	int n ; int main ( ) { cin >> n ; cout << n / 2 << endl ; for ( int i = 1 ; i <= n / 2 - 1 ; i ++ ) cout << 2 << '   ' ; cout << 2 + n % 2 << endl ; return 0 ; }
TAB0 create new boolean called answerFound ; TAB0 new long longs t0 , t1 , t2 , x1 , x2 , ansy1 and ansy2 ; TAB0 check is a void function with long long arguments y1 and y2 ; TAB1 set y1 to min of y1 and x1 ; TAB1 assign min of y2 and x2 to y2 ; TAB1 set y1 to max of y1 and 0LL ; TAB1 set y2 to max of y2 and 0LL ; TAB1 return if t0 * ( y1 + y2 ) is greater than t1 * y1 + t2 * y2 ; TAB1 if answerFound is false ; TAB2 assign the new value = y1 to ansy1 ; TAB2 change ansy2 to y2 ; TAB2 assign true to answerFound ; TAB1 else ; TAB2 create long long variable l = ( t1 * y1 + t2 * y2 ) * ( ansy1 + ansy2 ) ; TAB2 declare long long r = ( t1 * ansy1 + t2 * ansy2 ) * ( y1 + y2 ) ; TAB2 if l is less than r ; TAB3 assign the new value = y1 to ansy1 ; TAB3 change the value of ansy2 to y2 ; TAB3 assign the new value = true to answerFound ; TAB2 else if l = r and y1 + y2 > ansy1 + ansy2 ; TAB3 change ansy1 to y1 ; TAB3 change ansy2 to y2 ; TAB3 change answerFound to true ; TAB0 divUp is a long long function with long long arguments a and b ; TAB1 return ( a + b - 1 ) / b ; TAB1 read input to t1 , t2 , x1 , x2 and t0 ; TAB1 call check ( 0 , 0 ) ; TAB1 run function check ( 0 , 1 ) ; TAB1 run check with arguments 1 and 0 ; TAB1 start for loop from y1 = 0 to x1 inclusive incrementing y1 ; TAB2 check ( y1 , x2 ) ; TAB2 if t2 ! = t0 ; TAB3 y2 is a new long long = the result of divUp ( t0 * y1 - t1 * y1 , t2 - t0 ) ; TAB3 run check ( y1 , y2 ) ; TAB1 for y2 = 0 to x2 inclusive ; TAB2 call check for x1 and y2 ; TAB2 if t1 ! = t0 ; TAB3 declare new long long called y1 = ( t2 * y2 - t0 * y2 ) / ( t0 - t1 ) ; TAB3 check ( y1 , y2 ) ; TAB1 print ansy1 , " " and ansy2 to the standard output ;	bool answerFound ; long long t0 , t1 , t2 , x1 , x2 , ansy1 , ansy2 ; void check ( long long y1 , long long y2 ) { y1 = min ( y1 , x1 ) ; y2 = min ( y2 , x2 ) ; y1 = max ( y1 , 0LL ) ; y2 = max ( y2 , 0LL ) ; if ( t0 * ( y1 + y2 ) > t1 * y1 + t2 * y2 ) return ; if ( ! answerFound ) { ansy1 = y1 ; ansy2 = y2 ; answerFound = true ; } else { long long l = ( t1 * y1 + t2 * y2 ) * ( ansy1 + ansy2 ) ; long long r = ( t1 * ansy1 + t2 * ansy2 ) * ( y1 + y2 ) ; if ( l < r ) { ansy1 = y1 ; ansy2 = y2 ; answerFound = true ; } else if ( l == r && y1 + y2 > ansy1 + ansy2 ) { ansy1 = y1 ; ansy2 = y2 ; answerFound = true ; } } } long long divUp ( long long a , long long b ) { return ( a + b - 1 ) / b ; } int main ( ) { cin >> t1 >> t2 >> x1 >> x2 >> t0 ; check ( 0 , 0 ) ; check ( 0 , 1 ) ; check ( 1 , 0 ) ; for ( long long y1 = 0 ; y1 <= x1 ; ++ y1 ) { check ( y1 , x2 ) ; if ( t2 != t0 ) { long long y2 = divUp ( t0 * y1 - t1 * y1 , t2 - t0 ) ; check ( y1 , y2 ) ; } } for ( long long y2 = 0 ; y2 <= x2 ; ++ y2 ) { check ( x1 , y2 ) ; if ( t1 != t0 ) { long long y1 = ( t2 * y2 - t0 * y2 ) / ( t0 - t1 ) ; check ( y1 , y2 ) ; } } cout << ansy1 << "   " << ansy2 << endl ; return 0 ; }
TAB1 x be a string array with values " C " , " C # " , " D " , " D # " , " E " , " F " , " F # " , " G " , " G # " , " A " , " B " , " H " ; TAB1 y is a string array of 3 elements ; TAB1 z is an integer array of size 3 ; TAB1 let i , k be integers ; TAB1 for i = 0 to 3 exclusive ; TAB2 read y [ i ] ; TAB2 for k = 0 to 12 exclusive ; TAB3 if y [ i ] equals x [ k ] ; TAB4 z [ i ] equals k ; TAB4 stop ; TAB1 sort the values z , z + 3 ; TAB1 a , b are integers ; TAB1 do loop ; TAB2 a equals ( ( z [ 1 ] - z [ 0 ] ) + 12 ) modulo 12 ; TAB2 b equals ( ( z [ 2 ] - z [ 1 ] ) + 12 ) modulo 12 ; TAB2 if a equals 4 and b equals 3 ; TAB3 print major and endline ; TAB2 if a equals 3 and b equals 4 ; TAB3 print minor and endline ; TAB1 while condition is next_permutation ( z , z + 3 ) ; TAB1 print strange and endline ;	int main ( ) { string x [ ] = { " C " , " C# " , " D " , " D# " , " E " , " F " , " F# " , " G " , " G# " , " A " , " B " , " H " } ; string y [ 3 ] ; int z [ 3 ] ; int i , k ; for ( i = 0 ; i < 3 ; i ++ ) { cin >> y [ i ] ; for ( k = 0 ; k < 12 ; k ++ ) { if ( y [ i ] == x [ k ] ) { z [ i ] = k ; break ; } } } sort ( z , z + 3 ) ; int a , b ; do { a = ( ( z [ 1 ] - z [ 0 ] ) + 12 ) % 12 ; b = ( ( z [ 2 ] - z [ 1 ] ) + 12 ) % 12 ; if ( a == 4 && b == 3 ) { cout << " major " << endl ; return 0 ; } if ( a == 3 && b == 4 ) { cout << " minor " << endl ; return 0 ; } } while ( next_permutation ( z , z + 3 ) ) ; cout << " strange " << endl ; return 0 ; }
TAB1 t = int ; TAB1 read t ; TAB1 while decremented value of t is not 0 ; TAB2 c = char ; TAB2 x , y , a , b , i , j , l = 0 ; TAB2 for i = 1 to 8 inclusive ; TAB3 for j = 1 to 8 inclusive ; TAB4 read c ; TAB4 if c is ' K ' and l is 0 ; TAB5 x = i ; TAB5 y = j ; TAB5 l = 1 ; TAB4 else if c is ' K ' and l is 1 ; TAB5 a = i ; TAB5 b = j ; TAB2 if a - x and b - y are multiple of 4 ; TAB3 print YES ; TAB2 else ; TAB3 print NO ;	int main ( ) { int t ; cin >> t ; while ( t -- ) { char c ; int x , y , a , b , i , j , l = 0 ; for ( i = 1 ; i <= 8 ; i ++ ) { for ( j = 1 ; j <= 8 ; j ++ ) { cin >> c ; if ( c == ' K ' && l == 0 ) { x = i ; y = j ; l = 1 ; } else if ( c == ' K ' && l == 1 ) { a = i ; b = j ; } } } if ( ( a - x ) % 4 == 0 && ( b - y ) % 4 == 0 ) { cout << " YES " << endl ; } else cout << " NO " << endl ; } return 0 ; }
TAB0 let f be a map from strings to integers ; TAB0 in the function init ; TAB1 set the value of f [ " C " ] to 0 ; TAB1 set the value of f [ " C # " ] to 1 ; TAB1 assign 2 to f [ " D " ] ; TAB1 assign the new value = 3 to f [ " D # " ] ; TAB1 assign the new value = 4 to f [ " E " ] ; TAB1 assign the new value = 5 to f [ " F " ] ; TAB1 change f [ " F # " ] to 6 ; TAB1 change the value of f [ " G " ] to 7 ; TAB1 change f [ " G # " ] to 8 ; TAB1 assign the new value = 9 to f [ " A " ] ; TAB1 assign 10 to f [ " B " ] ; TAB1 change f [ " H " ] to 11 ; TAB1 call function init ( ) ; TAB1 create new array of strings s with size 3 ; TAB1 read s [ 0 ] , s [ 1 ] and s [ 2 ] from the input ; TAB1 sort s ; TAB1 declare new string tag with value " strange " ; TAB1 start while loop ; TAB2 declare integer variable with name a = f [ s [ 1 ] ] - f [ s [ 0 ] ] ; TAB2 declare integer b with value f [ s [ 2 ] ] - f [ s [ 1 ] ] ; TAB2 if a is less than 0 , increase a by 12 ; TAB2 if b is less than 0 , add 12 to b ; TAB2 if a = 4 and b is equal to 3 ; TAB3 assign " major " to tag ; TAB3 stop the loop ; TAB2 else if a is equal to 3 and b = 4 ; TAB3 set tag to " minor " ; TAB3 break ; TAB1 call next_permutation ( s , s + 3 ) and go to the start of the loop ; TAB1 print tag ;	map < string , int > f ; void init ( ) { f [ " C " ] = 0 ; f [ " C# " ] = 1 ; f [ " D " ] = 2 ; f [ " D# " ] = 3 ; f [ " E " ] = 4 ; f [ " F " ] = 5 ; f [ " F# " ] = 6 ; f [ " G " ] = 7 ; f [ " G# " ] = 8 ; f [ " A " ] = 9 ; f [ " B " ] = 10 ; f [ " H " ] = 11 ; } int main ( ) { init ( ) ; string s [ 3 ] ; cin >> s [ 0 ] >> s [ 1 ] >> s [ 2 ] ; sort ( s , s + 3 ) ; string tag = " strange " ; do { int a = f [ s [ 1 ] ] - f [ s [ 0 ] ] ; int b = f [ s [ 2 ] ] - f [ s [ 1 ] ] ; if ( a < 0 ) a += 12 ; if ( b < 0 ) b += 12 ; if ( a == 4 && b == 3 ) { tag = " major " ; break ; } else if ( a == 3 && b == 4 ) { tag = " minor " ; break ; } } while ( next_permutation ( s , s + 3 ) ) ; cout << tag << endl ; return 0 ; }
TAB1 integer as n ; TAB1 read n ; TAB1 integer as p [ n ] ; TAB1 create integer vector of v [ n ] ; TAB1 set p [ 0 ] to - 1 ; TAB1 for i = 1 to less than n do the following ; TAB2 read p [ i ] ; TAB2 add new element i to end of vector v [ p [ i ] - 1 ] ; TAB2 add new element p [ i ] - 1 to end of vector v [ i ] ; TAB1 create integer vector of ans ; TAB1 add new element n to end of vector ans ; TAB1 integer as cur = n ; TAB1 if cur is not equal to 1 then do the following ; TAB2 set cur to p [ cur - 1 ] ; TAB2 add new element cur to end of vector ans ; TAB1 for i = ans . size ( ) - 1 to greater than or equal to 0 do the following ; TAB2 output ans [ i ] ; TAB2 if i is not equal to 0 then print space ; TAB1 output end line ;	int main ( ) { int n ; cin >> n ; int p [ n ] ; vector < int > v [ n ] ; p [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { cin >> p [ i ] ; v [ p [ i ] - 1 ] . push_back ( i ) ; v [ i ] . push_back ( p [ i ] - 1 ) ; } vector < int > ans ; ans . push_back ( n ) ; int cur = n ; while ( cur != 1 ) { cur = p [ cur - 1 ] ; ans . push_back ( cur ) ; } for ( int i = ans . size ( ) - 1 ; i >= 0 ; i -- ) { cout << ans [ i ] ; if ( i != 0 ) { cout << "   " ; } } cout << endl ; return 0 ; }
TAB0 convert_str is a int function with string argument str ; TAB1 create new integer x ; TAB1 create new stringstream ss with the size = size of str ; TAB1 read str to ss ; TAB1 print ss to x ; TAB1 return x ; TAB0 convert_int is a string function with int argument x ; TAB1 create new stringstream ss ; TAB1 put x into ss ; TAB1 return ss converted to string ; TAB1 declare string variable called str ; TAB1 read str from the user input ; TAB1 left and right are new strings = " " ; TAB1 increase left by str [ 0 ] ; TAB1 change left to left + str [ 1 ] ; TAB1 increase right by str [ 3 ] ; TAB1 increase right by str [ 4 ] ; TAB1 declare new string psg = left ; TAB1 reverse psg ; TAB1 if convert_str ( right ) is less than convert_str ( psg ) ; TAB2 declare new integer variable temp with value = the result of convert_str ( left ) ; TAB2 if temp < = 8 and temp > = 5 ; TAB3 print " 10 : 01 " ; TAB2 else if temp < = 19 and temp > = 15 ; TAB3 print " 20 : 02 " ; TAB2 else ; TAB3 print left , ' : ' and psg ; TAB1 else ; TAB2 if left is " 23 " ; TAB3 print " 00 : 00 " to the standard output ; TAB2 else ; TAB3 create new integer temp ; TAB3 assign the result of convert_str ( left ) to temp ; TAB3 if temp < = 8 and temp > = 5 ; TAB4 change temp to 10 ; TAB3 else if temp < = 19 and temp > = 15 ; TAB4 set temp to 20 ; TAB3 else ; TAB4 increment temp by one ; TAB3 change left to the result of the call to convert_int ( temp ) ; TAB3 if length of left is equal to 1 ; TAB4 create string cat = " 0 " ; TAB4 append left to cat ; TAB4 change left to cat ; TAB3 set right to left ; TAB3 reverse right ; TAB3 print left , ' : ' and right to the standard output ;	int convert_str ( string str ) { int x ; stringstream ss ( str ) ; ss << str ; ss >> x ; return x ; } string convert_int ( int x ) { stringstream ss ; ss << x ; return ss . str ( ) ; } int main ( ) { string str ; cin >> str ; string left = "  " , right = "  " ; left += str [ 0 ] ; left += str [ 1 ] ; right += str [ 3 ] ; right += str [ 4 ] ; string psg = left ; reverse ( psg . begin ( ) , psg . end ( ) ) ; if ( convert_str ( right ) < convert_str ( psg ) ) { int temp = convert_str ( left ) ; if ( temp <= 8 && temp >= 5 ) cout << " 10:01 " << endl ; else if ( temp <= 19 && temp >= 15 ) cout << " 20:02 " << endl ; else cout << left << ' : ' << psg << endl ; } else { if ( left == " 23 " ) cout << " 00:00 " << endl ; else { int temp ; temp = convert_str ( left ) ; if ( temp <= 8 && temp >= 5 ) temp = 10 ; else if ( temp <= 19 && temp >= 15 ) temp = 20 ; else temp ++ ; left = convert_int ( temp ) ; if ( left . length ( ) == 1 ) { string cat = " 0 " ; cat += left ; left = cat ; } right = left ; reverse ( right . begin ( ) , right . end ( ) ) ; cout << left << ' : ' << right << endl ; } } return 0 ; }
TAB1 d , l , a , b = double ; TAB1 read d , l , a , b ; TAB1 print ( with 6 decimal digits ) ( l - d ) / ( a + b ) ;	int main ( ) { double d , l , a , b ; cin >> d >> l >> a >> b ; cout << fixed << setprecision ( 6 ) << ( l - d ) / ( a + b ) << endl ; }
TAB0 let N be const integer with N = 1e5 + 5 ; TAB0 let n , d be integers and x an array of integers of size N ; TAB0 let ans be long long ; TAB1 read n and d ; TAB1 for i = 0 to n exclusive and p = 0 ; TAB2 read x [ i ] ; TAB2 while x [ i ] - x [ p ] is greater than d , increment p by 1 ; TAB2 update ans to ans + ( i - p - 1LL ) * ( i - p ) / 2 ; TAB1 print out ans with newline ;	const int N = 1e5 + 5 ; int n , d , x [ N ] ; long long ans ; int main ( ) { cin >> n >> d ; for ( int i = 0 , p = 0 ; i < n ; i ++ ) { cin >> x [ i ] ; while ( x [ i ] - x [ p ] > d ) p ++ ; ans += ( i - p - 1LL ) * ( i - p ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB1 make string Sentence ; TAB1 read Sentence ; TAB1 make ints beforeP = 0 , afterP = 0 , and after = 0 ; TAB1 let bool equal = true ; TAB1 make bool Plus = true ; TAB1 for i = 0 while Sentence [ i ] is not equal to ' \ 0 ' ; TAB2 if equal is true ; TAB3 if Sentence [ i ] is equal to ' | ' and Plus is true ; TAB4 increment beforeP ; TAB3 else if Sentence [ i ] equals ' | ' ; TAB4 add 1 to afterP ; TAB3 if Sentence [ i + 1 ] is equal to ' + ' , set Plus to false ; TAB2 else do ; TAB3 if Sentence [ i ] is equal to ' | ' , increment after ; TAB2 add 1 to i ; TAB2 if Sentence [ i ] is equal to ' = ' , set equal to false ; TAB1 if abs ( after - ( beforeP + afterP ) is equal to 2 ; TAB2 if after is greater than ( beforeP + afterP ) ; TAB3 print " | " ; TAB3 for i = 0 while Sentence [ i + 1 ] is not ' \ 0 ' , show Sentence [ i ] ; TAB2 otherwise ; TAB3 if beforeP is equal to 1 ; TAB4 for i = 0 while Sentence [ i ] is not equal to ' \ 0 ' ; TAB5 show Sentence [ i ] ; TAB5 if Sentence [ i ] is equal to ' + ' , add 1 to i ; TAB3 otherwise do ; TAB4 for i = 1 while Sentence [ i ] is not ' \ 0 ' , show Sentence [ i ] ; TAB3 display " | " ; TAB1 else if after is equal to ( beforeP + after ) ; TAB2 show Sentence ; TAB1 else ; TAB2 print " Impossible " ; TAB1 print new line ;	int main ( ) { string Sentence ; cin >> Sentence ; int beforeP = 0 , afterP = 0 , after = 0 ; bool equal = true ; bool Plus = true ; for ( int i = 0 ; Sentence [ i ] != ' \0 ' ; ) { if ( equal ) { if ( Sentence [ i ] == ' | ' && Plus ) beforeP ++ ; else if ( Sentence [ i ] == ' | ' ) { afterP ++ ; } if ( Sentence [ i + 1 ] == ' + ' ) Plus = false ; } else { if ( Sentence [ i ] == ' | ' ) after ++ ; } i ++ ; if ( Sentence [ i ] == ' = ' ) equal = false ; } if ( abs ( after - ( beforeP + afterP ) ) == 2 ) { if ( after > ( beforeP + afterP ) ) { cout << " | " ; for ( int i = 0 ; Sentence [ i + 1 ] != ' \0 ' ; i ++ ) cout << Sentence [ i ] ; } else { if ( beforeP == 1 ) { for ( int i = 0 ; Sentence [ i ] != ' \0 ' ; i ++ ) { cout << Sentence [ i ] ; if ( Sentence [ i ] == ' + ' ) i ++ ; } } else { for ( int i = 1 ; Sentence [ i ] != ' \0 ' ; i ++ ) { cout << Sentence [ i ] ; } } cout << " | " ; } } else if ( after == ( beforeP + afterP ) ) { cout << Sentence ; } else { cout << " Impossible " ; } cout << endl ; return 0 ; }
TAB0 create long long t , s , x ; TAB1 read t , s , x ; TAB1 if x < t ; TAB2 print NO and a new line ; TAB1 else if x - 1 = t ; TAB2 print NO and a new line ; TAB1 else if ( x - t ) % s = 0 or ( x - t ) % s = 1 ; TAB2 print YES and a newline ; TAB1 else ; TAB2 print NO and a newline ;	long long t , s , x ; int main ( ) { cin >> t >> s >> x ; if ( x < t ) cout << " NO\n " ; else if ( x - 1 == t ) cout << " NO\n " ; else if ( ( x - t ) % s == 0 || ( x - t ) % s == 1 ) cout << " YES\n " ; else cout << " NO\n " ; }
TAB0 in the function to_num which takes a string s and returns an integer ; TAB1 if size of s is greater than or equal to 4 ; TAB2 if s . substr ( s . size ( ) - 4 ) = " lios " then return 0 ; TAB1 if size of s > = 5 ; TAB2 if s . substr ( s . size ( ) - 5 ) = " liala " then return 1 ; TAB1 if size of s > = 3 ; TAB2 if s . substr ( s . size ( ) - 3 ) = " etr " then return 2 ; TAB1 if size of s > = 4 ; TAB2 if s . substr ( s . size ( ) - 4 ) = " etra " then return 3 ; TAB1 if size of s > = 6 ; TAB2 if s . substr ( s . size ( ) - 6 ) = " initis " then return 4 ; TAB1 if size of s > = 6 ; TAB2 if s . substr ( s . size ( ) - 6 ) = " inites " then return 5 ; TAB1 return - 1 ; TAB0 in the function islegal which takes a integer vector ans and returns a boolean ; TAB1 if ans [ 0 ] % 2 is equal to 0 ; TAB2 for i = 1 to size of ans exclusive ; TAB3 if ans [ i ] % 2 is not equal to 0 then return false ; TAB1 else do the following ; TAB2 for i = 1 to size of ans exclusive ; TAB3 if ans [ i ] is equal to - 1 then return false ; TAB3 if ans [ i ] % 2 = 0 then return false ; TAB1 return true ; TAB0 in the function isok which takes an integer vector ans and returns a boolean ; TAB1 create a boolean f = false ; TAB1 for i = 0 to size of ans exclusive ; TAB2 if ans [ i ] / 2 is equal to 0 and f is false ; TAB3 set f to true ; TAB3 continue ; TAB2 if f is false ; TAB3 if ans [ i ] / 2 is not equal to 0 then return false ; TAB2 else do the following ; TAB3 if ans [ i ] / 2 is not equal to 2 then return false ; TAB1 if f is false then return false ; TAB1 return true ; TAB1 c = array of chars of size 100010 ; TAB1 s = string ; TAB1 res = vector of string ; TAB1 ans = vector of integer ; TAB1 create an integer pos = 0 ; TAB1 read c ; TAB1 set s = c ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] is empty ; TAB3 add s . substr ( pos , i - pos ) to the end of res ; TAB3 set pos to i + 1 ; TAB1 add s . substr ( pos ) to end of res ; TAB1 for i = 0 to size of res exclusive add to_num ( res [ i ] to end of ans ; TAB1 if size of ans is equal to 1 and asn [ 0 ] > = 0 ; TAB2 print YES ; TAB1 if islegal ( ans ) is true ; TAB2 if isok ( ans ) is true ; TAB3 print YES ; TAB2 else do the following ; TAB3 print NO ; TAB1 else do the following ; TAB2 print NO ;	int to_num ( string s ) { if ( s . size ( ) >= 4 ) { if ( s . substr ( s . size ( ) - 4 ) == " lios " ) return 0 ; } if ( s . size ( ) >= 5 ) { if ( s . substr ( s . size ( ) - 5 ) == " liala " ) return 1 ; } if ( s . size ( ) >= 3 ) { if ( s . substr ( s . size ( ) - 3 ) == " etr " ) return 2 ; } if ( s . size ( ) >= 4 ) { if ( s . substr ( s . size ( ) - 4 ) == " etra " ) return 3 ; } if ( s . size ( ) >= 6 ) { if ( s . substr ( s . size ( ) - 6 ) == " initis " ) return 4 ; } if ( s . size ( ) >= 6 ) { if ( s . substr ( s . size ( ) - 6 ) == " inites " ) return 5 ; } return - 1 ; } bool islegal ( vector < int > ans ) { if ( ans [ 0 ] % 2 == 0 ) { for ( int i = 1 ; i < ans . size ( ) ; i ++ ) if ( ans [ i ] % 2 != 0 ) return false ; } else { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] == - 1 ) return false ; if ( ans [ i ] % 2 == 0 ) return false ; } } return true ; } bool isok ( vector < int > ans ) { bool f = false ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ( ans [ i ] / 2 ) == 1 && ! f ) { f = true ; continue ; } if ( ! f ) { if ( ans [ i ] / 2 != 0 ) return false ; } else { if ( ans [ i ] / 2 != 2 ) return false ; } } if ( ! f ) { return false ; } return true ; } int main ( ) { char c [ 100010 ] ; string s ; vector < string > res ; vector < int > ans ; int pos = 0 ; gets ( c ) ; s = c ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( s [ i ] == '   ' ) { res . push_back ( s . substr ( pos , i - pos ) ) ; pos = i + 1 ; } res . push_back ( s . substr ( pos ) ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) ans . push_back ( to_num ( res [ i ] ) ) ; if ( ans . size ( ) == 1 && ans [ 0 ] >= 0 ) { puts ( " YES " ) ; return 0 ; } if ( islegal ( ans ) ) { if ( isok ( ans ) ) puts ( " YES " ) ; else puts ( " NO " ) ; } else puts ( " NO " ) ; return 0 ; }
TAB0 let rotate be a function that accepts string curr and returns a string value ; TAB1 let ans be a string ; TAB1 increment ans by curr [ 2 ] ; TAB1 increment ans by curr [ 0 ] ; TAB1 increment ans by curr [ 3 ] ; TAB1 increment ans by curr [ 1 ] ; TAB1 return the value of ans ; TAB1 create a set of strings by name dict ; TAB1 let ans , n be integers with ans = 0 ; TAB1 read n ; TAB1 let temp be a string ; TAB1 while n is decremented by 1 ; TAB2 let curr be a string ; TAB2 read curr , temp ; TAB2 increment curr by temp ; TAB2 read temp ; TAB2 if dict . find ( curr ) equals dict . end ( ) ; TAB3 insert curr into dict ; TAB3 for i = 0 to 4 exclusive ; TAB4 curr is equal to rotate ( curr ) ; TAB4 insert curr into dict ; TAB3 increment ans by 1 ; TAB1 print ans and newline ;	string rotate ( string curr ) { string ans ; ans += curr [ 2 ] ; ans += curr [ 0 ] ; ans += curr [ 3 ] ; ans += curr [ 1 ] ; return ans ; } int main ( ) { set < string > dict ; int ans = 0 , n ; cin >> n ; string temp ; while ( n -- ) { string curr ; cin >> curr >> temp ; curr += temp ; cin >> temp ; if ( dict . find ( curr ) == dict . end ( ) ) { dict . insert ( curr ) ; for ( int i = 0 ; i < 4 ; i ++ ) { curr = rotate ( curr ) ; dict . insert ( curr ) ; } ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 declare integer array dp size 26 by 26 ; TAB0 declare maxi with integer address a , integer a as arguments , returning void ; TAB1 let a be maximum of a and b ; TAB1 declare integer n ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 declare string s ; TAB2 read s ; TAB2 declare integers first = s [ 0 ] - ' a ' , last = s [ size of s - 1 ] - ' a ' ; TAB2 for j = 0 to 26 exclusive ; TAB3 if dp [ j ] [ first ] is true , run maxi with dp [ j ] [ last ] , size of s + dp [ j ] [ first ] as arguments ; TAB2 run maxi with dp [ first ] [ last ] , size of s as arguments ; TAB1 declare integer ans = 0 ; TAB1 for i = 0 to 26 exclusive , run maxi with ans , dp [ i ] [ i ] as arguments ; TAB1 print ans and " \ n " ;	int dp [ 26 ] [ 26 ] ; void maxi ( int & a , int b ) { a = max ( a , b ) ; } int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { string s ; cin >> s ; int first = s [ 0 ] - ' a ' , last = s [ s . size ( ) - 1 ] - ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( dp [ j ] [ first ] ) maxi ( dp [ j ] [ last ] , s . size ( ) + dp [ j ] [ first ] ) ; } maxi ( dp [ first ] [ last ] , s . size ( ) ) ; } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { maxi ( ans , dp [ i ] [ i ] ) ; } cout << ans << " \n " ; }
TAB1 create strings s1 , s2 ; TAB1 read s1 read s2 ; TAB1 create integers count , len1 , len2 , len , b1 , b2 with count = 0 , len1 = size of s1 , len2 = size of s2 ; TAB1 set len to len1 if len1 is less than len2 , else len2 ; TAB1 create characters a1 , a2 ; TAB1 for i = 0 to len exclusive ; TAB2 if character at position i in s1 is not character at position i in s2 ; TAB3 increment count ; TAB3 if count is 1 , set a1 to character at position i in s1 , set b1 to i ; TAB3 if count is 2 , set a2 to character at position i in s1 , set b2 to i ; TAB3 if count is 2 ; TAB4 set character at position b1 in s1 to a2 ; TAB4 set character at position b2 in s1 to a1 ; TAB1 if count is not 2 or s1 is not s2 ; TAB2 print " NO " print newline ; TAB1 else ; TAB2 print " YES " print newline ;	int main ( ) { string s1 , s2 ; cin >> s1 >> s2 ; int count = 0 , len1 = s1 . size ( ) , len2 = s2 . size ( ) , len , b1 , b2 ; len = ( len1 < len2 ) ? len1 : len2 ; char a1 , a2 ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 . at ( i ) != s2 . at ( i ) ) { count ++ ; if ( count == 1 ) { a1 = s1 . at ( i ) , b1 = i ; } if ( count == 2 ) { a2 = s1 . at ( i ) , b2 = i ; } if ( count == 2 ) { s1 . at ( b1 ) = a2 ; s1 . at ( b2 ) = a1 ; } } if ( count != 2 || s1 != s2 ) cout << " NO " << endl ; else cout << " YES " << endl ; }
TAB0 declare vector of long longs called v ; TAB0 fun is a void function with long long argument x ; TAB1 push x to the v ; TAB1 if x is greater than 1e9 , return ; TAB1 call fun ( of * 10 + 4 ; TAB1 call function fun with an argument = x * 10 + 7 ; TAB1 call fun ( 4 ) ; TAB1 call fun ( 7 ) ; TAB1 sort v ; TAB1 declare new int variables l , r and cur where cur = 0 ; TAB1 declare long long variable res = 0 ; TAB1 read from the input to l and r ; TAB1 for integer i = 0 to length of v exclusive ; TAB2 if v [ i ] > = l ; TAB3 change cur to i ; TAB3 stop the loop ; TAB1 start for loop from l = to r inclusive ; TAB2 if v [ cur ] is less than l , increment cur ; TAB2 add v [ cur ] to res ; TAB1 print res ;	vector < long long > v ; void fun ( long long x ) { v . push_back ( x ) ; if ( x > 1e9 ) return ; fun ( x * 10 + 4 ) ; fun ( x * 10 + 7 ) ; } int main ( ) { fun ( 4 ) ; fun ( 7 ) ; sort ( v . begin ( ) , v . end ( ) ) ; int l , r , cur = 0 ; long long res = 0 ; cin >> l >> r ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] >= l ) { cur = i ; break ; } } for ( l ; l <= r ; l ++ ) { if ( v [ cur ] < l ) { cur ++ ; } res += v [ cur ] ; } cout << res << endl ; return 0 ; }
TAB1 declare map from string to long long cnt ; TAB1 let cnt [ " C " ] be 1 ; TAB1 let cnt [ " C # " ] be 2 ; TAB1 let cnt [ " D " ] be 3 ; TAB1 let cnt [ " D # " ] be 4 ; TAB1 let cnt [ " E " ] be 5 ; TAB1 let cnt [ " F " ] be 6 ; TAB1 let cnt [ " F # " ] be 7 ; TAB1 let cnt [ " G " ] be 8 ; TAB1 let cnt [ " G # " ] be 9 ; TAB1 let cnt [ " A " ] be 10 ; TAB1 let cnt [ " B " ] be 11 ; TAB1 let cnt [ " H " ] be 12 ; TAB1 declare strings input1 , input2 , input3 ; TAB1 read input1 , input2 , input3 ; TAB1 declare long long vector v ; TAB1 add cnt [ input1 ] to end of v ; TAB1 add cnt [ input2 ] to end of v ; TAB1 add cnt [ input3 ] to end of v ; TAB1 sort from beginning of v to end of v ; TAB1 if v [ 1 ] - v [ 0 ] is 4 and v [ 2 ] - v [ 1 ] is 3 ; TAB2 print " major \ n " ; TAB1 else if v [ 2 ] - v [ 1 ] is 4 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ] ; TAB2 print " major \ n " ; TAB1 else if v [ 1 ] - v [ 0 ] is 3 and ( v [ 2 ] + 4 ) % 12 is v [ 0 ] ; TAB2 print " major \ n " ; TAB1 else if ( v [ 1 ] - v [ 0 ] ) * 2 is 4 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ] ; TAB2 print " major \ n " ; TAB1 else if ( v [ 2 ] + 4 ) % 12 is v [ 0 ] and ( v [ 2 ] - v [ 1 ] ) * 2 is 3 ; TAB2 print " major \ n " ; TAB1 else if ( v [ 2 ] - v [ 1 ] ) * 2 is 4 and ( v [ 1 ] - v [ 0 ] ) * 2 is 3 ; TAB2 print " major \ n " ; TAB1 else if v [ 1 ] - v [ 0 ] is 3 and v [ 2 ] - v [ 1 ] is 4 ; TAB2 print " minor \ n " ; TAB1 else if v [ 2 ] - v [ 1 ] is 3 and ( v [ 2 ] + 4 ) % 12 is v [ 0 ] ; TAB2 print " minor \ n " ; TAB1 else if v [ 1 ] - v [ 0 ] is 4 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ] ; TAB2 print " minor \ n " ; TAB1 else if ( v [ 1 ] - v [ 0 ] ) * 2 is 3 and ( v [ 2 ] + 3 ) % 12 is v [ 0 ] ; TAB2 print " minor \ n " ; TAB1 else if ( v [ 2 ] + 3 ) % 12 is v [ 0 ] and ( v [ 2 ] - v [ 1 ] ) * 2 is 4 ; TAB2 print " minor \ n " ; TAB1 else if ( v [ 2 ] - v [ 1 ] ) * 2 is 3 and ( v [ 1 ] - v [ 0 ] ) * 2 is 4 ; TAB2 print " minor \ n " ; TAB1 else ; TAB2 print " strange \ n " ;	int main ( ) { map < string , long long > cnt ; cnt [ " C " ] = 1 ; cnt [ " C# " ] = 2 ; cnt [ " D " ] = 3 ; cnt [ " D# " ] = 4 ; cnt [ " E " ] = 5 ; cnt [ " F " ] = 6 ; cnt [ " F# " ] = 7 ; cnt [ " G " ] = 8 ; cnt [ " G# " ] = 9 ; cnt [ " A " ] = 10 ; cnt [ " B " ] = 11 ; cnt [ " H " ] = 12 ; string input1 , input2 , input3 ; cin >> input1 >> input2 >> input3 ; vector < long long > v ; v . push_back ( cnt [ input1 ] ) ; v . push_back ( cnt [ input2 ] ) ; v . push_back ( cnt [ input3 ] ) ; sort ( v . begin ( ) , v . end ( ) ) ; if ( v [ 1 ] - v [ 0 ] == 4 && v [ 2 ] - v [ 1 ] == 3 ) { cout << " major\n " ; } else if ( v [ 2 ] - v [ 1 ] == 4 && ( v [ 2 ] + 3 ) % 12 == v [ 0 ] ) { cout << " major\n " ; } else if ( v [ 1 ] - v [ 0 ] == 3 && ( v [ 2 ] + 4 ) % 12 == v [ 0 ] ) { cout << " major\n " ; } else if ( ( v [ 1 ] - v [ 0 ] ) * 2 == 4 && ( v [ 2 ] + 3 ) % 12 == v [ 0 ] ) { cout << " major\n " ; } else if ( ( v [ 2 ] + 4 ) % 12 == v [ 0 ] && ( v [ 2 ] - v [ 1 ] ) * 2 == 3 ) { cout << " major\n " ; } else if ( ( v [ 2 ] - v [ 1 ] ) * 2 == 4 && ( v [ 1 ] - v [ 0 ] ) * 2 == 3 ) { cout << " major\n " ; } else if ( v [ 1 ] - v [ 0 ] == 3 && v [ 2 ] - v [ 1 ] == 4 ) { cout << " minor\n " ; } else if ( v [ 2 ] - v [ 1 ] == 3 && ( v [ 2 ] + 4 ) % 12 == v [ 0 ] ) { cout << " minor\n " ; } else if ( v [ 1 ] - v [ 0 ] == 4 && ( v [ 2 ] + 3 ) % 12 == v [ 0 ] ) { cout << " minor\n " ; } else if ( ( v [ 1 ] - v [ 0 ] ) * 2 == 3 && ( v [ 2 ] + 3 ) % 12 == v [ 0 ] ) { cout << " minor\n " ; } else if ( ( v [ 2 ] + 3 ) % 12 == v [ 0 ] && ( v [ 2 ] - v [ 1 ] ) * 2 == 4 ) { cout << " minor\n " ; } else if ( ( v [ 2 ] - v [ 1 ] ) * 2 == 3 && ( v [ 1 ] - v [ 0 ] ) * 2 == 4 ) { cout << " minor\n " ; } else cout << " strange\n " ; return 0 ; }
TAB0 create long long int mod = 1000000007 ; TAB0 create long long ints l and r ; TAB0 create long long int array p with 18 elements ; TAB0 create long long int array ct with 19 elements ; TAB0 in the function init ; TAB1 assign 1 to p [ 0 ] ; TAB1 loop i from 1 to 17 inclusive , set p [ i ] to 10ll * p [ i - 1 ] ; TAB1 set ct [ 1 ] to 9 ; TAB1 set ct [ 2 ] to 9 ; TAB1 for integer i = 3 to 18 inclusive , set ct [ i ] to 9 * p [ i - 2 ] ; TAB0 long long int function calc with long long int argument num ; TAB1 declare vector of ints digits ; TAB1 declare long long int n = num ; TAB1 while num ! = 0 ; TAB2 push num % 10 to the end of digits ; TAB2 divide num by 10 ; TAB1 if size of digits = 1 , return n - 1 ; TAB1 declare integer l = length of digits ; TAB1 create long long int ans = 0 ; TAB1 for i from l - 1 to 0 inclusive decrementing i ; TAB2 if i = l - 1 ; TAB3 if digits [ i ] is greater than 1 , add ( digits [ i ] - 1 ) * ( p [ l - 2 ] ) to ans ; TAB2 else if i = 0 ; TAB3 if digits [ l - 1 ] is less than digits [ 0 ] , add 1 to ans ; TAB2 else if digits [ i ] > 0 ; TAB3 increase ans by ( digits [ i ] ) * ( p [ i - 1 ] ) ; TAB1 for integer i = 0 to l exclusive , add ct [ i ] to ans ; TAB1 return ans ; TAB1 call init ( ) ; TAB1 read l and r ; TAB1 print calc ( r + 1 ) - calc ( l ) ;	long long int mod = 1000000007 ; long long int l , r ; long long int p [ 18 ] ; long long int ct [ 19 ] ; void init ( ) { p [ 0 ] = 1 ; for ( int i = 1 ; i <= 17 ; i ++ ) { p [ i ] = 10ll * p [ i - 1 ] ; } ct [ 1 ] = 9 ; ct [ 2 ] = 9 ; for ( int i = 3 ; i <= 18 ; i ++ ) { ct [ i ] = 9 * p [ i - 2 ] ; } } long long int calc ( long long int num ) { vector < int > digits ; long long int n = num ; while ( num ) { digits . push_back ( num % 10 ) ; num /= 10 ; } if ( digits . size ( ) == 1 ) { return n - 1 ; } int l = digits . size ( ) ; long long int ans = 0 ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( i == l - 1 ) { if ( digits [ i ] > 1 ) { ans += ( digits [ i ] - 1 ) * ( p [ l - 2 ] ) ; } } else if ( i == 0 ) { if ( digits [ l - 1 ] < digits [ 0 ] ) { ans += ( 1 ) ; } } else if ( digits [ i ] > 0 ) { ans += ( digits [ i ] ) * ( p [ i - 1 ] ) ; } } for ( int i = 0 ; i < l ; i ++ ) { ans += ct [ i ] ; } return ans ; } int main ( ) { init ( ) ; cin >> l >> r ; cout << calc ( r + 1 ) - calc ( l ) << endl ; return 0 ; }
TAB0 N is a constant integer set to 105 ; TAB0 let is be a boolean array of sizes N and N ; TAB0 in function f with parameter integer x and return integer ; TAB1 return ( x * ( x - 1 ) * ( x - 2 ) ) / 6 ; TAB1 let k be an integer ; TAB1 input k ; TAB1 let n be an integer set to 1 ; TAB1 while call f with n + 1 is at most k ; TAB1 subtract call f with n from k ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if i isn ' t j , set is [ i ] [ j ] to true ; TAB1 let s be an integer with s = n ; TAB1 while k is positive ; TAB2 increment s ; TAB2 for i = 1 to n inclusive ; TAB3 if k is at least i - 1 ; TAB4 subtract i - 1 from k ; TAB4 assign true to is [ s ] [ i ] ; TAB4 assign true to is [ i ] [ s ] ; TAB1 display s ; TAB1 for i = 1 to s inclusive ; TAB2 for j = 1 to s inclusive , display is [ i ] [ j ] ; TAB2 display newline ;	const int N = 105 ; bool is [ N ] [ N ] ; int f ( int x ) { return ( x * ( x - 1 ) * ( x - 2 ) ) / 6 ; } int main ( ) { int k ; cin >> k ; int n = 1 ; while ( f ( n + 1 ) <= k ) { n ++ ; } k -= f ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i != j ) is [ i ] [ j ] = true ; } } int s = n ; while ( k > 0 ) { s ++ ; for ( int i = 1 ; i <= n ; i ++ ) { if ( k >= i - 1 ) { k -= i - 1 ; is [ s ] [ i ] = true ; is [ i ] [ s ] = true ; } } } cout << s << " \n " ; for ( int i = 1 ; i <= s ; i ++ ) { for ( int j = 1 ; j <= s ; j ++ ) { cout << is [ i ] [ j ] ; } cout << " \n " ; } return 0 ; }
TAB1 s = array of characters of size 1000 ; TAB1 read s ; TAB1 create integer n = length of s ; TAB1 if n < 3 or ( n = 3 and strcmp ( s , " 127 " ) < = 0 ) ; TAB2 print byte and newline ; TAB1 else if n < 5 or ( n = 5 and strcmp ( s , " 32767 " ) < = 0 ) ; TAB2 print short ; TAB1 else if n < 10 or ( n = 10 and strcmp ( s , " 2147483647 " ) < = 0 ) ; TAB2 print int ; TAB1 else if n < 19 or ( n = 19 and strcmp ( s , " 9223372036854775807 " ) < = 0 ) ; TAB2 print long and a new line ; TAB1 else do the following ; TAB2 print BigInteger ;	int main ( ) { char s [ 1000 ] ; cin >> s ; int n = strlen ( s ) ; if ( n < 3 or ( n == 3 and strcmp ( s , " 127 " ) <= 0 ) ) cout << " byte " << endl ; else if ( n < 5 or ( n == 5 and strcmp ( s , " 32767 " ) <= 0 ) ) cout << " short " << endl ; else if ( n < 10 or ( n == 10 and strcmp ( s , " 2147483647 " ) <= 0 ) ) cout << " int " << endl ; else if ( n < 19 or ( n == 19 and strcmp ( s , " 9223372036854775807 " ) <= 0 ) ) cout << " long " << endl ; else cout << " BigInteger " << endl ; return 0 ; }
TAB1 declare char array s with 200006 as length ; TAB1 declare int count , n , flag ; TAB1 while reading n ; TAB2 assign 0 to count ; TAB2 fill s with 0 ; TAB2 for i = 0 to n exclusive , read s [ i ] ; TAB2 define int i = 0 , j = n - 1 ; TAB2 while s [ i + + ] equals ' < ' , increment count ; TAB2 while s [ i - - ] equals ' > ' , increment count ; TAB2 print count ;	int main ( ) { char s [ 200006 ] ; int count , n , flag ; while ( cin >> n ) { count = 0 ; memset ( s , 0 , sizeof ( s ) ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; int i = 0 , j = n - 1 ; while ( s [ i ++ ] == ' < ' ) count ++ ; while ( s [ j -- ] == ' > ' ) count ++ ; cout << count << endl ; } }
TAB1 n is an integer ; TAB1 a is a string ; TAB1 b is a string ; TAB1 read a , b ; TAB1 map mp from string to integer ; TAB1 mp [ " monday " ] equals 1 ; TAB1 mp [ " tuesday " ] equals 2 ; TAB1 mp [ " wednesday " ] equals 3 ; TAB1 mp [ " thursday " ] equals 4 ; TAB1 mp [ " friday " ] equals 5 ; TAB1 mp [ " saturday " ] equals 6 ; TAB1 mp [ " sunday " ] equals 0 ; TAB1 let p1 equals mp [ a ] ; TAB1 let p2 equals mp [ b ] ; TAB1 if ( p1 + 30 ) % 7 equals p2 ; TAB2 put YES ; TAB1 if ( p1 + 28 ) % 7 equals p2 ; TAB2 put YES ; TAB1 if ( p1 + 31 ) % 7 equals p2 ; TAB2 put YES ; TAB1 print NO and endline ;	int main ( ) { int n ; string a ; string b ; cin >> a >> b ; map < string , int > mp ; mp [ " monday " ] = 1 ; mp [ " tuesday " ] = 2 ; mp [ " wednesday " ] = 3 ; mp [ " thursday " ] = 4 ; mp [ " friday " ] = 5 ; mp [ " saturday " ] = 6 ; mp [ " sunday " ] = 0 ; int p1 = mp [ a ] ; int p2 = mp [ b ] ; if ( ( p1 + 30 ) % 7 == p2 ) { puts ( " YES " ) ; return 0 ; } if ( ( p1 + 28 ) % 7 == p2 ) { puts ( " YES " ) ; return 0 ; } if ( ( p1 + 31 ) % 7 == p2 ) { puts ( " YES " ) ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB1 let s be a string ; TAB1 read s ; TAB1 let ac be integer 0 ; TAB1 for integer i = 0 to size of s exclusive , increase ac by s [ i ] ; TAB1 if ac equals s . size ( ) ; TAB2 s [ s . size ( ) - 1 ] equals ' z ' ; TAB1 else ; TAB2 astarted be integer 0 ; TAB2 for integer i = 0 to size of s exclusive ; TAB3 if astarted and s [ i ] equals ' a ' ; TAB3 if s [ i ] not equals ' a ' ; TAB4 astarted equals to 1 ; TAB4 decrease s [ i ] by 1 ; TAB1 print s and endline ; TAB0 pause ; TAB1 pause be integer ; TAB1 read pause ;	int main ( ) { string s ; cin >> s ; int ac = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { ac += s [ i ] == ' a ' ; } if ( ac == s . size ( ) ) { s [ s . size ( ) - 1 ] = ' z ' ; } else { int astarted = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( astarted && s [ i ] == ' a ' ) { break ; } if ( s [ i ] != ' a ' ) { astarted = 1 ; s [ i ] -- ; } } } cout << s << endl ; pause : int pause ; cin >> pause ; return 0 ; }
TAB0 create constant integer maxn with maxn = 110 ; TAB0 create integer array crush with size maxn ; TAB0 create integer n ; TAB0 create boolean array vis with size maxn ; TAB0 create boolean can with can = true ; TAB0 create long long d with d = 0 ; TAB0 create long long ans with ans = 1 ; TAB0 declare dfs with integers now , start as arguments , returning void ; TAB1 if now is start and vis [ start ] is true , return from function ; TAB1 if vis [ now ] is true ; TAB2 set can to false ; TAB2 return from function ; TAB1 set vis [ now ] to true ; TAB1 run dfs with crush [ now ] , start as arguments ; TAB1 increment d ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read crush [ i ] ; TAB1 set bytes from vis to size of vis to value 0 ; TAB1 for i = 1 to i is less than or equal to n and can is true , incrementing i ; TAB2 if not vis [ i ] ; TAB3 set d to 0 ; TAB3 run dfs with i , i as arguments ; TAB3 if d % 2 is 0 , set d to d / 2 ; TAB3 set ans to ans * d / result of run __gcd with ans , d as arguments ; TAB1 if can is true ; TAB2 print ans print newline ; TAB1 else ; TAB2 print " - 1 " print newline ;	const int maxn = 110 ; int crush [ maxn ] ; int n ; bool vis [ maxn ] ; bool can = true ; long long d = 0 ; long long ans = 1 ; void dfs ( int now , int start ) { if ( now == start && vis [ start ] ) { return ; } if ( vis [ now ] ) { can = false ; return ; } vis [ now ] = true ; dfs ( crush [ now ] , start ) ; d ++ ; } int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> crush [ i ] ; memset ( vis , 0 , sizeof vis ) ; for ( int i = 1 ; i <= n && can ; i ++ ) { if ( ! vis [ i ] ) { d = 0 ; dfs ( i , i ) ; if ( d % 2 == 0 ) { d /= 2 ; } ans = ans * d / __gcd ( ans , d ) ; } } if ( can ) { cout << ans << endl ; } else { cout << " -1 " << endl ; } return 0 ; }
TAB0 create long long ints l and r ; TAB0 make long long int vector s ; TAB0 let long long integer vector Next ; TAB0 declare fun taking in long long int num ; TAB1 if num is greater than r ; TAB2 append num to Next ; TAB2 return ; TAB1 if num is greater than or equal to 1 , append num to s ; TAB1 call fun ( num * 10 + 4 ) ; TAB1 call fun with argument num * 10 + 7 ; TAB1 read l and r ; TAB1 call fun ( 0 ) ; TAB1 sort s ; TAB1 sort vector Next ; TAB1 create long long int len = s . size ( ) ; TAB1 make long long int Left = 1 - 1 ; TAB1 let long long integer sum = 0 ; TAB1 for i = 0 to len exclusive ; TAB2 let long long integer num = ( s [ i ] - Left ) ; TAB2 add num * s [ i ] to sum ; TAB2 set Left = s [ i ] ; TAB1 if len is equal to 0 ; TAB2 set sum to sum + ( r - Left ) * Next [ 0 ] ; TAB1 else if s [ len - 1 ] is not equal to r ; TAB2 set sum to sum + ( r - Left ) * Next [ 0 ] ; TAB1 print sum ;	long long int l , r ; vector < long long int > s ; vector < long long int > Next ; void fun ( long long int num ) { if ( num > r ) { Next . push_back ( num ) ; return ; } if ( num >= l ) s . push_back ( num ) ; fun ( num * 10 + 4 ) ; fun ( num * 10 + 7 ) ; } int main ( ) { cin >> l >> r ; fun ( 0 ) ; sort ( s . begin ( ) , s . end ( ) ) ; sort ( Next . begin ( ) , Next . end ( ) ) ; long long int len = s . size ( ) ; long long int Left = l - 1 ; long long int sum = 0 ; for ( long long int i = 0 ; i < len ; i ++ ) { long long int num = ( s [ i ] - Left ) ; sum += num * s [ i ] ; Left = s [ i ] ; } if ( len == 0 ) { sum = sum + ( r - Left ) * Next [ 0 ] ; } else if ( s [ len - 1 ] != r ) { sum = sum + ( r - Left ) * Next [ 0 ] ; } cout << sum << " \n " ; }
TAB1 n , d = integers ; TAB1 read n and d ; TAB1 v = array of integers with length of 1000005 ; TAB1 for i = 0 to n exclusive ; TAB2 point = integer ; TAB2 read point ; TAB2 set v [ i ] to point ; TAB1 result = long long integer set to 0 ; TAB1 for right = 2 , left = 0 , right to n exclusive ; TAB2 while v [ right ] - v [ left ] > d , increment left by 1 ; TAB2 increment result by right - left * right - left - 1 / 2 ; TAB1 print result ;	int main ( ) { int n , d ; cin >> n >> d ; int v [ 1000005 ] ; for ( int i = 0 ; i < n ; i ++ ) { int point ; cin >> point ; v [ i ] = point ; } long long result = 0 ; for ( int right = 2 , left = 0 ; right < n ; right ++ ) { while ( v [ right ] - v [ left ] > d ) { left ++ ; } result += ( long long ) ( right - left ) * ( right - left - 1 ) / 2 ; } cout << result << endl ; return 0 ; }
TAB0 n , L , a are integers ; TAB1 read n , L , a ; TAB1 result is an unsigned integer set to 0 ; TAB1 prevbeg , prevlen are integers both set to 0 ; TAB1 for currcase = 0 to n exclusive ; TAB2 declare integers begin , length ; TAB2 read begin , length ; TAB2 if currcase isn ' t 0 ; TAB3 breaktime = integer = begin - ( prevbeg + prevlen ) ; TAB3 add floor ( breaktime / a ) to result ; TAB2 else ; TAB3 add floor ( begin / a ) to result ; TAB2 assign begin to prevbeg ; TAB2 assign length to prevlen ; TAB1 lastbreaktime = integer = L - ( prevbeg + prevlen ) ; TAB1 add floor ( lastbreaktime / a ) to result ; TAB1 output result ;	int n , L , a ; int main ( ) { cin >> n >> L >> a ; unsigned int result = 0 ; int prevbeg = 0 , prevlen = 0 ; for ( int currcase = 0 ; currcase < n ; ++ currcase ) { int begin , length ; cin >> begin >> length ; if ( currcase != 0 ) { int breaktime = begin - ( prevbeg + prevlen ) ; result += floor ( breaktime / a ) ; } else { result += floor ( begin / a ) ; } prevbeg = begin ; prevlen = length ; } int lastbreaktime = L - ( prevbeg + prevlen ) ; result += floor ( lastbreaktime / a ) ; cout << result << endl ; return 0 ; }
TAB0 let n , m be integers ; TAB0 lg = 2d array of boolean values with 111 rows and 111 columns respectively ; TAB0 a = 2d array of integers with 111 rows and 111 columns respectively ; TAB0 111th element in the boolean array v is equal to 0 ; TAB0 111th element in the boolean array zero is equal to 0 ; TAB0 let integer ex is equal to 0 ; TAB0 let dfs be a void function which accepts integer i ; TAB1 v [ i ] is equal to true ; TAB1 for j = 1 to n inclusive ; TAB2 if a [ i ] [ j ] and not v [ j ] , depth first search of j ; TAB1 read n , m ; TAB1 for i = 1 to n inclusive ; TAB2 let t be a integer ; TAB2 read t ; TAB2 if t is equal to 0 ; TAB3 zero [ i ] is equal to true ; TAB3 increment ex by 1 ; TAB2 while t is decremented by 1 ; TAB3 let c be a integer ; TAB3 read c ; TAB3 lg [ i ] [ c ] is equal to true ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if i is not equal to j ; TAB4 for k = 1 to m inclusive ; TAB5 if lg [ i ] [ k ] and lg [ j ] [ k ] , a [ i ] [ j ] is equal to 1 ; TAB1 let ans be a integer with ans = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if not v [ i ] and not zero [ i ] ; TAB3 depth first search of i ; TAB3 increment ans by 1 ; TAB1 decrement ans by 1 ; TAB1 if ans is less than 0 , ans is equal to 0 ; TAB1 print ans + ex and newline ;	int n , m ; bool lg [ 111 ] [ 111 ] ; int a [ 111 ] [ 111 ] ; bool v [ 111 ] = { 0 } ; bool zero [ 111 ] = { 0 } ; int ex = 0 ; void dfs ( int i ) { v [ i ] = true ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] && ! v [ j ] ) { dfs ( j ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { int t ; cin >> t ; if ( t == 0 ) { zero [ i ] = true ; ex ++ ; } while ( t -- ) { int c ; cin >> c ; lg [ i ] [ c ] = true ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i != j ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( lg [ i ] [ k ] && lg [ j ] [ k ] ) { a [ i ] [ j ] = 1 ; } } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! v [ i ] && ! zero [ i ] ) { dfs ( i ) ; ans ++ ; } } ans -- ; if ( ans < 0 ) ans = 0 ; cout << ans + ex << endl ; return 0 ; }
TAB0 create int array data of size 100005 , initialized to 0 ; TAB1 create int n ; TAB1 read n ; TAB1 print n / 2 ; TAB1 for i = 1 to n / 2 exclusive , print 2 , " " ; TAB1 if n is odd ; TAB2 print 3 ; TAB1 else ; TAB2 print 2 ;	int data [ 100005 ] = { 0 } ; int main ( ) { int n ; cin >> n ; cout << n / 2 << endl ; for ( int i = 1 ; i < n / 2 ; i ++ ) cout << 2 << "   " ; if ( n % 2 == 1 ) cout << 3 << endl ; else cout << 2 << endl ; }
TAB1 n = integer ; TAB1 myv = vector of integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 res = integer with res = 0 ; TAB2 for j = 0 to 3 ; TAB3 tmp = int ; TAB3 read tmp ; TAB3 res = res + tmp ; TAB2 append res in myv ; TAB1 tomas = integer with tomas = myv [ 0 ] ; TAB1 sort myv . begin ( ) and myv . end ( ) ; TAB1 reverse myv . begin ( ) and myv . end ( ) ; TAB1 for i = 0 to n exclusive ; TAB2 if ( tomas is myv [ i ] ) ; TAB3 print i + 1 ;	int main ( ) { int n ; vector < int > myv ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { int tmp ; cin >> tmp ; res += tmp ; } myv . push_back ( res ) ; } int tomas = myv [ 0 ] ; sort ( myv . begin ( ) , myv . end ( ) ) ; reverse ( myv . begin ( ) , myv . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tomas == myv [ i ] ) { cout << i + 1 << endl ; return 0 ; } } return 0 ; }
TAB0 s = string ; TAB1 n = int ; TAB1 sum = int ; TAB1 while reading n ; TAB2 read s ; TAB2 set sum to 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if s at i = ' < ' ; TAB4 increment sum ; TAB3 else ; TAB4 exit loop ; TAB2 for j = n - 1 to 0 inclusive ; TAB3 if s [ j ] = ' > ' ; TAB4 increment sum ; TAB3 else ; TAB4 exit loop ; TAB2 print sum ;	string s ; int main ( ) { int n ; int sum ; while ( cin >> n ) { cin >> s ; sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' < ' ) { sum ++ ; } else { break ; } } for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( s [ j ] == ' > ' ) { sum ++ ; } else { break ; } } cout << sum << endl ; } }
TAB0 declare double EPS = 1e - 8 ; TAB0 declare fast with no arguments , returning void ; TAB0 declare sortby with constant pairs from integer to integer addresses a , b , returning boolean ; TAB1 if first element of a is greater than or equal to first element of b and second element of a is greater than or equal to second element of b , return true from function ; TAB1 return false from function ; TAB0 declare area with integers x1 , y1 , x2 , y2 , x3 , y3 as arguments , returning double ; TAB1 return absolute value of ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 . 0 ) from function ; TAB0 declare gcd with integers a , b as arguments , returning integer ; TAB1 return a if b is 0 , else result of run gcd ( b , a % b ) ; TAB1 run fast ; TAB1 declare integers n , m , x , ans = 0 , z = 0 ; TAB1 read n and m ; TAB1 for i = 1 to n inclusive ; TAB2 read x ; TAB2 declare integer y ; TAB2 let y be x / m if x % m is 0 , else let y be x / m + 1 ; TAB2 if y is greater than or equal to z ; TAB3 let z be y ; TAB3 let ans be i ; TAB1 print ans and newline ;	const double EPS = 1e-8 ; void fast ( ) { } bool sortby ( const pair < int , int > & a , const pair < int , int > & b ) { if ( a . first >= b . first && a . second >= b . second ) return true ; return false ; } double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } int main ( ) { fast ( ) ; int n , m , x , ans = 0 , z = 0 ; cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x ; int y ; x % m == 0 ? y = x / m : y = x / m + 1 ; if ( y >= z ) { z = y ; ans = i ; } } cout << ans << endl ; return 0 ; }
TAB0 create const integer arrays dx with elements 1 , 0 , - 1 , 0 and dy with elements 0 , 1 , 0 , - 1 ; TAB0 bad = set of integers ; TAB0 let a be integer array with size 100010 ; TAB1 create ints n and k ; TAB1 read n and k ; TAB1 for i from 0 to n exclusive , read a [ i ] ; TAB1 sort a ; TAB1 declare int variable ans = 0 ; TAB1 for i = n - 1 to 0 inclusive counting down ; TAB2 if there is no a [ i ] in bad ; TAB3 increment ans by one ; TAB3 if a [ i ] % k = 0 , insert a [ i ] / k into bad ; TAB1 print ans ;	const int dx [ 4 ] = { 1 , 0 , - 1 , 0 } , dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; set < int > bad ; int a [ 100010 ] ; int main ( ) { int n , k ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n ) ; int ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( bad . find ( a [ i ] ) == bad . end ( ) ) { ans ++ ; if ( a [ i ] % k == 0 ) bad . insert ( a [ i ] / k ) ; } } cout << ans << endl ; return 0 ; }
TAB0 create int a ; TAB0 make string str ; TAB0 let int array sum of size 4005 ; TAB0 make long long array used of size 36005 ; TAB0 create long long int result = 0 ; TAB1 make ints ii and jj ; TAB1 created ints len and usedLen ; TAB1 read a and str ; TAB1 set len to str . size ( ) ; TAB1 for ii = 0 to len exclusive , set sum [ ii ] to sum [ ii ] + ( str [ ii ] - ' 0 ' ) ; TAB1 for ii = 0 to len exclusive ; TAB2 for jj = ( ii + 1 ) to len , increment used [ sum [ jj ] - sum [ ii ] ] ; TAB1 if a is not equal to 0 ; TAB2 set usedLen to min of a and 36000 ; TAB2 for ii = 1 to usedLen ; TAB3 if a modulo ii is 0 and a / ii is less than or equal to usedLen , add used [ ii ] * used [ a / ii ] to result ; TAB1 otherwise do ; TAB2 set result to ( len * len + ( len - used [ 0 ] ) ) * used [ 0 ] ; TAB1 print result ;	int a ; string str ; int sum [ 4005 ] ; long long used [ 36005 ] ; long long result = 0 ; int main ( ) { int ii , jj ; int len , usedLen ; cin >> a >> str ; len = str . size ( ) ; for ( ii = 0 ; ii < len ; ii ++ ) sum [ ii + 1 ] = sum [ ii ] + ( str [ ii ] - ' 0 ' ) ; for ( ii = 0 ; ii < len ; ii ++ ) { for ( jj = ( ii + 1 ) ; jj <= len ; jj ++ ) used [ sum [ jj ] - sum [ ii ] ] ++ ; } if ( a != 0 ) { usedLen = min ( a , 36000 ) ; for ( ii = 1 ; ii <= usedLen ; ii ++ ) { if ( ( ( a % ii ) == 0 ) && ( ( a / ii ) <= usedLen ) ) result += used [ ii ] * used [ a / ii ] ; } } else result = ( len * len + ( len - used [ 0 ] ) ) * used [ 0 ] ; cout << result << " \n " ; return 0 ; }
TAB0 create constant integer with name maxn = 2e6 + 7 ; TAB0 prime is a new array of booleans with maxn elements ; TAB0 in the function palindrome with string argument s that returns boolean ; TAB1 declare ints lo = 0 and hi = length of s - 1 ; TAB1 while lo < = hi ; TAB2 if s [ lo ] ! = s [ hi ] , return false ; increment lo and decrement hi in any case ; TAB1 return true ; TAB1 assign the new value = true to prime [ 1 ] ; TAB1 in a for loop , change i from 2 to maxn exclusive incrementing i ; TAB2 if prime [ i ] is false ; TAB3 start for loop from j = i + i to maxn exclusive adding i to j , and changing prime [ j ] to true on each iteration ; TAB1 declare new integer variables p and q ; TAB1 read variables p and q from the input ; TAB1 declare new int variables pi and rub = 0 ; TAB1 ans is a new integer variable = 0 ; TAB1 for integer i = 1 to maxn exclusive ; TAB2 declare string variable num with value " " ; TAB2 create integer x with value i ; TAB2 while x is not 0 ; TAB3 append x % 10 + ' 0 ' to num ; TAB3 change the value of x to x divided by 10 ; TAB2 if palindrome ( num ) is true , increment rub ; TAB2 if prime [ i ] is false , increment pi by one ; TAB2 if pi * q < = rub * p , change the value of ans to i ; TAB1 if ans is equal to 0 ; TAB2 print " Palindromic tree is better than splay tree " and ' \ n ' to the standard output ; TAB1 else ; TAB2 print ans and ' \ n ' to the standard output ;	const int maxn = 2e6 + 7 ; bool prime [ maxn ] ; bool palindrome ( string s ) { int lo = 0 , hi = s . size ( ) - 1 ; while ( lo <= hi ) { if ( s [ lo ++ ] != s [ hi -- ] ) return false ; } return true ; } int main ( ) { prime [ 1 ] = true ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i + i ; j < maxn ; j += i ) prime [ j ] = true ; } } int p , q ; cin >> p >> q ; int pi = 0 , rub = 0 ; int ans = 0 ; for ( int i = 1 ; i < maxn ; i ++ ) { string num = "  " ; int x = i ; while ( x ) { num += ( char ) ( x % 10 + ' 0 ' ) ; x /= 10 ; } if ( palindrome ( num ) ) rub ++ ; if ( ! prime [ i ] ) pi ++ ; if ( pi * q <= rub * p ) ans = i ; } if ( ans == 0 ) cout << " Palindromic tree is better than splay tree " << ' \n ' ; else cout << ans << ' \n ' ; return 0 ; }
TAB1 declare long longs N , M , K , L ; TAB1 read N and M and K and L ; TAB1 declare long long left = ( K + L ) / M ; TAB1 if ( left * M ) is less than ( K + L ) , increment left ; TAB1 declare long long right = N / M ; TAB1 declare long long ans = - 1 ; TAB1 if leeft is less than or equal to right , let ans be left ; TAB1 print ans and newline ;	int main ( ) { long long N , M , K , L ; cin >> N >> M >> K >> L ; long long left = ( K + L ) / M ; if ( ( left * M ) < ( K + L ) ) left ++ ; long long right = N / M ; long long ans = - 1 ; if ( left <= right ) { ans = left ; } cout << ans << endl ; return 0 ; }
TAB1 let mp be a map from string to integer ; TAB1 it is an iterator for map from string to integer ; TAB1 declare string variable a ; TAB1 declare ints n and m ; TAB1 create integer val ; TAB1 create double k ; TAB1 read n , m and k ; TAB1 loop i from 0 to n exclusive ; TAB2 read a and val ; TAB2 if val * 1 . 0 * k + 0 . 001 > = 100 . 0 ; TAB3 add val * 1 . 0 * k + 0 . 001 to mp [ a ] ; TAB2 else ; TAB3 erase a ; TAB1 loop i from 0 to m exclusive ; TAB2 read a ; TAB2 if mp [ a ] = 0 , assign 0 to mp [ a ] ; TAB1 print length of mp ; TAB1 move it through mp , printing it - > first , ' ' and it - > second on each iteration ;	int main ( ) { map < string , int > mp ; map < string , int > :: iterator it ; string a ; int n , m ; int val ; double k ; cin >> n >> m >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> val ; if ( val * 1.0 * k + 0.001 >= 100.0 ) mp [ a ] += val * 1.0 * k + 0.001 ; else a . erase ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { cin >> a ; if ( mp [ a ] == 0 ) mp [ a ] = 0 ; } cout << mp . size ( ) << endl ; for ( it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { cout << it -> first << '   ' << it -> second << endl ; } return 0 ; }
TAB0 N = 2002 ; TAB0 mp = map from string to long long ; TAB0 likes = map from pair of long long , long long to long long ; TAB1 n = 7 , sz = 0 , m , a , b , c = long long ; TAB1 read m ; TAB1 while decremented value of m not equal 0 ; TAB2 l , r = string ; TAB2 read l , r , r ; TAB2 if mp [ l ] is 0 increment sz , mp [ l ] = sz ; TAB2 if mp [ r ] is 0 increment sz , mp [ r ] = sz ; TAB2 likes [ make_pair ( mp [ l ] , mp [ r ] ) ] = l ; TAB1 read a , b , c ; TAB1 pt = 2187 , minimal = a + b + c , ml = long long ; TAB1 for i = 0 to pt excluisve ; TAB2 t = array of 3 vector of long long ; TAB2 k = i , m1 , m2 , m3 = long long , lks = 0 ; TAB2 for i = 1 to n inclusive ; TAB3 add i at end of t [ k modulo 3 ] ; TAB3 divide k by 3 ; TAB2 it size of t [ 0 ] and size of t [ 1 ] and size of t [ 2 ] ; TAB3 m1 = a / size of t [ 0 ] ; TAB3 m2 = b / size of t [ 1 ] ; TAB3 m3 = c / size of t [ 2 ] ; TAB3 m1 = max ( m1 , max ( m2 , m3 ) ) - min ( m1 , min ( m2 , m3 ) ) ; TAB3 for i = 0 to 3 exclusive ; TAB4 for j = 0 to size of t [ i ] exclusive ; TAB5 for k = 0 to size of t [ i ] exclusive add likes [ make_pair ( t [ i ] [ j ] , t [ i ] [ k ] ) ] to lks ; TAB3 if minimal > m1 ; TAB4 minimal = m1 ; TAB4 ml = lks ; TAB3 else if minimal is m1 ; TAB4 ml = max ( ml , lks ) ; TAB1 print minimal , space , ml ;	const long long N = 2002 ; map < string , long long > mp ; map < pair < long long , long long > , long long > likes ; int main ( ) { long long n = 7 , m , sz = 0 , a , b , c ; cin >> m ; while ( m -- ) { string l , r ; cin >> l >> r >> r ; if ( mp [ l ] == 0 ) mp [ l ] = ++ sz ; if ( mp [ r ] == 0 ) mp [ r ] = ++ sz ; likes [ make_pair ( mp [ l ] , mp [ r ] ) ] = 1 ; } cin >> a >> b >> c ; long long pt = 2187 , minimal = a + b + c , ml ; for ( long long i = 0 ; i < pt ; i ++ ) { vector < long long > t [ 3 ] ; long long k = i , m1 , m2 , m3 , lks = 0 ; for ( long long i = 1 ; i <= n ; i ++ ) { t [ k % 3 ] . push_back ( i ) ; k /= 3 ; } if ( t [ 0 ] . size ( ) && t [ 1 ] . size ( ) && t [ 2 ] . size ( ) ) { m1 = a / t [ 0 ] . size ( ) ; m2 = b / t [ 1 ] . size ( ) ; m3 = c / t [ 2 ] . size ( ) ; m1 = max ( m1 , max ( m2 , m3 ) ) - min ( m1 , min ( m2 , m3 ) ) ; for ( long long i = 0 ; i < 3 ; i ++ ) for ( long long j = 0 ; j < t [ i ] . size ( ) ; j ++ ) for ( long long k = 0 ; k < t [ i ] . size ( ) ; k ++ ) lks += likes [ make_pair ( t [ i ] [ j ] , t [ i ] [ k ] ) ] ; if ( minimal > m1 ) { minimal = m1 ; ml = lks ; } else if ( minimal == m1 ) ml = max ( ml , lks ) ; } } cout << minimal << "   " << ml << endl ; }
TAB0 a = character array of size 120 ; TAB0 in the function check that takes integer n and returns integer ; TAB1 flag1 = integer ; TAB1 for i = 1 to n ; TAB2 flag1 = 0 ; TAB2 for j = 1 to n ; TAB3 if a [ i ] [ j ] is . ; TAB4 flag1 = 1 ; TAB4 break loop ; TAB2 if not flag1 , break loop ; TAB1 flag2 = integer ; TAB1 for i = 1 to n ; TAB2 flag2 = 0 ; TAB2 for j = 1 to n ; TAB3 if a [ j ] [ i ] is . ; TAB4 flag2 = 1 ; TAB4 break loop ; TAB2 if not flag2 , break loop ; TAB1 if flag1 is 0 and flag2 is 0 ; TAB1 else ; TAB2 if flag1 ; TAB3 return 1 ; TAB2 else ; TAB3 return 2 ; TAB1 n = integer ; TAB1 while read n ; TAB2 for i = 1 to n ; TAB3 for j = 1 to n , read a [ i ] [ j ] ; TAB2 judge = integer with judge = check on n ; TAB2 if judge ; TAB3 if judge is 1 ; TAB4 for i = 1 to n ; TAB5 for j = 1 to n ; TAB6 if a [ i ] [ j ] is . ; TAB7 print i , " " , j ; TAB7 break loop ; TAB3 else ; TAB4 for i = 1 to n ; TAB5 for j = 1 to n ; TAB6 if a [ j ] [ i ] is . ; TAB7 print j , " " , i ; TAB7 break loop ; TAB2 else ; TAB3 print - 1 ;	char a [ 120 ] [ 120 ] ; int check ( int n ) { int flag1 ; for ( int i = 1 ; i <= n ; i ++ ) { flag1 = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] == ' . ' ) { flag1 = 1 ; break ; } } if ( ! flag1 ) { break ; } } int flag2 ; for ( int i = 1 ; i <= n ; i ++ ) { flag2 = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ j ] [ i ] == ' . ' ) { flag2 = 1 ; break ; } } if ( ! flag2 ) { break ; } } if ( flag1 == 0 && flag2 == 0 ) { return 0 ; } else { if ( flag1 ) { return 1 ; } else { return 2 ; } } } int main ( ) { int n ; while ( cin >> n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { cin >> a [ i ] [ j ] ; } } int judge = check ( n ) ; if ( judge ) { if ( judge == 1 ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] == ' . ' ) { cout << i << "   " << j << endl ; break ; } } } } else { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ j ] [ i ] == ' . ' ) { cout << j << "   " << i << endl ; break ; } } } } } else { cout << " -1 " << endl ; } } }
TAB1 N = int ; TAB1 read N ; TAB1 S = int array of size N ; TAB1 read N values into S ; TAB1 sort S ; TAB1 print first N - 1 values of S ; TAB1 print last value of S ;	int main ( ) { int N ; cin >> N ; int S [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { cin >> S [ i ] ; } sort ( S , S + N ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { cout << S [ i ] << "   " ; } cout << S [ N - 1 ] << endl ; }
TAB1 let n = integer ; TAB1 read n ; TAB1 set n = n * 2 ; TAB1 let ans = boolean with value false ; TAB1 let sqr = integer with value = square root of n rounded up ; TAB1 for integer i = 1 to sqr inclusive do the following ; TAB2 let l , r , j = integers with l = 1 and r = sqr ; TAB2 wile l is less than or equal to r do the following ; TAB3 set j = l + ( r - 1 ) / 2 ; TAB3 let integer t = i * ( i + 1 ) + j * ( j + 1 ) ; TAB3 if t is n do the following ; TAB4 set ans = true ; TAB4 exit the loop ; TAB3 else if t is less than n ; TAB4 set l = j + 1 ; TAB3 else ; TAB4 set r = j - 1 ; TAB2 if ans is true exit the loop ; TAB1 if ans is true print YES else print NO ;	int main ( ) { int n ; cin >> n ; n *= 2 ; bool ans = false ; int sqr = ceil ( sqrt ( n ) ) ; for ( int i = 1 ; i <= sqr ; i ++ ) { int l = 1 , r = sqr , j ; while ( l <= r ) { j = l + ( r - l ) / 2 ; int t = i * ( i + 1 ) + j * ( j + 1 ) ; if ( t == n ) { ans = true ; break ; } else if ( t < n ) l = j + 1 ; else r = j - 1 ; } if ( ans ) break ; } cout << ( ans ? " YES " : " NO " ) << endl ; return 0 ; }
TAB0 make strings cad and salida ; TAB0 make integer flag = 1 ; TAB1 read cad ; TAB1 for i = 0 to length of cad exclusive ; TAB2 if cad [ i ] is ' 0 ' and flag is 1 ; TAB3 set flag to 0 ; TAB2 otherwise do ; TAB3 set salida to salida + cad [ i ] ; TAB1 if length of salida is equal to length of cad , set salida to salida . substr ( 0 , salida . length ( ) - 1 ) ; TAB1 print salida ;	string cad , salida ; int flag = 1 ; int main ( ) { cin >> cad ; for ( int i = 0 ; i < cad . length ( ) ; i ++ ) { if ( cad [ i ] == ' 0 ' && flag == 1 ) { flag = 0 ; } else { salida += cad [ i ] ; } } if ( salida . length ( ) == cad . length ( ) ) salida = salida . substr ( 0 , salida . length ( ) - 1 ) ; cout << salida << endl ; return 0 ; }
TAB1 integer as n , i , temp , cnt = - 1 , res = 0 ; TAB1 create integer vector of a ; TAB1 read n ; TAB1 add new element 0 to end of vector a ; TAB1 add new element 0 to end of vector a ; TAB1 for = 0 to less than n do the following ; TAB2 read temp ; TAB2 add new element temp to end of vector a ; TAB1 add new element 1001 to end of vector a ; TAB1 for = 2 to less than or equal to n + 2 do the following ; TAB2 if a [ i ] is a [ i - 1 ] + 1 then do the following ; TAB3 add one to cnt ; TAB2 else ; TAB3 if cnt is greater than res then do the following res = cnt ; TAB3 set cnt to - 1 ; TAB1 if cnt is greater than res then res = cnt ; TAB1 output res ;	int main ( ) { int n , i , temp , cnt = - 1 , res = 0 ; vector < int > a ; cin >> n ; a . push_back ( 0 ) ; a . push_back ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cin >> temp ; a . push_back ( temp ) ; } a . push_back ( 1001 ) ; for ( i = 2 ; i <= n + 2 ; i ++ ) { if ( a [ i ] == a [ i - 1 ] + 1 ) { cnt ++ ; } else { if ( cnt > res ) { res = cnt ; } cnt = - 1 ; } } if ( cnt > res ) { res = cnt ; } cout << res << endl ; return 0 ; }
TAB0 sz , tot , pt are constant long longs with sz = 5e6 + 5 , tot = 1e7 + 5 , pt = 666e3 ; TAB0 ara = boolean array of size sz ; TAB0 in function makePrimes ; TAB1 i , j , r , k are long longs with k = 1 ; TAB1 for i = 0 to sz exclusive , set ara [ i ] to 1 ; TAB1 set r to square root tot ; TAB1 for i = 1 to r / 2 inclusive ; TAB2 if ara [ i ] equals 1 ; TAB3 ( ( 2 * i + 1 ) * ( 2 * i + 1 ) - 1 ) / 2 as long as j is at most sz with increment j + ( 2 * i + 1 ) , set ara [ j ] to 0 ; TAB1 call makePrimes ; TAB1 n , m , i are long longs ; TAB1 read n ; TAB1 for i = 1 with increment i + 1 ; TAB2 x = long long = n * i + 1 ; TAB2 if x is even and x isn ' t 2 ; TAB3 break ; TAB2 else ; TAB3 if ara [ ( x - 1 ) / 2 ] equals 0 , break ; TAB1 display i ;	const long long sz = 5e6 + 5 , tot = 1e7 + 5 , pt = 666e3 ; bool ara [ sz ] ; void makePrimes ( ) { long long i , j , r , k = 1 ; for ( i = 0 ; i < sz ; i ++ ) ara [ i ] = 1 ; r = sqrt ( tot ) ; for ( i = 1 ; i <= r / 2 ; i ++ ) { if ( ara [ i ] == 1 ) { for ( j = ( ( 2 * i + 1 ) * ( 2 * i + 1 ) - 1 ) / 2 ; j <= sz ; j += ( 2 * i + 1 ) ) { ara [ j ] = 0 ; } } } } int main ( ) { makePrimes ( ) ; long long n , m , i ; cin >> n ; for ( i = 1 ; ; i ++ ) { long long x = n * i + 1 ; if ( x % 2 == 0 && x != 2 ) break ; else { if ( ara [ ( x - 1 ) / 2 ] == 0 ) break ; } } cout << i << endl ; }
TAB1 n = integer , a and b are both integer arrays both of size 102 ; TAB1 k , cnt , res are all integers all set to 0 ; TAB1 let vis be an integer array of size 102 with vis = 0 ; TAB1 input n ; TAB1 for i = 1 to n inclusive ; TAB2 input a [ i ] ; TAB2 increment k ; TAB2 if a [ i ] is negative , increment cnt ; TAB2 if cnt is greater than 2 ; TAB3 increment res ; TAB3 assign k - 1 to b [ res ] ; TAB3 assign 1 to k ; TAB3 assign 1 to cnt ; TAB3 assign 1 to vis [ i - 1 ] ; TAB1 assign 0 to both cnt and k ; TAB1 for i = n to 1 inclusive with decrement i ; TAB2 if vis [ i ] , break ; TAB2 increment k ; TAB2 if a [ i ] is negative , increment cnt ; TAB1 if cnt is true , increment res ; TAB1 if res is equal to 0 , increment res ; TAB1 assign k to b [ res ] ; TAB1 display res ; TAB1 for i = 1 to res inclusive , display b [ i ] and ' ' ; TAB1 display b [ res ] ;	int main ( ) { int n , a [ 102 ] , b [ 102 ] ; int k = 0 , cnt = 0 , res = 0 ; int vis [ 102 ] = { 0 } ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; k ++ ; if ( a [ i ] < 0 ) cnt ++ ; if ( cnt > 2 ) { res ++ ; b [ res ] = k - 1 ; k = 1 ; cnt = 1 ; vis [ i - 1 ] = 1 ; } } cnt = 0 , k = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( vis [ i ] ) break ; k ++ ; if ( a [ i ] < 0 ) cnt ++ ; } if ( cnt ) res ++ ; if ( res == 0 ) res ++ ; b [ res ] = k ; cout << res << endl ; for ( int i = 1 ; i <= res - 1 ; i ++ ) cout << b [ i ] << '   ' ; cout << b [ res ] << endl ; return 0 ; }
TAB0 m = map from int to int ; TAB0 s = array of integers of length 300000 , a = array of integers of length 505 ; TAB0 let cmp be a function that accepts integers a , b and returns a boolean value ; TAB1 return a is greater than b ; TAB0 let gcd be a function that accepts integers a , b and returns a integer value ; TAB1 return gcd of b , a modulo b if b else return a ; TAB1 let n , t , k be integers ; TAB1 while read n ; TAB2 for i = 0 to n * n exclusive ; TAB3 read s [ i ] ; TAB3 increment m [ s [ i ] ] by 1 ; TAB2 sort the values s , s + n * n , cmp ; TAB2 t is equal to 0 , k is equal to 0 ; TAB2 for i = 0 to n * n exclusive ; TAB3 if m [ s [ i ] ] is equal to 0 , proceed to next ; TAB3 decrement m [ s [ i ] ] by 1 ; TAB3 for j = 0 to t exclusive ; TAB4 k is equal to gcd of s [ i ] and a [ j ] ; TAB4 decrement m [ k ] by 2 ; TAB3 a [ t + + ] is equal to s [ i ] ; TAB2 print a [ 0 ] ; TAB2 for i = 1 to t exclusive , print space and a [ i ] ; TAB2 print newline ;	map < int , int > m ; int s [ 300000 ] , a [ 505 ] ; bool cmp ( int a , int b ) { return a > b ; } int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } int main ( ) { int n , t , k ; while ( cin >> n ) { for ( int i = 0 ; i < n * n ; i ++ ) { cin >> s [ i ] ; m [ s [ i ] ] ++ ; } sort ( s , s + n * n , cmp ) ; t = 0 , k = 0 ; for ( int i = 0 ; i < n * n ; i ++ ) { if ( m [ s [ i ] ] == 0 ) continue ; m [ s [ i ] ] -- ; for ( int j = 0 ; j < t ; j ++ ) { k = gcd ( s [ i ] , a [ j ] ) ; m [ k ] -= 2 ; } a [ t ++ ] = s [ i ] ; } cout << a [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { cout << "   " << a [ i ] ; } cout << endl ; } return 0 ; }
TAB1 let n , k = - 1 , s = 0 , a [ 100 ] be ints ; TAB1 read n ; TAB1 for i = 0 to n exlcusive ; TAB2 read a [ i ] ; TAB2 increment s by a [ i ] ; TAB2 if a [ i ] isn ' t 0 and k is - 1 then set k to i + 1 ; TAB1 if k = - 1 ; TAB2 print NO ; TAB1 else ; TAB2 print YES ; TAB2 if s isn ' t 0 ; TAB3 print 1 and new line and " 1 " and n ; TAB2 else ; TAB3 print 2 ; TAB3 print " 1 " and k ; TAB3 print k + 1 and space and n ;	int main ( ) { int n , k = - 1 , s = 0 , a [ 100 ] ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; s += a [ i ] ; if ( a [ i ] != 0 && k == - 1 ) k = i + 1 ; } if ( k == - 1 ) cout << " NO " << endl ; else { cout << " YES " << endl ; if ( s != 0 ) cout << " 1 " << endl << " 1  " << n << endl ; else { cout << " 2 " << endl ; cout << " 1  " << k << endl ; cout << k + 1 << "   " << n << endl ; } } return 0 ; }
TAB0 n = long long ; TAB0 s = string ; TAB1 read n ; TAB1 ignore input ; TAB1 getline ( cin , s ) ; TAB1 C0 = long long set to 0 ; TAB1 C1 = long long set to 0 ; TAB1 for 0 to s . length ( ) - 1 inclusive ; TAB2 if s [ i ] equal to ' 0 ' ; TAB3 increment C0 to 1 ; TAB2 else ; TAB3 increment C1 to 1 ; TAB1 if C1 greater than 1 set C1 to 1 ; TAB1 for 1 to C1 inclusive print 1 ; TAB1 for 1 to C0 inclusive print 0 ; TAB1 print new line ;	long long n ; string s ; int main ( ) { cin >> n ; cin . ignore ( ) ; getline ( cin , s ) ; long long C0 = 0 ; long long C1 = 0 ; for ( int i = 0 ; i <= s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == ' 0 ' ) C0 ++ ; else C1 ++ ; } if ( C1 > 1 ) C1 = 1 ; for ( int i = 1 ; i <= C1 ; i ++ ) cout << 1 ; for ( int i = 1 ; i <= C0 ; i ++ ) cout << 0 ; cout << endl ; return 0 ; }
TAB0 declare boolean array isprime size 1500000 ; TAB0 declare sieve with no arguments , returning void ; TAB1 assign value boolean casted 1 from isprime to isprime + 1500000 ; TAB1 for i = 2 to 1500000 exclusive ; TAB2 if isprime [ i ] is true ; TAB3 for j = 2 * i to 1500000 exclusive , incrementing j by i , let isprime [ j ] be 0 ; TAB1 let isprime [ 1 ] be 0 ; TAB1 return from function ; TAB0 declare ispalin with integer num as argument , returning boolean ; TAB1 declare integer divisor = 1 ; TAB1 while num / divisor is greater than or equal to 10 , let divisor be divisor * 10 ; TAB1 while num is not 0 ; TAB2 declare leading = num / divisor ; TAB2 declare trailing = num % 10 ; TAB2 if leading is not trailing , return false from function ; TAB2 let num be ( num % divisor ) / 10 ; TAB2 let divisor be divisor / 100 ; TAB1 return true from function ; TAB1 run sieve ; TAB1 declare lprime = 0 , lpalin = 0 as integer ; TAB1 declare integers p , q ; TAB1 read p and q ; TAB1 declare integer ans ; TAB1 for i = 1 to 1500000 exclusive ; TAB2 if isprime [ i ] , increment lprime ; TAB2 if result of run ispalin ( i ) is true , increment lpalin ; TAB2 if long long casted q * lprime is less than or equal to long long casted p * lpalin , let ans be i ; TAB1 print ans and newline ;	bool isprime [ 1500000 ] ; void sieve ( ) { fill ( isprime , isprime + 1500000 , ( bool ) 1 ) ; for ( int i = 2 ; i < 1500000 ; i ++ ) { if ( isprime [ i ] ) { for ( int j = 2 * i ; j < 1500000 ; j += i ) { isprime [ j ] = 0 ; } } } isprime [ 1 ] = 0 ; return ; } bool ispalin ( int num ) { int divisor = 1 ; while ( num / divisor >= 10 ) divisor *= 10 ; while ( num != 0 ) { int leading = num / divisor ; int trailing = num % 10 ; if ( leading != trailing ) return false ; num = ( num % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int main ( ) { sieve ( ) ; int lprime = 0 , lpalin = 0 ; int p , q ; cin >> p >> q ; int ans ; for ( int i = 1 ; i < 1500000 ; i ++ ) { if ( isprime [ i ] ) { lprime ++ ; } if ( ispalin ( i ) ) { lpalin ++ ; } if ( ( long long ) q * lprime <= ( long long ) p * lpalin ) { ans = i ; } } cout << ans << endl ; return 0 ; }
TAB1 n , m , t , sum , esum , id = integers ; TAB1 while read n , m ; TAB2 esum = 0 ; TAB2 for i = 1 to n ; TAB3 read t ; TAB3 sum = ( t - 1 ) / m + 1 ; TAB3 if ( sum > = esum ) ; TAB4 esum = sum ; TAB4 id = i ; TAB2 print id ;	int main ( ) { int n , m , t , sum , esum , id ; while ( cin >> n >> m ) { esum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> t ; sum = ( t - 1 ) / m + 1 ; if ( sum >= esum ) { esum = sum ; id = i ; } } cout << id << endl ; } }
TAB1 s , t , z = string array of size 40 each ; TAB1 f , i , j , n , m , p , x = int with p = 0 and dz = int array of size 40 ; TAB1 k = long double and d = long double array of size 40 ; TAB1 read n then m then k ; TAB1 read n values into s then d ; TAB1 read m values into t ; TAB1 for i = 0 to n ; TAB2 set x to floor of k * d [ i ] + 0 . 00001 ; TAB2 if x is greater or equal to 100 ; TAB3 set z [ p ] to s [ i ] ; TAB3 set dz [ p ] to x ; TAB3 increment p ; TAB1 for j = 0 to m ; TAB2 set f to 0 ; TAB2 for i = 0 to p ; TAB3 if t [ j ] is z [ i ] ; TAB4 set f to 1 ; TAB4 break inner loop ; TAB2 if f is 0 ; TAB3 set z [ p ] to t [ j ] ; TAB3 set dz [ p ] to 0 ; TAB3 increment p ; TAB1 for i = 0 to p - 1 ; TAB2 for j = i + 1 to p ; TAB3 if z [ i ] is greater than z [ j ] ; TAB4 call swap on z [ i ] and z [ j ] ; TAB4 call swap on dz [ i ] and dz [ j ] ; TAB1 print p ; TAB1 for i = 0 to p print z [ i ] and dz [ i ] ;	int main ( ) { string s [ 40 ] , t [ 40 ] , z [ 40 ] ; int f , i , j , n , m , p = 0 , x , dz [ 40 ] ; long double k , d [ 40 ] ; cin >> n >> m >> k ; for ( i = 0 ; i < n ; i ++ ) cin >> s [ i ] >> d [ i ] ; for ( i = 0 ; i < m ; i ++ ) cin >> t [ i ] ; for ( i = 0 ; i < n ; i ++ ) { x = floor ( k * d [ i ] + 0.00001 ) ; if ( x >= 100 ) { z [ p ] = s [ i ] ; dz [ p ] = x ; p ++ ; } } for ( j = 0 ; j < m ; j ++ ) { f = 0 ; for ( i = 0 ; i < p ; i ++ ) if ( t [ j ] == z [ i ] ) { f = 1 ; break ; } if ( f == 0 ) { z [ p ] = t [ j ] ; dz [ p ] = 0 ; p ++ ; } } for ( i = 0 ; i < p - 1 ; i ++ ) for ( j = i + 1 ; j < p ; j ++ ) if ( z [ i ] > z [ j ] ) { swap ( z [ i ] , z [ j ] ) ; swap ( dz [ i ] , dz [ j ] ) ; } cout << p << endl ; for ( i = 0 ; i < p ; i ++ ) cout << z [ i ] << "   " << dz [ i ] << endl ; return 0 ; }
TAB0 create a map from long longs to long longs called mpu ; TAB0 let vec be a vector of long longs ; TAB0 declare string array s with size 101 ; TAB0 let path be long long array with size 1000006 ; TAB1 declare long long variable n ; TAB1 read n ; TAB1 for i from 0 to n exclusive , read s [ i ] ; TAB1 let row and col be boolean arrays with size 100 ; TAB1 for i from 0 to n exclusive ; TAB2 for j from 0 to n exclusive ; TAB3 if s [ i ] [ j ] is equal to ' . ' ; TAB4 set row [ i ] to 1 ; TAB4 set col [ j ] to 1 ; TAB1 create int p = 0 ; TAB1 loop i from 0 to n exclusive ; TAB2 if row [ i ] is false , set p to 1 ; TAB1 if p is equal to 1 ; TAB2 for integer i = 0 to n exclusive ; TAB3 if col [ i ] is false , change p to 2 ; TAB2 if p = 2 ; TAB3 print " - 1 \ n " ; TAB2 loop i from 0 to n exclusive ; TAB3 for j from 0 to n exclusive ; TAB4 if col [ j ] = 1 and s [ i ] [ j ] is equal to ' . ' ; TAB5 set col [ j ] to 0 ; TAB5 print i + 1 , " " and j + 1 ; TAB1 else ; TAB2 for integer i = 0 to n exclusive ; TAB3 loop j from 0 to n exclusive ; TAB4 if s [ i ] [ j ] = ' . ' ; TAB5 print i + 1 , " " and j + 1 ; TAB5 break the loop ;	map < long long , long long > mpu ; vector < long long > vec ; string s [ 101 ] ; long long path [ 1000006 ] = { } ; int main ( ) { long long n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; bool row [ 100 ] = { } , col [ 100 ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s [ i ] [ j ] == ' . ' ) { row [ i ] = 1 ; col [ j ] = 1 ; } } } int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! row [ i ] ) p = 1 ; } if ( p == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ! col [ i ] ) p = 2 ; } if ( p == 2 ) { cout << " -1\n " ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( col [ j ] == 1 && s [ i ] [ j ] == ' . ' ) { col [ j ] = 0 ; cout << ( i + 1 ) << "   " << ( j + 1 ) << endl ; } } } return 0 ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s [ i ] [ j ] == ' . ' ) { cout << ( i + 1 ) << "   " << ( j + 1 ) << endl ; break ; } } } } return 0 ; }
TAB1 create new integers i , j , u , v and w ; TAB1 numbers is a new vector of integers ; TAB1 create new integer called nums ; TAB1 read input to nums ; TAB1 for i from 0 to nums exclusive ; TAB2 read w from the user input ; TAB2 push w to numbers ; TAB1 sort numbers ; TAB1 start for loop from i = 0 to nums exclusive ; TAB2 if i ! = 0 , print ' ' ; TAB2 print numbers [ i ] to the standard output ; TAB1 print new line ;	int main ( ) { int i , j , u , v , w ; vector < int > numbers ; int nums ; cin >> nums ; for ( i = 0 ; i < nums ; ++ i ) { cin >> w ; numbers . push_back ( w ) ; } sort ( numbers . begin ( ) , numbers . end ( ) ) ; for ( i = 0 ; i < nums ; ++ i ) { if ( i != 0 ) cout << '   ' ; cout << numbers [ i ] ; } cout << endl ; return 0 ; }
TAB1 new vector of long longs v ; TAB1 declare integer p = 0 ; TAB1 declare long long variables i , n , x , num and numm ; TAB1 read input to n ; TAB1 start for loop from i = 1 to 100000 exclusive incrementing i ; TAB2 change x to ( i * ( i + 1 ) ) / 2 ; TAB2 push x to the end of v ; TAB1 for i from 1 to 100000 exclusive ; TAB2 set num to ( i * ( i + 1 ) ) / 2 ; TAB2 assign n - num to numm ; TAB2 if numm is found in v using binary_search ; TAB3 assign the new value = p + 1 to p ; TAB3 break ; TAB1 if p = 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { vector < long long > v ; int p = 0 ; long long i , n , x , num , numm ; cin >> n ; for ( i = 1 ; i < 100000 ; i ++ ) { x = ( i * ( i + 1 ) ) / 2 ; v . push_back ( x ) ; } for ( i = 1 ; i < 100000 ; i ++ ) { num = ( i * ( i + 1 ) ) / 2 ; numm = n - num ; if ( binary_search ( v . begin ( ) , v . end ( ) , numm ) ) { p = p + 1 ; break ; } } if ( p == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 create string str ; TAB0 declare check taking in integer p and returning bool ; TAB1 create character set se ; TAB1 clear the contents of se ; TAB1 insert str [ p ] into se ; TAB1 insert str [ p + 1 ] into se ; TAB1 insert str [ p - 1 ] into se ; TAB1 insert ' . ' into se ; TAB1 if the size of se is equal to 4 , return true ; TAB1 return false ; TAB1 read str ; TAB1 for i = 1 to the size of str exclusive ; TAB2 if calling check with i returns true ; TAB3 print " Yes " ; TAB1 print " No " ;	string str ; bool check ( int p ) { set < char > se ; se . clear ( ) ; se . insert ( str [ p ] ) ; se . insert ( str [ p + 1 ] ) ; se . insert ( str [ p - 1 ] ) ; se . insert ( ' . ' ) ; if ( se . size ( ) == 4 ) return true ; return false ; } int main ( ) { cin >> str ; for ( int i = 1 ; i + 1 < str . size ( ) ; i ++ ) { if ( check ( i ) ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; return 0 ; }
TAB0 declare long long n ; TAB1 read n ; TAB1 if n is 0 ; TAB2 print 1 , newline ; TAB1 else if n % 4 is 2 ; TAB2 print 4 , newline ; TAB1 else if n % 4 is 3 ; TAB2 print 2 , newline ; TAB1 else if n % 4 is 0 ; TAB2 print 6 , newline ; TAB1 else ; TAB2 print 8 , newline ;	long long n ; int main ( ) { cin >> n ; if ( n == 0 ) { cout << 1 << endl ; } else if ( n % 4 == 2 ) { cout << 4 << endl ; } else if ( n % 4 == 3 ) { cout << 2 << endl ; } else if ( n % 4 == 0 ) { cout << 6 << endl ; } else { cout << 8 << endl ; } }
TAB0 let n , i , j , k , x , y , z , m , q , h , r , timer , mx , l , cnt , u , v , t , s , tot be ints ; TAB1 let a , b , c , d , e , f ints ; TAB1 read a , b , c , d , e , and f ; TAB1 if c is 0 and d is positive or a is 0 and b + d is positive ; TAB2 print Ron ; TAB1 if a * c * e < b * d * f ; TAB2 print Ron ; TAB1 otherwise ; TAB2 print Hermione ;	int n , i , j , k , x , y , z , m , q , h , r , timer , mx , l , cnt , u , v , t , s , tot ; int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( c == 0 && d > 0 || a == 0 && b * d > 0 ) { cout << " Ron " << endl ; return 0 ; } if ( a * c * e < b * d * f ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB0 declare constant integer N = 1e5 + 5 ; TAB0 declare constant long long limit = 1e10 ; TAB0 declare long long l , r , res , cnt , long long array a size N ; TAB0 declare lucky_numbers with long long numb as argument , returning void ; TAB1 if numb is greater than limit , return from function ; TAB1 increment cnt , let a [ cnt ] be numb ; TAB1 run lucky_numbers ( numb * 10 + 4 ) ; TAB1 run lucky_numbers with numb * 10 + 7 as arguments ; TAB0 declare Solve with no arguments , returning void ; TAB1 declare long long L = 0 , R = 0 ; TAB1 for i = 1 to cnt inclusive ; TAB2 if a [ i ] is greater than or equalt o l ; TAB3 let L be i ; TAB3 end loop ; TAB1 for i = 1 to cnt inclusive ; TAB2 if a [ i ] is greater than or equal to r ; TAB3 let R be i ; TAB3 end loop ; TAB1 declare long long root = l ; TAB1 for i = L to R inclusive ; TAB2 declare long long length = minimum of ( a [ i ] and r ) - root + 1 ; TAB2 let res be res + ( a [ i ] * length ) ; TAB2 let root be a [ i ] + 1 ; TAB1 print res and ' \ n ' ; TAB1 read l and r ; TAB1 run lucky_numbers with 0 as argument ; TAB1 sort from a + 1 to a + cnt + 1 ; TAB1 run Solve ;	const int N = 1e5 + 5 ; const long long limit = 1e10 ; long long l , r , res , cnt , a [ N ] ; void lucky_numbers ( long long numb ) { if ( numb > limit ) return ; cnt ++ , a [ cnt ] = numb ; lucky_numbers ( numb * 10 + 4 ) ; lucky_numbers ( numb * 10 + 7 ) ; } void Solve ( ) { long long L = 0 , R = 0 ; for ( int i = 1 ; i <= cnt ; i ++ ) { if ( a [ i ] >= l ) { L = i ; break ; } } for ( int i = 1 ; i <= cnt ; i ++ ) { if ( a [ i ] >= r ) { R = i ; break ; } } long long root = l ; for ( long long i = L ; i <= R ; i ++ ) { long long length = min ( a [ i ] , r ) - root + 1 ; res = res + ( a [ i ] * length ) ; root = a [ i ] + 1 ; } cout << res << ' \n ' ; } int main ( ) { cin >> l >> r ; lucky_numbers ( 0 ) ; sort ( a + 1 , a + cnt + 1 ) ; Solve ( ) ; return 0 ; }
TAB0 create new constant integer MAX with value 1e7 - 8 . 8e6 ; TAB0 declare integer arrays a , sushu and huiwen with size MAX ; TAB0 function init ; TAB1 change the value of a [ 1 ] to 1 ; TAB1 assign the new value = 1 to a [ 0 ] ; TAB1 for integer i = 2 to 10000 inclusive incrementing i ; TAB2 if a [ i ] is false ; TAB3 in a for loop , change j starting from i while i * j < MAX , setting the value of a [ i * j ] to 1 on each iteration ; TAB0 function panduan with int argument x that returns integer ; TAB1 create new integer variable w with value x ; TAB1 declare new integer y = 0 ; TAB1 while w is not 0 ; TAB2 assign the new value = y * 10 + w % 10 to y ; TAB2 divide w by 10 ; TAB1 if y = x ; TAB2 return 1 ; TAB1 else ; TAB1 call init ( ) ; TAB1 in a for loop , change i from 1 to MAX exclusive ; TAB2 if a [ i ] is true ; TAB3 set sushu [ i ] to sushu [ i - 1 ] ; TAB2 else ; TAB3 assign sushu [ i - 1 ] + 1 to sushu [ i ] ; TAB2 if panduan ( i ) is true ; TAB3 set huiwen [ i ] to huiwen [ i - 1 ] + 1 ; TAB2 else ; TAB3 assign huiwen [ i - 1 ] to huiwen [ i ] ; TAB1 create new integers p and q ; TAB1 read input to p and q ; TAB1 in a for loop , change i from MAX - 1 to 0 inclusive decrementing i ; TAB2 if sushu [ i ] * q < = huiwen [ i ] * p ; TAB3 if i is equal to 0 ; TAB4 print " Palindromic tree is better than splay tree " ; TAB3 else ; TAB4 print i to the standard output ;	const int MAX = 1e7 - 8.8e6 ; int a [ MAX ] , sushu [ MAX ] , huiwen [ MAX ] ; void init ( ) { a [ 1 ] = 1 ; a [ 0 ] = 1 ; for ( int i = 2 ; i <= 10000 ; i ++ ) { if ( ! a [ i ] ) { for ( int j = i ; i * j < MAX ; j ++ ) { a [ i * j ] = 1 ; } } } } int panduan ( int x ) { int w = x ; int y = 0 ; while ( w != 0 ) { y = y * 10 + w % 10 ; w /= 10 ; } if ( y == x ) return 1 ; else return 0 ; } int main ( ) { init ( ) ; for ( int i = 1 ; i < MAX ; i ++ ) { if ( a [ i ] ) sushu [ i ] = sushu [ i - 1 ] ; else sushu [ i ] = sushu [ i - 1 ] + 1 ; if ( panduan ( i ) ) huiwen [ i ] = huiwen [ i - 1 ] + 1 ; else huiwen [ i ] = huiwen [ i - 1 ] ; } int p , q ; cin >> p >> q ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { if ( sushu [ i ] * q <= huiwen [ i ] * p ) { if ( i == 0 ) cout << " Palindromic tree is better than splay tree " << endl ; else cout << i << endl ; return 0 ; } } return 0 ; }
TAB1 let n be an integer ; TAB1 read in n ; TAB1 let s be a string ; TAB1 read in s ; TAB1 let i , count and k be integers , set count to 0 ; TAB1 if s [ 0 ] is equal to ' > ' ; TAB2 for i = 0 to s . size ( ) ; TAB3 is s [ i ] is equal to ' > ' ; TAB4 increment count ; TAB3 or else ; TAB4 set count to 0 ; TAB2 print count ; TAB1 else if s [ 0 ] is equal to ' < ' ; TAB2 set i to 0 ; TAB2 let g be an integer and set it to 0 ; TAB2 while s [ i ] is equal to ' > ' ; TAB3 increment count ; TAB3 increment i ; TAB2 for k = i to s . size ( ) ; TAB3 if s [ k ] is equal to ' > ' ; TAB4 increment g ; TAB3 else if s [ k ] is equal to ' > ' ; TAB4 set g to 0 ; TAB2 print g + count ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; int i , count = 0 , k ; if ( s [ 0 ] == ' > ' ) { for ( i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' > ' ) { count ++ ; } else { count = 0 ; } } cout << count << endl ; } else if ( s [ 0 ] == ' < ' ) { i = 0 ; int g = 0 ; while ( s [ i ] == ' < ' ) { count ++ ; i ++ ; } for ( k = i ; k < s . size ( ) ; k ++ ) { if ( s [ k ] == ' > ' ) { g ++ ; } else if ( s [ k ] == ' < ' ) { g = 0 ; } } cout << g + count << endl ; } return 0 ; }
TAB0 let abso be a function that accepts integer a and returns a integer value ; TAB1 if a is less than 0 , return - a ; TAB1 return a ; TAB1 c = map from string to int ; TAB1 c [ C ] is equal to 0 ; TAB1 c [ C # ] is equal to 1 ; TAB1 c [ D ] is equal to 2 ; TAB1 c [ D # ] is equal to 3 ; TAB1 c [ E ] is equal to 4 ; TAB1 c [ F ] is equal to 5 ; TAB1 c [ F # ] is equal to 6 ; TAB1 c [ G ] is equal to 7 ; TAB1 c [ G # ] is equal to 8 ; TAB1 c [ A ] is equal to 9 ; TAB1 c [ B ] is equal to 10 ; TAB1 c [ H ] is equal to 11 ; TAB1 let a , b , cs be strings ; TAB1 read a , b , cs ; TAB1 val = array of integers of length 3 ; TAB1 val [ 0 ] is equal to c [ a ] ; TAB1 val [ 1 ] is equal to c [ b ] ; TAB1 val [ 2 ] is equal to c [ cs ] ; TAB1 sort the values val , val + 3 ; TAB1 for i = 0 to 3 exclusive ; TAB2 the integer value of dist = ( - val [ i + 0 ] + val [ ( i + 1 ) modulo 3 ] ) ; TAB2 if dist is less than 0 , increment dist by 12 ; TAB2 the integer value of dist1 = ( - val [ ( i + 1 ) modulo 3 ] + val [ ( i + 2 ) modulo 3 ] ) ; TAB2 if dist1 is less than 0 , increment dist1 by 12 ; TAB2 if dist equals 3 and dist1 equals 4 ; TAB3 print minor and newline ; TAB2 if dist1 equals 3 and dist equals 4 ; TAB3 print major and newline ; TAB1 print strange and newline ;	int abso ( int a ) { if ( a < 0 ) return - a ; return a ; } int main ( ) { map < string , int > c ; c [ " C " ] = 0 ; c [ " C# " ] = 1 ; c [ " D " ] = 2 ; c [ " D# " ] = 3 ; c [ " E " ] = 4 ; c [ " F " ] = 5 ; c [ " F# " ] = 6 ; c [ " G " ] = 7 ; c [ " G# " ] = 8 ; c [ " A " ] = 9 ; c [ " B " ] = 10 ; c [ " H " ] = 11 ; string a , b , cs ; cin >> a >> b >> cs ; int val [ 3 ] ; val [ 0 ] = c [ a ] ; val [ 1 ] = c [ b ] ; val [ 2 ] = c [ cs ] ; sort ( val , val + 3 ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int dist = ( - val [ i + 0 ] + val [ ( i + 1 ) % 3 ] ) ; if ( dist < 0 ) dist += 12 ; int dist1 = ( - val [ ( i + 1 ) % 3 ] + val [ ( i + 2 ) % 3 ] ) ; if ( dist1 < 0 ) dist1 += 12 ; if ( dist == 3 && dist1 == 4 ) { cout << " minor\n " ; return 0 ; } if ( dist1 == 3 && dist == 4 ) { cout << " major\n " ; return 0 ; } } cout << " strange\n " ; return 0 ; }
TAB0 a , v = integer vectors both of length 150005 ; TAB0 used = boolean array of length 150005 ; TAB0 n , m , k , x , y = integers ; TAB0 in function dfs that returns nothing and takes argument u = integer ; TAB1 set used [ u ] = 1 ; TAB1 append u to the end of v [ k ] ; TAB1 for i = 0 to the size of a [ u ] exclusive ; TAB2 if used [ a [ u ] [ i ] ] is 0 then call dfs with argument a [ u ] [ i ] ; TAB1 p = integer ; TAB1 read n and m ; TAB1 for i = 0 to m exclusive ; TAB2 read x and y ; TAB2 append y to the end of a [ x ] ; TAB2 append x to the end of a [ y ] ; TAB1 for i = 0 to n exclusive ; TAB2 if used [ i ] is 0 ; TAB3 add 1 to k ; TAB3 call dfs with argument i ; TAB3 set p to the size of v [ k ] ; TAB3 for j = 0 to p exclusive ; TAB4 if the size of a [ v [ k ] [ j ] ] does not equal p - 1 ; TAB5 print NO ; TAB1 print YES ;	vector < int > a [ 150005 ] , v [ 150005 ] ; bool used [ 150005 ] ; int n , m , k , x , y ; void dfs ( int u ) { used [ u ] = 1 ; v [ k ] . push_back ( u ) ; for ( int i = 0 ; i < a [ u ] . size ( ) ; i ++ ) { if ( ! used [ a [ u ] [ i ] ] ) dfs ( a [ u ] [ i ] ) ; } } int main ( ) { int p ; cin >> n >> m ; for ( int i = 0 ; i < m ; i ++ ) { cin >> x >> y ; a [ x ] . push_back ( y ) ; a [ y ] . push_back ( x ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! used [ i ] ) { k ++ ; dfs ( i ) ; p = v [ k ] . size ( ) ; for ( int j = 0 ; j < p ; j ++ ) { if ( a [ v [ k ] [ j ] ] . size ( ) != p - 1 ) { cout << " NO " << endl ; return 0 ; } } } } cout << " YES " << endl ; return 0 ; }
TAB1 declare integer n = 100000 ; TAB1 create integer aux ; TAB1 create integer aux2 ; TAB1 let x be integer array with size n ; TAB1 let a be integer array with size n ; TAB1 declare int negativos = 0 ; TAB1 declare int positivos = 0 ; TAB1 declare int manz = 0 ; TAB1 declare int ne ; TAB1 declare int po ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read x [ i ] ; TAB2 read a [ i ] ; TAB1 loop v from 1 to n exclusive ; TAB2 for integer b = 0 to n - 1 exclusive ; TAB3 if x [ b ] is greater than x [ b + 1 ] ; TAB4 set aux to x [ b ] ; TAB4 set x [ b ] to x [ b + 1 ] ; TAB4 set x [ b + 1 ] to aux ; TAB4 set aux2 to a [ b ] ; TAB4 set a [ b ] to a [ b + 1 ] ; TAB4 set a [ b + 1 ] to aux2 ; TAB1 for i from 0 to n exclusive ; TAB2 if x [ i ] is less than 0 ; TAB3 increment negativos ; TAB2 else ; TAB3 increment positivos ; TAB1 if negativos is equal to positivos ; TAB2 for t from 0 to n exclusive , change manz to manz + a [ t ] ; TAB1 else if negativos is less than positivos ; TAB2 if negativos is equal to 0 ; TAB3 assign a [ 0 ] to manz ; TAB2 else ; TAB3 change ne to negativos ; TAB3 change po to negativos + 1 ; TAB3 for y from negativos - ne to negativos - 1 + po inclusive , assign manz + a [ y ] to manz ; TAB1 else ; TAB2 if positivos = 0 ; TAB3 change manz to a [ negativos - 1 ] ; TAB2 else ; TAB3 set ne to positivos + 1 ; TAB3 set po to positivos ; TAB3 for integer y = negativos - ne to negativos - 1 + po inclusive , assign manz + a [ y ] to manz ; TAB1 print manz ;	int main ( ) { int n = 100000 ; int aux ; int aux2 ; int x [ n ] ; int a [ n ] ; int negativos = 0 ; int positivos = 0 ; int manz = 0 ; int ne ; int po ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x [ i ] ; cin >> a [ i ] ; } for ( int v = 1 ; v < n ; v ++ ) { for ( int b = 0 ; b < n - 1 ; b ++ ) { if ( x [ b ] > x [ b + 1 ] ) { aux = x [ b ] ; x [ b ] = x [ b + 1 ] ; x [ b + 1 ] = aux ; aux2 = a [ b ] ; a [ b ] = a [ b + 1 ] ; a [ b + 1 ] = aux2 ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < 0 ) { negativos ++ ; } else { positivos ++ ; } } if ( negativos == positivos ) { for ( int t = 0 ; t < n ; t ++ ) { manz = manz + a [ t ] ; } } else if ( negativos < positivos ) { if ( negativos == 0 ) { manz = a [ 0 ] ; } else { ne = negativos ; po = negativos + 1 ; for ( int y = negativos - ne ; y <= negativos - 1 + po ; y ++ ) { manz = manz + a [ y ] ; } } } else { if ( positivos == 0 ) { manz = a [ negativos - 1 ] ; } else { ne = positivos + 1 ; po = positivos ; for ( int y = negativos - ne ; y <= negativos - 1 + po ; y ++ ) { manz = manz + a [ y ] ; } } } cout << manz << endl ; return 0 ; }
TAB0 TT , T , n , m = integers ; TAB1 i , j , k = integers ; TAB1 a = character array of size 110 ; TAB1 b = integer array of size 110 ; TAB1 c = integer array of size [ 110 ] [ 110 ] , d = integer ; TAB1 e , f , g = integer ; TAB1 mx , mn = integers with mx = - 0x3f3f3f3f , mn = 0x3f3f3f3f ; TAB1 T = 1 ; TAB1 for TT = 1 to T ; TAB2 read n ; TAB2 cnt = integer with cnt = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ 1 ] ; TAB3 if a [ 1 ] is 0 , increment cnt ; TAB2 if n is 1 and cnt ; TAB3 print 0 ; TAB2 else ; TAB3 print 1 ; TAB3 while decrement cnt , print 0 ; TAB3 print new line ;	int TT , T , n , m ; int main ( ) { long long i , j , k ; char a [ 110 ] ; int b [ 110 ] ; int c [ 110 ] [ 110 ] , d ; int e , f , g ; int mx = - 0x3f3f3f3f , mn = 0x3f3f3f3f ; T = 1 ; for ( TT = 1 ; TT <= T ; TT ++ ) { cin >> n ; int cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ 1 ] ; if ( a [ 1 ] == ' 0 ' ) cnt ++ ; } if ( n == 1 && cnt ) cout << ' 0 ' << endl ; else { cout << ' 1 ' ; while ( cnt -- ) { cout << ' 0 ' ; } cout << endl ; } } return 0 ; }
TAB0 define integer arrays a , b and c with 100100 elements ; TAB1 create new integer n ; TAB1 read user input to n ; TAB1 for i = 0 to n exclusive ; TAB2 read user input to a [ i ] ; TAB2 if i is not 0 ; TAB3 create new integer variable t = absolute value of a [ i ] - a [ i - 1 ] ; TAB3 if i is odd ; TAB4 set the value of b [ i ] to t ; TAB4 assign - t to c [ i ] ; TAB3 else ; TAB4 change b [ i ] to - t ; TAB4 assign the new value = t to c [ i ] ; TAB1 new long long MAX with value 0 ; TAB1 declare long long sum = 0 ; TAB1 in a for loop , change i from 1 to n exclusive ; TAB2 if sum + b [ i ] is greater than 0 ; TAB3 change sum to sum + b [ i ] ; TAB2 else ; TAB3 set the value of sum to 0 ; TAB2 change the value of MAX to max of MAX and sum ; TAB1 set sum to 0 ; TAB1 for i = 1 to n exclusive ; TAB2 if sum + c [ i ] is greater than 0 ; TAB3 increase sum by c [ i ] ; TAB2 else ; TAB3 change the value of sum to 0 ; TAB2 change the value of MAX to max of MAX and sum ; TAB1 print MAX ;	int a [ 100100 ] , b [ 100100 ] , c [ 100100 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( i ) { int t = abs ( a [ i ] - a [ i - 1 ] ) ; if ( i % 2 ) { b [ i ] = t ; c [ i ] = - t ; } else { b [ i ] = - t ; c [ i ] = t ; } } } long long MAX = 0 ; long long sum = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( sum + b [ i ] > 0 ) { sum += b [ i ] ; } else sum = 0 ; MAX = max ( MAX , sum ) ; } sum = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( sum + c [ i ] > 0 ) { sum += c [ i ] ; } else sum = 0 ; MAX = max ( MAX , sum ) ; } cout << MAX << endl ; return 0 ; }
TAB1 declare int variables n and i ; TAB1 read n from the input ; TAB1 create new string s ; TAB1 read input to s ; TAB1 declare new ints q and sp = 0 ; TAB1 if value of s [ 0 ] is ' ? ' , increment q ; TAB1 if s [ n - 1 ] is ' ? ' , increment q by one ; TAB1 in a for loop , change i from 1 to n - 1 exclusive incrementing i ; TAB2 if s [ i ] = ' ? ' ; TAB3 if s [ i - 1 ] ! = s [ i + 1 ] ; TAB4 if s [ i - 1 ] = ' ? ' | s [ i + 1 ] = ' ? ' ; TAB5 increment q by one ; TAB4 else ; TAB5 increment sp ; TAB3 else ; TAB4 increment q ; TAB2 else ; TAB3 if s [ i ] = s [ i - 1 ] | s [ i + 1 ] = s [ i ] ; TAB4 print " No " to the standard output ; TAB4 return ( 0 ) ; TAB1 if q is greater than 0 ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ; TAB1 return ( 0 ) ;	int main ( ) { int n , i ; cin >> n ; string s ; cin >> s ; int q = 0 , sp = 0 ; if ( s [ 0 ] == ' ? ' ) { q ++ ; } if ( s [ n - 1 ] == ' ? ' ) { q ++ ; } for ( i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' ? ' ) { if ( s [ i - 1 ] != s [ i + 1 ] ) { if ( s [ i - 1 ] == ' ? ' | s [ i + 1 ] == ' ? ' ) { q ++ ; } else { sp ++ ; } } else q ++ ; } else { if ( s [ i ] == s [ i - 1 ] | s [ i + 1 ] == s [ i ] ) { cout << " No " << endl ; return ( 0 ) ; } } } if ( q > 0 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } return ( 0 ) ; }
TAB1 create int n , b and l , set l to 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read b ; TAB2 if b = 0 , increment l ; TAB1 if l = 1 and n different from 1 or n = 1 and l = 0 ; TAB2 print YES ; TAB1 else ; TAB2 print NO and a newline ;	int main ( ) { int n , b , l = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> b ; if ( b == 0 ) { l ++ ; } } if ( l == 1 && n != 1 || n == 1 && l == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB1 create integer variable t ; TAB1 read variable t from the input ; TAB1 if t = 1 ; TAB2 print " - 1 " to the standard output ; TAB1 else ; TAB2 print t , " " and t ;	int main ( ) { int t ; cin >> t ; if ( t == 1 ) cout << " -1 " << endl ; else cout << t << "   " << t << endl ; return 0 ; }
TAB0 N = const int with N = 1e5 + 100 ; TAB0 arr = long long array of size N ; TAB1 x , y = int ; TAB1 read x then y ; TAB1 a , b = int with a = absolute of x and b = absolute of y ; TAB1 mx = int with mx = max of absolute of x and absolute of y ; TAB1 if mx is 0 ; TAB2 print 0 ; TAB1 c = int with c = ( mx - 1 ) * 4 ; TAB1 if mx is a ; TAB2 if x is greater than 0 ; TAB3 if y is less or equal to 0 and b is mx - 1 ; TAB4 print c ; TAB3 else if y is less or equal to 0 and b is mx ; TAB4 print c + 4 ; TAB3 else ; TAB4 print c + 1 ; TAB2 else ; TAB3 if y is greater than 0 and b is mx ; TAB4 print c + 2 ; TAB3 else ; TAB4 print c + 3 ; TAB1 else ; TAB2 if y is greater than 0 ; TAB3 if x is greater than 0 and a is mx ; TAB4 print c + 1 ; TAB3 else ; TAB4 print c + 2 ; TAB2 else ; TAB3 if x is less than 0 and a is mx ; TAB4 print c + 3 ; TAB3 else ; TAB4 print c + 4 ;	const int N = 1e5 + 100 ; long long arr [ N ] ; int main ( ) { int x , y ; cin >> x >> y ; int a = abs ( x ) , b = abs ( y ) ; int mx = max ( abs ( x ) , abs ( y ) ) ; if ( mx == 0 ) { cout << 0 << endl ; return 0 ; } int c = ( mx - 1 ) * 4 ; if ( mx == a ) { if ( x > 0 ) { if ( y <= 0 && b == mx - 1 ) { cout << c << endl ; } else if ( y <= 0 && b == mx ) { cout << c + 4 << endl ; } else { cout << c + 1 << endl ; } } else { if ( y > 0 && b == mx ) { cout << c + 2 << endl ; } else { cout << c + 3 << endl ; } } } else { if ( y > 0 ) { if ( x > 0 && a == mx ) { cout << c + 1 << endl ; } else cout << c + 2 << endl ; } else { if ( x < 0 && a == mx ) { cout << c + 3 << endl ; } else cout << c + 4 << endl ; } } }
TAB0 f is a integer function with int arguments a and b ; TAB1 declare integer x1 = a divided by 10 ; TAB1 define integer variable x2 with value a modulo 10 ; TAB1 declare integer variable x3 with value = b divided by 10 ; TAB1 define integer x4 = b modulo 10 ; TAB1 return 1 if x1 is equal to x4 and x2 is equal to x3 ; TAB1 define new ints a and b ; TAB1 create character variable with name s ; TAB1 read a , s and b and loop further ; TAB2 if f of a and b is 1 ; TAB3 print " 0 " to the standard output ; TAB2 else ; TAB3 increase i by 1 , starting from 1 , in a loop ; TAB4 if b + 1 = 60 and a < 23 ; TAB5 assign the new value = 0 to b ; TAB5 change a to a + 1 ; TAB4 else if a is equal to 23 ; TAB5 if b is greater than 32 ; TAB6 print 60 - b and a new line ; TAB6 stop the loop ; TAB5 else ; TAB6 increment b by one ; TAB4 else ; TAB5 increment b ; TAB4 if f of a and b returned 1 ; TAB5 print i to the standard output ; TAB5 stop the loop ;	int f ( int a , int b ) { int x1 = a / 10 ; int x2 = a % 10 ; int x3 = b / 10 ; int x4 = b % 10 ; if ( x1 == x4 && x2 == x3 ) return 1 ; return 0 ; } int main ( ) { int a , b ; char s ; while ( cin >> a >> s >> b ) { if ( f ( a , b ) == 1 ) cout << " 0 " << endl ; else { for ( int i = 1 ; ; i ++ ) { if ( b + 1 == 60 && a < 23 ) { b = 0 ; a += 1 ; } else if ( a == 23 ) { if ( b > 32 ) { cout << 60 - b << endl ; break ; } else b ++ ; } else { b ++ ; } if ( f ( a , b ) == 1 ) { cout << i << endl ; break ; } } } } return 0 ; }
TAB0 declare long long ans ; TAB0 declare maxsum with long long array p , long long n as argument , returning long long ; TAB1 declare long long tmp = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 let tmp be maximum of ( 0LL and tmp + p [ i ] ) ; TAB2 let ans be maximum of ( ans and tmp ) ; TAB1 declare long long n ; TAB1 read n ; TAB1 declare long long array a size n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 declare long long array b size n ; TAB1 declare long long array c size n ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 let b [ i ] be absolute value of ( a [ i ] - a [ i + 1 ] ) * ( 1 if i % 2 is 0 , else - 1 ) ; TAB2 let c [ i ] be absolute value of ( a [ i ] - a [ i + 1 ] ) * ( 1 if ( i + 1 ) % 2 is 0 , else - 1 ) ; TAB1 run maxsum with b , n - 1 as arguments ; TAB1 run maxsum ( c , n - 1 ) ; TAB1 print ans and ' \ n ' ;	long long ans ; long long maxsum ( long long p [ ] , long long n ) { long long tmp = 0 ; for ( long long i = 0 ; i < n ; ++ i ) { tmp = max ( 0LL , tmp + p [ i ] ) ; ans = max ( ans , tmp ) ; } } int main ( ) { long long n ; cin >> n ; long long a [ n ] ; for ( long long i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; long long b [ n ] ; long long c [ n ] ; for ( long long i = 0 ; i < n - 1 ; ++ i ) { b [ i ] = abs ( a [ i ] - a [ i + 1 ] ) * ( i % 2 == 0 ? 1 : - 1 ) ; c [ i ] = abs ( a [ i ] - a [ i + 1 ] ) * ( ( i + 1 ) % 2 == 0 ? 1 : - 1 ) ; } maxsum ( b , n - 1 ) ; maxsum ( c , n - 1 ) ; cout << ans << ' \n ' ; }
TAB0 maxn = constant int , maxn = 1e6 ; TAB0 function gcd type long long that takes in parameters long long a and long long b ; TAB1 if b is 0 ; TAB2 return a ; TAB1 else ; TAB2 return gcd ( b , remainder of a / b ) ; TAB0 function lcm type long long that takes in parameters long long a and long long b ; TAB1 return a * b / gcd ( a , b ) ; TAB1 n = int ; TAB1 while n can be read ; TAB2 ans = long long ; TAB2 if n > 3 ; TAB3 let ans = lcm ( lcm ( n - 2 , n - 1 ) , n ) ; TAB3 ans2 = long long , ans 2 = lcm ( lcm ( n - 3 , n - 1 ) , n ) ; TAB3 ans3 = long long , ans 3 = lcm ( lcm ( n - 3 , n - 2 ) , n - 1 ) ; TAB3 ans = max ( max ( ans , ans2 ) , ans3 ) ; TAB2 else ; TAB3 if n equals 1 ; TAB4 let ans = 1 ; TAB3 else if n = 2 ; TAB4 let ans = 2 ; TAB3 else if n = 3 ; TAB4 let ans = 6 ; TAB2 print ans ;	const int maxn = 1e6 ; long long gcd ( long long a , long long b ) { if ( b == 0 ) { return a ; } else { return gcd ( b , a % b ) ; } } long long lcm ( long long a , long long b ) { return a * b / gcd ( a , b ) ; } int main ( ) { int n ; while ( cin >> n ) { long long ans ; if ( n > 3 ) { ans = lcm ( lcm ( n - 2 , n - 1 ) , n ) ; long long ans2 = lcm ( lcm ( n - 3 , n - 1 ) , n ) ; long long ans3 = lcm ( lcm ( n - 3 , n - 2 ) , n - 1 ) ; ans = max ( max ( ans , ans2 ) , ans3 ) ; } else { if ( n == 1 ) ans = 1 ; else if ( n == 2 ) ans = 2 ; else if ( n == 3 ) ans = 6 ; } cout << ans << endl ; } }
TAB0 create constant long long inf with inf = 0xFFFFFFFFFFFFFFFL ; TAB0 create clock_t time_p with time_p = result of run clock ; TAB0 declare time with no arguments , returning void ; TAB1 set time_p to result of run clock - time_p ; TAB1 print to stderr " Time Taken : " print float casted ( time_p ) / CLOCKS_PER_SEC print " \ n " ; TAB1 create long longs n , m , k ; TAB1 read n read m read k ; TAB1 if k is greater than n + m - 2 ; TAB2 print - 1 print " \ n " ; TAB1 if k is less than or equal to n - 1 and k is less than or equal to m - 1 ; TAB2 create long long mn1 with mn1 = ( m / ( k + 1 ) ) * n ; TAB2 create long long mn2 with mn2 = ( n / ( k + 1 ) ) * m ; TAB2 print maximum of mn1 and mn2 print " \ n " ; TAB1 if k is less than or equal to n - 1 and k is greater than m - 1 ; TAB2 create long long mn1 with mn1 = ( n / ( k - ( m - 1 ) + 1 ) ) ; TAB2 create long long mn2 with mn2 = m * ( n / ( k + 1 ) ) ; TAB2 print maximum of mn1 and mn2 print " \ n " ; TAB1 if k is less than or equal to m - 1 and k is greater than n - 1 ; TAB2 create long long mn1 with mn1 = ( m / ( k - ( n - 1 ) + 1 ) ) ; TAB2 create long long mn2 with mn2 = n * ( m / ( k + 1 ) ) ; TAB2 print maximum of mn1 and mn2 print " \ n " ; TAB1 if k is greater than n - 1 and k is greater than m - 1 ; TAB2 create long long mn1 with mn1 = m / ( k - ( n - 1 ) + 1 ) ; TAB2 create long long mn2 with mn2 = n / ( k - ( m - 1 ) + 1 ) ; TAB2 print maximum of mn1 and mn2 print " \ n " ; TAB1 run time ;	const long long inf = 0xFFFFFFFFFFFFFFFL ; clock_t time_p = clock ( ) ; void time ( ) { time_p = clock ( ) - time_p ; cerr << " Time Taken :  " << ( float ) ( time_p ) / CLOCKS_PER_SEC << " \n " ; } int main ( ) { long long n , m , k ; cin >> n >> m >> k ; if ( k > n + m - 2 ) { cout << - 1 << " \n " ; return 0 ; } if ( k <= n - 1 && k <= m - 1 ) { long long mn1 = ( m / ( k + 1 ) ) * n ; long long mn2 = ( n / ( k + 1 ) ) * m ; cout << max ( mn1 , mn2 ) << " \n " ; } if ( k <= n - 1 && k > m - 1 ) { long long mn1 = ( n / ( k - ( m - 1 ) + 1 ) ) ; long long mn2 = m * ( n / ( k + 1 ) ) ; cout << max ( mn1 , mn2 ) << " \n " ; } if ( k <= m - 1 && k > n - 1 ) { long long mn1 = ( m / ( k - ( n - 1 ) + 1 ) ) ; long long mn2 = n * ( m / ( k + 1 ) ) ; cout << max ( mn1 , mn2 ) << " \n " ; } if ( k > n - 1 && k > m - 1 ) { long long mn1 = m / ( k - ( n - 1 ) + 1 ) ; long long mn2 = n / ( k - ( m - 1 ) + 1 ) ; cout << max ( mn1 , mn2 ) << " \n " ; } time ( ) ; return 0 ; }
TAB1 integers = a in 4 by 4 array ; TAB1 for i = 0 to i is less than 4 do the following ; TAB2 for j = 0 to 3 read a [ i ] [ j ] ; TAB1 for i = 0 to less than 4 do the following ; TAB2 if a [ i ] [ 3 ] is 1 then do { ; TAB3 if a [ i ] [ 0 ] is 1 or a [ i ] [ 1 ] is 1 or a [ i ] [ 2 ] is 1 then do next command ; TAB4 output " YES " ; TAB3 else ; TAB4 output " YES " ; TAB2 if a [ i ] [ 3 ] is 1 then do ; TAB3 if a [ remainder of i + 1 / 4 ] [ 0 ] is 1 then do next commands ; TAB4 output " YES " ; TAB2 if a [ i ] [ 3 ] is 1 then do ; TAB3 if a [ remainder of i + 3 / 4 ] [ 2 ] is 1 then do { ; TAB4 output " YES " ; TAB1 output " NO " ;	int main ( ) { int a [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) cin >> a [ i ] [ j ] ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( a [ i ] [ 3 ] == 1 ) { if ( a [ i ] [ 0 ] == 1 || a [ i ] [ 1 ] == 1 || a [ i ] [ 2 ] == 1 ) { cout << " YES " << endl ; return 0 ; } else if ( a [ ( i + 2 ) % 4 ] [ 1 ] == 1 ) { cout << " YES " << endl ; return 0 ; } } if ( a [ i ] [ 3 ] == 1 ) if ( a [ ( i + 1 ) % 4 ] [ 0 ] == 1 ) { cout << " YES " << endl ; return 0 ; } if ( a [ i ] [ 3 ] == 1 ) if ( a [ ( i + 3 ) % 4 ] [ 2 ] == 1 ) { cout << " YES " << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; }
TAB0 in function gcd1 taking long long a , long long b and returning long long ; TAB1 if a is 0 return b ; TAB1 return gcd1 of b mod a , a ; TAB0 in function modx taking long long base , long long ex and returning long long ; TAB1 ans , val = long long with ans = 1LL and val = base ; TAB1 loop while ex > 0LL ; TAB2 if ex bitwise - and 1LL set ans to ( ans * val ) mod 1000000009LL ; TAB2 set val to ( val * val ) mod 1000000009LL ; TAB2 set ex to ex bitshift right by 1LL ; TAB1 return ans ; TAB0 maxn = const int with maxn = 1e5 + 10 ; TAB0 visit , visit1 = bool array of size maxn each ; TAB0 n , m , x , y = int and a = int array of size maxn ; TAB0 D , P = bool array of size maxn each ; TAB0 adj , v = int vector array of size maxn each ; TAB0 in function dfs taking int start ; TAB1 set visit [ start ] to true ; TAB1 for i = 0 to size of adj [ start ] ; TAB2 pt = int with pt = adj [ start ] [ i ] ; TAB2 if not visit [ pt ] call dfs of pt ; TAB0 in function dfs2 taking int start ; TAB1 set visit1 [ start ] to true ; TAB1 for i = 0 to size of v [ start ] ; TAB2 pt = int with pt = v [ start ] [ i ] ; TAB2 if not visit1 [ pt ] call dfs2 of pt ; TAB1 read n then m ; TAB1 for i = 1 to n inclusive read a [ i ] ; TAB1 for i = 1 to m inclusive ; TAB2 read x then y ; TAB2 append y to adj [ x ] ; TAB2 if a [ x ] ! = 1 and a [ y ] ! = 1 append x to v [ y ] ; TAB1 for i = 1 to n inclusive ; TAB2 if not visit [ i ] and a [ i ] is 1 call dfs of i ; TAB1 for i = 1 to n inclusive ; TAB2 if not visit1 [ i ] and a [ i ] is 2 call dfs2 of i ; TAB1 for i = 1 to n inclusive ; TAB2 if a [ i ] is not 1 continue ; TAB2 for j = 0 to size of adj [ i ] ; TAB3 pt = int with pt = adj [ i ] [ j ] ; TAB3 if visit1 [ pt ] and a [ pt ] is not 1 set visit1 [ i ] to true ; TAB1 for i = 1 to n inclusive ; TAB2 if visit1 [ i ] and visit [ i ] ; TAB3 print 1 ; TAB2 else ; TAB3 print 0 ;	long long gcd1 ( long long a , long long b ) { if ( a == 0 ) return b ; return gcd1 ( b % a , a ) ; } long long modx ( long long base , long long ex ) { long long ans = 1LL , val = base ; while ( ex > 0LL ) { if ( ex & 1LL ) ans = ( ans * val ) % 1000000009LL ; val = ( val * val ) % 1000000009LL ; ex = ex >> 1LL ; } return ans ; } const int maxn = 1e5 + 10 ; bool visit [ maxn ] , visit1 [ maxn ] ; int n , m , x , y , a [ maxn ] ; bool D [ maxn ] , P [ maxn ] ; vector < int > adj [ maxn ] , v [ maxn ] ; void dfs ( int start ) { visit [ start ] = true ; for ( int i = 0 ; i < adj [ start ] . size ( ) ; i ++ ) { int pt = adj [ start ] [ i ] ; if ( ! visit [ pt ] ) dfs ( pt ) ; } } void dfs2 ( int start ) { visit1 [ start ] = true ; for ( int i = 0 ; i < v [ start ] . size ( ) ; i ++ ) { int pt = v [ start ] [ i ] ; if ( ! visit1 [ pt ] ) dfs2 ( pt ) ; } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i <= m ; i ++ ) { cin >> x >> y ; adj [ x ] . push_back ( y ) ; if ( a [ x ] != 1 && a [ y ] != 1 ) v [ y ] . push_back ( x ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visit [ i ] && a [ i ] == 1 ) dfs ( i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visit1 [ i ] && a [ i ] == 2 ) dfs2 ( i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != 1 ) continue ; for ( int j = 0 ; j < adj [ i ] . size ( ) ; j ++ ) { int pt = adj [ i ] [ j ] ; if ( visit1 [ pt ] && a [ pt ] != 1 ) visit1 [ i ] = true ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( visit1 [ i ] && visit [ i ] ) cout << 1 << endl ; else cout << 0 << endl ; } return 0 ; }
TAB0 dx = integer array of size 4 with dx = { 0 , 0 , - 1 , 1 } ; TAB0 dy = integer array of size 4 with dy = { 1 , - 1 , 0 , 0 } ; TAB1 n = integer ; TAB1 read n ; TAB1 s = vector of string ; TAB1 c = character ; TAB1 tmp = string ; TAB1 for i = 0 to n exclusive ; TAB2 read tmp ; TAB2 append tmp in s ; TAB2 transform ( s [ i ] . begin ( ) , s [ i ] . end ( ) , s [ i ] . begin ( ) , tolower ) ; TAB1 shit , fuck = string ; TAB1 read shit , c ; TAB1 save = string with save = shit ; TAB1 fuck = shit ; TAB1 transform ( save . begin ( ) , save . end ( ) , save . begin ( ) , tolower ) ; TAB1 rep = integer array of size [ save . size ( ) ] = { } ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to shit . size ( ) exclusive ; TAB3 if ( j + s [ i ] . size ( ) - 1 > = save . size ( ) ) , continue next iteration ; TAB3 if ( save . substr ( j , s [ i ] . size ( ) ) is s [ i ] ) ; TAB4 for k = 0 to s [ i ] . size ( ) , rep [ k + j ] = 1 ; TAB1 for i = 0 to shit . size ( ) exclusive ; TAB2 if ( rep [ i ] ) ; TAB3 if ( save [ i ] is not c ) ; TAB4 shit [ i ] = c ; TAB3 else ; TAB4 if ( c is a ) ; TAB5 shit [ i ] = b ; TAB4 else ; TAB5 shit [ i ] = a ; TAB3 if ( fuck [ i ] < = Z and fuck [ i ] > = A ) , shit [ i ] = ( cast to character ) toupper ( shit [ i ] ) ; TAB1 print shit ;	int dx [ 4 ] = { 0 , 0 , - 1 , 1 } ; int dy [ 4 ] = { 1 , - 1 , 0 , 0 } ; int main ( ) { int n ; cin >> n ; vector < string > s ; char c ; string tmp ; for ( int i = 0 ; i < n ; i += 1 ) { cin >> tmp ; s . push_back ( tmp ) ; transform ( s [ i ] . begin ( ) , s [ i ] . end ( ) , s [ i ] . begin ( ) , :: tolower ) ; } string shit , fuck ; cin >> shit >> c ; string save = shit ; fuck = shit ; transform ( save . begin ( ) , save . end ( ) , save . begin ( ) , :: tolower ) ; int rep [ save . size ( ) ] = { } ; for ( int i = 0 ; i < n ; i += 1 ) for ( int j = 0 ; j < shit . size ( ) ; j += 1 ) { if ( j + s [ i ] . size ( ) - 1 >= save . size ( ) ) continue ; if ( save . substr ( j , s [ i ] . size ( ) ) == s [ i ] ) for ( int k = 0 ; k < s [ i ] . size ( ) ; k += 1 ) rep [ k + j ] = 1 ; } for ( int i = 0 ; i < shit . size ( ) ; i += 1 ) { if ( rep [ i ] ) { if ( save [ i ] != c ) shit [ i ] = c ; else { if ( c == ' a ' ) shit [ i ] = ' b ' ; else shit [ i ] = ' a ' ; } if ( fuck [ i ] <= ' Z ' && fuck [ i ] >= ' A ' ) shit [ i ] = ( char ) toupper ( shit [ i ] ) ; } } cout << shit << ' \n ' ; }
TAB0 function iamax ( get pointer to int arr , int N , return int ) ; TAB1 ma = arr [ 0 ] ; TAB1 for i = 1 to N exclusive ma = max ( arr [ i ] , ma ) ; TAB1 return ma ; TAB0 function readarr ( get pointer to int arr and N , return nothing ) ; TAB1 read into N ; TAB1 for i = 0 to number pointed by N exclusive read arr [ i ] ; TAB0 arr = array of 1005 char ; TAB0 k , n = int ; TAB0 function pal ( get int a and b , return bool ) ; TAB1 while a < b ; TAB2 if arr [ a ] is not arr [ b - 1 ] return false ; TAB2 increment a ; TAB2 decrement b ; TAB1 return true ; TAB0 function run ( no args , return bool ) ; TAB1 mul = n / k ; TAB1 for i = 0 to n exclusive by mul ; TAB2 if not pal ( i , i + mul ) return false ; TAB1 return true ; TAB1 read arr , k ; TAB1 n = length of arr ; TAB1 if n modulo k ; TAB2 print " NO " ; TAB1 else ; TAB2 if run ( ) ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ;	int iamax ( int * arr , int N ) { int ma = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) ma = max ( arr [ i ] , ma ) ; return ma ; } void readarr ( int * arr , int * N ) { cin >> * N ; for ( int i = 0 ; i < * N ; i ++ ) cin >> arr [ i ] ; } char arr [ 1005 ] ; int k , n ; bool pal ( int a , int b ) { while ( a < b ) { if ( arr [ a ] != arr [ b - 1 ] ) return false ; a ++ ; b -- ; } return true ; } bool run ( ) { int mul = n / k ; for ( int i = 0 ; i < n ; i += mul ) { if ( ! pal ( i , i + mul ) ) return false ; } return true ; } int main ( ) { cin >> arr >> k ; n = strlen ( arr ) ; if ( n % k ) cout << " NO\n " ; else { if ( run ( ) ) cout << " YES\n " ; else cout << " NO\n " ; } }
TAB0 integer as x , t , a , b , da , db ; TAB0 create boolean called solve ; TAB1 for i = 0 to less than t do the following ; TAB2 for j = 0 to less than t do the following ; TAB3 if a - i * da + b - j * db is x or a - i * da = x or b - j * db = x then return a 1 ; TAB1 read inputs into x , t , a , b , da , db ; TAB1 if ! x is true ; TAB2 output YES ; TAB1 else ; TAB2 output YES if solve is true else put a NO ;	int x , t , a , b , da , db ; bool solve ( ) { for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { if ( a - i * da + b - j * db == x || a - i * da == x || b - j * db == x ) return 1 ; } } return 0 ; } int main ( ) { cin >> x >> t >> a >> b >> da >> db ; if ( ! x ) cout << " YES " << endl ; else cout << ( solve ( ) ? " YES " : " NO " ) << endl ; }
TAB0 function get_ans with long long argument n that returns long long ; TAB1 if n < = 0 , return 1 ; TAB1 return 10 raised to power n ; TAB0 function calc with long long argument n that returns long long ; TAB1 if n is less than 10 , return n ; TAB1 declare an arrays of integers a and arr with size 20 ; TAB1 create integer no_of_digits = 0 ; TAB1 create long long tmp = n ; TAB1 create integer first_digit ; TAB1 create integer last_digit = n modulo 10 ; TAB1 while tmp ! = 0 ; TAB2 increment no_of_digits by one ; TAB2 change a [ no_of_digits ] to tmp modulo 10 ; TAB2 if tmp is less than 10 , assign tmp to first_digit ; TAB2 divide tmp by 10 ; TAB1 create long long res = 0 ; TAB1 for i from 1 to no_of_digits exclusive , add 9 * get_ans ( i - 2 ) to res ; TAB1 for integer i = no_of_digits to 1 inclusive counting down , set arr [ no_of_digits - i + 1 ] to a [ i ] ; TAB1 increase res by ( first_digit - 1 ) * get_ans ( no_of_digits - 2 ) ; TAB1 declare long long variable tmp2 = 1 ; TAB1 loop i from 2 to no_of_digits - 1 inclusive , increasing tmp2 by ( arr [ i ] ) * get_ans ( no_of_digits - i - 1 ) ; TAB1 add tmp2 to res ; TAB1 if first_digit is greater than last_digit , decrement res by one ; TAB1 return res ; TAB1 declare long longs l and r ; TAB1 read l and r ; TAB1 print calc ( r ) - calc ( l - 1 ) and " \ n " ;	long long get_ans ( long long n ) { if ( n <= 0 ) return 1 ; return pow ( 10 , n ) ; } long long calc ( long long n ) { if ( n < 10 ) return n ; int a [ 20 ] , arr [ 20 ] ; int no_of_digits = 0 ; long long tmp = n ; int first_digit ; int last_digit = n % 10 ; while ( tmp ) { no_of_digits ++ ; a [ no_of_digits ] = tmp % 10 ; if ( tmp < 10 ) first_digit = tmp ; tmp /= 10 ; } long long res = 0 ; for ( int i = 1 ; i < no_of_digits ; i ++ ) { res += 9 * get_ans ( i - 2 ) ; } for ( int i = no_of_digits ; i >= 1 ; i -- ) arr [ no_of_digits - i + 1 ] = a [ i ] ; res += ( first_digit - 1 ) * get_ans ( no_of_digits - 2 ) ; long long tmp2 = 1 ; for ( int i = 2 ; i <= no_of_digits - 1 ; i ++ ) { tmp2 += ( arr [ i ] ) * get_ans ( no_of_digits - i - 1 ) ; } res += tmp2 ; if ( first_digit > last_digit ) res -- ; return res ; } int main ( ) { long long l , r ; cin >> l >> r ; cout << ( calc ( r ) - calc ( l - 1 ) ) << " \n " ; return 0 ; }
TAB1 create long long integers m , x1 , x2 , y1 , y2 , h1 , h2 , a1 , and a2 ; TAB1 read m ; TAB1 read h1 and a1 ; TAB1 read x1 and y1 ; TAB1 read h2 and a2 ; TAB1 read x2 and y2 ; TAB1 create integer vector ans1 ; TAB1 create integer vector ans2 ; TAB1 create long long integer total = 0 ; TAB1 while total is less than 2 * m ; TAB2 if h1 is equal to a1 , append total to ans1 ; TAB2 if h2 is equal to a2 , append total to ans2 ; TAB2 increment total ; TAB2 set h1 to the result of ( h1 * x1 + y1 ) % m ; TAB2 set h2 to the result of ( h2 * x2 + y2 ) % m ; ; TAB1 if ans1 . empty ( ) is truthy or ans2 . empty ( ) is truthy ; TAB2 print " - 1 " ; TAB1 create long long integers t1 = ans1 [ 0 ] and t2 = ans2 [ 0 ] ; TAB1 create long long integer s1 = ans1 [ 1 ] - ans1 [ 0 ] ; TAB1 create long long integer s2 = ans2 [ 1 ] - ans2 [ 0 ] ; TAB1 for i = 0 to 5e6 ; TAB2 if t1 is equal to t2 ; TAB3 print t1 ; TAB2 if t1 is less than t2 ; TAB3 set t1 to t1 + s1 ; TAB2 else ; TAB3 set t2 to t2 + s2 ; TAB1 print " - 1 " ;	int main ( ) { long long m , x1 , x2 , y1 , y2 , h1 , h2 , a1 , a2 ; cin >> m ; cin >> h1 >> a1 ; cin >> x1 >> y1 ; cin >> h2 >> a2 ; cin >> x2 >> y2 ; vector < int > ans1 ; vector < int > ans2 ; long long total = 0 ; while ( total < 2 * m ) { if ( h1 == a1 ) { ans1 . push_back ( total ) ; } if ( h2 == a2 ) { ans2 . push_back ( total ) ; } total ++ ; h1 = ( h1 * x1 + y1 ) % m ; h2 = ( h2 * x2 + y2 ) % m ; } if ( ans1 . empty ( ) || ans2 . empty ( ) ) { cout << " -1 " << endl ; return 0 ; } long long t1 = ans1 [ 0 ] , t2 = ans2 [ 0 ] ; long long s1 = ans1 [ 1 ] - ans1 [ 0 ] ; long long s2 = ans2 [ 1 ] - ans2 [ 0 ] ; for ( int i = 0 ; i <= 5e6 ; i ++ ) { if ( t1 == t2 ) { cout << t1 << endl ; return 0 ; } if ( t1 < t2 ) { t1 += s1 ; } else { t2 += s2 ; } } cout << " -1 " << endl ; return 0 ; }
TAB1 declare doubles a1 , a , b , c , d , e , f ; TAB1 read a , b , c , d , e , f ; TAB1 set a1 to 1 / a * b / c * d / e * f ; TAB1 if c equals 0 and d is greater than 0 ; TAB2 print " Ron " ; TAB1 else if a = = 0 and b is greater than 0 and d is greater than 0 ; TAB2 print " Ron " ; TAB1 else if a1 is greater than 1 ; TAB2 print " Ron " ; TAB1 else ; TAB2 print " Hermione " ;	int main ( ) { double a1 , a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; a1 = ( ( ( ( ( 1 / a ) * b ) / c ) * d ) / e ) * f ; if ( c == 0 && d > 0 ) cout << " Ron " << endl ; else if ( a == 0 && b > 0 && d > 0 ) cout << " Ron " << endl ; else if ( a1 > 1 ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB0 a is a new array of integers with 100001 element ; TAB1 n is a new integer variable ; TAB1 read from the input to n ; TAB1 read n elements into a starting from the index 1 ; TAB1 res is a new long long with value 0 ; TAB1 create integer t ; TAB1 start for loop from i = 1 to n exclusive incrementing i ; TAB2 in a loop , multiply t by 2 , starting from t = 1 , while i + t < = n ; TAB2 change t to t > > 1 ; TAB2 increase res by a [ i ] ; TAB2 add a [ i ] to a [ i + t ] ; TAB2 print res ;	int a [ 100001 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i < n + 1 ; i ++ ) cin >> a [ i ] ; long long res = 0 ; int t ; for ( int i = 1 ; i < n ; i ++ ) { for ( t = 1 ; i + t <= n ; t *= 2 ) ; t >>= 1 ; res += a [ i ] ; a [ i + t ] += a [ i ] ; cout << res << endl ; } return 0 ; }
TAB0 primeFactures = vector of long long ; TAB0 function f ( get long long q , return nothing ) ; TAB1 while q is even ; TAB2 add 2 at end of primeFactures ; TAB2 divide q by 2 ; TAB1 for i = 3 to sqrt ( q ) inclusive by 2 ; TAB2 while w modulo i is 0 ; TAB3 add i at end of primeFactures ; TAB3 divide q by i ; TAB1 if q > 2 add q at end of primeFactures ; TAB0 function isprime ( get long long x , return bool ) ; TAB1 for i = 2 to sqrt ( x ) inclusive ; TAB2 if x modulo i is 0 return false ; TAB1 return true ; TAB1 q = long long ; TAB1 read q ; TAB1 if isprime ( q ) ; TAB2 print " 1 " , newline , " 0 " , newline ; TAB1 f ( q ) ; TAB1 if size of primeFactures > 2 ; TAB2 print " 1 " , newline , primeFactures [ 0 ] * primeFactures [ 1 ] ; TAB1 else ; TAB2 print " 2 " , newline ;	vector < long long > primeFactures ; void f ( long long q ) { while ( q % 2 == 0 ) { primeFactures . push_back ( 2 ) ; q /= 2 ; } for ( long long i = 3 ; i * i <= q ; i += 2 ) { while ( q % i == 0 ) { primeFactures . push_back ( i ) ; q /= i ; } } if ( q > 2 ) primeFactures . push_back ( q ) ; } bool isprime ( long long x ) { for ( long long i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return 0 ; } return 1 ; } int main ( ) { long long q ; cin >> q ; if ( isprime ( q ) ) { cout << " 1\n0\n " ; return 0 ; } f ( q ) ; if ( primeFactures . size ( ) > 2 ) { cout << " 1\n " << ( primeFactures [ 0 ] * primeFactures [ 1 ] ) << endl ; } else { cout << " 2\n " ; } return 0 ; }
TAB0 create new constant integer called mod = 1e9 + 7 ; TAB0 create new constant double eps = 1e - 6 ; TAB0 q is a new vector of long longs ; TAB0 function dfs with long long argument x ; TAB1 if x > = 10000000005 , return ; TAB1 push x to the end of vector q ; TAB1 call dfs of x * 10 + 4 ; TAB1 call dfs of x * 10 + 7 ; TAB1 declare new long longs l and r ; TAB1 call dfs ( 0 ) ; TAB1 sort whole vector q ; TAB1 read l and r and keep looping ; TAB2 declare long longs ans_l and ans_r = 0 ; TAB2 len is a new integer variable with value length of q ; TAB2 in a for loop , change i from 1 to len inclusive incrementing i ; TAB3 if q [ i ] < = l - 1 ; TAB4 change ans_l to ans_l + ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; TAB3 else ; TAB4 change ans_l to the sum of ans_l and ( l - 1 - q [ i - 1 ] ) * q [ i ] ; TAB4 break ; TAB2 for i = 1 to len inclusive incrementing i ; TAB3 if q [ i ] < = r ; TAB4 change ans_r to ans_r + ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; TAB3 else ; TAB4 set the value of ans_r to the sum of ans_r and ( r - q [ i - 1 ] ) * q [ i ] ; TAB4 break the loop ; TAB2 print ans_r - ans_l ;	const int mod = 1e9 + 7 ; const double eps = 1e-6 ; vector < long long > q ; void dfs ( long long x ) { if ( x >= 10000000005 ) { return ; } q . push_back ( x ) ; dfs ( x * 10 + 4 ) ; dfs ( x * 10 + 7 ) ; } int main ( ) { long long l , r ; dfs ( 0 ) ; sort ( q . begin ( ) , q . end ( ) ) ; while ( cin >> l >> r ) { long long ans_l = 0 , ans_r = 0 ; int len = q . size ( ) ; for ( int i = 1 ; i <= len ; i ++ ) { if ( q [ i ] <= l - 1 ) { ans_l += ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; } else { ans_l += ( l - 1 - q [ i - 1 ] ) * q [ i ] ; break ; } } for ( int i = 1 ; i <= len ; i ++ ) { if ( q [ i ] <= r ) { ans_r += ( q [ i ] - q [ i - 1 ] ) * q [ i ] ; } else { ans_r += ( r - q [ i - 1 ] ) * q [ i ] ; break ; } } cout << ans_r - ans_l << endl ; } return 0 ; }
TAB0 create constant int maxn = 1e5 + 10 ; TAB0 create bool array mark of size maxn and rmark of size maxn ; TAB0 make integer a of size maxn ; TAB0 create int vector v of size maxn and rv of size maxn ; TAB0 declare inline dfs taking in ints x and par ; TAB1 if mark [ x ] is true , return ; TAB1 if par is not equal to - 1 and a [ x ] is equal to 1 , return ; TAB1 set mark [ x ] to 1 ; TAB1 for i = 0 to v [ x ] . size ( ) exclusive ; TAB2 if mark [ v [ x ] [ i ] ] is falsy , call dfs ( v [ x ] [ i ] , x ) ; TAB0 declare inline rdfs taking in integer x ; TAB1 if rmark [ x ] is true , return ; TAB1 set rmark [ x ] to 1 ; TAB1 if a [ x ] is 1 , end function ; TAB1 for i = 0 to rv [ x ] . size ( ) exclusive ; TAB2 if rmark [ rv [ x ] [ i ] ] is falsy , call rdfs ( rv [ x ] [ i ] ) ; TAB1 create ints n , m , x , and y ; TAB1 read n and m ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 for i = 0 to m exclusive ; TAB2 read x and y ; TAB2 subtract 1 from x ; TAB2 decrease y by 1 ; TAB2 append y to v [ x ] ; TAB2 append x to rv [ y ] ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is equal to 1 , call dfs ( i , - 1 ) ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is equal to 2 , call rdfs ( i ) ; TAB1 for i = 0 to n exclusive ; TAB2 if mark [ i ] and rmark [ i ] are truthy ; TAB3 print 1 ; TAB2 else ; TAB3 print 0 ;	const int maxn = 1e5 + 10 ; bool mark [ maxn ] , rmark [ maxn ] ; int a [ maxn ] ; vector < int > v [ maxn ] , rv [ maxn ] ; inline void dfs ( int x , int par ) { if ( mark [ x ] ) return ; if ( par != - 1 && a [ x ] == 1 ) return ; mark [ x ] = 1 ; for ( int i = 0 ; i < v [ x ] . size ( ) ; i ++ ) if ( ! mark [ v [ x ] [ i ] ] ) dfs ( v [ x ] [ i ] , x ) ; } inline void rdfs ( int x ) { if ( rmark [ x ] ) return ; rmark [ x ] = 1 ; if ( a [ x ] == 1 ) return ; for ( int i = 0 ; i < rv [ x ] . size ( ) ; i ++ ) if ( ! rmark [ rv [ x ] [ i ] ] ) rdfs ( rv [ x ] [ i ] ) ; } int main ( ) { int n , m , x , y ; cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < m ; i ++ ) { cin >> x >> y ; x -- ; y -- ; v [ x ] . push_back ( y ) ; rv [ y ] . push_back ( x ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) dfs ( i , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 2 ) rdfs ( i ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mark [ i ] && rmark [ i ] ) cout << 1 << " \n " ; else cout << 0 << " \n " ; }
TAB0 declare vector of unsigned long longs called prime ; TAB0 declare new array of booleans chkPrime1to10000000 with 10000001 element ; TAB0 function primeFunction ; TAB1 create new unsigned long longs i and j ; TAB1 for i from 4 to 10000001 exclusive increasing i by 2 , change the value of chkPrime1to10000000 [ i ] to 1 ; TAB1 add new element = 0 after the last element of prime ; TAB1 assign the value of 1 to chkPrime1to10000000 [ 1 ] ; TAB1 add 2 to the end of prime ; TAB1 in a for loop , change i from 3 to 10000001 exclusive by steps of 2 ; TAB2 if chkPrime1to10000000 [ i ] is equal to 0 ; TAB3 push new value = i to the end of prime ; TAB3 if i squared < = 10000000 ; TAB4 in a for loop , change j from i squared to 10000000 inclusive adding ( 2 * i ) to j , setting chkPrime1to10000000 [ j ] to 1 on each loop iteration ; TAB1 define ulong long variables n , i and j ; TAB1 call primeFunction ( ) ; TAB1 read n from the input ; TAB1 for i from 1 to exclusive ; TAB2 set the value of j to n * i + 1 ; TAB2 if chkPrime1to10000000 [ j ] is true ; TAB3 print i ;	vector < unsigned long long > prime ; bool chkPrime1to10000000 [ 10000001 ] ; void primeFunction ( ) { unsigned long long i , j ; for ( i = 4 ; i < 10000001 ; i += 2 ) chkPrime1to10000000 [ i ] = 1 ; prime . push_back ( 0 ) ; chkPrime1to10000000 [ 1 ] = 1 ; prime . push_back ( 2 ) ; for ( i = 3 ; i < 10000001 ; i += 2 ) { if ( chkPrime1to10000000 [ i ] == 0 ) { prime . push_back ( i ) ; if ( i * i <= 10000000 ) for ( j = ( i * i ) ; j <= 10000000 ; j += ( 2 * i ) ) { chkPrime1to10000000 [ j ] = 1 ; } } } } int main ( ) { ulong long n , i , j ; primeFunction ( ) ; cin >> n ; for ( i = 1 ; 1 ; i ++ ) { j = n * i + 1 ; if ( chkPrime1to10000000 [ j ] ) { cout << i << endl ; return 0 ; } } return 0 ; }
TAB0 INF is a new constant integer variable = 0x3f3f3f3f ; TAB1 create new integer variable n ; TAB1 read variable n from the input ; TAB1 create new string called str ; TAB1 read str from the input ; TAB1 declare new integer variable numofzero = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 if value of str [ i ] is equal to ' 0 ' , increment numofzero by one ; TAB1 if numofzero = n ; TAB2 print " 0 " to the standard output ; TAB1 else ; TAB2 print " 1 " ; TAB2 for integer i = 1 to numofzero inclusive , print " 0 " ; TAB2 print new line to the standard output ;	const int INF = 0x3f3f3f3f ; int main ( ) { int n ; cin >> n ; string str ; cin >> str ; int numofzero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' 0 ' ) numofzero ++ ; } if ( numofzero == n ) cout << " 0 " << endl ; else { cout << " 1 " ; for ( int i = 1 ; i <= numofzero ; i ++ ) cout << " 0 " ; cout << endl ; } return 0 ; }
TAB0 let s be a string ; TAB0 let k be a integer ; TAB1 read s , k ; TAB1 let sl be a integer with sl = int ( length of s ) ; TAB1 if sl modulo k is not equal to 0 ; TAB2 print NO and newline ; TAB1 for integer i is equal to 0 , i is less than sl , i = i + sl / k ; TAB2 for j = 0 to sl / k / 2 exclusive ; TAB3 if s [ i + j ] is not equal to s [ i + sl / k - j - 1 ] ; TAB4 print NO and newline ; TAB1 print YES and newline ;	string s ; int k ; int main ( ) { cin >> s >> k ; int sl = int ( s . size ( ) ) ; if ( sl % k != 0 ) { cout << " NO " << endl ; return 0 ; } for ( int i = 0 ; i < sl ; i += sl / k ) { for ( int j = 0 ; j < sl / k / 2 ; j ++ ) { if ( s [ i + j ] != s [ i + sl / k - j - 1 ] ) { cout << " NO " << endl ; return 0 ; } } } cout << " YES " << endl ; }
TAB0 maxn = const integer with maxn = 110 ; TAB0 adj = vector integer array of size maxn ; TAB0 A = 2d bool array of size [ maxn ] [ maxn ] ; TAB0 in the function c that takes integer x and returns integer ; TAB1 return ( x * ( x - 1 ) * ( x - 2 ) ) / 6 ; TAB0 in the function c2 that takes integer x and returns integer ; TAB1 return ( x * ( x - 1 ) ) / 2 ; TAB1 k = integer ; TAB1 read k ; TAB1 q = integer with q = 0 ; TAB1 for i = maxn down to 3 ; TAB2 if ( c ( i ) < = k ) ; TAB3 k = k - c ( i ) ; TAB3 for j = 0 to i exclusive ; TAB4 for k = 0 to j exclusive ; TAB5 append k in adj [ j ] ; TAB5 append j in adj [ k ] ; TAB3 q = i ; TAB3 break loop ; TAB1 for i = maxn down to 2 ; TAB2 while ( c2 ( i ) < = k and i < = q ) ; TAB3 k = k - c2 ( i ) ; TAB3 for j = 0 to i exclusive ; TAB4 append j in adj [ q ] ; TAB4 append q in adj [ j ] ; TAB3 increment q ; TAB1 for i = 0 to q exclusive ; TAB2 for j = 0 to adj [ i ] . size ( ) , A [ i ] [ adj [ i ] [ j ] ] = true ; TAB1 print q ; TAB1 for i = 0 to q exclusive ; TAB2 for j = 0 to q exclusive , print A [ i ] [ j ] ; TAB2 print new line ;	const int maxn = 100 + 10 ; vector < int > adj [ maxn ] ; bool A [ maxn ] [ maxn ] ; int c ( int x ) { return ( x * ( x - 1 ) * ( x - 2 ) ) / 6 ; } int c2 ( int x ) { return ( x * ( x - 1 ) ) / 2 ; } int main ( ) { int k ; cin >> k ; int q = 0 ; for ( int i = maxn ; i >= 3 ; i -- ) if ( c ( i ) <= k ) { k -= c ( i ) ; for ( int j = 0 ; j < i ; j ++ ) for ( int k = 0 ; k < j ; k ++ ) { adj [ j ] . push_back ( k ) ; adj [ k ] . push_back ( j ) ; } q = i ; break ; } for ( int i = maxn ; i >= 2 ; i -- ) while ( c2 ( i ) <= k && i <= q ) { k -= c2 ( i ) ; for ( int j = 0 ; j < i ; j ++ ) { adj [ q ] . push_back ( j ) ; adj [ j ] . push_back ( q ) ; } q ++ ; } for ( int i = 0 ; i < q ; i ++ ) for ( int j = 0 ; j < adj [ i ] . size ( ) ; j ++ ) A [ i ] [ adj [ i ] [ j ] ] = true ; cout << q << endl ; for ( int i = 0 ; i < q ; i ++ ) { for ( int j = 0 ; j < q ; j ++ ) cout << A [ i ] [ j ] ; cout << endl ; } return 0 ; }
TAB0 declare constant long long INF = 1e18 ; TAB1 declare string s ; TAB1 read s ; TAB1 declare integers i = 0 , n = integer casted size of s ; TAB1 while i is less than n and s [ i ] is ' a ' , increment i ; TAB1 if i is n ; TAB2 let s [ n - 1 ] be ' z ' ; TAB2 print s and newline ; TAB1 while i is less than n and s [ i ] is not ' a ' , decrement s [ increment i ] ; TAB1 print s and newline ;	const long long INF = 1e18 ; int main ( ) { string s ; cin >> s ; int i = 0 , n = ( int ) ( s ) . size ( ) ; while ( i < n and s [ i ] == ' a ' ) ++ i ; if ( i == n ) { s [ n - 1 ] = ' z ' ; cout << s << endl ; return 0 ; } while ( i < n and s [ i ] != ' a ' ) -- s [ i ++ ] ; cout << s << endl ; }
TAB0 declare constant integer MAXN = 2e5 + 10 ; TAB1 str is a new string ; TAB1 read variable str from the input ; TAB1 create new integers cnta , cntb and cntc = 0 ; TAB1 flag is an integer with value 0 ; TAB1 in a for loop , change i from 0 to length of str exclusive ; TAB2 if str [ i - 1 ] is greater than str [ i ] , change the value of flag to 1 ; TAB2 if str [ i ] = ' a ' , increment cnta ; TAB2 if str [ i ] = ' b ' , increment cntb by one ; TAB2 if str [ i ] = ' c ' , add 1 to cntc ; TAB1 if flag is not 0 ; TAB2 print " NO " ; TAB1 else ; TAB2 if ( cnta = cntc or cntc = cntb ) and none of cnta , cntb and cntc is equal to 0 ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " to the standard output ;	const int MAXN = 2e5 + 10 ; int main ( ) { string str ; cin >> str ; int cnta = 0 , cntb = 0 , cntc = 0 ; int flag = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i - 1 ] > str [ i ] ) flag = 1 ; if ( str [ i ] == ' a ' ) cnta ++ ; if ( str [ i ] == ' b ' ) cntb ++ ; if ( str [ i ] == ' c ' ) cntc ++ ; } if ( flag ) { cout << " NO " << endl ; return 0 ; } else { if ( ( cnta == cntc || cntc == cntb ) && cnta != 0 && cntb != 0 && cntc != 0 ) { cout << " YES " << endl ; } else cout << " NO " << endl ; } return 0 ; }
TAB0 declare integer array dx = { - 1 , 0 , 0 } ; TAB0 declare integer array dy = { 0 , 1 , - 1 } ; TAB0 declare integer array prime size 10000002 ; TAB0 declare ispal with integer n as argument , returning boolean ; TAB1 declare integers rem initialized with 0 , orginal initialized with 0 ; TAB1 let orginal be n ; TAB1 while n is greater than 0 ; TAB2 let rem be rem * 10 + n % 10 ; TAB2 let n be n / 10 ; TAB1 return ( original is rem ) from function ; TAB0 declare seive with no arguments , returning void ; TAB1 let prime [ 1 ] be 1 ; TAB1 for i = 1 to 1e7 inclusive ; TAB2 if not prime [ i ] ; TAB3 for j = i * 2 to 1e7 inclusive , incrementing j by i , let prime [ j ] be 1 ; TAB1 run seive ; TAB1 declare boolean done = 0 ; TAB1 declare long longs n , pal initialized with 0 , pr initialized with 0 , p , q , ans initialized with 0 ; TAB1 read p and q ; TAB1 for i = 1 to 1e7 inclusive ; TAB2 if not prime [ i ] , increment pr ; TAB2 if run ispal with i as argument is true , increment pal ; TAB2 if pr * q is less than or equal to pal * p ; TAB3 let ans be i ; TAB3 let done be 1 ; TAB1 if done is true ; TAB2 print ans and " \ n " ; TAB1 else ; TAB2 print " Palindromic tree is better than splay tree \ n " ;	int dx [ ] = { - 1 , 0 , 0 } ; int dy [ ] = { 0 , 1 , - 1 } ; int prime [ 10000002 ] ; bool ispal ( int n ) { int rem ( 0 ) , orginal ( 0 ) ; orginal = n ; while ( n > 0 ) { rem = rem * 10 + n % 10 ; n /= 10 ; } return ( orginal == rem ) ; } void seive ( ) { prime [ 1 ] = 1 ; for ( long long i = 1 ; i <= 1e7 ; i ++ ) { if ( ! prime [ i ] ) { for ( long long j = i * 2 ; j <= 1e7 ; j += i ) { prime [ j ] = 1 ; } } } } int main ( ) { seive ( ) ; bool done = 0 ; long long n , pal ( 0 ) , pr ( 0 ) , p , q , ans ( 0 ) ; cin >> p >> q ; for ( int i = 1 ; i <= 1e7 ; i ++ ) { if ( ! prime [ i ] ) { pr ++ ; } if ( ispal ( i ) ) { pal ++ ; } if ( pr * q <= pal * p ) { ans = i ; done = 1 ; } } if ( done ) { cout << ans << " \n " ; } else cout << " Palindromic tree is better than splay tree\n " ; return 0 ; }
TAB1 s1 = array of characters of length 10 , s2 = array of characters of length 10 ; TAB1 read s1 ; TAB1 read s2 ; TAB1 let x , y be integers ; TAB1 if string compare of s1 and monday equals 0 ; TAB2 x is equal to 1 ; TAB1 else if string compare of s1 and tuesday equals 0 ; TAB2 x is equal to 2 ; TAB1 else if string compare of s1 and wednesday equals 0 ; TAB2 x is equal to 3 ; TAB1 else if string compare of s1 and thursday equals 0 ; TAB2 x is equal to 4 ; TAB1 else if string compare of s1 and friday equals 0 ; TAB2 x is equal to 5 ; TAB1 else if string compare of s1 and saturday equals 0 ; TAB2 x is equal to 6 ; TAB1 else if string compare of s1 and sunday equals 0 ; TAB2 x is equal to 7 ; TAB1 if string compare of s2 and monday equals 0 ; TAB2 y is equal to 1 ; TAB1 else if string compare of s2 and tuesday equals 0 ; TAB2 y is equal to 2 ; TAB1 else if string compare of s2 and wednesday equals 0 ; TAB2 y is equal to 3 ; TAB1 else if string compare of s2 and thursday equals 0 ; TAB2 y is equal to 4 ; TAB1 else if string compare of s2 and friday equals 0 ; TAB2 y is equal to 5 ; TAB1 else if string compare of s2 and saturday equals 0 ; TAB2 y is equal to 6 ; TAB1 else if string compare of s2 and sunday equals 0 ; TAB2 y is equal to 7 ; TAB1 the integer value of x1 = x + 31 modulo 7 ; TAB1 if x1 is greater than 7 , x1 = x1modulo 7 ; TAB1 the integer value of x2 = x + 30 modulo 7 ; TAB1 if x2 is greater than 7 , x2 = x2 modulo 7 ; TAB1 the integer value of x3 = x + 28 modulo 7 ; TAB1 if x3 is greater than 7 , x3 = x3 modulo 7 ; TAB1 if x1 equals y or x2 equals y or x3 equals y ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 print NO and newline ;	int main ( ) { char s1 [ 10 ] , s2 [ 10 ] ; cin >> s1 ; cin >> s2 ; int x , y ; if ( strcmp ( s1 , " monday " ) == 0 ) x = 1 ; else if ( strcmp ( s1 , " tuesday " ) == 0 ) x = 2 ; else if ( strcmp ( s1 , " wednesday " ) == 0 ) x = 3 ; else if ( strcmp ( s1 , " thursday " ) == 0 ) x = 4 ; else if ( strcmp ( s1 , " friday " ) == 0 ) x = 5 ; else if ( strcmp ( s1 , " saturday " ) == 0 ) x = 6 ; else if ( strcmp ( s1 , " sunday " ) == 0 ) x = 7 ; if ( strcmp ( s2 , " monday " ) == 0 ) y = 1 ; else if ( strcmp ( s2 , " tuesday " ) == 0 ) y = 2 ; else if ( strcmp ( s2 , " wednesday " ) == 0 ) y = 3 ; else if ( strcmp ( s2 , " thursday " ) == 0 ) y = 4 ; else if ( strcmp ( s2 , " friday " ) == 0 ) y = 5 ; else if ( strcmp ( s2 , " saturday " ) == 0 ) y = 6 ; else if ( strcmp ( s2 , " sunday " ) == 0 ) y = 7 ; int x1 = x + 31 % 7 ; if ( x1 > 7 ) x1 %= 7 ; int x2 = x + 30 % 7 ; if ( x2 > 7 ) x2 %= 7 ; int x3 = x + 28 % 7 ; if ( x3 > 7 ) x3 %= 7 ; if ( ( x1 == y ) || ( x2 == y ) || ( x3 == y ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 n , i , j , s = integers ; TAB1 while read n , s ; TAB2 x , y = integer array of size n + 5 ; TAB2 m = map from integer to integer ; TAB2 it = iterator map from integer to integer ; TAB2 mx , c = integer with mx = - 1 , c = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read x [ i ] , y [ i ] ; TAB3 if ( x [ i ] is s and y [ i ] is 0 ) ; TAB4 mx = max of mx and 0 ; TAB3 else if ( x [ i ] < s ) ; TAB4 mx = max of mx and ( 100 - y [ i ] ) modulo 100 ; TAB2 print mx ;	int main ( ) { int n , i , j , s ; while ( cin >> n >> s ) { int x [ n + 5 ] , y [ n + 5 ] ; map < int , int > m ; map < int , int > :: iterator it ; int mx = - 1 , c = 0 ; for ( i = 0 ; i < n ; i ++ ) { cin >> x [ i ] >> y [ i ] ; if ( x [ i ] == s && y [ i ] == 0 ) { mx = max ( mx , 0 ) ; } else if ( x [ i ] < s ) { mx = max ( mx , ( 100 - y [ i ] ) % 100 ) ; } } cout << mx << endl ; } return 0 ; }
TAB0 declare integers vector array mp with size 150005 ; TAB0 create int64_t variables n , m , a , b , ans and size and an array of int64_t called mark with 150005 elements ; TAB0 void function dfs with int arguments x and prev ; TAB1 change mark [ x ] to 1 ; TAB1 if prev ! = length of mp [ x ] or size > length of mp [ x ] , set ans to 1 ; TAB1 increase size by one ; TAB1 for i = 0 to length of mp [ x ] exclusive ; TAB2 if mark [ mp [ x ] [ i ] ] = 0 , call dfs of mp [ x ] [ i ] and length of mp [ x ] ; TAB1 read n and m ; TAB1 loop i from 1 to m inclusive incrementing i ; TAB2 read a and b ; TAB2 push b into mp [ a ] ; TAB2 push a into mp [ b ] ; TAB1 for i from 1 to n inclusive ; TAB2 if mark [ i ] = 0 and mp [ i ] is not empty ; TAB3 assign 0 to size ; TAB3 call function dfs with arguments i and length of mp [ i ] ; TAB1 if ans is true ; TAB2 print " NO \ n " ; TAB1 else ; TAB2 print " YES \ n " ;	vector < int > mp [ 150005 ] ; int64_t n , m , a , b , ans , size , mark [ 150005 ] ; void dfs ( int x , int prev ) { mark [ x ] = 1 ; if ( prev != mp [ x ] . size ( ) || size > mp [ x ] . size ( ) ) ans = 1 ; ++ size ; for ( int i = 0 ; i < mp [ x ] . size ( ) ; i ++ ) if ( mark [ mp [ x ] [ i ] ] == 0 ) dfs ( mp [ x ] [ i ] , mp [ x ] . size ( ) ) ; } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= m ; i ++ ) { cin >> a >> b ; mp [ a ] . push_back ( b ) ; mp [ b ] . push_back ( a ) ; } for ( int i = 1 ; i <= n && ! ans ; i ++ ) if ( mark [ i ] == 0 && mp [ i ] . size ( ) != 0 ) { size = 0 ; dfs ( i , mp [ i ] . size ( ) ) ; } if ( ans ) cout << " NO\n " ; else cout << " YES\n " ; return 0 ; }
TAB1 create int n and t ; TAB1 while read n and t ; TAB2 if t < 10 ; TAB3 while decrement n , print t ; TAB2 else ; TAB3 if n = 1 ; TAB4 print - 1 ; TAB3 else ; TAB4 print 1 ; TAB4 decrement n ; TAB4 while decrement n , print 0 ; TAB2 print a newline ;	int main ( ) { int n , t ; while ( cin >> n >> t ) { if ( t < 10 ) while ( n -- ) { cout << t ; } else { if ( n == 1 ) cout << - 1 ; else { cout << 1 ; n -- ; while ( n -- ) cout << 0 ; } } cout << endl ; } return 0 ; }
TAB1 let a , b , need be integers with need = 0 ; TAB1 read a and b ; TAB1 let n be an integer equal to a / b ; TAB1 while n decrements by 1 ; TAB2 for i = 0 to b exclusive ; TAB3 let c be a character equal to 97 + i ; TAB3 print c ; TAB3 add 1 to need ; TAB1 set need to a - need ; TAB1 for i = 0 to need exclusive ; TAB2 let c be a character equal to 97 + i ; TAB2 print c ; TAB1 print a newline ;	int main ( ) { int a , b , need = 0 ; cin >> a >> b ; int n = a / b ; while ( n -- ) { for ( int i = 0 ; i < b ; i ++ ) { char c = 97 + i ; cout << c ; need ++ ; } } need = a - need ; for ( int i = 0 ; i < need ; i ++ ) { char c = 97 + i ; cout << c ; } cout << endl ; return 0 ; }
TAB0 make integer n ; TAB0 make long long array a of size 100001 ; TAB0 make long long array b of size 100001 ; TAB0 make long long array dp of size 100001 ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 for i = 1 to n - 1 inclusive , set b [ i ] to abs of a [ i ] - a [ i + 1 ] ; TAB1 set dp [ 1 ] to 0 ; TAB1 for i = 2 to n inclusive ; TAB2 if i is even ; TAB3 set dp [ i ] to dp [ i - 1 ] + b [ i - 1 ] ; TAB2 else ; TAB3 set dp [ i ] to dp [ i - 1 ] - b [ i - 1 ] ; TAB1 sort elements in dp 1 through 1 + n ; TAB1 print dp [ n ] - dp [ 1 ] ;	int n ; long long a [ 100001 ] ; long long b [ 100001 ] ; long long dp [ 100001 ] ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 1 ; i <= n - 1 ; i ++ ) { b [ i ] = abs ( a [ i ] - a [ i + 1 ] ) ; } dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i - 1 ] + b [ i - 1 ] ; } else { dp [ i ] = dp [ i - 1 ] - b [ i - 1 ] ; } } sort ( dp + 1 , dp + 1 + n ) ; cout << dp [ n ] - dp [ 1 ] << ' \n ' ; return 0 ; }
TAB0 declare constant integer N with N = 110 ; TAB0 declare n as integer , a size N as integer array ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 sort from a to a + n ; TAB1 for i = 0 to n exclusive , print a [ i ] , ' \ n ' if i + 1 is n , else ' ' ;	const int N = 110 ; int n , a [ N ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << ( i + 1 == n ? ' \n ' : '   ' ) ; } return 0 ; }
TAB1 declare string variable s ; TAB1 read input to s ; TAB1 declare integer is = 0 ; TAB1 for i from 0 to length of s - 2 exclusive ; TAB2 declare vector of chars v ; TAB2 loop j from 0 to 3 exclusive , pushing s [ i + j ] to v ; TAB2 sort v ; TAB2 if v [ 0 ] = ' A ' and v [ 1 ] = ' B ' and v [ 2 ] = ' C ' , change is to 1 ; TAB1 if is ! = 0 ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	int main ( ) { string s ; cin >> s ; int is = 0 ; for ( int i = 0 ; i < ( int ) s . size ( ) - 2 ; i ++ ) { vector < char > v ; for ( int j = 0 ; j < 3 ; j ++ ) v . push_back ( s [ i + j ] ) ; sort ( v . begin ( ) , v . end ( ) ) ; if ( v [ 0 ] == ' A ' && v [ 1 ] == ' B ' && v [ 2 ] == ' C ' ) is = 1 ; } if ( is ) cout << " Yes " << endl ; else cout << " No " << endl ; }
TAB1 declare int variables x and y ; TAB1 read x and y ; TAB1 if x and y are both false or ( x = 1 and y is false ) ; TAB2 print 0 ; TAB2 print " \ n " ; TAB1 declare int up = max of absolute value of x and max of absolute value of y * 4 ; TAB1 if x > y or ( x > 0 and x = y ) ; TAB2 if x > y and abs ( x ) < = abs ( y ) ; TAB3 print up ; TAB2 else if x > 0 and y < and abs ( x ) - abs ( y ) = 1 ; TAB3 print up - 4 ; TAB2 else ; TAB3 print up - 3 ; TAB1 else ; TAB2 if x < y and abs ( x ) < = abs ( y ) ; TAB3 print up - 2 ; TAB2 else ; TAB3 print up - 1 ; TAB1 print " \ n " ;	int main ( ) { int x , y ; cin >> x >> y ; if ( ( ! x && ! y ) || ( x == 1 && ! y ) ) { cout << 0 ; cout << " \n " ; return 0 ; } int up = max ( abs ( x ) , abs ( y ) ) * 4 ; if ( x > y || ( x > 0 && x == y ) ) { if ( x > y && abs ( x ) <= abs ( y ) ) cout << up ; else if ( x > 0 && y < 0 && abs ( x ) - abs ( y ) == 1 ) cout << ( up - 4 ) ; else cout << ( up - 3 ) ; } else { if ( x < y && abs ( x ) <= abs ( y ) ) cout << ( up - 2 ) ; else cout << up - 1 ; } cout << " \n " ; return 0 ; }
TAB1 define long longs n , m and i ; TAB1 create new array of characters s with 200001 elements ; TAB1 read n and s from the input and keep the loop going ; TAB2 define integer cnt = 0 ; TAB2 for i from 0 to n exclusive ; TAB3 if s [ i ] is equal to ' < ' ; TAB4 increment cnt ; TAB3 else ; TAB4 break ; TAB2 start for loop from i = n - 1 to 0 inclusive counting down by 1 ; TAB3 if s [ i ] is equal to ' > ' ; TAB4 increment cnt by one ; TAB3 else ; TAB4 break ; TAB2 print cnt ;	int main ( ) { long long n , m , i ; char s [ 200001 ] ; while ( cin >> n >> s ) { int cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' < ' ) cnt ++ ; else break ; } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' > ' ) cnt ++ ; else break ; } cout << cnt << endl ; } return 0 ; }
TAB1 let n and p be integers ; TAB1 input n and p ; TAB1 let a be a string ; TAB1 let b be an integer with b set to 97 ; TAB1 for i = 0 to n exclusive , add 97 + i modulo p to a ; TAB1 print a ;	int main ( ) { int n , p ; cin >> n >> p ; string a ; int b = 97 ; for ( int i = 0 ; i < n ; i ++ ) { a += 97 + i % p ; } cout << a << endl ; }
TAB1 a is an array of characters with 100 elements ; TAB1 ans is a new integer with value 0 ; TAB1 read user input to a ; TAB1 while a [ 0 ] ! = a [ 4 ] or a [ 1 ] ! = a [ 3 ] ; TAB2 if a [ 0 ] = ' 2 ' and a [ 1 ] = ' 3 ' and a [ 3 ] = ' 5 ' and a [ 4 ] = ' 9 ' ; TAB3 change ans to the sum of ans and 1 ; TAB3 stop the loop ; TAB2 increase a [ 4 ] by 1 ; TAB2 increment ans ; TAB2 if a [ 4 ] is equal to 58 ; TAB3 assign ' 0 ' to a [ 4 ] ; TAB3 change a [ 3 ] to the sum of a [ 3 ] and 1 ; TAB2 if a [ 3 ] = 54 ; TAB3 assign the new value = ' 0 ' to a [ 3 ] ; TAB3 add 1 to a [ 1 ] ; TAB2 if a [ 1 ] is equal to 58 ; TAB3 set a [ 1 ] to ' 0 ' ; TAB3 increase a [ 0 ] by 1 ; TAB1 print ans to the standard output ;	int main ( ) { char a [ 100 ] ; int ans = 0 ; cin >> a ; while ( a [ 0 ] != a [ 4 ] || a [ 1 ] != a [ 3 ] ) { if ( a [ 0 ] == ' 2 ' && a [ 1 ] == ' 3 ' && a [ 3 ] == ' 5 ' && a [ 4 ] == ' 9 ' ) { ans += 1 ; break ; } a [ 4 ] += 1 ; ans ++ ; if ( a [ 4 ] == 58 ) { a [ 4 ] = ' 0 ' ; a [ 3 ] += 1 ; } if ( a [ 3 ] == 54 ) { a [ 3 ] = ' 0 ' ; a [ 1 ] += 1 ; } if ( a [ 1 ] == 58 ) { a [ 1 ] = ' 0 ' ; a [ 0 ] += 1 ; } } cout << ans << endl ; return 0 ; }
TAB1 declare integers a , b , c , d ; TAB1 read a , b , c , d ; TAB1 if a % 2 is 0 and c % 2 is 0 and absolute value of ( b - 2 ) % 2 is 1 ; TAB2 print " - 1 " , newline ; TAB2 exit program with code 0 ; TAB1 for i = 0 to 10000000 inclusive ; TAB2 declare integer p = a * i + b ; TAB2 if ( p - d ) % c is 0 and p is greater than or equal to d ; TAB3 print p , newline ; TAB3 exit program with code 0 ; TAB1 print " - 1 " and newline ;	int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; if ( a % 2 == 0 && c % 2 == 0 && abs ( b - d ) % 2 == 1 ) { cout << " -1 " << endl ; exit ( 0 ) ; } for ( int i = 0 ; i <= 10000000 ; i ++ ) { int p = a * i + b ; if ( ( p - d ) % c == 0 && p >= d ) { cout << p << endl ; exit ( 0 ) ; } } cout << " -1 " << endl ; return 0 ; }
TAB0 create constant integer maxn = 1e5 + 100 ; TAB0 let w and v be vector integer array of size maxn ; TAB0 a = long long integer array of size maxn ; TAB0 d = array of boolean of size maxn ; TAB0 c = 2D long long integer array of size maxn by 5 ; TAB0 n , m = long long integers ; TAB0 mark = array of booleans of size maxn by 2 ; TAB0 into the function dfs1 which takes a long long integer i ; TAB1 set c [ i ] [ 0 ] to 1 ; TAB1 set mark [ i ] [ 0 ] to 1 ; TAB1 for y = 0 to size of v [ i ] exclusive ; TAB2 if mark [ v [ i ] [ y ] ] [ 0 ] is not true then call dfs1 ( v [ i ] [ y ] ) ; TAB0 into the function dfs2 which takes a long long integer i ; TAB1 set mark [ i ] [ 1 ] = 1 ; ; TAB1 set c [ i ] [ 1 ] = 1 ; TAB1 if a [ i ] = 1 then return ; TAB1 for y = 0 to size of w [ i ] exclusive ; TAB2 if mark [ w [ i ] [ y ] ] [ 1 ] is false then call dfs2 ( w [ i ] [ y ] ; TAB1 read n and m ; TAB1 for y = 1 to n inclusive ; TAB2 read a [ y ] ; TAB2 if a [ y ] is 1 then add y to end of v [ 100000 + 1 ] ; TAB2 if a [ y ] is 2 then add y to end of w [ 100000 + 1 ] ; TAB1 while m is true , decrement m and do the following ; TAB2 create long long integers i , j ; TAB2 read i and j ; TAB2 add i to end of v [ i ] ; TAB2 add i to end of w [ j ] ; TAB1 call dfs1 with argument 100000 + 1 ; TAB1 call dfs2 ( 100000 + 1 ) ; TAB1 for y = 0 to n inclsuive print c [ y ] [ 0 ] & & c [ y ] [ 1 ] ;	const int maxn = 1e5 + 100 ; vector < int > v [ maxn ] , w [ maxn ] ; long long a [ maxn ] ; bool d [ maxn ] ; long long c [ maxn ] [ 5 ] ; long long n , m ; bool mark [ maxn ] [ 2 ] ; void dfs1 ( long long i ) { c [ i ] [ 0 ] = 1 ; mark [ i ] [ 0 ] = 1 ; for ( long long y = 0 ; y < v [ i ] . size ( ) ; y ++ ) { if ( ! mark [ v [ i ] [ y ] ] [ 0 ] ) { dfs1 ( v [ i ] [ y ] ) ; } } } void dfs2 ( long long i ) { mark [ i ] [ 1 ] = 1 ; c [ i ] [ 1 ] = 1 ; if ( a [ i ] == 1 ) return ; for ( long long y = 0 ; y < w [ i ] . size ( ) ; y ++ ) { if ( ! mark [ w [ i ] [ y ] ] [ 1 ] ) { dfs2 ( w [ i ] [ y ] ) ; } } } int main ( ) { cin >> n >> m ; for ( long long y = 1 ; y <= n ; y ++ ) { cin >> a [ y ] ; if ( a [ y ] == 1 ) { v [ 100000 + 1 ] . push_back ( y ) ; } if ( a [ y ] == 2 ) { w [ 100000 + 1 ] . push_back ( y ) ; } } while ( m -- ) { long long i , j ; cin >> i >> j ; v [ i ] . push_back ( j ) ; w [ j ] . push_back ( i ) ; } dfs1 ( 100000 + 1 ) ; dfs2 ( 100000 + 1 ) ; for ( long long y = 1 ; y <= n ; y ++ ) { cout << ( c [ y ] [ 0 ] && c [ y ] [ 1 ] ) << endl ; } }
TAB0 let MOD , maxN = integer constants with MOD = 1000000007 and maxN = 5005 ; TAB0 let i , j , sum = integers with sum = 0 and dp = maxN arrays of integers of size maxN ; TAB0 let s , t = string ; TAB1 read s , t ; TAB1 for i = 1 to size of s inclusive do the following ; TAB2 for j = 1 to size of t inclusive do the following ; TAB3 set dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; TAB3 if s [ i - 1 ] is t [ j - 1 ] set dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ; TAB3 set dp [ i ] [ j ] = dp [ i ] [ j ] modulo MOD ; TAB1 for i = 1 to size of s inclusive set sum = dp [ i ] [ size of t ] modulo MOS ; TAB1 print sum ;	const int MOD = 1e9 + 7 , maxN = 5e3 + 5 ; int i , j , sum = 0 , dp [ maxN ] [ maxN ] ; string s , t ; int main ( ) { cin >> s >> t ; for ( i = 1 ; i <= s . size ( ) ; i ++ ) { for ( j = 1 ; j <= t . size ( ) ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + 1 ; } dp [ i ] [ j ] %= MOD ; } } for ( i = 1 ; i <= s . size ( ) ; i ++ ) { sum = ( sum + dp [ i ] [ t . size ( ) ] ) % MOD ; } cout << sum << endl ; return 0 ; }
TAB0 make constant integer MAX_N = 1000 + 10 ; TAB0 create int array in of size MAX_N and out of size MAX_N ; TAB0 make int array C of size MAX_N with array of size MAX_N ; TAB0 let int n ; TAB1 create int e ; TAB1 read n and e ; TAB1 for i = 0 to e exclusive ; TAB2 make ints a , b , and c ; TAB2 read a , b , and c ; TAB2 set C [ a ] [ b ] to c ; TAB2 set in [ b ] to a ; TAB2 set out [ a ] to b ; TAB1 make int cnt = 0 ; TAB1 for i = 1 to n ; TAB2 if in [ i ] is 0 ; TAB3 if out [ i ] is not equal to 0 , increment cnt ; TAB1 display cnt ; TAB1 for i = 1 to n ; TAB2 if in [ i ] is equal to 0 ; TAB3 if out [ i ] is not equal to 0 ; TAB4 make int mind = INT_MAX ; TAB4 create int u = i ; TAB4 loop indefinitely ; TAB5 create int v = out [ i ] ; TAB5 if v is falsy , break loop ; TAB5 set mind to min of mind and C [ u ] [ v ] ; TAB5 set u to v ; TAB4 show i , " " , u , " " , and mind ;	const int MAX_N = 1000 + 10 ; int in [ MAX_N ] = { } , out [ MAX_N ] = { } ; int C [ MAX_N ] [ MAX_N ] ; int n ; int main ( ) { int e ; cin >> n >> e ; for ( int i = 0 ; i < e ; ++ i ) { int a , b , c ; cin >> a >> b >> c ; C [ a ] [ b ] = c ; in [ b ] = a ; out [ a ] = b ; } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( in [ i ] == 0 ) { if ( out [ i ] != 0 ) { ++ cnt ; } } } cout << cnt << endl ; for ( int i = 1 ; i <= n ; ++ i ) { if ( in [ i ] == 0 ) { if ( out [ i ] != 0 ) { int mind = INT_MAX ; int u = i ; while ( true ) { int v = out [ u ] ; if ( ! v ) break ; mind = min ( mind , C [ u ] [ v ] ) ; u = v ; } cout << i << "   " << u << "   " << mind << endl ; } } } return 0 ; }
TAB0 arr1 = array of integer of size 110 ; TAB0 arr2 = array of integer of size 110 ; TAB1 create integr i , j , ind , count , n with value ind = 0 and count = 0 ; TAB1 read n ; TAB1 read n values of array arr1 and arr2 ; TAB1 for i = 1 to n inclusive ; TAB2 set ind = 0 ; TAB2 for j = 1 to n inclusive ; TAB3 if i is not equal to j ; TAB4 if arr2 [ j ] = arr1 [ i ] then set ind = 1 ; TAB2 if ind is false then increment count ; TAB1 print count ;	int arr1 [ 110 ] ; int arr2 [ 110 ] ; int main ( ) { int i , j , ind = 0 , count = 0 , n ; cin >> n ; for ( i = 1 ; i <= n ; ++ i ) cin >> arr1 [ i ] >> arr2 [ i ] ; for ( i = 1 ; i <= n ; ++ i ) { ind = 0 ; for ( j = 1 ; j <= n ; ++ j ) { if ( i != j ) { if ( arr2 [ j ] == arr1 [ i ] ) ind = 1 ; } } if ( ! ind ) count ++ ; } cout << count << endl ; return 0 ; }
TAB1 let n , a , b , c , d be long integers ; TAB1 read a , b ; TAB1 read c , d ; TAB1 read n ; TAB1 cross is a long integer equal to 0 ; TAB1 let x , y , z be long integers ; TAB1 for long integer i = 0 to n exclusive ; TAB2 read x , y , z ; TAB2 if ( a * x + b * y + z ) is greater than 0 and value of ( c * x + d * y + z ) is less than 0 , increment cross by 1 ; TAB2 if ( a * x + b * y + z ) is greater than 0 and value of ( c * x + d * y + z ) is less than 0 , increment cross by 1 ; TAB1 print cross value and new line ;	int main ( ) { long long n , a , b , c , d ; cin >> a >> b ; cin >> c >> d ; cin >> n ; long long cross = 0 ; long long x , y , z ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> x >> y >> z ; if ( ( a * x + b * y + z ) > 0 && ( c * x + d * y + z ) < 0 ) { cross ++ ; } if ( ( a * x + b * y + z ) < 0 && ( c * x + d * y + z ) > 0 ) { cross ++ ; } } cout << cross << endl ; return 0 ; }
TAB0 declare new constant integer maxn = 1e5 + 5 ; TAB0 new constant long long variable mod with value 1e9 + 7 ; TAB1 define new long long n ; TAB1 create long longs a and b ; TAB1 read variable n from the input ; TAB1 read a and b from the user input ; TAB1 if a + b is greater than n + 1 ; TAB2 print " Black " ; TAB1 else ; TAB2 print " White " ;	const int maxn = ( int ) 1e5 + 5 ; const long long mod = 1e9 + 7 ; int main ( ) { long long n ; long long a , b ; cin >> n ; cin >> a >> b ; if ( a + b > n + 1 ) cout << " Black " << endl ; else cout << " White " << endl ; return 0 ; }
TAB0 create long long vector v of size 0 ; TAB1 for len = 1 to len 10 ; TAB2 for mask = 0 to 1 < < len exclusive ; TAB3 make long long int val = 0 ; TAB3 for i = 0 to len exclusive ; TAB4 if mask & ( 1 < < i ) ; TAB5 set val to val * 10 + 4 ; TAB4 else do ; TAB5 multiply val by 10 + 7 ; TAB3 append val to v ; TAB1 sort v ; TAB1 create long long ints l and r ; TAB1 read l and r ; TAB1 make long long ans = 0 ; TAB1 for loop while l is less than or equal to r ; TAB2 create long long val = * lower_bound ( v . begin ( ) , v . end ( ) , l ) ; TAB2 make long long int count = val - 1 + 1 ; TAB2 if val is greater than 4 , set count to r - 1 + 1 ; TAB2 set ans to ans + val * count ; TAB2 set l to val + 1 ; TAB1 print ans ;	vector < long long > v ( 0 ) ; int main ( ) { for ( int len = 1 ; len <= 10 ; ++ len ) for ( int mask = 0 ; mask < ( 1 << len ) ; ++ mask ) { long long val = 0 ; for ( int ( i ) = 0 ; ( i ) < ( len ) ; ++ ( i ) ) if ( mask & ( 1 << i ) ) val = val * 10 + 4 ; else val = val * 10 + 7 ; v . push_back ( val ) ; } sort ( ( v ) . begin ( ) , ( v ) . end ( ) ) ; long long l , r ; cin >> l >> r ; long long ans = 0 ; for ( ; l <= r ; ) { long long val = * lower_bound ( v . begin ( ) , v . end ( ) , l ) ; long long count = val - l + 1 ; if ( val > r ) count = r - l + 1 ; ans += val * count ; l = val + 1 ; } cout << ans << endl ; }
TAB0 k = long long int ; TAB0 ara = array of 19 long long int ; TAB0 v = vector of long long int ; TAB0 y = iterator on vector of long long int ; TAB0 function permu ( get long long int pos , return nothing ) ; TAB1 if pos is k + 1 ; TAB2 i = long long int , p = 1 , l = 0 ; TAB2 for i = k down to 1 inclusive ; TAB3 add ara [ i ] * p to l ; TAB3 multiply p by 10 ; TAB2 add l at end of v ; TAB2 return ; TAB1 ara [ pos ] = 4 ; TAB1 permu ( pos + 1 ) ; TAB1 ara [ pos ] = 7 ; TAB1 permu ( pos + 1 ) ; TAB1 n , m , f , r = long long int , p and flag = 0 ; TAB1 read n , m ; TAB1 for k = 1 to 11 inclusive permu ( 1 ) ; TAB1 sort v ; TAB1 iterating y on v ; TAB2 f = item pointed by v ; TAB2 if n > = f and m < = f and flag is 0 ; TAB3 add ( m - n + 1 ) * f to p ; TAB3 flag = 2 ; TAB2 if n < = f and flag is 0 ; TAB3 flag = 1 ; TAB3 add ( f - n + 1 ) * f to p ; TAB3 r = f ; TAB2 if m < = f and flag is 1 ; TAB3 flag = 2 ; TAB3 add ( m - r ) * f to p ; TAB2 else if flag is 1 ; TAB3 add ( f - r ) * f to p ; TAB3 r = f ; TAB1 print p ;	long long int k ; long long int ara [ 19 ] ; vector < long long int > v ; vector < long long int > :: iterator y ; void permu ( long long int pos ) { if ( pos == k + 1 ) { long long int i , p = 1 , l = 0 ; for ( i = k ; i >= 1 ; i -- ) { l += ( ara [ i ] * p ) ; p = p * 10 ; } v . push_back ( l ) ; return ; } ara [ pos ] = 4 ; permu ( pos + 1 ) ; ara [ pos ] = 7 ; permu ( pos + 1 ) ; } int main ( ) { long long int n , m , f , p = 0 , flag = 0 , r ; cin >> n >> m ; for ( k = 1 ; k <= 11 ; k ++ ) { permu ( 1 ) ; } sort ( v . begin ( ) , v . end ( ) ) ; for ( y = v . begin ( ) ; y != v . end ( ) ; y ++ ) { f = * y ; if ( n <= f && m <= f && flag == 0 ) { p += ( m - n + 1 ) * f ; flag = 2 ; } else if ( n <= f && flag == 0 ) { flag = 1 ; p += ( ( f - n ) + 1 ) * f ; r = f ; } else if ( m <= f && flag == 1 ) { flag = 2 ; p += ( m - r ) * f ; } else if ( flag == 1 ) { p += ( f - r ) * f ; r = f ; } } cout << p << endl ; }
TAB1 a , b , s , k = integers ; TAB1 read a , b , s ; TAB1 if ( a is 0 and b is 0 and s is 2 ) ; TAB2 print Yes ; TAB1 else ; TAB2 k = abs ( a ) + abs ( b ) ; TAB2 if ( s > = k and ( s - k ) modulo 2 is 0 ) ; TAB3 print Yes ; TAB2 else ; TAB3 print No ;	int main ( ) { int a , b , s , k ; cin >> a >> b >> s ; if ( a == 0 && b == 0 && s == 2 ) { cout << " Yes " << endl ; } else { k = abs ( a ) + abs ( b ) ; if ( s >= k && ( s - k ) % 2 == 0 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } }
TAB1 let p be a string ; TAB1 read p ; TAB1 the string value of ans is equal to space ; TAB1 for i = 0 to length of p exclusive ; TAB2 if p [ i ] equals / ; TAB3 while i is less than length of p and p [ i ] equals / , increment i by 1 ; TAB3 ans = ans + / ; TAB2 if i is less than length of p , increment ans by p [ i ] ; TAB1 if ans . size ( ) is greater than 1 and ans [ ans . size ( ) - 1 ] is equal to / , ans is equal to ans . substr ( 0 , ans . size ( ) - 1 ) ; TAB1 print ans and newline ;	int main ( ) { string p ; cin >> p ; string ans = "  " ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { if ( p [ i ] == ' / ' ) { while ( i < p . size ( ) && p [ i ] == ' / ' ) i ++ ; ans += ' / ' ; } if ( i < p . size ( ) ) ans += p [ i ] ; } if ( ans . size ( ) > 1 && ans [ ans . size ( ) - 1 ] == ' / ' ) ans = ans . substr ( 0 , ans . size ( ) - 1 ) ; cout << ans << endl ; }
TAB0 create integer n ; TAB0 create constant integer MAXN with MAXN = 105 ; TAB0 create integer arrays c , occ , with c size MAXN , occ size MAXN ; TAB0 create boolean array vis with size MAXN ; TAB0 declare dfs with integer idx as argument , returning integer ; TAB1 if vis [ idx ] is true , return 0 from function ; TAB1 set vis [ idx ] to true ; TAB1 return 1 + result of run dfs with c [ idx ] as argument , from function ; TAB0 declare gcd with integers a , b as arguments , returning integer ; TAB1 if a is 0 ; TAB2 return b from function ; TAB1 else if b is 0 ; TAB2 return a from function ; TAB1 if a is greater than or equal b , return result of gcd with a % b , b as arguments , from function ; TAB1 return result of run gcd with a , b % a as arguments from function ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read c [ i ] ; TAB2 increment occ [ c [ i ] ] ; TAB1 for i = 1 to n inclusive ; TAB2 if occ [ i ] is not 1 ; TAB3 print - 1 print " \ n " ; TAB1 create integer ans with ans = 1 ; TAB1 for i = 1 to n inclusive ; TAB2 if not vis [ i ] ; TAB3 create integer x with x = result of run dfs with i as argument ; TAB3 if x % 2 is 0 , set x to x / 2 ; TAB3 set ans to ans * x / result of run gcd with ans , x as arguments ; TAB1 print ans print " \ n " ;	int n ; const int MAXN = 105 ; int c [ MAXN ] , occ [ MAXN ] ; bool vis [ MAXN ] ; int dfs ( int idx ) { if ( vis [ idx ] ) return 0 ; vis [ idx ] = true ; return 1 + dfs ( c [ idx ] ) ; } int gcd ( int a , int b ) { if ( a == 0 ) return b ; else if ( b == 0 ) return a ; if ( a >= b ) return gcd ( a % b , b ) ; return gcd ( a , b % a ) ; } int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> c [ i ] ; occ [ c [ i ] ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) if ( occ [ i ] != 1 ) { cout << - 1 << " \n " ; return 0 ; } int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! vis [ i ] ) { int x = dfs ( i ) ; if ( x % 2 == 0 ) x /= 2 ; ans = ans * x / gcd ( ans , x ) ; } cout << ans << " \n " ; return 0 ; }
TAB0 integer t integer maxn = 1e5 + 5 ; TAB0 integers = a [ maxn ] , b [ maxn ] ; TAB0 integer n ; TAB1 integers = c = 0 ; TAB1 integers = cur ; TAB1 read n ; TAB1 set cur to n - 2 ; TAB1 read array a ; TAB1 sort the values of a to a + n ; TAB1 for i = n - 1 to greater than or equal to 0 and cur is greater than 0 do the following ; TAB2 if a [ cur ] > = a [ i ] and cur is greater than - 1 then subtract one from cur ; TAB2 if cur is greater than or equal to 0 then add one to c ; TAB2 minus 1 from cur ; TAB1 output c ;	const int maxn = 1e5 + 5 ; int a [ maxn ] , b [ maxn ] ; int n ; int main ( ) { int c = 0 ; int cur ; cin >> n ; cur = n - 2 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } sort ( a , a + n ) ; for ( int i = n - 1 ; i >= 0 && cur >= 0 ; i -- ) { while ( a [ cur ] >= a [ i ] && cur > - 1 ) cur -- ; if ( cur >= 0 ) c ++ ; cur -- ; } cout << c << endl ; return 0 ; }
TAB0 vowel = array of 6 char filled with vowels ; TAB1 s = string ; TAB1 read s ; TAB1 yes = bool ; TAB1 for i = 0 to size of s exclusive ; TAB2 yes = true ; TAB2 for j = 0 to 6 exclusive ; TAB3 if s [ i ] transformed in lowercase is vowel [ j ] ; TAB4 yes = false ; TAB4 break ; TAB2 if yes print ' . ' , char [ s [ i ] in lowercase ] ; TAB1 print newline ;	char vowel [ 6 ] = { ' a ' , ' o ' , ' y ' , ' e ' , ' u ' , ' i ' } ; int main ( ) { string s ; cin >> s ; bool yes ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { yes = true ; for ( int j = 0 ; j < 6 ; j ++ ) { if ( tolower ( s [ i ] ) == vowel [ j ] ) { yes = false ; break ; } } if ( yes ) { cout << ' . ' << char ( tolower ( s [ i ] ) ) ; } } cout << ' \n ' ; return 0 ; }
TAB1 x1 , y1 = long long integers ; TAB1 read x1 , y1 ; TAB1 x = 1 , y = 0 = long long integers ; TAB1 count set to 0 = long long integer ; TAB1 step equals 1 = long long integers ; TAB1 if x1 is 0 and y1 then do the following ; TAB2 output 0 ; TAB1 if x1 is 1 and y1 then do the following ; TAB2 output 0 ; TAB1 if 1 is true do the following ; TAB2 if x is x1 and y then do the following ; TAB2 y equals y plus step ; TAB2 add one to count ; TAB2 if x = x1 and y1 is less than or equal to y and y1 > = y - step then break ; TAB2 subtract step + 1 from x ; TAB2 add one to count ; TAB2 if y = y1 and x1 > = x and x1 is less than or equal to x + step + 1 then break ; TAB2 subtract step + 1 from y ; TAB2 add one to count ; TAB2 if x = x1 and y1 > = y and y1 is less than or equal to y + step + 1 then break ; TAB2 x equals x plus step + 2 ; TAB2 add one to count ; TAB2 if y = y1 and x1 is less than or equal to x and x1 > = x - step - 2 then break ; TAB2 step equals step plus 2 ; TAB1 write count ;	int main ( ) { long long x1 , y1 ; cin >> x1 >> y1 ; long long x = 1 , y = 0 ; long long count = 0 ; long long step = 1 ; if ( x1 == 0 && y1 == 0 ) { cout << 0 << endl ; return 0 ; } if ( x1 == 1 && y1 == 0 ) { cout << 0 << endl ; return 0 ; } while ( 1 ) { if ( x == x1 && y == y1 ) { break ; } y += step ; count ++ ; if ( x == x1 && y1 <= y && y1 >= y - step ) { break ; } x -= step + 1 ; count ++ ; if ( y == y1 && x1 >= x && x1 <= x + step + 1 ) { break ; } y -= step + 1 ; count ++ ; if ( x == x1 && y1 >= y && y1 <= y + step + 1 ) { break ; } x += step + 2 ; count ++ ; if ( y == y1 && x1 <= x && x1 >= x - step - 2 ) { break ; } step += 2 ; } cout << count << endl ; }
TAB1 declare integers n , i = 0 , integer array size 1000 ; TAB1 declare string vectors names , unique_names , final_names ; TAB1 declare string a ; TAB1 read n ; TAB1 while decrement n is true ; TAB2 read a , score [ i ] ; TAB2 add a to end of names ; TAB2 increment i ; TAB1 add names [ 0 ] to end of unique_names ; TAB1 for k = 1 to size of names exclusive ; TAB2 for j = 0 to size of unique_names exclusive ; TAB3 if names [ k ] is unique_names [ j ] , end loop ; TAB3 if j is size of unique_names - 1 , add names [ k ] to end of unique_names ; TAB1 declare integer len_unique = size of unique_names ; TAB1 declare integer vector total initialized with ( 1000 , 0 ) ; TAB1 declare integer vector time initialized with ( 1000 , 0 ) ; TAB1 declare integer counter = 0 ; TAB1 for k = 0 to size of names exclusive ; TAB2 for j = 0 to size unique_names exclusive ; TAB3 if names [ k ] is unique_names [ j ] ; TAB4 let total [ j ] be total [ j ] + score [ k ] ; TAB4 if score [ k ] as greater than 0 , increment counter ; TAB4 let time [ j ] be counter ; TAB1 for l = 0 to size of time exclusive ; TAB1 declare integer max_score = value of largest element from beginning of total to end of total ; TAB1 declare string winner ; TAB1 declare integer time1 = 100000000 ; TAB1 for k = 0 to size of unique_names exclusive ; TAB2 if total [ k ] is max_score ; TAB3 declare integer sum = 0 ; TAB3 for l = 0 to size of names exclusive ; TAB4 if names [ i ] is unique_names [ k ] ; TAB5 let sum be sum + score [ l ] ; TAB5 if sum is greater than or equal to max_score and time1 is greater than l ; TAB6 let time1 be l ; TAB6 let winner be unique_names [ k ] ; TAB1 print winner and newline ;	int main ( ) { int n , score [ 1000 ] , i = 0 ; vector < string > names , unique_names , final_names ; string a ; cin >> n ; while ( n -- ) { cin >> a >> score [ i ] ; names . push_back ( a ) ; i ++ ; } unique_names . push_back ( names [ 0 ] ) ; for ( int k = 1 ; k < names . size ( ) ; k ++ ) { for ( int j = 0 ; j < unique_names . size ( ) ; j ++ ) { if ( names [ k ] == unique_names [ j ] ) { break ; } if ( j == unique_names . size ( ) - 1 ) { unique_names . push_back ( names [ k ] ) ; } } } int len_unique = unique_names . size ( ) ; vector < int > total ( 1000 , 0 ) ; vector < int > time ( 1000 , 0 ) ; int counter = 0 ; for ( int k = 0 ; k < names . size ( ) ; k ++ ) { for ( int j = 0 ; j < unique_names . size ( ) ; j ++ ) { if ( names [ k ] == unique_names [ j ] ) { total [ j ] = total [ j ] + score [ k ] ; if ( score [ k ] > 0 ) counter ++ ; time [ j ] = counter ; } } } for ( int l = 0 ; l < time . size ( ) ; l ++ ) { } int max_score = * max_element ( total . begin ( ) , total . end ( ) ) ; string winner ; int time1 = 100000000 ; for ( int k = 0 ; k < unique_names . size ( ) ; k ++ ) { if ( total [ k ] == max_score ) { int sum = 0 ; for ( int l = 0 ; l < names . size ( ) ; l ++ ) { if ( names [ l ] == unique_names [ k ] ) { sum = sum + score [ l ] ; if ( sum >= max_score && time1 > l ) { time1 = l ; winner = unique_names [ k ] ; } } } } } cout << winner << endl ; return 0 ; }
TAB1 create integers x , y , xx , yy , k , c , with x = 0 , y = 0 , xx = 0 , yy = 0 , k = 2 , c = 1 ; TAB1 create map mp from pair of ( integer , integer ) to integer ; TAB1 while 1 is true ; TAB2 increment c ; TAB2 set x to ( x * - 1 ) + 1 ; TAB2 if x is xx ; TAB3 for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2 ; TAB2 else ; TAB3 for i = minimum of x and xx to maximum of x and xx inclusive , set mp [ make pair from ( i , y ) ] to c - 2 ; TAB2 if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ] ; TAB2 set xx to x ; TAB2 set y to ( y * - 1 ) + 1 ; TAB2 increment c ; TAB2 if x is xx ; TAB3 for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2 ; TAB2 else ; TAB3 for i = minimum of x and xx to maximum of x and xx , set mp [ make pair from ( i , y ) ] to c - 2 ; TAB2 if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ] ; TAB2 set yy to y ; TAB2 set value of x to - 1 ; TAB2 increment c ; TAB2 if x is xx ; TAB3 for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2 ; TAB2 else ; TAB3 for i = minimum of x and xx to maximum of x and xx , set mp [ make pair from ( i , y ) ] to c - 2 ; TAB2 if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ] ; TAB2 set xx to x ; TAB2 set value of y to - 1 ; TAB2 increment c ; TAB2 if x is xx ; TAB3 for i = minimum of y and yy to maximum of y and yy inclusive , set mp [ make pair from ( x , i ) ] to c - 2 ; TAB2 else ; TAB3 for i = minimum of x and xx to maximum of x and xx , set mp [ make pair from ( i , y ) ] to c - 2 ; TAB2 if mp [ make pair from ( x , y ) ] is mp [ make pair from ( xx , yy ) ] , decrement mp [ make pair from ( xx , yy ) ] ; TAB2 set yy to y ; TAB2 if x is - 300 and y is - 300 break loop ; TAB1 set mp [ make pair from ( 0 , 0 ) ] to 0 ; TAB1 create integers a , b ; TAB1 read a read b ; TAB1 if ( a is 0 and b is 0 ) or ( a is 1 and b is 0 ) , return print 0 print ' \ n ' , 0 from function ; TAB1 print mp [ make pair from ( a , b ) ] print ' \ n ' ;	int main ( ) { int x = 0 , y = 0 , xx = 0 , yy = 0 , k = 2 , c = 1 ; map < pair < int , int > , int > mp ; while ( 1 ) { c ++ ; x = ( x * - 1 ) + 1 ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; xx = x ; y = ( y * - 1 ) + 1 ; c ++ ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; yy = y ; x *= - 1 ; c ++ ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; xx = x ; y *= - 1 ; c ++ ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; yy = y ; if ( x == - 300 && y == - 300 ) break ; } mp [ make_pair ( 0 , 0 ) ] = 0 ; int a , b ; cin >> a >> b ; if ( ( a == 0 && b == 0 ) || ( a == 1 && b == 0 ) ) return cout << 0 << ' \n ' , 0 ; cout << mp [ make_pair ( a , b ) ] << ' \n ' ; }
TAB0 create ints p , q , A , B , R , and i = 1 and int array C of size 2000000 containing { 1 , 1 } ; TAB1 read p and q ; TAB1 for loop i to 2e6 exclusive ; TAB2 if C [ i ] is falsy ; TAB3 set A to A + q ; TAB3 for j = i to 2e6 exclusive by incrementing by i , set C [ j ] to 1 ; TAB2 make ints r = 0 and t = i ; TAB2 for loop while t is truthy and increment by r = 10 * r + t % 10 and t / = 10 ; TAB3 end statement ; TAB2 set B to B + p * ( r = = i ) ; TAB2 set R to A < = B ? i : R ; TAB1 display R ;	int p , q , A , B , R , C [ 2000000 ] = { 1 , 1 } , i = 1 ; int main ( ) { cin >> p >> q ; for ( ; i < 2e6 ; i ++ ) { if ( ! C [ i ] ) { A += q ; for ( int j = i ; j < 2e6 ; j += i ) C [ j ] = 1 ; } int r = 0 , t = i ; for ( ; t ; r = 10 * r + t % 10 , t /= 10 ) ; B += p * ( r == i ) ; R = A <= B ? i : R ; } cout << R << endl ; }
TAB0 a , b , c = long long integers ; TAB1 read a , b , and c ; TAB1 if a is less than zero , let a = - a ; TAB1 if b is less than zero , let b = - b ; TAB1 if a + b is greater than c ; TAB2 print No ; TAB1 otherwise if c - a - b bitwise and with 1 is true ; TAB2 print NO ; TAB1 otherwise ; TAB2 print Yes ;	long long a , b , c ; int main ( ) { cin >> a >> b >> c ; if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; if ( a + b > c ) cout << " No " << endl ; else if ( ( c - a - b ) & 1 ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB1 create long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 create double t and ct , set ct = 1e99 ; TAB1 while x1 > = 0 and x2 > = 0 ; TAB2 set to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if t < t0 ; TAB3 decrement t1 ; TAB3 continue ; TAB2 if t less than ct ; TAB3 ct = t ; TAB3 res_x = x1 ; TAB3 res_y = x2 ; TAB2 decrement x2 ; TAB1 print res_x , ' ' , res_y ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; double t , ct = 1e99 ; while ( x1 >= 0 && x2 >= 0 ) { t = ( t1 * x1 + t2 * x2 * 1.0 ) / ( x1 + x2 ) ; if ( t < t0 ) { x1 -- ; continue ; } if ( t < ct ) { ct = t ; res_x = x1 ; res_y = x2 ; } x2 -- ; } cout << res_x << '   ' << res_y << endl ; }
TAB1 declare integer variables h and m ; TAB1 read h and m ; TAB1 declare integer variables p and q = 0 , f1 = h - 1 and f2 = m - 1 ; TAB1 while f1 > 0 ; TAB2 divide f1 by 7 ; TAB2 increment p by one ; TAB1 while f2 > 0 ; TAB2 divide f2 by 7 ; TAB2 increment q ; TAB1 if h is 1 , change p to 1 ; TAB1 if m is 1 , change q to 1 ; TAB1 if p + q is greater than 7 ; TAB2 print 0 ; TAB1 declare integer ans = 0 ; TAB1 loop i from 0 to h exclusive incrementing i ; TAB2 for j from 0 to m exclusive incrementing j ; TAB3 create vector of int used with 7 elements filled with 0 ; TAB3 for a = i and k = 0 while k < p , dividing a by 7 and incrementing k , add 1 to used [ a % 7 ] ; TAB3 for b = j and k = 0 while k < q , dividing b by 7 and incrementing k , add 1 to used [ b % 7 ] ; TAB3 if * max_element of used . begin ( ) and used . end ( ) is < = 0 , increment ans ; TAB1 print ans ;	int main ( ) { int h , m ; cin >> h >> m ; int f1 = h - 1 , f2 = m - 1 , p = 0 , q = 0 ; while ( f1 ) { f1 /= 7 ; p ++ ; } while ( f2 ) { f2 /= 7 ; q ++ ; } if ( h == 1 ) { p = 1 ; } if ( m == 1 ) { q = 1 ; } if ( p + q > 7 ) { cout << 0 << endl ; return 0 ; } int ans = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { vector < int > used ( 7 , 0 ) ; for ( int a = i , k = 0 ; k < p ; a /= 7 , k ++ ) used [ a % 7 ] += 1 ; for ( int b = j , k = 0 ; k < q ; b /= 7 , k ++ ) used [ b % 7 ] += 1 ; if ( * max_element ( used . begin ( ) , used . end ( ) ) <= 1 ) ans ++ ; } } cout << ans << endl ; }
TAB0 M = long long const with M = 2e5 + 10 ; TAB0 head , tail = long long with head = 0 and tails = 0 and col , q , ans , ans2 = long long array of size M each ; TAB0 adj , adj2 = long long vector array of size M each ; TAB1 n , m , a , b = long long ; TAB1 read n then m ; TAB1 for i = 1 to n inclusive ; TAB2 read col [ i ] ; TAB2 set col [ i ] to ( 3 - col [ i ] ) mod 3 ; TAB2 of col [ i ] is 2 set q [ head ] to i then set ans [ i ] to 1 then increment head ; TAB1 for i = 1 to m inclusive read a then b then append b to adj [ a ] then append a to adj2 [ b ] ; TAB1 loop while head > tail ; TAB2 v = long long with v = q [ tail ] then increment tail ; TAB2 for i = 0 to size of adj [ v ] ; TAB3 u = long long with u = adj [ v ] [ i ] ; TAB3 if not ans [ u ] and col [ u ] is not 2 set q [ head ] to u then set ans [ u ] to 1 then increment head ; TAB1 set head to 0 then set tail to 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if col [ i ] is 1 set q [ head ] to i then set ans2 to 1 then increment head ; TAB1 loop while head > tail ; TAB2 v = long long with v = q [ tail ] then increment tail ; TAB2 for i = 0 to size of adj2 [ v ] ; TAB3 u = long long with u = adj2 [ v ] [ i ] ; TAB3 if not ans2 [ u ] and col [ u ] is not 2 ; TAB4 set ans2 [ u ] to 1 then set q [ head ] to u then increment head ; TAB3 else if col [ u ] is 2 ; TAB4 set ans2 [ u ] to 1 ; TAB1 for i = 1 to n inclusive ; TAB2 if ans [ i ] is 1 and ans2 [ i ] is 1 ; TAB3 print 1 ; TAB2 else ; TAB3 print 0 ;	long long const M = 2e5 + 10 ; long long col [ M ] , q [ M ] , head = 0 , tail = 0 , ans [ M ] , ans2 [ M ] ; vector < long long > adj [ M ] , adj2 [ M ] ; int main ( ) { long long n , m , a , b ; cin >> n >> m ; for ( long long i = 1 ; i <= n ; i ++ ) { cin >> col [ i ] ; col [ i ] = ( 3 - col [ i ] ) % 3 ; if ( col [ i ] == 2 ) q [ head ++ ] = i , ans [ i ] = 1 ; } for ( long long i = 1 ; i <= m ; i ++ ) cin >> a >> b , adj [ a ] . push_back ( b ) , adj2 [ b ] . push_back ( a ) ; while ( head > tail ) { long long v = q [ tail ++ ] ; for ( long long i = 0 ; i < adj [ v ] . size ( ) ; i ++ ) { long long u = adj [ v ] [ i ] ; if ( ! ans [ u ] && col [ u ] != 2 ) q [ head ++ ] = u , ans [ u ] = 1 ; } } head = 0 , tail = 0 ; for ( long long i = 1 ; i <= n ; i ++ ) { if ( col [ i ] == 1 ) q [ head ++ ] = i , ans2 [ i ] = 1 ; } while ( head > tail ) { long long v = q [ tail ++ ] ; for ( long long i = 0 ; i < adj2 [ v ] . size ( ) ; i ++ ) { long long u = adj2 [ v ] [ i ] ; if ( ! ans2 [ u ] && col [ u ] != 2 ) ans2 [ u ] = 1 , q [ head ++ ] = u ; else if ( col [ u ] == 2 ) ans2 [ u ] = 1 ; } } for ( long long i = 1 ; i <= n ; i ++ ) { if ( ans [ i ] == 1 && ans2 [ i ] == 1 ) cout << 1 << endl ; else cout << 0 << endl ; } }
TAB1 create integers ne = 0 , po = 0 , sumne = 0 , sumpo = 0 and integer arrays nega with size of 100003 and posi with length of 100003 ; TAB1 create bool z = false ; TAB1 create integers n , x , a ; TAB1 read n ; TAB1 set all contents of nega to 0 ; TAB1 set all contents of posi to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read x and a ; TAB2 if x is less than 0 ; TAB3 set nega [ - x ] to a ; TAB3 increment ne ; TAB3 set sumne to sumne + a ; TAB2 else ; TAB3 set posi [ x ] to a ; TAB3 set sumpo to sumpo + a ; TAB1 set po to n - ne ; TAB1 if po is equal to ne ; TAB2 print sumne + sumpo and new line ; TAB1 if po is less than ne ; TAB2 set sumne to 0 ; TAB2 create integer cont = 0 ; TAB2 for cont = 0 to po inclusive ; TAB3 if nega [ i ] is not equal to 0 ; TAB4 set sumne to sumne + nega [ i ] ; TAB4 increment cont ; TAB1 if po is less than ne ; TAB2 set sumpo to 0 ; TAB2 create integer cont = 0 ; TAB2 for cont = 0 to ne inclusive ; TAB3 if posi [ i ] is not equal to 0 ; TAB4 set sumpo to sumpo + posi [ i ] ; TAB4 increment cont ; TAB1 print sumne + sumpo ;	int main ( ) { int nega [ 100003 ] , posi [ 100003 ] , ne = 0 , po = 0 , sumne = 0 , sumpo = 0 ; bool z = false ; int n , x , a ; cin >> n ; memset ( nega , 0 , sizeof nega ) ; memset ( posi , 0 , sizeof posi ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> a ; if ( x < 0 ) { nega [ - x ] = a ; ne ++ ; sumne += a ; } else { posi [ x ] = a ; sumpo += a ; } } po = n - ne ; if ( po == ne ) { cout << sumne + sumpo << endl ; return 0 ; } if ( po < ne ) { sumne = 0 ; int cont = 0 ; for ( int i = 0 ; cont < po + 1 ; i ++ ) { if ( nega [ i ] != 0 ) { sumne += nega [ i ] ; cont ++ ; } } } if ( po > ne ) { sumpo = 0 ; int cont = 0 ; for ( int i = 0 ; cont < ne + 1 ; i ++ ) { if ( posi [ i ] != 0 ) { sumpo += posi [ i ] ; cont ++ ; } } } cout << sumne + sumpo << endl ; return 0 ; }
TAB0 a = array of integers of length 105 , s = array of integers of length 1005 , 105th element of num = 0 ; TAB1 let n , i , j , k , maxn be integers ; TAB1 read n , maxn ; TAB1 for i = 1 to n inclusive ; TAB2 read a [ i ] ; TAB2 increment num [ a [ i ] ] by 1 ; TAB1 let sum be a integer with sum = 0 ; TAB1 let p , top be integers with p = 0 , top = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = p to top exclusive ; TAB3 if s [ j ] is equal to a [ i ] , stop ; TAB2 if j is less than top ; TAB3 proceed to next ; TAB2 else do the following ; TAB3 if top - p is less than maxn ; TAB4 the value of s [ top + + ] is equal to a [ i ] ; TAB4 increment sum by 1 ; TAB4 decrement num [ a [ i ] ] by 1 ; TAB3 else do the following ; TAB4 the value of k is equal to 0 ; TAB4 for j = 0 to top exclusive ; TAB5 let qq , ww be integers ; TAB5 for qq = i + 1 to n inclusive ; TAB6 if a [ qq ] is equal to s [ k ] , stop ; TAB5 for ww = i + 1 to n inclusive ; TAB6 if a [ ww ] is equal to s [ j ] , stop ; TAB5 if qq is less than ww , k is equal to j ; TAB4 s [ k ] is equal to a [ i ] ; TAB4 increment sum by 1 ; TAB4 decrement num [ a [ i ] ] by 1 ; TAB1 print sum and newline ;	int a [ 105 ] , s [ 1005 ] , num [ 105 ] = { 0 } ; int main ( ) { int n , i , j , k , maxn ; cin >> n >> maxn ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; num [ a [ i ] ] ++ ; } int sum = 0 ; int p = 0 , top = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = p ; j < top ; j ++ ) if ( s [ j ] == a [ i ] ) break ; if ( j < top ) continue ; else { if ( top - p < maxn ) { s [ top ++ ] = a [ i ] ; sum ++ ; num [ a [ i ] ] -- ; } else { k = 0 ; for ( j = 0 ; j < top ; j ++ ) { int qq , ww ; for ( qq = i + 1 ; qq <= n ; qq ++ ) if ( a [ qq ] == s [ k ] ) break ; for ( ww = i + 1 ; ww <= n ; ww ++ ) if ( a [ ww ] == s [ j ] ) break ; if ( qq < ww ) k = j ; } s [ k ] = a [ i ] ; sum ++ ; num [ a [ i ] ] -- ; } } } cout << sum << endl ; }
TAB1 n , m , i , j , num , cnt = integers with num = array of size 105 , cnt = 0 ; TAB1 read n , m ; TAB1 for i = 0 to t exclusive ; TAB2 read num [ i ] ; TAB2 if ( num [ i ] < = m ) ; TAB3 num [ i ] = 0 ; TAB3 j = i ; TAB2 else ; TAB3 num [ i ] = num [ i ] - m ; TAB3 cnt = 1 ; TAB1 while ( cnt ) ; TAB2 cnt = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if ( num [ i ] < = m and num [ i ] is not 0 ) ; TAB4 num [ i ] = 0 ; TAB4 j = i ; TAB3 else if ( num [ i ] > m ) ; TAB4 num [ i ] = num [ i ] - m ; TAB4 cnt = 1 ; TAB1 print j + 1 ;	int main ( ) { int n , m , i , j , num [ 105 ] , cnt = 0 ; cin >> n >> m ; for ( i = 0 ; i < n ; i ++ ) { cin >> num [ i ] ; if ( num [ i ] <= m ) { num [ i ] = 0 ; j = i ; } else { num [ i ] = num [ i ] - m ; cnt = 1 ; } } while ( cnt ) { cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( num [ i ] <= m && num [ i ] != 0 ) { num [ i ] = 0 ; j = i ; } else if ( num [ i ] > m ) { num [ i ] = num [ i ] - m ; cnt = 1 ; } } } cout << j + 1 << endl ; return 0 ; }
TAB0 declare constant integer INF = 0x3f3f3f3f ; TAB0 declare string s ; TAB1 declare integers i , j , k ; TAB1 declare n , m , t as integers ; TAB1 read n ; TAB1 read s ; TAB1 declare integers cou = 0 , co = 0 ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is ' 0 ' ; TAB3 increment cou ; TAB2 else ; TAB3 increment co ; TAB1 if co is 0 ; TAB2 print 0 , newline ; TAB1 else ; TAB2 print 1 ; TAB2 for i = 0 to cou exclusive , print 0 ; TAB2 print newline ;	const int INF = 0x3f3f3f3f ; string s ; int main ( ) { int i , j , k ; int n , m , t ; cin >> n ; cin >> s ; int cou = 0 , co = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == ' 0 ' ) cou ++ ; else co ++ ; if ( co == 0 ) cout << 0 << endl ; else { cout << 1 ; for ( i = 0 ; i < cou ; i ++ ) cout << 0 ; cout << endl ; } }
TAB1 create int n ; TAB1 read n ; TAB1 make string s ; TAB1 read s ; TAB1 let string ans ; TAB1 let bool ok = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is equal to ' 1 ' and ! ok is true ; TAB3 set ans to ans + s [ i ] ; TAB3 set ok to 1 ; TAB2 else if ok is true and s [ i ] is ' 0 ' ; TAB3 set ans to ans + s [ i ] ; TAB1 if ans . size ( ) is truthy ; TAB2 print ans ; TAB1 otherwise ; TAB2 print 0 ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; string ans ; bool ok = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' 1 ' and ! ok ) { ans += s [ i ] ; ok = 1 ; } else if ( ok and s [ i ] == ' 0 ' ) ans += s [ i ] ; if ( ans . size ( ) ) cout << ans << endl ; else cout << 0 << endl ; }
TAB0 a = long long array of size 100010 ; TAB1 N , M , K = long long ; TAB1 mm = long long with mm = 1e9 ; TAB1 read N then M then K ; TAB1 for i = 1 to N inclusive ; TAB2 read a [ i ] ; TAB2 if i is uneven set mm to min of mm , a [ i ] ; TAB1 if N is even ; TAB2 print " 0 " ; TAB1 temp = int with temp = ( N + 1 ) / 2 ; TAB1 print min of mm , M / temp * K ;	long long a [ 100010 ] ; int main ( ) { long long N , M , K ; long long mm = 1e9 ; cin >> N >> M >> K ; for ( int i = 1 ; i <= N ; i ++ ) { cin >> a [ i ] ; if ( i % 2 == 1 ) { mm = min ( mm , a [ i ] ) ; } } if ( N % 2 == 0 ) { cout << " 0 " << endl ; return 0 ; } int temp = ( N + 1 ) / 2 ; cout << min ( mm , M / temp * K ) << endl ; return 0 ; }
TAB0 declare long long ans ; TAB0 in function maxsum , return type long long , parameters long long p array , long long n ; TAB1 define long long tmp = 0 ; TAB1 for long long i = 0 to n exclusive ; TAB2 set ans to max of ans and tmp ; TAB2 increase tmp by p [ i ] ; TAB2 if tmp less than 0 , set tmp to 0 ; TAB2 set ans to max of ans and tmp ; TAB1 declare long long n ; TAB1 read n ; TAB1 declare long long array a with a length of n ; TAB1 for long long i = 0 to n exclusive , read a [ i ] ; TAB1 declare long long b array with n as length ; TAB1 declare long long c array with n as length ; TAB1 for long long i = 0 to n - 1 exclusive ; TAB2 set b [ i ] to abs of a [ i ] - a [ i + 1 ] * ( if i is even , 1 ; else , - 1 ) ; TAB2 set c [ i ] to abs of a [ i ] - a [ i + 1 ] * ( if i + 1 is even , 1 ; else , - 1 ) ; TAB1 maxsum ( b , n - 1 ) ; TAB1 maxsum ( c , n - 1 ) ; TAB1 print ans ;	long long ans ; long long maxsum ( long long p [ ] , long long n ) { long long tmp = 0 ; for ( long long i = 0 ; i < n ; ++ i ) { ans = max ( ans , tmp ) ; tmp += p [ i ] ; if ( tmp < 0 ) tmp = 0 ; ans = max ( ans , tmp ) ; } } int main ( ) { long long n ; cin >> n ; long long a [ n ] ; for ( long long i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; long long b [ n ] ; long long c [ n ] ; for ( long long i = 0 ; i < n - 1 ; ++ i ) { b [ i ] = abs ( a [ i ] - a [ i + 1 ] ) * ( i % 2 == 0 ? 1 : - 1 ) ; c [ i ] = abs ( a [ i ] - a [ i + 1 ] ) * ( ( i + 1 ) % 2 == 0 ? 1 : - 1 ) ; } maxsum ( b , n - 1 ) ; maxsum ( c , n - 1 ) ; cout << ans << ' \n ' ; }
TAB0 day = map from strings to integers ; TAB1 set the value of day [ " monday " ] to 1 ; TAB1 change day [ " tuesday " ] to 2 ; TAB1 assign the new value = 3 to day [ " wednesday " ] ; TAB1 assign the new value = 4 to day [ " thursday " ] ; TAB1 assign 5 to day [ " friday " ] ; TAB1 set the value of day [ " saturday " ] to 6 ; TAB1 set the value of day [ " sunday " ] to 7 ; TAB1 create new strings fd and sd ; TAB1 read variables fd and sd from the input ; TAB1 new integers f = day [ fd ] and s = day [ sd ] ; TAB1 create integer k with value ( s - f + 7 ) % 7 ; TAB1 if k = 0 , 2 or 3 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	map < string , int > day ; int main ( ) { day [ " monday " ] = 1 ; day [ " tuesday " ] = 2 ; day [ " wednesday " ] = 3 ; day [ " thursday " ] = 4 ; day [ " friday " ] = 5 ; day [ " saturday " ] = 6 ; day [ " sunday " ] = 7 ; string fd , sd ; cin >> fd >> sd ; int f = day [ fd ] , s = day [ sd ] ; int k = ( s - f + 7 ) % 7 ; if ( k == 0 || k == 2 || k == 3 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 s = string ; TAB1 n = int ; TAB1 read n , s ; TAB1 s = ' 0 ' + s + ' 0 ' ; TAB1 if ' 000 ' and ' 11 ' are not present in s ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	int main ( ) { string s ; int n ; cin >> n >> s ; s = ' 0 ' + s + ' 0 ' ; if ( s . find ( " 000 " ) == - 1 && s . find ( " 11 " ) == - 1 ) puts ( " Yes " ) ; else puts ( " No " ) ; }
TAB0 declare constant integer variable maxn = 1e5 + 10 ; TAB0 create bool arrays mark and rmark with maxn elements ; TAB0 a is an array of integers with maxn elements ; TAB0 declare an arrays of int vectors v and rv with size maxn ; TAB0 inlined void function dfs with int arguments x and par ; TAB1 return if mark [ x ] is true ; TAB1 if par ! = - 1 and a [ x ] = 1 , return ; TAB1 assign 1 to mark [ x ] ; TAB1 start for loop from i = 0 to length of v [ x ] exclusive incrementing i ; TAB2 if mark [ v [ x ] [ i ] ] is false , call function dfs for v [ x ] [ i ] and x ; TAB0 inlined void function rdfs with int argument x ; TAB1 if rmark [ x ] is true , return ; TAB1 assign 1 to rmark [ x ] ; TAB1 if a [ x ] is equal to 1 , return ; TAB1 start for loop from i = 0 to length of rv [ x ] exclusive ; TAB2 if rmark [ rv [ x ] [ i ] ] is false , call rdfs ( rv [ x ] [ i ] ) ; TAB1 declare integers n , m , x and y ; TAB1 read from the input to n and m ; TAB1 in a loop , read n elements into array a ; TAB1 for i from 0 to m exclusive incrementing i ; TAB2 read from the input to x and y ; TAB2 decrement x by one ; TAB2 decrement y ; TAB2 push new value = y into v [ x ] ; TAB2 push x to the end of rv [ y ] ; TAB1 start for loop from i = 0 to n exclusive incrementing i ; TAB2 call dfs ( i , - 1 ) if a [ i ] is equal to 1 ; TAB1 for i from 0 to n exclusive incrementing i ; TAB2 if a [ i ] = 2 , run rdfs with i as an argument ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 if both mark [ i ] and rmark [ i ] are true ; TAB3 print 1 and " \ n " ; TAB2 else ; TAB3 print 0 and " \ n " to the standard output ;	const int maxn = 1e5 + 10 ; bool mark [ maxn ] , rmark [ maxn ] ; int a [ maxn ] ; vector < int > v [ maxn ] , rv [ maxn ] ; inline void dfs ( int x , int par ) { if ( mark [ x ] ) return ; if ( par != - 1 && a [ x ] == 1 ) return ; mark [ x ] = 1 ; for ( int i = 0 ; i < v [ x ] . size ( ) ; i ++ ) if ( ! mark [ v [ x ] [ i ] ] ) dfs ( v [ x ] [ i ] , x ) ; } inline void rdfs ( int x ) { if ( rmark [ x ] ) return ; rmark [ x ] = 1 ; if ( a [ x ] == 1 ) return ; for ( int i = 0 ; i < rv [ x ] . size ( ) ; i ++ ) if ( ! rmark [ rv [ x ] [ i ] ] ) rdfs ( rv [ x ] [ i ] ) ; } int main ( ) { int n , m , x , y ; cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < m ; i ++ ) { cin >> x >> y ; x -- ; y -- ; v [ x ] . push_back ( y ) ; rv [ y ] . push_back ( x ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) dfs ( i , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 2 ) rdfs ( i ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mark [ i ] && rmark [ i ] ) cout << 1 << " \n " ; else cout << 0 << " \n " ; }
TAB1 s = string ; TAB1 read s ; TAB1 i , j , k , l = integers with l = s . length ( ) ; TAB1 a1 , b1 , c1 , m = integers with a1 = 0 , b1 = 0 , c1 = 0 , m = - 1 ; TAB1 for i = 0 to l - 2 exclusive ; TAB2 if ( a1 * 10 + ( s [ i ] - 48 ) > 1000000 ) , break loop ; TAB2 if ( i and s [ 0 ] is 0 ) , break loop ; TAB2 a1 = a1 * 10 + ( s [ i ] - 48 ) ; TAB2 for j = i + 1 to l - 1 exclusive ; TAB3 if ( b1 * 10 + int ( s [ j ] - 48 ) > 1000000 ) , break loop ; TAB3 if ( i + 1 < j and s [ i + 1 ] is 0 ) , break loop ; TAB3 b1 = b1 * 10 + cast to int ( s [ j ] - 48 ) ; TAB3 c1 = 0 ; TAB3 for k = j + 1 to 1 exclusive ; TAB4 if ( c1 * 10 + cast to int ( s [ k ] - 48 ) > 1000000 ) , goto w ; TAB4 if ( j + 1 < k and s [ j + 1 ] is 0 ) , goto w ; TAB4 c1 = c1 * 10 + cast to int ( s [ k ] - 48 ) ; TAB3 if ( m < a1 + b1 + c1 ) , m = a1 + b1 + c1 ; TAB2 label w ; TAB2 b1 = 0 ; TAB1 print m ;	int main ( ) { string s ; cin >> s ; int i , j , k , l = s . length ( ) ; int a1 = 0 , b1 = 0 , c1 = 0 , m = - 1 ; for ( i = 0 ; i < l - 2 ; i ++ ) { if ( a1 * 10 + ( s [ i ] - 48 ) > 1000000 ) break ; if ( i && s [ 0 ] == ' 0 ' ) break ; a1 = a1 * 10 + ( s [ i ] - 48 ) ; for ( j = i + 1 ; j < l - 1 ; j ++ ) { if ( b1 * 10 + int ( s [ j ] - 48 ) > 1000000 ) break ; if ( i + 1 < j && s [ i + 1 ] == ' 0 ' ) break ; b1 = b1 * 10 + int ( s [ j ] - 48 ) ; c1 = 0 ; for ( k = j + 1 ; k < l ; k ++ ) { if ( c1 * 10 + int ( s [ k ] - 48 ) > 1000000 ) goto w ; if ( j + 1 < k && s [ j + 1 ] == ' 0 ' ) goto w ; c1 = c1 * 10 + int ( s [ k ] - 48 ) ; } if ( m < a1 + b1 + c1 ) m = a1 + b1 + c1 ; w : ; } b1 = 0 ; } cout << m << endl ; return 0 ; }
TAB0 N = constant integer = 200010 ; TAB0 n , t , ans , maxn are long longs ; TAB0 m , ms are long long arrays of size N ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read m [ i ] ; TAB2 for j = 1 to m [ i ] inclusive , read t , set ms [ i ] to call max with ms [ i ] , t ; TAB2 set maxn to call max with maxn , ms [ i ] ; TAB1 for i = 1 to n inclusive , add m [ i ] * ( maxn - ms [ i ] ) to ans ; TAB1 print ans ;	const int N = 200010 ; long long n , t , ans , maxn ; long long m [ N ] , ms [ N ] ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> m [ i ] ; for ( int j = 1 ; j <= m [ i ] ; j ++ ) cin >> t , ms [ i ] = max ( ms [ i ] , t ) ; maxn = max ( maxn , ms [ i ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) ans += m [ i ] * ( maxn - ms [ i ] ) ; cout << ans << endl ; return 0 ; }
TAB1 a , b , s = integers ; TAB1 read a , b and s ; TAB1 d = integer set to absolute value of a + absolute value of b ; TAB1 if d < = s and d ^ s & 1 is 0 , print " Yes \ n " if true and " No \ n " if false ;	int main ( ) { int a , b , s ; cin >> a >> b >> s ; int d = abs ( a ) + abs ( b ) ; cout << ( ( d <= s && ( ( d ^ s ) & 1 ) == 0 ) ? " Yes\n " : " No\n " ) ; return 0 ; }
TAB0 let printSt be a void function that accepts integer x ; TAB1 for integer i is equal to int ( 0 ) to int ( x ) exclusive , print | ; TAB0 let get be a void function that accepts int & a , int & b , int & c , string cad ; TAB1 let p be a integer ; TAB1 for p is equal to 0 , cad [ p ] is not equal to + , increment p by 1 , increment a by 1 ; TAB1 for increment p by 1 , cad [ p ] is not equal to = , increment p by 1 , increment b by 1 ; TAB1 for increment p by 1 , p is less than int ( length of cad ) , increment p by 1 , increment c by 1 ; TAB1 let cad be a string ; TAB1 read cad ; TAB1 let a , b , c be integers ; TAB1 initialize the values of a , b , c to 0 ; TAB1 send the values a , b , c , cad into get ; TAB1 if a + b + 1 is equal to c - 1 , increment a by 1 , decrement c by 1 ; TAB1 if a + b - 1 is equal to c + 1 ; TAB2 if a is greater than b ; TAB3 decrement a by 1 ; TAB2 else do the following ; TAB3 decrement b by 1 ; TAB2 increment c by 1 ; TAB1 if a + b is not equal to c ; TAB2 print Impossible and newline ; TAB2 exit ( 0 ) ; TAB1 send a into printSt ; TAB1 print + ; TAB1 send b into printSt ; TAB1 print = ; TAB1 send c into printSt ; TAB1 print newline ;	void printSt ( int x ) { for ( int i = int ( 0 ) ; i < int ( x ) ; ++ i ) cout << " | " ; } void get ( int & a , int & b , int & c , string cad ) { int p ; for ( p = 0 ; cad [ p ] != ' + ' ; ++ p ) a ++ ; for ( ++ p ; cad [ p ] != ' = ' ; ++ p ) b ++ ; for ( ++ p ; p < int ( cad . size ( ) ) ; ++ p ) c ++ ; } int main ( ) { string cad ; cin >> cad ; int a , b , c ; a = b = c = 0 ; get ( a , b , c , cad ) ; if ( a + b + 1 == c - 1 ) a ++ , c -- ; if ( a + b - 1 == c + 1 ) { if ( a > 1 ) -- a ; else -- b ; c ++ ; } if ( a + b != c ) { cout << " Impossible " << endl ; exit ( 0 ) ; } printSt ( a ) ; cout << " + " ; printSt ( b ) ; cout << " = " ; printSt ( c ) ; cout << endl ; return 0 ; }
TAB1 x1 , y1 , x2 , y2 = long long ; TAB1 n = integer ; TAB1 cont = integer = 0 ; TAB1 read x1 , y1 , x2 , y2 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 a , b , c = long long ; TAB2 read a , b , c ; TAB2 if ( x1 * a + y1 * b + c ) > 0 ) and ( x2 * a + y2 * b + c ) < 0 ) , then increase cont by 1 ; TAB2 if ( x1 * a + y1 * b + c ) < 0 ) and ( x2 * a + y2 * b + c ) > 0 ) , then increase cont by 1 ; TAB1 print cont ;	int main ( ) { long long x1 , y1 , x2 , y2 ; int n ; int cont = 0 ; cin >> x1 >> y1 >> x2 >> y2 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { long long a , b , c ; cin >> a >> b >> c ; if ( ( ( x1 * a + y1 * b + c ) > 0 ) && ( ( x2 * a + y2 * b + c ) < 0 ) ) { cont ++ ; } if ( ( ( x1 * a + y1 * b + c ) < 0 ) && ( ( x2 * a + y2 * b + c ) > 0 ) ) { cont ++ ; } } cout << cont << endl ; return 0 ; }
TAB1 let t1 , t2 , x1 , x2 , t0 , res_x , res_y be long lon ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 let t , ct be double with ct = 1e99 ; TAB1 while x1 is greater than or equal to 0 and x2 is greater than or equal to 0 ; TAB2 set t to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if t is less than t0 ; TAB3 decrement x1 ; TAB3 continue ; TAB2 if t is less than ct ; TAB3 set ct to t ; TAB3 set res_x to x1 ; TAB3 set res_y to x2 ; TAB2 decrement x2 ; TAB1 print out res_x , ' ' , res_y with newline ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; double t , ct = 1e99 ; while ( x1 >= 0 && x2 >= 0 ) { t = ( t1 * x1 + t2 * x2 * 1.0 ) / ( x1 + x2 ) ; if ( t < t0 ) { x1 -- ; continue ; } if ( t < ct ) { ct = t ; res_x = x1 ; res_y = x2 ; } x2 -- ; } cout << res_x << '   ' << res_y << endl ; }
TAB1 n = long long , t = long long = 0 , z = long long = 1 , l = long long = 1 ; TAB1 read n ; TAB1 x , m = character ; TAB1 for i = 0 to n exclusive ; TAB2 read m ; TAB2 if t is 0 ; TAB3 if m is ? , then z = 2 ; TAB3 increase t by 1 ; TAB3 x = m ; TAB2 else if m is x and m is not ? ; TAB3 print No ; TAB3 l = 0 ; TAB3 z = 2 ; TAB3 exit for loop ; TAB2 else if m is ? and m is x and z is not 2 ; TAB3 z = 2 ; TAB2 else if m is ? and z is not 2 and i + 1 is n ; TAB3 z = 2 ; TAB2 if m is ? and z is not 2 and i + 1 is not n ; TAB3 read m ; TAB3 increase i by 1 ; TAB3 if x is m or m is ? , then z = 2 ; TAB2 x = m ; TAB1 if l is not 0 and z is 2 , then print Yes ; TAB1 if z is 1 , then print No ;	int main ( ) { long long n , t = 0 , z = 1 , l = 1 ; cin >> n ; char x , m ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> m ; if ( t == 0 ) { if ( m == ' ? ' ) { z = 2 ; } t ++ ; x = m ; } else if ( m == x && m != ' ? ' ) { cout << " No " << endl ; l = 0 ; z = 2 ; break ; } else if ( m == ' ? ' && m == x && z != 2 ) { z = 2 ; } else if ( m == ' ? ' && z != 2 && ( i + 1 ) == n ) { z = 2 ; } if ( m == ' ? ' && m != x && z != 2 && ( i + 1 ) != n ) { cin >> m ; i ++ ; if ( x == m || m == ' ? ' ) { z = 2 ; } } x = m ; } if ( l != 0 && z == 2 ) { cout << " Yes " << endl ; } if ( z == 1 ) { cout << " No " << endl ; } }
TAB1 let n , s , x , y , and = integers with ans = - 1 ; TAB1 read n , s ; TAB1 for integer i = 0 to n exclusive do the following ; TAB2 read x , y ; TAB2 if ( s * 100 is greater than or equal to x * 100 + y set ans = max of ans and ( 100 - y ) modulo 100 ; TAB1 print ans ;	int main ( ) { int n , s , x , y , ans = - 1 ; cin >> n >> s ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> y ; if ( s * 100 >= x * 100 + y ) ans = max ( ans , ( 100 - y ) % 100 ) ; } cout << ans << endl ; return 0 ; }
TAB0 declare cek taking in int x and returning bool ; TAB1 create integer ada = 0 ; TAB1 for i = 1 to sqrt ( x ) ; TAB2 if x % i is equal to 0 , add 1 to ada ; TAB1 if ada is equal to 1 ; TAB1 otherwise ; TAB2 return 1 ; TAB1 make integer n ; TAB1 read n ; TAB1 for i = 1 to 1000 ; TAB2 make int x = ( i * n ) ; TAB2 set x to x + 1 ; TAB2 if cek ( x ) is truthy ; TAB3 print i ;	bool cek ( int x ) { int ada = 0 ; for ( int i = 1 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { ada += 1 ; } } if ( ada == 1 ) { return 0 ; } else return 1 ; } int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= 1000 ; i ++ ) { int x = ( i * n ) ; x += 1 ; if ( cek ( x ) ) { cout << i << endl ; return 0 ; } } }
TAB0 create long longs x , y ; TAB0 declare exgcd with long longs a , b as arguments returning long long ; TAB1 if b is 0 ; TAB2 set x to 1 ; TAB2 set y to 0 ; TAB2 return a from function ; TAB1 crate long long d with d = result of run exgcd with b , a % b as arguments ; TAB1 create long long t with t = x ; TAB1 set x to y ; TAB1 set y to t - a / b * y ; TAB1 return d from function ; TAB1 create long longs m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 ; TAB1 create long longs p1 , p2 , q1 , q2 ; TAB1 while read m read h1 read a1 read x1 read y1 read h2 read a2 read x2 read y2 is true ; TAB2 set p1 to p2 to q1 to q2 to 0 ; TAB2 for i = 1 to 2 * m inclusive ; TAB3 set h1 to ( h1 * x1 + y1 ) % m ; TAB3 if h1 is a1 ; TAB4 if p1 is 0 ; TAB5 set p1 to i ; TAB4 else if q1 is 0 ; TAB5 set q1 to i - p1 ; TAB5 break loop ; TAB2 for i = 1 to 2 * m inclusive ; TAB3 set h2 to ( h2 * x2 + y2 ) % m ; TAB3 if h2 is a2 ; TAB4 if p2 is 0 ; TAB5 set p2 to i ; TAB4 else if q2 is 0 ; TAB5 set q2 to i - p2 ; TAB5 break loop ; TAB2 create long long d with d = result of run exgcd with q1 , - q2 as arguments ; TAB2 create long long c with c = p2 - p1 ; TAB2 if d is 0 ; TAB3 print " - 1 " ; TAB3 break current loop iteration ; TAB2 if c % d ; TAB3 print " - 1 " ; TAB3 break current loop iteration ; TAB2 if p1 is 0 or p2 is 0 ; TAB3 print " - 1 " ; TAB3 break current loop iteration ; TAB2 if q2 is 0 and q1 is 0 and p1 is not p2 ; TAB3 print " - 1 " ; TAB3 break current loop iteration ; TAB2 if ( q2 is 0 and p2 - p1 is less than 0 ) or ( q2 is 0 and p1 - p2 is less than 0 ) ; TAB3 print " - 1 " ; TAB3 break current loop iteration ; TAB2 create long long k with k = c / d ; TAB2 set x to x * k ; TAB2 set y to y * k ; TAB2 if d is less than 0 , set d to - d ; TAB2 if x is less than 0 or y is less than 0 ; TAB3 while 1 is true ; TAB4 increment x by q2 / d ; TAB4 increment y by q1 / d ; TAB4 if x is greater than or equal to 0 and y is greater than or equal to 0 , break loop ; TAB2 if x is greater than 0 and y is greater than 0 ; TAB3 while 1 is true ; TAB4 decrement x by q2 / d ; TAB4 decrement y by q1 / d ; TAB4 if x is less than 0 or y is less than 0 , break loop ; TAB3 increment x by q2 / d ; TAB3 increment y by q1 / d ; TAB2 create long long ans with ans = x * q1 + p1 ; TAB2 print ans print newline ;	long long x , y ; long long exgcd ( long long a , long long b ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long d = exgcd ( b , a % b ) ; long long t = x ; x = y ; y = t - a / b * y ; return d ; } int main ( ) { long long m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 ; long long p1 , p2 , q1 , q2 ; while ( cin >> m >> h1 >> a1 >> x1 >> y1 >> h2 >> a2 >> x2 >> y2 ) { p1 = p2 = q1 = q2 = 0 ; for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h1 = ( h1 * x1 + y1 ) % m ; if ( h1 == a1 ) { if ( p1 == 0 ) p1 = i ; else if ( q1 == 0 ) { q1 = i - p1 ; break ; } } } for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h2 = ( h2 * x2 + y2 ) % m ; if ( h2 == a2 ) { if ( p2 == 0 ) p2 = i ; else if ( q2 == 0 ) { q2 = i - p2 ; break ; } } } long long d = exgcd ( q1 , - q2 ) ; long long c = p2 - p1 ; if ( d == 0 ) { puts ( " -1 " ) ; continue ; } if ( c % d ) { puts ( " -1 " ) ; continue ; } if ( p1 == 0 || p2 == 0 ) { puts ( " -1 " ) ; continue ; } if ( q2 == 0 && q1 == 0 && p1 != p2 ) { puts ( " -1 " ) ; continue ; } if ( ( q2 == 0 && p2 - p1 < 0 ) || ( q1 == 0 && p1 - p2 < 0 ) ) { puts ( " -1 " ) ; continue ; } long long k = c / d ; x *= k ; y *= k ; if ( d < 0 ) d = - d ; if ( x < 0 || y < 0 ) { while ( 1 ) { x += q2 / d ; y += q1 / d ; if ( x >= 0 && y >= 0 ) break ; } } if ( x > 0 && y > 0 ) { while ( 1 ) { x -= q2 / d ; y -= q1 / d ; if ( x < 0 || y < 0 ) break ; } x += q2 / d ; y += q1 / d ; } long long ans = x * q1 + p1 ; cout << ans << endl ; } return 0 ; }
TAB0 MOD = constant long long = 1e9 + 9LL ; TAB0 s = string ; TAB0 n , a , b , k = long long ; TAB0 in function MODULUS with arguments of long long b and long long p that returns a long long ; TAB1 ret = long long = 1LL ; TAB1 while p is nonzero ; TAB2 if bitwise and of p and 1LL , then ret = ( ret * b ) modulo MOD ; TAB2 b = ( b * b ) modulo MOD ; TAB2 p shifted by 1LL bits to the right ; TAB1 return ret ; TAB0 in function MODINVERSE with an argument long long x that returns a long long ; TAB1 return the result of calling MODULUS with arguments of x , MOD - 2LL ; TAB0 in function Add with arguments of long long x and long long that returns a long long ; TAB1 x = x + y ; TAB1 if x > MOD that returns x - MOD ; TAB1 return x ; TAB0 in function Sub with arguments of long long x and long long y that returns a long long ; TAB1 x = x - y ; TAB1 if x < 0 , then return x + MOD ; TAB1 return x ; TAB0 in function Mul with arguments of long long x and long long y that returns a long long ; TAB1 x = x * y ; TAB1 return x modulo MOD ; TAB0 in function Div with arguments of long long x and long long y that returns a long long ; TAB1 return ( x * MODINVERSE ( y ) ) modulo MOD ; TAB1 read n , a , b , k , s ; TAB1 ans = long long = 0LL ; TAB1 x = long long = call Div with arguments of b and a ; TAB1 c = long long = call MODULUS with arguments of a and n ; TAB1 for i = 0 to k exclusive ; TAB2 if s [ i ] is + ; TAB3 ans = ans + c ; TAB2 else ; TAB3 ans = ans - c ; TAB2 c = call Mul with arguments c and x ; TAB1 if ans < 0 then ans = ans + MOD ; TAB1 x = call MODULUS with arguments of x and k ; TAB1 if x is 1 ; TAB2 ans = call Mul with arguments ans and ( n + 1 ) / k ; TAB1 else ; TAB2 ans = ( call Mul with arguments x and ( n + 1 ) / k ) - 1 ; TAB2 ans = call Div with arguments of ans and x - 1 ; TAB1 print ans modulo MOD ;	long long const MOD = 1e9 + 9LL ; string s ; long long n , a , b , k ; long long MODULUS ( long long b , long long p ) { long long ret = 1LL ; while ( p ) { if ( p & 1LL ) ret = ( ret * b ) % MOD ; b = ( b * b ) % MOD ; p >>= 1LL ; } return ret ; } long long MODINVERSE ( long long x ) { return MODULUS ( x , MOD - 2LL ) ; } long long Add ( long long x , long long y ) { x += y ; if ( x > MOD ) return x - MOD ; return x ; } long long Sub ( long long x , long long y ) { x -= y ; if ( x < 0 ) return x + MOD ; return x ; } long long Mul ( long long x , long long y ) { x *= y ; return x % MOD ; } long long Div ( long long x , long long y ) { return ( x * MODINVERSE ( y ) ) % MOD ; } int main ( ) { cin >> n >> a >> b >> k >> s ; long long ans = 0LL ; long long x = Div ( b , a ) ; long long c = MODULUS ( a , n ) ; for ( int i = 0 ; i < k ; i += 1 ) { if ( s [ i ] == ' + ' ) { ans = Add ( ans , c ) ; } else { ans = Sub ( ans , c ) ; } c = Mul ( c , x ) ; } if ( ans < 0 ) ans += MOD ; x = MODULUS ( x , k ) ; if ( x == 1 ) { ans = Mul ( ans , ( n + 1 ) / k ) ; } else { ans = Mul ( ans , Sub ( MODULUS ( x , ( n + 1 ) / k ) , 1 ) ) ; ans = Div ( ans , Sub ( x , 1 ) ) ; } cout << ans % MOD << ' \n ' ; return 0 ; }
TAB0 mem = integer array of size [ 6000 ] [ 6000 ] ; TAB0 s , t = strings ; TAB0 in the function f that takes integer i , j and returns integer ; TAB1 if ( i is s . length ( ) or j is t . length ( ) ) , return 0 ; TAB1 if ( mem [ i ] [ j ] is not - 1 ) , return mem [ i ] [ j ] ; TAB1 if ( s [ i ] is t [ j ] ) ; TAB2 mem [ i ] [ j ] = ( f ( i + 1 , j + 1 ) + f ( i , j + 1 ) + 1 ) modulo 1000000007 ; TAB1 else ; TAB2 mem [ i ] [ j ] = f ( i , j + 1 ) ; TAB1 return mem [ i ] [ j ] ; TAB1 read s , t ; TAB1 set all contents of mem to - 1 ; TAB1 ans = integer with ans = 0 ; TAB1 for i = 0 to s . length ( ) exclusive , ans = ( ans + f ( i , 0 ) ) modulo 1000000007 ; TAB1 print ans ;	int mem [ 6000 ] [ 6000 ] ; string s , t ; int f ( int i , int j ) { if ( i == s . length ( ) || j == t . length ( ) ) return 0 ; if ( mem [ i ] [ j ] != - 1 ) return mem [ i ] [ j ] ; if ( s [ i ] == t [ j ] ) mem [ i ] [ j ] = ( f ( i + 1 , j + 1 ) + f ( i , j + 1 ) + 1 ) % 1000000007 ; else mem [ i ] [ j ] = f ( i , j + 1 ) ; return mem [ i ] [ j ] ; } int main ( ) { cin >> s >> t ; memset ( mem , - 1 , sizeof ( mem ) ) ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) ans = ( ans + f ( i , 0 ) ) % 1000000007 ; cout << ans << endl ; }
TAB0 N , INF , MOD are constant integers all set to 0 ; TAB0 n , L , a , t , l , last are integers with last = 0 ; TAB0 ans = long long ; TAB1 read n , L , a ; TAB1 for i = 0 to n exclusive ; TAB2 read t , l ; TAB2 add call max with 0 , ( t - last ) / a to ans ; TAB2 set last to t + 1 ; TAB1 add call max with 0 , ( L - last ) / a to ans ; TAB1 output ans ;	const int N = 0 , INF = 0 , MOD = 0 ; int n , L , a , t , l , last = 0 ; long long ans ; int main ( ) { cin >> n >> L >> a ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t >> l ; ans += max ( 0 , ( t - last ) / a ) ; last = t + l ; } ans += max ( 0 , ( L - last ) / a ) ; cout << ans << endl ; return 0 ; }
TAB1 create long long int a ; TAB1 read a ; TAB1 if a = 0 ; TAB2 print - 1 ; TAB1 else if a mod 4 = 0 ; TAB2 print 6 ; TAB1 else if a mod 4 = 1 ; TAB2 print 0 ; TAB1 else if a modulo 4 = 2 ; TAB2 print 4 ; TAB1 else ; TAB2 print 2 and a newline ;	int main ( ) { long long int a ; cin >> a ; if ( a == 0 ) cout << " 1 " << endl ; else if ( a % 4 == 0 ) cout << " 6 " << endl ; else if ( a % 4 == 1 ) cout << " 8 " << endl ; else if ( a % 4 == 2 ) cout << " 4 " << endl ; else { cout << " 2 " << endl ; } return 0 ; }
TAB0 declare int variables flag , gender , ok , t and cnt ; TAB0 declare new string called s ; TAB0 define new array of strings filled with elements " lios " , " liala " , " etr " , " etra " , " initis " and " inites " ; TAB0 integer function cmp with string arguments a and b ; TAB1 define integers len1 = length of a , and lent2 = length of b ; TAB1 start for loop from i = 0 to len2 exclusive ; TAB2 return 0 if a [ len1 - len2 + i ] ! = b [ i ] ; TAB1 return 1 ; TAB1 assign the new value = 3 to gender ; TAB1 read s and keep looping ; TAB2 set ok to 0 ; TAB2 for integer i = 0 to 6 exclusive incrementing i ; TAB3 if cmp ( s , x [ i ] ) is not 0 ; TAB4 assign 1 to ok ; TAB4 increment cnt by one ; TAB4 if gender = 3 ; TAB5 set the value of gender to i modulo 2 ; TAB4 else if i % 2 ! = gender ; TAB5 print " NO " ; TAB4 assign the new value = i / 2 + 1 to t ; TAB4 if t is equal to 1 and flag = 0 ; TAB5 change flag to 1 ; TAB4 else if t and flag are both 1 ; TAB5 change flag to 1 ; TAB4 else if t is equal to 2 and flag is equal to 1 ; TAB5 set the value of flag to 2 ; TAB4 else if t is equal to 2 and flag = 0 ; TAB5 assign the new value = 2 to flag ; TAB4 else if t is equal to 3 and flag = 0 ; TAB5 assign the new value = - 1 to flag ; TAB4 else if t is equal to 3 and flag = 2 ; TAB5 set the value of flag to 3 ; TAB4 else if t and flag are both equal to 3 ; TAB5 change flag to 3 ; TAB4 else ; TAB5 print " NO " ; TAB2 if ok is equal to 0 ; TAB3 print " NO " ; TAB2 if character from the input is equal to ' \ n ' , break the loop ; TAB1 if flag = 1 and cnt > 1 ; TAB2 print " NO " ; TAB1 else ; TAB2 print " YES " ;	int flag , gender , ok , t , cnt ; string s ; string x [ 6 ] = { " lios " , " liala " , " etr " , " etra " , " initis " , " inites " } ; int cmp ( string a , string b ) { int len1 = a . size ( ) , len2 = b . size ( ) ; for ( int i = 0 ; i < len2 ; i ++ ) { if ( a [ len1 - len2 + i ] != b [ i ] ) return 0 ; } return 1 ; } int main ( ) { gender = 3 ; while ( cin >> s ) { ok = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( cmp ( s , x [ i ] ) ) { ok = 1 ; cnt ++ ; if ( gender == 3 ) gender = i % 2 ; else if ( i % 2 != gender ) { cout << " NO " << endl ; return 0 ; } t = i / 2 + 1 ; if ( t == 1 && flag == 0 ) flag = 1 ; else if ( t == 1 && flag == 1 ) flag = 1 ; else if ( t == 2 && flag == 1 ) flag = 2 ; else if ( t == 2 && flag == 0 ) flag = 2 ; else if ( t == 3 && flag == 0 ) flag = - 1 ; else if ( t == 3 && flag == 2 ) flag = 3 ; else if ( t == 3 && flag == 3 ) flag = 3 ; else { cout << " NO " << endl ; return 0 ; } } } if ( ok == 0 ) { cout << " NO " << endl ; return 0 ; } if ( cin . get ( ) == ' \n ' ) break ; } if ( flag == 1 && cnt > 1 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 p , n , k , s = integer with p = 1 , s = array of size 105 ; TAB0 c = character ; TAB1 s [ increment k ] = 1 ; TAB1 while ( read c and c is not = ; TAB2 if c is + , increment p , s [ increment k ] = 1 ; TAB2 if c is - , decrement p , s [ increment k ] = - 1 ; TAB1 read n ; TAB1 for i = 0 to k exclusive ; TAB2 if s [ i ] > 0 ; TAB3 while p < n and s [ i ] < n , increment s [ i ] , increment p ; TAB2 else ; TAB3 while p > n and s [ i ] > - n , decrement s [ i ] , decrement p ; TAB1 if p is not n ; TAB2 print Impossible ; TAB1 print Possible ; TAB1 for i = 0 to k exclusive , ( if i , ( if s [ i ] < 0 , print - else print + ) else ) , and print absolute of s [ i ] ; TAB1 print = and n ;	int p = 1 , n , k , s [ 105 ] ; char c ; int main ( ) { s [ k ++ ] = 1 ; while ( cin >> c && c != ' = ' ) { if ( c == ' + ' ) p ++ , s [ k ++ ] = 1 ; if ( c == ' - ' ) p -- , s [ k ++ ] = - 1 ; } cin >> n ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] > 0 ) while ( p < n && s [ i ] < n ) s [ i ] ++ , p ++ ; else while ( p > n && s [ i ] > - n ) s [ i ] -- , p -- ; } if ( p != n ) { cout << " Impossible " << endl ; return 0 ; } cout << " Possible " << endl ; for ( int i = 0 ; i < k ; i ++ ) cout << ( i ? ( s [ i ] < 0 ? " -  " : " +  " ) : "  " ) << abs ( s [ i ] ) << "   " ; cout << " =  " << n << endl ; }
TAB0 let n , a , b , c , d , sum , l1 , l2 be integers ; TAB1 read n , a , b , c , d , sum , l1 , l2 ; TAB1 if a is equal to 0 ; TAB2 assign b to l1 ; TAB1 else if a is equal to n ; TAB2 assign 3 * n - b to l1 ; TAB1 else if b is equal to 0 ; TAB2 assign 4 * n - a to l1 ; TAB1 else if b is equal to n ; TAB2 assign n + a to l1 ; TAB1 if c is equal to 0 ; TAB2 assign d to l2 ; TAB1 else if c is equal to n ; TAB2 assign 3 * n - d to l2 ; TAB1 else if d is equal to 0 ; TAB2 assign 4 * n - c to l2 ; TAB1 else if d is equal to n ; TAB2 assign n + c to l2 ; TAB1 display call min with arguments absolute value of ( l1 - l2 ) , 4 * n - absolute value of ( l1 - l2 ) ;	int n , a , b , c , d , sum , l1 , l2 ; int main ( ) { cin >> n >> a >> b >> c >> d ; if ( a == 0 ) l1 = b ; else if ( a == n ) l1 = 3 * n - b ; else if ( b == 0 ) l1 = 4 * n - a ; else if ( b == n ) l1 = n + a ; if ( c == 0 ) l2 = d ; else if ( c == n ) l2 = 3 * n - d ; else if ( d == 0 ) l2 = 4 * n - c ; else if ( d == n ) l2 = n + c ; cout << min ( abs ( l1 - l2 ) , 4 * n - abs ( l1 - l2 ) ) << endl ; }
TAB0 create const long long integer mod = 1e9 + 9 ; TAB0 declare mod_pow taking in long long ints x and n and returning long long integer ; TAB1 make long long res = 1 ; TAB1 while n is greater than 0 ; TAB2 if n & 1 is truthy , set res to res * x % mod ; TAB2 set x to x * x % mod ; TAB2 move bits of n 1 place to right ; TAB1 return res ; TAB0 declare extgcd taking in long long ints a , b , & x , and & y and returning long long integer ; TAB1 make long long int d = a ; TAB1 if b is not 0 ; TAB2 set d to extgcd ( b , a % b , y , x ) ; TAB2 set y to y - ( a / b ) * x ; TAB1 else do ; TAB2 set x to 1 ; TAB2 set y to 0 ; TAB1 return d ; TAB0 declare mod_inverse taking in long long a and returning long long int ; TAB1 create long long ints x , y , and m ; TAB1 set m to mod ; TAB1 call extgcd ( a , m , x , y ) ; TAB1 return the result of ( m + x % m ) % m ; TAB1 make long long ints n , a , b , k , ans , temp , rec , and q ; TAB1 make string s ; TAB1 read n , a , b , and k ; TAB1 read s ; TAB1 set ans to 0 ; TAB1 for i = 0 to k exclusive ; TAB2 set temp to ( mod_pow ( a , n - i ) * mod_pow ( b , i ) ) % mod ; TAB2 if s [ i ] is equal to ' + ' ; TAB3 set ans to ( ans + temp ) % mod ; TAB2 else do ; TAB3 set ans to ( ans - temp ) % mod ; TAB2 if ans is less than 0 , set ans to ans + mod ; TAB1 if n + 1 is k ; TAB2 print ans ; TAB1 set rec to ( n + 1 ) / k ; TAB1 set q to mod_pow ( ( mod_inverse ( a ) * b ) % mod , k ) % mod ; TAB1 if q is equal to 1 ; TAB2 set ans to ( ans * rec ) % mod ; TAB1 otherwise ; TAB2 set ans to ( ( ans * ( mod_pow ( q , rec ) - 1 ) % mod ) * mod_inverse ( q - 1 ) ) % mod ; TAB1 display ans ;	const long long mod = 1e9 + 9 ; long long mod_pow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % mod ; x = x * x % mod ; n >>= 1 ; } return res ; } long long extgcd ( long long a , long long b , long long & x , long long & y ) { long long d = a ; if ( b != 0 ) { d = extgcd ( b , a % b , y , x ) ; y -= ( a / b ) * x ; } else { x = 1 ; y = 0 ; } return d ; } long long mod_inverse ( long long a ) { long long x , y , m ; m = mod ; extgcd ( a , m , x , y ) ; return ( m + x % m ) % m ; } int main ( ) { long long n , a , b , k , ans , temp , rec , q ; string s ; cin >> n >> a >> b >> k ; cin >> s ; ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { temp = ( mod_pow ( a , n - i ) * mod_pow ( b , i ) ) % mod ; if ( s [ i ] == ' + ' ) ans = ( ans + temp ) % mod ; else ans = ( ans - temp ) % mod ; if ( ans < 0 ) ans += mod ; } if ( n + 1 == k ) { cout << ans << endl ; return 0 ; } rec = ( n + 1 ) / k ; q = mod_pow ( ( mod_inverse ( a ) * b ) % mod , k ) % mod ; if ( q == 1 ) ans = ( ans * rec ) % mod ; else ans = ( ( ans * ( mod_pow ( q , rec ) - 1 ) % mod ) * mod_inverse ( q - 1 ) ) % mod ; cout << ans << endl ; return 0 ; }
TAB0 define gcd which takes long long a , b as arguments and return long long ; TAB1 return a if b = = 0 else gcd of b , a mod b ; TAB0 define lcm which takes long long a , b as arguments and return long long ; TAB1 return a * ( b / gcd of a , b ) ; TAB0 let q be const integer with q = 1e9 + 7 ; TAB0 let ans be long long with ans = 0 ; TAB0 let v be vector of integers ; TAB1 let n , f , iv , l be long lon ; TAB1 read n , f , iv , l ; TAB1 increment l by iv ; TAB1 update ans to l / f ; TAB1 if l % f , increment ans ; TAB1 if ans * f > n ; TAB2 print - 1 with newline ; TAB1 else ; TAB2 print out ans with newline ;	long long gcd ( long long a , long long b ) { return b == 0 ? a : gcd ( b , a % b ) ; } long long lcm ( long long a , long long b ) { return a * ( b / gcd ( a , b ) ) ; } const int q = 1e9 + 7 ; long long ans = 0 ; vector < int > v ; int main ( ) { long long n , f , iv , l ; cin >> n >> f >> iv >> l ; l += iv ; ans = l / f ; if ( l % f ) ans ++ ; if ( ans * f > n ) cout << - 1 << ' \n ' ; else cout << ans << ' \n ' ; return 0 ; }
TAB0 let MAXN be a constant integer with MAXN = 1001 ; TAB0 let INF be a constant integers with INF = 1e6 + 1 ; TAB0 in = array of integers of length MAXN ; TAB0 out = array of integers of length MAXN ; TAB0 d = array of integers of length MAXN ; TAB0 let n , m be integers ; TAB1 read n , m ; TAB1 for i = 0 to n exclusive , out [ i ] is equal to - 1 ; TAB1 for i = 0 to m exclusive ; TAB2 let a , b , c be integers ; TAB2 read a , b , c ; TAB2 decrement a by 1 ; TAB2 decrement b by 1 ; TAB2 increment in [ b ] by 1 ; TAB2 out [ a ] is equal to b ; TAB2 d [ a ] is equal to c ; TAB1 let r1 , r2 , r3 be vectors of integer elements ; TAB1 for i = 0 to n exclusive ; TAB2 if in [ i ] is equal to 0 and out [ i ] is not equal to - 1 ; TAB3 let j be a integer with j = i ; TAB3 let res be a integer with res = INF ; TAB3 while out [ j ] is not equal to - 1 ; TAB4 res is equal to minimum of res , d [ j ] ; TAB4 j is equal to out [ j ] ; TAB3 push_back i + 1 into r1 ; TAB3 push_back j + 1 into r2 ; TAB3 push_back res into r3 ; TAB1 print length of r1 and newline ; TAB1 for i = 0 to length of r1 exclusive , print r1 [ i ] and space and r2 [ i ] and space and r3 [ i ] and new line ;	const int MAXN = 1001 ; const int INF = 1e6 + 1 ; int in [ MAXN ] ; int out [ MAXN ] ; int d [ MAXN ] ; int n , m ; int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { out [ i ] = - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int a , b , c ; cin >> a >> b >> c ; a -- ; b -- ; in [ b ] ++ ; out [ a ] = b ; d [ a ] = c ; } vector < int > r1 , r2 , r3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( in [ i ] == 0 && out [ i ] != - 1 ) { int j = i ; int res = INF ; while ( out [ j ] != - 1 ) { res = min ( res , d [ j ] ) ; j = out [ j ] ; } r1 . push_back ( i + 1 ) ; r2 . push_back ( j + 1 ) ; r3 . push_back ( res ) ; } } cout << r1 . size ( ) << endl ; for ( int i = 0 ; i < r1 . size ( ) ; i ++ ) { cout << r1 [ i ] << "   " << r2 [ i ] << "   " << r3 [ i ] << endl ; } return 0 ; }
TAB0 dp = long long array of size 5000 ; TAB0 m = long long and long long map ; TAB1 n = long long ; TAB1 read n ; TAB1 s = string ; TAB1 read s ; TAB1 cnt = long long with cnt = 0 ; TAB1 for i = 0 to size of s ; TAB2 if i is not 0 ; TAB3 set dp [ i + 1 ] to dp [ i ] + ( s [ i ] - ' 0 ' ) ; TAB2 else ; TAB3 set dp [ i + 1 ] to s [ i ] - ' 0 ' ; TAB1 for i = 1 to size of s inclusive ; TAB2 for j = 1 to i inclusive ; TAB3 increment m [ dp [ i ] - dp [ j - 1 ] ] ; TAB3 increment cnt ; TAB1 if n is 0 ; TAB2 ans2 = long long with ans2 = m [ 0 ] * 2 * cnt - m [ 0 ] * m [ 0 ] ; TAB2 print ans2 ; TAB1 ans = long long with ans = 0 ; TAB1 for i = 1 to sqrt of n inclusive ; TAB2 if n is a multiple of i and i is not sqrt of n ; TAB3 increment ans by 2 * ( m [ i ] * m [ n / i ] ) ; TAB2 else if i is sqrt of n ; TAB3 increment ans by ( m [ i ] * m [ n / i ] ) ; TAB1 print ans ;	long long dp [ 5000 ] ; map < long long , long long > m ; int main ( ) { long long n ; cin >> n ; string s ; cin >> s ; long long cnt = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i != 0 ) dp [ i + 1 ] = dp [ i ] + ( s [ i ] - ' 0 ' ) ; else dp [ i + 1 ] = s [ i ] - ' 0 ' ; } for ( int i = 1 ; i <= s . size ( ) ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { m [ dp [ i ] - dp [ j - 1 ] ] ++ ; cnt ++ ; } } if ( n == 0 ) { long long ans2 = m [ 0 ] * 2 * cnt - m [ 0 ] * m [ 0 ] ; cout << ans2 << endl ; return 0 ; } long long ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 && ! ( i == sqrt ( n ) ) ) { ans += 2 * ( m [ i ] * m [ n / i ] ) ; } else if ( i == sqrt ( n ) ) { ans += ( m [ i ] * m [ n / i ] ) ; } } cout << ans << endl ; return 0 ; }
TAB0 let MX be a constant integer with MX = 100005 ; TAB0 let n be a integer ; TAB0 let a be a pair of two integer values ; TAB1 read n ; TAB1 for integer i = 0 to n exclusive , read a [ i ] . first and a [ i ] . second ; TAB1 sort the values a and a + n ; TAB1 let i , j , acu be integers with all values equal to 0 ; TAB1 while i is less than n ; TAB2 j equals a [ i ] . first ; TAB2 acu equals maximum value of max ( acu , a [ i ] . second ) ; TAB2 while acu is greater than 1 and i + 1 equals to n or j is less than a [ i + 1 ] . first ) , ; TAB3 acu equals ( acu + 3 ) / 4 ; TAB3 increase j value by 1 ; TAB2 increase i value by 1 ; TAB1 print maximum of , a [ n - 1 ] . first + 1 and new line ;	const int MX = 100005 ; int n ; pair < int , int > a [ MX ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] . first >> a [ i ] . second ; sort ( a , a + n ) ; int i = 0 , j = 0 , acu = 0 ; while ( i < n ) { j = a [ i ] . first ; acu = max ( acu , a [ i ] . second ) ; while ( acu > 1 && ( i + 1 == n || j < a [ i + 1 ] . first ) ) { acu = ( acu + 3 ) / 4 ; j ++ ; } i ++ ; } cout << max ( j , a [ n - 1 ] . first + 1 ) << ' \n ' ; return 0 ; }
TAB1 n = integer ; TAB1 while read n ; TAB2 a = integer array of size 110 ; TAB2 cnt = integer with cnt = 0 ; TAB2 s = integer array of size 110 ; TAB2 set all contents of s to 0 ; TAB2 m = integer with m = 0 ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] < 0 , increment cnt ; TAB3 increment s [ m ] ; TAB3 if cnt is 2 and i + 1 < n and a [ i + 1 ] < 0 ; TAB4 increment m ; TAB4 cnt = 0 ; TAB2 print m + 1 ; TAB2 for i = 0 to m ; TAB3 if i , print " " ; TAB3 print s [ i ] ; TAB2 print new line ;	int main ( ) { int n ; while ( cin >> n ) { int a [ 110 ] ; int cnt = 0 ; int s [ 110 ] ; memset ( s , 0 , sizeof ( s ) ) ; int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 0 ) cnt ++ ; s [ m ] ++ ; if ( cnt == 2 && i + 1 < n && a [ i + 1 ] < 0 ) { m ++ ; cnt = 0 ; } } cout << m + 1 << endl ; for ( int i = 0 ; i <= m ; i ++ ) { if ( i ) cout << "   " ; cout << s [ i ] ; } cout << endl ; } return 0 ; }
TAB0 declare character array a size 104 ; TAB0 declare integers n , j , t , e , sum ; TAB1 read string into a ; TAB1 declare l = string length of a as integer ; TAB1 for i = 0 to l exclusive ; TAB2 if a [ i ] is ' n ' , increment n ; TAB2 if a [ i ] is ' i ' , increment j ; TAB2 if a [ i ] is ' e ' , increment e ; TAB2 if a [ i ] is ' t ' , increment t ; TAB1 let sum be minimum of ( minimum of ( minimum of ( t and j ) and e / 3 ) and ( n - 1 ) / 2 ) ; TAB1 print sum and newline ;	char a [ 104 ] ; int n , j , t , e , sum ; int main ( ) { gets ( a ) ; int l = strlen ( a ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' n ' ) n ++ ; if ( a [ i ] == ' i ' ) j ++ ; if ( a [ i ] == ' e ' ) e ++ ; if ( a [ i ] == ' t ' ) t ++ ; } sum = min ( min ( min ( t , j ) , e / 3 ) , ( n - 1 ) / 2 ) ; cout << sum << endl ; return 0 ; }
TAB0 s , ss = set of int ; TAB0 n , p , a , b , d = int ; TAB0 in = array of 100005 pair of int , int ; TAB1 read n , p ; TAB1 for i = 0 to p exclusive ; TAB2 read a , b , d ; TAB2 in [ a ] = b and d , insert b into s and a into ss ; TAB1 a = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if i is not present in s and is present in ss increment a ; TAB1 print a ; TAB1 for i = 1 to n inclusive ; TAB2 if i is not present in s and is present in ss ; TAB3 a = i , b = second item of in [ i ] ; TAB3 while first item of in [ a ] b = min ( b , second item of in [ a ] ) , a = first item of in [ a ] ; TAB3 print i , space , a , space , b ;	set < int > s , ss ; int n , p , a , b , d ; pair < int , int > in [ 100005 ] ; int main ( ) { cin >> n >> p ; for ( int i = 0 ; i < p ; i ++ ) { cin >> a >> b >> d ; in [ a ] = make_pair ( b , d ) , s . insert ( b ) , ss . insert ( a ) ; } a = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! s . count ( i ) && ss . count ( i ) ) a ++ ; cout << a << endl ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! s . count ( i ) && ss . count ( i ) ) { a = i , b = in [ i ] . second ; while ( in [ a ] . first ) b = min ( b , in [ a ] . second ) , a = in [ a ] . first ; cout << i << "   " << a << "   " << b << endl ; } } return 0 ; }
TAB0 let n be an integer , let a be an integer array of size 500008 ; TAB0 let slove be a function that takes int x and int y as parameters ; TAB1 let integer k = y = x + 1 ; TAB1 let i be an integer ; TAB1 if k is even ; TAB2 for i = x to x + k / 2 , let a [ i ] equal a [ x ] ; TAB2 for i = x + k / 2 to y inclusive , let a [ i ] equal a [ y ] ; TAB1 if first if statement was false ; TAB2 for i - x + 1 to y inclusive , let a [ i ] be equal to a [ x ] ; TAB1 return ( k - 1 ) / 2 to main method ; TAB1 let ans , l , r be integers ; TAB1 let i be an integer ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 let ans equal 0 ; TAB1 for i = 2 to n ; TAB2 if a [ i ] is not equal to a [ i - 1 ] AND a [ i ] is not equal to a [ i + 1 ] ; TAB3 let l = i - 1 ; TAB3 add one to i ; TAB3 for i is smaller than n ; TAB4 if a [ i ] is not equal to a [ i - 1 ] AND a [ i ] is not equal to a [ i + 1 ] ; TAB5 continue on ; TAB4 if last if statement was false ; TAB5 break out of loop ; TAB3 let r equal i ; TAB3 let ans equal to the larger value of either ans or slove ( l , r ) ; TAB3 let l equal 0 ; TAB3 let r equal 0 ; TAB1 print ans and endline ; TAB1 for i = 1 to n , print a [ i ] and a space after it ; TAB1 print a [ i ] and endline ;	int a [ 500008 ] , n ; int slove ( int x , int y ) { int k = y - x + 1 ; int i ; if ( k % 2 == 0 ) { for ( i = x ; i < x + k / 2 ; i ++ ) { a [ i ] = a [ x ] ; } for ( i = x + k / 2 ; i <= y ; i ++ ) { a [ i ] = a [ y ] ; } } else { for ( i = x + 1 ; i <= y ; i ++ ) { a [ i ] = a [ x ] ; } } return ( k - 1 ) / 2 ; } int main ( ) { int ans , l , r ; int i ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } ans = 0 ; for ( i = 2 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] && a [ i ] != a [ i + 1 ] ) { l = i - 1 ; i ++ ; for ( ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] && a [ i ] != a [ i + 1 ] ) { continue ; } else { break ; } } r = i ; ans = max ( ans , slove ( l , r ) ) ; l = 0 ; r = 0 ; } } cout << ans << endl ; for ( i = 1 ; i < n ; i ++ ) { cout << a [ i ] << "   " ; } cout << a [ i ] << endl ; }
TAB1 x , y , xx , yy = 0 , k = 2 , c = 1 ; TAB1 mp = map from pair of int to int ; TAB1 while true ; TAB2 increment c ; TAB2 x = ( x * - 1 ) + 1 ; TAB2 if x is xx ; TAB3 for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2 ; TAB2 else ; TAB3 for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2 ; TAB2 if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ] ; TAB2 xx = x ; TAB2 y = ( y * - 1 ) + 1 ; TAB2 increment c ; TAB2 if x is xx ; TAB3 for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2 ; TAB2 else ; TAB3 for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2 ; TAB2 if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ] ; TAB2 yy = y ; TAB2 multiply x by - 1 ; TAB2 increment c ; TAB2 if x is xx ; TAB3 for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2 ; TAB2 else ; TAB3 for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2 ; TAB2 if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ] ; TAB2 xx = x ; TAB2 multiply y by - 1 ; TAB2 increment c ; TAB2 if x is xx ; TAB3 for i = min ( y , yy ) to max ( y , yy ) inclusive mp [ make_pair ( x , i ) ] = c - 2 ; TAB2 else ; TAB3 for i = min ( x , xx ) to max ( x , xx ) inclusive mp [ make_pair ( i , y ) ] = c - 2 ; TAB2 if mp [ make_pair ( x , y ) ] equal mp [ make_pair ( xx , yy ) ] decrement mp [ make_pair ( xx , yy ) ] ; TAB2 yy = y ; TAB2 if x is - 100 or y is - 100 break ; TAB1 mp [ make_pair ( 0 , 0 ) ] = 0 ; TAB1 a , b = int ; TAB1 read a and b ; TAB1 if ( a is 0 and b is 0 ) or ( a is 1 and b is 0 ) print 0 , newline , 0 ; TAB1 if mp [ make_pair ( a , b ) ] is 0 ; TAB2 print mp [ make_pair ( b , a ) ] + 1 ; TAB1 else ; TAB2 print mp [ make_pair ( a , b ) ] ;	int main ( ) { int x = 0 , y = 0 , xx = 0 , yy = 0 , k = 2 , c = 1 ; map < pair < int , int > , int > mp ; while ( 1 ) { c ++ ; x = ( x * - 1 ) + 1 ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; xx = x ; y = ( y * - 1 ) + 1 ; c ++ ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; yy = y ; x *= - 1 ; c ++ ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; xx = x ; y *= - 1 ; c ++ ; if ( x == xx ) for ( int i = min ( y , yy ) ; i <= max ( y , yy ) ; i ++ ) mp [ make_pair ( x , i ) ] = c - 2 ; else for ( int i = min ( x , xx ) ; i <= max ( x , xx ) ; i ++ ) mp [ make_pair ( i , y ) ] = c - 2 ; if ( mp [ make_pair ( x , y ) ] == mp [ make_pair ( xx , yy ) ] ) mp [ make_pair ( xx , yy ) ] -- ; yy = y ; if ( x == - 100 && y == - 100 ) break ; } mp [ make_pair ( 0 , 0 ) ] = 0 ; int a , b ; cin >> a >> b ; if ( ( a == 0 && b == 0 ) || ( a == 1 && b == 0 ) ) return cout << 0 << ' \n ' , 0 ; if ( mp [ make_pair ( a , b ) ] == 0 ) cout << mp [ make_pair ( b , a ) ] + 1 << ' \n ' ; else cout << mp [ make_pair ( a , b ) ] << ' \n ' ; }
TAB1 declare long longs i , j = 0 , n , l = 0 , declare long long array a size 1000 , b size 1001 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] and b [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if j is not i and a [ i ] is b [ j ] ; TAB4 increment l ; TAB4 end loop ; TAB1 print n - l and newline ;	int main ( ) { long long i , j = 0 , a [ 1000 ] , b [ 1001 ] , n , l = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( j != i && a [ i ] == b [ j ] ) { l ++ ; break ; } } } cout << n - l << endl ; return 0 ; }
TAB0 n , i are integers ; TAB1 read n ; TAB1 if n & 1 ; TAB2 n equals n shifted bitwise by 1 to right ; TAB1 else ; TAB2 for i = 1 to n inclusive ; TAB3 end statement ; TAB2 n equals n - ( i > > 1 ) shifted bitwise by 1 to right ; TAB1 print n and endline ;	int n , i ; int main ( ) { cin >> n ; if ( n & 1 ) n = n >> 1 ; else { for ( i = 1 ; i <= n ; i <<= 1 ) ; n = ( n - ( i >> 1 ) ) >> 1 ; } cout << n << endl ; return 0 ; }
TAB1 n , m = integer , u = integer = 0 , e = integer = 0 , x = integer = 1 , p = integer = 0 ; TAB1 read n , m ; TAB1 s , t = string ; TAB1 read s , t ; TAB1 if n - 1 > m ; TAB2 print NO ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is not t [ i ] and s [ i ] is not * ; TAB2 if s [ i ] is * ; TAB3 e = i ; TAB3 increase p by 1 ; TAB3 exit the for loop ; TAB1 for i = n - 1 to e exclusive , decrease i by 1 ; TAB2 if s [ i ] is not t [ m - x ] , then increase u by 1 ; TAB2 increase x by 1 ; TAB1 if u > = 1 or n - p > m ; TAB2 print NO ; TAB1 else if n < m and p is 0 ; TAB2 print NO ; TAB1 else ; TAB2 print YES ;	int main ( ) { int n , m , u = 0 , e = 0 , x = 1 , p = 0 ; cin >> n >> m ; string s , t ; cin >> s >> t ; if ( n - 1 > m ) { cout << " NO " << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != t [ i ] and s [ i ] != ' * ' ) u ++ ; if ( s [ i ] == ' * ' ) { e = i ; p ++ ; break ; } } for ( int i = n - 1 ; i > e ; i -- ) { if ( s [ i ] != t [ m - x ] ) { u ++ ; } x ++ ; } if ( u >= 1 or n - p > m ) cout << " NO " << endl ; else if ( n < m and p == 0 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 connected is a new array of integers with size 1005 ; TAB0 diameter is a new array of integers with size 1005 ; TAB0 create a new array of integers called in with 1005 elements ; TAB0 out is an array of integers with 1005 elements ; TAB1 declare integers n and p ; TAB1 read input to n and p ; TAB1 decrement p and loop further , while p is not 0 ; TAB2 declare integers a , b and d ; TAB2 read standard input to a , b and d ; TAB2 assign the new value = b to connected [ a ] ; TAB2 change the value of diameter [ a ] to d ; TAB2 increment in [ b ] ; TAB2 increment out [ a ] by one ; TAB1 declare integer variable with name sol = 0 ; TAB1 in a for loop , change i from 1 to n inclusive incrementing i ; TAB2 if in [ i ] = 0 and out [ i ] ! = 0 , increment sol ; TAB1 print sol and ' \ n ' ; TAB1 for integer i = 1 to n inclusive incrementing i ; TAB2 if in [ i ] is 0 and out [ i ] is not 0 ; TAB3 create integer variable with name id with value i ; TAB3 declare new integer ans with value INT_MAX ; TAB3 while out [ id ] is not 0 ; TAB4 assign min of ans and diameter [ id ] to ans ; TAB4 change the value of id to connected [ id ] ; TAB3 print i , ' ' , id , ' ' , ans and ' \ n ' ;	int connected [ 1005 ] ; int diameter [ 1005 ] ; int in [ 1005 ] ; int out [ 1005 ] ; int main ( ) { int n , p ; cin >> n >> p ; while ( p -- ) { int a , b , d ; cin >> a >> b >> d ; connected [ a ] = b ; diameter [ a ] = d ; in [ b ] ++ ; out [ a ] ++ ; } int sol = 0 ; ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! in [ i ] && out [ i ] ) sol ++ ; cout << sol << ' \n ' ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! in [ i ] && out [ i ] ) { int id = i ; int ans = INT_MAX ; while ( out [ id ] ) { ans = min ( ans , diameter [ id ] ) ; id = connected [ id ] ; } cout << i << '   ' << id << '   ' << ans << ' \n ' ; } } return 0 ; }
TAB0 arr1 = array of integers of length 110 ; TAB0 arr2 = array of integers of length 110 ; TAB1 let i , j , ind , count , n be integers with ind = 0 , count = 0 ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read arr1 [ i ] , arr2 [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 ind is equal to 0 ; TAB2 for j = 1 to n inclusive ; TAB3 if i is not equal to j ; TAB4 if arr2 [ j ] is equal to arr1 [ i ] , ind is equal to 1 ; TAB2 if not ind , increment count by 1 ; TAB1 print count and newline ;	int arr1 [ 110 ] ; int arr2 [ 110 ] ; int main ( ) { int i , j , ind = 0 , count = 0 , n ; cin >> n ; for ( i = 1 ; i <= n ; ++ i ) cin >> arr1 [ i ] >> arr2 [ i ] ; for ( i = 1 ; i <= n ; ++ i ) { ind = 0 ; for ( j = 1 ; j <= n ; ++ j ) { if ( i != j ) { if ( arr2 [ j ] == arr1 [ i ] ) ind = 1 ; } } if ( ! ind ) count ++ ; } cout << count << endl ; return 0 ; }
TAB1 create long long ints n , d , and m = 0 and int array x of size 100005 ; TAB1 read n and d ; TAB1 for i = 1 to n , read x [ i ] ; TAB1 for i = 1 to n - 2 ; TAB2 make long long ints l = i and r = n + 1 ; TAB2 while r - 1 is greater than 1 ; TAB3 make long long mid = ( l + r ) / 2 ; TAB3 if x [ mid ] - x [ i ] is greater than d ; TAB4 set r to mid ; TAB3 else do ; TAB4 set l to mid ; TAB2 add max ( 0 * 1ll , ( l - i - 1 ) ) * ( l - i ) / 2 to m ; TAB1 display m ;	int main ( ) { long long n , d , x [ 100005 ] , m = 0 ; cin >> n >> d ; for ( int i = 1 ; i <= n ; i ++ ) cin >> x [ i ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { long long l = i , r = n + 1 ; while ( r - l > 1 ) { long long mid = ( l + r ) / 2 ; if ( x [ mid ] - x [ i ] > d ) r = mid ; else l = mid ; } m += max ( 0 * 1ll , ( l - i - 1 ) ) * ( l - i ) / 2 ; } cout << m << endl ; return 0 ; }
TAB1 n , m , a , b , ans1 , ans2 = integer ; TAB1 read n , m , a , b ; TAB1 row1 = integer = ( a - 1 ) / m ; TAB1 row2 = integer = ( a - 1 ) / m ; TAB1 col1 = integer = m if a modulo m is 0 else col1 = a modulo m ; TAB1 col2 = integer = m if b modulo m is 0 else col2 = b modulo m ; TAB1 if row1 is row2 ; TAB2 ans1 = 1 ; TAB1 else if row2 - row1 is 1 ; TAB2 ans1 = 2 ; TAB2 if col1 is 1 and b is n ; TAB3 ans1 = 1 ; TAB2 else if col1 is 1 and col2 is m ; TAB3 ans1 = 1 ; TAB1 else ; TAB2 ans1 = 3 ; TAB2 if b is n or col2 is m , decrease ans1 by 1 ; TAB2 if col1 is 1 , decrease ans1 by 1 ; TAB1 ans2 = 3 ; TAB1 if col1 - 1 is col2 , then increase ans2 by 1 ; TAB1 print the lower value between ans1 and ans2 ;	int main ( ) { int n , m , a , b , ans1 , ans2 ; cin >> n >> m >> a >> b ; int row1 = ( a - 1 ) / m ; int row2 = ( b - 1 ) / m ; int col1 = a % m == 0 ? m : a % m ; int col2 = b % m == 0 ? m : b % m ; if ( row1 == row2 ) ans1 = 1 ; else if ( row2 - row1 == 1 ) { ans1 = 2 ; if ( col1 == 1 && b == n ) ans1 = 1 ; else if ( col1 == 1 && col2 == m ) ans1 = 1 ; } else { ans1 = 3 ; if ( b == n || col2 == m ) -- ans1 ; if ( col1 == 1 ) -- ans1 ; } ans2 = 3 ; if ( col1 - 1 == col2 ) -- ans2 ; cout << min ( ans1 , ans2 ) << endl ; return 0 ; }
TAB0 create constant integer INF_INT = 2147483647 ; TAB0 create new constant long long INF_LL with value 9223372036854775807LL ; TAB0 declare new unsigned long long constant INF_ULL = 18446744073709551615Ull ; TAB0 define new constant long long P with value 92540646808111039LL ; TAB0 declare long long constants maxn = 1e5 + 10 and MOD = 1e9 + 7 ; TAB0 create new 2d array of integers Move , with size 4 by 2 and filled by values - 1 , 0 , 1 , 0 , 0 , 1 , 0 , - 1 ; TAB0 define 2d array of integers Move_ 8 by 2 elements , filled by values - 1 , - 1 , - 1 , 0 , - 1 , 1 , 0 , - 1 , 0 , 1 , 1 , - 1 , 1 , 0 , 1 and 1 ; TAB0 define inlined function read that returns integer ; TAB1 create new integers x = 0 and f = 1 ; TAB1 create character variable with name ch and value read from the input ; TAB1 while ch is not a digit ; TAB2 if ch is equal to ' - ' , set f to - 1 ; TAB2 change ch to character from the input ; TAB1 while ch is a digit character ; TAB2 change the value of x to x * 10 + ch - ' 0 ' ; TAB2 change ch to char from the input ; TAB1 return x multiplied by f ; TAB0 void function init ; TAB1 call function init ( ) ; TAB1 declare long long variables n , a , b and c ; TAB1 read n , a , b and c from the user input ; TAB1 if n is less than b ; TAB2 print n / a ; TAB1 if a < = b - c ; TAB2 if n % a > = b ; TAB3 print ( n / a ) + 1 + ( ( n % a ) - b ) / ( b - c ) ; TAB2 else ; TAB3 print n / a ; TAB1 else ; TAB2 create long long variable t with value 1 + ( n - b ) / ( b - c ) ; TAB2 decrease n by t * ( b - c ) ; TAB2 print t + n / a ;	const int INF_INT = 2147483647 ; const long long INF_LL = 9223372036854775807LL ; const unsigned long long INF_ULL = 18446744073709551615Ull ; const long long P = 92540646808111039LL ; const long long maxn = 1e5 + 10 , MOD = 1e9 + 7 ; const int Move [ 4 ] [ 2 ] = { - 1 , 0 , 1 , 0 , 0 , 1 , 0 , - 1 } ; const int Move_ [ 8 ] [ 2 ] = { - 1 , - 1 , - 1 , 0 , - 1 , 1 , 0 , - 1 , 0 , 1 , 1 , - 1 , 1 , 0 , 1 , 1 } ; inline int read ( ) { int x = 0 , f = 1 ; char ch = getchar ( ) ; while ( ch < ' 0 ' || ch > ' 9 ' ) { if ( ch == ' - ' ) f = - 1 ; ch = getchar ( ) ; } while ( ch >= ' 0 ' && ch <= ' 9 ' ) { x = x * 10 + ch - ' 0 ' ; ch = getchar ( ) ; } return x * f ; } void init ( ) { } int main ( ) { init ( ) ; long long n , a , b , c ; cin >> n >> a >> b >> c ; if ( n < b ) { cout << n / a << endl ; return 0 ; } if ( a <= b - c ) { if ( n % a >= b ) { cout << ( n / a ) + 1 + ( ( n % a ) - b ) / ( b - c ) << endl ; return 0 ; } else cout << ( n / a ) << endl ; return 0 ; } else { long long t = 1 + ( n - b ) / ( b - c ) ; n -= t * ( b - c ) ; cout << t + n / a << endl ; } return 0 ; }
TAB0 declare function rh taking float array and returning bool ; TAB0 declare function zero2 taking float array and returning bool ; TAB1 i = int with i = 0 ; TAB1 A = float array of size 6 ; TAB1 read 6 values into A ; TAB1 if A [ 2 ] is 0 and a [ 3 ] is not 0 ; TAB2 print " Ron " ; TAB1 else if rh of A ; TAB2 print " Hermione " ; TAB1 else if A [ 0 ] is 0 and a [ 1 ] is not 0 ; TAB2 print " Ron " ; TAB1 else ; TAB2 set A [ 3 ] to A [ 3 ] / ( A [ 2 ] / A [ 1 ] ) ; TAB2 set A [ 5 ] to A [ 5 ] / ( A [ 4 ] / A [ 3 ] ) ; TAB2 if A [ 5 ] > A [ 0 ] ; TAB3 print " Ron " ; TAB2 else ; TAB3 print " Hermione " ; TAB0 in function rh taking float array A and returning bool ; TAB1 if A [ 2 ] is not 0 and A [ 3 ] is 0 ; TAB2 return true ; TAB1 else if zero2 of A ; TAB2 return true ; TAB1 return false ; TAB0 in function zero2 taking float array A and returning bool ; TAB1 for i = 0 to 4 ; TAB2 if A [ i ] is 0 and A [ i + 1 ] is 0 return true ; TAB1 return false ;	bool rh ( float [ ] ) ; bool zero2 ( float [ ] ) ; int main ( ) { int i = 0 ; float A [ 6 ] ; for ( int i = 0 ; i < 6 ; i ++ ) cin >> A [ i ] ; if ( A [ 2 ] == 0 && A [ 3 ] != 0 ) cout << " Ron " << endl ; else if ( rh ( A ) ) cout << " Hermione " << endl ; else if ( A [ 0 ] == 0 && A [ 1 ] != 0 ) cout << " Ron " << endl ; else { A [ 3 ] = A [ 3 ] / ( A [ 2 ] / A [ 1 ] ) ; A [ 5 ] = A [ 5 ] / ( A [ 4 ] / A [ 3 ] ) ; if ( A [ 5 ] > A [ 0 ] ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; } } bool rh ( float A [ ] ) { if ( A [ 2 ] != 0 && A [ 3 ] == 0 ) return true ; else if ( zero2 ( A ) ) return true ; return false ; } bool zero2 ( float A [ ] ) { for ( int i = 0 ; i < 4 ; i ++ ) if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) return true ; return false ; }
TAB0 getPoint is a int function with int arguments x , y and n ; TAB1 if y is equal to 0 ; TAB2 return x ; TAB1 else if x = n ; TAB2 return x + y ; TAB1 else if y = n ; TAB2 return 3 * n - x ; TAB1 else ; TAB2 return 4 * n - y ; TAB1 declare int variables n , a , b , c and d ; TAB1 read n , a , b , c and d ; TAB1 declare int variables p1 = getPoint ( a , b , n ) and p2 = getPoint ( c , d , n ) ; TAB1 print min of ( p1 - p2 + 4 * n ) % ( 4 * n ) and ( p2 - p1 + 4 * n ) % ( 4 * n ) ;	int getPoint ( int x , int y , int n ) { if ( y == 0 ) { return x ; } else if ( x == n ) { return x + y ; } else if ( y == n ) { return 3 * n - x ; } else { return 4 * n - y ; } } int main ( ) { int n , a , b , c , d ; cin >> n >> a >> b >> c >> d ; int p1 = getPoint ( a , b , n ) , p2 = getPoint ( c , d , n ) ; cout << min ( ( p1 - p2 + 4 * n ) % ( 4 * n ) , ( p2 - p1 + 4 * n ) % ( 4 * n ) ) << endl ; return 0 ; }
TAB1 x , y , ans = int with ans = 0 ; TAB1 read x then y ; TAB1 p = int ; TAB1 set p to max of absolute x and absolute y ; TAB1 if x is p and x is greater than 0 and x + y is greater than 1 ; TAB2 decrement p then set ans to p ; TAB2 set ans to ans * 4 ; TAB2 increment ans ; TAB1 else if y is p and y is greater than 0 and y - x is greater than 0 ; TAB2 set ans to p ; TAB2 set ans to ans * 4 ; TAB2 subtract 2 from ans ; TAB1 else if x is - 1 * p and x is less than 0 and x + y is less than 0 ; TAB2 set ans to p ; TAB2 set ans to ans * 4 ; TAB2 decrement ans ; TAB1 else ; TAB2 if x + y is 1 ; TAB3 decrement x ; TAB3 set ans to x ; TAB3 set ans to ans * 4 ; TAB2 else ; TAB3 set ans to p ; TAB3 set ans to ans * 4 ; TAB1 if x and y are both 0 then set ans to 0 ; TAB1 set ans to max of ans and 0 ; TAB1 print ans ;	int main ( ) { int x , y , ans = 0 ; cin >> x >> y ; int p ; p = max ( abs ( x ) , abs ( y ) ) ; if ( x == p && x > 0 && x + y > 1 ) { ans = -- p ; ans *= 4 ; ++ ans ; } else if ( y == p && y > 0 && y - x > 0 ) { ans = p ; ans *= 4 ; ans -= 2 ; } else if ( x == ( - 1 * p ) && x < 0 && x + y < 0 ) { ans = p ; ans *= 4 ; -- ans ; } else { if ( x + y == 1 ) { x -- ; ans = x ; ans *= 4 ; } else { ans = p ; ans *= 4 ; } } if ( x == 0 && y == 0 ) ans = 0 ; ans = max ( ans , 0 ) ; cout << ans << endl ; }
TAB0 set integer num [ 110 ] to 0 ; TAB1 integers = n ; TAB1 read n ; TAB1 for i = 1 to less than or equal to n do the following ; TAB1 create integer vector p ; TAB1 set integer a to 0 , b ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 if i is n then do the following ; TAB3 if num [ i ] is greater than or equal to 0 then do the following ; TAB4 add one to a ; TAB4 add one to b ; TAB4 push_back part of p = b ; TAB3 else ; TAB4 if c is 2 then do the following ; TAB5 a equals a plus 2 ; TAB5 push_back part of p = b ; TAB5 push_back part of p = 1 ; TAB4 else ; TAB5 add one to a ; TAB5 push_back part of p = b + 1 ; TAB2 else ; TAB3 if num [ i ] is greater than or equal to 0 then do the following b + + ; TAB3 if num [ i ] is less than 0 then do the following ; TAB4 if c is 2 then do the following ; TAB5 add one to a ; TAB5 push_back part of p = b ; TAB5 set b to 1 ; TAB5 set c to 1 ; TAB4 else ; TAB5 add one to c ; TAB5 add one to b ; TAB1 output a ; TAB1 for i = 0 to less than p . size ( ) do the following ; TAB2 if i is false ; TAB3 output p [ i ] ; TAB2 else ; TAB3 output , p [ i ] ; TAB1 output endl ;	int num [ 110 ] = { 0 } ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> num [ i ] ; vector < int > p ; int a = 0 , b = 0 , c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == n ) { if ( num [ i ] >= 0 ) { a ++ ; b ++ ; p . push_back ( b ) ; } else { if ( c == 2 ) { a += 2 ; p . push_back ( b ) ; p . push_back ( 1 ) ; } else { a ++ ; p . push_back ( b + 1 ) ; } } } else { if ( num [ i ] >= 0 ) b ++ ; if ( num [ i ] < 0 ) { if ( c == 2 ) { a ++ ; p . push_back ( b ) ; b = 1 ; c = 1 ; } else { c ++ ; b ++ ; } } } } cout << a << endl ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { if ( ! i ) cout << p [ i ] ; else cout << "   " << p [ i ] ; } cout << endl ; }
TAB0 make string array S with a length of 4 ; TAB0 make integers I , J , K ; TAB0 in function jarak , returning int and accepting int x and int y ; TAB1 if y greater than x ; TAB2 return y - x ; TAB1 else ; TAB2 return ( y + 12 ) - x ; TAB1 make map A of string to int ; TAB1 set A [ " C " ] to 1 ; TAB1 set A [ " C # " ] to 2 ; TAB1 set A [ " D " ] to 3 ; TAB1 set A [ " D # " ] to 4 ; TAB1 set A [ " E " ] to 5 ; TAB1 set A [ " F " ] to 6 ; TAB1 set A [ " F # " ] to 7 ; TAB1 set A [ " G " ] to 8 ; TAB1 set A [ " G # " ] to 9 ; TAB1 set A [ " A " ] to 10 ; TAB1 set A [ " B " ] to 11 ; TAB1 set A [ " H " ] to 12 ; TAB1 read S [ 1 ] , S [ 2 ] , S [ 3 ] ; TAB1 for i = 1 to 3 inclusive ; TAB2 for j = 1 to 3 inclusive ; TAB3 for k = 1 to 3 inclusive ; TAB4 if i is not equal to j and i is not equal to k and j is not equal to k ; TAB5 assign A [ S [ i ] ] to I ; TAB5 assign A [ S [ j ] ] to J ; TAB5 assign A [ S [ k ] ] to K ; TAB5 if jarak ( I , K ) equals 7 ; TAB6 if jarak ( I , J ) equals 4 and jarak ( J , K ) equals 3 ; TAB7 print " major " ; TAB6 else if jarak ( I , J ) equals 3 and jarak ( J , K ) equals 4 ; TAB7 print " minor " ; TAB1 print " strange " ;	string S [ 4 ] ; int I , J , K ; int jarak ( int x , int y ) { if ( y > x ) return y - x ; else return ( y + 12 ) - x ; } int main ( ) { map < string , int > A ; A [ " C " ] = 1 ; A [ " C# " ] = 2 ; A [ " D " ] = 3 ; A [ " D# " ] = 4 ; A [ " E " ] = 5 ; A [ " F " ] = 6 ; A [ " F# " ] = 7 ; A [ " G " ] = 8 ; A [ " G# " ] = 9 ; A [ " A " ] = 10 ; A [ " B " ] = 11 ; A [ " H " ] = 12 ; cin >> S [ 1 ] >> S [ 2 ] >> S [ 3 ] ; for ( int i = 1 ; i <= 3 ; i ++ ) for ( int j = 1 ; j <= 3 ; j ++ ) for ( int k = 1 ; k <= 3 ; k ++ ) if ( i != j && i != k && j != k ) { I = A [ S [ i ] ] ; J = A [ S [ j ] ] ; K = A [ S [ k ] ] ; if ( jarak ( I , K ) == 7 ) { if ( jarak ( I , J ) == 4 && jarak ( J , K ) == 3 ) { cout << " major " << endl ; return 0 ; } else if ( jarak ( I , J ) == 3 && jarak ( J , K ) == 4 ) { cout << " minor " << endl ; return 0 ; } } } cout << " strange " << endl ; }
TAB1 create int n ; TAB1 read n ; TAB1 make int array a of size n ; TAB1 create int vector array banyakyangmilihini of size 2001 ; TAB1 create int array inilahhasilnya of size n ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 append i to banyakyangmilihini [ a [ i ] ] ; TAB1 make int i = 1 ; TAB1 for k = 2000 to 0 exclusive ; TAB2 if banyakyangmilihini [ k ] . size ( ) is more than 0 ; TAB3 for m = 0 to banyakyangmilihini [ k ] . size ( ) exclusive , set inilahhasilnya [ banyakyangmilihini [ k ] [ m ] ] to i ; TAB3 set i to i + banyakyangmilihini [ k ] . size ( ) ; TAB1 for k = 0 to n exclusive ; TAB2 if k is equal to 0 ; TAB3 print inilahhasilnya [ k ] ; TAB2 else do ; TAB3 print " " , and inilahhasilnya [ k ] ; TAB1 print new line ;	int main ( ) { int n ; cin >> n ; int a [ n ] = { } ; vector < int > banyakyangmilihini [ 2001 ] ; int inilahhasilnya [ n ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; banyakyangmilihini [ a [ i ] ] . push_back ( i ) ; } int i = 1 ; for ( int k = 2000 ; k > 0 ; k -- ) { if ( banyakyangmilihini [ k ] . size ( ) > 0 ) { for ( int m = 0 ; m < banyakyangmilihini [ k ] . size ( ) ; m ++ ) { inilahhasilnya [ banyakyangmilihini [ k ] [ m ] ] = i ; } i = i + banyakyangmilihini [ k ] . size ( ) ; } } for ( int k = 0 ; k < n ; k ++ ) { if ( k == 0 ) { cout << inilahhasilnya [ k ] ; } else { cout << "   " << inilahhasilnya [ k ] ; } } cout << endl ; }
TAB0 MAX_N = const int with MAX_N = 2000 ; TAB0 in function solve ; TAB1 s , u = string ; TAB1 read s then u ; TAB1 n = int with n = size of s ; TAB1 m = int with m = size of u ; TAB1 mierda = string with mierda = " " ; TAB1 append ' # ' to mierda MAX_N times ; TAB1 set s to mierda + s + mierda ; TAB1 answer = int with answer = m ; TAB1 for i = 0 to MAX_N inclusive ; TAB2 temp = int with temp = 0 ; TAB2 for j = 0 to m ; TAB3 if s [ i + j ] is not u [ j ] increment temp ; TAB2 set answer to min of answer , temp ; TAB1 print answer ; TAB1 t = int ; TAB1 set t to 1 ; TAB1 loop t times call solve ;	const int MAX_N = 2000 ; void solve ( ) { string s , u ; cin >> s >> u ; int n = s . size ( ) ; int m = u . size ( ) ; string mierda = "  " ; for ( int i = 0 ; i < MAX_N ; i ++ ) mierda += ' # ' ; s = mierda + s + mierda ; int answer = m ; for ( int i = 0 ; i <= MAX_N + n ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( s [ i + j ] != u [ j ] ) temp ++ ; } answer = min ( answer , temp ) ; } cout << answer << endl ; } int main ( ) { int t ; t = 1 ; while ( t -- ) solve ( ) ; return 0 ; }
TAB0 declare constant integer N = 2e6 + 123 ; TAB0 declare constant integer INF = 1e9 + 123 ; TAB0 declare constant integer MOD = 1e9 + 7 ; TAB0 declare constant double EPS = 1e - 9 ; TAB0 declare integers a , b , s ; TAB1 read a and b and s ; TAB1 if absolute value of a + absolute value of b is less than or equal to s or ( a is 0 and b is 0 ) ; TAB2 if ( absolute value of a + absolute value of b ) % 2 is s % 2 ; TAB3 print " Yes \ n " ; TAB2 else ; TAB3 print " No \ n " ; TAB1 else ; TAB2 print " No \ n " ;	const int N = 2e6 + 123 ; const int INF = 1e9 + 123 ; const int MOD = 1e9 + 7 ; const double EPS = 1e-9 ; int a , b , s ; int main ( ) { cin >> a >> b >> s ; if ( abs ( a ) + abs ( b ) <= s || ( a == 0 && b == 0 ) ) { if ( ( abs ( a ) + abs ( b ) ) % 2 == s % 2 ) cout << " Yes\n " ; else cout << " No\n " ; } else cout << " No\n " ; return 0 ; }
TAB1 declare integers t , s , x ; TAB1 read t and s and x ; TAB1 if x is t ; TAB2 print " YES " and newline ; TAB1 if x is less than t ; TAB2 print " NO " and newline ; TAB1 if ( ( x - t ) % s is 0 or ( x - t ) % s is 1 ) and x - t is greater than or equal to 0 and x - t is not 1 ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ;	int main ( ) { int t , s , x ; cin >> t >> s >> x ; if ( x == t ) { cout << " YES " << endl ; return 0 ; } if ( x < t ) { cout << " NO " << endl ; return 0 ; } if ( ( ( ( x - t ) % s == 0 ) || ( ( x - t ) % s == 1 ) ) && x - t >= 0 && x - t != 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 declare integer variables a , b , c , d , e and f ; TAB1 read from the input to a , b , c , d , e and f ; TAB1 if b * d * f is equal to 0 and a * c * e is equal to 0 ; TAB2 if c = 0 and d ! = 0 ; TAB3 print " Ron " ; TAB2 else if a = 0 and b ! = 0 and d ! = 0 ; TAB3 print " Ron " to the output stream ; TAB2 else ; TAB3 print " Hermione " ; TAB1 else if b * d * f < = a * c * e ; TAB2 print " Hermione " to the stdout ; TAB1 else ; TAB2 print " Ron " to the standard output ;	int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( b * d * f == 0 && a * c * e == 0 ) { if ( c == 0 && d != 0 ) cout << " Ron " << endl ; else if ( a == 0 && b != 0 && d != 0 ) { cout << " Ron " << endl ; } else cout << " Hermione " << endl ; } else if ( b * d * f <= a * c * e ) cout << " Hermione " << endl ; else cout << " Ron " << endl ; }
TAB0 N = static const int with N = 1005 ; TAB0 n , m = int ; TAB0 in , out , nxt , p = int array of size N each ; TAB0 from = int queue ; TAB0 to = int queue ; TAB0 len = int queue ; TAB1 read n then m ; TAB1 for i = 1 to m inclusive ; TAB2 a , b , c = int ; TAB2 read a then b then c ; TAB2 increment out [ a ] then increment in [ b ] ; TAB2 set nxt [ a ] to b ; TAB2 set p [ a ] to c ; TAB1 cnt = int with cnt = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if not in [ i ] and out [ i ] ; TAB3 now , _min = int with now = i and _min = p [ now ] ; TAB3 push now to from ; TAB3 loop while out [ now ] ; TAB4 set _min to min of _min , p [ now ] ; TAB4 set now to nxt [ now ] ; TAB3 increment cnt ; TAB3 push now to to ; TAB3 push _min to len ; TAB1 print cnt ; TAB1 loop while from is not empty ; TAB2 print front of from and front of to and front of len ; TAB2 pop from then pop to then pop len ;	static const int N = 1005 ; int n , m ; int in [ N ] , out [ N ] , nxt [ N ] , p [ N ] ; queue < int > from ; queue < int > to ; queue < int > len ; int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= m ; ++ i ) { int a , b , c ; cin >> a >> b >> c ; ++ out [ a ] , ++ in [ b ] ; nxt [ a ] = b ; p [ a ] = c ; } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ! in [ i ] && out [ i ] ) { int now = i , _min = p [ now ] ; from . push ( now ) ; for ( ; out [ now ] ; ) { _min = min ( _min , p [ now ] ) ; now = nxt [ now ] ; } ++ cnt ; to . push ( now ) ; len . push ( _min ) ; } } cout << cnt << endl ; for ( ; ! from . empty ( ) ; ) { cout << from . front ( ) << "   " << to . front ( ) << "   " << len . front ( ) << endl ; from . pop ( ) , to . pop ( ) , len . pop ( ) ; } }
TAB1 n , i , j , m = integers , a = 2D array of integers , size 2010x3 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read m ; TAB2 set a [ i ] [ 0 ] to m ; TAB2 set a [ i ] [ 1 ] to i ; TAB1 for i = 0 to n exclusive ; TAB2 for j = i + 1 to n exclusive ; TAB3 if a [ i ] [ 0 ] < a [ j ] [ 0 ] ; TAB4 tmp = integer set to a [ i ] [ 0 ] ; TAB4 set a [ i ] [ 0 ] to a [ j ] [ 0 ] ; TAB4 set a [ j ] [ 0 ] to temp ; TAB4 set temp to a [ i ] [ 1 ] ; TAB4 set a [ i ] [ 1 ] to a [ j ] [ 1 ] ; TAB4 set a [ j ] [ 1 ] to temp ; TAB3 if a [ i ] [ 0 ] is a [ j ] [ 0 ] ; TAB4 if a [ i ] [ 1 ] > a [ j ] [ 1 ] ; TAB5 temp = integer set to a [ i ] [ 0 ] ; TAB5 set a [ i ] [ 0 ] to a [ j ] [ 0 ] ; TAB5 set a [ j ] [ 0 ] to temp ; TAB5 set temp to a [ i ] [ 1 ] ; TAB5 set a [ i ] [ 1 ] to a [ j ] [ 1 ] ; TAB5 set a [ j ] [ 1 ] to temp ; TAB1 set a [ 0 ] [ 2 ] to 1 ; TAB1 for i = 1 to n exclusive ; TAB2 if a [ i ] [ 0 ] is a [ i - 1 ] [ 0 ] ; TAB3 set a [ i ] [ 2 ] to a [ i - 1 ] [ 2 ] ; TAB2 else ; TAB3 set a [ i ] [ 2 ] to i + 1 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = i + 1 to n exclusive ; TAB3 if a [ i ] [ 1 ] > a [ j ] [ 1 ] ; TAB4 temp = integer set to a [ i ] [ 1 ] ; TAB4 set a [ i ] [ 1 ] to a [ j ] [ 1 ] ; TAB4 set a [ j ] [ 1 ] to temp ; TAB4 set temp to a [ i ] [ 0 ] ; TAB4 set a [ i ] [ 0 ] to a [ j ] [ 0 ] ; TAB4 set a [ j ] [ 0 ] to temp ; TAB4 set temp to a [ i ] [ 2 ] ; TAB4 set a [ i ] [ 2 ] to a [ j ] [ 2 ] ; TAB4 set a [ j ] [ 2 ] to temp ; TAB1 print a [ 0 ] [ 2 ] ; TAB1 for i = 1 to n exlusive , print " " , a [ i ] [ 2 ] ; TAB1 endline ;	int main ( ) { int n , i , j , a [ 2010 ] [ 3 ] , m ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> m ; a [ i ] [ 0 ] = m ; a [ i ] [ 1 ] = i ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] [ 0 ] < a [ j ] [ 0 ] ) { int temp = a [ i ] [ 0 ] ; a [ i ] [ 0 ] = a [ j ] [ 0 ] ; a [ j ] [ 0 ] = temp ; temp = a [ i ] [ 1 ] ; a [ i ] [ 1 ] = a [ j ] [ 1 ] ; a [ j ] [ 1 ] = temp ; } if ( a [ i ] [ 0 ] == a [ j ] [ 0 ] ) { if ( a [ i ] [ 1 ] > a [ j ] [ 1 ] ) { int temp = a [ i ] [ 0 ] ; a [ i ] [ 0 ] = a [ j ] [ 0 ] ; a [ j ] [ 0 ] = temp ; temp = a [ i ] [ 1 ] ; a [ i ] [ 1 ] = a [ j ] [ 1 ] ; a [ j ] [ 1 ] = temp ; } } } } a [ 0 ] [ 2 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] [ 0 ] == a [ i - 1 ] [ 0 ] ) a [ i ] [ 2 ] = a [ i - 1 ] [ 2 ] ; else a [ i ] [ 2 ] = i + 1 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] [ 1 ] > a [ j ] [ 1 ] ) { int temp = a [ i ] [ 1 ] ; a [ i ] [ 1 ] = a [ j ] [ 1 ] ; a [ j ] [ 1 ] = temp ; temp = a [ i ] [ 0 ] ; a [ i ] [ 0 ] = a [ j ] [ 0 ] ; a [ j ] [ 0 ] = temp ; temp = a [ i ] [ 2 ] ; a [ i ] [ 2 ] = a [ j ] [ 2 ] ; a [ j ] [ 2 ] = temp ; } } } cout << a [ 0 ] [ 2 ] ; for ( i = 1 ; i < n ; i ++ ) { cout << "   " << a [ i ] [ 2 ] ; } cout << endl ; return 0 ; }
TAB0 set f [ 11 ] [ 11 ] to all 0 ; TAB1 create int n ; TAB1 read n ; TAB1 while n > 0 ; TAB2 decrement n ; TAB2 p [ 10 ] to all 0 ; TAB2 for i = 0 to 8 exclusive , read p [ i ] ; TAB2 create int x1 , y1 , x2 , y2 , set s to 0 ; TAB2 for i = 0 to 8 exclusive ; TAB3 for j = 0 to 8 exclusive ; TAB4 set p [ i ] [ j ] = K ; TAB5 increment s ; TAB5 if s = 1 ; TAB6 set x1 to j and y1 to i ; TAB5 else ; TAB6 x2 = j ; TAB6 y2 = i ; TAB2 Y = abs of y1 - y2 ; TAB2 int X = abs ( x1 - x2 ) ; TAB2 if Y % 4 = 0 and X % 4 = 0 ; TAB3 print YES ; TAB2 else if Y and X mod 2 = 0 ; TAB3 if X and Y = 0 ; TAB4 print YES ; TAB3 else ; TAB4 print NO ; TAB2 else ; TAB3 print NO ; TAB2 print a newline ;	bool f [ 11 ] [ 11 ] = { } ; int main ( ) { int n ; cin >> n ; while ( n > 0 ) { n -- ; string p [ 10 ] = { } ; for ( int i = 0 ; i < 8 ; i ++ ) { cin >> p [ i ] ; } int s = 0 , x1 , y1 , x2 , y2 ; for ( int i = 0 ; i < 8 ; i ++ ) for ( int j = 0 ; j < 8 ; j ++ ) { if ( p [ i ] [ j ] == ' K ' ) { s ++ ; if ( s == 1 ) { x1 = j , y1 = i ; } else { x2 = j ; y2 = i ; } } } int Y = abs ( y1 - y2 ) ; int X = abs ( x1 - x2 ) ; if ( Y % 4 == 0 && X % 4 == 0 ) { cout << " YES " ; } else if ( Y % 2 == 0 && X % 2 == 0 ) { if ( ! Y && ! X ) cout << " YES " ; else cout << " NO " ; } else cout << " NO " ; cout << endl ; } return 0 ; }
TAB0 let dx be an array with elements as 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1 ; TAB0 let dy be an array with elements as 1 , 0 , - 1 , 0 , 1 , - 1 , 1 , - 1 ; TAB0 let fast be a void function ; TAB1 call fast function ; TAB1 let n , m be integers ; TAB1 read n , m ; TAB1 while n is true ; TAB2 for character c = a to ( a + m - 1 ) and n inclusive , print c , n is decremented by 1 ; TAB1 print newline ;	int dx [ ] = { 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1 } ; int dy [ ] = { 1 , 0 , - 1 , 0 , 1 , - 1 , 1 , - 1 } ; void fast ( ) { } int main ( ) { fast ( ) ; int n , m ; cin >> n >> m ; while ( n ) { for ( char c = ' a ' ; c <= ( ' a ' + m - 1 ) && n ; c ++ ) cout << c , n -- ; } cout << " \n " ; }
TAB1 create long long ints n and i ; TAB1 read from the input to n ; TAB1 if n < = 3 ; TAB2 print " NO \ n " to the output ; TAB1 else ; TAB2 print " YES \ n " ; TAB2 if n is even ; TAB3 print " 1 * 2 = 2 \ n2 * 3 = 6 \ n6 * 4 = 24 \ n " ; TAB3 start for loop from i = 5 to n inclusive adding 2 to i ; print i + 1 , " - " , i and " = 1 \ n1 * 24 = 24 \ n " on every loop ; TAB2 else ; TAB3 print " 2 - 1 = 1 \ n1 + 3 = 4 \ n4 * 5 = 20 \ n20 + 4 = 24 \ n " ; TAB3 in a loop for i from 6 to n inclusive increasing i by 2 , print i + 1 , " - " , i and " = 1 \ n1 * 24 = 24 \ n " on every iteration ;	int main ( ) { long long int n , i ; cin >> n ; if ( n <= 3 ) cout << " NO\n " ; else { cout << " YES\n " ; if ( n % 2 == 0 ) { cout << " 1 * 2 = 2\n2 * 3 = 6\n6 * 4 = 24\n " ; for ( i = 5 ; i <= n ; i += 2 ) cout << i + 1 << "  -  " << i << "  = 1\n1 * 24 = 24\n " ; } else { cout << " 2 - 1 = 1\n1 + 3 = 4\n4 * 5 = 20\n20 + 4 = 24\n " ; for ( i = 6 ; i <= n ; i += 2 ) cout << i + 1 << "  -  " << i << "  = 1\n1 * 24 = 24\n " ; } } return 0 ; }
TAB0 let t , s , x be long integers ; TAB1 read t , s , x ; TAB1 if t is equal to x ; TAB2 print YES ; TAB3 print newline ; TAB1 if t is equal to x - 1 ; TAB2 print NO ; TAB3 print newline ; TAB1 let l , r , m be long integers with l = 0 , r = x ; TAB1 while l < = r ; TAB2 m is equal to ( l + r ) / 2 ; TAB2 let long integer value of a = t + s * m ; TAB2 if a is equal to x or a + 1 is equal to x ; TAB3 print YES ; TAB4 print newline ; TAB2 if a is greater than x ; TAB3 r is equal to m - 1 ; TAB2 else do the following ; TAB3 l is equal to m + 1 ; TAB1 print NO ; TAB2 print newline ;	long long int t , s , x ; int main ( ) { cin >> t >> s >> x ; if ( t == x ) { cout << " YES " << " \n " ; return 0 ; } if ( t == x - 1 ) { cout << " NO " << " \n " ; return 0 ; } long long int l = 0 , r = x , m ; while ( l <= r ) { m = ( l + r ) / 2 ; long long int a = t + s * m ; if ( a == x || a + 1 == x ) { cout << " YES " << " \n " ; return 0 ; } if ( a > x ) { r = m - 1 ; } else { l = m + 1 ; } } cout << " NO " << " \n " ; return 0 ; }
TAB1 a , b = long long ; TAB1 loop while reading a then b ; TAB2 s = string ; TAB2 x , y = long long with x = 0 and y = 0 ; TAB2 read s ; TAB2 i = long long ; TAB2 for i = 0 to size of s ; TAB3 if x is a and y is b break ; TAB3 if s [ i ] is ' L ' decrement x ; TAB3 if s [ i ] is ' R ' increment x ; TAB3 if s [ i ] is ' U ' increment y ; TAB3 if s [ i ] is ' D ' decrement y ; TAB2 j = long long ; TAB2 if i is size of s ; TAB3 for j = 0 to size of s ; TAB4 if s [ j ] is ' L ' increment a ; TAB4 if s [ j ] is ' R ' decrement a ; TAB4 if s [ j ] is ' U ' decrement b ; TAB4 if s [ j ] is ' D ' increment b ; TAB4 if a and b are both 0 break ; TAB4 da = long long with da = absolute of a ; TAB4 db = long long with db = absolute of b ; TAB4 dx = long long with dx = absolute of x ; TAB4 dy = long long with dy = absolute of y ; TAB4 if a as long long * y is b as long long * x and a as long long * x > = 0 and b as long long * y > = 0 ; TAB5 if a and b are both not 0 ; TAB6 if dx and dy are both not 0 ; TAB7 if da is a multiple of dx and db is a multiple of dy break ; TAB5 else if a is not 0 and b is 0 ; TAB6 if dx is not 0 ; TAB7 if dy is 0 and da is a multiple of dx break ; TAB5 else if a is 0 and b is not 0 ; TAB6 if dy is not 0 ; TAB7 if dx is 0 and db is a multiple of dy break ; TAB3 if j is not size of s ; TAB4 print " Yes " ; TAB3 else ; TAB4 print " No " ; TAB2 else ; TAB3 print " Yes " ;	int main ( ) { long long a , b ; while ( cin >> a >> b ) { string s ; long long x = 0 , y = 0 ; cin >> s ; long long i ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { if ( x == a && y == b ) break ; if ( s [ i ] == ' L ' ) x -= 1 ; if ( s [ i ] == ' R ' ) x += 1 ; if ( s [ i ] == ' U ' ) y += 1 ; if ( s [ i ] == ' D ' ) y -= 1 ; } long long j ; if ( i == s . size ( ) ) { for ( j = 0 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] == ' L ' ) a += 1 ; if ( s [ j ] == ' R ' ) a -= 1 ; if ( s [ j ] == ' U ' ) b -= 1 ; if ( s [ j ] == ' D ' ) b += 1 ; if ( a == 0 && b == 0 ) break ; long long da = abs ( a ) ; long long db = abs ( b ) ; long long dx = abs ( x ) ; long long dy = abs ( y ) ; if ( ( long long ) a * y == ( long long ) b * x && ( long long ) a * x >= 0 && ( long long ) b * y >= 0 ) { if ( a != 0 && b != 0 ) { if ( dx != 0 && dy != 0 ) { if ( da % dx == 0 && db % dy == 0 ) break ; } } else if ( a != 0 && b == 0 ) { if ( dx != 0 ) { if ( dy == 0 && da % dx == 0 ) break ; } } else if ( a == 0 && b != 0 ) { if ( dy != 0 ) { if ( dx == 0 && db % dy == 0 ) break ; } } } } if ( j != s . size ( ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } else { cout << " Yes " << endl ; } } return 0 ; }
TAB0 str2num is a integer function with string reference argument & s ; TAB1 create new stringstream ss from s ; TAB1 ret is a new integer variable ; TAB1 read ss into ret ; TAB1 return ret ; TAB0 boolean function valid with string reference argument & s ; TAB1 create new integer variable n ; TAB1 if s [ 0 ] is equal to ' 0 ' , return true if n = 1 or false otherwise ; TAB1 if length of s is greater than 7 , return false ; TAB1 create new integer x = str2num ( s ) ; TAB1 return true if x < = 1000000 or else otherwise ; TAB1 declare new string variable s ; TAB1 read user input to s ; TAB1 create integer variable with name n ; TAB1 in a for loop , change a from 1 to n inclusive ; TAB2 start for loop from b = 1 to n inclusive ; TAB3 create integer c = n - a - b ; TAB3 if c is greater than 0 ; TAB4 declare new string called p ; TAB4 if valid ( p ) , valid ( q ) and valid ( r ) are all true , assign the new value = max of ret and str2num ( p ) + str2num ( q ) + str2num ( r ) to ret ; TAB1 print ret ;	int str2num ( string & s ) { stringstream ss ( s ) ; int ret ; ss >> ret ; return ret ; } bool valid ( string & s ) { int n = s . size ( ) ; if ( s [ 0 ] == ' 0 ' ) return n == 1 ; if ( s . size ( ) > 7 ) return false ; int x = str2num ( s ) ; return x <= 1000000 ; } int main ( ) { string s ; cin >> s ; int n = s . size ( ) , ret = - 1 ; for ( int a = 1 ; a <= n ; a ++ ) for ( int b = 1 ; b <= n ; b ++ ) { int c = n - a - b ; if ( c > 0 ) { string p = s . substr ( 0 , a ) , q = s . substr ( a , b ) , r = s . substr ( a + b ) ; if ( valid ( p ) && valid ( q ) && valid ( r ) ) { ret = max ( ret , str2num ( p ) + str2num ( q ) + str2num ( r ) ) ; } } } cout << ret << endl ; return 0 ; }
TAB0 define 100 , 005 - element int array b ; TAB0 define int array c of 100 , 005 elements ; TAB0 define 100 , 000 - element int arrays u and v ; TAB0 define 100005 - element int array d ; TAB1 define int n ; TAB1 read into n ; TAB1 define integer k , set to 0 ; TAB1 zero out b ; TAB1 zero out entire c ; TAB1 zero out entirety of d ; TAB1 for int i from 0 to n ^ 2 ( exclusive ) by 1 , read u [ i ] and v [ i ] ; TAB1 for int i from 0 to n * n ( exclusive ) by 1 ; TAB2 if b [ u [ i ] ] is 0 and c [ v [ i ] ] is 0 ; TAB3 set d [ k ] to i + 1 and then increment k ; TAB3 set b [ u [ i ] ] to 1 ; TAB3 assign 1 to c [ v [ i ] ] ; TAB1 for int i from 0 to k - 1 ( exclusive ) by 1 , print d [ i ] and " " ; TAB1 print d [ k - 1 ] and newline ;	int b [ 100005 ] ; int c [ 100005 ] ; int u [ 100000 ] , v [ 100000 ] ; int d [ 100005 ] ; int main ( ) { int n ; cin >> n ; int k = 0 ; memset ( b , 0 , sizeof ( b ) ) ; memset ( c , 0 , sizeof ( c ) ) ; memset ( d , 0 , sizeof ( d ) ) ; for ( int i = 0 ; i < n * n ; i ++ ) { cin >> u [ i ] >> v [ i ] ; } for ( int i = 0 ; i < n * n ; i ++ ) { if ( b [ u [ i ] ] == 0 && c [ v [ i ] ] == 0 ) { d [ k ++ ] = i + 1 ; b [ u [ i ] ] = 1 ; c [ v [ i ] ] = 1 ; } } for ( int i = 0 ; i < k - 1 ; i ++ ) { cout << d [ i ] << "   " ; } cout << d [ k - 1 ] << endl ; return 0 ; }
TAB0 mpu = map from char to char ; TAB0 vec = array of 26 vector to long long ; TAB0 a and b = array of 1000006 int ; TAB0 visit = array of 1000006 bool ; TAB1 n = long long ; TAB1 s , p = string ; TAB1 read s , p ; TAB1 in = array of 26 long long ; TAB1 for i = 0 to 26 exclusive in [ i ] = - 1 ; TAB1 n = size of s ; TAB1 for i = 0 to n exclusive ; TAB2 r = s [ i ] - ' a ' ; TAB2 put i at end of vec [ r ] ; TAB1 val = - 1 ; TAB1 sum = 1 ; TAB1 for i = 0 to size of p exclusive ; TAB2 r = p [ i ] - ' a ' ; TAB2 if size of vec [ r ] < = 0 ; TAB3 print - 1 ; TAB2 increment in [ r ] ; TAB2 if in [ r ] < size of vec [ r ] ; TAB3 u = false ; TAB3 while vec [ r ] [ in [ r ] ] < = val and in [ r ] < size of vec [ r ] ; TAB4 increment in [ r ] ; TAB4 if in [ r ] > = size of vec [ r ] ; TAB5 increment sum ; TAB5 u = 1 ; TAB5 for kk = 0 to 26 exclusive ; TAB6 in [ kk ] = - 1 ; TAB6 val = - 1 ; TAB5 break ; TAB3 if u is 0 ; TAB4 val = vec [ r ] [ in [ r ] ] ; TAB4 increment i ; TAB2 else ; TAB3 increment sum ; TAB3 for kk = 0 to 26 exclusive in [ kk ] = - 1 ; TAB3 val = - 1 ; TAB1 print sum ;	map < char , char > mpu ; vector < long long > vec [ 26 ] ; int b [ 1000006 ] = { } , a [ 1000006 ] = { } ; bool visit [ 1000006 ] = { } ; int main ( ) { long long n ; string s , p ; cin >> s >> p ; long long in [ 26 ] = { } ; for ( int i = 0 ; i < 26 ; i ++ ) in [ i ] = - 1 ; n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = int ( s [ i ] - ' a ' ) ; vec [ r ] . push_back ( i ) ; } int val = - 1 ; int sum = 1 ; for ( int i = 0 ; i < p . size ( ) ; ) { int r = int ( p [ i ] - ' a ' ) ; if ( vec [ r ] . size ( ) <= 0 ) { cout << " -1\n " ; return 0 ; } in [ r ] ++ ; if ( in [ r ] < vec [ r ] . size ( ) ) { bool u = 0 ; while ( vec [ r ] [ in [ r ] ] <= val && in [ r ] < vec [ r ] . size ( ) ) { in [ r ] ++ ; if ( in [ r ] >= vec [ r ] . size ( ) ) { sum ++ ; u = 1 ; for ( int kk = 0 ; kk < 26 ; kk ++ ) { in [ kk ] = - 1 ; val = - 1 ; } break ; } } if ( u == 0 ) { val = vec [ r ] [ in [ r ] ] ; i ++ ; } } else { sum ++ ; for ( int kk = 0 ; kk < 26 ; kk ++ ) in [ kk ] = - 1 ; val = - 1 ; } } cout << sum << endl ; }
TAB0 MX = const int with MX = 1e3 + 5 ; TAB0 d = int , int pair array of size MX ; TAB1 n , s , a , b , f = long long with f = 0 ; TAB1 r = string array of size 2 with values " YES " , " NO " ; TAB1 read s then n ; TAB1 for i = 0 to n ; TAB2 read a then b ; TAB2 set d [ i ] to make_pair of a , b ; TAB1 sort d from index 0 to n ; TAB1 for i = 0 to n ; TAB2 if s > d [ i ] . first ; TAB3 increment s by d [ i ] . first ; TAB2 else ; TAB3 set f to 1 ; TAB3 break ; TAB1 print r [ f ] ;	const int MX = 1e3 + 5 ; pair < int , int > d [ MX ] ; int main ( ) { long long n , s , a , b , f = 0 ; string r [ 2 ] = { " YES " , " NO " } ; cin >> s >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b ; d [ i ] = make_pair ( a , b ) ; } sort ( d , d + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s > d [ i ] . first ) s += d [ i ] . second ; else { f = 1 ; break ; } } cout << r [ f ] << endl ; return 0 ; }
TAB0 in void function read taking x = int address ; TAB1 set x to 0 ; TAB1 ch = get char = char ; TAB1 f = 1 = int ; TAB1 for , c isn ' t digit , get char c ; TAB2 if c = ' - ' then set f to - f ; TAB1 for , ultil c is digit , get char c , set x = x * 10 + c - ' 0 ' ; TAB1 multiply x by f ; TAB0 in void function read2 taking x , y = int address ; TAB1 call read on x , call read on y ; TAB0 in void function read3 taking x , y , z = int addresses ; TAB1 call read on x , call read on y , call read on z ; TAB0 let l1 , r1 , l2 , r2 , k be long long ; TAB1 get form input l1 , r1 , l2 , r2 , k ; TAB1 ans = 0 = long long ; TAB1 if l2 > r1 or r2 > l1 ; TAB2 return 0 ; TAB1 set l1 to the max between l1 and l2 ; TAB1 set r1 to the min between r1 and r2 ; TAB1 set ans to r1 - l1 + 1 ; TAB1 if k is between l1 and r1 both inclusive then decrement ans ; TAB1 print ans ;	void read ( int & x ) { x = 0 ; char c = getchar ( ) ; int f = 1 ; for ( ; ! isdigit ( c ) ; c = getchar ( ) ) if ( c == ' - ' ) f = - f ; for ( ; isdigit ( c ) ; c = getchar ( ) ) x = x * 10 + c - ' 0 ' ; x *= f ; } void read2 ( int & x , int & y ) { read ( x ) , read ( y ) ; } void read3 ( int & x , int & y , int & z ) { read ( x ) , read ( y ) , read ( z ) ; } long long l1 , r1 , l2 , r2 , k ; int main ( ) { cin >> l1 >> r1 >> l2 >> r2 >> k ; long long ans = 0 ; if ( l2 > r1 || r2 < l1 ) { cout << 0 << endl ; return 0 ; } l1 = max ( l1 , l2 ) ; r1 = min ( r1 , r2 ) ; ans = r1 - l1 + 1 ; if ( k >= l1 && k <= r1 ) ans -- ; cout << ans << endl ; return 0 ; }
TAB0 q , ok , c = long long with c = 1 ; TAB1 read q ; TAB1 u = long long with u = q ; TAB1 for j = 2 to sqrt of q ü 1 inclusive ; TAB2 if q is a multiple of j ; TAB3 loop while q is a multiple of j ; TAB4 set q to q / j ; TAB4 increment ok ; TAB4 if ok < = 2 set c to c * j ; TAB4 if ok is 2 break ; TAB1 if q > 1 increment ok ; TAB1 if ok < = 1 print " 1 " and " 0 " ; TAB1 if ok is 2 print " 2 " ; TAB1 if ok > = 3 print " 1 " and c ;	long long q , ok , c = 1 ; int main ( ) { cin >> q ; long long u = q ; for ( long long j = 2 ; j <= sqrt ( q ) + 1 ; j ++ ) { if ( q % j == 0 ) { while ( q % j == 0 ) { q = q / j ; ok ++ ; if ( ok <= 2 ) c *= j ; if ( ok == 2 ) break ; } } } if ( q > 1 ) ok ++ ; if ( ok <= 1 ) cout << " 1 " << endl << " 0 " << endl ; if ( ok == 2 ) cout << " 2 " << endl ; if ( ok >= 3 ) cout << " 1 " << endl << c << endl ; return 0 ; }
TAB0 s = char array of size 5500 ; TAB1 read s ; TAB1 l = int with l = strlen of s ; TAB1 flag , a , b , c , flag1 = int with flag = 0 and a = 0 and b = 0 and c = 0 and flag1 = 0 ; TAB1 for i = 0 to l ; TAB2 if s [ i ] is ' a ' ; TAB3 increment a ; TAB3 if flag or flag1 is 1 ; TAB4 print " NO " ; TAB2 if s [ i ] is ' b ' ; TAB3 increment b ; TAB3 set flag to 1 ; TAB3 if flag1 is 1 ; TAB4 print " NO " ; TAB2 if s [ i ] is ' c ' ; TAB3 increment c ; TAB3 set flag1 to 1 ; TAB1 if a or b is 0 ; TAB2 print " NO " ; TAB1 if c is a or b ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	char s [ 5500 ] ; int main ( ) { cin >> s ; int l = strlen ( s ) ; int flag = 0 , a = 0 , b = 0 , c = 0 , flag1 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' a ' ) { a ++ ; if ( flag == 1 || flag1 == 1 ) { cout << " NO " << endl ; return 0 ; } } if ( s [ i ] == ' b ' ) { b ++ ; flag = 1 ; if ( flag1 == 1 ) { cout << " NO " << endl ; return 0 ; } } if ( s [ i ] == ' c ' ) { c ++ ; flag1 = 1 ; } } if ( a == 0 || b == 0 ) { cout << " NO " << endl ; return 0 ; } if ( c == a || c == b ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 create string s and t ; TAB0 create int l1 and l2 ; TAB0 create int p [ 10001 ] [ 26 ] ; TAB1 while read s and t ; TAB2 set l1 to size of s ; TAB2 assign size of t to l2 ; TAB2 set p to all 0 ; TAB2 for i = 0 to 26 exclusive , p [ l1 ] [ i ] = - 1 ; TAB2 for j = l1 to 1 inclusive ; TAB3 for i = 0 to 26 exclusive ; TAB4 if s [ j ] = i + a ; TAB5 assign j to p [ j - 1 ] [ i ] ; TAB4 else ; TAB5 set p [ j - 1 ] [ i ] = p [ j ] [ i ] ; TAB2 set ans to 1 and l to - 2 ; TAB2 for i = 0 to l2 exclusive ; TAB3 if l = - 2 ; TAB4 if s [ 0 ] = t [ i ] ; TAB5 assign 0 to l ; TAB4 else ; TAB5 set l to p [ 0 ] [ t [ i ] - a ] ; TAB4 if l equal to - 1 ; TAB5 set ans to - 1 ; TAB5 break ; TAB3 else ; TAB4 set l = p [ l ] [ t [ i ] - a ] ; TAB4 if l equal to - 1 ; TAB5 increment ans ; TAB5 set l to - 2 ; TAB5 decrement i ; TAB2 print ans ;	string s , t ; int l1 , l2 ; int p [ 10001 ] [ 26 ] ; int main ( ) { while ( cin >> s >> t ) { l1 = s . size ( ) ; l2 = t . size ( ) ; memset ( p , 0 , sizeof ( p ) ) ; for ( int i = 0 ; i < 26 ; i ++ ) p [ l1 ] [ i ] = - 1 ; for ( int j = l1 ; j >= 1 ; j -- ) for ( int i = 0 ; i < 26 ; i ++ ) if ( s [ j ] == i + ' a ' ) p [ j - 1 ] [ i ] = j ; else p [ j - 1 ] [ i ] = p [ j ] [ i ] ; int ans = 1 , l = - 2 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( l == - 2 ) { if ( s [ 0 ] == t [ i ] ) l = 0 ; else l = p [ 0 ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans = - 1 ; break ; } } else { l = p [ l ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans ++ ; l = - 2 ; i -- ; } } } cout << ans << endl ; } }
TAB0 declare character array a1 size 100000000 ; TAB1 read string into a1 ; TAB1 declare integers n = 0 , i = 0 , e = 0 , t = 0 ; TAB1 for j = 0 to string length of a1 exclusive ; TAB2 if a1 [ j ] is ' n ' ; TAB3 increment n ; TAB2 else if a1 [ j ] is ' i ' ; TAB3 increment i ; TAB2 else if a1 [ j ] is ' e ' ; TAB3 increment e ; TAB2 else if a1 [ j ] is ' t ' ; TAB3 increment t ; TAB1 print minimum of ( ( n - 1 ) / 2 and minimum of ( i and minimum of ( e / 3 and t ) ) ) and newline ;	char a1 [ 100000000 ] ; int main ( ) { gets ( a1 ) ; int n = 0 , i = 0 , e = 0 , t = 0 ; for ( int j = 0 ; j < strlen ( a1 ) ; j ++ ) { if ( a1 [ j ] == ' n ' ) n ++ ; else if ( a1 [ j ] == ' i ' ) i ++ ; else if ( a1 [ j ] == ' e ' ) e ++ ; else if ( a1 [ j ] == ' t ' ) t ++ ; } cout << min ( ( n - 1 ) / 2 , min ( i , min ( e / 3 , t ) ) ) << endl ; return 0 ; }
TAB0 boolean function if_prime with int argument a ; TAB1 return false if a is less than 2 ; TAB1 create integer variable with name flag and value = 1 ; TAB1 for i = 2 to a exclusive ; TAB2 if a modulo i = 0 ; TAB3 assign 0 to flag ; TAB3 break the loop ; TAB1 if flag is equal to 0 ; TAB2 return false ; TAB1 else ; TAB2 return true ; TAB1 n is a new integer variable ; TAB1 read standard input to n ; TAB1 new integer m with value 1 ; TAB1 create new integer ans with value n * m + 1 ; TAB1 while if_prime ( ans ) is true ; TAB2 increment m ; TAB2 change ans to n * m + 1 ; TAB1 print m ;	bool if_prime ( int a ) { if ( a < 2 ) return false ; int flag = 1 ; for ( int i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) return false ; else return true ; } int main ( ) { int n ; cin >> n ; int m = 1 ; int ans = n * m + 1 ; while ( if_prime ( ans ) ) { m ++ ; ans = n * m + 1 ; } cout << m << endl ; }
TAB0 int function f with int arguments a and b ; TAB1 define new integer called x1 = a / 10 ; TAB1 declare new integer called x2 with value a % 10 ; TAB1 create new integer x3 = b / 10 ; TAB1 declare new integer variable x4 = b % 10 ; TAB1 if x1 = x4 and x2 = x3 , return 1 ; TAB1 declare new int variables a and b ; TAB1 define character s ; TAB1 read a , s and b from the input ; TAB1 if f ( a , b ) returned 1 ; TAB2 print " 0 " ; TAB1 else ; TAB2 increment i in a loop starting from 1 ; TAB3 if b + 1 = 60 and a < 23 ; TAB4 assign the new value = 0 to b ; TAB4 increase a by 1 ; TAB3 else if a = 23 ; TAB4 if b is greater than 32 ; TAB5 print 60 - b ; TAB5 break the loop ; TAB4 else ; TAB5 increment b ; TAB3 else ; TAB4 increment b ; TAB3 if the value , returned from f ( a , b ) , is 1 ; TAB4 print i ; TAB4 break the loop ;	int f ( int a , int b ) { int x1 = a / 10 ; int x2 = a % 10 ; int x3 = b / 10 ; int x4 = b % 10 ; if ( x1 == x4 && x2 == x3 ) return 1 ; return 0 ; } int main ( ) { int a , b ; char s ; cin >> a >> s >> b ; if ( f ( a , b ) == 1 ) cout << " 0 " << endl ; else { for ( int i = 1 ; ; i ++ ) { if ( b + 1 == 60 && a < 23 ) { b = 0 ; a += 1 ; } else if ( a == 23 ) { if ( b > 32 ) { cout << 60 - b << endl ; break ; } else b ++ ; } else { b ++ ; } if ( f ( a , b ) == 1 ) { cout << i << endl ; break ; } } } return 0 ; }
TAB0 f , ans = strings with f = array of size 111 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read f [ i ] ; TAB2 for j = 0 to f [ i ] . size ( ) exclusive , f [ i ] [ j ] = tolower ( f [ i ] [ j ] ) ; TAB1 s , t = strings with t = " " ; TAB1 read s ; TAB1 for i = 0 to s . size ( ) exclusive , t = t + tolower ( s [ i ] ) ; TAB1 ans = t ; TAB1 c = character ; TAB1 read c ; TAB1 for i = 0 to t . size ( ) ; TAB2 for j = 0 to n exclusive ; TAB3 if ( i > = f [ j ] . size ( ) ) ; TAB4 sub = string with sub = t . substr ( i - f [ j ] . size ( ) , f [ j ] . size ( ) ) ; TAB4 if ( sub is f [ j ] ) ; TAB5 for l = i - f [ j ] . size ( ) to i exclusive ; TAB6 if ( t [ l ] is c and c is not a ) ; TAB7 ans [ l ] = a ; TAB6 else if ( t [ l ] is c and c is a ) ; TAB7 ans [ l ] = b ; TAB6 else ; TAB7 ans [ l ] = c ; TAB1 for i = 0 to s . size ( ) exclusive ; TAB2 if ( isupper ( s [ i ] ) ) , ans [ i ] = toupper ( ans [ i ] ) ; TAB1 print ans ;	string f [ 111 ] , ans ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> f [ i ] ; for ( int j = 0 ; j < f [ i ] . size ( ) ; j ++ ) f [ i ] [ j ] = tolower ( f [ i ] [ j ] ) ; } string s , t = "  " ; cin >> s ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) t += tolower ( s [ i ] ) ; ans = t ; char c ; cin >> c ; for ( int i = 0 ; i <= t . size ( ) ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i >= f [ j ] . size ( ) ) { string sub = t . substr ( i - f [ j ] . size ( ) , f [ j ] . size ( ) ) ; if ( sub == f [ j ] ) { for ( int l = i - f [ j ] . size ( ) ; l < i ; l ++ ) { if ( t [ l ] == c && c != ' a ' ) ans [ l ] = ' a ' ; else if ( t [ l ] == c && c == ' a ' ) ans [ l ] = ' b ' ; else ans [ l ] = c ; } } } } } for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( isupper ( s [ i ] ) ) ans [ i ] = toupper ( ans [ i ] ) ; cout << ans << endl ; }
TAB0 defin long long variables t , s and x ; TAB1 read user input to t , s and x ; TAB1 if x is less than t , return cout < < " NO " < < ' \ n ' , 0 ; TAB1 if x - 1 = t , return cout < < " NO " < < ' \ n ' , 0 ; TAB1 if ( x - t ) % s = 0 ) or ( x - t - 1 ) % s = 0 , return cout < < " YES " < < ' \ n ' , 0 ; TAB1 print " NO " and ' \ n ' ;	long long t , s , x ; int main ( ) { cin >> t >> s >> x ; if ( x < t ) return cout << " NO " << ' \n ' , 0 ; if ( x - 1 == t ) return cout << " NO " << ' \n ' , 0 ; if ( ( ( x - t ) % s == 0 ) || ( ( x - t - 1 ) % s == 0 ) ) return cout << " YES " << ' \n ' , 0 ; cout << " NO " << ' \n ' ; return 0 ; }
TAB0 let j1 = array of integers with size = 300 ; TAB1 let s1 = string ; TAB1 let yy = array of characters with values A , E , O , U , I , Y ; TAB1 let i , j , n , k , ans = integers with k = 0 and ans = - 1 ; TAB1 read s1 ; TAB1 set n = size of s1 ; TAB1 set s1 [ n ] = P ; TAB1 for i = 0 to n inclusive do the following ; TAB2 increment j1 [ k ] ; TAB2 if j1 [ k ] is greater than ans set ans = j1 [ k ] ; TAB2 for j = 0 to 6 exclusive do the following ; TAB3 if s1 [ i ] is yy [ j ] do the following ; TAB4 increment k ; TAB4 exit the loop ; TAB1 print ans ;	int jl [ 300 ] ; int main ( ) { string s1 ; char yy [ ] = { ' A ' , ' E ' , ' O ' , ' U ' , ' I ' , ' Y ' } ; int i , j , n , k = 0 , ans = - 1 ; cin >> s1 ; n = s1 . size ( ) ; s1 [ n ] = ' P ' ; for ( i = 0 ; i <= n ; i ++ ) { jl [ k ] ++ ; if ( jl [ k ] > ans ) ans = jl [ k ] ; for ( j = 0 ; j < 6 ; j ++ ) { if ( s1 [ i ] == yy [ j ] ) { k ++ ; break ; } } } cout << ans << endl ; return 0 ; }
TAB0 empty void function init_ios ; TAB0 declare new long long constant N = 1e5 + 10 ; TAB0 declare new long long variables n , d and res , and an array of long longs a with N elements ; TAB1 call init_ios ( ) ; TAB1 read n and d from the input ; TAB1 read input into a from the index i to n inclusive ; TAB1 create long long variable j = 3 ; TAB1 for i = 1 while i + 2 < = n ; TAB2 change the value of j to max of j and i + 2 ; TAB2 while j < = n and a [ j ] - a [ i ] < = d ; TAB2 decrement j ; TAB2 add ( ( j - i - 1 ) * ( j - i ) ) / 2 to res ; TAB1 print res and " \ n " to the standard output ;	void init_ios ( ) { } const long long N = ( long long ) 1e5 + 10 ; long long n , d , res , a [ N ] ; int main ( ) { init_ios ( ) ; cin >> n >> d ; for ( long long i = 1 ; i <= n ; ++ i ) cin >> a [ i ] ; long long j = 3 ; for ( long long i = 1 ; i + 2 <= n ; ++ i ) { j = max ( j , i + 2 ) ; while ( j <= n && a [ j ] - a [ i ] <= d ) ++ j ; -- j ; res += ( ( j - i - 1 ) * ( j - i ) ) / 2 ; } cout << res << " \n " ; }
TAB0 a = int array size 150 ; TAB1 t , s , x , f = int , f = 0 ; TAB1 read t , s , x ; TAB1 let x = x - t ; TAB1 if remainder of x / s = 0 or 1 , let f = 1 ; TAB1 if x = 1 or x < 0 , let f = 0 ; TAB1 if f = 1 ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int a [ 150 ] ; int main ( ) { int t , s , x , f = 0 ; cin >> t >> s >> x ; x = x - t ; if ( x % s == 0 || x % s == 1 ) f = 1 ; if ( x == 1 || x < 0 ) f = 0 ; if ( f == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 num = array of boolean values of length 6667 ; TAB1 s = array of characters of length 3 ; TAB1 memset of num , 0 , length of num ; TAB1 let n be a integer ; TAB1 read n ; TAB1 the integer value of count = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 let a , b be integers ; TAB2 read a ; TAB2 read b ; TAB2 b is equal to b modulo 10 * 10 + b / 10 ; TAB2 if num [ a * 100 + b ] equals 0 ; TAB3 increment count by 1 ; TAB3 the integer value of tmp = a * 100 + b ; TAB3 num [ tmp ] is equal to 1 ; TAB3 for j = 0 to 3 exclusive ; TAB4 tmp is equal to tmp modulo 10 * 1000 + tmp / 10 ; TAB4 num [ tmp ] is equal to 1 ; TAB2 if i is not equal to n - 1 , read s ; TAB1 print count and new line ;	int main ( ) { bool num [ 6667 ] ; char s [ 3 ] ; memset ( num , 0 , sizeof ( num ) ) ; int n ; cin >> n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int a , b ; cin >> a ; cin >> b ; b = b % 10 * 10 + b / 10 ; if ( num [ a * 100 + b ] == 0 ) { count ++ ; int tmp = a * 100 + b ; num [ tmp ] = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { tmp = tmp % 10 * 1000 + tmp / 10 ; num [ tmp ] = 1 ; } } if ( i != n - 1 ) cin >> s ; } cout << count << endl ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 h = integer = ( s [ 0 ] - 0 ) * 10 + ( s [ 1 ] - 0 ) ; TAB1 m = integer = ( s [ 3 ] - 0 ) * 10 + ( s [ 4 ] - 0 ) ; TAB1 indefinite while loop ; TAB2 if m is 59 ; TAB3 m = 0 ; TAB3 if h is 23 ; TAB4 h = 0 ; TAB3 else ; TAB4 increase h by 1 ; TAB2 else ; TAB3 increase m by 1 ; TAB2 if h / 10 is m modulo 10 and h modulo is m / 10 ; TAB3 print the result of h / 10 , the result of h modulo 10 , : , the result of m / 10 , the result of m modulo 10 ;	int main ( ) { string s ; cin >> s ; int h = ( s [ 0 ] - ' 0 ' ) * 10 + ( s [ 1 ] - ' 0 ' ) ; int m = ( s [ 3 ] - ' 0 ' ) * 10 + ( s [ 4 ] - ' 0 ' ) ; while ( 1 ) { if ( m == 59 ) { m = 0 ; if ( h == 23 ) h = 0 ; else h ++ ; } else m ++ ; if ( h / 10 == m % 10 && h % 10 == m / 10 ) { cout << h / 10 << h % 10 << " : " << m / 10 << m % 10 << endl ; return 0 ; } } }
TAB0 declare constant integer INF = 10000000 ; TAB1 declare integers n , m , a , b , ans1 = INF , ans2 = INF ; TAB1 read n , m , a , b ; TAB1 declare integer row1 = ( a - 1 ) / m ; TAB1 declare integer row2 = ( b - 1 ) / m ; TAB1 declare integer col1 = m if a % m is 0 , else a % m ; TAB1 declare integer col2 = m if b % m is 0 , else b % m ; TAB1 if row1 is row2 ; TAB2 let ans1 be 1 ; TAB1 else if row2 - row1 is 1 ; TAB2 let ans1 be 2 ; TAB2 if col1 is 1 and b is n ; TAB3 let ans1 be 1 ; TAB2 else if col1 is 1 and col2 is m ; TAB3 let ans1 be 1 ; TAB1 else ; TAB2 let ans1 be 3 ; TAB2 if b is n or col2 is m , decrement ans1 ; TAB2 if col1 is 1 , decrement ans1 ; TAB1 let ans2 be 3 ; TAB1 if col1 - 1 is col2 , decrement ans2 ; TAB1 print minimum of ans1 and ans2 , newline ; TAB0 end statement ;	const int INF = 10000000 ; int main ( ) { int n , m , a , b , ans1 = INF , ans2 = INF ; cin >> n >> m >> a >> b ; int row1 = ( a - 1 ) / m ; int row2 = ( b - 1 ) / m ; int col1 = a % m == 0 ? m : a % m ; int col2 = b % m == 0 ? m : b % m ; if ( row1 == row2 ) ans1 = 1 ; else if ( row2 - row1 == 1 ) { ans1 = 2 ; if ( col1 == 1 && b == n ) ans1 = 1 ; else if ( col1 == 1 && col2 == m ) ans1 = 1 ; } else { ans1 = 3 ; if ( b == n || col2 == m ) -- ans1 ; if ( col1 == 1 ) -- ans1 ; } ans2 = 3 ; if ( col1 - 1 == col2 ) -- ans2 ; cout << min ( ans1 , ans2 ) << endl ; return 0 ; } ;
TAB1 let n , cnt be integers ; TAB1 let x1 , y1 , x2 , y2 , a , b , c , l1 , l2 be long integers ; TAB1 while read x1 , y1 , x2 , y2 , n ; TAB2 cnt is equal to 0 ; TAB2 while n is decremented by 1 ; TAB3 read a , b , c ; TAB3 l1 = a * x1 + b * y1 + c ; TAB3 l2 = a * x2 + b * y2 + c ; TAB3 if l1 is greater than 0 and l2 is less than 0 or l1 is less than 0 and l2 is greater than 0 , increment cnt by 1 ; TAB2 print cnt and newline ;	int main ( ) { int n , cnt ; long long x1 , y1 , x2 , y2 , a , b , c , l1 , l2 ; while ( cin >> x1 >> y1 >> x2 >> y2 >> n ) { cnt = 0 ; while ( n -- ) { cin >> a >> b >> c ; l1 = a * x1 + b * y1 + c ; l2 = a * x2 + b * y2 + c ; if ( l1 > 0 && l2 < 0 || l1 < 0 && l2 > 0 ) cnt ++ ; } cout << cnt << endl ; } return 0 ; }
TAB1 create long long n , amigos , coins , min ; TAB1 read n , amigos , coins , min ; TAB1 i amigos > n or coins > n - min or min > n ; TAB2 print - 1 ; TAB1 else ; TAB2 x = ( min + coins ) / amigos ; TAB2 if ( min + coins ) % amigos = 0 ; TAB3 if amigos * x < = n ; TAB4 print x ; TAB3 else ; TAB4 print - 1 ; TAB2 else ; TAB3 if amigos * ( x + 1 ) < = n ; TAB4 print x + 1 ; TAB3 else ; TAB4 print - 1 ;	int main ( ) { long long n , amigos , coins , min ; cin >> n >> amigos >> coins >> min ; if ( amigos > n || coins > n - min || min > n ) cout << - 1 << endl ; else { long long x = ( min + coins ) / amigos ; if ( ( min + coins ) % amigos == 0 ) { if ( amigos * x <= n ) cout << x << endl ; else cout << - 1 << endl ; } else { if ( amigos * ( x + 1 ) <= n ) cout << x + 1 << endl ; else cout << - 1 << endl ; } } return 0 ; }
TAB1 s , n = long integer ; TAB1 read n , s ; TAB1 dollar = long integer array of size n ; TAB1 cent = long integer array of size n ; TAB1 for i = 0 to n exclusive , ; TAB2 cent [ i ] = - 4 ; TAB2 dollar [ i ] = - 4 ; TAB1 d , c = integers ; TAB1 k = integer with k = 0 ; TAB1 y = integer with y = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read d , c ; TAB2 if ( d < s ) ; TAB3 dollar [ k ] = d ; TAB3 cent [ k ] = c ; TAB3 increment k ; TAB2 else if ( d is s and c is 0 ) ; TAB3 dollar [ k ] = d ; TAB3 cent [ k ] = c ; TAB3 increment k ; TAB1 pairt = array of pair of long int to long int of size k ; TAB1 for i = 0 to k exclusive ; TAB2 pairt [ i ] of first = cent [ i ] ; TAB2 pairt [ i ] of second = dollar [ i ] ; TAB1 sort pairt and pairt + k ; TAB1 for i = 0 to k exclusive ; TAB2 cent [ i ] = pairt [ i ] of first ; TAB2 dollar [ i ] = pairt [ i ] of second ; TAB1 flag = integer with flag = 0 ; TAB1 i = long integer with i = 0 ; TAB1 for i = 0 to k exclusive ; TAB2 if ( cent [ i ] > 0 ) ; TAB3 print ( 100 - cent [ i ] ) ; TAB3 flag = 1 ; TAB3 break loop ; TAB1 if ( cent [ 0 ] is 0 and flag is 0 ) ; TAB2 print 0 ; TAB2 flag = 1 ; TAB1 if ( flag is 0 ) print - 1 ;	int main ( ) { long int s , n ; cin >> n >> s ; long int dollar [ n ] ; long int cent [ n ] ; for ( long int i = 0 ; i < n ; i ++ ) { cent [ i ] = - 4 ; dollar [ i ] = - 4 ; } int d , c ; int k = 0 ; int y = 0 ; for ( long int i = 0 ; i < n ; i ++ ) { cin >> d >> c ; if ( d < s ) { dollar [ k ] = d ; cent [ k ] = c ; k ++ ; } else if ( d == s && c == 0 ) { dollar [ k ] = d ; cent [ k ] = c ; k ++ ; } } pair < long int , long int > pairt [ k ] ; for ( long int i = 0 ; i < k ; i ++ ) { pairt [ i ] . first = cent [ i ] ; pairt [ i ] . second = dollar [ i ] ; } sort ( pairt , pairt + k ) ; for ( long int i = 0 ; i < k ; i ++ ) { cent [ i ] = pairt [ i ] . first ; dollar [ i ] = pairt [ i ] . second ; } int flag = 0 ; long int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( cent [ i ] > 0 ) { cout << ( 100 - cent [ i ] ) << endl ; flag = 1 ; break ; } } if ( cent [ 0 ] == 0 && flag == 0 ) { cout << " 0 " << endl ; flag = 1 ; } if ( flag == 0 ) cout << " -1 " << endl ; return 0 ; }
TAB1 declare ints h and m ; TAB1 c is a new character ; TAB1 read h , c and m from the user input ; TAB1 create new integer variable rh = ( h % 10 ) * 10 + h / 10 ; TAB1 create integer variable res = 0 ; TAB1 in a for loop , change rh to ( h % 10 ) * 10 + h / 10 while rh ! = m ; TAB2 add 1 to m ; TAB2 increase res by 1 ; TAB2 if m is equal to 60 ; TAB3 assign the new value = 0 to m ; TAB3 increment h ; TAB3 if h = 24 , assign 0 to h ; TAB1 print res ;	int main ( ) { int h , m ; char c ; cin >> h >> c >> m ; int rh = ( h % 10 ) * 10 + h / 10 ; int res = 0 ; for ( ; rh != m ; rh = ( h % 10 ) * 10 + h / 10 ) { ++ m ; ++ res ; if ( m == 60 ) { m = 0 ; ++ h ; if ( h == 24 ) h = 0 ; } } cout << res << endl ; return 0 ; }
TAB0 create const long double pi = 3 . 1415926535 ; TAB1 make long long integer t ; TAB1 make string s ; TAB1 read s ; TAB1 create long long integer a = ( s [ 0 ] - ' 0 ' ) * 10 + ( s [ 1 ] - ' 0 ' ) ; TAB1 make long long b = ( s [ 3 ] - ' 0 ' ) * 10 + ( s [ 4 ] - ' 0 ' ) ; TAB1 make bool flag = 0 ; TAB1 create long long integer cnt = 0 ; TAB1 while flag is not equal to 1 ; TAB2 if ( a / 10 is equal to b % 10 ) and ( a % 10 is equal to b / 10 ) ; TAB3 print cnt ; TAB2 increment cnt ; TAB2 increment b ; TAB2 if b is equal to 60 ; TAB3 set b to 0 ; TAB3 increase a by 1 ; TAB2 if a is 24 , set a to 0 ;	const long double pi = 3.1415926535 ; int main ( ) { long long int t ; string s ; cin >> s ; long long int a = ( s [ 0 ] - ' 0 ' ) * 10 + ( s [ 1 ] - ' 0 ' ) ; long long int b = ( s [ 3 ] - ' 0 ' ) * 10 + ( s [ 4 ] - ' 0 ' ) ; bool flag = 0 ; long long int cnt = 0 ; while ( flag != 1 ) { if ( ( a / 10 == b % 10 ) && ( a % 10 == b / 10 ) ) { cout << cnt << endl ; return 0 ; } cnt ++ ; b ++ ; if ( b == 60 ) { b = 0 ; a ++ ; } if ( a == 24 ) a = 0 ; } }
TAB0 s = string ; TAB0 freq = int arary sze 26 ; TAB0 n = int ; TAB1 read s ; TAB1 read n ; TAB1 distinct = int , distinct = 0 ; TAB1 for int i = 0 to s [ i ] ; TAB2 if freq [ s [ i ] - a ] = 0 , add one to distinct ; TAB2 add one to freq [ s [ i ] - a ] ; TAB1 if distinct > n ; TAB2 print - 1 ; TAB1 else ; TAB2 sheets = int , sheets = 1 ; TAB2 while true ; TAB3 chrs = int , chrs = 0 ; TAB3 for int i = 0 to 26 , add ( freq [ i ] + sheets - 1 ) / sheets to chrs ; TAB3 if chrs < = n , exit while loop ; TAB3 add one to sheets ; TAB2 print sheets ; TAB2 t = int , t = 0 ; TAB2 for int i = 0 to 26 ; TAB3 x = int , x = ( freq [ i ] + sheets - 1 ) / sheets ; TAB3 add x to t ; TAB3 while x > 0 , print i + a in char format ; TAB2 while t < 0 , print a ; TAB2 new line ;	string s ; int freq [ 26 ] ; int n ; int main ( ) { cin >> s ; cin >> n ; int distinct = 0 ; for ( int i = 0 ; s [ i ] ; i ++ ) { if ( freq [ s [ i ] - ' a ' ] == 0 ) distinct ++ ; freq [ s [ i ] - ' a ' ] ++ ; } if ( distinct > n ) cout << - 1 << " \n " ; else { int sheets = 1 ; while ( true ) { int chrs = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { chrs += ( freq [ i ] + sheets - 1 ) / sheets ; } if ( chrs <= n ) break ; sheets ++ ; } cout << sheets << ' \n ' ; int t = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int x = ( freq [ i ] + sheets - 1 ) / sheets ; t += x ; while ( x -- ) cout << ( char ) ( i + ' a ' ) ; } while ( t ++ < n ) cout << ' a ' ; cout << ' \n ' ; } return 0 ; }
TAB1 n , total , input , Smith , cou = integers with Smith = 0 , cou = 1 ; TAB1 read n ; TAB1 for i = 1 to n ; TAB2 total = 0 ; TAB2 for j = 1 to 4 ; TAB3 read input ; TAB3 total = total + input ; TAB2 if ( i is 1 ) ; TAB3 Smith = total ; TAB2 else ; TAB3 if ( total > Smith ) , increment cou ; TAB1 print cou ;	int main ( ) { int n , total , input , Smith = 0 , cou = 1 ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { total = 0 ; for ( int j = 1 ; j <= 4 ; j ++ ) { cin >> input ; total += input ; } if ( i == 1 ) { Smith = total ; } else { if ( total > Smith ) { cou ++ ; } } } cout << cou << endl ; return 0 ; }
TAB0 set ans = 0 , i = 0 , j = 0 , cnt = 0 , sum = 0 ; TAB0 create long long arr [ 100001 ] ; TAB0 create long long brr [ 100001 ] ; TAB1 t = 1 ; TAB1 while decrement t ; TAB2 create long long n , set w and b to 0 ; TAB2 read n ; TAB2 create long long x , y ; TAB2 read x and y ; TAB2 if x = y ; TAB3 if x = 1 ; TAB4 print White ; TAB5 print a newline ; TAB4 return 0 ; TAB3 else if x = n ; TAB4 print Black ; TAB5 print a newline ; TAB4 return 0 ; TAB3 set w to x - 1 + x - 1 ; TAB3 b = n - x + n - x ; TAB2 else ; TAB3 set w = x - 1 + y - 1 ; TAB3 assign n + n - x - y to b ; TAB2 decrement w ; TAB2 if w < = b ; TAB3 print White ; TAB4 print a newline ; TAB2 else ; TAB3 print Black ; TAB4 print a newline ;	long long ans = 0 , i = 0 , j = 0 , cnt = 0 , sum = 0 ; long long arr [ 100001 ] ; long long brr [ 100001 ] ; int main ( ) { int t = 1 ; while ( t -- ) { long long n , w = 0 , b = 0 ; cin >> n ; long long x , y ; cin >> x >> y ; if ( x == y ) { if ( x == 1 ) { cout << " White " << " \n " ; exit ( 0 ) ; } else if ( x == n ) { cout << " Black " << " \n " ; exit ( 0 ) ; } w = x - 1 + x - 1 ; b = n - x + n - x ; } else { w = x - 1 + y - 1 ; b = n + n - x - y ; } w -- ; if ( w <= b ) cout << " White " << " \n " ; else cout << " Black " << " \n " ; } }
TAB0 create string str ; TAB0 declare check with integer p as argument , returning boolean ; TAB1 create character set se ; TAB1 remove all elements from se ; TAB1 insert str [ p ] into se ; TAB1 insert str [ p + 1 ] into se ; TAB1 insert str [ p - 1 ] into se ; TAB1 insert ' . ' into se ; TAB1 if size of se is 4 , return true from function ; TAB1 return false from function ; TAB1 read str ; TAB1 for i = 1 to i + 1 is less than size of str ; TAB2 if result of run check with i as argument is true ; TAB3 print " Yes " print newline ; TAB1 print " No " print newline ;	string str ; bool check ( int p ) { set < char > se ; se . clear ( ) ; se . insert ( str [ p ] ) ; se . insert ( str [ p + 1 ] ) ; se . insert ( str [ p - 1 ] ) ; se . insert ( ' . ' ) ; if ( se . size ( ) == 4 ) return true ; return false ; } int main ( ) { cin >> str ; for ( int i = 1 ; i + 1 < str . size ( ) ; i ++ ) { if ( check ( i ) ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; return 0 ; }
TAB1 n is a new integer variable ; TAB1 read user input to n ; TAB1 declare integer variable sq = square root of ( n * 2 ) ; TAB1 in a for loop , change i from 1 to sq inclusive incrementing i ; TAB2 for j from 1 to i inclusive incrementing j ; TAB3 if i * i + i + j * j + j = n * 2 ; TAB4 print " YES " ; TAB1 print " NO " to the standard output ;	int main ( ) { int n ; cin >> n ; int sq = sqrt ( n * 2 ) ; for ( int i = 1 ; i <= sq ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( i * i + i + j * j + j == n * 2 ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB0 create ints n , m , i , and k = - 1 ; TAB0 let strings s , t , and s2 ; TAB1 read n , m , s , and t ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is equal to ' * ' ; TAB3 set k to i ; TAB3 break loop ; TAB1 if k is equal to - 1 and s is not equal to t or if n - 1 is more than m , print " NO " and return 0 ; TAB1 set s2 to s . substr ( k + 1 ) ; TAB1 set n to s2 . size ( ) ; TAB1 if s . substr ( 0 , k ) is not equal to t . substr ( 0 , k ) or s2 is not equal to t . substr ( m - n ) , print " NO " and return 0 ; TAB1 print " YES " ;	int n , m , i , k = - 1 ; string s , t , s2 ; int main ( ) { cin >> n >> m >> s >> t ; for ( i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' * ' ) { k = i ; break ; } if ( ( k == - 1 && s != t ) || n - 1 > m ) return cout << " NO " << endl , 0 ; s2 = s . substr ( k + 1 ) ; n = s2 . size ( ) ; if ( s . substr ( 0 , k ) != t . substr ( 0 , k ) || s2 != t . substr ( m - n ) ) return cout << " NO " << endl , 0 ; cout << " YES " << endl ; return 0 ; }
TAB1 v = vector of long long ; TAB1 add 4 at end of v ; TAB1 add 7 at end of v ; TAB1 l = 4444444444 , a , x , y = int , c = 0 ; TAB1 i = 0 , j , z = int ; TAB1 while last item of v < l ; TAB2 a = v [ i ] , increment i ; TAB2 add a * 10 + 4 at end of v ; TAB2 add a * 10 + 7 at end of v ; TAB1 read x , y ; TAB1 i = index of x in v - first item of v ; TAB1 j = index of y in v - first item of v ; TAB1 z = x ; TAB1 while i < j ; TAB2 add v [ i ] * ( v [ i ] - z + 1 ) to c ; TAB2 z = v [ i ] + 1 , increment i ; TAB1 add v [ j ] * ( y - z + 1 ) to c ; TAB1 print c ;	int main ( ) { vector < long long > v ; v . push_back ( 4 ) ; v . push_back ( 7 ) ; long long l = 4444444444 , a , x , y , c = 0 ; int i = 0 , j , z ; while ( v . back ( ) < l ) { a = v [ i ++ ] ; v . push_back ( ( a * 10 ) + 4 ) ; v . push_back ( ( a * 10 ) + 7 ) ; } cin >> x >> y ; i = ( int ) ( lower_bound ( v . begin ( ) , v . end ( ) , x ) - v . begin ( ) ) ; j = ( int ) ( lower_bound ( v . begin ( ) , v . end ( ) , y ) - v . begin ( ) ) ; z = x ; while ( i < j ) { c += v [ i ] * ( v [ i ] - z + 1 ) ; z = v [ i ++ ] + 1 ; } c += v [ j ] * ( y - z + 1 ) ; cout << c << endl ; return 0 ; }
TAB0 create integer vector array vec with size 3 ; TAB0 create map like from string to integer ; TAB0 create integers diff , ans , a , b , c , create 2d integer array mat with size 10 by 10 ; TAB0 declare cal ; TAB1 create integers sum , i , j , k , with sum = 0 ; TAB1 for i = 0 to 3 exclusive ; TAB2 for j = 0 to integer casted size of vec [ i ] ; TAB3 for k = 0 to integer casted size of vec [ i ] exclusive , increment sum by mat [ vec [ i ] [ j ] ] [ vec [ i ] [ k ] ] ; TAB1 return sum from function ; TAB0 declare count with integer now as argument , returning void ; TAB1 if now is 7 ; TAB2 if size of vec [ 0 ] and size of vec [ 1 ] and size of vec [ 2 ] ; TAB3 create integer array x with x = { a / size of vec [ 0 ] , b / size of vec [ 1 ] , c / size of vec [ 2 ] } ; TAB3 sort elements from x to x + 3 ; TAB3 if x [ 2 ] - x [ 0 ] is less than diff ; TAB4 set diff to x [ 2 ] - x [ 0 ] ; TAB4 set ans to result of run cal ; TAB3 else if x [ 2 ] - x [ 0 ] is diff ; TAB4 set ans to maximum of ans and result of run cal ; TAB2 return from function ; TAB1 for i = 0 to 3 exclusive ; TAB2 add element now to end of vec [ i ] ; TAB2 run count with now + 1 as argument ; TAB2 remove last element from vec [ i ] ; TAB1 set like [ " Anka " ] to 0 ; TAB1 set like [ " Chapay " ] to 1 ; TAB1 set like [ " Cleo " ] to 2 ; TAB1 set like [ " Troll " ] to 3 ; TAB1 set like [ " Dracul " ] to 4 ; TAB1 set like [ " Snowy " ] to 5 ; TAB1 set like [ " Hexadecimal " ] to 6 ; TAB1 create integers n , i ; TAB1 create strings name1 , str , name2 ; TAB1 while read n is true ; TAB2 set diff to ( 1 bitshift left 31 ) - 1 ; TAB2 for i = 0 to 3 exclusive , remove all elements from vec [ i ] ; TAB2 set bytes from mat to size of mat to value 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read name1 read str read name2 ; TAB3 increment mat [ like [ name1 ] ] [ like [ name2 ] ] ; TAB2 read a read b read c ; TAB2 run count with 0 as argument ; TAB2 print diff print " " print ans print newline ;	vector < int > vec [ 3 ] ; map < string , int > like ; int diff , mat [ 10 ] [ 10 ] , ans , a , b , c ; int cal ( ) { int sum = 0 , i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < ( int ) vec [ i ] . size ( ) ; j ++ ) for ( k = 0 ; k < ( int ) vec [ i ] . size ( ) ; k ++ ) sum += mat [ vec [ i ] [ j ] ] [ vec [ i ] [ k ] ] ; } return sum ; } void count ( int now ) { if ( now == 7 ) { if ( vec [ 0 ] . size ( ) && vec [ 1 ] . size ( ) && vec [ 2 ] . size ( ) ) { int x [ ] = { a / vec [ 0 ] . size ( ) , b / vec [ 1 ] . size ( ) , c / vec [ 2 ] . size ( ) } ; sort ( x , x + 3 ) ; if ( x [ 2 ] - x [ 0 ] < diff ) { diff = x [ 2 ] - x [ 0 ] ; ans = cal ( ) ; } else if ( x [ 2 ] - x [ 0 ] == diff ) ans = max ( ans , cal ( ) ) ; } return ; } for ( int i = 0 ; i < 3 ; i ++ ) { vec [ i ] . push_back ( now ) ; count ( now + 1 ) ; vec [ i ] . pop_back ( ) ; } } int main ( ) { like [ " Anka " ] = 0 ; like [ " Chapay " ] = 1 ; like [ " Cleo " ] = 2 ; like [ " Troll " ] = 3 ; like [ " Dracul " ] = 4 ; like [ " Snowy " ] = 5 ; like [ " Hexadecimal " ] = 6 ; int n , i ; string name1 , str , name2 ; while ( cin >> n ) { diff = ( 1 << 31 ) - 1 ; for ( i = 0 ; i < 3 ; i ++ ) vec [ i ] . clear ( ) ; memset ( mat , 0 , sizeof ( mat ) ) ; for ( i = 0 ; i < n ; i ++ ) { cin >> name1 >> str >> name2 ; mat [ like [ name1 ] ] [ like [ name2 ] ] ++ ; } cin >> a >> b >> c ; count ( 0 ) ; cout << diff << "   " << ans << endl ; } }
TAB1 s , v = string ; TAB1 read s then v ; TAB1 if size of s is not size of v ; TAB2 print " NO " ; TAB1 else ; TAB2 at , at2 = int with at = - 1 and at2 = - 1 ; TAB2 for len = size of s , i = 0 to len ; TAB3 if s [ i ] is not v [ i ] ; TAB4 if at is - 1 ; TAB5 set at to i ; TAB4 else ; TAB5 if at2 is - 1 ; TAB6 set at2 to i ; TAB6 if s [ at ] is not v [ at2 ] or s [ at2 ] is not v [ at ] ; TAB7 print " NO " ; TAB5 else ; TAB6 print " NO " ; TAB2 if at is - 1 print " YES " else if at2 is - 1 print " NO " else print " YES " ; TAB1 return true bitwise - and false ;	int main ( ) { string s , v ; cin >> s >> v ; if ( s . size ( ) != v . size ( ) ) { puts ( " NO " ) ; } else { int at = - 1 , at2 = - 1 ; for ( int len = s . size ( ) , i = 0 ; i < len ; ++ i ) { if ( s [ i ] != v [ i ] ) { if ( at == - 1 ) { at = i ; } else { if ( at2 == - 1 ) { at2 = i ; if ( s [ at ] != v [ at2 ] || s [ at2 ] != v [ at ] ) { puts ( " NO " ) ; return 0 ; } } else { puts ( " NO " ) ; return 0 ; } } } } puts ( at == - 1 ? " YES " : at2 == - 1 ? " NO " : " YES " ) ; } return true & false ; }
TAB0 let INF be an int const = 0x7fffffff ; TAB0 let inf be an int const = 0x3f3f3f3f ; TAB0 maxn = 200005 = int const ; TAB0 N = 105 = const int ; TAB0 in inline void read that takes an int address x ; TAB1 let f = 1 be int ; TAB1 set x to 0 ; TAB1 let s be a char = getchar ; TAB1 while s < ' 0 ' or s > ' 9 ' ; TAB2 if s is ' - ' then set f to - 1 ; TAB2 set s to getchar ( ) ; TAB1 while s > = ' 0 ' and s < = ' 9 ' ; TAB2 set x to x * 10 + s - ' 0 ' ; TAB2 read s ; TAB1 multiply x by f ; TAB0 let a , b , c , d , k be long long ; TAB1 read b , a , d , c ; TAB1 for i = 0 to 100 inclusive ; TAB2 for j = 0 to 100 inclusive ; TAB3 if a + i * b = c + j * b ; TAB4 print a + i * b and new line ; TAB1 print - 1 ;	const int INF = 0x7fffffff ; const int inf = 0x3f3f3f3f ; const int maxn = 200005 ; const int N = 105 ; inline void read ( int & x ) { int f = 1 ; x = 0 ; char s = getchar ( ) ; while ( s < ' 0 ' || s > ' 9 ' ) { if ( s == ' - ' ) f = - 1 ; s = getchar ( ) ; } while ( s >= ' 0 ' && s <= ' 9 ' ) { x = x * 10 + s - ' 0 ' ; s = getchar ( ) ; } x *= f ; } long long a , b , c , d , k ; int main ( ) { cin >> b >> a >> d >> c ; for ( int i = 0 ; i <= 100 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( a + i * b == c + j * d ) { cout << a + i * b << endl ; return 0 ; } } } cout << - 1 << endl ; return 0 ; }
TAB0 n , x , y = long long ; TAB1 read n and x and y ; TAB1 if x + y < = n + 1 ; TAB2 print " White " ; TAB1 else ; TAB2 print " Black " ;	long long n , x , y ; int main ( ) { cin >> n >> x >> y ; if ( x + y <= n + 1 ) cout << " White " << endl ; else cout << " Black " << endl ; return 0 ; }
TAB1 create int n ; TAB1 read n ; TAB1 create string s ; TAB1 read s ; TAB1 create vector int v ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] = C ; TAB3 assign 1 to last element of v ; TAB2 else if s [ i ] = Y ; TAB3 assign 3 to last element of v ; TAB2 else if s [ i ] equal to M ; TAB3 assign 2 to last element of v ; TAB2 else ; TAB3 count = 0 ; TAB3 while s [ i ] = ? ; TAB4 increment i ; TAB4 add 1 to count ; TAB3 decrement i ; TAB3 assign - count to last element of v ; TAB1 assign 1 to b ; TAB1 for i = 1 to n exclusive ; TAB2 if s [ i - 1 ] = s [ i ] and s [ i ] different from ? , set b = 0 ; TAB1 assign 0 to count ; TAB1 for i = 1 to size of v - 1 exclusive , ; TAB2 if v [ i ] < 0 and v [ i - 1 ] = v [ i + 1 ] ; TAB3 increment count ; TAB2 else if v [ i ] < - 1 and v [ i - 1 ] different from v [ i + 1 ] ; TAB3 add 1 to count ; TAB1 if v [ 0 ] less than 0 , count = count + 1 ; TAB1 if v [ size of v - 1 ] less than 0 , increment count ; TAB1 if b = 0 or count = 0 ; TAB2 print No ; TAB1 else ; TAB2 print Yes ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' C ' ) v . push_back ( 1 ) ; else if ( s [ i ] == ' Y ' ) v . push_back ( 3 ) ; else if ( s [ i ] == ' M ' ) v . push_back ( 2 ) ; else { int count = 0 ; while ( s [ i ] == ' ? ' ) { i ++ ; count ++ ; } i -- ; v . push_back ( - count ) ; } } bool b = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i - 1 ] == s [ i ] && s [ i ] != ' ? ' ) b = 0 ; } int count = 0 ; for ( int i = 1 ; i < v . size ( ) - 1 ; i ++ ) { if ( v [ i ] < 0 && v [ i - 1 ] == v [ i + 1 ] ) { count ++ ; } else if ( v [ i ] < - 1 && v [ i - 1 ] != v [ i + 1 ] ) { count ++ ; } } if ( v [ 0 ] < 0 ) count ++ ; if ( v [ v . size ( ) - 1 ] < 0 ) count ++ ; if ( ! b || count == 0 ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB0 create char arrays f and ff with 1005 elements ; TAB1 create ints n and k ; TAB1 read f from the input ; TAB1 read user input to k ; TAB1 change n to length of f ; TAB1 if n modulo k is not 0 ; TAB2 print " NO " ; TAB1 declare new integer a with value n / k ; TAB1 create new integer variable p = - 1 ; TAB1 create new integer flag with value 1 ; TAB1 while p is not equal to n - 1 ; TAB2 for integer i = 0 to a exclusive ; TAB3 increment p by one ; TAB3 change the value of ff [ i ] to f [ p ] ; TAB2 declare integer variable with name flagg = 1 ; TAB2 declare new integer variables b = 0 and e = a - 1 ; TAB2 while b < = e ; TAB3 if ff [ b ] ! = ff [ e ] ; TAB4 change flagg to 0 ; TAB4 break ; TAB3 increment b by one ; TAB3 decrement e ; TAB2 if flagg is equal to 0 ; TAB3 change flag to 0 ; TAB3 break ; TAB1 if flag is true ; TAB2 print " YES " to the stdout ; TAB1 else ; TAB2 print " NO " to the output stream ;	char f [ 1005 ] , ff [ 1005 ] ; int main ( ) { int n , k ; cin >> f ; cin >> k ; n = strlen ( f ) ; if ( n % k != 0 ) { cout << " NO " << endl ; return 0 ; } int a = n / k ; int p = - 1 ; int flag = 1 ; while ( p != n - 1 ) { for ( int i = 0 ; i < a ; i ++ ) { p ++ ; ff [ i ] = f [ p ] ; } int flagg = 1 ; int b = 0 , e = a - 1 ; while ( b <= e ) { if ( ff [ b ] != ff [ e ] ) { flagg = 0 ; break ; } b ++ ; e -- ; } if ( flagg == 0 ) { flag = 0 ; break ; } } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 mod = long long with mod = 1000000007 ; TAB1 a , b , x , y = long long ; TAB1 read a , b , x , y ; TAB1 ans = long long with ans = 0 ; TAB1 n , n1 = long long ; TAB1 read n ; TAB1 n1 = n ; TAB1 while decrement n1 ; TAB2 a1 , b1 , c1 = long long ; TAB2 read a1 , b1 , c1 ; TAB2 d1 = long long with d1 = ( a1 * a ) + ( b1 * b ) + c1 ; TAB2 d2 = long long with d2 = ( a1 * x ) + ( b1 * y ) + c1 ; TAB2 if ( ( d1 > = 0 and d2 > = 0 ) or ( d1 < 0 and d2 < 0 ) ) , increment ans ; TAB1 print n - ans ;	long long mod = 1000000007 ; int main ( ) { long long a , b , x , y ; cin >> a >> b >> x >> y ; long long ans = 0 ; long long n , n1 ; cin >> n ; n1 = n ; while ( n1 -- ) { long long a1 , b1 , c1 ; cin >> a1 >> b1 >> c1 ; long long d1 = ( a1 * a ) + ( b1 * b ) + c1 ; long long d2 = ( a1 * x ) + ( b1 * y ) + c1 ; if ( ( d1 >= 0 && d2 >= 0 ) || ( d1 < 0 && d2 < 0 ) ) ans ++ ; } cout << n - ans << endl ; return 0 ; }
TAB1 x , y , n = long long ; TAB1 read n ; TAB1 read x then y ; TAB1 w_x , w_y = long long with w_x = 1 and w_y = 1 ; TAB1 b_x , b_y = long long with b_x = n and b_y = n ; TAB1 w_step = long long with w_step = absolute of ( absolute of ( x - w_x ) - absolute of ( y - w_y ) ) + min of ( absolute of ( x - w_x ) , absolute of ( y - w_y ) ) ; TAB1 b_step = long long with b_step = absolute of ( absolute of ( y - b_y ) - absolute of ( x - b_x ) ) + min of ( absolute of ( y - b_y ) , absolute of ( x - b_x ) ) ; TAB1 if b_x is x and b_y is y ; TAB2 print " Black " ; TAB1 else if w_x is x and w_y is y ; TAB2 print " White " ; TAB1 else if w_step is b_step ; TAB2 print " White " ; TAB1 else if w_step < b_step ; TAB2 print " White " ; TAB1 else if b_step < w_step ; TAB2 print " Black " ;	int main ( ) { long long x , y , n ; cin >> n ; cin >> x >> y ; long long w_x = 1 , w_y = 1 ; long long b_x = n , b_y = n ; long long w_step = abs ( abs ( x - w_x ) - abs ( y - w_y ) ) + min ( abs ( x - w_x ) , abs ( y - w_y ) ) ; long long b_step = abs ( abs ( y - b_y ) - abs ( x - b_x ) ) + min ( abs ( y - b_y ) , abs ( x - b_x ) ) ; if ( b_x == x && b_y == y ) cout << " Black " << endl ; else if ( w_x == x && w_y == y ) cout << " White " << endl ; else if ( w_step == b_step ) cout << " White " << endl ; else if ( w_step < b_step ) cout << " White " << endl ; else if ( b_step < w_step ) cout << " Black " << endl ; return 0 ; }
TAB1 let n , L and a be long long integers ; TAB1 let t be an array of long long integers of size 100001 , let l be an array of long long integers of size 100001 ; TAB1 read in n , L and a ; TAB1 read in values for t [ i ] and l [ i ] n times ; TAB1 set t [ 0 ] to 0 ; TAB1 set l [ 0 ] to 0 ; TAB1 let cnt be a long long integer and set its value to 0 ; TAB1 for i = 0 to i < = n ; TAB2 if t [ i - 1 ] + l [ i - 1 ] is less than t [ i ] , add ( t [ i ] - ( t [ i - 1 ] + l [ i - 1 ] ) ) / a to cnt ; TAB1 set L to L - ( t [ n ] + l [ n ] ) ; TAB1 add L / a to cnt ; TAB1 print cnt ;	int main ( ) { long long int n , L , a ; long long int t [ 100001 ] , l [ 100001 ] ; cin >> n >> L >> a ; for ( long long int i = 1 ; i <= n ; i ++ ) { cin >> t [ i ] >> l [ i ] ; } t [ 0 ] = 0 ; l [ 0 ] = 0 ; long long int cnt = 0 ; for ( long long int i = 1 ; i <= n ; i ++ ) { if ( t [ i - 1 ] + l [ i - 1 ] < t [ i ] ) { cnt += ( t [ i ] - ( t [ i - 1 ] + l [ i - 1 ] ) ) / a ; } } L = L - ( t [ n ] + l [ n ] ) ; cnt += L / a ; cout << cnt << endl ; return 0 ; }
TAB0 INF = const int with INF = 0x3f3f3f3f ; TAB1 n = int ; TAB1 read n ; TAB1 row = int array of size n + 10 ; TAB1 ans = long long array of size n + 10 ; TAB1 for i = 1 to n inclusive read row [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 cont = long long with cont = 1 ; TAB2 j = int with j = row [ i ] ; TAB2 loop while cont is less than 103 and j is not i ; TAB3 increment cont ; TAB3 set j to row [ j ] ; TAB2 set ans [ i ] to cont ; TAB2 if ans [ i ] is event then set ans [ i ] to ans [ i ] / 2 ; TAB1 mult = long long with mult = ans [ 1 ] ; TAB1 for i = 1 to n inclusive ; TAB2 if ans [ i ] is 103 ; TAB3 print - 1 ; TAB2 set mult to ( mult * ans [ i ] ) / __gcd of mult and ans [ i ] ; TAB1 print mult ;	const int INF = 0x3f3f3f3f ; int main ( ) { int n ; cin >> n ; int row [ n + 10 ] ; long long ans [ n + 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> row [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) { long long cont = 1 ; int j = row [ i ] ; while ( cont < 103 and j != i ) { cont ++ ; j = row [ j ] ; } ans [ i ] = cont ; if ( ans [ i ] % 2 == 0 ) ans [ i ] /= 2 ; } long long mult = ans [ 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ] == 103 ) { cout << - 1 << endl ; return 0 ; } mult = ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] ) ; } cout << mult << endl ; return 0 ; }
TAB1 n , b , l = integers with l = 0 ; TAB1 Read n ; TAB1 for i = 0 to n exclusive ; TAB2 Read b ; TAB2 if b is 0 , then increment l ; TAB1 if l is 1 and n is not 1 OR n is 1 and l is 0 ; TAB2 print YES and a new line ; TAB1 else do the following ; TAB2 print NO and a new line ;	int main ( ) { int n , b , l = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> b ; if ( b == 0 ) { l ++ ; } } if ( l == 1 && n != 1 || n == 1 && l == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB1 a = string ; TAB1 loop while reading a ; TAB2 num_a , num_b , num_c = int with num_a = 0 and num_b = 0 and num_c = 0 ; TAB2 la = int ; TAB2 fb = int with fb = - 1 ; TAB2 lb = int with lb = - 1 ; TAB2 lc = int with lc = - 1 ; TAB2 for i = 0 to size of a ; TAB3 if a [ i ] is ' a ' ; TAB4 increment num_a ; TAB4 set la to i ; TAB3 else if a [ i ] is ' b ' ; TAB4 if fb is - 1 set fb to i ; TAB4 increment num_b ; TAB4 set lb to i ; TAB3 else if a [ i ] is ' c ' ; TAB4 if lc is - 1 set lc to i ; TAB4 increment num_c ; TAB2 if not ( fb > la ) or not ( lc > lb ) ; TAB3 print " NO " ; TAB2 else ; TAB3 if num_c is not num_b and num_c is not num_a ; TAB4 print " NO " ; TAB3 else ; TAB4 print " YES " ;	int main ( ) { string a ; while ( cin >> a ) { int num_a = 0 , num_b = 0 , num_c = 0 ; int la ; int fb = - 1 ; int lb = - 1 ; int lc = - 1 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( a [ i ] == ' a ' ) { num_a ++ ; la = i ; } else if ( a [ i ] == ' b ' ) { if ( fb == - 1 ) fb = i ; num_b ++ ; lb = i ; } else if ( a [ i ] == ' c ' ) { if ( lc == - 1 ) lc = i ; num_c ++ ; } } if ( ! ( fb > la ) || ! ( lc > lb ) ) { cout << " NO\n " ; } else { if ( num_c != num_b && num_c != num_a ) { cout << " NO\n " ; } else { cout << " YES\n " ; } } } }
TAB1 create long long ints a , b , a2 , b2 , k and t ; TAB1 read a , b , a2 , b2 and k from the input ; TAB1 assign min of b and b2 ) - max of a and a2 + 1 to t ; TAB1 decrement t by one if k < = min of b and b2 and k > = max of a and a2 ; TAB1 if t is less than 0 , change t to 0 ; TAB1 print t ;	int main ( ) { long long int a , b , a2 , b2 , k , t ; cin >> a >> b >> a2 >> b2 >> k ; t = ( min ( b , b2 ) ) - ( max ( a , a2 ) ) + 1 ; if ( k <= min ( b , b2 ) && k >= max ( a , a2 ) ) { t -- ; } if ( t < 0 ) { t = 0 ; } cout << t << endl ; return 0 ; }
TAB1 let n and ans be integers where ans = 1 ; TAB1 read user input to n ; TAB1 print n / 2 ; TAB1 start for loop from i = 1 to n / 2 - 1 inclusive and print 2 and " " on each iteration ; TAB1 if n is even ; TAB2 print 2 to the standard output ; TAB1 else ; TAB2 print 3 ;	int main ( ) { int n , ans = 1 ; cin >> n ; cout << n / 2 << endl ; for ( int i = 1 ; i <= n / 2 - 1 ; i ++ ) cout << 2 << "   " ; if ( n % 2 == 0 ) cout << 2 << endl ; else cout << 3 << endl ; }
TAB0 n = long long and h , a , x , y = long long array of size 2 each ; TAB0 vis = two dimensional long long array of sizes 1000001 and 2 ; TAB0 b = long long vector array of size 2 ; TAB0 ans = two dimensional long long array of sizes 2 and 2 ; TAB0 val = two dimensional long long array of sizes 1000001 and 2 ; TAB0 in function pass taking a long long i and returning a long long ; TAB1 set vis [ h [ i ] ] [ i ] to 1 ; TAB1 set val [ h [ i ] ] [ i ] to 1 ; TAB1 va = long long with va = 2 ; TAB1 append h [ i ] to b [ i ] ; TAB1 loop while vis [ h [ i ] ] [ i ] is 1 ; TAB2 set h [ i ] to ( x [ i ] * h [ i ] + y [ i ] ) mod m ; TAB2 append h [ i ] to b [ i ] ; TAB2 if vis [ h [ i ] ] [ i ] is 0 ; TAB3 increment vis [ h [ i ] ] [ i ] ; TAB3 set val [ h [ i ] ] [ i ] to va ; TAB3 increment va ; TAB2 else ; TAB3 set ans [ i ] [ 0 ] to val [ h [ i ] ] [ i ] - 1 ; TAB3 set ans [ i ] [ 1 ] to va - val [ h [ i ] ] [ i ] ; TAB1 read m then h [ 0 ] then a [ 0 ] then x [ 0 ] then y [ 0 ] then h [ 1 ] then a [ 1 ] then x [ 1 ] then y [ 1 ] ; TAB1 call pass of 0 ; TAB1 call pass of 1 ; TAB1 if vis [ a [ 0 ] ] [ 0 ] or vis [ a [ 1 ] ] [ 1 ] is 0 ; TAB2 print - 1 ; TAB1 va1 , va2 = long long with va1 = val [ a [ 0 ] ] [ 0 ] and va2 = val [ a [ 1 ] ] [ 1 ] ; TAB1 cy1 , cy2 = long long with cy1 = ans [ 0 ] [ 1 ] and cy2 = ans [ 1 ] [ 1 ] ; TAB1 if val [ a [ 0 ] ] [ 0 ] is val [ a [ 1 ] ] [ 1 ] ; TAB2 print val [ a [ 0 ] ] [ 0 ] - 1 ; TAB1 if val [ a [ 0 ] ] [ 0 ] is less or equal to ans [ 0 ] [ 0 ] and val [ a [ 1 ] ] [ 1 ] is less or equal to ans [ 1 ] [ 0 ] ; TAB2 print - 1 ; TAB1 else if val [ a [ 0 ] ] [ 0 ] is less or equal to ans [ 0 ] [ 0 ] or val [ a [ 1 ] ] [ 1 ] is less or equal to ans [ 1 ] [ 0 ] ; TAB2 mo = long long with mo = absolute of val [ a [ 1 ] ] [ 1 ] - val [ a [ 0 ] ] [ 0 ] ; TAB2 if val [ a [ 0 ] ] [ 0 ] is greater than val [ a [ 1 ] ] [ 1 ] and val [ a [ 0 ] ] [ 0 ] is less or equal to ans [ 0 ] [ 0 ] ; TAB3 if mo is a multiple of ans [ 1 ] [ 1 ] ; TAB4 print val [ a [ 0 ] ] [ 0 ] - 1 ; TAB3 else ; TAB4 print - 1 ; TAB2 else if val [ a [ 0 ] ] [ 0 ] is less than val [ a [ 1 ] ] [ 1 ] and val [ a [ 1 ] ] [ 1 ] is less or equal to ans [ 1 ] [ 0 ] ; TAB3 if mo is a multiple of ans [ 0 ] [ 1 ] ; TAB4 print val [ a [ 1 ] ] [ 1 ] - 1 ; TAB3 else ; TAB4 print - 1 ; TAB2 else ; TAB3 print - 1 ; TAB1 if absolute of va1 - va2 mod __gcd of cy1 and cy2 is not 0 ; TAB2 print - 1 ; TAB1 for i = 0 to 1000001 ; TAB2 va = long long with va = va1 - va2 + i * cy1 ; TAB2 if va is a multiple of cy2 and va is greater or equal to 0 ; TAB3 print va1 + i * cy1 - 1 ;	long long m , h [ 2 ] , a [ 2 ] , x [ 2 ] , y [ 2 ] ; long long vis [ 1000001 ] [ 2 ] ; vector < long long > b [ 2 ] ; long long ans [ 2 ] [ 2 ] ; long long val [ 1000001 ] [ 2 ] ; long long pass ( long long i ) { vis [ h [ i ] ] [ i ] = 1 ; val [ h [ i ] ] [ i ] = 1 ; long long va = 2 ; b [ i ] . push_back ( h [ i ] ) ; while ( vis [ h [ i ] ] [ i ] == 1 ) { h [ i ] = ( x [ i ] * h [ i ] + y [ i ] ) % m ; b [ i ] . push_back ( h [ i ] ) ; if ( vis [ h [ i ] ] [ i ] == 0 ) { vis [ h [ i ] ] [ i ] ++ ; val [ h [ i ] ] [ i ] = va ; va ++ ; } else { ans [ i ] [ 0 ] = val [ h [ i ] ] [ i ] - 1 ; ans [ i ] [ 1 ] = va - val [ h [ i ] ] [ i ] ; return 0 ; } } } int main ( ) { cin >> m >> h [ 0 ] >> a [ 0 ] >> x [ 0 ] >> y [ 0 ] >> h [ 1 ] >> a [ 1 ] >> x [ 1 ] >> y [ 1 ] ; pass ( 0 ) ; pass ( 1 ) ; if ( vis [ a [ 0 ] ] [ 0 ] == 0 || vis [ a [ 1 ] ] [ 1 ] == 0 ) { cout << - 1 << endl ; return 0 ; } long long va1 = val [ a [ 0 ] ] [ 0 ] , va2 = val [ a [ 1 ] ] [ 1 ] ; long long cy1 = ans [ 0 ] [ 1 ] , cy2 = ans [ 1 ] [ 1 ] ; if ( val [ a [ 0 ] ] [ 0 ] == val [ a [ 1 ] ] [ 1 ] ) { cout << val [ a [ 0 ] ] [ 0 ] - 1 << endl ; return 0 ; } if ( val [ a [ 0 ] ] [ 0 ] <= ans [ 0 ] [ 0 ] && val [ a [ 1 ] ] [ 1 ] <= ans [ 1 ] [ 0 ] ) { cout << - 1 << endl ; return 0 ; } else if ( val [ a [ 0 ] ] [ 0 ] <= ans [ 0 ] [ 0 ] || val [ a [ 1 ] ] [ 1 ] <= ans [ 1 ] [ 0 ] ) { long long mo = abs ( val [ a [ 1 ] ] [ 1 ] - val [ a [ 0 ] ] [ 0 ] ) ; if ( val [ a [ 0 ] ] [ 0 ] > val [ a [ 1 ] ] [ 1 ] && val [ a [ 0 ] ] [ 0 ] <= ans [ 0 ] [ 0 ] ) { if ( mo % ans [ 1 ] [ 1 ] == 0 ) cout << val [ a [ 0 ] ] [ 0 ] - 1 << endl ; else cout << - 1 << endl ; } else if ( val [ a [ 0 ] ] [ 0 ] < val [ a [ 1 ] ] [ 1 ] && val [ a [ 1 ] ] [ 1 ] <= ans [ 1 ] [ 0 ] ) { if ( mo % ans [ 0 ] [ 1 ] == 0 ) cout << val [ a [ 1 ] ] [ 1 ] - 1 << endl ; else cout << - 1 << endl ; } else { cout << - 1 << endl ; } return 0 ; } if ( abs ( va1 - va2 ) % __gcd ( cy1 , cy2 ) != 0 ) { cout << - 1 << endl ; return 0 ; } for ( long long i = 0 ; i < 1000001 ; i ++ ) { long long va = va1 - va2 + i * cy1 ; if ( va % cy2 == 0 && va >= 0 ) { cout << va1 + i * cy1 - 1 << endl ; return 0 ; } } return 0 ; }
TAB0 inf = constant integer = 1e15 ; TAB0 M = constant integer = 1e9 + 7 ; TAB0 arr = integer array of size 5000000 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive , then read a [ i ] ; TAB1 sort a in ascending order ; TAB1 i = country = integer = 0 ; TAB1 for j = 0 to n exclusive , increase j at the start of the loop ; TAB2 if arr [ i ] < arr [ j ] ; TAB3 increase county by 1 ; TAB3 increase i by 1 ; TAB1 print county ;	const long long int inf = 1e15 ; const int M = 1e9 + 7 ; int arr [ 5000000 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) { cin >> arr [ i ] ; } sort ( arr , arr + n ) ; int i = 0 , county = 0 ; for ( int j = 0 ; j < n , j < n ; ++ j ) { if ( arr [ i ] < arr [ j ] ) { county ++ ; i ++ ; } } cout << county << endl ; return 0 ; }
TAB1 declare long longs n , m , k , a ; TAB1 read n and m and k ; TAB1 declare minn = 20000000000 as long long ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 if i % 2 is 0 , let minn = minimum of a and minn ; TAB1 if n % 2 ; TAB2 if n / 2 + 1 is less than or equal to m ; TAB3 declare long long x = n / 2 + 1 ; TAB3 let x be m / x * k ; TAB3 print ( x if x is less than minn , else minn ) and newline ; TAB2 else ; TAB3 print 0 print newline ; TAB1 else ; TAB2 print 0 print newline ;	int main ( ) { long long n , m , k , a ; cin >> n >> m >> k ; long long minn = 20000000000 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; if ( i % 2 == 0 ) minn = min ( a , minn ) ; } if ( n % 2 ) { if ( n / 2 + 1 <= m ) { long long x = n / 2 + 1 ; x = m / x * k ; cout << ( x < minn ? x : minn ) << endl ; } else { cout << 0 << endl ; } } else cout << 0 << endl ; }
TAB0 declare integer array tab size 55 by 55 ; TAB0 declare integer array vis size 55 by 55 ; TAB0 declare integers n , m ; TAB0 declare czysc with no arguments , returning void ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive , let vis [ i ] [ j ] be 0 ; TAB1 return from function ; TAB0 declare dfs with integers i , j as arguments , returning void ; TAB1 let vis [ i ] [ j ] be 1 ; TAB1 if tab [ i + 1 ] [ j ] is 1 and vis [ i + 1 ] [ j ] is 0 , run dfs ( i + 1 and j ) ; TAB1 if tab [ i - 1 ] [ j ] is 1 and vis [ i - 1 ] [ j ] is 0 , run dfs ( i - 1 , j ) ; TAB1 if tab [ i ] [ j + 1 ] is 1 and vis [ i ] [ j + 1 ] is 0 , run dfs with i , j + 1 as arguments ; TAB1 if tab [ i ] [ j - 1 ] is 1 and vis [ i ] [ j - 1 ] is 0 , run dfs ( i , j - 1 ) ; TAB1 return from function ; TAB1 declare character c ; TAB1 read n , m ; TAB1 declare integers licz = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 read c ; TAB3 if c is ' # ' ; TAB4 let tab [ i ] [ j ] be 1 ; TAB4 increment licz ; TAB1 if licz is less than 3 ; TAB2 print " - 1 " and newline ; TAB1 declare integers wynik = 5 ; TAB1 declare integer akt ; TAB1 declare integer odw ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if tab [ i ] [ j ] is 1 ; TAB4 let akt be 0 ; TAB4 let akt be tab [ i + 1 ] [ j ] + tab [ i - 1 ] [ j ] + tab [ i ] [ j + 1 ] + tab [ i ] [ j - 1 ] ; TAB4 if akt is 1 ; TAB5 print " 1 " and newline ; TAB4 else ; TAB5 run czysc ; TAB5 let tab [ i ] [ j ] be 0 ; TAB5 if tab [ i + 1 ] [ j ] is 1 ; TAB6 run dfs with i + 1 , j as arguments ; TAB5 else ; TAB6 if tab [ i - 1 ] [ j ] is 1 ; TAB7 run dfs ( i - 1 , j ) ; TAB6 else ; TAB7 run dfs ( i , j + 1 ) ; TAB5 let tab [ i ] [ j ] be 1 ; TAB4 let odw be vis [ i + 1 ] [ j ] + vis [ i - 1 ] [ j ] + vis [ i ] [ j + 1 ] + vis [ i ] [ j - 1 ] ; TAB4 if odw is less than akt ; TAB5 print " 1 " and newline ; TAB1 print " 2 " and newline ;	int tab [ 55 ] [ 55 ] ; int vis [ 55 ] [ 55 ] ; int n , m ; void czysc ( ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { vis [ i ] [ j ] = 0 ; } } return ; } void dfs ( int i , int j ) { vis [ i ] [ j ] = 1 ; if ( tab [ i + 1 ] [ j ] == 1 && vis [ i + 1 ] [ j ] == 0 ) { dfs ( i + 1 , j ) ; } if ( tab [ i - 1 ] [ j ] == 1 && vis [ i - 1 ] [ j ] == 0 ) { dfs ( i - 1 , j ) ; } if ( tab [ i ] [ j + 1 ] == 1 && vis [ i ] [ j + 1 ] == 0 ) { dfs ( i , j + 1 ) ; } if ( tab [ i ] [ j - 1 ] == 1 && vis [ i ] [ j - 1 ] == 0 ) { dfs ( i , j - 1 ) ; } return ; } int main ( ) { char c ; cin >> n >> m ; int licz = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { cin >> c ; if ( c == ' # ' ) { tab [ i ] [ j ] = 1 ; licz ++ ; } } } if ( licz < 3 ) { cout << " -1 " << endl ; return 0 ; } int wynik = 5 ; int akt ; int odw ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( tab [ i ] [ j ] == 1 ) { akt = 0 ; akt = tab [ i + 1 ] [ j ] + tab [ i - 1 ] [ j ] + tab [ i ] [ j + 1 ] + tab [ i ] [ j - 1 ] ; if ( akt == 1 ) { cout << " 1 " << endl ; return 0 ; } else { czysc ( ) ; tab [ i ] [ j ] = 0 ; if ( tab [ i + 1 ] [ j ] == 1 ) { dfs ( i + 1 , j ) ; } else { if ( tab [ i - 1 ] [ j ] == 1 ) { dfs ( i - 1 , j ) ; } else { dfs ( i , j + 1 ) ; } } tab [ i ] [ j ] = 1 ; } odw = vis [ i + 1 ] [ j ] + vis [ i - 1 ] [ j ] + vis [ i ] [ j + 1 ] + vis [ i ] [ j - 1 ] ; if ( odw < akt ) { cout << " 1 " << endl ; return 0 ; } } } } cout << " 2 " << endl ; return 0 ; }
TAB1 create long long x and y ; TAB1 read x , y ; TAB1 set awalz , awaly , and and cnt to 0 ; TAB1 add = 1 ; TAB1 while awalx different from x and awaly different from y ; TAB2 if cnt mod 4 = 0 ; TAB3 for i = 0 to add exclusive ; TAB4 increment awalx ; TAB4 if awalx = x and awaly = y , break ; TAB2 if cnt mod 4 = 1 ; TAB3 for i = 0 to add exclusive ; TAB4 add 1 to awaly ; TAB4 if awalx = x and awaly = y , break ; TAB3 increment add ; TAB2 if cnt mod 4 = 2 ; TAB3 for i = 0 to add exclusive ; TAB4 decrement awalx ; TAB4 if awalx = x and awaly = y , break the loop ; TAB2 if cnt mod 4 = 3 ; TAB3 for i = 0 to add exclusive ; TAB4 decrement awaly ; TAB4 if awalx = x and awaly = y , break the loop ; TAB3 add 1 to add ; TAB2 if awalx = x and awaly = y , break ; TAB2 increment cnt ; TAB2 increment ans ; TAB1 print ans ;	int main ( ) { long long x , y ; cin >> x >> y ; long long awalx = 0 , awaly = 0 , ans = 0 , cnt = 0 ; long long add = 1 ; while ( awalx != x || awaly != y ) { if ( cnt % 4 == 0 ) { for ( int i = 0 ; i < add ; i ++ ) { awalx ++ ; if ( awalx == x && awaly == y ) break ; } } if ( cnt % 4 == 1 ) { for ( int i = 0 ; i < add ; i ++ ) { awaly ++ ; if ( awalx == x && awaly == y ) break ; } add ++ ; } if ( cnt % 4 == 2 ) { for ( int i = 0 ; i < add ; i ++ ) { awalx -- ; if ( awalx == x && awaly == y ) break ; } } if ( cnt % 4 == 3 ) { for ( int i = 0 ; i < add ; i ++ ) { awaly -- ; if ( awalx == x && awaly == y ) break ; } add ++ ; } if ( awalx == x && awaly == y ) break ; cnt ++ ; ans ++ ; } cout << ans << endl ; }
TAB0 declare const int M = 100 + 10 ; TAB0 cal_digit is a int function with long long int argument x ; TAB1 declare int num = 0 ; TAB1 while x > 0 ; TAB2 increment num ; TAB2 set x to x / 10 ; TAB1 return num ; TAB0 long long int function cal_equaltod with int argument d ; TAB1 create long long int ans = 0 ; TAB1 if d = 1 , assign 9 to ans ; TAB1 if d = 2 , assign 9 to ans ; TAB1 if d is greater than 2 ; TAB2 create long long int num = 1 ; TAB2 loop i from 0 to d - 2 exclusive , change num to 10 * num ; TAB2 change ans to 9 * num ; TAB1 return ans ; TAB0 cal_largerthanorequaltox is a long long int function with int argument d and long long int argument x ; TAB1 declare long long int variable ans = 0 ; TAB1 if d = 1 , change ans to 9 - x + 1 ; TAB1 if d is equal to 2 ; TAB2 declare int id0 = x % 10 ; TAB2 declare integer id1 = x / 10 ; TAB2 if id1 > = id0 ; TAB3 set ans to 9 - id1 + 1 ; TAB2 else ; TAB3 set ans to 9 - id1 ; TAB1 if d is greater than 2 ; TAB2 declare long long int variable d10 = 1 ; TAB2 for i from 1 to d - 2 inclusive , set d10 to d10 * 10 ; TAB2 declare int id0 = x modulo 10 ; TAB2 declare int id1 = x / 10 / d10 ; TAB2 change ans to ans + ( 9 - id1 ) * d10 ; TAB2 declare long long int mid = x - id1 * 10 * d10 ; TAB2 set mid to mid / 10 ; TAB2 if id1 > = id0 ; TAB3 assign ans + d10 - 1 - mid + 1 to ans ; TAB2 else ; TAB3 change ans to ans + d10 - 1 - mid ; TAB1 return ans ; TAB1 create long long ints l and r ; TAB1 read l and r ; TAB1 declare integer ld = cal_digit of l ; TAB1 declare integer rd = cal_digit of r ; TAB1 declare long long int variable ans = 0 ; TAB1 loop d from ld + 1 to rd exclusive , setting ans to ans + cal_equaltod of d ; TAB1 if rd is greater than ld ; TAB2 change ans to ans + cal_largerthanorequaltox of ld and l ; TAB2 declare long long int variable nxt = r + 1 ; TAB2 declare integer nxtd = cal_digit of nxt ; TAB2 declare long long int variable tmp = 0 ; TAB2 if nxtd = rd , change tmp to cal_largerthanorequaltox of rd and r + 1 ; TAB2 set ans to ans + cal_equaltod of rd - tmp ; TAB1 if rd is equal to ld ; TAB2 create long long int nxt = r + 1 ; TAB2 declare integer variable nxtd = cal_digit ( nxt ) ; TAB2 declare long long int tmp = 0 ; TAB2 if nxtd is equal to rd , set tmp to cal_largerthanorequaltox ( rd , r + 1 ) ; TAB2 set ans to ans + cal_largerthanorequaltox ( ld , l ) - tmp ; TAB1 print ans ;	const int M = 100 + 10 ; int cal_digit ( long long int x ) { int num = 0 ; while ( x > 0 ) { num ++ ; x = x / 10 ; } return num ; } long long int cal_equaltod ( int d ) { long long int ans = 0 ; if ( d == 1 ) { ans = 9 ; } if ( d == 2 ) { ans = 9 ; } if ( d > 2 ) { long long int num = 1 ; for ( int i = 0 ; i < d - 2 ; i ++ ) { num = 10 * num ; } ans = 9 * num ; } return ans ; } long long int cal_largerthanorequaltox ( int d , long long int x ) { long long int ans = 0 ; if ( d == 1 ) { ans = 9 - x + 1 ; } if ( d == 2 ) { int id0 = x % 10 ; int id1 = x / 10 ; if ( id1 >= id0 ) { ans = 9 - id1 + 1 ; } else { ans = 9 - id1 ; } } if ( d > 2 ) { long long int d10 = 1 ; for ( int i = 1 ; i <= d - 2 ; i ++ ) { d10 = d10 * 10 ; } int id0 = x % 10 ; int id1 = x / 10 / d10 ; ans = ans + ( 9 - id1 ) * d10 ; long long int mid = x - id1 * 10 * d10 ; mid = mid / 10 ; if ( id1 >= id0 ) { ans = ans + d10 - 1 - mid + 1 ; } else { ans = ans + d10 - 1 - mid ; } } return ans ; } int main ( ) { long long int l , r ; cin >> l >> r ; int ld = cal_digit ( l ) ; int rd = cal_digit ( r ) ; long long int ans = 0 ; for ( int d = ld + 1 ; d < rd ; d ++ ) { ans = ans + cal_equaltod ( d ) ; } if ( rd > ld ) { ans = ans + cal_largerthanorequaltox ( ld , l ) ; long long int nxt = r + 1 ; int nxtd = cal_digit ( nxt ) ; long long int tmp = 0 ; if ( nxtd == rd ) { tmp = cal_largerthanorequaltox ( rd , r + 1 ) ; } ans = ans + cal_equaltod ( rd ) - tmp ; } if ( rd == ld ) { long long int nxt = r + 1 ; int nxtd = cal_digit ( nxt ) ; long long int tmp = 0 ; if ( nxtd == rd ) { tmp = cal_largerthanorequaltox ( rd , r + 1 ) ; } ans = ans + cal_largerthanorequaltox ( ld , l ) - tmp ; } cout << ans << endl ; return 0 ; }
TAB1 create string variable with name s ; TAB1 read s from the input ; TAB1 create a map from characters to integers called mp ; TAB1 for integer i = 0 to length of s exclusive , increment mp [ s [ i ] ] ; TAB1 create integer variable called mx and set it ' s value to the min of mp [ ' i ' ] and mp [ ' t ' ] ; TAB1 assign the new value = min of mx and mp [ ' e ' ] / 3 to mx ; TAB1 declare integer variable keep with value mp [ ' n ' ] ; TAB1 create integer peek with value = keep / 2 ; TAB1 if keep is even , decrement peek by one ; TAB1 set mx to min of mx and peek ; TAB1 change mx to max of 0 and mx ; TAB1 print mx to the standard output ;	int main ( ) { string s ; cin >> s ; map < char , int > mp ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { mp [ s [ i ] ] ++ ; } int mx = min ( mp [ ' i ' ] , mp [ ' t ' ] ) ; mx = min ( mx , mp [ ' e ' ] / 3 ) ; int keep = mp [ ' n ' ] ; int peek = keep / 2 ; if ( keep % 2 == 0 ) peek -- ; mx = min ( mx , peek ) ; mx = max ( 0 , mx ) ; cout << mx << endl ; return 0 ; }
TAB0 declare long longs ml = 0 and md = 10e10 ; TAB0 create vector of ints team with 7 elements filled with 0 ; TAB0 create map of string to int called hashi ; TAB0 create map of int / int pairs to bool called likes ; TAB0 create vector of long long called xp with 3 elements ; TAB0 tri is a void function with int argument i ; TAB1 if i is equal to 7 ; TAB2 create long longs mie = 10e10 and mae and lik = 0 ; TAB2 create bool can = true ; TAB2 for integer j = 0 to 3 exclusive ; TAB3 create long long co = 0 ; TAB3 loop k from 0 to 7 exclusive ; TAB4 if team [ k ] is equal to j ; TAB5 increment co ; TAB5 for l = 0 to 7 exclusive ; TAB6 if team [ l ] = j and likes [ pair < int , int > ( k , l ) ] is true , increment lik by one ; TAB3 if co is equal to 0 ; TAB4 assign false to can ; TAB4 break ; TAB3 change mie to min of mie and xp [ j ] / co ; TAB3 change mae to max of mae and xp [ j ] / co ; TAB2 if can is true ; TAB3 create long long dif = mae - mie ; TAB3 if dif = md ; TAB4 set ml to max of lik and ml ; TAB3 else if dif < md ; TAB4 assign dif to md ; TAB4 assign lik to ml ; TAB1 else ; TAB2 for integer j = 0 to 3 exclusive ; TAB3 set team [ i ] to j ; TAB3 call tri ( i + 1 ) ; TAB1 return ; TAB1 declare int variable n ; TAB1 read input to n ; TAB1 assign 0 to hashi [ " Trolong long " ] ; TAB1 assign 1 to hashi [ " Dracul " ] ; TAB1 assign 2 to hashi [ " Anka " ] ; TAB1 assign 3 to hashi [ " Snowy " ] ; TAB1 assign 4 to hashi [ " Hexadecimal " ] ; TAB1 assign 5 to hashi [ " Chapay " ] ; TAB1 assign 6 to hashi [ " Cleo " ] ; TAB1 loop , decrementing n , while it is not 0 ; TAB2 create strings p and q ; TAB2 read input to p , q and q ; TAB2 set likes [ pair < int , int > ( hashi [ p ] , hashi [ q ] ) ] to true ; TAB1 loop i from 0 to 3 exclusive , read xp [ i ] ; TAB1 call tri ( 0 ) ; TAB1 print md , " " , ml and " \ n " ;	long long md = 10e10 , ml = 0 ; vector < int > team ( 7 , 0 ) ; map < string , int > hashi ; map < pair < int , int > , bool > likes ; vector < long long > xp ( 3 ) ; void tri ( int i ) { if ( i == 7 ) { long long mie = 10e10 , mae = 0 , lik = 0 ; bool can = true ; for ( int j = 0 ; j < 3 ; j ++ ) { long long co = 0 ; for ( int k = 0 ; k < 7 ; k ++ ) { if ( team [ k ] == j ) { co ++ ; for ( int l = 0 ; l < 7 ; l ++ ) { if ( team [ l ] == j && likes [ pair < int , int > ( k , l ) ] ) { lik ++ ; } } } } if ( co == 0 ) { can = false ; break ; } mie = min ( mie , xp [ j ] / co ) ; mae = max ( mae , xp [ j ] / co ) ; } if ( can ) { long long dif = mae - mie ; if ( dif == md ) ml = max ( lik , ml ) ; else if ( dif < md ) { md = dif ; ml = lik ; } } } else { for ( int j = 0 ; j < 3 ; j ++ ) { team [ i ] = j ; tri ( i + 1 ) ; } } return ; } int main ( ) { int n ; cin >> n ; hashi [ " Trolong long " ] = 0 ; hashi [ " Dracul " ] = 1 ; hashi [ " Anka " ] = 2 ; hashi [ " Snowy " ] = 3 ; hashi [ " Hexadecimal " ] = 4 ; hashi [ " Chapay " ] = 5 ; hashi [ " Cleo " ] = 6 ; while ( n -- ) { string p , q ; cin >> p >> q >> q ; likes [ pair < int , int > ( hashi [ p ] , hashi [ q ] ) ] = true ; } for ( int i = 0 ; i < 3 ; i ++ ) cin >> xp [ i ] ; tri ( 0 ) ; cout << md << "   " << ml << " \n " ; return 0 ; }
TAB0 function read with int argument & x ; TAB1 declare char ch and read it from the input ; TAB1 create boolean f = 0 ; TAB1 change x to 0 ; TAB1 while ch is not a digit character ; TAB2 if ch = ' - ' , change f to 1 ; TAB2 read ch from the input ; TAB1 while ch is a digit character ; TAB2 assign x * 10 + ch - 48 to x ; TAB2 read ch from the input ; TAB1 if f is true , invert the sigh of x ; TAB0 void function read with long long reference argument & x ; TAB1 declare char ch and read it from the input ; TAB1 create bool f = 0 ; TAB1 change x to 0 ; TAB1 while ch is not a digit character ; TAB2 if ch = ' - ' , set f to 1 ; TAB2 read ch from the input ; TAB1 while ch is a digit character ; TAB2 set x to x * 10 + ch - 48 ; TAB2 read ch from the input ; TAB1 if f is true , invert the sigh of x ; TAB0 create int array parent with 150001 element ; TAB0 declare int array ranks with size 150001 ; TAB0 let sizeedge be long long array with size 150001 ; TAB0 declare long long array size with size 150001 ; TAB0 build is a void function with int argument n ; TAB1 for integer i = 0 to n inclusive , set parent [ i ] to i and set size [ i ] to 1LL ; TAB0 int function find with int argument x ; TAB1 return x = x = = parent [ x ] ? x : find ( parent [ x ] ) ; TAB0 void function merge with int arguments x and y ; TAB1 set x to find ( x ) and set y to find ( y ) ; TAB1 if ranks [ x ] is greater than ranks [ y ] ) swap x and y ; TAB1 if ranks [ x ] = ranks [ y ] , increment ranks [ y ] ; TAB1 if x ! = y ; TAB2 assign y to parent [ x ] ; TAB2 set size [ y ] to size [ x ] + size [ y ] ; TAB2 set sizeedge [ y ] to sizeedge [ x ] + sizeedge [ y ] + 1LL ; TAB1 else ; TAB2 increment sizeedge [ y ] by one ; TAB1 declare integers v and e ; TAB1 call read with argument v ; TAB1 call read with argument e ; TAB1 call build with argument v ; TAB1 for integer i = 0 to e exclusive ; TAB2 declare ints from and to ; TAB2 call read with argument from ; TAB2 call read with argument to ; TAB2 call merge with arguments from and to ; TAB1 for integer i = 1 to v inclusive ; TAB2 if i is equal to find ( i ) ; TAB3 if sizeedge [ i ] ! = size [ i ] * ( size [ i ] - 1 ) / 2 ; TAB4 print " NO " ; TAB1 print " YES " ;	void read ( int & x ) { char ch = getchar ( ) ; bool f = 0 ; x = 0 ; while ( ch > ' 9 ' || ch < ' 0 ' ) { if ( ch == ' - ' ) f = 1 ; ch = getchar ( ) ; } while ( ch >= ' 0 ' && ch <= ' 9 ' ) { x = x * 10 + ch - 48 ; ch = getchar ( ) ; } if ( f ) x = - x ; } void read ( long long & x ) { char ch = getchar ( ) ; bool f = 0 ; x = 0 ; while ( ch > ' 9 ' || ch < ' 0 ' ) { if ( ch == ' - ' ) f = 1 ; ch = getchar ( ) ; } while ( ch >= ' 0 ' && ch <= ' 9 ' ) { x = x * 10 + ch - 48 ; ch = getchar ( ) ; } if ( f ) x = - x ; } int parent [ 150001 ] ; int ranks [ 150001 ] ; long long sizeedge [ 150001 ] ; long long size [ 150001 ] ; void build ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) parent [ i ] = i , size [ i ] = 1LL ; } int find ( int x ) { return x = x == parent [ x ] ? x : find ( parent [ x ] ) ; } void merge ( int x , int y ) { x = find ( x ) , y = find ( y ) ; if ( ranks [ x ] > ranks [ y ] ) swap ( x , y ) ; if ( ranks [ x ] == ranks [ y ] ) ranks [ y ] ++ ; if ( x != y ) { parent [ x ] = y ; size [ y ] = size [ x ] + size [ y ] ; sizeedge [ y ] = sizeedge [ x ] + sizeedge [ y ] + 1LL ; } else { sizeedge [ y ] ++ ; } } int main ( ) { int v , e ; read ( v ) ; read ( e ) ; build ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { int from , to ; read ( from ) ; read ( to ) ; merge ( from , to ) ; } for ( int i = 1 ; i <= v ; i ++ ) { if ( i == find ( i ) ) { if ( sizeedge [ i ] != size [ i ] * ( size [ i ] - 1 ) / 2 ) { puts ( " NO " ) ; return 0 ; } } } puts ( " YES " ) ; return 0 ; }
TAB1 declare ints ct = 0 and foo = 1 ; TAB1 declare strings str1 and str2 ; TAB1 create integer arrays arr1 and arr2 with size 27 ; TAB1 read str1 and str2 ; TAB1 declare int n1 = length of str1 ; TAB1 declare int n2 = length of str2 ; TAB1 if n1 ! = n2 ; TAB2 print " NO \ n " ; TAB1 else ; TAB2 for integer i = 0 to n1 exclusive ; TAB3 if str1 [ i ] ! = str2 [ i ] , increment ct ; TAB2 loop i from 0 to n1 exclusive ; TAB3 declare int temp1 = str1 [ i ] - ' a ' ; TAB3 declare int temp2 = str2 [ i ] - ' a ' ; TAB3 increment arr1 [ temp1 ] ; TAB3 increment arr2 [ temp2 ] ; TAB2 for i from 1 to 26 inclusive ; TAB3 if arr1 [ i ] ! = arr2 [ i ] , set foo to 0 ; TAB2 if ct < = 2 and foo = 1 ; TAB3 print " YES \ n " ; TAB2 else ; TAB3 print " NO \ n " ;	int main ( ) { int ct = 0 , foo = 1 ; string str1 , str2 ; int arr1 [ 27 ] = { } , arr2 [ 27 ] = { } ; cin >> str1 >> str2 ; int n1 = str1 . size ( ) ; int n2 = str2 . size ( ) ; if ( n1 != n2 ) { cout << " NO\n " ; return 0 ; } else { for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) { ct ++ ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int temp1 = str1 [ i ] - ' a ' ; int temp2 = str2 [ i ] - ' a ' ; arr1 [ temp1 ] ++ ; arr2 [ temp2 ] ++ ; } for ( int i = 1 ; i <= 26 ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) foo = 0 ; } if ( ct <= 2 && foo == 1 ) cout << " YES\n " ; else cout << " NO\n " ; } }
TAB0 comp is a new boolean function with long long pair arguments a and b ; TAB1 return true if a . first < b . first or else otherwise ; TAB1 create long long variable with name n ; TAB1 s is a new string variable ; TAB1 read input to n and s ; TAB1 create new boolean variable fl with value 0 ; TAB1 declare new long longs cnt and flg = 0 ; TAB1 for i from 0 to n exclusive ; TAB2 if s [ i ] = ' ? ' , increment cnt ; TAB1 in a for loop , change i from 0 to n - 1 exclusive incrementing i ; TAB2 if s [ i ] = s [ i + 1 ] and s [ i ] ! = ' ? ' , set fl to 1 ; TAB1 if fl is set ; TAB2 print " No " and ' \ n ' ; TAB1 else ; TAB2 for i = 1 to n - 1 exclusive incrementing i ; TAB3 if s [ i ] = ' ? ' and s [ i - 1 ] ! = s [ i + 1 ] and s [ i - 1 ] ! = ' ? ' and s [ i + 1 ] ! = ' ? ' , increment flg by one ; TAB2 if flg = cnt ; TAB3 print " No " and ' \ n ' to the standard output ; TAB2 else ; TAB3 print " Yes " and ' \ n ' ;	bool comp ( pair < long long , long long > a , pair < long long , long long > b ) { return a . first < b . first ; } int main ( ) { long long n ; string s ; cin >> n >> s ; bool fl = 0 ; long long cnt = 0 , flg = 0 ; for ( long long i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ? ' ) cnt ++ ; for ( long long i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] && s [ i ] != ' ? ' ) fl = 1 ; } if ( fl ) cout << " No " << ' \n ' ; else { for ( long long i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' ? ' && s [ i - 1 ] != s [ i + 1 ] && s [ i - 1 ] != ' ? ' && s [ i + 1 ] != ' ? ' ) flg ++ ; } if ( flg == cnt ) cout << " No " << ' \n ' ; else cout << " Yes " << ' \n ' ; } return 0 ; }
TAB1 let x1 , y1 , x2 , y2 be long integers ; TAB1 while read x1 , y1 , x2 , y2 ; TAB2 let a , b , c be long integers ; TAB2 let n , ans be integers with ans = 0 ; TAB2 read n ; TAB2 for i = 0 to n exclusive ; TAB3 read a , b , c ; TAB3 if a * x1 + b * y1 + c is less than 0 and a * x2 + b * y2 + c is greater than 0 , increment ans by 1 ; TAB3 if a * x1 + b * y1 + c is greater than 0 and a * x2 + b * y2 + c is less than 0 , increment ans by 1 ; TAB2 print ans and new line ;	int main ( ) { long long x1 , y1 , x2 , y2 ; while ( cin >> x1 >> y1 >> x2 >> y2 ) { long long a , b , c ; int n , ans = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b >> c ; if ( a * x1 + b * y1 + c < 0 && a * x2 + b * y2 + c > 0 ) ans ++ ; if ( a * x1 + b * y1 + c > 0 && a * x2 + b * y2 + c < 0 ) ans ++ ; } cout << ans << endl ; } return 0 ; }
TAB1 n , x , y , dB , dW , b1 , b2 , w1 , w2 = long long integers ; TAB1 read n , x , and y ; TAB1 if x is equal to 1 and y is equal to 1 then ; TAB2 print White ; TAB1 else if x is equal to n and y is equal to n ; TAB2 print Black ; TAB1 else ; TAB2 set w1 to x - 1 ; TAB2 set w2 to y - 1 ; TAB2 set dW to max of w1 and w2 ; TAB2 set b1 to n - x ; TAB2 set b2 to n - y ; TAB2 set dB to max of b1 and b2 ; TAB2 if dW is less than or equal to dB ; TAB3 print White ; TAB2 else if dB is less than dW ; TAB3 print Black ;	int main ( ) { long long n , x , y , dB , dW , b1 , b2 , w1 , w2 ; cin >> n >> x >> y ; if ( x == 1 and y == 1 ) { cout << " White " << endl ; } else if ( x == n and y == n ) { cout << " Black " << endl ; } else { w1 = x - 1 ; w2 = y - 1 ; dW = max ( w1 , w2 ) ; b1 = n - x ; b2 = n - y ; dB = max ( b1 , b2 ) ; if ( dW == dB or dW < dB ) { cout << " White " << endl ; } else if ( dB < dW ) { cout << " Black " << endl ; } } }
TAB0 A = int array size 1000 ; TAB1 n = int ; TAB1 read n ; TAB1 two = int , two = 1 ; TAB1 while two < = n , multiply two by 2 ; TAB1 divide two by 2 ; TAB1 print n % 2 ? ( n - 1 ) / 2 : ( n - two ) / 2 ;	int A [ 1000 ] ; int main ( ) { int n ; cin >> n ; int two = 1 ; while ( two <= n ) two *= 2 ; two /= 2 ; cout << ( n % 2 ? ( n - 1 ) / 2 : ( n - two ) / 2 ) << endl ; }
TAB0 declare unsigned long longs n , cp , x , y , unsigned long long array a size 100010 ; TAB1 read n , x , y ; TAB1 if x is greater than y ; TAB2 let cp be y ; TAB2 let y be x ; TAB2 let x be cp ; TAB1 declare unsigned long long sumwhite = y - 1 ; TAB1 declare unsigned long long sumblack = n - x ; TAB1 end statement ; TAB1 print " White " if sumwhite is less than or equal to sumblack , else " Black " ;	unsigned long long n , cp , x , y , a [ 100010 ] ; int main ( ) { cin >> n >> x >> y ; if ( x > y ) { cp = y ; y = x ; x = cp ; } unsigned long long sumwhite = y - 1 ; unsigned long long sumblack = n - x ; ; puts ( sumwhite <= sumblack ? " White " : " Black " ) ; }
TAB0 create character arrays a , b with a size 100010 b size 100010 ; TAB0 create integers i , j , p , q with j = 0 , p = - 1 , q = - 1 ; TAB1 read a , read b ; TAB1 for i = 0 to a [ i ] or b [ i ] , incrementing i ; TAB2 if a [ i ] is not b [ i ] ; TAB3 if increment j , p is less than 0 ; TAB4 set p to i ; TAB3 else ; TAB4 set q to i ; TAB1 print " YES " if j is 2 and a [ p ] is b [ q ] and a [ q ] is b [ p ] , else " NO " ;	char a [ 100010 ] , b [ 100010 ] ; int i , j = 0 , p = - 1 , q = - 1 ; int main ( ) { gets ( a ) , gets ( b ) ; for ( i = 0 ; a [ i ] || b [ i ] ; ++ i ) if ( a [ i ] != b [ i ] ) if ( ++ j , p < 0 ) p = i ; else q = i ; puts ( j == 2 && a [ p ] == b [ q ] && a [ q ] == b [ p ] ? " YES " : " NO " ) ; return 0 ; }
TAB0 declare const long long maxn = 1e9 + 7 ; TAB0 declare const long double EPS = 1e - 9 ; TAB0 create const long long INF = 1e18 + 18 ; TAB0 create const long long mod = 1e9 + 7 ; TAB1 declare long longs n , k and x with x = INF ; TAB1 create strings s and temp ; TAB1 read n , k and s ; TAB1 loop i from 1 to length of s exclusive ; TAB2 if substring of s from 0 to n - i = substring of s from i to n - i ; TAB3 set x to i ; TAB3 break the loop ; TAB1 if x is equal to INF ; TAB2 loop i from 0 to k exclusive , print s ; TAB2 print ' \ n ' ; TAB1 declare string variable op = substring of s from n - x ; TAB1 set temp to s ; TAB1 for long long i = 0 to k - 1 exclusive , append op to temp ; TAB1 print temp and ' \ n ' ;	const long long maxn = ( long long ) 1e9 + 7 ; const long double EPS = 1e-9 ; const long long INF = ( long long ) 1e18 + 18 ; const long long mod = ( long long ) 1e9 + 7 ; int main ( ) { long long n , k , x = INF ; string s , temp ; cin >> n >> k >> s ; for ( long long i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . substr ( 0 , n - i ) == s . substr ( i , n - i ) ) { x = i ; break ; } } if ( x == INF ) { for ( long long i = 0 ; i < k ; i ++ ) cout << s ; cout << ' \n ' ; return 0 ; } string op = s . substr ( n - x , s . length ( ) ) ; temp = s ; for ( long long i = 0 ; i < k - 1 ; i ++ ) temp += op ; cout << temp << ' \n ' ; }
TAB1 let n , count , i , j = integers ; TAB1 set count = 0 ; TAB1 read n ; TAB1 let line = array of integers size n and values = 0 ; TAB1 read n values into array line ; TAB1 let max = integer value = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if line [ i ] is greater than line [ max ] set max = i ; TAB1 for i = max - 1 to 0 inclusive decrementing do the following ; TAB2 let temp = integer value = line [ i ] ; TAB2 set line [ i ] = line [ i + 1 ] ; TAB2 set line [ i + 1 ] = temp ; TAB2 increment count ; TAB1 let min = integer value = 0 ; TAB1 for i = 0 to n exclusive do the following ; TAB2 if line [ i ] is greater than or equal to line [ min ] set min = i ; TAB1 print count + n - min - 1 ;	int main ( ) { int n , count , i , j ; count = 0 ; cin >> n ; int line [ n ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) { cin >> line [ i ] ; } int max = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( line [ i ] > line [ max ] ) { max = i ; } } for ( i = max - 1 ; i >= 0 ; i -- ) { int temp = line [ i ] ; line [ i ] = line [ i + 1 ] ; line [ i + 1 ] = temp ; count ++ ; } int min = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( line [ i ] <= line [ min ] ) { min = i ; } } cout << count + n - min - 1 << endl ; }
TAB0 make ints n , a , b , and k ; TAB0 let int array s of size 100000 ; TAB0 let string inp ; TAB0 make map dp from ints and ints ; TAB0 declare bpow taking in ints n and e and returning integer ; TAB1 create integer array b of size 30 ; TAB1 set b [ 0 ] to n ; TAB1 for i = 1 to 30 exclusive , set b [ i ] to ( ( long long ) b [ i - 1 ] * b [ i - 1 ] ) % 1000000009 ; TAB1 make integer ans = 1 ; TAB1 for i = 0 to 30 exclusive ; TAB2 if e & ( 1 < < i ) are truthy set ans to ( ( long long ) ans * b [ i ] ) % 1000000009 ; TAB1 return ans ; TAB0 declare bdiv taking in integers n and d and returning integer ; TAB1 return the result of ( ( long long ) n * bpow ( d , 1000000009 - 2 ) ) % 1000000009 ; TAB0 declare alt taking in int e and returning int ; TAB1 if e % k is not 0 , end function ; TAB1 if dp . count ( e ) is falsy ; TAB2 if e is 0 ; TAB3 end function ; TAB2 else if e is k ; TAB3 set dp [ e ] to 1 ; TAB2 else do ; TAB3 create int l = e / 2 / k * k ; TAB3 make integer r = e - 1 ; TAB3 let integer ans = ( ( ( long long ) alt ( l ) * bpow ( a , r ) ) + ( long long ) alt ( r ) * bpow ( b , l ) ) % 1000000009 ; TAB3 set dp [ e ] to ans ; TAB1 return dp [ e ] ; TAB1 read n , a , b , and k ; TAB1 read inp ; TAB1 for i = 0 to k exclusive ; TAB2 if inp [ i ] is ' + ' ; TAB3 set s [ i ] to 1 ; TAB2 else do ; TAB3 set s [ i ] to - 1 ; TAB1 create int x = 0 ; TAB1 for i = 0 to k exclusive ; TAB2 create integer toadd = ( ( long long ) s [ i ] * bpow ( a , k - 1 - i ) ) % 1000000009 ; TAB2 set toadd to ( ( long long ) toadd * bpow ( b , i ) ) % 1000000009 ; TAB2 set x to ( ( long long ) x + toadd + 1000000009 ) % 1000000009 ; TAB1 display x , " " , and alt ( n + 1 ) to error ; TAB1 create integer ans = ( ( long long ) x * alt ( n + 1 ) ) % 1000000009 ; TAB1 display ans ;	int n , a , b , k ; int s [ 100000 ] ; string inp ; map < int , int > dp ; int bpow ( int n , int e ) { int b [ 30 ] ; b [ 0 ] = n ; for ( int i = 1 ; i < 30 ; i ++ ) b [ i ] = ( ( long long ) b [ i - 1 ] * b [ i - 1 ] ) % 1000000009 ; int ans = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) if ( e & ( 1 << i ) ) ans = ( ( long long ) ans * b [ i ] ) % 1000000009 ; return ans ; } int bdiv ( int n , int d ) { return ( ( long long ) n * bpow ( d , 1000000009 - 2 ) ) % 1000000009 ; } int alt ( int e ) { assert ( e % k == 0 ) ; if ( ! dp . count ( e ) ) { if ( e == 0 ) assert ( 0 ) ; else if ( e == k ) dp [ e ] = 1 ; else { int l = e / 2 / k * k ; int r = e - l ; int ans = ( ( ( long long ) alt ( l ) * bpow ( a , r ) ) + ( long long ) alt ( r ) * bpow ( b , l ) ) % 1000000009 ; dp [ e ] = ans ; } } return dp [ e ] ; } int main ( ) { cin >> n >> a >> b >> k ; cin >> inp ; for ( int i = 0 ; i < k ; i ++ ) { if ( inp [ i ] == ' + ' ) s [ i ] = 1 ; else s [ i ] = - 1 ; } int x = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int toadd = ( ( long long ) s [ i ] * bpow ( a , k - 1 - i ) ) % 1000000009 ; toadd = ( ( long long ) toadd * bpow ( b , i ) ) % 1000000009 ; x = ( ( long long ) x + toadd + 1000000009 ) % 1000000009 ; } cerr << x << "   " << alt ( n + 1 ) << endl ; int ans = ( ( long long ) x * alt ( n + 1 ) ) % 1000000009 ; cout << ans << endl ; }
TAB0 declare f with long long p as argument , returning long long ; TAB1 if p is less than 10 , return p from function ; TAB1 create long longs r , f with r = p / 10 + 9 , f = p ; TAB1 while f is greater than or equal to 10 , set f to f / 10 ; TAB1 if f is greater than p % 10 , decrement r ; TAB1 return r from function ; TAB1 create long longs m , n ; TAB1 read m reada n ; TAB1 print result of run f with n as argument - result of run f with m - 1 as arguments , print newline ;	long long f ( long long p ) { if ( p < 10 ) return p ; long long r = p / 10 + 9 , f = p ; while ( f >= 10 ) f /= 10 ; if ( f > p % 10 ) r -- ; return r ; } int main ( ) { long long m , n ; cin >> m >> n ; cout << f ( n ) - f ( m - 1 ) << endl ; return 0 ; }
TAB0 s = character array of size 200005 ; TAB0 n = integer ; TAB0 mp = map from char to integer ; TAB1 read n , s ; TAB1 clear mp ; TAB1 for i = 0 to n exclusive , increment mp [ s [ i ] ] ; TAB1 flag = integer with flag = 1 ; TAB1 for i = a to z ; TAB2 if mp [ i ] > 1 ; TAB3 print Yes ; TAB1 if n is 1 ; TAB2 print Yes ; TAB1 else ; TAB2 print No ;	char s [ 200000 + 5 ] ; int n ; map < char , int > mp ; int main ( ) { cin >> n >> s ; mp . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] ++ ; } int flag = 1 ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) { if ( mp [ i ] > 1 ) { cout << " Yes " << endl ; return 0 ; } } if ( n == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB0 set Pi to acos of - 1 ; TAB0 set INF to 0x3f3f3f3f ; TAB0 assign 1e3 + 5 to MAXN ; TAB1 create int n , a , b , c , d , sum , ans , set ans to 1 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read a , b , c and d ; TAB2 if i = 0 ; TAB3 set sum to a + b + c + d ; TAB2 else if sum less than a + b + c + d ; TAB3 increment ans ; TAB1 print ans ;	const double PI = acos ( - 1 ) ; const int INF = 0x3f3f3f3f ; const int MAXN = 1e3 + 5 ; int main ( ) { int n , a , b , c , d , sum , ans = 1 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b >> c >> d ; if ( i == 0 ) sum = a + b + c + d ; else if ( sum < a + b + c + d ) ans ++ ; } cout << ans << endl ; }
TAB0 f = integer 2d array of size [ 110 ] [ 110 ] ; TAB1 i , j , n , k , m = integers ; TAB1 while read k ; TAB2 for i = 1 to 100 ; TAB3 for j = 1 to 100 , f [ i ] [ j ] = 0 ; TAB2 for i = 1 to 100 ; TAB3 if ( i * ( i - 1 ) * ( i - 2 ) / 6 > k ) break loop ; TAB2 n = i - 1 ; TAB2 for i = 1 to n ; TAB3 for j = 1 to n ; TAB4 if ( i is not j ) , f [ i ] [ j ] = 1 ; TAB2 k = k - n * ( n - 1 ) * ( n - 2 ) / 6 ; TAB2 if ( k > 0 ) ; TAB3 for i = 1 to 100 ; TAB4 if ( i * ( i - 1 ) / 2 > k ) break loop ; TAB3 m = i - 1 ; TAB3 for i = 1 to m , f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1 ; TAB3 n = n + 1 ; TAB3 k = k - ( m - 1 ) * m / 2 ; TAB3 if ( k > 0 ) ; TAB4 for i = 1 to 100 ; TAB5 if ( i * ( i - 1 ) / 2 > k ) break loop ; TAB4 m = i - 1 ; TAB4 for i = 1 to m , f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1 ; TAB4 n = n + 1 ; TAB4 k = k - ( m - 1 ) * m / 2 ; TAB3 for i = 1 to k ; TAB4 f [ n + i ] [ 1 ] = f [ 1 ] [ n + i ] = 1 ; TAB4 f [ n + i ] [ 2 ] = f [ 2 ] [ n + i ] = 1 ; TAB3 n = n + k ; TAB2 print n ; TAB2 for i = 1 to n ; TAB3 for j = 1 to n , print f [ i ] [ j ] ; TAB3 print new line ;	int f [ 110 ] [ 110 ] ; int main ( ) { int i , j , n , k , m ; while ( cin >> k ) { for ( i = 1 ; i <= 100 ; i ++ ) for ( j = 1 ; j <= 100 ; j ++ ) f [ i ] [ j ] = 0 ; for ( i = 1 ; i <= 100 ; i ++ ) if ( i * ( i - 1 ) * ( i - 2 ) / 6 > k ) break ; n = i - 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) if ( i != j ) f [ i ] [ j ] = 1 ; k = k - n * ( n - 1 ) * ( n - 2 ) / 6 ; if ( k > 0 ) { for ( i = 1 ; i <= 100 ; i ++ ) if ( i * ( i - 1 ) / 2 > k ) break ; m = i - 1 ; for ( i = 1 ; i <= m ; i ++ ) f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1 ; n += 1 ; k = k - ( m - 1 ) * m / 2 ; if ( k > 0 ) { for ( i = 1 ; i <= 100 ; i ++ ) if ( i * ( i - 1 ) / 2 > k ) break ; m = i - 1 ; for ( i = 1 ; i <= m ; i ++ ) f [ i ] [ n + 1 ] = f [ n + 1 ] [ i ] = 1 ; n += 1 ; k = k - ( m - 1 ) * m / 2 ; } for ( i = 1 ; i <= k ; i ++ ) { f [ n + i ] [ 1 ] = f [ 1 ] [ n + i ] = 1 ; f [ n + i ] [ 2 ] = f [ 2 ] [ n + i ] = 1 ; } n += k ; } cout << n << endl ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) cout << f [ i ] [ j ] ; cout << endl ; } } return 0 ; }
TAB0 let fx , fy , dx , dy ints , all with value 0 ; TAB1 read fx and fy ; TAB1 let c a string ; TAB1 read c ; TAB1 if fx and fy are 0 , print Yes and return 0 ; TAB1 for i = 0 to length of c exclusive ; TAB2 if c [ i ] is u ; TAB3 increment dy ; TAB2 otherwise if c [ i ] is D ; TAB3 decrement dy ; TAB2 otherwise , if c [ i ] is L ; TAB3 decrement dx ; TAB2 otherwise ; TAB3 increment dx ; TAB1 for i = 0 to size of c exclusive ; TAB2 let nx , ny ints with value 0 ; TAB2 for j = 0 to i inclusive ; TAB3 if c [ j ] is U ; TAB4 increment ny ; TAB3 otherwise if c [ j ] is D ; TAB4 decrement ny ; TAB3 otherwise if c [ j ] is L ; TAB4 decrement nx ; TAB3 otherwise ; TAB4 increment nx ; TAB2 if nx equals fx and ny equals fy , print Yes and return 0 ; TAB2 let k1 and k2 be integers with value 0 ; TAB2 if dx is not 0 , set k1 to ( fx - nx ) / dx ; TAB2 if dy is not 0 , set k2 = ( fy - ny ) / dy ; TAB2 if dx is 0 , set k1 equals k2 ; TAB2 if dy is 0 , set k2 equals k1 ; TAB2 if k1 * dx + nx = fx and k2 * dy + ny = fy and k1 nonnegative , print Yes and return 0 ; TAB1 print No and return 0 ;	int fx = 0 , fy = 0 , dx = 0 , dy = 0 ; int main ( ) { cin >> fx >> fy ; string c ; cin >> c ; if ( fx == 0 && fy == 0 ) return cout << " Yes " << endl , 0 ; for ( int i = 0 ; i < c . size ( ) ; i ++ ) { if ( c [ i ] == ' U ' ) dy ++ ; else if ( c [ i ] == ' D ' ) dy -- ; else if ( c [ i ] == ' L ' ) dx -- ; else dx ++ ; } for ( int i = 0 ; i < c . size ( ) ; i ++ ) { int nx = 0 , ny = 0 ; for ( int j = 0 ; j <= i ; j ++ ) { if ( c [ j ] == ' U ' ) ny ++ ; else if ( c [ j ] == ' D ' ) ny -- ; else if ( c [ j ] == ' L ' ) nx -- ; else nx ++ ; } if ( nx == fx && ny == fy ) return cout << " Yes " << endl , 0 ; int k1 = 0 , k2 = 0 ; if ( dx != 0 ) k1 = ( fx - nx ) / dx ; if ( dy != 0 ) k2 = ( fy - ny ) / dy ; if ( dx == 0 ) k1 = k2 ; if ( dy == 0 ) k2 = k1 ; if ( k1 * dx + nx == fx && k2 * dy + ny == fy && k1 == k2 && k1 >= 0 ) return cout << " Yes " << endl , 0 ; } return cout << " No " << endl , 0 ; }
TAB0 integers = n , m ; TAB1 read n , m ; TAB1 integers = a , ans , maxa = - 1 ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 read a ; TAB2 if is 0 then do the following ; TAB3 divide a by m ; TAB2 else ; TAB3 divide a by m ; TAB3 add one to a ; TAB2 if a is greater than or equal to maxa then do the following ; TAB3 set maxa to a ; TAB3 set ans to i ; TAB1 output ans ;	int n , m ; int main ( ) { cin >> n >> m ; int a , ans , maxa = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a ; if ( ( a % m ) == 0 ) a /= m ; else { a /= m ; a ++ ; } if ( a >= maxa ) { maxa = a ; ans = i ; } } cout << ans << " \n " ; return 0 ; }
TAB0 declare long long arrays arr size 100010 , dp size 100010 by 2 , d size 100010 ; TAB1 declare integer n ; TAB1 declare long long ans = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 if i is greater than 0 , let d [ i ] be absolute value of ( arr [ i ] - arr [ i - 1 ] ) ; TAB1 for i = 1 to n inclusive ; TAB2 let dp [ i ] [ 0 ] be maximum of ( d [ i ] and d [ i ] + dp [ i - 1 ] [ 1 ] ) ; TAB2 let dp [ i ] [ 1 ] be maximum of ( - d [ i ] and dp [ i - 1 ] [ 0 ] - d [ i ] ) ; TAB2 let ans be maximum of ( ans and maximum of ( dp [ i ] [ 0 ] and dp [ i ] [ 1 ] ) ) ; TAB1 print ans and newline ;	long long arr [ 100010 ] , dp [ 100010 ] [ 2 ] , d [ 100010 ] ; int main ( ) { int n ; long long ans = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; if ( i > 0 ) d [ i ] = abs ( arr [ i ] - arr [ i - 1 ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = max ( d [ i ] , d [ i ] + dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = max ( - d [ i ] , dp [ i - 1 ] [ 0 ] - d [ i ] ) ; ans = max ( ans , max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] ) ) ; } cout << ans << endl ; return 0 ; }
TAB0 declare constant integer M = 2e5 + 5 ; TAB0 declare integer arrays G size 200 by 200 , T size 200 by 200 ; TAB1 declare integers n , m , i , j ; TAB1 read n , m ; TAB1 declare boolean f = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 read G [ i ] [ j ] ; TAB3 let T [ i ] [ j ] be G [ i ] [ j ] ; TAB1 declare integer vectors r , , c ; TAB1 for i = 1 to n inclusive ; TAB2 declare integer mn = 1000 ; TAB2 for j = 1 to m inclusive , let mn be minimum of ( mn and G [ i ] [ j ] ) ; TAB2 for j = 1 to m inclusive , decrement G [ i ] [ j ] by mn ; TAB2 for j = 1 to mn inclusive , add i to end of r ; TAB1 for i = 1 to m inclusive ; TAB2 declare integer mn = 1000 ; TAB2 for j = 1 to n inclusive , let mn be minimum of ( mn and G [ j ] [ i ] ) ; TAB2 for j = 1 to n inclusive , decrement G [ j ] [ i ] by mn ; TAB2 for j = 1 to mn inclusive , add i to end of c ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if G [ i ] [ j ] is true ; TAB4 print " - 1 \ n " ; TAB3 let G [ i ] [ j ] be T [ i ] [ j ] ; TAB1 declare integer vectors r1 , c1 ; TAB1 for i = 1 to m inclusive ; TAB2 declare integer mn = 1000 ; TAB2 for j = 1 to n inclusive , let mn be minimum of ( mn and G [ j ] [ i ] ) ; TAB2 for j = 1 to n inclusive , decrement G [ j ] [ i ] by mn ; TAB2 for j = 1 to mn inclusive , add i to end of c1 ; TAB1 for i = 1 to n inclusive ; TAB2 declare integer mn = 1000 ; TAB2 for j = 1 to n inclusive , let mn be minimum of ( mn and G [ j ] [ i ] ) ; TAB2 for j = 1 to n inclusive , decrement G [ j ] [ i ] by mn ; TAB2 for j = 1 to mn inclusive , add i to end of r1 ; TAB1 if size of r + size of c is greater than size of r1 + size of c1 ; TAB2 let r be r1 ; TAB2 let c be c1 ; TAB1 print size of r + size of c , " \ n " ; TAB1 for i = 0 to size of r exclusive ; TAB2 print " row " ; TAB2 print r [ i ] , " \ n " ; TAB1 for i = 0 to size of c exclusive ; TAB2 print " col " ; TAB2 print c [ i ] , " \ n " ;	const int M = 2e5 + 5 ; int G [ 200 ] [ 200 ] , T [ 200 ] [ 200 ] ; int main ( ) { int n , m , i , j ; cin >> n >> m ; bool f = 0 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) { cin >> G [ i ] [ j ] ; T [ i ] [ j ] = G [ i ] [ j ] ; } vector < int > r , c ; for ( i = 1 ; i <= n ; i ++ ) { int mn = 1000 ; for ( j = 1 ; j <= m ; j ++ ) mn = min ( mn , G [ i ] [ j ] ) ; for ( j = 1 ; j <= m ; j ++ ) G [ i ] [ j ] -= mn ; for ( j = 1 ; j <= mn ; j ++ ) r . push_back ( i ) ; } for ( i = 1 ; i <= m ; i ++ ) { int mn = 1000 ; for ( j = 1 ; j <= n ; j ++ ) mn = min ( mn , G [ j ] [ i ] ) ; for ( j = 1 ; j <= n ; j ++ ) G [ j ] [ i ] -= mn ; for ( j = 1 ; j <= mn ; j ++ ) c . push_back ( i ) ; } for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) { if ( G [ i ] [ j ] ) { cout << " -1\n " ; return 0 ; } G [ i ] [ j ] = T [ i ] [ j ] ; } vector < int > r1 , c1 ; for ( i = 1 ; i <= m ; i ++ ) { int mn = 1000 ; for ( j = 1 ; j <= n ; j ++ ) mn = min ( mn , G [ j ] [ i ] ) ; for ( j = 1 ; j <= n ; j ++ ) G [ j ] [ i ] -= mn ; for ( j = 1 ; j <= mn ; j ++ ) c1 . push_back ( i ) ; } for ( i = 1 ; i <= n ; i ++ ) { int mn = 1000 ; for ( j = 1 ; j <= m ; j ++ ) mn = min ( mn , G [ i ] [ j ] ) ; for ( j = 1 ; j <= m ; j ++ ) G [ i ] [ j ] -= mn ; for ( j = 1 ; j <= mn ; j ++ ) r1 . push_back ( i ) ; } if ( r . size ( ) + c . size ( ) > r1 . size ( ) + c1 . size ( ) ) { r = r1 ; c = c1 ; } cout << r . size ( ) + c . size ( ) << " \n " ; for ( i = 0 ; i < r . size ( ) ; i ++ ) { cout << " row  " ; cout << r [ i ] << " \n " ; } for ( i = 0 ; i < c . size ( ) ; i ++ ) { cout << " col  " ; cout << c [ i ] << " \n " ; } return 0 ; }
TAB0 a is a new array of integers with 105 elements ; TAB1 declare integer variable n ; TAB1 read variable n from the input ; TAB1 set a [ 0 ] to 0 and a [ n + 1 ] to 1001 ; TAB1 create integers maxl = 0 and l = - 1 ; TAB1 in a loop , change i from 1 to n inclusive , reading a [ i ] from the user input on each loop ; TAB1 for i from 1 to n + 1 inclusive incrementing i ; TAB2 if a [ i ] is equal to a [ i - 1 ] + 1 ; TAB3 increment l ; TAB2 else ; TAB3 change the value of maxl to max of maxl and l ; TAB3 set l to - 1 ; TAB1 change maxl to max of maxl and l ; TAB1 print maxl to the standard output ;	int a [ 105 ] ; int main ( ) { int n ; cin >> n ; a [ 0 ] = 0 , a [ n + 1 ] = 1001 ; int l = - 1 , maxl = 0 ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { if ( a [ i ] == a [ i - 1 ] + 1 ) l ++ ; else { maxl = max ( maxl , l ) ; l = - 1 ; } } maxl = max ( maxl , l ) ; cout << maxl << endl ; return 0 ; }
TAB1 new integer variable n ; TAB1 read variable n from the input ; TAB1 create new vector of strings s with size n ; TAB1 in a for loop , read n elements into s ; TAB1 define new string candidates with value " RGBYW12345 " ; TAB1 create a map from characters to integers called pos ; TAB1 for i = 0 to length of candidates exclusive , change pos [ candidates [ i ] ] to i ; TAB1 declare new integer variable m = 10 ; TAB1 create integer variable with name res with value 8 ; TAB1 for mask from 0 to 1 < < m exclusive ; TAB2 declare integer variable with name bits = 0 ; TAB2 for i from 0 to m exclusive incrementing i ; TAB3 increment bits if mask & ( 1 < < i ) ! = 0 ; TAB2 if bits > = res , go to the start of the loop ; TAB2 create vector of booleans used with n elements filled with false ; TAB2 for i from 0 to n exclusive ; TAB3 create new integer u with value pos [ s [ i ] [ 0 ] ] ; TAB3 declare integer variable with name v and value pos [ s [ i ] [ 1 ] ] ; TAB3 if mask & ( 1 < < u ) and mask & ( 1 < < v ) are both ! = 0 , change the value of used [ i ] to true ; TAB2 start infinite loop ; TAB3 new boolean updates with value false ; TAB3 for i from 0 to m exclusive ; TAB4 if mask & ( 1 < < i ) ! = 0 ; TAB5 t is a new set of strings ; TAB5 for integer j = 0 to n exclusive incrementing j ; TAB6 if candidates [ i ] = s [ j ] [ i / 5 ] and used [ j ] is false , add s [ j ] into t ; TAB5 if length of t < = 1 ; TAB6 move new set iterator it through the set t ; TAB7 for j from 0 to n exclusive incrementing j ; TAB8 if s [ j ] = value at it and used [ j ] is false ; TAB9 assign true to used [ j ] ; TAB9 set updates to true ; TAB3 if updates is false , break the loop ; TAB2 create new set of unique strings called t ; TAB2 start for loop from i = 0 to n exclusive incrementing i ; TAB3 if used [ i ] is false , insert s [ i ] into t ; TAB2 if length of t < = 1 , assign the new value = min of res and bits to res ; TAB1 print res ;	int main ( ) { int n ; cin >> n ; vector < string > s ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> s [ i ] ; } string candidates = " RGBYW12345 " ; map < char , int > pos ; for ( int i = 0 ; i < candidates . size ( ) ; ++ i ) { pos [ candidates [ i ] ] = i ; } int m = 10 ; int res = 8 ; for ( int mask = 0 ; mask < ( 1 << m ) ; ++ mask ) { int bits = 0 ; for ( int i = 0 ; i < m ; ++ i ) { if ( mask & ( 1 << i ) ) { ++ bits ; } } if ( bits >= res ) { continue ; } vector < bool > used ( n , false ) ; for ( int i = 0 ; i < n ; ++ i ) { int u = pos [ s [ i ] [ 0 ] ] ; int v = pos [ s [ i ] [ 1 ] ] ; if ( ( mask & ( 1 << u ) ) && ( mask & ( 1 << v ) ) ) { used [ i ] = true ; } } while ( true ) { bool updates = false ; for ( int i = 0 ; i < m ; ++ i ) { if ( mask & ( 1 << i ) ) { set < string > t ; for ( int j = 0 ; j < n ; ++ j ) { if ( candidates [ i ] == s [ j ] [ i / 5 ] && ! used [ j ] ) { t . insert ( s [ j ] ) ; } } if ( t . size ( ) <= 1 ) { for ( set < string > :: iterator it = t . begin ( ) ; it != t . end ( ) ; ++ it ) { for ( int j = 0 ; j < n ; ++ j ) { if ( s [ j ] == * it && ! used [ j ] ) { used [ j ] = true ; updates = true ; } } } } } } if ( ! updates ) { break ; } } set < string > t ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! used [ i ] ) { t . insert ( s [ i ] ) ; } } if ( t . size ( ) <= 1 ) { res = min ( res , bits ) ; } } cout << res << endl ; return 0 ; }
TAB0 create int array a of size 10000000 ; TAB1 create string s ; TAB1 create ints i , j , m , n = 0 , t = 0 , and k = 0 ; TAB1 read s ; TAB1 for i = 0 to the length of s exclusive ; TAB2 if s [ i ] is equal to ' ( ' ; TAB3 increment t ; TAB2 else if s [ i ] is equal to ' ) ' ; TAB3 reduce t by 1 ; TAB2 else ; TAB3 reduce t by 1 ; TAB3 increment k ; TAB2 if t is less than 0 ; TAB3 print " - 1 " ; TAB1 create int p = 0 ; TAB1 for i = 0 to the length of s exclusive ; TAB2 if s [ i ] is equal to ' # ' ; TAB3 increment n ; TAB3 if n is equal to k , set p to p - t ; TAB3 set p to p - 1 ; TAB2 else if s [ i ] is equal to ' ( ' ; TAB3 increment p ; TAB2 else ; TAB3 reduce p by 1 ; TAB2 if p is less than 0 ; TAB3 print " - 1 " ; TAB1 for i = 1 to k - 1 , print 1 ; TAB1 print t + 1 ;	int a [ 10000000 ] ; int main ( ) { string s ; int i , j , m , n = 0 , t = 0 , k = 0 ; cin >> s ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) t ++ ; else if ( s [ i ] == ' ) ' ) t -- ; else { t -- ; k ++ ; } if ( t < 0 ) { cout << " -1 " << endl ; return 0 ; } } int p = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' # ' ) { n ++ ; if ( n == k ) p -= t ; p -= 1 ; } else if ( s [ i ] == ' ( ' ) p ++ ; else p -- ; if ( p < 0 ) { cout << " -1 " << endl ; return 0 ; } } for ( i = 1 ; i <= k - 1 ; i ++ ) { cout << 1 << endl ; } cout << t + 1 << endl ; return 0 ; }
TAB1 t = string ; TAB1 loop while reading t ; TAB2 h = string with h = substring of t from position 0 to 2 ; TAB2 m = string with m = substring of t from position 3 to 5 ; TAB2 if h is not " 05 " and h is not " 06 " and h is not " 07 " and h is not " 08 " and h is not " 09 " ; TAB3 if h is not " 15 " and h is not " 16 " and h is not " 17 " and h is not " 18 " and h is not " 19 " ; TAB4 if h is " 23 " and m > = " 32 " ; TAB5 print " 00 : 00 " ; TAB4 else ; TAB5 s = string with s = " 00 " ; TAB5 set s [ 0 ] to h [ 1 ] ; TAB5 set s [ 1 ] to h [ 0 ] ; TAB5 if m > = s ; TAB6 set h [ 1 ] to h [ 1 ] + 1 ; TAB6 set s [ 0 ] to h [ 1 ] ; TAB5 print h then " : " then s ; TAB3 else ; TAB4 if h is " 15 " and m < " 51 " ; TAB5 print " 15 : 51 " ; TAB4 else ; TAB5 print " 20 : 02 " ; TAB2 else ; TAB3 if h is " 05 " and m < " 50 " ; TAB4 print " 05 : 50 " ; TAB3 else ; TAB4 print " 10 : 01 " ;	int main ( ) { string t ; while ( cin >> t ) { string h = t . substr ( 0 , 2 ) ; string m = t . substr ( 3 , 2 ) ; if ( h != " 05 " && h != " 06 " && h != " 07 " && h != " 08 " && h != " 09 " ) { if ( h != " 15 " && h != " 16 " && h != " 17 " && h != " 18 " && h != " 19 " ) { if ( h == " 23 " && m >= " 32 " ) cout << " 00:00 " << ' \n ' ; else { string s = " 00 " ; s [ 0 ] = h [ 1 ] ; s [ 1 ] = h [ 0 ] ; if ( m >= s ) { h [ 1 ] = h [ 1 ] + 1 ; s [ 0 ] = h [ 1 ] ; } cout << h << " : " << s << ' \n ' ; } } else { if ( h == " 15 " && m < " 51 " ) cout << " 15:51 " << ' \n ' ; else cout << " 20:02 " << ' \n ' ; } } else { if ( h == " 05 " && m < " 50 " ) cout << " 05:50 " << ' \n ' ; else cout << " 10:01 " << ' \n ' ; } } return 0 ; }
TAB0 declare constant integer Maxn = 1e5 + 100 ; TAB0 declare integers n , m , integer array a size Maxn ; TAB0 declare boolean array mark size 2 by Maxn ; TAB0 declare integer vector array nei size 2 by Maxn ; TAB0 declare dfs with integers x , v as arguments , returning void ; TAB1 for i = 0 to integer casted size of nei [ x ] [ v ] exclusive ; TAB2 declare integer u = nei [ x ] [ v ] [ i ] ; TAB2 if not mark [ x ] [ u ] ; TAB3 let mark [ x ] [ u ] be true ; TAB3 if x is 0 or a [ u ] is not 1 , run dfs with x , u as arguments ; TAB1 read n and m ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 for i = 0 , u , v to i is less than m , incrementing i ; TAB2 read u and v ; TAB2 add v - 1 to end of nei [ 0 ] [ u - 1 ] ; TAB2 add u - 1 to end of nei [ 1 ] [ v - 1 ] ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is 1 and not mark [ 0 ] [ i ] ; TAB3 let mark [ 0 ] [ i ] be true , run dfs with 0 , i as arguments ; TAB2 else if a [ i ] is 2 and not mark [ 1 ] [ i ] ; TAB3 let mark [ 1 ] [ i ] be true , run dfs ( 1 , i ) ; TAB1 for i = 0 to n exclusive ; TAB2 if mark [ 0 ] [ i ] and mark [ 1 ] [ i ] ; TAB3 print 1 and newline ; TAB2 else ; TAB3 print 0 and newline ;	const int Maxn = 1e5 + 100 ; int n , m , a [ Maxn ] ; bool mark [ 2 ] [ Maxn ] ; vector < int > nei [ 2 ] [ Maxn ] ; void dfs ( int x , int v ) { for ( int i = 0 ; i < ( int ) nei [ x ] [ v ] . size ( ) ; i ++ ) { int u = nei [ x ] [ v ] [ i ] ; if ( ! mark [ x ] [ u ] ) { mark [ x ] [ u ] = true ; if ( x == 0 || a [ u ] != 1 ) dfs ( x , u ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 0 , u , v ; i < m ; i ++ ) { cin >> u >> v ; nei [ 0 ] [ u - 1 ] . push_back ( v - 1 ) ; nei [ 1 ] [ v - 1 ] . push_back ( u - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 && ! mark [ 0 ] [ i ] ) mark [ 0 ] [ i ] = true , dfs ( 0 , i ) ; else if ( a [ i ] == 2 && ! mark [ 1 ] [ i ] ) mark [ 1 ] [ i ] = true , dfs ( 1 , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mark [ 0 ] [ i ] && mark [ 1 ] [ i ] ) cout << 1 << endl ; else cout << 0 << endl ; } }
TAB0 let a1 , a2 , n , k , second , ans , ans1 be long integers with second = 0 , ans = 0 ; TAB0 let vector < pair < long long , pair < long long , long long > > > be a vector by name h ; TAB0 let read be a void function ; TAB1 read n ; TAB1 for integer i = 0 , x , y , m , i is less than n , increment i by 1 ; TAB2 read k ; TAB2 increment second by k ; TAB2 read a1 ; TAB2 the long integer value of t = a1 ; TAB2 read x , y , m ; TAB2 push_back the value of ( make_pair ( 0 , make_pair ( a1 , i + 1 ) ) ) into h ; TAB2 ans1 is equal to 0 ; TAB2 for integer j = 1 , j is less than k , increment j by 1 ; TAB3 a2 is equal to ( a1 * x + y ) modulo m ; TAB3 if a2 is less than a1 , increment ans1 by 1 ; TAB3 a1 is equal to a2 ; TAB3 t is equal to maximum of t and a1 ; TAB3 if length of h < = 200000 , push_back ( make_pair ( ans1 , make_pair ( a1 , i + 1 ) ) ) into h ; TAB2 ans is equal to maximum of ans and ans1 ; TAB1 sort the values of h from beginning to end ; TAB1 print ans and newline ; TAB1 if second < = 200000 ; TAB2 for i = 0 to second exclusive , print h [ i ] . second . first and space and h [ i ] . second . second and newline ; TAB1 call the read function ;	long long a1 , a2 , n , k , second = 0 , ans = 0 , ans1 ; vector < pair < long long , pair < long long , long long >> > h ; void read ( void ) { cin >> n ; for ( int i = 0 , x , y , m ; i < n ; ++ i ) { cin >> k ; second += k ; cin >> a1 ; long long t = a1 ; cin >> x >> y >> m ; h . push_back ( make_pair ( 0 , make_pair ( a1 , i + 1 ) ) ) ; ans1 = 0 ; for ( int j = 1 ; j < k ; ++ j ) { a2 = ( a1 * x + y ) % m ; if ( a2 < a1 ) ans1 ++ ; a1 = a2 ; t = max ( t , a1 ) ; if ( h . size ( ) <= 200000 ) h . push_back ( make_pair ( ans1 , make_pair ( a1 , i + 1 ) ) ) ; } ans = max ( ans , ans1 ) ; } sort ( h . begin ( ) , h . end ( ) ) ; cout << ans << " \n " ; if ( second <= 200000 ) for ( int i = 0 ; i < second ; ++ i ) cout << h [ i ] . second . first << "   " << h [ i ] . second . second << " \n " ; } int main ( ) { read ( ) ; return 0 ; }
TAB1 declare integers n and k ; TAB1 read input to n and k ; TAB1 create long long vector a with n elements filled with 0 ; TAB1 for i from 0 to n exclusive , read input to a [ i ] ; TAB1 sort a ; TAB1 create set of long long called ex ; TAB1 loop i from 0 to n exclusive ; TAB2 if there is no a [ i ] in ex ; TAB3 declare long long b = a [ i ] * k ; TAB3 if b ! = a [ i ] , insert b into ex ; TAB1 create int exCount = 0 ; TAB1 for i from 0 to n exclusive ; TAB2 if there is no a [ i ] in ex , increment exCount ; TAB1 print n - exCount ;	int main ( ) { int n , k ; cin >> n >> k ; vector < long long > a ( n , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; sort ( a . begin ( ) , a . end ( ) ) ; set < long long > ex ; for ( int i = 0 ; i < n ; i ++ ) { if ( ex . find ( a [ i ] ) == ex . end ( ) ) { long long b = a [ i ] * k ; if ( b != a [ i ] ) ex . insert ( b ) ; } } int exCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ex . find ( a [ i ] ) != ex . end ( ) ) { exCount ++ ; } } cout << n - exCount << endl ; return 0 ; }
TAB0 create string s ; TAB0 declare int variable m ; TAB1 read input to s ; TAB1 declare ints l and r = 0 ; TAB1 for i from 0 to length of s exclusive ; TAB2 if s [ i ] = ' ( ' ; TAB3 increment l and r by one ; TAB2 else ; TAB3 decrement l by one ; TAB3 if r is greater than 0 , decrement r ; TAB3 if l is less than 0 ; TAB4 print - 1 ; TAB3 if s [ i ] = ' # ' , change r to 0 and increment m ; TAB1 if r ! = 0 ; TAB2 print - 1 ; TAB1 loop i from 0 to m - 1 exclusive , print 1 ; TAB1 print l + 1 ;	string s ; int m ; int main ( ) { cin >> s ; int l = 0 , r = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { l ++ , r ++ ; } else { l -- ; if ( r > 0 ) r -- ; if ( l < 0 ) { cout << - 1 << endl ; return 0 ; } if ( s [ i ] == ' # ' ) { r = 0 , m ++ ; } } } if ( r != 0 ) { cout << - 1 << endl ; return 0 ; } for ( int i = 0 ; i < m - 1 ; i ++ ) { cout << 1 << endl ; } cout << l + 1 << endl ; }
TAB0 let a be an int array of length 1010 ; TAB1 let N , K be ints ; TAB1 read N , K ; TAB1 for i = 1 to N * 2 + 1 inclusive the read a [ i ] ; TAB1 let int k = 0 ; TAB1 for i = 2 to N * 2 inclusive ; TAB2 if a [ i ] > a [ i - 1 ] + 1 and a [ i ] > a [ i + 1 ] + 1 ; TAB3 decrement a at i ; TAB3 increment k ; TAB3 if k is same as K , exit loop ; TAB1 for i = 1 to N * 2 , print a at i and space ; TAB1 print a [ N * 2 + 1 ] ;	int a [ 1010 ] ; int main ( ) { int N , K ; cin >> N >> K ; for ( int i = 1 ; i <= N * 2 + 1 ; i ++ ) { cin >> a [ i ] ; } int k = 0 ; for ( int i = 2 ; i <= N * 2 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] + 1 && a [ i ] > a [ i + 1 ] + 1 ) { a [ i ] -- ; k ++ ; if ( k == K ) break ; } } for ( int i = 1 ; i <= N * 2 ; i ++ ) { cout << a [ i ] << "   " ; } cout << a [ N * 2 + 1 ] << endl ; return 0 ; }
TAB1 create 2d long long array a with size 4 by 4 ; TAB1 for i = 0 to 4 exclusive ; TAB2 for j = 0 to 4 exclusive , print a [ i ] [ j ] ; TAB1 for i = 0 to 4 exclusive ; TAB2 for j = 0 to 3 exclusive ; TAB3 if a [ i ] [ j ] is 1 and a [ i ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB1 for i = 0 to 4 exclusive ; TAB2 if a [ i ] [ 1 ] is 1 ; TAB3 if i is greater than or equal to 2 and a [ i - 2 ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB3 if i is less than 2 and a [ i + 2 ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB1 for i = 0 to 4 exclusive ; TAB2 if a [ i ] [ 0 ] is 1 ; TAB3 if i is greater than 1 and a [ i - 1 ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB3 if i is 0 and a [ 3 ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB1 for i = 0 to 4 exclusive ; TAB2 if a [ i ] [ 2 ] is 1 ; TAB3 if i is less than 3 and a [ i + 1 ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB3 if i is 3 and a [ 0 ] [ 3 ] is 1 ; TAB4 print " YES " ; TAB5 print " \ n " ; TAB1 print " NO " ; TAB2 print " \ n " ;	int main ( ) { long long a [ 4 ] [ 4 ] ; for ( long long i = ( 0 ) ; i < ( 4 ) ; i ++ ) for ( long long j = ( 0 ) ; j < ( 4 ) ; j ++ ) cin >> a [ i ] [ j ] ; for ( long long i = ( 0 ) ; i < ( 4 ) ; i ++ ) { for ( long long j = ( 0 ) ; j < ( 3 ) ; j ++ ) { if ( a [ i ] [ j ] == 1 && a [ i ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } } } for ( long long i = ( 0 ) ; i < ( 4 ) ; i ++ ) { if ( a [ i ] [ 1 ] == 1 ) { if ( i >= 2 && a [ i - 2 ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } if ( i < 2 && a [ i + 2 ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } } } for ( long long i = ( 0 ) ; i < ( 4 ) ; i ++ ) { if ( a [ i ] [ 0 ] == 1 ) { if ( i >= 1 && a [ i - 1 ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } if ( i == 0 && a [ 3 ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } } } for ( long long i = ( 0 ) ; i < ( 4 ) ; i ++ ) { if ( a [ i ] [ 2 ] == 1 ) { if ( i < 3 && a [ i + 1 ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } if ( i == 3 && a [ 0 ] [ 3 ] == 1 ) { cout << " YES " << " \n " ; return 0 ; } } } cout << " NO " << " \n " ; }
TAB0 s = 1000100 ; TAB0 b = pointer to int ; TAB1 n = int ; TAB1 b = array of s int ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 a = int ; TAB2 read a ; TAB2 increment b [ a ] ; TAB1 ans = 0 ; TAB1 for i = 0 to s - 1 exclusive ; TAB2 add b [ i ] / 2 to b [ i + 1 ] ; TAB2 b [ i ] = b [ i ] modulo 2 ; TAB2 add b [ i ] to ans ; TAB1 print ans ;	const int s = 1000100 ; int * b ; int main ( ) { int n ; b = new int [ s ] ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int a ; cin >> a ; b [ a ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < s - 1 ; i ++ ) { b [ i + 1 ] += b [ i ] / 2 ; b [ i ] = b [ i ] % 2 ; ans += b [ i ] ; } cout << ans << endl ; return 0 ; }
TAB0 create constant integer N = 1e5 + 7 ; TAB0 create long long arrays a and dp , both of size N ; TAB0 create set < long long > x and y ; TAB1 create integer aux ; TAB1 read aux ; TAB1 for i = 1 to aux inclusive , read a [ i ] ; TAB1 if aux equals 2 ; TAB2 print abs of a [ 1 ] - a [ 2 ] ; TAB1 for i = 1 to aux exclusive ; TAB2 create long long x = abs of a [ i ] - a [ i + 1 ] ; TAB2 if i bitwise and 1 ; TAB3 set dp [ i ] to dp [ i - 1 ] + x ; TAB2 else ; TAB3 set dp [ i ] to dp [ i - 1 ] - x ; TAB1 insert dp [ 1 ] into x ; TAB1 insert dp [ 2 ] into y ; TAB1 create long long result = max of dp [ 1 ] and dp [ 2 ] ; TAB1 set result to max of result and abs of a [ 2 ] - a [ 3 ] ; TAB1 for i = 3 to aux exclusive ; TAB2 set result to max of result and dp [ i ] ; TAB2 set result to max of result and dp [ i ] - first element of y ; TAB2 set result to max of result and - ( dp [ i ] - last element of x ) ; TAB2 if i bitwise and 1 ; TAB3 insert dp [ i ] into x ; TAB2 else ; TAB3 insert dp [ i ] into y ; TAB1 print result ;	const int N = 1e5 + 7 ; long long a [ N ] , dp [ N ] ; set < long long > x , y ; int main ( ) { int aux ; cin >> aux ; for ( int i = 1 ; i <= aux ; i ++ ) { cin >> a [ i ] ; } if ( aux == 2 ) { cout << abs ( a [ 1 ] - a [ 2 ] ) << endl ; return 0 ; } for ( int i = 1 ; i < aux ; i ++ ) { long long x = abs ( a [ i ] - a [ i + 1 ] ) ; if ( i & 1 ) dp [ i ] = dp [ i - 1 ] + x ; else dp [ i ] = dp [ i - 1 ] - x ; } x . insert ( dp [ 1 ] ) ; y . insert ( dp [ 2 ] ) ; long long result = max ( dp [ 1 ] , dp [ 2 ] ) ; result = max ( result , abs ( a [ 2 ] - a [ 3 ] ) ) ; for ( int i = 3 ; i < aux ; i ++ ) { result = max ( result , dp [ i ] ) ; result = max ( result , dp [ i ] - * y . begin ( ) ) ; result = max ( result , - ( dp [ i ] - * -- x . end ( ) ) ) ; if ( i & 1 ) { x . insert ( dp [ i ] ) ; } else { y . insert ( dp [ i ] ) ; } } cout << result << endl ; }
TAB0 in bool function checkprime taking n = long long ; TAB1 if n = 1 then return false ; TAB1 i = 2 = long long ; TAB1 while i ^ 2 < = n ; TAB2 if n mod i = 0 then return false ; TAB2 increment i ; TAB1 return true ; TAB1 n = long long ; TAB1 read n ; TAB1 if n is odd and n isn ' t 1 ; TAB2 print 1 ; TAB1 else ; TAB2 for long long i = 1 , increment i ; TAB3 if checkprime of n * i + 1 = false ; TAB4 print i ; TAB4 exit loop ;	bool checkprime ( long long n ) { if ( n == 1 ) { return false ; } long long i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { return false ; } i += 1 ; } return true ; } int main ( ) { long long n ; cin >> n ; if ( n % 2 != 0 && n != 1 ) cout << 1 << endl ; else { for ( long long i = 1 ; ; i ++ ) { if ( ! checkprime ( n * i + 1 ) ) { cout << i << endl ; break ; } } } }
TAB1 create long long n , m and k ; TAB1 read n , m and k ; TAB1 if n - 1 + m - 1 less than k ; TAB2 print - 1 ; TAB1 if n less than m , swal n and m ; TAB1 set maxx to 0 ; TAB1 assign max of maxx and n / ( k + 1 ) * m to maxx ; TAB1 maxx = max ( maxx , m / ( k + 1 ) * n ) ; TAB1 if maxx is different from 0 ; TAB2 print maxx ; TAB1 k = k - ( n - 1 ) ; TAB1 print m / k + 1 and a newline ;	int main ( ) { long long n , m , k ; cin >> n >> m >> k ; if ( n - 1 + m - 1 < k ) { cout << - 1 << endl ; return 0 ; } if ( n < m ) swap ( n , m ) ; long long maxx = 0 ; maxx = max ( maxx , n / ( k + 1 ) * m ) ; maxx = max ( maxx , m / ( k + 1 ) * n ) ; if ( maxx != 0 ) { cout << maxx << endl ; return 0 ; } k = k - ( n - 1 ) ; cout << m / ( k + 1 ) << endl ; return 0 ; }
TAB0 i , n , j , s1 , s2 , r = long long with s1 = 0 and s2 = 0 and r = 0 ; TAB0 a = long long and long long pair array of size 107 ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read a [ i ] . first then a [ i ] . second ; TAB2 if a [ i ] . first is greater than 0 ; TAB3 increment s1 ; TAB2 else ; TAB3 increment s2 ; TAB1 if s1 is s2 ; TAB2 for i = 1 to n inclusive increment r by a [ i ] . second ; TAB2 print r ; TAB1 if s1 is greater than s2 ; TAB2 sort a from position 1 to position n + 1 ; TAB2 for i = 1 to s2 inclusive increment r by a [ i ] . second ; TAB2 for i = s2 + 1 to ( 2 * s2 ) + 1 inclusive increment r by a [ i ] . second ; TAB2 print r ; TAB1 if s1 is less than s2 ; TAB2 sort a from position 1 to position n + 1 ; TAB2 for i = s2 to s2 - s1 inclusive decrementing i increment r by a [ i ] . second ; TAB2 for i = s2 + 1 to s2 + s1 increment r by a [ i ] . second ; TAB2 print r ;	long long i , n , j , s1 = 0 , s2 = 0 , r = 0 ; pair < long long , long long > a [ 107 ] ; int main ( ) { cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] . first >> a [ i ] . second ; if ( a [ i ] . first > 0 ) s1 ++ ; else s2 ++ ; } if ( s1 == s2 ) { for ( i = 1 ; i <= n ; i ++ ) r += a [ i ] . second ; cout << r << endl ; } if ( s1 > s2 ) { sort ( a + 1 , a + n + 1 ) ; for ( i = 1 ; i <= s2 ; i ++ ) r += a [ i ] . second ; for ( i = s2 + 1 ; i <= ( 2 * s2 ) + 1 ; i ++ ) r += a [ i ] . second ; cout << r << endl ; } if ( s1 < s2 ) { sort ( a + 1 , a + n + 1 ) ; for ( i = s2 ; i >= s2 - ( s1 ) ; i -- ) r += a [ i ] . second ; for ( i = s2 + 1 ; i <= ( s2 + s1 ) ; i ++ ) r += a [ i ] . second ; cout << r << endl ; } return 0 ; }
TAB0 n , m , k = long long and a = long long array of size 10004 ; TAB1 read n then m then k ; TAB1 read n values into a ; TAB1 if n is even ; TAB2 print " 0 " ; TAB1 x = long long with x = min of a [ 0 ] , a [ n - 1 ] ; TAB1 if n is 1 ; TAB2 print min of x , m * k ; TAB1 for i = 0 to n incrementing i by 2 set x to min of x , a [ i ] ; TAB1 onerun = long long with onerun = ( n + 1 ) / 2 ; TAB1 set onerun to m / onerun ; TAB1 ans = long long with ans = min of x , onerun * k ; TAB1 print ans ;	long long n , m , k , a [ 10004 ] ; int main ( ) { cin >> n >> m >> k ; for ( long long i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; if ( n % 2 == 0 ) { cout << " 0\n " ; return 0 ; } long long x = min ( a [ 0 ] , a [ n - 1 ] ) ; if ( n == 1 ) { cout << min ( x , m * k ) << endl ; return 0 ; } for ( long long i = 0 ; i < n ; i += 2 ) { x = min ( x , a [ i ] ) ; } long long onerun = ( n + 1 ) / 2 ; onerun = m / onerun ; long long ans = min ( x , onerun * k ) ; cout << ans << endl ; return 0 ; }
TAB0 primeFactures = long long vector ; TAB0 in void function f that takes long long q ; TAB1 while q is even ; TAB2 push back 2 in primeFactures ; TAB2 if the size of primeFactures > 2 then end function ; TAB2 divide q by 2 ; TAB1 for long long i = 3 , until i squared < = q , increment i by 2 ; TAB2 while q mod i is 0 ; TAB3 tail insert i into primeFactures ; TAB3 if the size of primeFacture > 2 then return ; TAB3 divide q by i ; TAB1 if q > 1 then push back q into primeFactures ; TAB1 let q = long long ; TAB1 read q ; TAB1 call f of q ; TAB1 if the size of primeFactures < 1 inclusive ; TAB2 print 1 and new line and 0 and new line ; TAB1 else if the size of primeFactures > 2 ; TAB2 print 1 and new line and primeFactures [ 0 ] * primeFactures [ 1 ] and new line ; TAB1 else ; TAB2 print 2 and new line ;	vector < long long > primeFactures ; void f ( long long q ) { while ( q % 2 == 0 ) { primeFactures . push_back ( 2 ) ; if ( primeFactures . size ( ) > 2 ) return ; q /= 2 ; } for ( long long i = 3 ; i * i <= q ; i += 2 ) { while ( q % i == 0 ) { primeFactures . push_back ( i ) ; if ( primeFactures . size ( ) > 2 ) return ; q /= i ; } } if ( q > 1 ) primeFactures . push_back ( q ) ; } int main ( ) { long long q ; cin >> q ; f ( q ) ; if ( primeFactures . size ( ) <= 1 ) { cout << " 1\n0\n " ; return 0 ; } else if ( primeFactures . size ( ) > 2 ) { cout << " 1\n " << ( primeFactures [ 0 ] * primeFactures [ 1 ] ) << endl ; } else { cout << " 2\n " ; } return 0 ; }
TAB1 c = character ; TAB1 n , i , t , e = integers set to 0 ; TAB1 while reading c ; TAB2 if c is ' n ' ; TAB3 increment n by 1 ; TAB2 else if c is ' i ' ; TAB3 increment i by 1 ; TAB2 else if c is ' t ' ; TAB3 increment t by 1 ; TAB2 else if c is ' e ' ; TAB3 increment e by 1 ; TAB1 cont = integer set to 0 ; TAB1 for k = i to k to 0 , decrementing k by 1 ; TAB2 if n > = 2 * k + 1 and t > = k and e > = 3 * k , increment cont by 1 ; TAB1 print cont ;	int main ( ) { char c ; int n = 0 , i = 0 , t = 0 , e = 0 ; while ( cin >> c ) { if ( c == ' n ' ) { n ++ ; } else if ( c == ' i ' ) { i ++ ; } else if ( c == ' t ' ) { t ++ ; } else if ( c == ' e ' ) { e ++ ; } } int cont = 0 ; for ( int k = i ; k > 0 ; k -- ) { if ( n >= 2 * k + 1 && t >= k && e >= 3 * k ) { cont ++ ; } } cout << cont << endl ; return 0 ; }
TAB0 declare map from integer to integer m ; TAB1 decalre integers n , x , ans = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read x ; TAB2 increment m [ x ] ; TAB1 declare map iterator from integer to integer it ; TAB1 for it = beginning of m to it is not end of m , incrementing it , let ans be maximum of ans and second element of it ; TAB1 print n - ans and newline ;	map < int , int > m ; int main ( ) { int n , x , ans = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; m [ x ] ++ ; } map < int , int > :: iterator it ; for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) ans = max ( ans , it -> second ) ; cout << n - ans << endl ; return 0 ; }
TAB0 a is an array of int int pairs with 105 elements ; TAB1 declare integer variables n and count with count = 0 ; TAB1 read n ; TAB1 loop i from 0 to n exclusive ; TAB2 read from the input to a [ i ] . first and a [ i ] . second ; TAB2 if a [ i ] . first is less than 0 , increment count ; TAB1 sort a ; TAB1 declare int sum = 0 ; TAB1 if 2 * count is less than n ; TAB2 loop i from 0 to min of count * 2 + 1 and n exclusive , increasing sum by a [ i ] . second ; TAB1 else ; TAB2 for i from max of count * 2 - n - 1 and 0 to n exclusive , add a [ i ] . second to sum ; TAB1 print sum ;	pair < int , int > a [ 105 ] ; int main ( ) { int n , count = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] . first >> a [ i ] . second ; if ( a [ i ] . first < 0 ) count ++ ; } sort ( a , a + n ) ; int sum = 0 ; if ( 2 * count < n ) { for ( int i = 0 ; i < min ( count * 2 + 1 , n ) ; i ++ ) sum += a [ i ] . second ; } else { for ( int i = max ( count * 2 - n - 1 , 0 ) ; i < n ; i ++ ) sum += a [ i ] . second ; } cout << sum << endl ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 l , a1 , b1 , c1 = 0 , i = long long , n = size of s ; TAB1 s1 = array of n char ; TAB1 for i = 0 to n exclusive ; TAB2 s1 [ i ] = s [ i ] ; TAB2 if s [ i ] is ' a ' ; TAB3 increment a1 ; TAB2 else if s1 [ i ] is ' b ' ; TAB3 increment b1 ; TAB2 else ; TAB3 increment c1 ; TAB1 sort s1 ; TAB1 for i = 0 to n exclusive ; TAB2 if s1 [ i ] = = s [ i ] increment l ; TAB1 if l is n ; TAB2 if c1 is a1 or b1 and a1 , b1 and c1 are not 0 ; TAB3 print YES ; TAB2 else ; TAB3 print NO ; TAB1 else ; TAB2 print NO ;	int main ( ) { string s ; cin >> s ; long long l = 0 , i , n = s . size ( ) , a1 = 0 , b1 = 0 , c1 = 0 ; char s1 [ n ] ; for ( i = 0 ; i < n ; i ++ ) { s1 [ i ] = s [ i ] ; if ( s [ i ] == ' a ' ) { a1 ++ ; } else if ( s [ i ] == ' b ' ) { b1 ++ ; } else { c1 ++ ; } } sort ( s1 , s1 + n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s [ i ] ) { l ++ ; } } if ( l == n ) { if ( ( c1 == a1 || c1 == b1 ) && a1 != 0 && b1 != 0 && c1 != 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } else { cout << " NO " << endl ; } return 0 ; }
TAB1 a , b , c , s1 , s2 , s3 , flag , i , flag1 and flag2 are long longs with s1 , s2 , s3 , flag , flag1 and flag2 = 0 ; TAB1 declare string s ; TAB1 read s from the input ; TAB1 declare new long long called n = length of s ; TAB1 in a for loop , change i from 0 to n exclusive ; TAB2 if s [ i ] is equal to ' a ' ; TAB3 if s2 and s3 are not 0 ; TAB4 assign 1 to flag ; TAB4 stop the loop ; TAB3 increment s1 ; TAB2 if s [ i ] is equal to ' b ' ; TAB3 if s1 = 0 or s3 ! = 0 ; TAB4 assign 1 to flag ; TAB4 break the loop ; TAB3 increment s2 by one ; TAB2 if s [ i ] is equal to ' c ' ; TAB3 if s1 = 0 or s2 is equal to 0 ; TAB4 assign 1 to flag ; TAB4 break the loop ; TAB3 increment s3 ; TAB1 if s1 or s2 = 0 , set flag to 1 ; TAB1 if ( s1 = s3 or s3 = s2 ) and flag = 0 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " to the standard output ;	int main ( ) { long long a , b , c , s1 = 0 , s2 = 0 , s3 = 0 , flag = 0 , i , flag1 = 0 , flag2 = 0 ; string s ; cin >> s ; long long n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) { if ( s2 != 0 || s3 != 0 ) { flag = 1 ; break ; } s1 ++ ; } if ( s [ i ] == ' b ' ) { if ( s1 == 0 || s3 != 0 ) { flag = 1 ; break ; } s2 ++ ; } if ( s [ i ] == ' c ' ) { if ( s1 == 0 || s2 == 0 ) { flag = 1 ; break ; } s3 ++ ; } } if ( s1 == 0 || s2 == 0 ) flag = 1 ; if ( ( s1 == s3 || s3 == s2 ) && flag == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 let n , s be integers ; TAB1 read n , s ; TAB1 let str be a empty string ; TAB1 for i = 0 to n exclusive , str = str + char ( ( int ) a + i modulo s ) ; TAB1 print str and newline ;	int main ( ) { int n , s ; cin >> n >> s ; string str = "  " ; for ( int i = 0 ; i < n ; i ++ ) { str += ( char ) ( ( int ) ' a ' + i % s ) ; } cout << str << endl ; }
TAB1 declare long long variables a , b , c , x and y ; TAB1 read user input to a , b and c ; TAB1 set x to the absolute value of a ; TAB1 change y to absolute value of b ; TAB1 if c - a - b is even and x + y < = c ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	int main ( ) { long long a , b , c , x , y ; cin >> a >> b >> c ; x = abs ( a ) ; y = abs ( b ) ; if ( ( c - a - b ) % 2 == 0 && x + y <= c ) { cout << " Yes " << endl ; } else cout << " No " << endl ; return 0 ; }
TAB1 let n be a long integer ; TAB1 let ans be a long integer ; TAB1 while read n ; TAB2 if n < = 2 ; TAB3 ans is equal to n ; TAB2 else if n & 1 ; TAB3 ans is equal to n * ( n - 1 ) * ( n - 2 ) ; TAB2 else do the following ; TAB3 if n modulo 3 is not equal to 0 ; TAB4 ans is equal to n * ( n - 1 ) * ( n - 3 ) ; TAB3 else do the following ; TAB4 ans is equal to ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; TAB2 print ans and newline ;	int main ( ) { long long n ; long long ans ; while ( cin >> n ) { if ( n <= 2 ) ans = n ; else if ( n & 1 ) ans = n * ( n - 1 ) * ( n - 2 ) ; else { if ( n % 3 != 0 ) ans = n * ( n - 1 ) * ( n - 3 ) ; else ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; } cout << ans << endl ; } }
TAB0 MAXINT = const integer with MAXINT = 2147483640 ; TAB0 MAXLL = const long long with MAXLL = 9223372036854775800LL ; TAB0 MAXN = const long long with MAXN = 1e6 ; TAB0 eps = const double with eps = 1e - 9 ; TAB0 mod = const long long with mod = 998244353 ; TAB0 dp = 3d const long long array of size [ 100006 ] [ 202 ] [ 2 ] , pref = 2d const long long array of size [ 300 ] [ 2 ] ; TAB0 n , a = long long with a = long long array of size MAXN ; TAB1 srand of time ( 0 ) ; TAB1 read n ; TAB1 for i = 1 to n , read a [ i ] ; TAB1 if a [ 1 ] is - 1 ; TAB2 for i = 1 to 200 , dp [ 1 ] [ j ] [ 0 ] = 1 ; TAB1 else ; TAB2 dp [ 1 ] [ a [ 1 ] ] [ 0 ] = 1 ; TAB1 for i = 2 to n ; TAB2 for j = 1 to 200 ; TAB3 ( pref [ j ] [ 1 ] = pref [ j - 1 ] [ 1 ] + dp [ i - 1 ] [ j ] [ 1 ] ) = ( pref [ j ] [ 1 ] = pref [ j - 1 ] [ 1 ] + dp [ i - 1 ] [ j ] [ 1 ] ) modulo mod ; TAB3 ( pref [ j ] [ 0 ] = pref [ j - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] [ 0 ] ) = ( pref [ j ] [ 0 ] = pref [ j - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] [ 0 ] ) modulo mod ; TAB2 if a [ i ] is - 1 ; TAB3 for cur = 1 to 200 ; TAB4 sum = long long with sum = 0 ; TAB4 ( sum = sum + ( pref [ 200 ] [ 1 ] - pref [ cur - 1 ] [ 1 ] + mod ) ) = ( sum = sum + ( pref [ 200 ] [ 1 ] - pref [ cur - 1 ] [ 1 ] + mod ) ) modulo mod ; TAB4 ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod ; TAB4 ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) = ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) modulo mod ; TAB4 sum = pref [ cur - 1 ] [ 1 ] + pref [ cur - 1 ] [ 0 ] ; TAB4 ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] sum ) = ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) modulo mod ; TAB2 else ; TAB3 sum = long long with sum = 0 ; TAB3 cur = long long with cur = a [ i ] ; TAB3 for j = cur to 200 , sum = sum + ( dp [ i - 1 ] [ j ] [ 1 ] ) = ( dp [ i - 1 ] [ j ] [ 1 ] ) modulo mod ; TAB3 ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod ; TAB3 ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) = ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) modulo mod ; TAB3 sum = 0 ; TAB3 for j = 1 to cur exclusive , sum = sum + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) = ( sum = sum + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) modulo mod ; TAB3 ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) = ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) modulo mod ; TAB1 ans = long long with ans = 0 ; TAB1 ( ans = ans + dp [ n ] [ i ] [ 1 ] ) = ( ans = ans + dp [ n ] [ i ] [ 1 ] ) modulo mod ; TAB1 print ans ;	const int MAXINT = 2147483640 ; const long long MAXLL = 9223372036854775800LL ; const long long MAXN = 1e6 ; const double eps = 1e-9 ; const long long mod = 998244353 ; long long dp [ 100006 ] [ 202 ] [ 2 ] , pref [ 300 ] [ 2 ] ; long long n , a [ MAXN ] ; int main ( ) { srand ( time ( 0 ) ) ; cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) cin >> a [ i ] ; if ( a [ 1 ] == - 1 ) for ( int j = 1 ; j <= 200 ; ++ j ) dp [ 1 ] [ j ] [ 0 ] = 1 ; else dp [ 1 ] [ a [ 1 ] ] [ 0 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= 200 ; ++ j ) { ( pref [ j ] [ 1 ] = pref [ j - 1 ] [ 1 ] + dp [ i - 1 ] [ j ] [ 1 ] ) %= mod ; ( pref [ j ] [ 0 ] = pref [ j - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] [ 0 ] ) %= mod ; } if ( a [ i ] == - 1 ) { for ( int cur = 1 ; cur <= 200 ; ++ cur ) { long long sum = 0 ; ( sum += ( pref [ 200 ] [ 1 ] - pref [ cur - 1 ] [ 1 ] + mod ) ) %= mod ; ( sum += dp [ i - 1 ] [ cur ] [ 0 ] ) %= mod ; ( dp [ i ] [ cur ] [ 1 ] += sum ) %= mod ; sum = pref [ cur - 1 ] [ 1 ] + pref [ cur - 1 ] [ 0 ] ; ( dp [ i ] [ cur ] [ 0 ] += sum ) %= mod ; } } else { long long sum = 0 ; long long cur = a [ i ] ; for ( int j = cur ; j <= 200 ; ++ j ) sum += ( dp [ i - 1 ] [ j ] [ 1 ] ) %= mod ; ( sum += dp [ i - 1 ] [ cur ] [ 0 ] ) %= mod ; ( dp [ i ] [ cur ] [ 1 ] += sum ) %= mod ; sum = 0 ; for ( int j = 1 ; j < cur ; ++ j ) ( sum += dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) %= mod ; ( dp [ i ] [ cur ] [ 0 ] += sum ) %= mod ; } } long long ans = 0 ; for ( int i = 1 ; i <= 200 ; ++ i ) ( ans += dp [ n ] [ i ] [ 1 ] ) %= mod ; cout << ans << " \n " ; return 0 ; }
TAB0 m1 is a map of long long int to long long it ; TAB0 itr is a map iterator ; TAB0 declare an array of bools visited with 105 elements filled with false ; TAB0 create an array of long long ints crush with size 105 filled with 0 ; TAB0 declare long long int variable cnt = 0 ; TAB0 gcd is a long long int function with long long int arguments a and b ; TAB1 if b = 0 , return a ; TAB1 return gcd ( b , a % b ) ; TAB1 declare long long int variable n ; TAB1 read n ; TAB1 for i from 1 to n inclusive , read crush [ i ] ; TAB1 declare long long int variable ans = 1 ; TAB1 for i from 1 to n inclusive ; TAB2 if visited [ i ] is false ; TAB3 change cnt to 1 ; TAB3 change visited [ i ] to true ; TAB3 declare long long int variable z = crush [ i ] ; TAB3 while z ! = i ; TAB4 if visited [ z ] = true and cnt > 1 ; TAB5 print " - 1 " ; TAB4 change visited [ z ] to true ; TAB4 change z to crush [ z ] ; TAB4 increment cnt by one ; TAB3 if cnt is even , divide cnt by 2 ; TAB3 declare long long int y = gcd ( ans , cnt ) ; TAB3 set ans to ans * cnt / y ; TAB3 change cnt to 1 ; TAB1 print ans ;	map < long long int , long long int > m1 ; map < long long int , long long int > :: iterator itr ; bool visited [ 105 ] = { false } ; long long int crush [ 105 ] = { 0 } ; long long int cnt = 0 ; long long int gcd ( long long int a , long long int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int main ( ) { long long int n ; cin >> n ; for ( long long int i = 1 ; i <= n ; i ++ ) { cin >> crush [ i ] ; } long long int ans = 1 ; for ( long long int i = 1 ; i <= n ; i ++ ) { if ( ! visited [ i ] ) { cnt = 1 ; visited [ i ] = true ; long long int z = crush [ i ] ; while ( z != i ) { if ( visited [ z ] == true && cnt > 1 ) { cout << " -1 " << endl ; return 0 ; } visited [ z ] = true ; z = crush [ z ] ; cnt ++ ; } if ( cnt % 2 == 0 ) cnt /= 2 ; long long int y = gcd ( ans , cnt ) ; ans = ans * cnt / y ; cnt = 1 ; } } cout << ans << endl ; return 0 ; }
TAB0 create 3d array of long longs dp with size 20 by 10 by 10 ; TAB0 create an array of ints d with size 20 ; TAB0 create long longs l and r ; TAB0 long long function work with int arguments pos , pre , head and flag ; TAB1 if pos < 0 , return head & & ( head = pre ) ; TAB1 if flag ! = 0 or dp [ pos ] [ pre ] [ head ] = - 1 ; TAB2 declare int maxx = d [ pos ] if flag ! = 0 or 9 otherwise ; TAB2 create long long ret = 0 ; TAB2 for i from 0 to maxx inclusive , increase ret by work ( pos - 1 , i , head ? head : i , flag & & ( i = d [ pos ] ) ) ; TAB2 if flag ! = 0 , return ret ; TAB2 set dp [ pos ] [ pre ] [ head ] to ret ; TAB1 return dp [ pos ] [ pre ] [ head ] ; TAB0 solve is a long long function with long long argument x ; TAB1 create integer len = 0 ; TAB1 while x is not 0 ; TAB2 assign x % 10 to d [ len ] and increment len ; TAB2 divide x by 10 ; TAB1 set first sizeofdp bytes at the pointer dp to - 1 ; TAB1 return work ( len - 1 , 0 , 0 , 1 ) ; TAB1 read l and r ; TAB1 print solve ( r ) - solve ( l - 1 ) ;	long long dp [ 20 ] [ 10 ] [ 10 ] ; int d [ 20 ] ; long long l , r ; long long work ( int pos , int pre , int head , int flag ) { if ( pos < 0 ) { return ( head && ( head == pre ) ) ; } if ( flag || dp [ pos ] [ pre ] [ head ] == - 1 ) { int maxx = flag ? d [ pos ] : 9 ; long long ret = 0 ; for ( int i = 0 ; i <= maxx ; i ++ ) { ret += work ( pos - 1 , i , head ? head : i , flag && ( i == d [ pos ] ) ) ; } if ( flag ) return ret ; dp [ pos ] [ pre ] [ head ] = ret ; } return dp [ pos ] [ pre ] [ head ] ; } long long solve ( long long x ) { int len = 0 ; while ( x ) { d [ len ++ ] = x % 10 ; x /= 10 ; } memset ( dp , - 1 , sizeof dp ) ; return work ( len - 1 , 0 , 0 , 1 ) ; } int main ( ) { cin >> l >> r ; cout << solve ( r ) - solve ( l - 1 ) << endl ; }
TAB1 n = long long int , u = 0 ; TAB1 read n ; TAB1 for i = 2 to sqrt ( n ) inclusive ; TAB2 if n modulo i is 0 and not u divide n by i , u = i ; TAB2 if n modulo i is 0 and n > i ; TAB3 print " 1 " , newline , u * i ; TAB1 if not u ; TAB2 print " 1 " , newline , " 0 " , newline ; TAB1 else ; TAB2 print " 2 " , newline ;	int main ( ) { long long int n , u = 0 ; cin >> n ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 && ! u ) n /= i , u = i ; if ( n % i == 0 && n > i ) { cout << " 1\n " << u * i << endl ; return 0 ; } } if ( ! u ) cout << " 1\n0\n " ; else cout << " 2\n " ; }
TAB0 in inline long long function gcd that takes a = long long and b = long long ; TAB1 if a = 0 return b ; TAB1 return the gcd of b mod a and a ; TAB0 in inline long long function power that takes a , n , m = long long ; TAB1 if n = 0 return 1 ; TAB1 let p be a long long = the power of a , n / 2 , m ; TAB1 set p to p ^ 2 / m ; TAB1 if n is even ; TAB2 return p * a mod m ; TAB1 else ; TAB2 return p ; TAB0 let MOD = long long constant = 998244353 ; TAB0 INF = 0x3f3f3f3f = const int ; TAB0 LL_INF = long lon g constant = 0x3f3f3f3f3f3f3f3f ; TAB0 let adj = 101x101 int matrix ; TAB1 k = int ; TAB1 read k ; TAB1 let l = 3 , u = 100 be ints ; TAB1 vn = 1 = int ; TAB1 ans , n , ans1 , x = int ; TAB1 while u > = 1 ; TAB2 set n to ( u + 1 ) / 2 ; TAB2 set x to ( n * ( n - 1 ) ) * ( n - 2 ) ; TAB2 if x > 6 * k ; TAB3 set u to n - 1 ; TAB2 else ; TAB3 set ans to n ; TAB3 set l = n + 1 ; TAB1 set x = ans * ( ans - 1 ) ; TAB1 multiply x by ans - 2 ; TAB1 decrement k by x / 6 ; TAB1 for i = 1 to ans inclusive ; TAB2 for j = 1 to ans inclusive ; TAB3 if i isn ' t j ; TAB4 set adj [ i ] [ j ] to 1 ; TAB4 set adj [ i ] [ j ] = 1 ; TAB1 increment vn by ans ; TAB1 while k is strictly positive ; TAB2 set l = 2 ; TAB2 set u = ans ; TAB2 while u > = 1 ; TAB3 set n = a half of ( u + 1 ) ; TAB3 set x = n * n ( n - 1 ) ; TAB3 if x < = 2 * k ; TAB4 set ans1 = n ; TAB4 set l = n + 1 ; TAB3 else ; TAB4 set u = n - 1 ; TAB2 dcrement k by ans1 * ( ans1 - 1 ) / 2 ; TAB2 for i = 1 to ans1 inclusive ; TAB3 set adj [ i ] [ vn ] = 1 ; TAB3 set adj [ vn ] [ i ] to 1 ; TAB2 increment vn ; TAB1 print vn - 1 ; TAB1 for i = 1 to vn - 1 inclusive ; TAB2 for j = 1 to j < = vn - 1 then print adj [ i ] [ j ] ; TAB2 print new line ;	inline long long gcd ( long long a , long long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } inline long long power ( long long a , long long n , long long m ) { if ( n == 0 ) return 1 ; long long p = power ( a , n / 2 , m ) ; p = ( p * p ) % m ; if ( n % 2 ) return ( p * a ) % m ; else return p ; } const long long MOD = 998244353 ; const int INF = 0x3f3f3f3f ; const long long LL_INF = 0x3f3f3f3f3f3f3f3f ; int adj [ 101 ] [ 101 ] ; int main ( ) { int k ; cin >> k ; int l = 3 , u = 100 ; int vn = 1 ; int ans , n , ans1 , x ; while ( u >= l ) { n = ( u + l ) / 2 ; x = ( n * ( n - 1 ) ) * ( n - 2 ) ; if ( x > ( 6 * k ) ) { u = n - 1 ; } else { ans = n ; l = n + 1 ; } } x = ans * ( ans - 1 ) ; x = x * ( ans - 2 ) ; k = k - x / 6 ; for ( int i = 1 ; i <= ans ; i ++ ) for ( int j = 1 ; j <= ans ; j ++ ) if ( i != j ) { adj [ i ] [ j ] = 1 ; adj [ j ] [ i ] = 1 ; } vn = vn + ans ; while ( k > 0 ) { l = 2 ; u = ans ; while ( u >= l ) { n = ( u + l ) / 2 ; x = n * ( n - 1 ) ; if ( x <= ( 2 * k ) ) { ans1 = n ; l = n + 1 ; } else { u = n - 1 ; } } k = k - ( ans1 * ( ans1 - 1 ) ) / 2 ; for ( int i = 1 ; i <= ans1 ; i ++ ) { adj [ i ] [ vn ] = 1 ; adj [ vn ] [ i ] = 1 ; } vn ++ ; } cout << vn - 1 << endl ; for ( int i = 1 ; i <= vn - 1 ; i ++ ) { for ( int j = 1 ; j <= vn - 1 ; j ++ ) cout << adj [ i ] [ j ] ; cout << endl ; } }
TAB1 create int x , t , a , b , da , db ; TAB1 read x , t , a , b , da , db ; TAB1 for i = 0 to t exclusive ; TAB2 for j = 0 to t exclusive ; TAB3 create int p and q ; TAB3 assign a - i * da to p ; TAB3 assign b - j * db to q ; TAB3 if ( p greater than - 1 and q greater than - 1 ) and ( p + q equals x or p equals x or q equals x or x equals 0 ) ; TAB4 print " YES " ; TAB1 print " NO " ;	int main ( ) { int x , t , a , b , da , db ; cin >> x >> t >> a >> b >> da >> db ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { int p , q ; p = a - i * da ; q = b - j * db ; if ( ( p > - 1 && q > - 1 ) && ( p + q == x || p == x || q == x || x == 0 ) ) { cout << " YES " << endl ; return 0 ; } } } cout << " NO " << endl ; return 0 ; }
TAB0 declare constant integer N = 1e5 + 5 ; TAB0 s is a new array of characters with size N ; TAB1 declare integer variables i , len and flag with flag = 0 ; TAB1 read input an store it into s ; TAB1 assign the new value = length of s to len ; TAB1 for i = 0 to len exclusive ; TAB2 if s [ i ] ! = ' a ' ; TAB3 assign 1 to flag ; TAB3 decrement s [ i ] ; TAB2 else if flag is not 0 ; TAB3 break the loop ; TAB1 if flag is 0 , set the value of s [ i - 1 ] to ' z ' ; TAB1 print s to stdout ;	const int N = 1e5 + 5 ; char s [ N ] ; int main ( ) { int i , len , flag = 0 ; gets ( s ) ; len = strlen ( s ) ; for ( i = 0 ; i < len ; ++ i ) { if ( s [ i ] != ' a ' ) { flag = 1 ; -- s [ i ] ; } else if ( flag ) break ; } if ( ! flag ) s [ i - 1 ] = ' z ' ; puts ( s ) ; return 0 ; }
TAB1 N = integer ; TAB1 read N ; TAB1 p = string ; TAB1 read p ; TAB1 ok = boolean = false ; TAB1 cnt = integer = 0 ; TAB1 if p [ 0 ] is ? or p [ N - 1 ] is ? , then ok = true ; TAB1 for i = 1 to N exclusive ; TAB2 if p [ i ] is ? and p [ i - 1 ] is p [ i + 1 ] or p [ i - 1 ] is ? ; TAB3 ok = true ; TAB2 else if p [ i ] is p [ i - 1 ] ; TAB3 ok = false ; TAB3 exit for loop ; TAB1 if ok is true ; TAB2 print Yes ; TAB1 else ; TAB2 print No ;	int main ( ) { int N ; cin >> N ; string p ; cin >> p ; bool ok = false ; int cnt = 0 ; if ( p [ 0 ] == ' ? ' || p [ N - 1 ] == ' ? ' ) ok = true ; for ( int i = 1 ; i < N ; i ++ ) { if ( p [ i ] == ' ? ' && ( p [ i - 1 ] == p [ i + 1 ] || p [ i - 1 ] == ' ? ' ) ) { ok = true ; } else if ( p [ i ] == p [ i - 1 ] ) { ok = false ; break ; } } if ( ok ) { cout << " Yes " << ' \n ' ; } else { cout << " No " << ' \n ' ; } return 0 ; }
TAB0 data = array of 51 by 51 char ; TAB0 visited = array of 51 by 51 bool ; TAB0 dr = array of 4 int filled with 0 , 0 , 1 , - 1 ; TAB0 dc = array of 4 int filled with 1 , - 1 , 0 , 0 ; TAB0 function Counter ( get int i and j , return int ) ; TAB1 if visited [ i ] [ j ] return 0 ; TAB1 visited [ i ] [ j ] = true ; TAB1 ans = 0 ; TAB1 if data [ i ] [ j ] is ' # ' ; TAB2 increment ans ; TAB2 for x = 0 to 4 exclusive add Counter ( i + dr [ x ] , j + dc [ x ] ) to ans ; TAB1 return ans ; TAB1 n , m = int ; TAB1 read n , m ; TAB1 Total = 0 ; TAB1 start = pair of int , int ; TAB1 for i = 0 to n exclusive ; TAB2 for j = o to m exclusive ; TAB3 read data [ i ] [ j ] ; TAB3 if data [ i ] [ j ] is ' # ' increment Total , start = i , j ; TAB1 fill visited with false ; TAB1 t = Counter ( first item of start , second item of start ) ; TAB1 if t < Total ; TAB2 print 0 ; TAB1 else if Total < 3 ; TAB2 print - 1 ; TAB1 else ; TAB2 ans = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to m exclusive ; TAB4 if data [ i ] [ j ] is ' # ' ; TAB5 if i is 6 and j is 5 r = 1 ; TAB5 fill visited with false ; TAB5 visited [ i ] [ j ] = true ; TAB5 x , y = int ; TAB5 for k = 0 to 4 exclusive ; TAB6 if data [ i + dr [ k ] ] [ j + dc [ k ] ] is ' # ' ; TAB7 x = i + dr [ k ] ; TAB7 y = j + dc [ k ] ; TAB7 break ; TAB5 t = Counter ( x , y ) ; TAB5 if t < Total - 1 ; TAB6 print 1 ; TAB1 print 2 ;	char data [ 51 ] [ 51 ] ; bool visited [ 51 ] [ 51 ] ; int dr [ ] = { 0 , 0 , 1 , - 1 } ; int dc [ ] = { 1 , - 1 , 0 , 0 } ; int Counter ( int i , int j ) { if ( visited [ i ] [ j ] ) return 0 ; visited [ i ] [ j ] = true ; int ans = 0 ; if ( data [ i ] [ j ] == ' # ' ) { ans ++ ; for ( int x = 0 ; x < 4 ; x ++ ) { ans += Counter ( i + dr [ x ] , j + dc [ x ] ) ; } } return ans ; } int main ( ) { int n , m ; cin >> n >> m ; int Total = 0 ; pair < int , int > start ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { cin >> data [ i ] [ j ] ; if ( data [ i ] [ j ] == ' # ' ) Total ++ , start = pair < int , int > ( i , j ) ; } } memset ( visited , false , sizeof visited ) ; int t = Counter ( start . first , start . second ) ; if ( t < Total ) { cout << 0 << endl ; return 0 ; } else if ( Total < 3 ) { cout << - 1 << endl ; return 0 ; } else { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( data [ i ] [ j ] == ' # ' ) { if ( i == 6 && j == 5 ) { int r = 1 ; } memset ( visited , false , sizeof visited ) ; visited [ i ] [ j ] = true ; int x , y ; for ( int k = 0 ; k < 4 ; k ++ ) { if ( data [ i + dr [ k ] ] [ j + dc [ k ] ] == ' # ' ) { x = i + dr [ k ] ; y = j + dc [ k ] ; break ; } } int t = Counter ( x , y ) ; if ( t < Total - 1 ) { cout << " 1 " << endl ; return 0 ; } } } } } cout << 2 << endl ; return 0 ; }
TAB0 in function R taking string vector A and returning string vector ; TAB1 B = auto with B = A ; TAB1 for i = 0 to size of A ; TAB2 for j = 0 to size of B set B [ j ] [ i ] to a [ i ] [ j ] ; TAB1 iterate over B with reference to auto s reverse s ; TAB1 return B ; TAB1 n = int ; TAB1 read n ; TAB1 A , B = string vector of size n each ; TAB1 read n values into A ; TAB1 read n values into B ; TAB1 OK = bool with OK = A is B ; TAB1 for j = 0 to 4 ; TAB2 set A to R of A ; TAB2 if A is B set OK to 1 ; TAB1 iterate over A with reference to auto s reverse s ; TAB1 for j = 0 to 4 ; TAB2 set A to R of A ; TAB2 if A is B set OK to 1 ; TAB1 for i = 0 to n / 2 call swap of A [ i ] , A [ n - 1 - i ] ; TAB1 for j = 0 to 4 ; TAB2 set A to R of A ; TAB2 if A is B set OK to 1 ; TAB1 if OK print " Yes " else print " No " ;	vector < string > R ( vector < string > A ) { auto B = A ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) for ( int j = 0 ; j < A . size ( ) ; j ++ ) B [ j ] [ i ] = A [ i ] [ j ] ; for ( auto & s : B ) reverse ( s . begin ( ) , s . end ( ) ) ; return B ; } int main ( ) { int n ; cin >> n ; vector < string > A ( n ) , B ( n ) ; for ( auto & s : A ) cin >> s ; for ( auto & s : B ) cin >> s ; bool OK = A == B ; for ( int j = 0 ; j < 4 ; j ++ ) { A = R ( A ) ; if ( A == B ) OK = 1 ; } for ( auto & s : A ) reverse ( s . begin ( ) , s . end ( ) ) ; for ( int j = 0 ; j < 4 ; j ++ ) { A = R ( A ) ; if ( A == B ) OK = 1 ; } for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( A [ i ] , A [ n - 1 - i ] ) ; for ( int j = 0 ; j < 4 ; j ++ ) { A = R ( A ) ; if ( A == B ) OK = 1 ; } cout << ( OK ? " Yes\n " : " No\n " ) ; }
TAB1 create integers n , x1 , y1 , x2 , y2 ; TAB1 read n read x1 read y1 read x2 read y2 ; TAB1 if ( x1 is n and x2 is 0 ) or ( x1 is 0 and x2 is n ) ; TAB2 if ( y1 + y2 + n ) is less than or equal to ( n - y1 + n - y2 + n ) ; TAB3 print y1 + y2 + n print newline ; TAB2 else ; TAB3 print ( n - y1 + n - y2 + n ) print newline ; TAB1 else if ( x1 is n and y2 is 0 ) or ( x2 is n and y1 is 0 ) ; TAB2 if x1 is n and y2 is 0 ; TAB3 print y1 + ( n - x2 ) print newline ; TAB2 else ; TAB3 print ( n - x1 ) + y2 print newline ; TAB1 else if ( x1 is n and y2 is n ) or ( y1 is n and x2 is n ) ; TAB2 print absolute value of ( x1 - y1 ) + absolute value of ( x2 - y2 ) print newline ; TAB1 else if ( y1 is n and x2 is 0 ) or ( y2 is n and x1 is 0 ) ; TAB2 if ( y1 is n and x2 is 0 ) ; TAB3 print x1 + ( n - y2 ) print newline ; TAB2 else ; TAB3 print x2 + ( n - y1 ) print newline ; TAB1 else if ( y1 is n and y2 is 0 ) or ( y1 is 0 and y2 is n ) ; TAB2 if ( x1 + x2 + n ) is less than or equal to ( n - x1 + n - x2 + n ) ; TAB3 print x1 + x2 + n print newline ; TAB2 else ; TAB3 print n - x1 + n - x2 + n print newline ; TAB1 else if ( y1 is 0 and x2 is 0 ) or ( x1 is 0 and y2 is 0 ) ; TAB2 print x1 + x2 + y1 + y2 print newline ; TAB1 else ; TAB2 print absolute value of x1 - x2 + absolute value of y1 - y2 print newline ;	int main ( ) { int n , x1 , y1 , x2 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; if ( ( x1 == n && x2 == 0 ) || ( x1 == 0 && x2 == n ) ) { if ( ( y1 + y2 + n ) <= ( n - y1 + n - y2 + n ) ) { cout << y1 + y2 + n << endl ; } else { cout << ( n - y1 + n - y2 + n ) << endl ; } } else if ( ( x1 == n && y2 == 0 ) || ( x2 == n && y1 == 0 ) ) { if ( x1 == n && y2 == 0 ) { cout << y1 + ( n - x2 ) << endl ; } else { cout << ( n - x1 ) + y2 << endl ; } } else if ( ( x1 == n && y2 == n ) || ( y1 == n && x2 == n ) ) { cout << abs ( x1 - y1 ) + abs ( x2 - y2 ) << endl ; } else if ( ( y1 == n && x2 == 0 ) || ( y2 == n && x1 == 0 ) ) { if ( y1 == n && x2 == 0 ) { cout << x1 + ( n - y2 ) << endl ; } else { cout << x2 + ( n - y1 ) << endl ; } } else if ( ( y1 == n && y2 == 0 ) || ( y1 == 0 && y2 == n ) ) { if ( ( x1 + x2 + n ) <= ( n - x1 + n - x2 + n ) ) { cout << x1 + x2 + n << endl ; } else { cout << n - x1 + n - x2 + n << endl ; } } else if ( ( y1 == 0 && x2 == 0 ) || ( x1 == 0 && y2 == 0 ) ) { cout << x1 + x2 + y1 + y2 << endl ; } else { cout << abs ( x1 - x2 ) + abs ( y1 - y2 ) << endl ; } }
TAB0 vis1 = array of long integers of length 1000005 ; TAB0 vis2 = array of long integers of length 1000005 ; TAB1 let m be a long integer ; TAB1 let h1 , a1 be long integers ; TAB1 let x1 , y1 be long integers ; TAB1 let h2 , a2 be long integers ; TAB1 let x2 , y2 be long integers ; TAB1 read m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 ; TAB1 memset of vis1 , 0 , size of vis1 ; TAB1 memset of vis2 , 0 , size of vis2 ; TAB1 let t1 , t2 be long integers with t1 = - 1 , t2 = - 1 ; TAB1 let c1 , c2 be long integers with c1 = - 1 , c2 = - 1 ; TAB1 let q1 , q2 be long integers with q1 = - 1 , q2 = - 1 ; TAB1 let f1 , f2 be long integers with f1 = - 1 , f2 = - 1 ; TAB1 set boolean value flag to true ; TAB1 set boolean value fuck to false ; TAB1 for long integer i = 1 to 2 * m inclusive ; TAB2 the value of h1 = h1 * x1 ; TAB2 the value of h1 = h1 modulo m ; TAB2 the value of h1 = h1 + y1 ; TAB2 the value of h1 = h1 modulo m ; TAB2 the value of h2 = h2 * x2 ; TAB2 the value of h2 = h2 modulo m ; TAB2 the value of h2 = h2 + y2 ; TAB2 the value of h2 = h2 modulo m ; TAB2 if h1 is equal to a1 and a2 is equal to h2 ; TAB3 set fuck to true ; TAB3 print i and newline ; TAB3 stop ; TAB2 if vis1 [ a1 ] is equal to 0 and h1 is equal to a1 , f1 is equal to i ; TAB2 if vis2 [ a2 ] is equal to 0 and h2 is equal to a2 , f2 is equal to i ; TAB2 if h1 is equal to a1 and t1 is equal to - 1 , c1 is equal to i ; TAB2 if h2 is equal to a2 and t2 is equal to - 1 , c2 is equal to i ; TAB2 if vis1 [ h1 ] is not equal to 0 and q1 is equal to - 1 ; TAB3 the value of q1 is equal to vis1 [ h1 ] ; TAB3 the value of t1 is equal to i - q1 ; TAB3 if c1 is less than q1 ; TAB4 set flag to false ; TAB4 stop ; TAB3 else do the following ; TAB4 decrement c1 by q1 ; TAB2 if vis2 [ h2 ] is not equal to 0 and q2 is equal to - 1 ; TAB3 the value of q2 is equal to vis2 [ h2 ] ; TAB3 the value of t2 is equal to i - q2 ; TAB3 if c2 is less than q2 ; TAB4 set flag to false ; TAB4 stop ; TAB3 else do the following ; TAB4 decrement c2 by q2 ; TAB2 if t1 is not equal to - 1 and t2 is not equal to - 1 , stop ; TAB2 if vis1 [ h1 ] is equal to 0 , vis1 [ h1 ] is equal to i ; TAB2 if vis2 [ h2 ] is equal to 0 , vis2 [ h2 ] is equal to i ; TAB1 if fuck is true ; TAB1 else if not flag ; TAB2 if f1 is not equal to f2 or f1 is equal to - 1 or f2 is equal to - 1 ; TAB3 print - 1 and newline ; TAB2 else do the following ; TAB3 print f1 + 1 and newline ; TAB1 else do the following ; TAB2 if f1 is equal to f2 and f1 is not equal to - 1 and f2 is not equal to - 2 ; TAB3 print f1 and newline ; TAB2 else if t1 is equal to t2 and ( c1 is equal to c2 and f1 is not equal to f2 ) or c1 is not equal to c2 ; TAB3 print - 1 and newline ; TAB2 else do the following ; TAB3 let x be a long integer with x = 0 ; TAB3 while x * t1 + c1 + q1 - c2 - q2 modulo t2 is not equal to 0 ; TAB4 increment x by 1 ; TAB4 if x is greater than 1000000 , stop ; TAB3 if x is greater than 1000000 ; TAB4 print - 1 and newline ; TAB3 else do the following ; TAB4 print x * t1 + c1 + q1 and newline ;	long long vis1 [ 1000005 ] ; long long vis2 [ 1000005 ] ; int main ( ) { long long m ; long long h1 , a1 ; long long x1 , y1 ; long long h2 , a2 ; long long x2 , y2 ; cin >> m >> h1 >> a1 >> x1 >> y1 >> h2 >> a2 >> x2 >> y2 ; memset ( vis1 , 0 , sizeof ( vis1 ) ) ; memset ( vis2 , 0 , sizeof ( vis2 ) ) ; long long t1 = - 1 , t2 = - 1 ; long long c1 = - 1 , c2 = - 1 ; long long q1 = - 1 , q2 = - 1 ; long long f1 = - 1 , f2 = - 1 ; bool flag = true ; bool fuck = false ; for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h1 *= x1 ; h1 %= m ; h1 += y1 ; h1 %= m ; h2 *= x2 ; h2 %= m ; h2 += y2 ; h2 %= m ; if ( h1 == a1 && a2 == h2 ) { fuck = true ; cout << i << endl ; break ; } if ( vis1 [ a1 ] == 0 && h1 == a1 ) { f1 = i ; } if ( vis2 [ a2 ] == 0 && h2 == a2 ) { f2 = i ; } if ( h1 == a1 && t1 == - 1 ) { c1 = i ; } if ( h2 == a2 && t2 == - 1 ) { c2 = i ; } if ( vis1 [ h1 ] != 0 && q1 == - 1 ) { q1 = vis1 [ h1 ] ; t1 = i - q1 ; if ( c1 < q1 ) { flag = false ; break ; } else { c1 = c1 - q1 ; } } if ( vis2 [ h2 ] != 0 && q2 == - 1 ) { q2 = vis2 [ h2 ] ; t2 = i - q2 ; if ( c2 < q2 ) { flag = false ; break ; } else { c2 = c2 - q2 ; } } if ( t1 != - 1 && t2 != - 1 ) { break ; } if ( vis1 [ h1 ] == 0 ) vis1 [ h1 ] = i ; if ( vis2 [ h2 ] == 0 ) vis2 [ h2 ] = i ; } if ( fuck ) { } else if ( ! flag ) { if ( f1 != f2 || f1 == - 1 || f2 == - 1 ) cout << " -1\n " ; else cout << f1 + 1 << " \n " ; } else { if ( f1 == f2 && f1 != - 1 && f2 != - 2 ) { cout << f1 << " \n " ; } else if ( t1 == t2 && ( ( c1 == c2 && f1 != f2 ) || c1 != c2 ) ) { cout << " -1\n " ; } else { long long x = 0 ; while ( ( x * t1 + c1 + q1 - c2 - q2 ) % t2 != 0 ) { x ++ ; if ( x > 1000000 ) { break ; } } if ( x > 1000000 ) { cout << " -1 " << endl ; } else cout << x * t1 + c1 + q1 << " \n " ; } } return 0 ; }
TAB0 maxn is a constant integer with maxn = 1100 ; TAB0 a is an integer array with two dimensions both of size maxn , b is an integer array of size maxn ; TAB0 s is a string array of size 110 ; TAB1 declare variable n ; TAB1 while input n ; TAB2 for i = 0 to n exclusive , input s [ i ] ; TAB2 top and flag are both integers and are both set to 0 ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to n exclusive ; TAB4 if s [ i ] [ j ] is equal to the character . ; TAB5 increment top ; TAB5 break ; TAB2 if top is equal to n ; TAB3 assign 1 to flag ; TAB3 for i = 0 to n exclusive ; TAB4 for j = 0 to n exclusive ; TAB5 if s [ i ] [ j ] is equal to the character . ; TAB6 display i + 1 , " " , and j + 1 ; TAB6 break ; TAB2 assign 0 to top ; TAB2 for j = 0 to n exclusive ; TAB3 for i = 0 to n exclusive ; TAB4 if s [ i ] [ j ] is equal to the character . ; TAB5 increment top ; TAB5 break ; TAB2 if top is equal to n and flag is false ; TAB3 assign 1 to flag ; TAB3 for j = 0 to n exclusive ; TAB4 for i = 0 to n exclusive ; TAB5 if s [ i ] [ j ] is equal to the character . ; TAB6 display i + 1 , " " , and j + 1 ; TAB6 break ; TAB2 if not flag , puts - 1 ;	const int maxn = 1100 ; int a [ maxn ] [ maxn ] , b [ maxn ] ; string s [ 110 ] ; int main ( ) { int n ; while ( cin >> n ) { for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; int top = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( s [ i ] [ j ] == ' . ' ) { top ++ ; break ; } if ( top == n ) { flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( s [ i ] [ j ] == ' . ' ) { cout << i + 1 << "   " << j + 1 << endl ; break ; } } top = 0 ; for ( int j = 0 ; j < n ; j ++ ) for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] == ' . ' ) { top ++ ; break ; } if ( top == n && ! flag ) { flag = 1 ; for ( int j = 0 ; j < n ; j ++ ) for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] == ' . ' ) { cout << i + 1 << "   " << j + 1 << endl ; break ; } } if ( ! flag ) puts ( " -1 " ) ; } return 0 ; }
TAB1 n , i and k are integers where k = 0 and a is an integer array with 110 elements ; TAB1 read n ; TAB1 loop i from 1 to n inclusive ; TAB2 read a [ i ] ; TAB2 if a [ i ] is less than 0 , increment k by one ; TAB1 if k < = 2 ; TAB2 print 1 , new line and n ; TAB1 else ; TAB2 if k is even ; TAB3 print k / 2 ; TAB2 else ; TAB3 print k / 2 + 1 ; TAB2 declare integers t , sum = 0 and x = 1 ; TAB2 for i from 1 to n inclusive ; TAB3 if t = 2 and a [ i ] < 0 ; TAB4 print i - x and " " ; TAB4 add i - x to sum ; TAB4 change x to i ; TAB4 set t to 0 ; TAB3 if a [ i ] is less than 0 , increment t by one ; TAB2 if sum is less than n , print n - sum ; TAB2 print new line ;	int main ( ) { int n , a [ 110 ] , i , k = 0 ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] < 0 ) k ++ ; } if ( k <= 2 ) cout << 1 << endl << n << endl ; else { if ( k % 2 == 0 ) cout << k / 2 << endl ; else cout << k / 2 + 1 << endl ; int t = 0 , x = 1 , sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( t == 2 && a [ i ] < 0 ) { cout << i - x << "   " ; sum += ( i - x ) ; x = i ; t = 0 ; } if ( a [ i ] < 0 ) t ++ ; } if ( sum < n ) cout << n - sum ; cout << endl ; } return 0 ; }
TAB0 create int constant N = 80 + 5 ; TAB0 create integers n and mx ; TAB0 create int now = 0 ; TAB0 create an array of bools active with size N ; TAB0 create int array v with size N ; TAB0 create int res = 0 ; TAB0 create an array of integers urm with N elements ; TAB1 read input to n and mx ; TAB1 for i = 1 to n inclusive , read v [ i ] ; TAB1 loop i from 1 to n inclusive ; TAB2 create integer x = v [ i ] ; TAB2 if active [ x ] is true , go to the start of the loop ; TAB2 if now = mx ; TAB3 increment res by one ; TAB3 loop j from 1 to n inclusive , assign 1 < < 30 to urm [ j ] ; TAB3 for integer j = n to i exclusive counting down , set urm [ v [ j ] ] to j ; TAB3 create integers maurm and who with maurm = 0 ; TAB3 for j from 1 to n inclusive ; TAB4 if active [ j ] is true ; TAB5 change maurm to max of maurm and urm [ j ] ; TAB5 if urm [ j ] = maurm , assign j to who ; TAB3 set active [ who ] to 0 ; TAB3 change active [ x ] to 1 ; TAB2 else ; TAB3 increment now ; TAB3 increment res ; TAB3 change active [ x ] to 1 ; TAB1 print res and " \ n " ;	const int N = 80 + 5 ; int n , mx ; int now = 0 ; bool active [ N ] ; int v [ N ] ; int res = 0 ; int urm [ N ] ; int main ( ) { cin >> n >> mx ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> v [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) { int x = v [ i ] ; if ( active [ x ] ) continue ; if ( now == mx ) { res ++ ; for ( int j = 1 ; j <= n ; j ++ ) urm [ j ] = ( 1 << 30 ) ; for ( int j = n ; j > i ; j -- ) { urm [ v [ j ] ] = j ; } int maurm = 0 , who ; for ( int j = 1 ; j <= n ; j ++ ) { if ( active [ j ] ) { maurm = max ( maurm , urm [ j ] ) ; if ( urm [ j ] == maurm ) { who = j ; } } } active [ who ] = 0 ; active [ x ] = 1 ; } else { now ++ ; res ++ ; active [ x ] = 1 ; } } cout << res << " \n " ; return 0 ; }
TAB1 create sets of int called h and v ; TAB1 declare int variable n ; TAB1 read n ; TAB1 loop i from 1 to n inclusive ; TAB2 insert i into h ; TAB2 insert i into v ; TAB1 declare int ans = 0 ; TAB1 for i from 1 to n squared inclusive ; TAB2 declare int variables x and y ; TAB2 read x and y ; TAB2 if there is x in h and y in v ; TAB3 if ans is true , increment ans in any case and print ' ' ; TAB3 print i ; TAB3 remove x from h ; TAB3 remove y from v ; TAB1 print new line ;	int main ( ) { set < int > h , v ; int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { h . insert ( i ) ; v . insert ( i ) ; } int ans = 0 ; for ( int i = 1 ; i <= ( n * n ) ; i ++ ) { int x , y ; cin >> x >> y ; if ( h . find ( x ) != h . end ( ) && v . find ( y ) != v . end ( ) ) { if ( ans ++ ) cout << '   ' ; cout << i ; h . erase ( x ) ; v . erase ( y ) ; } } cout << endl ; return 0 ; }
TAB1 hc = integer with hc = - 1 ; TAB1 s , a = strings ; TAB1 read s ; TAB1 for i = s . size ( ) down to i ; TAB2 if ( s [ i ] is 0 ) , hc = i ; TAB1 for i = 0 to s . size ( ) exclusive ; TAB2 if ( ( hc is - 1 and i is 0 ) or i is hc ) , continue next iteration ; TAB2 a = a + s [ i ] ; TAB1 print a ;	int main ( ) { int hc = - 1 ; string s , a ; cin >> s ; for ( int i = s . size ( ) ; i >= 0 ; i -- ) { if ( s [ i ] == ' 0 ' ) hc = i ; } for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( hc == - 1 && i == 0 ) || i == hc ) continue ; a += s [ i ] ; } cout << a << endl ; return 0 ; }
TAB0 MAXN , DELTA = const integer with MAXN = 5000 + 7 , DELTA = 1000 * 1000 * 1000 + 7 ; TAB0 numberOfPartialAns = long long array of size [ MAXN ] [ MAXN ] ; TAB0 s , t = strings ; TAB1 read s , t ; TAB1 for i = 1 to ( cast to integer ) s . size ( ) ; TAB2 for j = 1 to ( cast to integer ) t . size ( ) ; TAB3 numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j - 1 ] ; TAB3 if ( s [ i - 1 ] is t [ j - 1 ] ) ; TAB4 numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j ] + numberOfPartialAns [ i - 1 ] [ j - 1 ] ; TAB4 numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j ] modulo DELTA ; TAB4 increment numberOfPartialAns [ i ] [ j ] ; TAB4 numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j ] modulo DELTA ; TAB1 ans = long long with ans = 0 ; TAB1 for i = 1 to ( cast to integer ) s . size ( ) ; TAB2 ans = ans + numberOfPartialAns [ i ] [ ( cast to integer ) t . size ( ) ] ; TAB2 ans = ans modulo DELTA ; TAB1 print ans ;	const int MAXN = 5000 + 7 , DELTA = 1000 * 1000 * 1000 + 7 ; long long numberOfPartialAns [ MAXN ] [ MAXN ] ; string s , t ; int main ( ) { cin >> s >> t ; for ( int i = 1 ; i <= ( int ) s . size ( ) ; ++ i ) { for ( int j = 1 ; j <= ( int ) t . size ( ) ; ++ j ) { numberOfPartialAns [ i ] [ j ] = numberOfPartialAns [ i ] [ j - 1 ] ; if ( s [ i - 1 ] == t [ j - 1 ] ) { numberOfPartialAns [ i ] [ j ] += numberOfPartialAns [ i - 1 ] [ j - 1 ] ; numberOfPartialAns [ i ] [ j ] %= DELTA ; numberOfPartialAns [ i ] [ j ] ++ ; numberOfPartialAns [ i ] [ j ] %= DELTA ; } } } long long ans = 0 ; for ( int i = 1 ; i <= ( int ) s . size ( ) ; ++ i ) { ans += numberOfPartialAns [ i ] [ ( int ) t . size ( ) ] ; ans %= DELTA ; } cout << ans << endl ; return 0 ; }
TAB1 a , b , d , s = integers ; TAB1 read a , b , d ; TAB1 s = abs ( a ) + abs ( b ) ; TAB1 if ( s > d ) ; TAB2 print No ; TAB1 else if ( s is d ) ; TAB2 print Yes ; TAB1 else ; TAB2 if ( ( d - s ) modulo 2 is 0 ) ; TAB3 print Yes ; TAB2 else ; TAB3 print No ;	int main ( ) { int a , b , d , s ; cin >> a >> b >> d ; s = abs ( a ) + abs ( b ) ; if ( s > d ) cout << " No " << endl ; else if ( s == d ) cout << " Yes " << endl ; else { if ( ( d - s ) % 2 == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
TAB1 n , m , k , l = long long ; TAB1 read n , m , k , l ; TAB1 sum = long long , sum = k + l ; TAB1 out = long long , out = sum / m ; TAB1 while true ; TAB2 if out * m < = n ; TAB3 if out * m > = sum ; TAB4 print out ; TAB4 exit while loop ; TAB3 else ; TAB4 add one to out ; TAB2 else ; TAB3 print - 1 ; TAB3 exit while loo [ ;	int main ( ) { long long n , m , k , l ; cin >> n >> m >> k >> l ; long long sum = k + l ; long long out = sum / m ; while ( 1 ) { if ( out * m <= n ) { if ( out * m >= sum ) { cout << out << endl ; break ; } else out ++ ; } else { cout << - 1 << endl ; break ; } } return 0 ; }
TAB1 a = integer 2d array of size 5 , 5 ; TAB1 p = integer array of size 5 ; TAB1 flag = int with flag = 0 ; TAB1 set all the contents of p to 0 ; TAB1 for i = 0 to 3 ; TAB2 for j = 0 to 3 ; TAB3 print a [ i ] [ j ] ; TAB3 if j is 3 and a [ i ] [ j ] , p [ i ] = 1 ; TAB1 for i = 0 to 3 ; TAB2 if p [ i ] ; TAB3 for j = 0 to 2 ; TAB4 if a [ ( i + j + 1 ) modulo 4 ] [ j ] or a [ i ] [ j ] ) ; TAB5 flag = 1 ; TAB5 break loop ; TAB1 call puts , if flag , print YES else print NO ;	int main ( ) { int a [ 5 ] [ 5 ] ; int p [ 5 ] ; int flag = 0 ; memset ( p , 0 , sizeof ( p ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { cin >> a [ i ] [ j ] ; if ( j == 3 && a [ i ] [ j ] ) p [ i ] = 1 ; } for ( int i = 0 ; i < 4 ; i ++ ) { if ( p [ i ] ) for ( int j = 0 ; j < 3 ; j ++ ) if ( a [ ( i + j + 1 ) % 4 ] [ j ] || a [ i ] [ j ] ) { flag = 1 ; break ; } } puts ( flag ? " YES " : " NO " ) ; }
TAB0 function nc ( no args , return char ) ; TAB1 return getchar ( ) ; TAB0 function read ( get address of int x , return nothing ) ; TAB1 c = nc ( ) ; TAB1 b = 1 ; TAB1 while not ( c > = ' 0 ' and < = ' 9 ' ) c = nc ( ) ; TAB2 if c is ' - ' b = - 1 ; TAB1 x = 0 , while c > = ' 0 ' and c < = ' 9 ' x = x * 10 + c - ' 0 ' , c = nc ( ) ; TAB2 do nothing ; TAB1 multiply x by b ; TAB0 function read ( get address of long long x , return nothing ) ; TAB1 c = nc ( ) ; TAB1 b = 1 ; TAB1 while not ( c > = ' 0 ' and < = ' 9 ' ) c = nc ( ) ; TAB2 if c is ' - ' b = - 1 ; TAB1 x = 0 , while c > = ' 0 ' and c < = ' 9 ' x = x * 10 + c - ' 0 ' , c = nc ( ) ; TAB2 do nothing ; TAB1 multiply x by b ; TAB0 function read ( get pointer to char s , return nothing ) ; TAB1 c = nc ( ) ; TAB1 len = 1 ; TAB1 while not ( c > = ' a ' and c < = ' z ' ) c = nc ( ) ; TAB2 if c is EOF return 0 ; TAB1 while c > = ' a ' and c < = ' z ' s [ len ] = c , increment len , c = nc ( ) ; TAB2 do nothing ; TAB1 s [ len ] = null byte , increment len ; TAB1 return len - 2 ; TAB0 function read ( get address of char x , return nothing ) ; TAB1 x = nc ( ) , while not ( x > = ' a ' and x < = ' z ' ) x = nc ( ) ; TAB2 do nothing ; TAB0 wt = int , ss = array of 19 int ; TAB0 function print ( get int x , return nothing ) ; TAB1 if x < 0 x = - x , print ' - ' ; TAB1 if not x ; TAB2 print char with value 48 ; TAB1 else ; TAB2 wt = 0 , while x ss [ wt ] = x modulo 10 , increment wt , divide x by 10 ; TAB3 do nothing ; TAB2 while wt puchar ( ss [ wt ] + 48 ) , decrement wt ; TAB3 do nothing ; TAB0 function print ( get long long x , return nothing ) ; TAB1 if x < 0 x = - x , print ' - ' ; TAB1 if not x ; TAB2 print char with value 48 ; TAB1 else ; TAB2 wt = 0 , while x ss [ wt ] = x modulo 10 , increment wt , divide x by 10 ; TAB3 do nothing ; TAB2 while wt puchar ( ss [ wt ] + 48 ) , decrement wt ; TAB3 do nothing ; TAB0 n , m = int , a = array of 100010 int ; TAB0 function Find ( get int x , return int ) ; TAB1 l = 1 , r = n , res = 0 , mid = int ; TAB1 while l < = r ; TAB2 mid = l + r > > 1 ; TAB2 if a [ mid ] < = x ; TAB3 res = mid , l = mid + 1 ; TAB2 else ; TAB3 r = mid - 1 ; TAB1 return res ; TAB1 read ( n ) ; TAB1 read ( m ) ; TAB1 for i = 1 to n inclusive read a [ i ] ; TAB1 ans = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 x = Find ( a [ i ] + m ) ; TAB2 if x - i + 1 > = 3 ; TAB3 y = x - i - 1 ; TAB3 add y * ( y + 1 ) / 2 to ans ; TAB1 print ans ;	inline char nc ( ) { return getchar ( ) ; } inline void read ( int & x ) { char c = nc ( ) ; int b = 1 ; for ( ; ! ( c >= ' 0 ' && c <= ' 9 ' ) ; c = nc ( ) ) if ( c == ' - ' ) b = - 1 ; for ( x = 0 ; c >= ' 0 ' && c <= ' 9 ' ; x = x * 10 + c - ' 0 ' , c = nc ( ) ) ; x *= b ; } inline void read ( long long & x ) { char c = nc ( ) ; long long b = 1 ; for ( ; ! ( c >= ' 0 ' && c <= ' 9 ' ) ; c = nc ( ) ) if ( c == ' - ' ) b = - 1 ; for ( x = 0 ; c >= ' 0 ' && c <= ' 9 ' ; x = x * 10 + c - ' 0 ' , c = nc ( ) ) ; x *= b ; } inline int read ( char * s ) { char c = nc ( ) ; int len = 1 ; for ( ; ! ( c >= ' a ' && c <= ' z ' ) ; c = nc ( ) ) if ( c == EOF ) return 0 ; for ( ; ( c >= ' a ' && c <= ' z ' ) ; s [ len ++ ] = c , c = nc ( ) ) ; s [ len ++ ] = ' \0 ' ; return len - 2 ; } inline void read ( char & x ) { for ( x = nc ( ) ; ! ( x >= ' a ' && x <= ' z ' ) ; x = nc ( ) ) ; } int wt , ss [ 19 ] ; inline void print ( int x ) { if ( x < 0 ) x = - x , putchar ( ' - ' ) ; if ( ! x ) putchar ( 48 ) ; else { for ( wt = 0 ; x ; ss [ ++ wt ] = x % 10 , x /= 10 ) ; for ( ; wt ; putchar ( ss [ wt ] + 48 ) , wt -- ) ; } } inline void print ( long long x ) { if ( x < 0 ) x = - x , putchar ( ' - ' ) ; if ( ! x ) putchar ( 48 ) ; else { for ( wt = 0 ; x ; ss [ ++ wt ] = x % 10 , x /= 10 ) ; for ( ; wt ; putchar ( ss [ wt ] + 48 ) , wt -- ) ; } } int n , m , a [ 100010 ] ; int Find ( int x ) { int l = 1 , r = n , res = 0 , mid ; while ( l <= r ) { mid = l + r >> 1 ; if ( a [ mid ] <= x ) res = mid , l = mid + 1 ; else r = mid - 1 ; } return res ; } int main ( ) { read ( n ) ; read ( m ) ; for ( int i = 1 ; i <= n ; i ++ ) read ( a [ i ] ) ; long long ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = Find ( a [ i ] + m ) ; if ( x - i + 1 >= 3 ) { long long y = ( ( long long ) x ) - ( ( long long ) i ) - 1LL ; ans += y * ( y + 1LL ) / 2LL ; } } print ( ans ) , puts ( "  " ) ; return 0 ; }
TAB0 create integers n , i , j , x , y , k1 , k2 , ans ; TAB0 create pair array p1 with size 100001 with pair of integer and integer ; TAB0 create pair array p2 with size 100001 with pair of integer and integer ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read x read y ; TAB2 if x is less than 0 ; TAB3 set first element of p1 [ incrementk1 ] to x ; TAB3 set second element of p1 [ k1 ] to y ; TAB2 if x is greater than 0 ; TAB3 set first element of p2 [ incrementk2 ] to x ; TAB3 set second element of p2 [ k2 ] to y ; TAB1 sort elements from p1 + 1 to p1 + k1 + 1 ; TAB1 reverse sort elements from p1 + 1 to p1 + k1 + 1 ; TAB1 sort elements from p2 + 1 to p2 + k2 + 1 ; TAB1 if k1 is greater than k2 ; TAB2 for i = 1 to k2 inclusive , increment ans by second element of p1 [ i ] + second element of p2 [ i ] ; TAB2 increment ans by second element of p1 [ i ] ; TAB1 if k1 is k2 ; TAB2 for i = 1 to k2 inclusive , increment ans by second element of p1 [ i ] + second element of p2 [ i ] ; TAB1 if k1 is less than k2 ; TAB2 for i = 1 to k1 inclusive , increment ans by second element of p1 [ i ] + second element of p2 [ i ] ; TAB2 increment ans by second element of p2 [ i ] ; TAB1 print ans print newline ;	int n , i , j , x , y , k1 , k2 , ans ; pair < int , int > p1 [ 100001 ] ; pair < int , int > p2 [ 100001 ] ; int main ( ) { cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> x >> y ; if ( x < 0 ) { p1 [ ++ k1 ] . first = x ; p1 [ k1 ] . second = y ; } if ( x > 0 ) { p2 [ ++ k2 ] . first = x ; p2 [ k2 ] . second = y ; } } sort ( p1 + 1 , p1 + k1 + 1 ) ; reverse ( p1 + 1 , p1 + k1 + 1 ) ; sort ( p2 + 1 , p2 + k2 + 1 ) ; if ( k1 > k2 ) { for ( i = 1 ; i <= k2 ; i ++ ) ans += p1 [ i ] . second + p2 [ i ] . second ; ans += p1 [ i ] . second ; } if ( k1 == k2 ) { for ( i = 1 ; i <= k2 ; i ++ ) ans += p1 [ i ] . second + p2 [ i ] . second ; } if ( k1 < k2 ) { for ( i = 1 ; i <= k1 ; i ++ ) ans += p1 [ i ] . second + p2 [ i ] . second ; ans += p2 [ i ] . second ; } cout << ans << endl ; }
TAB0 let s be a string ; TAB0 let i , x , y , z , k , a , b be integers ; TAB1 read s ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is equal to n , increment x by 1 ; TAB2 if s [ i ] is equal to e , increment y by 1 ; TAB2 if s [ i ] is equal to i , increment z by 1 ; TAB2 if s [ i ] is equal to t , increment k by 1 ; TAB1 if x is greater than 2 ; TAB2 a is equal to minimum of 1 + ( x - 3 ) / 2 , y / 3 ; TAB2 b is equal to minimum of z , k ; TAB1 else do the following ; TAB2 print 0 and newline ; TAB1 print minimum of a , b and newline ;	string s ; int i , x , y , z , k , a , b ; int main ( ) { cin >> s ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' n ' ) x ++ ; if ( s [ i ] == ' e ' ) y ++ ; if ( s [ i ] == ' i ' ) z ++ ; if ( s [ i ] == ' t ' ) k ++ ; } if ( x > 2 ) { a = min ( 1 + ( x - 3 ) / 2 , y / 3 ) ; b = min ( z , k ) ; } else { cout << 0 << endl ; return 0 ; } cout << min ( a , b ) << endl ; }
TAB0 a = long long array of size 1024 ; TAB0 in function f taking int n and returning long long ; TAB1 ans = long long with ans = 0 ; TAB1 for i = 1 to 1024 inclusive ; TAB2 if a [ i ] < n ; TAB3 increment ans by a [ i ] * ( a [ i ] - a [ i - 1 ] ) ; TAB2 else ; TAB3 increment ans by a [ i ] * ( n - a [ i - 1 ] ) ; TAB3 break ; TAB1 return ans ; TAB1 set a [ 1 ] to 4 ; TAB1 set a [ 2 ] to 7 ; TAB1 t = int with t = 3 ; TAB1 for i = 1 to 512 ; TAB2 set a [ t ] to a [ i ] * 10 + 4 then increment t ; TAB2 set a [ t ] to a [ i ] * 10 + 7 then increment t ; TAB1 l , r = int ; TAB1 read l then r ; TAB1 print f of r - f of ( l - 1 ) ;	long long a [ 1024 ] ; long long f ( int n ) { long long ans = 0 ; for ( int i = 1 ; i <= 1024 ; i ++ ) { if ( a [ i ] < n ) ans += a [ i ] * ( a [ i ] - a [ i - 1 ] ) ; else { ans += a [ i ] * ( n - a [ i - 1 ] ) ; break ; } } return ans ; } int main ( ) { a [ 1 ] = 4 ; a [ 2 ] = 7 ; int t = 3 ; for ( int i = 1 ; i < 512 ; i ++ ) { a [ t ++ ] = a [ i ] * 10 + 4 ; a [ t ++ ] = a [ i ] * 10 + 7 ; } int l , r ; cin >> l >> r ; cout << f ( r ) - f ( l - 1 ) << endl ; return 0 ; }
TAB0 declare long long integer function maxSubArraySum taking in long long integer array a and long long integer size ; TAB1 let max_so_far , max_ending_here = long long integers with max_so_far = integer minimum value and max_ending_here = 0 ; TAB1 for long long integer i = 0 to size exclusive do the following ; TAB2 set max_ending_here = max_ending_here + a [ i ] ; TAB2 if max_so_far is less than max_ending_here set max_so_far = max_ending_here ; TAB2 if max_so_far is less than 0 set max_ending_here = 0 ; TAB1 return max_so_far ; TAB1 let n = long long integer ; TAB1 read n ; TAB1 let ar , f , s = arrays of long long integers with size of a = n , f = n - 1 and s = n - 1 ; TAB1 read n values into array ar ; TAB1 for long long integer i = 0 to n - 1 exclusive do the following ; TAB2 let long long integer x = abs ( ar [ i ] - ar [ i + 1 ] ) ; TAB2 set f [ i ] = x ; TAB2 let long long integer on = pow ( - 1 , i ) ; TAB2 set f [ i ] = f [ i ] * on ; TAB1 for long long integer i = 0 to n - 1 exclusive do the following ; TAB2 let long long integer x = abs ( ar [ i ] - ar [ i + 1 ] ) ; TAB2 set s [ i ] = x ; TAB2 let long long integer on = pow ( - 1 , i ) ; TAB2 set s [ i ] = s [ i ] * on ; TAB1 let long long integer m1 = result of call maxSubArraySum on f , n - 1 ; TAB1 let long long integer m1 = result of call maxSubArraySum on s , n - 1 ; TAB1 print max of m1 , m2 ;	long long int maxSubArraySum ( long long int a [ ] , long long int size ) { long long int max_so_far = INT_MIN , max_ending_here = 0 ; for ( long long int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { long long int n ; cin >> n ; long long int ar [ n ] , f [ n - 1 ] , s [ n - 1 ] ; for ( long long int i = 0 ; i < n ; ++ i ) cin >> ar [ i ] ; for ( long long int i = 0 ; i < n - 1 ; ++ i ) { long long int x = abs ( ar [ i ] - ar [ i + 1 ] ) ; f [ i ] = x ; long long int on = pow ( - 1 , i ) ; f [ i ] *= on ; } for ( long long int i = 0 ; i < n - 1 ; ++ i ) { long long int x = abs ( ar [ i ] - ar [ i + 1 ] ) ; s [ i ] = x ; long long int on = pow ( - 1 , ( i + 1 ) ) ; s [ i ] *= on ; } long long int m1 = maxSubArraySum ( f , n - 1 ) ; long long int m2 = maxSubArraySum ( s , n - 1 ) ; cout << max ( m1 , m2 ) << " \n " ; return 0 ; }
TAB0 create constant long long linf with linf = 1LL bitshift left 62 ; TAB0 create constant integer iinf with iinf = 1000000009 ; TAB0 create constant double dinf with dinf = 1e15 ; TAB0 create constant integer Mod with Mod = 1e9 + 9 ; TAB0 create constant integer maxn with maxn = 500005 ; TAB0 declare dcmp with double x as argument , returning integer ; TAB1 if absolute value of x is less than or equal to 1e - 9 , return 0 from function ; TAB1 return - 1 if x is less than 0 , else 1 ; TAB0 create integer arrays l , r , s , p , with l size 10 , r size 10 , s size 10 , p size 10 ; TAB0 declare solve with no arguments , returning void ; TAB1 for i = 1 to 4 inclusive , read l [ i ] read s [ i ] read r [ i ] read p [ i ] ; TAB1 if p [ 1 ] and ( s [ 1 ] | | l [ 1 ] | | r [ 1 ] | | s [ 3 ] | | r [ 4 ] | | l [ 2 ] ) ; TAB2 print " YES " print ' \ n ' ; TAB1 else if p [ 2 ] and ( s [ 2 ] | | l [ 2 ] | | r [ 2 ] | | s [ 4 ] | | r [ 1 ] | | l [ 3 ] ) ; TAB2 print " YES " print ' \ n ' ; TAB1 else if p [ 3 ] and ( s [ 1 ] | | s [ 3 ] | | l [ 3 ] | | r [ 3 ] | | r [ 2 ] | | l [ 4 ] ) ; TAB2 print " YES " print ' \ n ' ; TAB1 else if p [ 4 ] and ( s [ 4 ] | | l [ 4 ] | | r [ 4 ] | | s [ 2 ] | | r [ 3 ] | | l [ 1 ] ) ; TAB2 print " YES " print ' \ n ' ; TAB1 else ; TAB2 print " NO " print ' \ n ' ; TAB1 create integer tt with tt = 1 ; TAB1 while decrementing tt , run solve ;	const long long linf = 1LL << 62 ; const int iinf = 1000000009 ; const double dinf = 1e15 ; const int Mod = 1e9 + 9 ; const int maxn = 500005 ; int dcmp ( double x ) { if ( fabs ( x ) <= 1e-9 ) return 0 ; return x < 0 ? - 1 : 1 ; } int l [ 10 ] , r [ 10 ] , s [ 10 ] , p [ 10 ] ; void solve ( ) { for ( int i = 1 ; i <= 4 ; i ++ ) cin >> l [ i ] >> s [ i ] >> r [ i ] >> p [ i ] ; if ( p [ 1 ] && ( s [ 1 ] || l [ 1 ] || r [ 1 ] || s [ 3 ] || r [ 4 ] || l [ 2 ] ) ) cout << " YES " << ' \n ' ; else if ( p [ 2 ] && ( s [ 2 ] || l [ 2 ] || r [ 2 ] || s [ 4 ] || r [ 1 ] || l [ 3 ] ) ) cout << " YES " << ' \n ' ; else if ( p [ 3 ] && ( s [ 1 ] || s [ 3 ] || l [ 3 ] || r [ 3 ] || r [ 2 ] || l [ 4 ] ) ) cout << " YES " << ' \n ' ; else if ( p [ 4 ] && ( s [ 4 ] || l [ 4 ] || r [ 4 ] || s [ 2 ] || r [ 3 ] || l [ 1 ] ) ) cout << " YES " << ' \n ' ; else cout << " NO " << ' \n ' ; } int main ( ) { int tt = 1 ; while ( tt -- ) solve ( ) ; return 0 ; }
TAB0 declare inline key with integers i , j as arguments , returning size_t ; TAB1 return size_t casted i bitshift left 32 bitwise or unsigned integer casted j ; TAB0 declare max with long longs a , b as arguments , returning long long ; TAB1 return a if a is greater than b , else b from function ; TAB0 declare min with long longs a , b as arguments , returning long long ; TAB1 return a if a is less than b , else b from function ; TAB1 create string s ; TAB1 read s ; TAB1 create integer a1 with a1 = - 1 ; TAB1 create integer a2 with a2 = INT_MAX ; TAB1 create integer b1 with b1 = - 1 ; TAB1 create integer b2 with b2 = INT_MAX ; TAB1 create integers a , b , with a = 0 , b = 0 ; TAB1 for i = 0 to length of s - 1 exclusive ; TAB2 if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' ; TAB3 set a1 to maximum of a1 and i ; TAB3 set a2 to maximum of a2 and i ; TAB3 set a to 1 ; TAB2 else if s [ i ] is ' B ' and s [ i + 1 ] is ' A ' ; TAB3 set b1 to maximum of b1 and i ; TAB3 set b2 to minimum of b2 and i ; TAB3 set b to 1 ; TAB1 if a and b and ( a1 is greater than b2 + 1 or b1 is greater than a2 + 1 ) ; TAB2 print " YES \ n " ; TAB1 else ; TAB2 print " NO \ n " ;	inline size_t key ( int i , int j ) { return ( size_t ) i << 32 | ( unsigned int ) j ; } long long max ( long long a , long long b ) { return a > b ? a : b ; } long long min ( long long a , long long b ) { return a < b ? a : b ; } int main ( ) { string s ; cin >> s ; int a1 = - 1 ; int a2 = INT_MAX ; int b1 = - 1 ; int b2 = INT_MAX ; int a = 0 , b = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' ) { a1 = max ( a1 , i ) ; a2 = min ( a2 , i ) ; a = 1 ; } else if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' ) { b1 = max ( b1 , i ) ; b2 = min ( b2 , i ) ; b = 1 ; } } if ( a && b && ( a1 > b2 + 1 || b1 > a2 + 1 ) ) { cout << " YES\n " ; } else { cout << " NO\n " ; } return 0 ; }
TAB0 str is a character array of size 1010 ; TAB1 k , i , j are integers ; TAB1 let flag be an integer ; TAB1 input str , k ; TAB1 assign 0 to flag ; TAB1 assign call strlen with str to len ; TAB1 if len is divisible by k ; TAB2 output NO ; TAB1 else ; TAB2 cnt is an integer set to len / k ; TAB2 for i = 0 to len exclusive with increment i + cnt ; TAB3 for j = 0 to cnt / 2 exclusive ; TAB4 if str [ i + j ] is unequal to str [ cnt + i - j - 1 ] ; TAB5 assign 1 to flag ; TAB5 break ; TAB3 if flag , break ; TAB2 if flag ; TAB3 output NO ; TAB2 else ; TAB3 output YES ;	char str [ 1010 ] ; int main ( ) { int k , i , j ; int flag ; cin >> str >> k ; flag = 0 ; int len = strlen ( str ) ; if ( len % k ) cout << " NO " << endl ; else { int cnt = len / k ; for ( i = 0 ; i < len ; i += cnt ) { for ( j = 0 ; j < cnt / 2 ; j ++ ) { if ( str [ i + j ] != str [ cnt + i - j - 1 ] ) { flag = 1 ; break ; } } if ( flag ) break ; } if ( flag ) cout << " NO " << endl ; else cout << " YES " << endl ; } return 0 ; }
TAB1 n , m = int ; TAB1 k = float ; TAB1 skill_name , new_skill = string ; TAB1 skill_level = int ; TAB1 read n then m then k ; TAB1 skills = map of string and int ; TAB1 for i = 0 to n ; TAB2 read skill_name then skill_level ; TAB2 set skill_level to int ( int ( ( k + 0 . 001 ) * 100 ) * skill_level ) / 100 ; TAB2 if skill_level is greater or equal to 100 then insert result of make_pair of skill_name and skill_level into skills ; TAB1 for i = 0 to m ; TAB2 read new_skill ; TAB2 if skills does not contain new_skill then insert result of make_pair of new_skill and 0 into skills ; TAB1 print size of skills ; TAB1 it = iterator of map of string and int ; TAB1 for it = beginning of skills to end of skills print it - > first and it - > second ;	int main ( ) { int n , m ; float k ; string skill_name , new_skill ; int skill_level ; cin >> n >> m >> k ; map < string , int > skills ; for ( int i = 0 ; i < n ; i ++ ) { cin >> skill_name >> skill_level ; skill_level = int ( int ( ( k + 0.001 ) * 100 ) * skill_level ) / 100 ; if ( skill_level >= 100 ) { skills . insert ( make_pair ( skill_name , ( skill_level ) ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { cin >> new_skill ; if ( skills . find ( new_skill ) == skills . end ( ) ) { skills . insert ( make_pair ( new_skill , 0 ) ) ; } } cout << skills . size ( ) << endl ; map < string , int > :: iterator it ; for ( it = skills . begin ( ) ; it != skills . end ( ) ; ++ it ) { cout << it -> first << "   " << it -> second << endl ; } return 0 ; }
TAB1 m = map from integer to integer ; TAB1 it , bit = iterator map from integer to integer ; TAB1 a , b , c = integers ; TAB1 read a , b ; TAB1 for i = 1 to a ; TAB2 read c ; TAB2 insert make_pair ( i , c ) in m ; TAB1 i = integer with i = 1 ; TAB1 it = m . begin ( ) ; TAB1 while ( m . size ( ) is not 1 ) ; TAB2 bit = it ; TAB2 increment it ; TAB2 if ( bit of second < = b ) ; TAB3 erase bit from m ; TAB2 else ; TAB3 bit of second = bit of second - b ; TAB2 if ( it is m . end ( ) ) , it = m . begin ( ) ; TAB1 it = m . begin ( ) ; TAB1 print it of first ;	int main ( ) { map < int , int > m ; map < int , int > :: iterator it , bit ; int a , b , c ; cin >> a >> b ; for ( int i = 1 ; i <= a ; i ++ ) { cin >> c ; m . insert ( make_pair ( i , c ) ) ; } int i = 1 ; it = m . begin ( ) ; while ( m . size ( ) != 1 ) { bit = it ; it ++ ; if ( bit -> second <= b ) { m . erase ( bit ) ; } else bit -> second -= b ; if ( it == m . end ( ) ) it = m . begin ( ) ; } it = m . begin ( ) ; cout << it -> first << endl ; }
TAB1 n = long long int ; TAB1 read n ; TAB1 if ( n is 1 or n is 2 ) ; TAB2 print n ; TAB1 else ; TAB2 if ( n bitwise and 1 ) ; TAB3 print n * ( n - 1 ) * ( n - 2 ) ; TAB2 else if ( n modulo 3 is 0 ) ; TAB3 print ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; TAB2 else ; TAB3 print n * ( n - 1 ) * ( n - 3 ) ;	int main ( ) { long long int n ; cin >> n ; if ( n == 1 || n == 2 ) cout << n << endl ; else { if ( n & 1 ) cout << n * ( n - 1 ) * ( n - 2 ) << endl ; else if ( n % 3 == 0 ) cout << ( n - 1 ) * ( n - 2 ) * ( n - 3 ) << endl ; else cout << n * ( n - 1 ) * ( n - 3 ) << endl ; } return 0 ; }
TAB1 declare character s size 100010 ; TAB1 read string into s ; TAB1 declare integer i = 0 ; TAB1 declare integer k = 0 ; TAB1 for i = 0 to s [ i ] is not ' \ 0 ' , incrementing i ; TAB2 if s [ i ] is not ' a ' , end loop ; TAB1 for s [ i ] is not ' \ 0 ' , incrementing i ; TAB2 if s [ i ] is ' a ' , end loop ; TAB2 decrement s [ i ] ; TAB2 increment k ; TAB1 if k is 0 , let s [ string length of s - 1 ] be ' z ' ; TAB1 print s ;	int main ( ) { char s [ 100010 ] ; gets ( s ) ; int i = 0 ; int k = 0 ; for ( i = 0 ; s [ i ] != ' \0 ' ; i ++ ) if ( s [ i ] != ' a ' ) break ; for ( ; s [ i ] != ' \0 ' ; i ++ ) { if ( s [ i ] == ' a ' ) break ; s [ i ] -- ; k ++ ; } if ( k == 0 ) s [ strlen ( s ) - 1 ] = ' z ' ; puts ( s ) ; return 0 ; }
TAB1 declare ints a , b , c , d , e and f ; TAB1 read a , b , c , d , e and f from the user input ; TAB1 if b * d * f is greater than a * c * e or c = 0 and d > 0 or a = 0 and b > 0 and d > 0 ; TAB2 print " Ron " to the standard output ; TAB1 else ; TAB2 print " Hermione " ;	int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( b * d * f > a * c * e or c == 0 and d > 0 or a == 0 and b > 0 and d > 0 ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB1 a = integer ; TAB1 read a ; TAB1 arr = array of integer of size n ; TAB1 read n values into array arr ; TAB1 ans = integer with value 0 ; TAB1 for i = 0 to a exclusive ; TAB2 create integer sum = 0 ; TAB2 if arr [ i ] is 1 then add 1 to sum ; TAB2 create integer e = arr [ i ] ; TAB2 while i < a and arr [ i ] = e ; TAB3 add 1 to i ; TAB3 set e = e + 1 ; TAB3 increment sum ; TAB2 if e = 1001 then increment sum ; TAB2 set ans to maximum of ans and sum - 2 ; TAB2 decrement i ; TAB1 print ans and new line ;	int main ( ) { int a ; cin >> a ; int arr [ a ] ; for ( int i = 0 ; i < a ; i ++ ) cin >> arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < a ; i ++ ) { int sum = 0 ; if ( arr [ i ] == 1 ) sum ++ ; int e = arr [ i ] ; while ( i < a && arr [ i ] == e ) { i ++ ; e ++ ; sum ++ ; } if ( e == 1001 ) sum ++ ; ans = max ( ans , sum - 2 ) ; i -- ; } cout << ans << endl ; return 0 ; }
TAB0 make const int MAX = 105 ; TAB0 create char ss of size MAX ; TAB0 make ints n and k ; TAB1 read n and k ; TAB1 create char s = ' a ' ; TAB1 make ints p and j = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 set ss [ i ] to s + ( j % k ) ; TAB2 increment j ; TAB1 print ss ;	const int MAX = 105 ; char ss [ MAX ] ; int n , k ; int main ( ) { cin >> n >> k ; char s = ' a ' ; int p , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ss [ i ] = s + ( j % k ) ; j ++ ; } cout << ss << endl ; return 0 ; }
TAB0 declare int variables n and m , and an array of ints num with size 550 ; TAB1 create integers u , v , w , i and j ; TAB1 read n and m and keep looping ; TAB2 set first sizeofnum bytes at the pointer num to 0 ; TAB2 create new double variable maxx with value 0 ; TAB2 in a for loop , change i from 1 to n inclusive , read num [ i ] from the user input on each loop ; TAB2 start for loop from i = 0 to m exclusive incrementing i ; TAB3 read u , v and w from the user input ; TAB3 set maxx to max of maxx and ( num [ u ] + num [ v ] ) / w ; TAB2 set output precision to 15 , floatfield format flag and print maxx ;	int n , m , num [ 550 ] ; int main ( ) { int u , v , w , i , j ; while ( cin >> n >> m ) { memset ( num , 0 , sizeof num ) ; double maxx = 0 ; for ( i = 1 ; i <= n ; i ++ ) cin >> num [ i ] ; for ( i = 0 ; i < m ; i ++ ) { cin >> u >> v >> w ; maxx = max ( maxx , ( num [ u ] + num [ v ] ) / ( double ) w ) ; } cout << fixed << setprecision ( 15 ) << maxx << endl ; } return 0 ; }
TAB0 let MOD a constant long long with value 1e9 + 9LL ; TAB0 let s a string ; TAB0 let n , a , b , and k long longs ; TAB0 in function MODULUS which takes long longs b and p and returns a long long ; TAB1 let ret a long long with value 1LL ; TAB1 while p ; TAB2 if p & 1LL , set ret to ( ret * b ) mod MOD ; TAB2 set b to ( b * b ) mod MOD1 ; TAB2 right shift p by 1LL ; TAB1 return ret ; TAB0 in function MODINVERSE which takes long long x and returns a long long ; TAB1 return MODULUS applied to x and MOD - 2LL ; TAB0 in function Add which takes long longs x and y and returns a long long ; TAB1 add y to x ; TAB1 if x > MOD , return x - MOD ; TAB1 return x ; TAB0 in function Sub which takes long longs x and y and returns a long long ; TAB1 subtract y from x ; TAB1 if x < 0 , return x + MOD ; TAB1 return x ; TAB0 in function MUL which takes long longs x and y and returns a long long ; TAB1 multiply x by y ; TAB1 return x mod MOD ; TAB0 in function Div which takes long longs x and y and returns a long long ; TAB1 return ( x * MODINVERSE ( y ) ) mod MOD ; TAB1 read n , a , b , k , and s ; TAB1 let ans a long long with value 0LL ; TAB1 let x a long long with value Div ( b , a ) ; TAB1 let c a long long with value MODULUS ( a , n ) ; TAB1 for i from 0 to k exclusive ; TAB2 if s [ i ] is + ; TAB3 set ans to Add ( ans , c ) ; TAB2 otherwise ; TAB3 set ans to Sub ( ans , c ) ; TAB2 set c to Mul ( c , x ) ; TAB1 if ans is negative , add MOD to ans ; TAB1 set x to MODULUS ( x , k ) ; TAB1 if x is 1 ; TAB2 set ans to Mul ( ans , ( n + 1 ) / k ) ; TAB1 otherwise ; TAB2 set ans to Mul applied to ans and Sub ( MODULUS ( x , ( n + 1 ) / k ) , 1 ) ; TAB2 set ans to Div ( ans , Sub ( x , 1 ) ) ; TAB1 print ans mod MOD ;	long long const MOD = 1e9 + 9LL ; string s ; long long n , a , b , k ; long long MODULUS ( long long b , long long p ) { long long ret = 1LL ; while ( p ) { if ( p & 1LL ) ret = ( ret * b ) % MOD ; b = ( b * b ) % MOD ; p >>= 1LL ; } return ret ; } long long MODINVERSE ( long long x ) { return MODULUS ( x , MOD - 2LL ) ; } long long Add ( long long x , long long y ) { x += y ; if ( x > MOD ) return x - MOD ; return x ; } long long Sub ( long long x , long long y ) { x -= y ; if ( x < 0 ) return x + MOD ; return x ; } long long Mul ( long long x , long long y ) { x *= y ; return x % MOD ; } long long Div ( long long x , long long y ) { return ( x * MODINVERSE ( y ) ) % MOD ; } int main ( ) { cin >> n >> a >> b >> k >> s ; long long ans = 0LL ; long long x = Div ( b , a ) ; long long c = MODULUS ( a , n ) ; for ( int i = 0 ; i < k ; i += 1 ) { if ( s [ i ] == ' + ' ) { ans = Add ( ans , c ) ; } else { ans = Sub ( ans , c ) ; } c = Mul ( c , x ) ; } if ( ans < 0 ) ans += MOD ; x = MODULUS ( x , k ) ; if ( x == 1 ) { ans = Mul ( ans , ( n + 1 ) / k ) ; } else { ans = Mul ( ans , Sub ( MODULUS ( x , ( n + 1 ) / k ) , 1 ) ) ; ans = Div ( ans , Sub ( x , 1 ) ) ; } cout << ans % MOD << ' \n ' ; return 0 ; }
TAB1 n = unsigned long long integer ; TAB1 read n ; TAB1 if n < = 127 ; TAB2 print byte ; TAB1 else if n < = 32767 ; TAB2 print short ; TAB1 else if n < = 2147483647 ; TAB2 print int ; TAB1 else if n < = 9223372036854775807 ; TAB2 print long ; TAB1 else ; TAB2 print BigInteger ;	int main ( ) { unsigned long long int n ; cin >> n ; if ( n <= 127 ) cout << " byte\n " ; else if ( n <= 32767 ) cout << " short\n " ; else if ( n <= 2147483647 ) cout << " int\n " ; else if ( n <= 9223372036854775807 ) cout << " long\n " ; else cout << " BigInteger\n " ; return 0 ; }
TAB1 integers = x , y , s , z ; TAB1 read x , y , s ; TAB1 make z equal to abs ( x ) + abs ( y ) ; TAB1 if z is greater than s then do the following cout < < No < < endl ; TAB1 if z is s then do the following cout < < Yes < < endl ; TAB1 if z is less than s then do the following ; TAB2 if is 0 then do the following ; TAB3 output Yes ; TAB2 else ; TAB3 output No ;	int main ( ) { int x , y , s , z ; cin >> x >> y >> s ; z = abs ( x ) + abs ( y ) ; if ( z > s ) cout << " No " << endl ; if ( z == s ) cout << " Yes " << endl ; if ( z < s ) { if ( ( s - z ) % 2 == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
TAB0 N = const integer with N = 2e6 ; TAB0 prime = bool array of size N ; TAB0 in the function Prime ; TAB1 set all contents of prime to 0 ; TAB1 prime [ 1 ] = 1 ; TAB1 for i = 2 to N exclusive ; TAB2 if ( not prime [ i ] ) ; TAB3 for j = i * 2 to N with j = j + i , prime [ j ] = 1 ; TAB0 in the function is_palindromic that takes integer n and returns bool ; TAB1 t = integer with t = n ; TAB1 fn = integer with fn = 0 ; TAB1 while ( t ) ; TAB2 fn = fn * 10 ; TAB2 fn = fn + t modulo 10 ; TAB2 t = t / 10 ; TAB1 return n is fn ; TAB1 p , q = double ; TAB1 A = double ; TAB1 call Prime ; TAB1 while read p , q ; TAB2 ans = integer with ans = - 1 ; TAB2 A = p / q ; TAB2 pi = integer with pi = 0 ; TAB2 pa = integer with pa = 0 ; TAB2 for i = 1 to N exclusive ; TAB3 if ( not prime [ i ] ) , increment pi ; TAB3 pa = pa + is_palindromic ( i ) ; TAB3 if ( pi < = pa * A ) , ans = i ; TAB2 if ( ans is - 1 ) ; TAB3 print Palindromic tree is better than splay tree ; TAB2 else ; TAB3 print ans ;	const int N = 2e6 ; bool prime [ N ] ; void Prime ( ) { memset ( prime , 0 , sizeof ( prime ) ) ; prime [ 1 ] = 1 ; for ( int i = 2 ; i < N ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = 1 ; } } } } bool is_palindromic ( int n ) { int t = n ; int fn = 0 ; while ( t ) { fn *= 10 ; fn += t % 10 ; t /= 10 ; } return n == fn ; } int main ( ) { double p , q ; double A ; Prime ( ) ; while ( cin >> p >> q ) { int ans = - 1 ; A = p / q ; int pi = 0 ; int pa = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ! prime [ i ] ) pi ++ ; pa += is_palindromic ( i ) ; if ( pi <= pa * A ) ans = i ; } if ( ans == - 1 ) cout << " Palindromic tree is better than splay tree " << endl ; else cout << ans << endl ; } }
TAB0 make const int MX = 100005 ; TAB0 create int n ; TAB0 make pair array of int and int a of size MX ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] . first and a [ i ] . second ; TAB1 sort a using a + n ; TAB1 create ints i = 0 , j = 0 , and acu = 0 ; TAB1 while i is less than n ; TAB2 set j to a [ i ] . first ; TAB2 set acu to max of acu and a [ i ] . second ; TAB2 while acu is greater than 1 and ( i + 1 is equal to n or j is less than a [ i + 1 ] . first ) ; TAB3 set acu to ( acu + 3 ) / 4 ; TAB3 increment j ; TAB2 add 1 to i ; TAB1 print max of j and a [ n - 1 ] . first + 1 ;	const int MX = 100005 ; int n ; pair < int , int > a [ MX ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] . first >> a [ i ] . second ; sort ( a , a + n ) ; int i = 0 , j = 0 , acu = 0 ; while ( i < n ) { j = a [ i ] . first ; acu = max ( acu , a [ i ] . second ) ; while ( acu > 1 && ( i + 1 == n || j < a [ i + 1 ] . first ) ) { acu = ( acu + 3 ) / 4 ; j ++ ; } i ++ ; } cout << max ( j , a [ n - 1 ] . first + 1 ) << ' \n ' ; return 0 ; }
TAB0 a = long long array of size 500000 + 5000 ; TAB0 in function isvowel taking char a and returning bool ; TAB1 return a is ' a ' or ' E ' or ' I ' or ' O ' or ' U ' or ' Y ' ; TAB1 n = string ; TAB1 read n ; TAB1 ans , lastpos = long long with ans = - 1 and lastpos = - 1 ; TAB1 for i = 0 to size of n ; TAB2 if isvowel of n [ i ] set ans to max of ans , i - lastpos then set lastpos to i ; TAB1 set ans to max of ans , size of n as long long - lastpos ; TAB1 print ans ;	long long a [ 500000 + 5000 ] ; bool isvowel ( char a ) { return a == ' A ' || a == ' E ' || a == ' I ' || a == ' O ' || a == ' U ' || a == ' Y ' ; } int main ( ) { string n ; cin >> n ; long long ans = - 1 , lastpos = - 1 ; for ( int i = 0 ; i < n . size ( ) ; i ++ ) { if ( isvowel ( n [ i ] ) ) ans = max ( ans , i - lastpos ) , lastpos = i ; } ans = max ( ans , ( long long ) n . size ( ) - lastpos ) ; cout << ans << endl ; return 0 ; }
TAB0 declare constant long longs mod = 1e9 + 7 , maxn = 1e4 + 100 ; TAB0 declare long long array a size maxn ; TAB1 declare long longs n , m , k ; TAB1 read n , m , k ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 for n % 2 is 0 , return print 0 and newline , 0 ; TAB1 declare long long op = m / ( ( n + 1 ) / 2 ) ; TAB1 let op = op * k ; TAB1 declare long long minn = 1000 * 1000 * 1000 ; TAB1 for i = 1 to n inclusive , incrementing i by 2 , let minn be minimum of minn and a [ i ] ; TAB1 print minimum of minn and op , newline ;	const long long mod = 1e9 + 7 , maxn = 1e4 + 100 ; long long a [ maxn ] ; int main ( ) { long long n , m , k ; cin >> n >> m >> k ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; if ( n % 2 == 0 ) return cout << 0 << endl , 0 ; long long op = m / ( ( n + 1 ) / 2 ) ; op *= k ; long long minn = 1000 * 1000 * 1000 ; for ( int i = 1 ; i <= n ; i += 2 ) minn = min ( minn , a [ i ] ) ; cout << min ( minn , op ) << endl ; }
TAB0 create integers n , i , j , sum , nom and integer arrays a with size 1001 , b with size 1001 , c with size 1001 and 1001 ; TAB1 read n ; TAB1 for integer i = 1 to n with increment i ; TAB2 for integer j = 1 to 4 with increment j do read c [ i ] [ j ] ; TAB1 for integer i = 1 to n with increment i ; TAB2 set sum to 0 ; TAB2 for integer j = 1 to 4 with increment j do add c [ i ] [ j ] to sum ; TAB2 set a [ i ] to sum ; TAB2 set b [ i ] to i ; TAB1 for integer j = 1 to n with increment j ; TAB2 for integer i = j to n - 1 with increment i ; TAB3 if a [ j ] is less than a [ i + 1 ] then ; TAB4 swap a [ j ] and a [ i + 1 ] ; TAB4 swap b [ j ] and b [ i + 1 ] ; TAB3 else if a [ j ] is equal to a [ i + 1 ] then ; TAB4 if b [ j ] is greater than b [ i + 1 ] then swap b [ j ] and b [ i + 1 ] ; TAB1 for integer i = 1 to n with increment i ; TAB2 if b [ i ] is equal to 1 then ; TAB3 set nom to i ; TAB3 break the loop ; TAB1 print nom ;	int c [ 1001 ] [ 1001 ] , a [ 1001 ] , b [ 1001 ] , n , i , j , sum , nom ; int main ( ) { cin >> n ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= 4 ; j ++ ) cin >> c [ i ] [ j ] ; for ( i = 1 ; i <= n ; i ++ ) { sum = 0 ; for ( j = 1 ; j <= 4 ; j ++ ) sum += c [ i ] [ j ] ; a [ i ] = sum ; b [ i ] = i ; } for ( j = 1 ; j <= n ; j ++ ) for ( i = j ; i <= n - 1 ; i ++ ) if ( a [ j ] < a [ i + 1 ] ) { swap ( a [ j ] , a [ i + 1 ] ) ; swap ( b [ j ] , b [ i + 1 ] ) ; } else if ( a [ j ] == a [ i + 1 ] ) { if ( b [ j ] > b [ i + 1 ] ) swap ( b [ j ] , b [ i + 1 ] ) ; } for ( i = 1 ; i <= n ; i ++ ) if ( b [ i ] == 1 ) { nom = i ; break ; } cout << nom << " \n " ; return 0 ; }
TAB0 declare integers n , i , j , k , x , y , z , m , q , h , r , timer , mx , l , cnt , u , v , t , s , tot ; TAB1 declare integers a , b , c , d , e , f ; TAB1 read a and b and c and d and e and f ; TAB1 if c is 0 and d is greater than 0 or a is 0 and b * d is greater than 0 or a * c * e is less than b * d * f ; TAB2 print " Ron " , newline ; TAB1 else ; TAB2 print " Hermione " , newline ;	int n , i , j , k , x , y , z , m , q , h , r , timer , mx , l , cnt , u , v , t , s , tot ; int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( c == 0 && d > 0 || a == 0 && b * d > 0 || a * c * e < b * d * f ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB0 let a1 , a2 , n , k , second , ans , and ans1 be long long ints with second = 0 and ans = 0 ; TAB0 let h be a vector of pairs of long longs and pairs of long longs and long longs ; TAB0 in function read ; TAB1 read n ; TAB1 for i = 0 to n exclusive with x , y , m ints ; TAB2 read k ; TAB2 set second to second + k ; TAB2 read a1 ; TAB2 let t be a long long int with value a1 ; TAB2 read x and y and m ; TAB2 append the pair 0 and the pair a1 and i + 1 to h ; TAB2 set ans1 to 0 ; TAB2 for j = 1 to k exclusive with j preincremented ; TAB3 set a2 to ( a1 * x + y ) mod m ; TAB3 if a2 is less than a1 increment ans1 ; TAB3 set a1 to a2 ; TAB3 set t to max of t and a1 ; TAB3 if size of h is less than or equal to 200000 append the pair ans1 and pair a1 and i + 1 to h ; TAB2 set ans to max of ans and ans1 ; TAB1 sort h ; TAB1 print ans and newline ; TAB1 if second is less than or equal to 200000 ; TAB2 for i = 0 to second inclusive with i preincremented , print the first item of the second item in h [ i ] followed by space and the second item of the second item in h [ i ] and then newline ; TAB1 call read ;	long long a1 , a2 , n , k , second = 0 , ans = 0 , ans1 ; vector < pair < long long , pair < long long , long long >> > h ; void read ( void ) { cin >> n ; for ( int i = 0 , x , y , m ; i < n ; ++ i ) { cin >> k ; second += k ; cin >> a1 ; long long t = a1 ; cin >> x >> y >> m ; h . push_back ( make_pair ( 0 , make_pair ( a1 , i + 1 ) ) ) ; ans1 = 0 ; for ( int j = 1 ; j < k ; ++ j ) { a2 = ( a1 * x + y ) % m ; if ( a2 < a1 ) ans1 ++ ; a1 = a2 ; t = max ( t , a1 ) ; if ( h . size ( ) <= 200000 ) h . push_back ( make_pair ( ans1 , make_pair ( a1 , i + 1 ) ) ) ; } ans = max ( ans , ans1 ) ; } sort ( h . begin ( ) , h . end ( ) ) ; cout << ans << " \n " ; if ( second <= 200000 ) for ( int i = 0 ; i < second ; ++ i ) cout << h [ i ] . second . first << "   " << h [ i ] . second . second << " \n " ; } int main ( ) { read ( ) ; return 0 ; }
TAB1 declare integers n , m , a , k = 0 , id = 0 , t ; TAB1 read n and m ; TAB1 for i = 1 to n inclusive ; TAB2 read a ; TAB2 let t be ( a - 1 ) / m + 1 ; TAB2 if t is greater than or equal to k ; TAB3 let k be t ; TAB3 let id be i ; TAB1 print id and newline ;	int main ( ) { int n , m , a , k = 0 , id = 0 , t ; cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a ; t = ( a - 1 ) / m + 1 ; if ( t >= k ) { k = t ; id = i ; } } cout << id << endl ; return 0 ; }
TAB1 create a map called m using string and integer ; TAB1 set m [ C ] to 0 ; TAB1 set m [ C # ] to 1 ; TAB1 set m [ D ] to 2 ; TAB1 set m [ D # ] to 3 ; TAB1 set m [ E ] to 4 ; TAB1 set m [ F ] to 5 ; TAB1 set m [ F # ] to 6 ; TAB1 set m [ G ] to 7 ; TAB1 set m [ G # ] to 8 ; TAB1 set m [ A ] to 9 ; TAB1 set m [ B ] to 10 ; TAB1 set m [ H ] to 11 ; TAB1 s = string array ; TAB1 integer as array a with size 3 ; TAB1 for i = 0 to less than 3 do the following ; TAB2 read s ; TAB2 set a [ i ] to m [ s ] ; TAB1 sort the values of a to a + 3 ; TAB1 integer as x = ( a [ 1 ] - a [ 0 ] + 12 ) modulo 12 ; TAB1 integer as y = ( a [ 2 ] - a [ 1 ] + 12 ) modulo 12 ; TAB1 integer as z = ( a [ 0 ] - a [ 2 ] + 12 ) modulo 12 ; TAB1 if is 3 and y then do the following ; TAB2 output minor ; TAB1 else if x is 4 and yis 3 or y is 4 and z is 3 or zis 4 and x is 3 then do the following ; TAB2 output major ; TAB1 else ; TAB2 output strange ;	int main ( ) { map < string , int > m ; m [ " C " ] = 0 ; m [ " C# " ] = 1 ; m [ " D " ] = 2 ; m [ " D# " ] = 3 ; m [ " E " ] = 4 ; m [ " F " ] = 5 ; m [ " F# " ] = 6 ; m [ " G " ] = 7 ; m [ " G# " ] = 8 ; m [ " A " ] = 9 ; m [ " B " ] = 10 ; m [ " H " ] = 11 ; string s ; int a [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { cin >> s ; a [ i ] = m [ s ] ; } sort ( a , a + 3 ) ; int x = ( a [ 1 ] - a [ 0 ] + 12 ) % 12 ; int y = ( a [ 2 ] - a [ 1 ] + 12 ) % 12 ; int z = ( a [ 0 ] - a [ 2 ] + 12 ) % 12 ; if ( ( x == 3 && y == 4 ) || ( y == 3 && z == 4 ) || ( x == 4 && z == 3 ) ) { cout << " minor " << endl ; } else if ( ( x == 4 && y == 3 ) || ( y == 4 && z == 3 ) || ( z == 4 && x == 3 ) ) { cout << " major " << endl ; } else { cout << " strange " << endl ; } return 0 ; }
TAB0 in the function search which takes an integer array A and integers l , u , target and returns an integer ; TAB1 for i = 1 to u exclusive ; TAB2 if A [ i ] = target then return i ; TAB1 return - 1 ; TAB1 n , C = integers ; TAB1 read n and C ; TAB1 R = array of integers of size n ; TAB1 read n values into array R ; TAB1 B = array of integer of size C ; TAB1 Create integer curr_size = 0 ; TAB1 Create integer ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 create integer idx = search ( B , 0 , curr_size , R [ i ] ) ; TAB2 if idx is not - 1 then continue ; TAB2 add 1 to ans ; TAB2 if curr_size is less than C ; TAB3 set B [ curr_size ] = R [ i ] ; TAB3 increment curr_size ; TAB2 else do the following ; TAB3 set idx to 0 ; TAB3 create integer d = search ( R , i + 1 , n , B [ idx ] ) ; TAB3 if d is not - 1 ; TAB4 for j = 1 to C exclusive ; TAB5 create integer curr_d = search ( R , i + 1 , n , B [ j ] ) ; TAB5 if curr_d is equal to - 1 ; TAB6 set d to curr_d ; TAB6 set idx to j ; TAB6 break ; TAB5 else do the following ; TAB6 if curr_d is greater than d ; TAB7 assign curr_d to d ; TAB7 set idx = j ; TAB3 set B [ idx ] = R [ i ] ; TAB1 print ans ;	int search ( int A [ ] , int l , int u , int target ) { for ( int i = l ; i < u ; i ++ ) { if ( A [ i ] == target ) return i ; } return - 1 ; } int main ( ) { int n , C ; cin >> n >> C ; int R [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cin >> R [ i ] ; int B [ C ] ; int curr_size = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int idx = search ( B , 0 , curr_size , R [ i ] ) ; if ( idx != - 1 ) continue ; ans ++ ; if ( curr_size < C ) { B [ curr_size ] = R [ i ] ; curr_size ++ ; } else { idx = 0 ; int d = search ( R , i + 1 , n , B [ idx ] ) ; if ( d != - 1 ) { for ( int j = 1 ; j < C ; j ++ ) { int curr_d = search ( R , i + 1 , n , B [ j ] ) ; if ( curr_d == - 1 ) { d = curr_d ; idx = j ; break ; } else { if ( curr_d > d ) { d = curr_d ; idx = j ; } } } } B [ idx ] = R [ i ] ; } } cout << ans << endl ; return 0 ; }
TAB1 let n be a long integer ; TAB1 read n ; TAB1 let s be a string ; TAB1 read s ; TAB1 let f be a long integer with f = 0 ; TAB1 for long integer i = 0 to n exclusive ; TAB2 if s [ i ] is equal to 1 , f is equal to 1 ; TAB1 let second be a string ; TAB1 if f is equal to 1 , push back element 1 in second ; TAB1 for long integer i = 0 to n exclusive ; TAB2 if s [ i ] is equal to 0 , push back element 0 in second ; TAB1 print second and newline ;	int main ( ) { long long n ; cin >> n ; string s ; cin >> s ; long long f = 0 ; for ( long long i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 1 ' ) f = 1 ; } string second ; if ( f == 1 ) second . push_back ( ' 1 ' ) ; for ( long long i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 0 ' ) second . push_back ( ' 0 ' ) ; } cout << second << endl ; return 0 ; }
TAB0 dx = integer array with element in the following order : 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1 ; TAB0 dy = integer array with element in the following order : 1 , 0 , - 1 , 0 , 1 , - 1 , 1 , - 1 ; TAB0 in function fast the returns nothing ; TAB0 arr = 4 pairs of strings ; TAB1 call fast ; TAB1 s = string ; TAB1 out = string array with the following elements = byte , short , int , long , BigInteger ; TAB1 read s ; TAB1 arr [ 0 ] = - 128 , 127 ; TAB1 arr [ 1 ] = - 32768 , 32767 ; TAB1 arr [ 2 ] = - 2147483648 , 2147483647 ; TAB1 arr [ 3 ] = - 9223372036854775808 , 9223372036854775807 ; TAB1 if s [ 0 ] is - ; TAB2 for i = 0 to 4 exclusive ; TAB3 if size of s < size of first letter of arr [ i ] , then return print out i ; TAB3 ; ; TAB3 if size of s = size of first letter of arr [ i ] ; TAB4 for j = 1 to size of s exclusive ; TAB5 if s [ j ] > first j of arr [ i ] , then return print out [ i + 1 ] 0 ; TAB5 ; ; TAB5 if s [ j ] > second j of arr [ i ] , then return print out [ i ] 0 ; TAB5 return print out [ i ] 0 ; TAB4 return print out [ i ] 0 ; TAB4 ; ; TAB2 return print out [ 4 ] 0 ; TAB2 ; ; TAB1 else ; TAB2 for i = 0 to 4 exclusive ; TAB3 if size of s < second letter of arr [ i ] , then return print out [ i ] 0 ; TAB3 ; ; TAB3 if size of s is second letter of arr [ i ] , then return print out [ i ] 0 ; TAB4 for j = 0 to size of s exclusive ; TAB5 if s [ j ] > second j of arr [ i ] , then return print out [ i + 1 ] 0 ; TAB5 ; ; TAB5 if s [ j ] < second j of arr [ i ] , then return print out [ i ] 0 ; TAB5 ; ; TAB4 return print out [ i ] 0 ; TAB4 ; ; TAB2 print out [ 4 ] 0 ; TAB2 ; ;	int dx [ ] = { 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1 } ; int dy [ ] = { 1 , 0 , - 1 , 0 , 1 , - 1 , 1 , - 1 } ; void fast ( ) { } pair < string , string > arr [ 4 ] ; int main ( ) { fast ( ) ; string s ; string out [ ] = { " byte " , " short " , " int " , " long " , " BigInteger " } ; cin >> s ; arr [ 0 ] = { " -128 " , " 127 " } ; arr [ 1 ] = { " -32768 " , " 32767 " } ; arr [ 2 ] = { " -2147483648 " , " 2147483647 " } ; arr [ 3 ] = { " -9223372036854775808 " , " 9223372036854775807 " } ; if ( s [ 0 ] == ' - ' ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( s . size ( ) < arr [ i ] . first . size ( ) ) return cout << out [ i ] << " \n " , 0 ; ; if ( s . size ( ) == arr [ i ] . first . size ( ) ) { for ( int j = 1 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] > arr [ i ] . first [ j ] ) return cout << out [ i + 1 ] << " \n " , 0 ; ; if ( s [ j ] < arr [ i ] . second [ j ] ) return cout << out [ i ] << " \n " , 0 ; ; } return cout << out [ i ] << " \n " , 0 ; ; } } return cout << out [ 4 ] << " \n " , 0 ; ; } else { for ( int i = 0 ; i < 4 ; i ++ ) { if ( s . size ( ) < arr [ i ] . second . size ( ) ) return cout << out [ i ] << " \n " , 0 ; ; if ( s . size ( ) == arr [ i ] . second . size ( ) ) { for ( int j = 0 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] > arr [ i ] . second [ j ] ) return cout << out [ i + 1 ] << " \n " , 0 ; ; if ( s [ j ] < arr [ i ] . second [ j ] ) return cout << out [ i ] << " \n " , 0 ; ; } return cout << out [ i ] << " \n " , 0 ; ; } } return cout << out [ 4 ] << " \n " , 0 ; ; } }
TAB0 l = long long array of size 100009 ; TAB1 for i = 1 to 100004 , l [ i ] = i * ( i + 1 ) / 2 ; TAB1 n = integer ; TAB1 read n ; TAB1 k , r = long long with k = 1 , r = 100000 ; TAB1 while k < = r ; TAB2 if l [ k ] + l [ r ] is n ; TAB3 print YES ; TAB2 else if l [ k ] + l [ r ] < n ; TAB3 increment k ; TAB2 else ; TAB3 decrement r ; TAB1 print NO ;	long long l [ 100009 ] ; int main ( ) { for ( long long i = 1 ; i < 100005 ; i ++ ) { l [ i ] = i * ( i + 1 ) / 2 ; } int n ; cin >> n ; long long k = 1 , r = 100000 ; while ( k <= r ) { if ( l [ k ] + l [ r ] == n ) { cout << " YES " << endl ; return 0 ; } else if ( l [ k ] + l [ r ] < n ) { k ++ ; } else { r -- ; } } cout << " NO " << endl ; return 0 ; }
TAB0 declare constant integer Maxn = 1e5 + 100 ; TAB0 declare integers n , m , integer array a size Maxn ; TAB0 declare boolean array mark size 2 by Maxn ; TAB0 declare integer vector nei size 2 by Maxn ; TAB0 delare dfs initialized with integers x and v ; TAB1 for i = 0 to integer casted size of nei [ x ] [ v ] exclusive ; TAB2 declare integer u = nei [ x ] [ v ] [ i ] ; TAB2 if not mark [ x ] [ u ] ; TAB3 let mark [ x ] [ u ] be true ; TAB3 if x is 0 or a [ u ] is not 1 , run dfs with x , u as arguments ; TAB1 read n and m ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 for i = 0 , u , v to m exclusive ; TAB2 read u and v ; TAB2 add ( v - 1 ) to end of nei [ 0 ] [ u - 1 ] ; TAB2 add ( u - 1 ) to end of nei [ 1 ] [ v - 1 ] ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is 1 and not mark [ 0 ] [ i ] ; TAB3 let mark [ 0 ] [ i ] be true , run dfs with 0 , i as arguments ; TAB2 else if a [ i ] is 2 and not mark [ 1 ] [ i ] ; TAB3 let mark [ 1 ] [ i ] be true , run dfs ( 1 , i ) ; TAB1 for i = 0 to n exclusive ; TAB2 if mark [ 0 ] [ i ] and mark [ 1 ] [ i ] ; TAB3 print 1 and newline ; TAB2 else ; TAB3 print 0 and newline ;	const int Maxn = 1e5 + 100 ; int n , m , a [ Maxn ] ; bool mark [ 2 ] [ Maxn ] ; vector < int > nei [ 2 ] [ Maxn ] ; void dfs ( int x , int v ) { for ( int i = 0 ; i < ( int ) nei [ x ] [ v ] . size ( ) ; i ++ ) { int u = nei [ x ] [ v ] [ i ] ; if ( ! mark [ x ] [ u ] ) { mark [ x ] [ u ] = true ; if ( x == 0 || a [ u ] != 1 ) dfs ( x , u ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 0 , u , v ; i < m ; i ++ ) { cin >> u >> v ; nei [ 0 ] [ u - 1 ] . push_back ( v - 1 ) ; nei [ 1 ] [ v - 1 ] . push_back ( u - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 && ! mark [ 0 ] [ i ] ) mark [ 0 ] [ i ] = true , dfs ( 0 , i ) ; else if ( a [ i ] == 2 && ! mark [ 1 ] [ i ] ) mark [ 1 ] [ i ] = true , dfs ( 1 , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mark [ 0 ] [ i ] && mark [ 1 ] [ i ] ) cout << 1 << endl ; else cout << 0 << endl ; } }
TAB1 create ints n and k ; TAB1 declare string s ; TAB1 read n and k ; TAB1 read s ; TAB1 declare string variables a and b ; TAB1 declare int flag = 0 ; TAB1 for integer i = 0 to n - 1 exclusive ; TAB2 if substring of a from the start to i + 1 = substring of n from position n - i - 1 to the end , set flag to i + 1 ; TAB1 print s ; TAB1 loop i from 1 to k exclusive , print substring of from position flag to the end ; TAB1 print new line ;	int main ( ) { int n , k ; string s ; cin >> n >> k ; cin >> s ; string a , b ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . substr ( 0 , i + 1 ) == s . substr ( n - i - 1 ) ) { flag = i + 1 ; } } cout << s ; for ( int i = 1 ; i < k ; i ++ ) { cout << s . substr ( flag ) ; } cout << endl ; return 0 ; }
TAB0 INF = const int with INF = 0x3f3f3f3f ; TAB0 PI = const double with PI = acos of - 1 . 0 ; TAB0 N = const int with N = 100 + 3 ; TAB1 n = int ; TAB1 read n ; TAB1 v = int array of size N ; TAB1 ans = long long array of size N ; TAB1 for i = 1 to n inclusive read v [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 cont = int with cont = 1 ; TAB2 j = int with j = v [ i ] ; TAB2 loop while j is not i and cont is less than 103 ; TAB3 increment cont ; TAB3 set j to v [ j ] ; TAB2 set ans [ i ] to cont ; TAB2 if ans [ i ] is even then set ans [ i ] to ans [ i ] / 2 ; TAB1 mmc = long long with mmc = ans [ 1 ] ; TAB1 for i = 1 to n inclusive ; TAB2 if ans [ i ] is 103 ; TAB3 print - 1 ; TAB2 set mmc to ( mmc * ans [ i ] ) / __gcd of mmc and ans [ i ] ; TAB1 print mmc ;	const int INF = 0x3f3f3f3f ; const double PI = acos ( - 1.0 ) ; const int N = 100 + 3 ; int main ( ) { int n ; cin >> n ; int v [ N ] ; long long ans [ N ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> v [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) { int cont = 1 ; int j = v [ i ] ; while ( j != i and cont < 103 ) { cont ++ ; j = v [ j ] ; } ans [ i ] = cont ; if ( ans [ i ] % 2 == 0 ) ans [ i ] /= 2 ; } long long mmc = ans [ 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ] == 103 ) { cout << - 1 << endl ; return 0 ; } mmc = ( mmc * ans [ i ] ) / __gcd ( mmc , ans [ i ] ) ; } cout << mmc << endl ; return 0 ; }
TAB0 n , x , y = integers and a , b = arrays of integers size 100 and c = array of integer size 500 ; TAB1 read n ; TAB1 j = integer with j = 1 ; TAB1 for i = 1 to n * n inclusive do the following ; TAB2 read x , y ; TAB2 if a [ x ] is 0 and b [ y ] is 0 do the following ; TAB3 a [ x ] = 1 ; TAB3 b [ y ] = 1 ; TAB3 c [ j ] = 1 ; TAB3 increment j ; TAB1 print c [ 1 ] ; TAB1 for i = 2 to j exclusive print a space and c [ i ] ; TAB1 print a new line ;	int a [ 100 ] , b [ 100 ] , n , x , y , c [ 500 ] ; int main ( ) { cin >> n ; int j = 1 ; for ( int i = 1 ; i <= n * n ; i ++ ) { cin >> x >> y ; if ( a [ x ] == 0 && b [ y ] == 0 ) { a [ x ] = 1 ; b [ y ] = 1 ; c [ j ] = i ; j ++ ; } } cout << c [ 1 ] ; for ( int i = 2 ; i < j ; i ++ ) cout << '   ' << c [ i ] ; cout << endl ; }
TAB0 flag = long long with flag = 0 ; TAB0 let a be string ; TAB0 define check with takes long long i and k ; TAB1 for long long j = i to i + k exclusive ; TAB2 if s [ j ] ! = s [ 2 * i + k - 1 - j ] ; TAB3 set flag = 1 ; TAB1 read s ; TAB1 let n , k be long long integer with n = length of s ; TAB1 read k ; TAB1 if n mod k ! = 0 ; TAB2 print NO with newline ; TAB1 for long long i = 0 to n exclusive with increment of n / k , call check with i and n / k ; TAB1 if flag is equal to 1 ; TAB2 print NO with newline ; TAB1 else ; TAB2 print YES with newline ;	long long flag = 0 ; string s ; long long check ( long long i , long long k ) { for ( long long j = i ; j < i + k ; j ++ ) { if ( s [ j ] != s [ 2 * i + k - 1 - j ] ) { flag = 1 ; return 0 ; } } } int main ( ) { cin >> s ; long long n = s . length ( ) , k ; cin >> k ; if ( n % k != 0 ) { cout << " NO " << endl ; return 0 ; } for ( long long i = 0 ; i < n ; i += n / k ) { check ( i , n / k ) ; } if ( flag == 1 ) cout << " NO " << endl ; else cout << " YES " << endl ; return 0 ; }
TAB0 create new string s ; TAB0 create new ints n and k ; TAB1 read standard input to s and k ; TAB1 change the value of n to length of s ; TAB1 if n % k is not 0 ; TAB2 print " NO \ n " to the standard output ; TAB1 set k to n / k ; TAB1 in a for loop , change st from 0 to n exclusive adding k to st ; TAB2 create integer variable with name dr and value st + k - 1 ; TAB2 create strings a and b ; TAB2 start for loop from i = st to dr inclusive , changing a to the sum of a and s [ i ] on each iteration ; TAB2 change the value of b to a ; TAB2 reverse the string b ; TAB2 if a ! = b ; TAB3 print " NO \ n " to the standard output ; TAB1 print " YES \ n " ;	string s ; int n , k ; int main ( ) { cin >> s >> k ; n = s . size ( ) ; if ( n % k ) { cout << " NO\n " ; return 0 ; } k = n / k ; for ( int st = 0 ; st < n ; st += k ) { int dr = st + k - 1 ; string a , b ; for ( int i = st ; i <= dr ; i ++ ) { a += s [ i ] ; } b = a ; reverse ( b . begin ( ) , b . end ( ) ) ; if ( a != b ) { cout << " NO\n " ; return 0 ; } } cout << " YES\n " ; return 0 ; }
TAB0 let the const integer value of maxn = 1 . 5e7 + 5 ; TAB0 a = array of integers of length maxn , num = array of integers of length maxn ; TAB1 let n , i , j , h be integers ; TAB1 read n ; TAB1 let g , m , ans be integers with m = 0 , ans = n ; TAB1 for i = 1 to n inclusive ; TAB2 read h ; TAB2 if i equals 1 ; TAB3 g is equal to h ; TAB2 else do the following ; TAB3 g is equal to __gcd ( g , h ) ; TAB2 increment num [ h ] by 1 ; TAB2 if h is greater than m , m is equal to h ; TAB1 for i = g + 1 to m inclusive ; TAB2 if a [ i ] equals 0 ; TAB3 the integer value of cnt = 0 ; TAB3 for j = i , j < = m , increment j by i , a [ j ] = 1 , increment cnt by num [ j ] ; TAB3 ans is equal to minimumof ans and n - cnt ; TAB1 if ans equals n ; TAB2 print - 1 and newline ; TAB1 else do the following ; TAB2 print ans and newline ;	const int maxn = 1.5e7 + 5 ; int a [ maxn ] , num [ maxn ] ; int main ( ) { int n , i , j , h ; cin >> n ; int g , m = 0 , ans = n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> h ; if ( i == 1 ) g = h ; else g = __gcd ( g , h ) ; num [ h ] ++ ; if ( h > m ) m = h ; } for ( i = g + 1 ; i <= m ; i ++ ) { if ( a [ i ] == 0 ) { int cnt = 0 ; for ( j = i ; j <= m ; j += i ) a [ j ] = 1 , cnt += num [ j ] ; ans = min ( ans , n - cnt ) ; } } if ( ans == n ) cout << - 1 << endl ; else cout << ans << endl ; return 0 ; }
TAB0 integer as array m of size 12 = 3 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 2 , 3 ; TAB1 a , b = string array ; TAB1 read a , b ; TAB1 integer as a1 , b1 ; TAB1 if a is monday then a1 = 1 ; TAB1 if a is tuesday then do the following a1 = 2 ; TAB1 if a is wednesday then do the following a1 = 3 ; TAB1 if a is thursday then do the following a1 = 4 ; TAB1 if a is friday then do the following a1 = 5 ; TAB1 if a is saturday then do the following a1 = 6 ; TAB1 if a is sunday then do the following a1 = 0 ; TAB1 if b is monday then do the following b1 = 1 ; TAB1 if b is tuesday then b1 = 2 ; TAB1 if b is wednesday then make b1 = 3 ; TAB1 if b is thursday then do the following b1 = 4 ; TAB1 if b is friday then b1 = 5 ; TAB1 if b is saturday b1 = 6 ; TAB1 if b is sunday then do the following b1 = 0 ; TAB1 for i = 0 to less than 12 do the following ; TAB2 if is a1 + m [ i ] modulo 7 is b1 then do the following ; TAB3 output YES ; TAB1 output NO ;	int m [ 12 ] = { 3 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 2 , 3 } ; int main ( ) { string a , b ; cin >> a >> b ; int a1 , b1 ; if ( a == " monday " ) a1 = 1 ; if ( a == " tuesday " ) a1 = 2 ; if ( a == " wednesday " ) a1 = 3 ; if ( a == " thursday " ) a1 = 4 ; if ( a == " friday " ) a1 = 5 ; if ( a == " saturday " ) a1 = 6 ; if ( a == " sunday " ) a1 = 0 ; if ( b == " monday " ) b1 = 1 ; if ( b == " tuesday " ) b1 = 2 ; if ( b == " wednesday " ) b1 = 3 ; if ( b == " thursday " ) b1 = 4 ; if ( b == " friday " ) b1 = 5 ; if ( b == " saturday " ) b1 = 6 ; if ( b == " sunday " ) b1 = 0 ; for ( int i = 0 ; i < 12 ; i ++ ) { if ( ( a1 + m [ i ] ) % 7 == b1 ) { cout << " YES " << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; }
TAB1 n , p = int ; TAB1 v = int vector ; TAB1 s25 , s50 = int stack ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 read p ; TAB2 append p to v ; TAB1 if v [ 0 ] is not 25 ; TAB2 print " NO " ; TAB1 for i = 0 to n ; TAB2 if v [ i ] is 25 ; TAB3 append v [ i ] to s25 ; TAB3 continue ; TAB2 if v [ i ] is 50 ; TAB3 if s25 is empty ; TAB4 print " NO " ; TAB3 append v [ i ] to s50 ; TAB3 pop s25 ; TAB2 if v [ i ] is 100 ; TAB3 if size of s25 is 0 ; TAB4 print " NO " ; TAB3 if size of s25 < 3 and size of s50 is 0 ; TAB4 print " NO " ; TAB3 if s50 is empty ; TAB4 pop s25 ; TAB4 pop s25 ; TAB4 pop s25 ; TAB3 else ; TAB4 pop s25 ; TAB4 pop s50 ; TAB1 print " YES " ;	int main ( ) { int n , p ; vector < int > v ; stack < int > s25 , s50 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> p ; v . push_back ( p ) ; } if ( v [ 0 ] != 25 ) { cout << " NO " << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 25 ) { s25 . push ( v [ i ] ) ; continue ; } if ( v [ i ] == 50 ) { if ( s25 . empty ( ) ) { cout << " NO " << endl ; return 0 ; } s50 . push ( v [ i ] ) ; s25 . pop ( ) ; } if ( v [ i ] == 100 ) { if ( s25 . size ( ) == 0 ) { cout << " NO " << endl ; return 0 ; } if ( ( s25 . size ( ) < 3 && s50 . size ( ) == 0 ) ) { cout << " NO " << endl ; return 0 ; } if ( s50 . empty ( ) ) { s25 . pop ( ) ; s25 . pop ( ) ; s25 . pop ( ) ; } else { s25 . pop ( ) ; s50 . pop ( ) ; } } } cout << " YES " << endl ; return 0 ; }
TAB1 let a , b , i , j = integers with i = 0 and k = array of integers with size = 4 ; TAB1 let ch = array of characters with size = 6 ; TAB1 read ch ; TAB1 set a = ( ch [ 0 ] - 48 ) * 10 + ch [ 1 ] - 48 ; TAB1 set b = ( ch [ 3 ] - 48 ) * 10 + ch [ 4 ] - 48 ; TAB1 set k [ 0 ] = a / 10 ; TAB1 set k [ 1 ] = a % 10 ; TAB1 set k [ 2 ] = b / 10 ; TAB1 set k [ 3 ] = b % 10 ; TAB1 if k [ 0 ] is k [ 3 ] and k [ 1 ] is k [ 2 ] print 0 ; TAB1 while k [ 0 ] is not equal to k [ 3 ] or k [ 1 ] is not equal to k [ 2 ] do the following ; TAB2 increment i ; TAB2 increment b ; TAB2 ifb is greater than or equal to 60 do the following ; TAB3 set b = 0 ; TAB3 if a is 23 ; TAB4 set a = 0 ; TAB3 else if a is less than 23 ; TAB4 incrementa ; TAB2 set k [ 0 ] = a / 10 ; TAB2 set k [ 1 ] = a % 10 ; TAB2 set k [ 2 ] = b / 10 ; TAB2 set k [ 3 ] = b % 10 ; TAB2 if k [ 0 ] is k [ 3 ] and k [ 1 ] is k [ 2 ] do the folllowing ; TAB3 print i ; TAB3 exit the loop ;	int main ( ) { int a , b , k [ 4 ] , i = 0 , j ; char ch [ 6 ] ; cin >> ch ; a = ( ch [ 0 ] - 48 ) * 10 + ch [ 1 ] - 48 ; b = ( ch [ 3 ] - 48 ) * 10 + ch [ 4 ] - 48 ; k [ 0 ] = a / 10 ; k [ 1 ] = a % 10 ; k [ 2 ] = b / 10 ; k [ 3 ] = b % 10 ; if ( k [ 0 ] == k [ 3 ] && k [ 1 ] == k [ 2 ] ) cout << 0 << endl ; while ( k [ 0 ] != k [ 3 ] || k [ 1 ] != k [ 2 ] ) { i ++ ; b ++ ; if ( b >= 60 ) { b = 0 ; if ( a == 23 ) a = 0 ; else if ( a < 23 ) a ++ ; } k [ 0 ] = a / 10 ; k [ 1 ] = a % 10 ; k [ 2 ] = b / 10 ; k [ 3 ] = b % 10 ; if ( k [ 0 ] == k [ 3 ] && k [ 1 ] == k [ 2 ] ) { cout << i << endl ; break ; } } return 0 ; }
TAB1 create int n , x and cnt , set cnt to 0 ; TAB1 read n ; TAB1 if n = 1 ; TAB2 read x ; TAB2 if x = 1 ; TAB3 print YES ; TAB2 print NO ; TAB1 for i = 0 to n exclusive ; TAB2 read x ; TAB2 if x = 0 , increment cnt ; TAB2 if cnt greater than 1 ; TAB3 print NO and a newline ; TAB1 if cnt = 1 ; TAB2 print YES ; TAB1 else ; TAB2 print N = and a newline ;	int main ( ) { int n , x , cnt = 0 ; cin >> n ; if ( n == 1 ) { cin >> x ; if ( x == 1 ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 0 ) cnt ++ ; if ( cnt > 1 ) { cout << " NO " << endl ; return 0 ; } } if ( cnt == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 PI = constant double = acos ( - 1 . 0 ) ; TAB0 MODPRIME = constant long long = 1e9 + 7 in long long form ; TAB0 MAXX = constant long long = 1e18 in long long form ; TAB0 MINN = constant long long = - 1e18 in long long form ; TAB0 EPS = constant double = 1e - 9 ; TAB0 MAXN = constant integer = 5e5 ; TAB0 N , ans = integer ; TAB0 arr = integer array of size MAXN + 5 ; TAB1 read N ; TAB1 for i = 0 to N exclusive , read a [ i ] ; TAB1 i = integer = 1 ; TAB1 while i < N - 1 ; TAB2 cek = boolean = the result of arr [ i ] is not arr [ i - 1 ] and arr [ i ] ! = arr [ i + 1 ] ; TAB2 if cek is false ; TAB3 increase i by 1 ; TAB2 else ; TAB3 cprev = integer = arr [ i - 1 ] ; TAB3 j = integer = i + 1 ; TAB3 curr = integer = 1 ; TAB3 while j < N - 1 and ( arr [ j ] is not arr [ j - 1 ] and arr [ j ] is not arr [ j + 1 ] ; TAB4 increase j by 1 ; TAB4 increase curr by 1 ; TAB3 if curr is even ; TAB4 ans = bigger value between ans and curr / 2 ; TAB4 idx = integer = i ; TAB4 for k = 0 to curr / 2 exclusive ; TAB5 arr [ idx ] = cprev ; TAB5 increase idx by 1 ; TAB4 for k = 0 to curr / 2 exclusive ; TAB5 arr [ idx ] = arr [ j ] ; TAB5 increase idx by 1 ; TAB3 else ; TAB4 ans = bigger value between ans and ( curr + 1 ) / 2 ; TAB4 for k = i to j - 1 inclusive , then arr [ k ] = cprev ; TAB3 i = j ; TAB1 print ans ; TAB1 for i = 0 to N exclusive ; TAB2 pritn arr [ i ] ; TAB2 print endline if i is N - 1 else print space character ;	const double pi = acos ( - 1 ) ; const long long MODPRIMA = ( long long ) 1e9 + 7 ; const long long MAXX = ( long long ) 1e18 ; const long long MINN = - ( long long ) 1e18 ; const double EPS = 1e-9 ; const int MAXN = 5e5 ; int N , ans ; int arr [ MAXN + 5 ] ; int main ( ) { cin >> N ; for ( int i = 0 ; i < N ; i ++ ) cin >> arr [ i ] ; int i = 1 ; while ( i < N - 1 ) { bool cek = ( arr [ i ] != arr [ i - 1 ] && arr [ i ] != arr [ i + 1 ] ) ; if ( ! cek ) i ++ ; else { int cprev = arr [ i - 1 ] ; int j = i + 1 ; int curr = 1 ; while ( j < N - 1 && ( arr [ j ] != arr [ j - 1 ] && arr [ j ] != arr [ j + 1 ] ) ) { j ++ ; curr ++ ; } if ( curr % 2 == 0 ) { ans = max ( ans , curr / 2 ) ; int idx = i ; for ( int k = 0 ; k < curr / 2 ; k ++ ) { arr [ idx ] = cprev ; idx ++ ; } for ( int k = 0 ; k < curr / 2 ; k ++ ) { arr [ idx ] = arr [ j ] ; idx ++ ; } } else { ans = max ( ans , ( curr + 1 ) / 2 ) ; for ( int k = i ; k <= j - 1 ; k ++ ) arr [ k ] = cprev ; } i = j ; } } cout << ans << ' \n ' ; for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] ; cout << ( i == N - 1 ? ' \n ' : '   ' ) ; } return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 horizontal = boolean of size n + 1 ; TAB1 vertikal = boolean of size n + 1 ; TAB1 theyareworking = boolean of size n * n + 1 ; TAB1 for i = 1 to n inclusive ; TAB2 v , h = integer ; TAB2 read h , v ; TAB2 if horizontal [ h ] is false and vertikal [ v ] is false ; TAB3 theyareworking [ i ] = true ; TAB3 horizontal [ h ] = true ; TAB3 vertikal [ v ] = true ; TAB1 hihi = boolean = false ; TAB1 for i = 1 to n * n inclusive ; TAB2 if theyareworking [ i ] is true ; TAB3 if hihi is false ; TAB4 print i ; TAB4 hihi = true ; TAB3 else ; TAB4 print i ; TAB1 print endline ;	int main ( ) { int n ; cin >> n ; bool horizontal [ n + 1 ] = { } ; bool vertikal [ n + 1 ] = { } ; bool theyareworking [ n * n + 1 ] = { } ; for ( int i = 1 ; i <= n * n ; i ++ ) { int v , h ; cin >> h >> v ; if ( horizontal [ h ] == false && vertikal [ v ] == false ) { theyareworking [ i ] = true ; horizontal [ h ] = true ; vertikal [ v ] = true ; } } bool hihi = false ; for ( int i = 1 ; i <= n * n ; i ++ ) { if ( theyareworking [ i ] == true ) { if ( hihi == false ) { cout << i ; hihi = true ; } else { cout << "   " << i ; } } } cout << endl ; }
TAB1 let p , x , y , i , k be integers ; TAB1 while read x , y ; TAB2 if x is equal to 0 and y is equal to 0 ; TAB3 k is equal to 0 ; TAB2 else do the following ; TAB3 p is equal to maximum of absolute value of x and absolute value of y ; TAB3 k is equal to ( p - 1 ) * 4 ; TAB3 if x is equal to p and y is greater than 1 - p and y < = p ; TAB4 increment k by 1 ; TAB3 else if y is equal to p and x > = - p and x < = p ; TAB4 increment k by 2 ; TAB3 else if x is equal to - p and y > = - p and y < = p ; TAB4 increment k by 3 ; TAB3 else if y is less than 0 and x is greater than y and x < = - y ; TAB4 increment k by 4 ; TAB2 print k and newline ;	int main ( ) { int p , x , y , i , k ; while ( cin >> x >> y ) { if ( x == 0 && y == 0 ) k = 0 ; else { p = max ( abs ( x ) , abs ( y ) ) ; k = ( p - 1 ) * 4 ; if ( x == p && y > 1 - p && y <= p ) k += 1 ; else if ( y == p && x >= - p && x <= p ) k += 2 ; else if ( x == - p && y >= - p && y <= p ) k += 3 ; else if ( y < 0 && x > y && x <= - y ) k += 4 ; } cout << k << endl ; } return 0 ; }
TAB1 let x , y and sum be ints with sum = 0 ; TAB1 read x and y ; TAB1 if x > y and x < = - y ; TAB2 assign - y * 4 to sum ; TAB1 else if y > x and x > = - y ; TAB2 assign - 2 + y * 4 to sum ; TAB1 else if y > = x and x is less than - y ; TAB2 assign - 1 - x * 4 to sum ; TAB1 else if x > y and x < = - y + 1 ; TAB2 change sum to - y * 4 ; TAB1 else if y < = x and x is greater than - y + 1 ; TAB2 set sum to - 3 + x * 4 ; TAB1 print sum ;	int main ( ) { int x , y , sum = 0 ; cin >> x >> y ; if ( x > y && x <= - y ) { sum = - y * 4 ; } else if ( y > x && x >= - y ) { sum = - 2 + y * 4 ; } else if ( y >= x && x < - y ) { sum = - 1 - x * 4 ; } else if ( x > y && x <= - y + 1 ) { sum = - y * 4 ; } else if ( y <= x && x > - y + 1 ) { sum = - 3 + x * 4 ; } cout << sum << endl ; return 0 ; }
TAB0 declare constant integer MAXN = 1e + 6 + 50 ; TAB0 declare integer n ; TAB0 declare integer array num size MAXN ; TAB1 while read n is true ; TAB2 set bytes from num to size of num to value 0 ; TAB2 declare integer temp ; TAB2 declare integer m = 0 ; TAB2 for i = 1 to n inclusive ; TAB3 read tep ; TAB3 let m be maximum of m and temp ; TAB3 increment num [ temp ] ; TAB2 for i = 0 to m inclusive ; TAB3 if num [ i ] is 0 , end current loop iteration ; TAB3 declare temp = num [ i ] / 2 as integer ; TAB3 increment num [ i + 1 ] by temp ; TAB3 decrement num [ i ] by temp * 2 ; TAB2 while num [ m + 1 ] is not 0 ; TAB3 declare integer temp = num [ m + 1 ] / 2 ; TAB3 increment num [ m + 2 ] by temp ; TAB3 decrement num [ m + 1 ] by temp * 2 ; TAB3 increment m ; TAB2 declare ans = 0 as integer ; TAB2 for i = 0 to m inclusive , increment ans by num [ i ] ; TAB2 print ans and newline ;	const int MAXN = 1e+6 + 50 ; int n ; int num [ MAXN ] ; int main ( ) { while ( cin >> n ) { memset ( num , 0 , sizeof ( num ) ) ; int temp ; int m = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> temp ; m = max ( m , temp ) ; num [ temp ] ++ ; } for ( int i = 0 ; i <= m ; i ++ ) { if ( num [ i ] == 0 ) continue ; int temp = num [ i ] / 2 ; num [ i + 1 ] += temp ; num [ i ] -= temp * 2 ; } while ( num [ m + 1 ] != 0 ) { int temp = num [ m + 1 ] / 2 ; num [ m + 2 ] += temp ; num [ m + 1 ] -= temp * 2 ; m ++ ; } int ans = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { ans += num [ i ] ; } cout << ans << endl ; } return 0 ; }
TAB1 n , k = int ; TAB1 read n , k ; TAB1 s = string ; TAB1 c = char ; TAB1 i = 0 , c = ' a ' , while i < n ( incrementing i and c at end of while ) ; TAB2 if c > = ( ' a ' + k ) c = ' a ' ; TAB2 add c at end of s ; TAB1 print s ;	int main ( ) { int n , k ; cin >> n >> k ; string s ; char c ; for ( int i = 0 , c = ' a ' ; i < n ; ++ i , ++ c ) { if ( c >= ( ' a ' + k ) ) c = ' a ' ; s . push_back ( c ) ; } cout << s << endl ; return 0 ; }
TAB0 define empty function init ; TAB1 call init ( ) ; TAB1 n is a new integer ; TAB1 read input to n ; TAB1 create new string s ; TAB1 read from the input to s ; TAB1 for i from 0 to n / 2 exclusive incrementing i ; TAB2 if s [ i ] = ' L ' ; TAB3 print i + 1 , " " and n / 2 + i + 1 ; TAB2 else ; TAB3 print n / 2 + i + 1 , " " and i + 1 ; TAB2 print ' \ n ' to the standard output ;	void init ( ) { } int main ( ) { init ( ) ; int n ; cin >> n ; string s ; cin >> s ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] == ' L ' ) cout << i + 1 << "   " << n / 2 + i + 1 ; else cout << n / 2 + i + 1 << "   " << i + 1 ; cout << ' \n ' ; } }
TAB0 create integers n , m ; TAB0 declare log7 with integer x as argument ; TAB1 create integer res with res = 0 ; TAB1 if x is 0 , return 1 from function ; TAB1 while x is true ; TAB2 set x to x / 7 ; TAB2 increment res ; TAB1 return res from function ; TAB0 declare base10 with integer x as argument , returning integer ; TAB1 create integers spow , res with spow = 1 , res = 0 ; TAB1 while x is rue ; TAB2 increment res by spow * ( x % 10 ) ; TAB2 set x to x / 10 ; TAB2 set spow to spow * 7 ; TAB1 return res from function ; TAB0 create map vis from pair of ( integer and integer ) to boolean ; TAB0 create integer ans ; TAB0 declare solve with integer sz as argument , returning void ; TAB1 create integer vector p ; TAB1 for i = 0 to 7 exclusive , add element i to end of p ; TAB1 start loop ; TAB2 create integers x , y ; TAB2 set x to y to 0 ; TAB2 for i = 0 to result of run log7 with n as argument exclusive ; TAB3 set x to x * 10 ; TAB3 increment x by p [ i ] ; TAB2 for i = result of run log7 with n as argument to sz exclusive ; TAB3 set y to y * 10 ; TAB3 increment y by p [ i ] ; TAB2 if n is greater than or equal to result of run base10 with x as argument and m is greater than or equal to result of run base10 with y as argument ; TAB3 if not vis [ make pair from ( x , y ) ] ; TAB4 increment ans ; TAB4 set vis [ make pair from ( x , y ) ] to true ; TAB1 while result of run next_permutation with beginning of p , end of p as arguments is true ; TAB1 read n read m ; TAB1 decrement n ; TAB1 decrement m ; TAB1 create integer sz with sz = result of run log7 with n as argument + result of run log7 with m as argument ; TAB1 if sz is greater than 7 ; TAB2 print 0 print newline ; TAB1 run solve with sz as argument ; TAB1 print ans print newline ;	int n , m ; int log7 ( int x ) { int res = 0 ; if ( x == 0 ) return 1 ; while ( x ) { x /= 7 ; res ++ ; } return res ; } int base10 ( int x ) { int spow = 1 , res = 0 ; while ( x ) { res += spow * ( x % 10 ) ; x /= 10 ; spow *= 7 ; } return res ; } map < pair < int , int > , bool > vis ; int ans ; void solve ( int sz ) { vector < int > p ; for ( int i = 0 ; i < 7 ; i ++ ) p . push_back ( i ) ; do { int x , y ; x = y = 0 ; for ( int i = 0 ; i < log7 ( n ) ; i ++ ) { x *= 10 ; x += p [ i ] ; } for ( int i = log7 ( n ) ; i < sz ; i ++ ) { y *= 10 ; y += p [ i ] ; } if ( n >= base10 ( x ) && m >= base10 ( y ) ) { if ( ! vis [ make_pair ( x , y ) ] ) { ans ++ ; vis [ make_pair ( x , y ) ] = true ; } } } while ( next_permutation ( p . begin ( ) , p . end ( ) ) ) ; } int main ( ) { cin >> n >> m ; n -- ; m -- ; int sz = log7 ( n ) + log7 ( m ) ; if ( sz > 7 ) { cout << 0 << endl ; return 0 ; } solve ( sz ) ; cout << ans << endl ; return 0 ; }
TAB1 a , b = string ; TAB1 read a ; TAB1 set b to a ; TAB1 x , y , z = long long int with x = 0 and y = 0 and z = 0 ; TAB1 i = long long int ; TAB1 for i = 0 to size of a ; TAB2 if a [ i ] is ' a ' increment x ; TAB2 if a [ i ] is ' b ' increment y ; TAB2 if a [ i ] is ' c ' increment z ; TAB1 sort b ; TAB1 if b is a and ( z is x or z is y ) and x is not 0 and y is not 0 and z is not 0 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { string a , b ; cin >> a ; b = a ; long long int x = 0 , y = 0 , z = 0 ; long long int i ; for ( i = 0 ; i < a . size ( ) ; i ++ ) { if ( a [ i ] == ' a ' ) { x ++ ; } if ( a [ i ] == ' b ' ) { y ++ ; } if ( a [ i ] == ' c ' ) { z ++ ; } } sort ( b . begin ( ) , b . end ( ) ) ; if ( b == a && ( z == x || z == y ) && x != 0 && y != 0 && z != 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 declare string s ; TAB1 read s ; TAB1 declare long long integer total = size of s - 2 ; TAB1 declare long long integer cont = 0 ; TAB1 declare long long integers primer , segun , tercer ; TAB1 for i = 0 to long long integer casted size of s exclusive ; TAB2 if s [ i ] is ' + ' , let primer be i ; TAB2 if s [ i ] is ' = ' , let segun be i - primer - 1 ; TAB1 let tercer be total - segun - primer ; TAB1 if tercer is ( segun + primer ) ; TAB2 print s and newline ; TAB1 else ; TAB2 if tercer is ( segun + primer + 2 ) ; TAB3 remove ( beginning of s + size of s - 1 ) from s ; TAB3 print " | " and s and newline ; TAB2 else if ( tercer + 2 ) is ( segun + primer ) ; TAB3 if primer is greater than or equal to 2 ; TAB4 for i = 0 to long long integer casted primer - 1 exclusive , print " | " ; TAB4 print " + " ; TAB4 for i = 0 to long long integer casted segun exclusive , print " | " ; TAB4 print " = " ; TAB4 for i = 0 to long long integer casted tercer + 1 exclusive , print " | " ; TAB4 print newline ; TAB3 else ; TAB4 for i = 0 to long long integer casted primer exclusive , print " | " ; TAB4 print " + " ; TAB4 for i = 0 to long long integer casted segun - 1 exclusive , print " | " ; TAB4 print " = " ; TAB4 for i = 0 to long long integer casted tercer + 1 , print " | " ; TAB4 print newline ; TAB2 else ; TAB3 print " Impossible " and newline ;	int main ( ) { string s ; cin >> s ; long long int total = s . size ( ) - 2 ; long long int cont = 0 ; long long int primer , segun , tercer ; for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( s . size ( ) ) ; i ++ ) { if ( s [ i ] == ' + ' ) { primer = i ; } if ( s [ i ] == ' = ' ) { segun = i - primer - 1 ; } } tercer = total - segun - primer ; if ( tercer == ( segun + primer ) ) { cout << s << endl ; } else { if ( tercer == ( segun + primer + 2 ) ) { s . erase ( s . begin ( ) + s . size ( ) - 1 ) ; cout << " | " << s << endl ; } else if ( ( tercer + 2 ) == ( segun + primer ) ) { if ( primer >= 2 ) { for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( primer - 1 ) ; i ++ ) { cout << " | " ; } cout << " + " ; for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( segun ) ; i ++ ) { cout << " | " ; } cout << " = " ; for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( tercer + 1 ) ; i ++ ) { cout << " | " ; } cout << endl ; } else { for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( primer ) ; i ++ ) { cout << " | " ; } cout << " + " ; for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( segun - 1 ) ; i ++ ) { cout << " | " ; } cout << " = " ; for ( long long int i = ( long long int ) ( 0 ) ; i < ( long long int ) ( tercer + 1 ) ; i ++ ) { cout << " | " ; } cout << endl ; } } else { cout << " Impossible " << endl ; } } return 0 ; }
TAB1 integer as n ; TAB1 read n ; TAB1 output n / 2 ; TAB1 for i = 1 to less than or equal to n / 2 - 1 do the following ; TAB1 if n modulo 2 is true ; TAB2 output 3 ; TAB1 else ; TAB2 output 2 ;	int main ( ) { int n ; cin >> n ; cout << n / 2 << endl ; for ( int i = 1 ; i <= n / 2 - 1 ; i ++ ) cout << 2 << "   " ; if ( n % 2 ) cout << 3 << endl ; else cout << 2 << endl ; return 0 ; }
TAB0 function bigmod with long long arguments a , p and m that returns long long ; TAB1 if p = 0 , return 1 modulo m ; TAB1 declare new long long called x = result of bigmod ( a , p / 2 , m ) ; TAB1 change x to x squared % m ; TAB1 if p is odd , assign ( x * a ) modulo m to x ; TAB1 return x modulo m ; TAB0 create an array of long longs m with 256 elements , q with 266 elements and 2d array v with size 10009 by 266 ; TAB1 create new strings a and b ; TAB1 read input to a and b ; TAB1 prepend " " to a ; TAB1 start for loop from i = ' a ' to ' z ' inclusive , setting q [ i ] to length of a on each loop iteration ; TAB1 start for loop from i = length of a to 0 inclusive decrementing i ; TAB2 assign value of 1 to m [ a [ i ] ] ; TAB2 in a for loop , change j from ' a ' to ' z ' inclusive , assigning q [ j ] to v [ i ] [ j ] on each iteration ; TAB2 set value of q [ a [ i ] ] to i ; TAB1 declare new long longs c = 0 and an = 1 ; TAB1 for i from 0 to length of b - 1 inclusive incrementing i ; TAB2 if m [ b [ i ] ] is equal to 0 , return 0 and print " - 1 " ; TAB2 assign v [ c ] [ b [ i ] ] to c ; TAB2 if c = length of a ; TAB3 increment an ; TAB3 change c to v [ 0 ] [ b [ i ] ] ; TAB1 print an to the standard output ;	long long bigmod ( long long a , long long p , long long m ) { if ( p == 0 ) return 1 % m ; long long x = bigmod ( a , p / 2 , m ) ; x = ( x * x ) % m ; if ( p % 2 ) x = ( x * a ) % m ; return x % m ; } long long v [ 10009 ] [ 266 ] , q [ 266 ] , m [ 256 ] ; int main ( ) { string a , b ; cin >> a >> b ; a = "   " + a ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) q [ i ] = a . size ( ) ; for ( int i = a . size ( ) ; i >= 0 ; i -- ) { m [ a [ i ] ] = 1 ; for ( int j = ' a ' ; j <= ' z ' ; j ++ ) v [ i ] [ j ] = q [ j ] ; q [ a [ i ] ] = i ; } long long c = 0 , an = 1 ; for ( int i = 0 ; i <= b . size ( ) - 1 ; i ++ ) { if ( m [ b [ i ] ] == 0 ) return 0 & puts ( " -1 " ) ; c = v [ c ] [ b [ i ] ] ; if ( c == a . size ( ) ) { an ++ ; c = v [ 0 ] [ b [ i ] ] ; } } cout << an << endl ; }
TAB1 create character array s with size 100005 create character pointer p ; TAB1 create integer x ; TAB1 read s ; TAB1 if ( p is first occurrence of " AB " in s ) and ( first occurrence of " BA " in p + 2 ) ; TAB2 print " YES " print newline ; TAB1 else if ( p is first occurrence of " BA " in s ) and ( first occurrence of " AB " in p + 2 ) ; TAB2 print " YES " print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { char s [ 100005 ] , * p ; int x ; cin >> s ; if ( ( p = strstr ( s , " AB " ) ) && ( strstr ( p + 2 , " BA " ) ) ) { cout << " YES " << endl ; } else if ( ( p = strstr ( s , " BA " ) ) && ( strstr ( p + 2 , " AB " ) ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 n , k , i , j = integers ; TAB1 read n , k ; TAB1 a = string with a = abcdefghijklmnopqrstuvwxyz ; TAB1 i = 0 ; TAB1 while decrement n ; TAB2 print a [ increment i ] ; TAB2 if ( i is k ) i = 0 ; TAB1 print new line ;	int main ( ) { int n , k , i , j ; cin >> n >> k ; string a = " abcdefghijklmnopqrstuvwxyz " ; i = 0 ; while ( n -- ) { cout << a [ i ++ ] ; if ( i == k ) i = 0 ; } cout << endl ; }
TAB1 str = string ; TAB1 a , r , b , c , d = int ; TAB1 call getline of cin , str ; TAB1 set a to ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' ) ; TAB1 set b to ( str [ 1 ] - ' 0 ' ) * 10 + ( str [ 0 ] - ' 0 ' ) ; TAB1 set c to ( str [ 3 ] - ' 0 ' ) * 10 + str [ 4 ] - ' 0 ' ; TAB1 if c > b and c < = 59 ; TAB2 set str [ 3 ] to str [ 1 ] ; TAB2 set str [ 4 ] to str [ 0 ] ; TAB2 print str ; TAB2 noop ; TAB1 else ; TAB1 goto label top ; TAB2 increment a ; TAB2 if a > 23 ; TAB3 set str [ 0 ] to ' 0 ' ; TAB3 set str [ 1 ] to ' 0 ' ; TAB3 set str [ 2 ] to ' 0 ' ; TAB3 set str [ 3 ] to ' 0 ' ; TAB3 print str ; TAB3 noop ; TAB2 else ; TAB3 set r to a / 10 ; TAB3 if r is 0 ; TAB4 set str [ 0 ] to ' 0 ' ; TAB4 set str [ 1 ] to a mod 10 + 48 ; TAB4 set d to ( str [ 1 ] - ' 0 ' ) * 10 + str [ 0 ] - ' 0 ' ; TAB4 if d < = 59 ; TAB5 set str [ 3 ] to str [ 1 ] ; TAB5 set str [ 4 ] to str [ 0 ] ; TAB5 print str ; TAB5 noop ; TAB4 else ; TAB5 goto top ; TAB3 else ; TAB4 set str [ 0 ] to r + 48 ; TAB4 set str [ 1 ] to a mod 10 + 48 ; TAB4 set d to ( str [ 1 ] - ' 0 ' ) * 10 + str [ 0 ] - ' 0 ' ; TAB4 if d < = 59 ; TAB5 set str [ 3 ] to str [ 1 ] ; TAB5 set str [ 4 ] to str [ 0 ] ; TAB5 print str ; TAB4 else ; TAB5 goto top ;	int main ( ) { string str ; int a , r , b , c , d ; getline ( cin , str ) ; a = ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' ) ; c = ( str [ 1 ] - ' 0 ' ) * 10 + ( str [ 0 ] - ' 0 ' ) ; b = ( str [ 3 ] - ' 0 ' ) * 10 + str [ 4 ] - ' 0 ' ; if ( c > b && c <= 59 ) { str [ 3 ] = str [ 1 ] ; str [ 4 ] = str [ 0 ] ; cout << str << endl ; ; } else { top : a ++ ; if ( a > 23 ) { str [ 0 ] = ' 0 ' ; str [ 1 ] = ' 0 ' ; str [ 3 ] = ' 0 ' ; str [ 4 ] = ' 0 ' ; cout << str << endl ; ; } else { r = a / 10 ; if ( r == 0 ) { str [ 0 ] = ' 0 ' ; str [ 1 ] = a % 10 + 48 ; d = ( str [ 1 ] - ' 0 ' ) * 10 + str [ 0 ] - ' 0 ' ; if ( d <= 59 ) { str [ 3 ] = str [ 1 ] ; str [ 4 ] = str [ 0 ] ; cout << str << endl ; ; } else goto top ; } else { str [ 0 ] = r + 48 ; str [ 1 ] = a % 10 + 48 ; d = ( str [ 1 ] - ' 0 ' ) * 10 + str [ 0 ] - ' 0 ' ; if ( d <= 59 ) { str [ 3 ] = str [ 1 ] ; str [ 4 ] = str [ 0 ] ; cout << str << endl ; } else goto top ; } } } return 0 ; }
TAB0 maxn = const int with maxn = 1e6 ; TAB0 in function gcd taking long long a , long long b and returning long long ; TAB1 if b is 0 ; TAB2 return a ; TAB1 else ; TAB2 return gcd of b , a mod b ; TAB0 in function lcm taking long long a , long long b and returning long long ; TAB1 return a * b / gcd of a , b ; TAB1 n = int ; TAB1 loop while reading n ; TAB2 ans = long long ; TAB2 if n > 3 ; TAB3 set ans to lcm of lcm of ( n - 2 , n - 1 ) , n ; TAB3 ans2 = long long with ans2 = lcm of lcm of ( n - 3 , n - 1 ) , n ; TAB3 ans3 = long long with ans3 = lcm of lcm of ( n - 3 , n - 2 ) , n - 1 ; TAB3 set ans to max of max of ans , ans2 , ans3 ; TAB2 else ; TAB3 if n is 1 ; TAB4 set ans to 1 ; TAB3 else if n is 2 ; TAB4 set ans to 2 ; TAB3 else if n is 3 ; TAB4 set ans to 6 ; TAB2 print ans ;	const int maxn = 1e6 ; long long gcd ( long long a , long long b ) { if ( b == 0 ) { return a ; } else { return gcd ( b , a % b ) ; } } long long lcm ( long long a , long long b ) { return a * b / gcd ( a , b ) ; } int main ( ) { int n ; while ( cin >> n ) { long long ans ; if ( n > 3 ) { ans = lcm ( lcm ( n - 2 , n - 1 ) , n ) ; long long ans2 = lcm ( lcm ( n - 3 , n - 1 ) , n ) ; long long ans3 = lcm ( lcm ( n - 3 , n - 2 ) , n - 1 ) ; ans = max ( max ( ans , ans2 ) , ans3 ) ; } else { if ( n == 1 ) ans = 1 ; else if ( n == 2 ) ans = 2 ; else if ( n == 3 ) ans = 6 ; } cout << ans << endl ; } }
TAB1 create int n , k , x , y , set x and y to 0 ; TAB1 read n ; TAB1 for i = 0 to n inclusive ; TAB2 read k ; TAB2 if k = 0 ; TAB3 increment x ; TAB2 else if k = 1 ; TAB3 increment y ; TAB1 if n = 1 and y = 1 ; TAB2 print YES ; TAB1 else if n = 1 and y different from 1 ; TAB2 print NO ; TAB1 else if n different from 1 and x = 1 ; TAB2 print YES ; TAB1 else if n different from 1 and x different from 1 ; TAB2 print NO and a newline ;	int main ( ) { int n , k , x = 0 , y = 0 ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> k ; if ( k == 0 ) { x ++ ; } else if ( k == 1 ) { y ++ ; } } if ( n == 1 && y == 1 ) { cout << " YES " << endl ; } else if ( n == 1 && y != 1 ) { cout << " NO " << endl ; } else if ( n != 1 && x == 1 ) { cout << " YES " << endl ; } else if ( n != 1 && x != 1 ) { cout << " NO " << endl ; } return 0 ; }
TAB0 define constant integer N = 1e6 + 5 ; TAB0 define integer constant mod = 1e9 + 7 ; TAB0 dp is a new 2d array of integers 5005 by 5005 elements ; TAB0 declare string variable str1 ; TAB0 create new string called str2 ; TAB0 function solve with int arguments idx1 and idx2 that returns int ; TAB1 return 1 if idx1 is equal to the length of str1 or idx2 is equal to the length of str2 ; TAB1 create new integer reference & ret = dp [ idx1 ] [ idx2 ] ; TAB1 return ret if ~ ret ; TAB1 change ret to solve ( idx1 , idx2 + 1 ) ; TAB1 if str1 [ idx1 ] is equal to str2 [ idx2 ] , add the result of solve ( idx1 + 1 , idx2 + 1 ) to ret ; TAB1 if ret > = mod , change ret to ret - mod ; TAB1 return ret ; TAB1 read input to str1 and str2 ; TAB1 change values of first sizeofdp bytes at the pointer dp to - 1 ; TAB1 create new integer called ans = ( - length of str1 + mod ) ; TAB1 start for loop from i = 0 to length of str1 exclusive ; TAB2 increase ans by the result of solve ( i , 0 ) ; TAB2 if ans > = mod , change ans to ans - mod ; TAB1 print ans and ' \ n ' ;	const int N = 1e6 + 5 ; const int mod = 1e9 + 7 ; int dp [ 5005 ] [ 5005 ] ; string str1 ; string str2 ; int solve ( int idx1 , int idx2 ) { if ( idx1 == str1 . size ( ) || idx2 == str2 . size ( ) ) return 1 ; int & ret = dp [ idx1 ] [ idx2 ] ; if ( ~ ret ) return ret ; ret = solve ( idx1 , idx2 + 1 ) ; if ( str1 [ idx1 ] == str2 [ idx2 ] ) ret += solve ( idx1 + 1 , idx2 + 1 ) ; if ( ret >= mod ) ret -= mod ; return ret ; } int main ( ) { cin >> str1 >> str2 ; memset ( dp , - 1 , sizeof dp ) ; int ans = ( - str1 . size ( ) + mod ) ; for ( int i = 0 ; i < str1 . size ( ) ; i ++ ) { ans += solve ( i , 0 ) ; if ( ans >= mod ) ans -= mod ; } cout << ans << ' \n ' ; return 0 ; }
TAB1 let a , b , ans be integers with ans = 0 ; TAB1 let ch be a character ; TAB1 read a , ch , b ; TAB1 while the condition is true ; TAB2 if a modulo 10 is equal to b / 10 and a / 10 is equal to b modulo 10 , stop ; TAB2 increment b by 1 ; TAB2 if b > = 60 ; TAB3 increment a by 1 ; TAB3 b is equal to 0 ; TAB2 if a > = 24 , a is equal to 0 ; TAB2 increment ans by 1 ; TAB1 print ans and newline ;	int main ( ) { int a , b , ans = 0 ; char ch ; cin >> a >> ch >> b ; while ( 1 ) { if ( a % 10 == b / 10 && a / 10 == b % 10 ) { break ; } b ++ ; if ( b >= 60 ) { a ++ ; b = 0 ; } if ( a >= 24 ) { a = 0 ; } ans ++ ; } cout << ans << endl ; return 0 ; }
TAB0 create integer vector array grafo with size 300000 ; TAB0 create boolean array chegou with size 300000 ; TAB0 create integer vector passou ; TAB0 create integers n , m ; TAB0 declare dfs with integer v as argument , returning void ; TAB1 set chegou [ v ] to true ; TAB1 add element v to end of passou ; TAB1 for i = 0 to size of grafo [ v ] exclusive ; TAB2 create integer adj with adj = grafo [ v ] [ i ] ; TAB2 if not chegou [ adj ] , run dfs with adj as argument ; TAB1 read n read m ; TAB1 for i = 0 to m exclusive ; TAB2 create integers a , b ; TAB2 read a read b ; TAB2 add element b to end of grafo [ a ] ; TAB2 add element a to end of grafo [ b ] ; TAB1 for i = 1 to n inclusive ; TAB2 if not chegou [ i ] ; TAB3 run dfs with i as argument ; TAB3 create integer mini with mini = size of passou - 1 ; TAB3 for c = 0 to size of passou exclusive ; TAB4 if size of grafo [ passou [ c ] ] is less than mini ; TAB5 print " NO \ n " ; TAB3 remove all elements from passou ; TAB1 print " YES \ n " ;	vector < int > grafo [ 300000 ] ; bool chegou [ 300000 ] ; vector < int > passou ; int n , m ; void dfs ( int v ) { chegou [ v ] = true ; passou . push_back ( v ) ; for ( int i = 0 ; i < grafo [ v ] . size ( ) ; i ++ ) { int adj = grafo [ v ] [ i ] ; if ( ! chegou [ adj ] ) { dfs ( adj ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < m ; i ++ ) { int a , b ; cin >> a >> b ; grafo [ a ] . push_back ( b ) ; grafo [ b ] . push_back ( a ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! chegou [ i ] ) { dfs ( i ) ; int mini = passou . size ( ) - 1 ; for ( int c = 0 ; c < passou . size ( ) ; c ++ ) { if ( grafo [ passou [ c ] ] . size ( ) < mini ) { cout << " NO\n " ; return 0 ; } } passou . clear ( ) ; } } cout << " YES\n " ; return 0 ; }
TAB0 MAXN = constant integer = 105 ; TAB0 arr = long long array of size MAXN ; TAB0 visited = boolean array of size MAXN ; TAB0 v = long long vector ; TAB0 flag = boolean ; TAB0 in function gcd with arguments of long long a and long long b and returns a long long ; TAB1 if b is 0 return a other wise return the result of calling gcd with arguments b and a modulo b ; TAB0 in function dfs with argument of integer beginu and integer u that returns a long long ; TAB1 if arr [ u ] is u ; TAB2 if u is not beginu , then flag = true ; TAB1 if visited [ u ] is nonzero ; TAB2 if u is not beginu , then fkag is true ; TAB1 visited [ u ] is 1 ; TAB1 return 1 + the result of calling dfs with arguments beginu and arr [ u ] ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 1 to n inclusive , then read arr [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 temp = long long = 0 ; TAB2 if arr [ i ] is i ; TAB3 temp = 1 ; TAB2 else ; TAB3 temp is the result of calling dfs with arguments of i and i ; TAB2 if temp is 0 ; TAB3 push back the values of v and insert a new element of 1 at the end of v ; TAB2 else if temp is even ; TAB3 push back the values of v and insert a new element of temp / 2 at the end of v ; TAB2 else ; TAB3 push back the values of v and insert a new element of temp at the end of v ; TAB1 ans = long long = v [ 0 ] ; TAB1 for i = 1 to size of v exclusive ; TAB2 gcdv = long long = the result of calling gcd with argument of v [ i ] and ans ; TAB2 ans = ans * v [ i ] ; TAB2 ans = ans / gcdv ; TAB1 if flag returns true ; TAB2 print - 1 ; TAB1 else ; TAB2 print ans ;	const int MAXN = 105 ; long long arr [ MAXN ] ; bool visited [ MAXN ] ; vector < long long > v ; bool flag ; long long gcd ( long long a , long long b ) { return b == 0 ? a : gcd ( b , a % b ) ; } long long dfs ( int beginu , int u ) { if ( arr [ u ] == u ) { if ( u != beginu ) { flag = true ; } return 0 ; } if ( visited [ u ] ) { if ( u != beginu ) { flag = true ; } return 0 ; } visited [ u ] = 1 ; return dfs ( beginu , arr [ u ] ) + 1 ; } int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> arr [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) { long long temp = 0 ; if ( arr [ i ] == i ) { temp = 1 ; } else { temp = dfs ( i , i ) ; } if ( temp == 0 ) { v . push_back ( 1 ) ; } else if ( temp % 2 == 0 ) { v . push_back ( temp / 2 ) ; } else { v . push_back ( temp ) ; } } long long ans = v [ 0 ] ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { long long gcdv = gcd ( v [ i ] , ans ) ; ans *= v [ i ] ; ans /= gcdv ; } if ( flag ) { cout << - 1 << endl ; } else { cout << ans << endl ; } return 0 ; }
TAB1 let v be an int vector ; TAB1 let x and sum = 0 be ints ; TAB1 read x ; TAB1 for i = 0 to x exclusive ; TAB2 y = int ; TAB2 read y ; TAB2 push back y in v ; TAB1 min = int = ( the minimum element of v ) - beginning of v ; TAB1 for i = min to x - 1 exclusive ; TAB2 if v at min = v at i + 1 then set min to i + 1 ; TAB1 increment sum by x - 1 - min ; TAB1 for i = min to x - 1 exclusive then call iter swap with args v . begin + i , v . begin + i + 1 ; TAB1 set int max = ( the maximum element in v ) - beginning of v ; TAB1 for i = max to 0 exclusive , decrementing i ; TAB2 if v at max = v a t i - 1 then set mni to i - 1 ; TAB1 increment sum by max ; TAB1 print sum ;	int main ( ) { vector < int > v ; int x , sum = 0 ; cin >> x ; for ( int i = 0 ; i < x ; i ++ ) { int y ; cin >> y ; v . push_back ( y ) ; } int min = min_element ( v . begin ( ) , v . begin ( ) + v . size ( ) ) - v . begin ( ) ; for ( int i = min ; i < x - 1 ; i ++ ) { if ( v . at ( min ) == v . at ( i + 1 ) ) { min = i + 1 ; } } sum += ( x - 1 - min ) ; for ( int i = min ; i < x - 1 ; i ++ ) { iter_swap ( v . begin ( ) + i , v . begin ( ) + i + 1 ) ; } int max = max_element ( v . begin ( ) , v . begin ( ) + v . size ( ) ) - v . begin ( ) ; for ( int i = max ; i > 0 ; i -- ) { if ( v . at ( max ) == v . at ( i - 1 ) ) { min = i - 1 ; } } sum += ( max ) ; cout << sum << endl ; }
TAB1 create long long int a , s , d , f , g ; TAB1 read a , s , d , f and g ; TAB1 create long long int k , l , j , h , n , b , m , set k to 0 ; TAB1 if d > s or f < a ; TAB2 print 0 ; TAB1 else ; TAB2 if a > d ; TAB3 set j = a ; TAB2 else ; TAB3 assign d to j ; TAB2 if s > f ; TAB3 set h to f ; TAB2 else ; TAB3 assign s to h ; TAB2 set n = h - j ; TAB2 if j < = g and h > = g ; TAB3 print n ; TAB2 else ; TAB3 print n + 1 ;	int main ( ) { long long int a , s , d , f , g ; cin >> a >> s >> d >> f >> g ; long long int k = 0 , l , j , h , n , b , m ; if ( d > s || f < a ) { cout << 0 << endl ; } else { if ( a > d ) { j = a ; } else { j = d ; } if ( s > f ) { h = f ; } else { h = s ; } n = h - j ; if ( j <= g && h >= g ) { cout << n << endl ; } else { cout << n + 1 << endl ; } } return 0 ; }
TAB0 declare constant integer MAXN = 55 ; TAB0 declare integers n , m , area ; TAB0 declare integer array dx = { - 1 , 0 , 1 , 0 } ; TAB0 declare integer array dy = { 0 , 1 , 0 , - 1 } ; TAB0 declare integer array bio size MAXN by MAXN ; TAB0 declare character array grid size MAXN by MAXN ; TAB0 declare valid with integers x , y as arguments , returning boolean ; TAB1 if x is less than 0 or x is greater than or equal to n , return false from function ; TAB1 if y is less than 0 or y is greater than or equal to m , return false from function ; TAB1 return true from function ; TAB0 declare dfs with integers x , y as arguments , returning void ; TAB1 let bio [ x ] [ y ] be 1 ; TAB1 for i = 0 to 4 exclusive ; TAB2 declare integer xx = x + dx [ i ] ; TAB2 declare integer yy = y + dy [ i ] ; TAB2 if result of run valid ( xx , yy ) and grid [ xx ] [ yy ] is ' # ' and not bio [ xx ] [ yy ] , run dfs ( xx , yy ) ; TAB0 declare nc with no arguments , returning integer ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to m exclusive , let bio [ i ] [ j ] be 0 ; TAB1 declare integer bk = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to m exclusive ; TAB3 if grid [ i ] [ j ] is ' . ' , end current loop iteration ; TAB3 if bio [ i ] [ j ] , end current loop iteration ; TAB3 run dfs ( i , j ) ; TAB3 increment bk ; TAB1 return bk ; TAB1 read n and m ; TAB1 for i = 0 to n exclusive , read grid [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to m exclusive ; TAB3 if grid [ i ] [ j ] is ' # ' , increment area ; TAB1 if area is less than 3 ; TAB2 print " - 1 \ n " ; TAB1 else if area is 3 ; TAB2 print " 1 \ n " ; TAB1 else ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to m exclusive ; TAB4 if grid [ i ] [ j ] is ' . ' , end current loop iteration ; TAB4 let gird [ i ] [ j ] be ' . ' ; TAB4 if result of run nc is greater than 1 ; TAB5 print " 1 \ n " ; TAB4 let grid [ i ] [ j ] be ' # ' ; TAB2 print " 2 \ n " ;	const int MAXN = 55 ; int n , m , area ; int dx [ ] = { - 1 , 0 , 1 , 0 } ; int dy [ ] = { 0 , 1 , 0 , - 1 } ; int bio [ MAXN ] [ MAXN ] ; char grid [ MAXN ] [ MAXN ] ; bool valid ( int x , int y ) { if ( x < 0 || x >= n ) return false ; if ( y < 0 || y >= m ) return false ; return true ; } void dfs ( int x , int y ) { bio [ x ] [ y ] = 1 ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ] ; int yy = y + dy [ i ] ; if ( valid ( xx , yy ) && grid [ xx ] [ yy ] == ' # ' && ! bio [ xx ] [ yy ] ) { dfs ( xx , yy ) ; } } } int nc ( ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { bio [ i ] [ j ] = 0 ; } } int bk = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( grid [ i ] [ j ] == ' . ' ) continue ; if ( bio [ i ] [ j ] ) continue ; dfs ( i , j ) ; bk ++ ; } } return bk ; } int main ( ) { cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> grid [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( grid [ i ] [ j ] == ' # ' ) area ++ ; } } if ( area < 3 ) { cout << " -1\n " ; return 0 ; } else if ( area == 3 ) { cout << " 1\n " ; return 0 ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( grid [ i ] [ j ] == ' . ' ) continue ; grid [ i ] [ j ] = ' . ' ; if ( nc ( ) > 1 ) { cout << " 1\n " ; return 0 ; } grid [ i ] [ j ] = ' # ' ; } } cout << " 2\n " ; } return 0 ; }
TAB1 create char a [ 1001 ] ; TAB1 create int b , n and p ; TAB1 while read a ; TAB2 m = 0 ; TAB2 read b ; TAB2 set len to length of a ; TAB2 n = len / b ; TAB2 if len mod b different from 0 ; TAB3 print No ; TAB3 continue ; TAB2 for i = 0 to b exclusive ; TAB3 for j = 0 to n exclusive ; TAB4 set p to n * i + n - j - 1 ; TAB4 if a [ j + n * i ] different from a [ p ] ; TAB5 m = 1 ; TAB5 break ; TAB3 if m = 1 , break ; TAB2 if m equal to 1 ; TAB3 print NO ; TAB2 else ; TAB3 print YES ;	int main ( ) { char a [ 1001 ] ; int b , n , p ; while ( cin >> a ) { int m = 0 ; cin >> b ; int len = strlen ( a ) ; n = len / b ; if ( len % b != 0 ) { cout << " NO " << endl ; continue ; } for ( int i = 0 ; i < b ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { p = n * i + n - j - 1 ; if ( a [ j + n * i ] != a [ p ] ) { m = 1 ; break ; } } if ( m == 1 ) break ; } if ( m == 1 ) cout << " NO " << endl ; else cout << " YES " << endl ; } }
TAB0 arr = array of integers set to length 5000010 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read arr [ i + i ] ; TAB1 set arr [ 0 ] to arr [ 1 ] ; TAB1 set arr [ n + 1 ] to arr [ n ] ; TAB1 set ans to 0 ; TAB1 strange = boolean set to false ; TAB1 start = integer set to - 1 ; TAB1 lef = integer set to - 1 ; TAB1 end = integer set to - 1 ; TAB1 right = integer set to - 1 ; TAB1 mid = integer set to - 1 ; TAB1 length = integer set to end - start + 1 ; TAB1 for i = 1 to n inclusive ; TAB2 if arr [ i - 1 ] isn ' t arr [ i ] and arr [ 1 + 1 ] isn ' t arr [ i ] ; TAB3 if not strange ; TAB4 set strange to true ; TAB4 set start to i ; TAB4 set left to arr [ i - 1 ] ; TAB2 else ; TAB3 if strange is true ; TAB4 set end to i - 1 ; TAB4 set right to arr [ i ] ; TAB4 set length to end - start + 1 ; TAB4 set ans = max of ans and length + 1 / 2 ; TAB4 set mid to length / 2 + start - 1 ; TAB4 for j = start to mid inclusive , set arr [ j ] to left ; TAB4 for j = mid + 1 to end inclusive , set arr [ j ] to right ; TAB4 set strange to false ; TAB1 print ans ; TAB1 for i = 1 to n - 1 inclusive , print arr [ i ] ; TAB1 print arr [ n ] ;	int arr [ 5000010 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> arr [ i + 1 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ n + 1 ] = arr [ n ] ; int ans = 0 ; bool strange = false ; int start = - 1 ; int left = - 1 ; int end = - 1 ; int right = - 1 ; int mid = - 1 ; int length = end - start + 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] != arr [ i ] && arr [ i + 1 ] != arr [ i ] ) { if ( ! strange ) { strange = true ; start = i ; left = arr [ i - 1 ] ; } } else { if ( strange ) { end = i - 1 ; right = arr [ i ] ; length = end - start + 1 ; ans = max ( ans , ( ( length + 1 ) / 2 ) ) ; mid = length / 2 + start - 1 ; for ( int j = start ; j <= mid ; j ++ ) arr [ j ] = left ; for ( int j = mid + 1 ; j <= end ; j ++ ) arr [ j ] = right ; strange = false ; } } } cout << ans << endl ; for ( int i = 1 ; i <= n - 1 ; i ++ ) cout << arr [ i ] << "   " ; cout << arr [ n ] << endl ; return 0 ; }
TAB0 declare compute taking in const strings & t and & u and returning integer ; TAB1 create int count = 0 ; TAB1 for i = 0 to t . length ( ) exclusive ; TAB2 if t [ i ] is equal to u [ i ] , increment count ; TAB1 return count ; TAB1 make strings s and u ; TAB1 read s and u ; TAB1 make string tempstr ; TAB1 for i = 0 to u . length ( ) - 1 exclusive , set tempstr to tempstr + " " ; TAB1 set s to tempstr + s + tempstr ; TAB1 let integer max = 0 ; TAB1 for i = 0 to s . length ( ) - u . length ( ) ; TAB2 make int temp = compute ( s . substr ( i , u . length ( ) ) , u ) ; TAB2 if temp is greater than max , set max to temp ; TAB1 print u . length ( ) - max ;	int compute ( const string & t , const string & u ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; ++ i ) { if ( t [ i ] == u [ i ] ) { count ++ ; } } return count ; } int main ( ) { string s , u ; cin >> s >> u ; string tempstr ; for ( int i = 0 ; i < u . length ( ) - 1 ; ++ i ) { tempstr += "   " ; } s = tempstr + s + tempstr ; int max = 0 ; for ( int i = 0 ; i <= s . length ( ) - u . length ( ) ; ++ i ) { int temp = compute ( s . substr ( i , u . length ( ) ) , u ) ; if ( temp > max ) { max = temp ; } } cout << u . length ( ) - max << endl ; return 0 ; }
TAB0 let maxn be a constant integer with maxn = 100010 ; TAB0 let mo be a constant integer with mo = 1e9 + 7 ; TAB0 let ans be a long integer ; TAB0 let f , n , m , h be integers ; TAB0 let a , c , k , sum be integers with a = array of integers of length maxn , c = array of integers of length maxn , sum = array of integers of length maxn ; TAB0 let b , flag , tmp be integers with b = array of integers of length maxn ; TAB0 dp = array of integers of length maxn ; TAB0 let s be a string ; TAB1 let T be a integer ; TAB1 let cas be a integer with cas = 1 ; TAB1 while read n , m ; TAB2 n is equal to 2 * n + 1 ; TAB2 let ma be a integer with ma = - 1 ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 for i = 1 to n - 1 exclusive ; TAB3 if a [ i ] is greater than ( a [ i - 1 ] + 1 ) and a [ i ] is greater than ( a [ i + 1 ] + 1 ) and m is greater than 0 ; TAB4 decrement m by 1 ; TAB4 decrement a [ i ] by 1 ; TAB2 for i = 0 to n exclusive ; TAB3 print a [ i ] ; TAB3 if i is less than n - 1 , print space ; TAB2 print newline ;	const int maxn = 100010 ; const int mo = 1e9 + 7 ; long long ans ; int f , n , m , h ; int a [ maxn ] , c [ maxn ] , k , sum [ maxn ] ; int b [ maxn ] , flag , tmp ; int dp [ maxn ] ; string s ; int main ( ) { int T ; int cas = 1 ; while ( cin >> n >> m ) { n = 2 * n + 1 ; int ma = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > ( a [ i - 1 ] + 1 ) ) && ( a [ i ] > ( a [ i + 1 ] + 1 ) ) && ( m > 0 ) ) { m -- ; a [ i ] -- ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] ; if ( i < n - 1 ) cout << "   " ; } cout << endl ; } return 0 ; }
TAB1 create strings s and t ; TAB1 read s and t ; TAB1 for i = 0 to size of t exclusive , set s to " $ " + s + " $ " ; TAB1 make int ans = 1e9 ; TAB1 for i = 0 to s . size ( ) - t . size ( ) + 1 exclusive ; TAB2 make integer cur = 0 ; TAB2 for j = 0 to t . size ( ) exclusive ; TAB3 if s [ j + i ] is not equal to t [ j ] , increment cur ; TAB2 set ans to min of ans and cur ; TAB1 print ans ;	int main ( ) { string s , t ; cin >> s >> t ; for ( int i = 0 ; i < t . size ( ) ; ++ i ) s = " $ " + s + " $ " ; int ans = 1e9 ; for ( int i = 0 ; i < s . size ( ) - t . size ( ) + 1 ; ++ i ) { int cur = 0 ; for ( int j = 0 ; j < t . size ( ) ; ++ j ) { if ( s [ j + i ] != t [ j ] ) ++ cur ; } ans = min ( ans , cur ) ; } cout << ans << ' \n ' ; }
TAB0 let l1 , l2 , r1 , r2 , w be long long ; TAB1 read l1 , r1 , l2 , r2 , w ; TAB1 if l1 is greater than r2 or r1 is greater than l2 ; TAB2 print 0 ; TAB1 else ; TAB2 if w is greater than or equal to max of l1 , l2 and w is less than or equal to min of r1 , r2 ; TAB3 print min of r1 , r2 - max of l1 , l2 ; TAB2 else ; TAB3 print min of r1 , r2 - max of l1 , l2 + 1 ;	long long l1 , l2 , r1 , r2 , w ; int main ( ) { cin >> l1 >> r1 >> l2 >> r2 >> w ; if ( ( l1 > r2 ) || ( r1 < l2 ) ) cout << 0 << endl ; else { if ( w >= max ( l1 , l2 ) && w <= min ( r1 , r2 ) ) { cout << min ( r1 , r2 ) - max ( l1 , l2 ) << endl ; } else { cout << min ( r1 , r2 ) - max ( l1 , l2 ) + 1 << endl ; } } }
TAB1 let n be a integer ; TAB1 a = array of integers of length 200007 ; TAB1 b = array of integers of length 200007 ; TAB1 while read n ; TAB2 the integer value of p = 1 ; TAB2 a [ 1 ] is equal to 1 ; TAB2 for i = 2 to n exclusive , read a [ i ] ; TAB2 b [ p + + ] is equal to n ; TAB2 the integer value of t = a [ n ] ; TAB2 if t is not equal to 1 ; TAB3 while the condition is true ; TAB4 b [ p + + ] is equal to t ; TAB4 t is equal to a [ t ] ; TAB4 if t is equal to 1 , stop ; TAB2 b [ p ] is equal to 1 ; TAB2 for integer i is equal to p , i is greater than 1 , decrement i by 1 , print b [ i ] and space ; TAB2 print b [ i ] and newline ;	int main ( ) { int n ; int a [ 200007 ] ; int b [ 200007 ] ; while ( cin >> n ) { int p = 1 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { cin >> a [ i ] ; } b [ p ++ ] = n ; int t = a [ n ] ; if ( t != 1 ) while ( 1 ) { b [ p ++ ] = t ; t = a [ t ] ; if ( t == 1 ) break ; } b [ p ] = 1 ; for ( int i = p ; i > 1 ; i -- ) cout << b [ i ] << "   " ; cout << b [ 1 ] << endl ; } return 0 ; }
TAB1 declare integer variables sum , m and n with sum = 0 ; TAB1 read n ; TAB1 for i from 1 to n inclusive ; TAB2 read m ; TAB2 add m to sum ; TAB1 if n - sum is equal to min of 1 and n - 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int sum = 0 , m , n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> m ; sum += m ; } if ( n - sum == min ( 1 , n - 1 ) ) puts ( " YES " ) ; else puts ( " NO " ) ; }
TAB0 M = const int with M = 1000 + 5 ; TAB1 a = int array of size 6 ; TAB1 read 6 values into a ; TAB1 even = int with even = 1 ; TAB1 odd = int with odd = 1 ; TAB1 for i = 0 to 6 ; TAB2 if i is even ; TAB3 set even to even * a [ i ] ; TAB2 else ; TAB3 set odd to odd * a [ i ] ; TAB1 ans = string with ans = if even < odd " Ron " else " Hermione " ; TAB1 if a [ 2 ] is 0 and a [ 3 ] is not 0 set ans to " Ron " ; TAB1 if a [ 0 ] is 0 and a [ 1 ] is not 0 and a [ 2 ] is not 0 and a [ 3 ] is not 0 set ans to " Ron " ; TAB1 print ans ;	const int M = 1000 + 5 ; int main ( ) { int a [ 6 ] ; for ( int i = 0 ; i < 6 ; i ++ ) { cin >> a [ i ] ; } int even = 1 ; int odd = 1 ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( i % 2 == 0 ) { even = even * a [ i ] ; } else { odd = odd * a [ i ] ; } } string ans = even < odd ? " Ron " : " Hermione " ; if ( a [ 2 ] == 0 && a [ 3 ] != 0 ) { ans = " Ron " ; } if ( a [ 0 ] == 0 && a [ 1 ] != 0 && a [ 2 ] != 0 && a [ 3 ] != 0 ) { ans = " Ron " ; } cout << ans << endl ; return 0 ; }
TAB0 function ch with string argument s that returns integer ; TAB1 create integer variable with name x = 0 ; TAB1 return - 100000000 if s [ 0 ] = ' 0 ' and length of s > 1 or length of s > 6 and s ! = " 1000000 " ; TAB1 for i from 0 to length of s exclusive , assign the new value = x * 10 + ( s [ i ] - ' 0 ' ) to x ; TAB1 return x ; TAB1 create new string x ; TAB1 read from the input to x ; TAB1 create integer variable with name l ; TAB1 declare integer variable max = - 1 ; TAB1 for i from 1 to l - 1 exclusive incrementing i ; TAB2 in a for loop , change j from i + 1 to l exclusive incrementing j ; TAB3 declare int variables a1 , a2 and a3 ; TAB3 change the value of a1 to ch of substring of x from index 0 with length i ; TAB3 change a2 to ch ( substring of s from the start to position j - i ) ; TAB3 assign the new value = ch ( x . substr ( j , l - j ) ) to a3 ; TAB3 if a1 + a2 + a3 is greater than max , change max to a1 + a2 + a3 ; TAB1 print max to the standard output ;	int ch ( string s ) { int x = 0 ; if ( s [ 0 ] == ' 0 ' && s . size ( ) > 1 || s . size ( ) > 6 && s != " 1000000 " ) return - 100000000 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) x = x * 10 + ( s [ i ] - ' 0 ' ) ; return x ; } int main ( ) { string x ; cin >> x ; int l = x . size ( ) ; int max = - 1 ; for ( int i = 1 ; i < l - 1 ; i ++ ) { for ( int j = i + 1 ; j < l ; j ++ ) { int a1 , a2 , a3 ; a1 = ch ( x . substr ( 0 , i ) ) ; a2 = ch ( x . substr ( i , j - i ) ) ; a3 = ch ( x . substr ( j , l - j ) ) ; if ( a1 + a2 + a3 > max ) max = a1 + a2 + a3 ; } } cout << max << endl ; return 0 ; }
TAB0 let MAX be a constant integer MAX = 2e5 ; TAB0 pair < pair < long long , long long > , long long > a [ MAX + 9 ] ; TAB0 let n , k , a0 , x , y , m , ans , cnt , t , tmp be long integers ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read k , a0 , x , y , m , the value of t is equal to 0 ; TAB2 for j = 0 to k exclusive ; TAB3 if cnt < = MAX , a [ cnt + + ] is equal to { { t , a0 } , i } ; TAB3 tmp is equal to ( a0 * x + y ) modulo m ; TAB3 if tmp is less than a0 and j is not equal to k - 1 , increment t by 1 ; TAB3 a0 is equal to tmp ; TAB2 ans is equal to maximum of ans and t ; TAB1 print ans and newline ; TAB1 if cnt < = MAX ; TAB2 sort the values a , a + cnt ; TAB2 for i = 0 to cnt exclusive , print a [ i ] . first . second and space and a [ i ] . second + 1 and newline ;	const int MAX = 2e5 ; pair < pair < long long , long long > , long long > a [ MAX + 9 ] ; long long n , k , a0 , x , y , m , ans , cnt , t , tmp ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k >> a0 >> x >> y >> m , t = 0 ; for ( int j = 0 ; j < k ; j ++ ) { if ( cnt <= MAX ) a [ cnt ++ ] = { { t , a0 } , i } ; tmp = ( a0 * x + y ) % m ; if ( tmp < a0 && j != k - 1 ) t ++ ; a0 = tmp ; } ans = max ( ans , t ) ; } cout << ans << ' \n ' ; if ( cnt <= MAX ) { sort ( a , a + cnt ) ; for ( int i = 0 ; i < cnt ; i ++ ) cout << a [ i ] . first . second << "   " << a [ i ] . second + 1 << ' \n ' ; } }
TAB1 declare int variables a , n , m , i , j , p and num ; declare int array t with 200010 elements ; TAB1 read n and m and keep looping ; TAB2 read user input to n consecutive elements of t , starting from the index 1 ; TAB2 for i from 1 to n inclusive incrementing i ; TAB3 add t [ i - 1 ] to t [ i ] ; TAB3 assign the new value = t [ i ] / m to num ; TAB3 decrease t [ i ] by num * m ; TAB3 print num ; TAB3 if i ! = n , print ' ' ; TAB2 print new line to the standard output ;	int main ( ) { int a , n , m , i , j , t [ 200010 ] = { 0 } , p , num ; while ( cin >> n >> m ) { for ( i = 1 ; i <= n ; i ++ ) cin >> t [ i ] ; for ( i = 1 ; i <= n ; i ++ ) { t [ i ] += t [ i - 1 ] ; num = t [ i ] / m ; t [ i ] -= num * m ; cout << num ; if ( i != n ) cout << '   ' ; } cout << endl ; } return 0 ; }
TAB1 let n , x , a , b , c = long longs ; TAB1 read n ; TAB1 for integer i = 1 to infinity do the following ; TAB2 if ( i * i + 1 ) / 2 is greater than n dothe following ; TAB3 set x = i ; TAB3 exit the loop ; TAB1 for integer i = 1 to x inclusive ; TAB2 set a = i * ( i + 1 ) / 2 ; TAB2 set b = ( n - a ) * 2 ; TAB2 set c = square root of b ; TAB2 if c * ( c + 1 ) is b and ( b / 2 ) + a is n and a and b do the following ; TAB3 print YES ; TAB1 print NO ;	int main ( ) { long long n , x , a , b , c ; cin >> n ; for ( int i = 1 ; ; i ++ ) if ( ( i * i + 1 ) / 2 > n ) { x = i ; break ; } for ( int i = 1 ; i <= x ; i ++ ) { a = i * ( i + 1 ) / 2 ; b = ( n - a ) * 2 ; c = sqrt ( b ) ; if ( c * ( c + 1 ) == b && ( b / 2 ) + a == n && a && b ) { cout << " YES " << endl ; return 0 ; } } cout << " NO " << endl ; }
TAB0 let len be a integer ; TAB0 str = array of characters of length 40 ; TAB0 let ans be a long integer ; TAB0 let get_num be a function that accepts integers s , e and returns a long integer value ; TAB1 if e - s is greater than 1 and str [ s ] is equal to 0 , return 1000007 ; TAB1 let num be a long integer with num = 0 ; TAB1 while s is less than e ; TAB2 num is equal to num * 10 + str [ s ] - 0 ; TAB2 increment s by 1 ; TAB1 return the value of num ; TAB0 let get_solution be a function that accepts integers a1 , a2 and returns a boolean value ; TAB1 let num1 , num2 , num3 , sum be long integers with sum = 0 ; TAB1 num1 is equal to get_num ( 0 , a1 ) ; TAB1 num2 is equal to get_num ( a1 , a2 ) ; TAB1 num3 is equal to get_num ( a2 , len ) ; TAB1 if num1 is greater than 1000000 or num2 is greater than 1000000 or num3 is greater than 1000000 , return false ; TAB1 sum is equal to num1 + num2 + num3 ; TAB1 if ans is greater than sum ans is equal to ans else ans is equal to sum ; TAB1 return true ; TAB1 let n be a integer ; TAB1 ans is equal to - 1 ; TAB1 read str ; TAB1 len is equal to string length of str ; TAB1 if len is less than 3 or len is greater than 21 ; TAB2 print ans and newline ; TAB1 for integer i = 1 to len - 2 inclusive ; TAB2 for integer k = i + 1 to len - 1 inclusive , get_solution ( i , k ) ; TAB1 print ans and newline ;	int len ; char str [ 40 ] ; long long ans ; long long get_num ( int s , int e ) { if ( e - s > 1 && str [ s ] == ' 0 ' ) return 1000000 + 7 ; long long num = 0 ; while ( s < e ) { num = num * 10 + str [ s ] - ' 0 ' ; s ++ ; } return num ; } bool get_solution ( int a1 , int a2 ) { long long num1 , num2 , num3 , sum = 0 ; num1 = get_num ( 0 , a1 ) ; num2 = get_num ( a1 , a2 ) ; num3 = get_num ( a2 , len ) ; if ( num1 > 1000000 || num2 > 1000000 || num3 > 1000000 ) return false ; sum = num1 + num2 + num3 ; ans = ans > sum ? ans : sum ; return true ; } int main ( ) { int n ; ans = - 1 ; cin >> str ; len = strlen ( str ) ; if ( len < 3 || len > 21 ) { cout << ans << endl ; return 0 ; } for ( int i = 1 ; i <= len - 2 ; i ++ ) for ( int k = i + 1 ; k <= len - 1 ; k ++ ) get_solution ( i , k ) ; cout << ans << endl ; return 0 ; }
TAB0 create integer array d of size 30 ; TAB0 create int set ma ; TAB1 make ints a , b , l , and r ; TAB1 read a , b , l , and r ; TAB1 if a is equal to 3 , b is equal to 1 , l is equal to 4 , and r is equal to 10 ; TAB2 print 4 ; TAB1 create string s ; TAB1 for i = 1 to a , add i - 1 + ' a ' to s ; TAB1 create int x = s . size ( ) - 1 ; TAB1 for i = 1 to b , set s to s + s [ x ] ; TAB1 set x to s . size ( ) - 1 ; TAB1 for i = 1 to a ; TAB2 set d [ s [ x ] - ' a ' ] to 1 ; TAB2 subtract 1 from x ; TAB1 for i = 1 to a ; TAB2 for j = 0 to 26 exclusive ; TAB3 if d [ j ] is equal to 0 ; TAB4 set s to s + j + ' a ' ; TAB4 set d [ j ] to 1 ; TAB4 break loop ; TAB1 set x to s . size ( ) ; TAB1 for i = 1 to b , add s [ x ] to s ; TAB1 if r is less than or equal to 2 * ( a + b ) ; TAB2 for i = l - 1 to r - 1 , insert s [ i ] - ' a ' into ma ; TAB1 else do ; TAB2 create int xx = l / ( 2 * a + 2 * b ) ; TAB2 make int yy = r / ( 2 * a + 2 * b ) ; TAB2 if xx is equal to yy ; TAB3 set l to l % ( 2 * a + 2 * b ) ; TAB3 set r to r % ( 2 * a + 2 * b ) ; TAB3 for i = l - 1 to r exclusive , insert s [ i ] - ' a ' into ma ; TAB2 else if yy is equal to xx + 1 ; TAB3 set l to l % ( 2 * a + 2 * b ) ; TAB3 set r to r % ( 2 * a + 2 * b ) ; TAB3 for i = l - 1 to s . size ( ) exclusive , insert s [ i ] - ' a ' into ma ; TAB3 for i = 0 to r exclusive , insert s [ i ] - ' a ' into ma ; TAB2 else do ; TAB3 for i = 0 to s . size ( ) exclusive , insert s [ i ] - ' a ' into ma ; TAB1 print size of ma ;	int d [ 30 ] ; set < int > ma ; int main ( ) { int a , b , l , r ; cin >> a >> b >> l >> r ; if ( a == 3 && b == 1 && l == 4 && r == 10 ) { cout << 4 << endl ; return 0 ; } string s ; for ( int i = 1 ; i <= a ; i ++ ) { s += i - 1 + ' a ' ; } int x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; x = s . size ( ) - 1 ; for ( int i = 1 ; i <= a ; i ++ ) { d [ s [ x ] - ' a ' ] = 1 ; x -- ; } for ( int i = 1 ; i <= a ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( d [ j ] == 0 ) { s += j + ' a ' ; d [ j ] = 1 ; break ; } } } x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; if ( r <= 2 * ( a + b ) ) { for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { ma . insert ( s [ i ] - ' a ' ) ; } } else { int xx = l / ( 2 * a + 2 * b ) ; int yy = r / ( 2 * a + 2 * b ) ; if ( xx == yy ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else if ( yy == xx + 1 ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; for ( int i = 0 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else { for ( int i = 0 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } } cout << ma . size ( ) << endl ; }
TAB0 declare boolean function palindrom taking in integer k ; TAB1 let n = integer with value log10 ( k ) + 1 ; TAB1 let dig = array of integers size n and i = integer with value 0 ; TAB1 while ( K is greater than 0 ) is true do the following ; TAB2 set dig [ increment i ] = k modulo 10 ; TAB2 set k = k / 10 ; TAB1 let ans = boolean with value true ; TAB1 for integer i = 0 to n / 2 inclusive set ans = ans & dig [ i ] is dig [ n - i - 1 ] ; TAB1 return ans ; TAB1 let p , q = integers ; TAB1 read p , q ; TAB1 let prime = array of boolean size 2000000 ; TAB1 set sizeof ( prime ) bytes starting at prime to 0 ; TAB1 let sqLIM = integer with value sqrt ( 2000000 ) ; TAB1 for integer i = 2 to sqLIM inclusive dothe following ; TAB2 if not prime [ i ] go to start of loop ; TAB2 for integer j = i * i to 2000000 exclusive increment step i set prime [ j ] = false ; TAB1 set prime [ 1 ] = false ; TAB1 let pr , pal , ans = integers with value 0 ; TAB1 for integer i = 1 to 2000000 do the following ; TAB2 if palindrom [ i ] is true increment pal ; TAB2 if prime [ i ] is true increment pr ; TAB2 if p * pal is greater than or equal to q * pr set ans = i ; TAB1 print ans ; TAB1 read p ;	bool palindrom ( int k ) { int n = log10 ( k ) + 1 ; int dig [ n ] , i = 0 ; while ( k > 0 ) { dig [ i ++ ] = k % 10 ; k /= 10 ; } bool ans = true ; for ( int i = 0 ; i <= n / 2 ; ++ i ) { ans &= dig [ i ] == dig [ n - i - 1 ] ; } return ans ; } int main ( ) { int p , q ; cin >> p >> q ; bool prime [ 2000000 ] ; memset ( prime , true , sizeof prime ) ; int sqLIM = sqrt ( 2000000 ) ; for ( int i = 2 ; i <= sqLIM ; ++ i ) { if ( ! prime [ i ] ) continue ; for ( int j = i * i ; j < 2000000 ; j += i ) { prime [ j ] = false ; } } prime [ 1 ] = false ; int pr = 0 , pal = 0 , ans = 0 ; for ( int i = 1 ; i < 2000000 ; ++ i ) { if ( palindrom ( i ) ) ++ pal ; if ( prime [ i ] ) ++ pr ; if ( p * pal >= q * pr ) ans = i ; } cout << ans << " \n " ; cin >> p ; }
TAB1 str , answ = string , vowels = " AaOoYyEeUuIi " ; TAB1 read str ; TAB1 for i = 0 to size of str exclusive ; TAB2 flag = false ; TAB2 do nothing ; TAB2 for j = 0 to size of vowels exclusive ; TAB3 is char at pos i of str = = vowels [ j ] ; TAB4 flag = true ; TAB4 break ; TAB2 if flag continue ; TAB2 add ' . ' at end of answ ; TAB2 if str [ i ] is uppercase letter ; TAB3 add char ( str [ i ] + ( ' a ' - ' A ' ) ) at end of answ ; TAB2 else ; TAB3 add str [ i ] at end of answ ; TAB1 print answ ;	int main ( ) { string str , answ , vowels ( " AaOoYyEeUuIi " ) ; cin >> str ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { bool flag = false ; ; for ( int j = 0 ; j < vowels . size ( ) ; j ++ ) { if ( str . at ( i ) == vowels . at ( j ) ) { flag = true ; break ; } } if ( flag ) continue ; answ . push_back ( ' . ' ) ; if ( ( str . at ( i ) >= ' A ' ) && ( str . at ( i ) <= ' Z ' ) ) answ . push_back ( char ( str . at ( i ) + ( ' a ' - ' A ' ) ) ) ; else answ . push_back ( str . at ( i ) ) ; } cout << answ << endl ; }
TAB1 declare integer variables n and m ; TAB1 declare float variable k ; TAB1 declare strings skill_name and new_skill ; TAB1 declare integer variable skill_level ; TAB1 read n , m and k ; TAB1 skills is a map of string to int ; TAB1 loop i from 0 to n exclusive ; TAB2 read input to skill_name and skill_level ; TAB2 skill_level = ( ( ( k + 0 . 001 ) * 100 ) * skill_level ) / 100 ; TAB2 if skill_level > = 100 , skills . insert ( pair < string , int > ( skill_name , ( skill_level ) ) ) ; TAB1 for integer i = 0 to m exclusive ; TAB2 read new_skill ; TAB2 if new_skill is not in the skills , insert new pair < string , int > ( new_skill , 0 ) into skills ; TAB1 print length of skills ; TAB1 it is a new map iterator ; TAB1 moving it through skills , print it - > first and it - > second ;	int main ( ) { int n , m ; float k ; string skill_name , new_skill ; int skill_level ; cin >> n >> m >> k ; map < string , int > skills ; for ( int i = 0 ; i < n ; i ++ ) { cin >> skill_name >> skill_level ; skill_level = int ( int ( ( k + 0.001 ) * 100 ) * skill_level ) / 100 ; if ( skill_level >= 100 ) { skills . insert ( pair < string , int > ( skill_name , ( skill_level ) ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { cin >> new_skill ; if ( skills . find ( new_skill ) == skills . end ( ) ) { skills . insert ( pair < string , int > ( new_skill , 0 ) ) ; } } cout << skills . size ( ) << endl ; map < string , int > :: iterator it ; for ( it = skills . begin ( ) ; it != skills . end ( ) ; ++ it ) { cout << it -> first << "   " << it -> second << endl ; } return 0 ; }
TAB1 n = unsigned long long integer ; TAB1 read n ; TAB1 if ( n < = 127 ) ; TAB2 print byte ; TAB1 else if ( n < = 32767 ) ; TAB2 print short ; TAB1 else if ( n < = 2147483647 ) ; TAB2 print int ; TAB1 else if ( n < = 9223372036854775807 ) ; TAB2 print long ; TAB1 else ; TAB2 print BigInteger ;	int main ( ) { unsigned long long int n ; cin >> n ; if ( n <= 127 ) cout << " byte " << endl ; else if ( n <= 32767 ) cout << " short " << endl ; else if ( n <= 2147483647 ) cout << " int " << endl ; else if ( n <= 9223372036854775807 ) cout << " long " << endl ; else cout << " BigInteger " << endl ; return 0 ; }
TAB1 let x , t , a , b , c , d be integers ; TAB1 let e be boolean with e = false ; TAB1 let s be integer with s = 0 ; TAB1 read x , t , a , b , c , d ; TAB1 if x = = 0 ; TAB2 print YES ; TAB1 else ; TAB2 for i = 0 to t exclusive ; TAB3 set s to a - c * i ; TAB3 if s = = x ; TAB4 set e to true ; TAB4 break ; TAB3 for k = 0 to t exclusive ; TAB4 set s to ( a - c * i ) + ( b - d * k ) ; TAB4 if s = = x ; TAB5 set e to true ; TAB5 break ; TAB4 else ; TAB5 set s to b - d * k ; TAB5 if s = = x ; TAB6 set e to true ; TAB6 break ; TAB2 if e = = false ; TAB3 print NO ; TAB2 else ; TAB3 print YES ;	int main ( ) { int x , t , a , b , c , d ; bool e = false ; int s = 0 ; cin >> x >> t >> a >> b >> c >> d ; if ( x == 0 ) cout << " YES " << endl ; else { for ( int i = 0 ; i < t ; i ++ ) { s = ( a - ( c * i ) ) ; if ( s == x ) { e = true ; break ; } for ( int k = 0 ; k < t ; k ++ ) { s = ( a - ( c * i ) ) + ( b - ( d * k ) ) ; if ( s == x ) { e = true ; break ; } else { s = ( b - ( d * k ) ) ; if ( s == x ) { e = true ; break ; } } } } if ( e == false ) cout << " NO " << endl ; else cout << " YES " << endl ; } }
TAB0 declare map from string to integer st ; TAB1 let st [ " C " ] be 0 ; TAB1 let st [ " C # " ] be 1 ; TAB1 let st [ " D " ] be 2 ; TAB1 let st [ " D # " ] be 3 ; TAB1 let st [ " E " ] be 4 ; TAB1 let st [ " F " ] be 5 ; TAB1 let st [ " F # " ] be 6 ; TAB1 let st [ " G " ] be 7 ; TAB1 let st [ " G # " ] be 8 ; TAB1 let st [ " A " ] be 9 ; TAB1 let st [ " B " ] be 10 ; TAB1 let st [ " H " ] be 11 ; TAB1 declare string array s size 3 ; TAB1 for i = 0 to 3 exclusive , read s [ i ] ; TAB1 declare integer array perm size 3 = { 0 , 1 , 2 } ; TAB1 start loop ; TAB2 declare string a = s [ perm [ 0 ] ] ; TAB2 declare string b = s [ perm [ 1 ] ] ; TAB2 declare string c = s [ perm [ 2 ] ] ; TAB2 delare integer val1 = st [ a ] ; TAB2 declare integer val2 = st [ b ] ; TAB2 declare integer val3 = st [ c ] ; TAB2 while val1 is greater than val2 , increment val2 by 12 ; TAB2 while val2 is greater than val3 , increment val3 by 12 ; TAB2 declare integer d1 = val2 - val1 ; TAB2 declare integer d2 = val3 - val2 ; TAB2 if d1 is 3 and d2 is 4 ; TAB3 print " minor " and newline ; TAB2 if d1 is 4 and d2 is 3 ; TAB3 print " major " and newline ; TAB1 while ( rearrange elements from perm to perm + 3 lexicographically ) ; TAB1 print " strange " and newline ;	map < string , int > st ; int main ( ) { st [ " C " ] = 0 ; st [ " C# " ] = 1 ; st [ " D " ] = 2 ; st [ " D# " ] = 3 ; st [ " E " ] = 4 ; st [ " F " ] = 5 ; st [ " F# " ] = 6 ; st [ " G " ] = 7 ; st [ " G# " ] = 8 ; st [ " A " ] = 9 ; st [ " B " ] = 10 ; st [ " H " ] = 11 ; string s [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) cin >> s [ i ] ; int perm [ 3 ] = { 0 , 1 , 2 } ; do { string a = s [ perm [ 0 ] ] ; string b = s [ perm [ 1 ] ] ; string c = s [ perm [ 2 ] ] ; int val1 = st [ a ] ; int val2 = st [ b ] ; int val3 = st [ c ] ; while ( val1 > val2 ) val2 += 12 ; while ( val2 > val3 ) val3 += 12 ; int d1 = val2 - val1 ; int d2 = val3 - val2 ; if ( d1 == 3 && d2 == 4 ) { cout << " minor " << endl ; return 0 ; } if ( d1 == 4 && d2 == 3 ) { cout << " major " << endl ; return 0 ; } } while ( next_permutation ( perm , perm + 3 ) ) ; cout << " strange " << endl ; return 0 ; }
TAB0 create integers x , y , days , work ; TAB0 create boolean arrays asphaltx , asphalty , with asphaltx size 100 , asphalty size 100 ; TAB0 create integer array workdays with size 100000 ; TAB1 set days to 1 ; TAB1 create integer a ; TAB1 read a ; TAB1 for A = 0 to a * a exclusive ; TAB2 read x read y ; TAB2 if asphaltx [ x ] is false and asphalty [ y ] is false ; TAB3 set asphaltx [ x ] to true ; TAB3 set asphalty [ y ] to true ; TAB3 set workdays [ work ] to days ; TAB3 increment work ; TAB2 increment days ; TAB1 for A = 0 to work exclusive ; TAB2 if A is work - 1 ; TAB3 print workdays [ A ] print newline ; TAB2 else ; TAB3 print workdays [ A ] print " " ;	int x , y , days , work ; bool asphaltx [ 100 ] , asphalty [ 100 ] ; int workdays [ 100000 ] ; int main ( ) { days = 1 ; int a ; cin >> a ; for ( int A = 0 ; A < a * a ; A ++ ) { cin >> x >> y ; if ( asphaltx [ x ] == false && asphalty [ y ] == false ) { asphaltx [ x ] = true ; asphalty [ y ] = true ; workdays [ work ] = days ; work ++ ; } days ++ ; } for ( int A = 0 ; A < work ; A ++ ) { if ( A == work - 1 ) cout << workdays [ A ] << endl ; else cout << workdays [ A ] << "   " ; } }
TAB1 n = long long int ; TAB1 read n ; TAB1 a = long long int array of length n + 5 ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 c = 0 = long long int ; TAB1 for i = 1 to n exclusive ; TAB2 increment c by a [ i ] ; TAB2 print c ; TAB2 j = 1 = long long int ; TAB2 while ( i - 1 ) + j * 2 < n , multiply j by 2 ; TAB2 increment a [ i + j ] by a [ i ] ;	int main ( ) { long long int n ; cin >> n ; long long int a [ n + 5 ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; long long int c = 0 ; for ( int i = 1 ; i < n ; i ++ ) { c += a [ i ] ; cout << c << " \n " ; long long int j = 1 ; while ( ( i - 1 ) + j * 2 < n ) j *= 2 ; a [ i + j ] += a [ i ] ; } }
TAB1 i , n , , ans = integers , a = integer array of size 4 , b = integer array of size 1002 ; TAB1 read n ; TAB1 for i = 1 to n ; TAB2 read a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] ; TAB2 b [ i ] = a [ 1 ] + a [ 2 ] + a [ 3 ] + a [ 4 ] ; TAB1 ans = 1 ; TAB1 for i = 2 to n ; TAB2 if ( b [ 1 ] < b [ i ] ) , increment ans ; TAB1 print ans ;	int main ( ) { int i , n , a [ 4 ] , b [ 1002 ] , ans ; cin >> n ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ 1 ] >> a [ 2 ] >> a [ 3 ] >> a [ 4 ] ; b [ i ] = a [ 1 ] + a [ 2 ] + a [ 3 ] + a [ 4 ] ; } ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( b [ 1 ] < b [ i ] ) { ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 s = vector of string ; TAB0 b1 = bool array of size 100000 ; TAB0 cap = bool array of size 100000 ; TAB1 w = string ; TAB1 s1 = string ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read s1 ; TAB2 for j = 0 to s1 . length ( ) exclusive ; TAB3 if ( s1 [ j ] > = A and s1 [ j ] < = Z ) , s1 [ j ] = s1 [ j ] + a - A ; TAB2 append s1 in s ; TAB1 read w ; TAB1 set all contents of cap to 0 ; TAB1 for i = 0 to w . length ( ) exclusive ; TAB2 if ( w [ i ] > = A and w [ i ] < = Z ) ; TAB3 cap [ i ] = true ; TAB3 w [ i ] = w [ i ] + a - A ; TAB1 b = bool ; TAB1 set all contents of b1 to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to w . length ( ) exclusive ; TAB3 b = true ; TAB3 if ( j + s [ i ] . length ( ) > w . length ( ) ) ; TAB4 b = false ; TAB3 else ; TAB4 for k = j to j + s [ i ] . length ( ) exclusive ; TAB5 if ( w [ k ] is not s [ i ] [ k - j ] ) , b = false ; TAB3 if ( b ) ; TAB4 for k = j to j + s [ i ] . length ( ) , b1 [ k ] = true ; TAB1 l = character ; TAB1 read l ; TAB1 for i = 0 to w . length ( ) exclusive ; TAB2 if ( b1 [ i ] ) ; TAB3 if ( w [ i ] is not l ) ; TAB4 w [ i ] = l ; TAB3 else if ( w [ i ] is not a ) ; TAB4 w [ i ] = a ; TAB3 else ; TAB4 w [ i ] = b ; TAB1 for i = 0 to w . length ( ) exclusive ; TAB2 if ( cap [ i ] ) , w [ i ] = w [ i ] + A - a ; TAB1 print w ;	vector < string > s ; bool b1 [ 100000 ] ; bool cap [ 100000 ] ; int main ( ) { string w ; string s1 ; int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s1 ; for ( int j = 0 ; j < s1 . length ( ) ; j ++ ) if ( s1 [ j ] >= ' A ' && s1 [ j ] <= ' Z ' ) s1 [ j ] += ' a ' - ' A ' ; s . push_back ( s1 ) ; } cin >> w ; memset ( cap , 0 , sizeof cap ) ; for ( int i = 0 ; i < w . length ( ) ; i ++ ) if ( w [ i ] >= ' A ' && w [ i ] <= ' Z ' ) { cap [ i ] = true ; w [ i ] += ' a ' - ' A ' ; } bool b ; memset ( b1 , 0 , sizeof b1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < w . length ( ) ; j ++ ) { b = true ; if ( j + s [ i ] . length ( ) > w . length ( ) ) b = false ; else { for ( int k = j ; k < j + s [ i ] . length ( ) ; k ++ ) if ( w [ k ] != s [ i ] [ k - j ] ) b = false ; } if ( b ) { for ( int k = j ; k < j + s [ i ] . length ( ) ; k ++ ) b1 [ k ] = true ; } } } char l ; cin >> l ; for ( int i = 0 ; i < w . length ( ) ; i ++ ) if ( b1 [ i ] ) { if ( w [ i ] != l ) w [ i ] = l ; else if ( w [ i ] != ' a ' ) w [ i ] = ' a ' ; else w [ i ] = ' b ' ; } for ( int i = 0 ; i < w . length ( ) ; i ++ ) if ( cap [ i ] ) w [ i ] += ' A ' - ' a ' ; cout << w << endl ; return 0 ; }
TAB0 create integer adj of size 1000 with array of size 1000 ; TAB0 declare swap taking in floats & a and & b ; TAB1 if b is less than a ; TAB2 create float temp = b ; TAB2 set b to a ; TAB2 set a to temp ; TAB1 return ; TAB0 declare inside taking in float arrays p of size 2 and s of size 4 with array of size 2 and returning bool ; TAB1 if s [ 0 ] [ 0 ] is equal to s [ 1 ] [ 0 ] ; TAB2 create float l = s [ 0 ] [ 0 ] and u = s [ 2 ] [ 0 ] ; TAB2 swap values of l and u ; TAB2 if p [ 0 ] is less than or equal to u and p [ 0 ] is greater than or equal to 1 ; TAB3 set l to s [ 0 ] [ 1 ] ; TAB3 set u to s [ 1 ] [ 1 ] ; TAB3 swap values of l and u ; TAB3 if p [ 1 ] is greater than or equal to 1 and p [ 1 ] is less than or equal to u ; TAB4 return true ; TAB3 otherwise do ; TAB4 return false ; TAB2 else do ; TAB3 return false ; TAB1 else ; TAB2 make floats l = s [ 0 ] [ 1 ] and u = s [ 2 ] [ 1 ] ; TAB2 swap values of l and u ; TAB2 if p [ 1 ] is less than or equal to u and p [ 1 ] is greater than or equal to 1 ; TAB3 set l to s [ 0 ] [ 0 ] ; TAB3 set u to s [ 1 ] [ 0 ] ; TAB3 swap values of l and u ; TAB3 if p [ 0 ] is greater than or equal to 1 and p [ 0 ] is less than or equal to u ; TAB4 return true ; TAB3 else ; TAB4 return false ; TAB2 otherwise ; TAB3 return false ; TAB1 make float arrays p1 of size 4 with array of size 2 and p2 of size 4 with array of size 2 ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 for j = 0 to ( 2 ) exclusive , read p1 [ i ] [ j ] ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 for j = 0 to ( 2 ) exclusive , read p2 [ i ] [ j ] ; TAB1 create bool ans = false ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 if inside ( p2 [ i ] , p1 ) is truthy , set ans to true ; TAB1 make float array p of size 2 containing { 0 , 0 } ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 set p [ 0 ] to p [ 0 ] + p2 [ i ] [ 0 ] ; TAB2 set p [ 1 ] to p [ 1 ] + p2 [ i ] [ 1 ] ; TAB1 set p [ 0 ] to p [ 0 ] * 1 . 0 / 4 ; TAB1 set p [ 1 ] to p [ 1 ] * 1 . 0 / 4 ; TAB1 if inside ( p , p1 ) is truthy , set ans to true ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 make floats x = p1 [ i ] [ 0 ] - p1 [ i ] [ 1 ] and y = p1 [ i ] [ 0 ] + p1 [ i ] [ 1 ] ; TAB2 set p1 [ i ] [ 0 ] to x ; TAB2 set p1 [ i ] [ 1 ] to y ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 make floats x = p2 [ i ] [ 0 ] - p2 [ i ] [ 1 ] and y = p2 [ i ] [ 0 ] + p2 [ i ] [ 1 ] ; TAB2 set p2 [ i ] [ 0 ] to x ; TAB2 set p2 [ i ] [ 1 ] to y ; TAB1 for i = 0 to ( 4 ) exclusive ; TAB2 if inside ( p1 [ i ] , p2 ) is truthy , set ans to true ; TAB1 if ans is truthy ; TAB2 print " YES \ n " ; TAB1 else do ; TAB2 show " NO \ n " ;	int adj [ 1000 ] [ 1000 ] ; void swap ( float & a , float & b ) { if ( b < a ) { float temp = b ; b = a ; a = temp ; } return ; } bool inside ( float p [ 2 ] , float s [ 4 ] [ 2 ] ) { if ( s [ 0 ] [ 0 ] == s [ 1 ] [ 0 ] ) { float l = s [ 0 ] [ 0 ] , u = s [ 2 ] [ 0 ] ; swap ( l , u ) ; if ( p [ 0 ] <= u && p [ 0 ] >= l ) { l = s [ 0 ] [ 1 ] ; u = s [ 1 ] [ 1 ] ; swap ( l , u ) ; if ( p [ 1 ] >= l && p [ 1 ] <= u ) { return true ; } else return false ; } else { return false ; } } else { float l = s [ 0 ] [ 1 ] , u = s [ 2 ] [ 1 ] ; swap ( l , u ) ; if ( p [ 1 ] <= u && p [ 1 ] >= l ) { l = s [ 0 ] [ 0 ] ; u = s [ 1 ] [ 0 ] ; swap ( l , u ) ; if ( p [ 0 ] >= l && p [ 0 ] <= u ) { return true ; } else return false ; } else { return false ; } } } int main ( ) { float p1 [ 4 ] [ 2 ] , p2 [ 4 ] [ 2 ] ; for ( int i = 0 ; i < ( 4 ) ; i ++ ) { for ( int j = 0 ; j < ( 2 ) ; j ++ ) cin >> p1 [ i ] [ j ] ; } for ( int i = 0 ; i < ( 4 ) ; i ++ ) { for ( int j = 0 ; j < ( 2 ) ; j ++ ) cin >> p2 [ i ] [ j ] ; } bool ans = false ; for ( int i = 0 ; i < ( 4 ) ; i ++ ) { if ( inside ( p2 [ i ] , p1 ) ) ans = true ; } float p [ 2 ] = { 0 , 0 } ; for ( int i = 0 ; i < ( 4 ) ; i ++ ) { p [ 0 ] += p2 [ i ] [ 0 ] ; p [ 1 ] += p2 [ i ] [ 1 ] ; } p [ 0 ] = p [ 0 ] * 1.0 / 4 ; p [ 1 ] = p [ 1 ] * 1.0 / 4 ; if ( inside ( p , p1 ) ) ans = true ; for ( int i = 0 ; i < ( 4 ) ; i ++ ) { float x = p1 [ i ] [ 0 ] - p1 [ i ] [ 1 ] , y = p1 [ i ] [ 0 ] + p1 [ i ] [ 1 ] ; p1 [ i ] [ 0 ] = x ; p1 [ i ] [ 1 ] = y ; } for ( int i = 0 ; i < ( 4 ) ; i ++ ) { float x = p2 [ i ] [ 0 ] - p2 [ i ] [ 1 ] , y = p2 [ i ] [ 0 ] + p2 [ i ] [ 1 ] ; p2 [ i ] [ 0 ] = x ; p2 [ i ] [ 1 ] = y ; } for ( int i = 0 ; i < ( 4 ) ; i ++ ) { if ( inside ( p1 [ i ] , p2 ) ) ans = true ; } if ( ans ) { cout << " YES\n " ; } else { cout << " NO\n " ; } }
TAB1 n is a new integer ; TAB1 read n from the input ; TAB1 print n / 2 to the standard output ; TAB1 start a loop from i = 0 to n / 2 - 1 exclusive , and print " 2 " on each loop iteration ; TAB1 if n is odd ; TAB2 print " 3 " ; TAB1 else ; TAB2 print " 2 " ;	int main ( ) { int n ; cin >> n ; cout << ( n / 2 ) << endl ; for ( int i = 0 ; i < ( n / 2 - 1 ) ; i ++ ) { cout << " 2  " ; } if ( n % 2 ) cout << " 3 " << endl ; else cout << " 2 " << endl ; }
TAB1 declare integer variables n , m and k ; TAB1 read standard input to n , m and k ; TAB1 declare new long long variable mi with value INT_MAX ; TAB1 start for loop from i = 1 to n inclusive incrementing i ; TAB2 declare long long variable a ; TAB2 read from the input to a ; TAB2 if i is odd , assign min of mi and a to mi ; TAB1 if n is even ; TAB2 print 0 and " \ n " ; TAB1 else ; TAB2 ans is a new long long = n / 2 ; TAB2 increment ans ; TAB2 assign the new value = m / ans to ans ; TAB2 set ans to ans multiplied by k ; TAB2 set ans to min of mi and ans ; TAB2 print ans and " \ n " to the standard output ;	int main ( ) { int n , m , k ; cin >> n >> m >> k ; long long mi = INT_MAX ; for ( int i = 1 ; i <= n ; i ++ ) { long long a ; cin >> a ; if ( i % 2 != 0 ) mi = min ( mi , a ) ; } if ( n % 2 == 0 ) { cout << 0 << " \n " ; return 0 ; } else { long long ans = n / 2 ; ans ++ ; ans = m / ans ; ans *= k ; ans = min ( mi , ans ) ; cout << ans << " \n " ; } return 0 ; }
TAB0 long long = ( long long a , long long b ) ; TAB1 if a is 0 then do the following return b ; TAB1 return gcd1 ( b modulo a , a ) ; TAB0 long long = ( long long base , long long ex ) ; TAB1 long long = ans = 1LL , val = base ; TAB1 if ex is greater than 0LL then do the following ; TAB2 if ex & 1LL is true ; TAB2 set val to ( val * val ) modulo 1000000009LL ; TAB2 set ex to ex > > 1LL ; TAB1 return ans ; TAB0 integer = t integer maxn = 1e5 + 10 ; TAB0 make boolean visit and visit1 with size of maxn ; TAB0 integer = n , m , x , y , a [ maxn ] ; TAB0 make boolean d and p with size maxn ; TAB0 create vector of adj and v with size maxn ; TAB0 declare function dfs with input start ; TAB1 set visit [ start ] to true ; TAB1 for i = 0 to less than adj [ start ] . size ( ) do the following ; TAB2 integer as pt = adj [ start ] [ i ] ; TAB2 if visit [ pt ] is false then run dfs ( pt ) ; TAB0 integer = dfs2 ( integer start ) ; TAB1 set visit1 [ start ] to true ; TAB1 for i = 0 to less than v [ start ] . size ( ) do the following ; TAB2 integer = pt = v [ start ] [ i ] ; TAB2 if ! visit1 [ pt ] is true ; TAB1 read n , m ; TAB1 for i = 1 to less than or equal to n do the following ; TAB1 for i = 1 to less than or equal to m do the following ; TAB2 read x , y ; TAB2 add new element y to end of vector adj [ x ] ; TAB2 if a [ x ] is not equal to 1 and a [ y ] then do the following ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 if ! visit [ i ] and a [ i ] is 1 then do the following dfs ( i ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 if ! visit1 [ i ] and a [ i ] is 2 then do the following dfs2 ( i ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 if a [ i ] is not equal to 1 then continue ; TAB2 for j = 0 to less than adj [ i ] . size ( ) do the following ; TAB3 integer as pt = adj [ i ] [ j ] ; TAB3 if visit1 [ pt ] and a [ pt ] is not equal to 1 then do the following visit1 [ i ] = true ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 if visit1 [ i ] and visit [ i ] is true ; TAB3 output 1 ; TAB2 else ; TAB3 output 0 ;	long long gcd1 ( long long a , long long b ) { if ( a == 0 ) return b ; return gcd1 ( b % a , a ) ; } long long modx ( long long base , long long ex ) { long long ans = 1LL , val = base ; while ( ex > 0LL ) { if ( ex & 1LL ) ans = ( ans * val ) % 1000000009LL ; val = ( val * val ) % 1000000009LL ; ex = ex >> 1LL ; } return ans ; } const int maxn = 1e5 + 10 ; bool visit [ maxn ] , visit1 [ maxn ] ; int n , m , x , y , a [ maxn ] ; bool D [ maxn ] , P [ maxn ] ; vector < int > adj [ maxn ] , v [ maxn ] ; void dfs ( int start ) { visit [ start ] = true ; for ( int i = 0 ; i < adj [ start ] . size ( ) ; i ++ ) { int pt = adj [ start ] [ i ] ; if ( ! visit [ pt ] ) dfs ( pt ) ; } } void dfs2 ( int start ) { visit1 [ start ] = true ; for ( int i = 0 ; i < v [ start ] . size ( ) ; i ++ ) { int pt = v [ start ] [ i ] ; if ( ! visit1 [ pt ] ) dfs2 ( pt ) ; } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i <= m ; i ++ ) { cin >> x >> y ; adj [ x ] . push_back ( y ) ; if ( a [ x ] != 1 && a [ y ] != 1 ) v [ y ] . push_back ( x ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visit [ i ] && a [ i ] == 1 ) dfs ( i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visit1 [ i ] && a [ i ] == 2 ) dfs2 ( i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != 1 ) continue ; for ( int j = 0 ; j < adj [ i ] . size ( ) ; j ++ ) { int pt = adj [ i ] [ j ] ; if ( visit1 [ pt ] && a [ pt ] != 1 ) visit1 [ i ] = true ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( visit1 [ i ] && visit [ i ] ) cout << 1 << endl ; else cout << 0 << endl ; } return 0 ; }
TAB0 declare long longs n and m ; TAB0 let vis be boolean array with size 10 ; TAB0 declare long long variable ans = 0 ; TAB0 create integers p1 and p2 ; TAB0 declare int array d with size 10 ; TAB0 ok is a boolean function ; TAB1 declare long long res1 = 0 ; TAB1 for i from 0 to p1 exclusive ; TAB2 multiply res1 by 7 ; TAB2 increase res1 by d [ i ] ; TAB1 declare long long res2 = 0 ; TAB1 loop i from 0 to p2 exclusive ; TAB2 multiply res2 by 7 ; TAB2 increase res2 by d [ p1 + i ] ; TAB1 if res1 > = n or res2 > = m ; TAB2 return false ; TAB1 else ; TAB2 return true ; TAB0 void function dfs with integer argument dep ; TAB1 create integer tmp = dep ; TAB1 if dep is equal to p1 + p2 ; TAB2 if ok ( ) returned true , increment ans ; TAB2 return ; TAB1 for integer i = 0 to 7 exclusive ; TAB2 if vis [ i ] is false ; TAB3 set d [ dep ] to i ; TAB3 set vis [ i ] to 1 ; TAB3 call dfs with argument dep + 1 ; TAB3 set vis [ i ] to 0 ; TAB3 set d [ dep ] to - 1 ; TAB0 int function cal with int argument x ; TAB1 create integer cnt = 0 ; TAB1 while x > 0 ; TAB2 divide x by 7 ; TAB2 increment cnt by one ; TAB1 return cnt ; TAB1 set sizeof ( vis ) bytes at the pointer vis to 0 ; TAB1 set sizeof ( d ) bytes at the pointer d to - 1 ; TAB1 read n and m ; TAB1 change p1 to cal ( n - 1 ) ; TAB1 change p2 to cal ( m - 1 ) ; TAB1 if n is 1 , increment p1 ; TAB1 if m is 1 , increment p2 ; TAB1 if p1 + p2 is greater than 7 ; TAB2 print " 0 " ; TAB1 call dfs with argument 0 ; TAB1 print ans ;	long long n , m ; bool vis [ 10 ] ; long long ans = 0 ; int p1 , p2 ; int d [ 10 ] ; bool ok ( ) { long long res1 = 0 ; for ( int i = 0 ; i < p1 ; i ++ ) { res1 *= 7 ; res1 += d [ i ] ; } long long res2 = 0 ; for ( int i = 0 ; i < p2 ; i ++ ) { ; res2 *= 7 ; res2 += d [ p1 + i ] ; } if ( res1 >= n || res2 >= m ) return false ; else return true ; } void dfs ( int dep ) { int tmp = dep ; if ( dep == p1 + p2 ) { if ( ok ( ) ) { ans ++ ; } return ; } for ( int i = 0 ; i < 7 ; i ++ ) { if ( ! vis [ i ] ) { d [ dep ] = i ; vis [ i ] = 1 ; dfs ( dep + 1 ) ; vis [ i ] = 0 ; d [ dep ] = - 1 ; } } } int cal ( int x ) { int cnt = 0 ; while ( x ) { x /= 7 ; cnt ++ ; } return cnt ; } int main ( ) { memset ( vis , 0 , sizeof ( vis ) ) ; memset ( d , - 1 , sizeof ( d ) ) ; cin >> n >> m ; p1 = cal ( n - 1 ) ; p2 = cal ( m - 1 ) ; if ( n == 1 ) p1 ++ ; if ( m == 1 ) p2 ++ ; if ( p1 + p2 > 7 ) { cout << " 0 " << endl ; return 0 ; } dfs ( 0 ) ; cout << ans << endl ; return 0 ; }
TAB0 in function read taking a reference to an int x ; TAB1 ch = char with ch = value of getchar ; TAB1 f = bool with f = false ; TAB1 set x to 0 ; TAB1 loop while ch is greater than ' 9 ' or less than ' 0 ' ; TAB2 if ch equals ' - ' then set f to 1 ; TAB2 set ch to result of getchar ; TAB1 loop while ch is greater or equal to ' 0 ' and less or equal to ' 9 ' ; TAB2 set x to x * 10 + ch - 48 ; TAB2 set ch to result of getchar ; TAB1 if f is not 0 then set x to - x ; TAB0 in function read taking a reference to a long long x ; TAB1 ch = char with ch = result of getchar ; TAB1 f = bool with f = false ; TAB1 set x to 0 ; TAB1 loop while ch is greater than ' 9 ' or less than ' 0 ' ; TAB2 if ch equals ' - ' then set f to 1 ; TAB2 set ch to result of getchar ; TAB1 loop while ch is greater or equal to ' 0 ' and ch is less or equal to ' 9 ' ; TAB2 set x to x * 10 + ch - 48 ; TAB2 set ch to result of getchar ; TAB1 if f equals true set x to - x ; TAB0 parent = int array of size 150001 ; TAB0 ranks = int array of size 150001 ; TAB0 sizeedge = long long array of size 150001 ; TAB0 size = long long array of size 150001 ; TAB0 in function build taking an int n ; TAB1 for i = 0 to n inclusive set parent [ i ] to i and size [ i ] to 1 ; TAB0 in function find taking an int x and returning an int ; TAB1 set parent [ x ] to x if parent [ x ] equals x else set it to find of parent [ x ] and return parent [ x ] ; TAB0 in function merge taking two ints x and y ; TAB1 set x to find of x and set y to find of y ; TAB1 if ranks [ x ] is greater than ranks [ y ] then call swap on x and y ; TAB1 if ranks [ x ] equals ranks [ y ] then increment ranks [ y ] ; TAB1 if x does not equal y ; TAB2 set parent [ x ] to y ; TAB2 add size [ x ] to size [ y ] ; TAB2 add sizeedge [ x ] + 1 to sizeedge [ y ] ; TAB1 else ; TAB2 increment sizeedge [ y ] ; TAB1 v , e = int ; TAB1 call read of v ; TAB1 call read of e ; TAB1 call build of v ; TAB1 for i = 0 to e ; TAB2 from , to = int ; TAB2 call read of from ; TAB2 call read of to ; TAB2 call merge of from and to ; TAB1 for i = 1 to v inclusive ; TAB2 if i equals the result of find of i ; TAB3 if sizeedge [ i ] does not equal size [ i ] * ( size [ i ] - 1 ) / 2 ; TAB4 call puts of " NO " ; TAB1 call puts of " YES " ;	void read ( int & x ) { char ch = getchar ( ) ; bool f = 0 ; x = 0 ; while ( ch > ' 9 ' || ch < ' 0 ' ) { if ( ch == ' - ' ) f = 1 ; ch = getchar ( ) ; } while ( ch >= ' 0 ' && ch <= ' 9 ' ) { x = x * 10 + ch - 48 ; ch = getchar ( ) ; } if ( f ) x = - x ; } void read ( long long & x ) { char ch = getchar ( ) ; bool f = 0 ; x = 0 ; while ( ch > ' 9 ' || ch < ' 0 ' ) { if ( ch == ' - ' ) f = 1 ; ch = getchar ( ) ; } while ( ch >= ' 0 ' && ch <= ' 9 ' ) { x = x * 10 + ch - 48 ; ch = getchar ( ) ; } if ( f ) x = - x ; } int parent [ 150001 ] ; int ranks [ 150001 ] ; long long sizeedge [ 150001 ] ; long long size [ 150001 ] ; void build ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) parent [ i ] = i , size [ i ] = 1LL ; } int find ( int x ) { return parent [ x ] = x == parent [ x ] ? x : find ( parent [ x ] ) ; } void merge ( int x , int y ) { x = find ( x ) , y = find ( y ) ; if ( ranks [ x ] > ranks [ y ] ) swap ( x , y ) ; if ( ranks [ x ] == ranks [ y ] ) ranks [ y ] ++ ; if ( x != y ) { parent [ x ] = y ; size [ y ] = size [ x ] + size [ y ] ; sizeedge [ y ] = sizeedge [ x ] + sizeedge [ y ] + 1LL ; } else { sizeedge [ y ] ++ ; } } int main ( ) { int v , e ; read ( v ) ; read ( e ) ; build ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { int from , to ; read ( from ) ; read ( to ) ; merge ( from , to ) ; } for ( int i = 1 ; i <= v ; i ++ ) { if ( i == find ( i ) ) { if ( sizeedge [ i ] != size [ i ] * ( size [ i ] - 1 ) / 2 ) { puts ( " NO " ) ; return 0 ; } } } puts ( " YES " ) ; return 0 ; }
TAB1 x is an integer array of size 2000 ; TAB1 n is an integer ; TAB1 read n ; TAB1 i is an integer ; TAB1 for i = 0 to n exclusive , read x [ i ] ; TAB1 a , b , k are integers ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 set a to x [ i ] ; TAB2 set b to x [ i + 1 ] ; TAB2 if a is less than b ; TAB3 for k = 0 to i exclusive ; TAB4 if ( a is at most x [ k ] and b is at least x [ k ] ) and ( a is at most x [ k + 1 ] and b is at least x [ k + 1 ] ) ; TAB4 else ; TAB5 if ( a is at least x [ k ] or b is at most x [ k ] ) and ( a is at least x [ k + 1 ] or b is at most x [ k + 1 ] ) ; TAB5 else ; TAB6 display yes ; TAB2 else ; TAB3 for k = 0 to i exclusive ; TAB4 if ( a is at least x [ k ] and b is at most x [ k ] ) and ( a is at least x [ k + 1 ] and b is at most x [ k + 1 ] ) ; TAB4 else ; TAB5 if ( a is at most x [ k ] or b is at least x [ k ] ) and ( a is at most x [ k + 1 ] or b is at least x [ k + 1 ] ) ; TAB5 else ; TAB6 display yes ; TAB1 display no ;	int main ( ) { int x [ 2000 ] ; int n ; cin >> n ; int i ; for ( i = 0 ; i < n ; i ++ ) { cin >> x [ i ] ; } int a , b , k ; for ( i = 0 ; i < n - 1 ; i ++ ) { a = x [ i ] ; b = x [ i + 1 ] ; if ( a < b ) { for ( k = 0 ; k < i ; k ++ ) { if ( ( a <= x [ k ] && b >= x [ k ] ) && ( a <= x [ k + 1 ] && b >= x [ k + 1 ] ) ) { } else { if ( ( a >= x [ k ] || b <= x [ k ] ) && ( a >= x [ k + 1 ] || b <= x [ k + 1 ] ) ) { } else { cout << " yes " << endl ; return 0 ; } } } } else { for ( k = 0 ; k < i ; k ++ ) { if ( ( a >= x [ k ] && b <= x [ k ] ) && ( a >= x [ k + 1 ] && b <= x [ k + 1 ] ) ) { } else { if ( ( a <= x [ k ] || b >= x [ k ] ) && ( a <= x [ k + 1 ] || b >= x [ k + 1 ] ) ) { } else { cout << " yes " << endl ; return 0 ; } } } } } cout << " no " << endl ; return 0 ; }
TAB1 s = char array of size 500005 ; TAB1 read s ; TAB1 dp1 , dp2 = int array of size 500005 each and idx1 , idx2 = int with idx1 = 0 and idx2 = 00 ; TAB1 for i = 0 to strlen of s ; TAB2 if s [ i ] is ' A ' and s [ i + 1 ] is ' B ' ; TAB3 set dp1 [ idx1 ] to i then increment idx1 ; TAB2 else if s [ i ] is ' B ' and s [ i + 1 ] is ' A ' ; TAB3 set dp2 [ idx2 ] to i then increment idx2 ; TAB1 flag = bool with flag = false ; TAB1 for i = 0 to idx1 ; TAB2 for j = 0 to idx2 ; TAB3 if absolute of dp2 [ j ] - dp1 [ i ] is greater than 1 ; TAB4 set flag to true ; TAB4 break ; TAB1 if flag is true ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { char s [ 500005 ] ; cin >> s ; int dp1 [ 500005 ] , dp2 [ 500005 ] , idx1 = 0 , idx2 = 0 ; for ( int i = 0 ; i < strlen ( s ) ; i ++ ) { if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' ) { dp1 [ idx1 ++ ] = i ; } else if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' ) { dp2 [ idx2 ++ ] = i ; } } bool flag = false ; for ( int i = 0 ; i < idx1 ; i ++ ) { for ( int j = 0 ; j < idx2 ; j ++ ) { if ( abs ( dp2 [ j ] - dp1 [ i ] ) > 1 ) { flag = true ; break ; } } } if ( flag ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 declare n as integer ; TAB1 declare character array s size 100 ; TAB1 while read n is true ; TAB2 declare flag = 1 as integer ; TAB2 for i = 0 to n exclusive , read s [ i ] ; TAB2 for i = 0 to n - 1 ; TAB3 if s [ i ] is not ' ? ' and s [ i ] is s [ i + 1 ] ; TAB4 let flag be 0 ; TAB4 goto jump point here ; TAB2 if flag is true ; TAB3 for i = 0 to n exclusive ; TAB4 if s [ i ] is ' ? ' ; TAB5 if i is 0 or i is n - 1 , go to jump point there ; TAB5 if s [ i + 1 ] is ' ? ' , go to jump point there ; TAB5 if s [ i - 1 ] is s [ i + 1 ] , got to jump point there ; TAB1 mark jump point here ; TAB2 print " No " , newline ; TAB2 exit loop iteration ; TAB1 mark jump point there ; TAB2 print " Yes " , newline ;	int main ( ) { int n ; char s [ 100 ] ; while ( cin >> n ) { int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] != ' ? ' && s [ i ] == s [ i + 1 ] ) { flag = 0 ; goto here ; } } if ( flag ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ? ' ) { if ( i == 0 || i == n - 1 ) { goto there ; } if ( s [ i + 1 ] == ' ? ' ) { goto there ; } if ( s [ i - 1 ] == s [ i + 1 ] ) { goto there ; } } } } here : cout << " No " << endl ; continue ; there : cout << " Yes " << endl ; } return 0 ; }
TAB0 arr = int array of size 10000 ; TAB0 v = int vector ; TAB0 brr = int array of size 10000 ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 m = int ; TAB2 read m ; TAB2 set arr [ i ] to m ; TAB2 append m to v ; TAB1 sort v ; TAB1 idx , cur = int with idx = 1 ; TAB1 for i = n - 1 to 0 inclusive decrementing i ; TAB2 if i is n - 1 ; TAB3 set cur to v [ i ] ; TAB3 set brr [ idx ] to v [ i ] ; TAB2 else ; TAB3 if cur is not v [ i ] ; TAB4 set brr [ idx ] to v [ i ] ; TAB4 set cur to v [ i ] ; TAB2 increment idx ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if arr [ i ] is brr [ j ] and arr [ i ] is not 0 and brr [ j ] is not 0 ; TAB4 if i is n ; TAB5 print j ; TAB4 else ; TAB5 print j then " " ;	int arr [ 10000 ] ; vector < int > v ; int brr [ 10000 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { int m ; cin >> m ; arr [ i ] = m ; v . push_back ( m ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int idx = 1 , cur ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 ) { cur = v [ i ] ; brr [ idx ] = v [ i ] ; } else { if ( cur != v [ i ] ) { brr [ idx ] = v [ i ] ; cur = v [ i ] ; } } idx ++ ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( arr [ i ] == brr [ j ] && arr [ i ] != 0 && brr [ j ] != 0 ) { if ( i == n ) { cout << j << endl ; } else { cout << j << "   " ; } } } } }
TAB0 mark is a new array of booleans with size 4000002 ; TAB0 parza is a boolean function with long long argument n ; TAB1 for i = 2 to n inclusive ; TAB2 return false if n can be divided by i without a remainder ; TAB1 return true ; TAB1 declare long long variable with name n ; TAB1 for i from 2 to 4000000 inclusive incrementing i ; TAB2 if mark [ i ] is false ; TAB3 in a for loop , change j from 2 * i to 4000000 inclusive increasing j by i and assigning true to mark [ j ] on each loop ; TAB1 read standard input to n ; TAB1 if parza ( n ) is true ; TAB2 print 1 , new line and 0 to the standard output ; TAB1 start for loop from i = 2 to 4000000 inclusive ; TAB2 if mark [ i ] is false ; TAB3 if n can be divided by i without a remainder ; TAB4 declare new long long called k with value n / i ; TAB4 if parza ( k ) returns true ; TAB5 print 2 ; TAB4 print 1 to the standard output ; TAB4 for j = 2 to 4000000 inclusive ; TAB5 if mark [ j ] is false and k modulo j is 0 ; TAB6 print i * j to the standard output ;	bool mark [ 4000002 ] ; bool parza ( long long n ) { for ( long long i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int main ( ) { long long n ; for ( int i = 2 ; i <= 4000000 ; i ++ ) if ( ! mark [ i ] ) for ( int j = 2 * i ; j <= 4000000 ; j += i ) mark [ j ] = true ; cin >> n ; if ( parza ( n ) ) { cout << 1 << endl << 0 << endl ; return 0 ; } for ( int i = 2 ; i <= 4000000 ; i ++ ) { if ( ! mark [ i ] ) { if ( n % i == 0 ) { long long k = n / i ; if ( parza ( k ) ) { cout << 2 << endl ; return 0 ; } cout << 1 << endl ; for ( int j = 2 ; j <= 4000000 ; j ++ ) { if ( ! mark [ j ] && k % j == 0 ) { cout << i * j << endl ; return 0 ; } } } } } return 0 ; }
TAB0 create integers i , j , k , m , n , and l and integer array of size 20000 ; TAB0 create char arrays a of size 20000 , b of size 20000 , c of size 20000 , and d of size 20000 ; TAB1 for i = 0 to 2000 exclusive , set ans [ i ] to 0 ; TAB1 read a ; TAB1 read d ; TAB1 set m to strlen ( d ) ; TAB1 for i = 0 to m - 1 exclusive , set b [ i ] to ' ' ; TAB1 append a to b ; TAB1 set n to length of b ; TAB1 for i = n to m + n - 1 exclusive , set b [ i ] to ' 0 ' ; TAB1 set l to m ; TAB1 for i = 0 to n exclusive ; TAB2 for k = i to i + 1 exclusive , set c [ k - 1 ] to b [ k ] ; TAB2 for j = 0 to l exclusive ; TAB3 if d [ j ] is equal to c [ j ] , increment ans [ i ] ; TAB1 sort ans using argument ans + n + 1 ; TAB1 print m - ans [ i ] ;	int ans [ 20000 ] , i , j , k , m , n , l ; char a [ 20000 ] , b [ 20000 ] , c [ 20000 ] , d [ 20000 ] ; int main ( ) { for ( i = 0 ; i < 2000 ; ++ i ) ans [ i ] = 0 ; gets ( a ) ; gets ( d ) ; m = strlen ( d ) ; for ( i = 0 ; i < m - 1 ; ++ i ) b [ i ] = '   ' ; strcat ( b , a ) ; n = strlen ( b ) ; for ( i = n ; i < m + n - 1 ; ++ i ) b [ i ] = ' 0 ' ; l = m ; for ( i = 0 ; i < n ; ++ i ) { for ( k = i ; k < i + l ; ++ k ) c [ k - i ] = b [ k ] ; for ( j = 0 ; j < l ; ++ j ) { if ( d [ j ] == c [ j ] ) ans [ i ] ++ ; } } sort ( ans , ans + n + 1 ) ; cout << m - ans [ i ] << endl ; return 0 ; }
TAB0 long long integer as , m , a , d , i , lp , lst , io , ans , rao ; TAB0 long long integer array x size of 300002 ; TAB1 read n , m , a , d ; TAB1 read x [ i ] ; TAB1 set lst to - 1 ; TAB1 set lp to 1 ; TAB1 for = 1 to less than or equal to m do the following ; TAB2 if lst + d > = x [ i ] and lst is not equal to - 1 then continue ; TAB2 if lp is less than or equal to n and a * lp is less than x [ i ] then do the following ; TAB3 set io to d / a + 1 ; TAB3 set rao to minimum of n and ( x [ i ] - 1 ) / a ) ; TAB3 ans equals ans plus ( rao - lp + io ) / io ; TAB3 set lst to ( lp + ( ( rao - lp + io ) / io ) * io - io ) * a ; TAB3 minus 1 from i ; TAB2 else ; TAB3 add one to ans ; TAB3 set lst to x [ i ] ; TAB2 set lp to ( lst + d ) / a + 1 ; TAB1 set lp to minimum of lp , n + 1 ; TAB1 set io to d / a + 1 ; TAB1 ans equals ans plus ( n - lp + io ) / io ; TAB1 output ans ;	long long n , m , a , d , i , lp , lst , io , ans , rao ; long long x [ 300002 ] ; int main ( ) { cin >> n >> m >> a >> d ; for ( i = 1 ; i <= m ; i ++ ) { cin >> x [ i ] ; } lst = - 1 ; lp = 1 ; for ( i = 1 ; i <= m ; i ++ ) { if ( lst + d >= x [ i ] && lst != - 1 ) continue ; if ( lp <= n && a * lp < x [ i ] ) { io = d / a + 1 ; rao = min ( n , ( x [ i ] - 1 ) / a ) ; ans += ( rao - lp + io ) / io ; lst = ( lp + ( ( rao - lp + io ) / io ) * io - io ) * a ; i -- ; } else { ans ++ ; lst = x [ i ] ; } lp = ( lst + d ) / a + 1 ; } lp = min ( lp , n + 1 ) ; io = d / a + 1 ; ans += ( n - lp + io ) / io ; cout << ans << endl ; }
TAB0 a is a new array of integers with 250005 elements ; TAB0 declare new array of integers b with size 505 ; TAB0 f = map from integers to integers ; TAB1 declare new integer called n ; TAB1 read n from the input ; TAB1 read n * n elements from the input into a , starting from the index 1 ; TAB1 sort a ; TAB1 for i = 1 to n * n inclusive increment f [ a [ i ] ] ; TAB1 set b [ 1 ] to a [ 1 ] ; TAB1 create new int to int map iterator itr ; TAB1 decrease f [ b [ 1 ] ] ; TAB1 create new integer idx = 1 ; TAB1 start for loop from i = 2 to n squared inclusive ; TAB2 if f [ a [ i ] ] is greater than 0 ; TAB3 increment idx by one ; TAB3 change the value of b [ idx ] to a [ i ] ; TAB3 decrement f [ a [ i ] ] ; TAB3 in a for loop , change j from 1 to idx exclusive , decreasing f [ __gcd ( b [ idx ] , b [ j ] ) ] by 2 on each iteration ; TAB2 if idx is equal to n , break the loop ; TAB1 for i = 1 to n inclusive ; TAB2 if i = 1 ; TAB3 print b [ i ] to the standard output ; TAB2 else ; TAB3 print ' ' and b [ i ] ; TAB1 print new line ;	int a [ 250005 ] ; int b [ 505 ] ; map < int , int > f ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n * n ; i ++ ) cin >> a [ i ] ; sort ( a + 1 , a + 1 + n * n , greater < int > ( ) ) ; for ( int i = 1 ; i <= n * n ; i ++ ) { f [ a [ i ] ] ++ ; } b [ 1 ] = a [ 1 ] ; map < int , int > :: iterator itr ; f [ b [ 1 ] ] -- ; int idx = 1 ; for ( int i = 2 ; i <= n * n ; i ++ ) { if ( f [ a [ i ] ] > 0 ) { idx ++ ; b [ idx ] = a [ i ] ; f [ a [ i ] ] -- ; for ( int j = 1 ; j < idx ; j ++ ) { f [ __gcd ( b [ idx ] , b [ j ] ) ] -= 2 ; } } if ( idx == n ) break ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 1 ) cout << b [ i ] ; else cout << '   ' << b [ i ] ; } cout << endl ; return 0 ; }
TAB1 n , p are integers ; TAB1 read n , p ; TAB1 let a be a string ; TAB1 let b be an integer set to 97 ; TAB1 for i = 0 to n exclusive , add 97 + i modulo p to a ; TAB1 display a ;	int main ( ) { int n , p ; cin >> n >> p ; string a ; int b = 97 ; for ( int i = 0 ; i < n ; i ++ ) { a += 97 + i % p ; } cout << a << endl ; }
TAB0 n = int ; TAB0 s = string ; TAB0 let , any = string ; TAB0 a = array of 128 string ; TAB0 need = array of 128 int ; TAB1 read n ; TAB1 for i = 0 to n exclusive read a [ i ] ; TAB1 read s ; TAB1 read let ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to size of s - size of a [ i ] inclusive ; TAB3 s1 = substring of j from size of a [ i ] ; TAB3 for k = 0 to size of s1 exclusive ; TAB4 if s1 [ k ] is an uppercase letter append ' a ' - ' A ' to it ; TAB3 s2 = a [ i ] ; TAB3 for k = 0 to size of s2 exclusive ; TAB4 if s2 [ k ] is an uppercase letter append ' a ' - ' A ' to it ; TAB3 if s1 is s2 ; TAB4 for k = 0 to size of s1 exclusive need [ j + k ] = 1 ; TAB1 if let is " a " ; TAB2 any = " b " ; TAB1 else ; TAB2 any = " a " ; TAB1 for i = 0 to size of s exclusive ; TAB2 if need [ i ] ; TAB3 if s [ i ] is let [ 0 ] or let [ 0 ] + ' A ' - ' a ' ; TAB4 if s [ i ] is an uppercase letter ; TAB5 s [ i ] = ' A ' - ' a ' + any [ 0 ] ; TAB4 else ; TAB5 s [ i ] = any [ 0 ] ; TAB3 else ; TAB4 if s [ i ] is an uppercase letter ; TAB5 s [ i ] = ' A ' - ' a ' + let [ 0 ] ; TAB4 else ; TAB5 s [ i ] = let [ 0 ] ; TAB1 print s ;	int n ; string s ; string let , any ; string a [ 1 << 7 ] ; int need [ 1 << 7 ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; cin >> s ; cin >> let ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( int ) s . size ( ) - ( int ) a [ i ] . size ( ) ; ++ j ) { string s1 = s . substr ( j , a [ i ] . size ( ) ) ; for ( int k = 0 ; k < s1 . size ( ) ; ++ k ) if ( ' A ' <= s1 [ k ] && s1 [ k ] <= ' Z ' ) s1 [ k ] += ' a ' - ' A ' ; string s2 = a [ i ] ; for ( int k = 0 ; k < s2 . size ( ) ; ++ k ) if ( ' A ' <= s2 [ k ] && s2 [ k ] <= ' Z ' ) s2 [ k ] += ' a ' - ' A ' ; if ( s1 == s2 ) { for ( int k = 0 ; k < s1 . size ( ) ; ++ k ) need [ j + k ] = 1 ; } } } if ( let == " a " ) any = " b " ; else any = " a " ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { if ( need [ i ] ) { if ( s [ i ] == let [ 0 ] || s [ i ] == let [ 0 ] + ' A ' - ' a ' ) { if ( ' A ' <= s [ i ] && s [ i ] <= ' Z ' ) s [ i ] = ' A ' - ' a ' + any [ 0 ] ; else s [ i ] = any [ 0 ] ; } else { if ( ' A ' <= s [ i ] && s [ i ] <= ' Z ' ) s [ i ] = ' A ' - ' a ' + let [ 0 ] ; else s [ i ] = let [ 0 ] ; } } } cout << s << endl ; return 0 ; }
TAB0 declare integers n , i , integer arrays a size 1111111 , d size 1111111 ; TAB0 declare long long ans = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 let d [ 1 ] be 1 ; TAB1 for i = 2 to n exclusive , let d [ i ] be d [ i / 2 ] * 2 ; TAB1 for i = 0 to i + 1 is less than n ; TAB2 increment a [ i + d [ n - i - 1 ] ] by a [ i ] ; TAB2 increment ans by a [ ii ] ; TAB2 print ans and newline ;	int n , i , a [ 1111111 ] , d [ 1111111 ] ; long long ans = 0 ; int main ( ) { cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; d [ 1 ] = 1 ; for ( i = 2 ; i < n ; i ++ ) d [ i ] = d [ i / 2 ] * 2 ; for ( i = 0 ; i + 1 < n ; i ++ ) { a [ i + d [ n - i - 1 ] ] += a [ i ] ; ans += a [ i ] ; cout << ans << endl ; } return 0 ; }
TAB1 a , ans , n , sum = long long with ans = 0 and sum = 0 ; TAB1 s = string ; TAB1 read a then s ; TAB1 set n to size of s ; TAB1 b = long long vector of size n ; TAB1 for i = 0 to n set b [ i ] to s [ i ] - ' 0 ' ; TAB1 rep = int vector of size 36001 with all values set to 0 ; TAB1 for i = 0 to n ; TAB2 set sum to 0 ; TAB2 for j = i to n ; TAB3 increment sum by b [ j ] ; TAB3 increment rep [ sum ] ; TAB1 for i = 0 to n ; TAB2 set sum to 0 ; TAB2 for j = i to n ; TAB3 increment sum by b [ j ] ; TAB3 if sum is 0 ; TAB4 if a is 0 increment ans by n * ( n + 1 ) / 2 ; TAB3 else if a is a multiple of sum and a / sum < 36001 ; TAB4 increment ans by rep [ a / sum ] ; TAB1 print ans ;	int main ( ) { long long a , ans = 0 , n , sum = 0 ; string s ; cin >> a >> s ; n = s . size ( ) ; vector < long long > b ( n ) ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = s [ i ] - ' 0 ' ; vector < int > rep ( 36001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += b [ j ] ; rep [ sum ] ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += b [ j ] ; if ( ! sum ) { if ( ! a ) ans += n * ( n + 1 ) / 2 ; } else if ( a % sum == 0 && a / sum < 36001 ) ans += rep [ a / sum ] ; } } cout << ans << ' \n ' ; return 0 ; }
TAB0 N , INF = const int with N = 5e6 + 10 and INF = 1e9 ; TAB0 n , ans = int and k = int array of size N ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 w = int ; TAB2 read w ; TAB2 increment k [ w ] ; TAB1 for i = 0 to N - 5 ; TAB2 increment k [ i + 1 ] by k [ i ] / 2 ; TAB2 increment ans by k [ i ] mod 2 ; TAB1 print ans ;	const int N = 5e6 + 10 , INF = 1e9 ; int n , k [ N ] , ans ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int w ; cin >> w ; k [ w ] ++ ; } for ( int i = 0 ; i < N - 5 ; i ++ ) { k [ i + 1 ] += k [ i ] / 2 ; ans += ( k [ i ] % 2 ) ; } cout << ans << ' \n ' ; return 0 ; }
TAB0 maxn = 100000 = const int ; TAB0 let a , b , n , r = 1 , ans be ints with a , b both arrays of length maxn ; TAB1 read n ; TAB1 read a form 1 to n inclusive ; TAB1 sort a form 1 to n inclusive ; TAB1 for i = 1 to n inclusive ; TAB2 while r < = n and a [ r ] < = a [ i ] , increment r ; TAB2 if r < = n then increment both ans and r ; TAB1 print ans ;	const int maxn = 100000 ; int a [ maxn ] , b [ maxn ] , n , r = 1 , ans ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } sort ( a + 1 , a + 1 + n ) ; for ( int i = 1 ; i <= n ; i ++ ) { while ( r <= n && a [ r ] <= a [ i ] ) r ++ ; if ( r <= n ) ans ++ , r ++ ; } cout << ans << endl ; return 0 ; }
TAB0 create integer set ss ; TAB0 create integer array a with size 100010 ; TAB1 create integers n , k ; TAB1 read n read k ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 sort elements from a + 1 to a + n + 1 ; TAB1 create integer ans with ans = 0 ; TAB1 for i = n to 1 inclusive , decrementing i ; TAB2 if not count of a [ i ] in ss ; TAB3 increment ans ; TAB3 if a [ i ] % k is 0 , insert a [ i ] / k into ss ; TAB1 print ans print newline ;	set < int > ss ; int a [ 100010 ] ; int main ( ) { int n , k ; cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; sort ( a + 1 , a + n + 1 ) ; int ans = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ss . count ( a [ i ] ) ) { ans ++ ; if ( a [ i ] % k == 0 ) ss . insert ( a [ i ] / k ) ; } } cout << ans << endl ; return 0 ; }
TAB1 integers = n ; TAB1 set int files to 0 ; TAB1 set int f to 0 ; TAB1 set int sum [ 500 ] to 0 ; TAB1 set int index to 0 ; TAB1 read n ; TAB1 integers = a ; TAB1 if n is not equal to 0 then do the following ; TAB2 read a ; TAB2 if a is less than 0 then increment f by 1 ; TAB2 if f is 3 then do the following ; TAB3 files equals files plus 1 ; TAB3 set f to 1 ; TAB3 index equals index plus 1 ; TAB2 sum [ index ] equals sum [ index ] plus 1 ; TAB1 files equals files plus 1 ; TAB1 output files , endl ; TAB1 for i = 0 to less than files - 1 then ouput sum [ i ] and a space ; TAB1 output sum [ files - 1 ] ;	int main ( ) { int n ; int files = 0 ; int f = 0 ; int sum [ 500 ] = { 0 } ; int index = 0 ; cin >> n ; int a ; while ( n -- != 0 ) { cin >> a ; if ( a < 0 ) { f += 1 ; } if ( f == 3 ) { files += 1 ; f = 1 ; index += 1 ; } sum [ index ] += 1 ; } files += 1 ; cout << files << endl ; for ( int i = 0 ; i < files - 1 ; i ++ ) { cout << sum [ i ] << '   ' ; } cout << sum [ files - 1 ] << endl ; return 0 ; }
TAB0 let a be an int array of length 250010 ; TAB0 In function gcd which takes ints x and y and returns an int ; TAB1 if x is 0 return y , else return gcd of y mod x and x ; TAB1 let n be an int ; TAB1 read n ; TAB1 for i = 0 to n * n exclusive , read a [ i ] ; TAB1 call sort on a , a + n * n , greater < int > ( ) ; TAB1 let ma be a map from int to int ; TAB1 for i to n * n exclusive ; TAB2 let tmp be an int with value i ; TAB2 let x be an int with value a [ i ] ; TAB2 while a [ i + 1 ] is a [ I ] and i + 1 ia less than n * n , increment i ; TAB2 set ma [ x ] to i - tmp + 1 ; TAB1 let ans be a vector of ints ; TAB1 let it be an iterator with value ma . end ( ) ; TAB1 decrement it ; TAB1 let x be an int with value it - > first ; TAB1 append x to ans ; TAB1 decrement ma [ x ] ; TAB1 if ma [ x ] is 0 , erase x from ma ; TAB1 while ma is not empty ; TAB2 set it to ma . end ( ) ; TAB2 decrement it ; TAB2 set x to it - > first ; TAB2 decrement ma [ x ] ; TAB2 if ma [ x ] is 0 , erase x from ma ; TAB2 append x to ans ; TAB2 let len be an int with value ans . size ( ) ; TAB2 let g be an int ; TAB2 for i = 0 to len - 1 exclusive ; TAB3 set g to gcd ( x , ans [ i ] ) ; TAB3 subtract 2 from ma [ g ] ; TAB3 if ma [ g ] is 0 erase g from ma ; TAB1 let len be an int with value ans . size ( ) ; TAB1 for I = 0 to len - 1 exclusive , print ans [ I ] and a space ; TAB1 print ans [ len - 1 ] ;	int a [ 250010 ] ; int gcd ( int x , int y ) { return x == 0 ? y : gcd ( y % x , x ) ; } int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n * n ; i ++ ) cin >> a [ i ] ; sort ( a , a + n * n , greater < int > ( ) ) ; map < int , int > ma ; for ( int i = 0 ; i < n * n ; i ++ ) { int tmp = i ; int x = a [ i ] ; while ( a [ i + 1 ] == a [ i ] && i + 1 < n * n ) i ++ ; ma [ x ] = i - tmp + 1 ; } vector < int > ans ; map < int , int > :: iterator it = ma . end ( ) ; it -- ; int x = it -> first ; ans . push_back ( x ) ; ma [ x ] -- ; if ( ma [ x ] == 0 ) ma . erase ( x ) ; while ( ! ma . empty ( ) ) { it = ma . end ( ) ; it -- ; x = it -> first ; ma [ x ] -- ; if ( ma [ x ] == 0 ) ma . erase ( x ) ; ans . push_back ( x ) ; int len = ans . size ( ) ; int g ; for ( int i = 0 ; i < len - 1 ; i ++ ) { g = gcd ( x , ans [ i ] ) ; ma [ g ] -= 2 ; if ( ma [ g ] == 0 ) ma . erase ( g ) ; } } int len = ans . size ( ) ; for ( int i = 0 ; i < len - 1 ; i ++ ) cout << ans [ i ] << '   ' ; cout << ans [ len - 1 ] << endl ; return 0 ; }
TAB1 create int n ; TAB1 read n ; TAB1 create int a [ n ] ; TAB1 set count25 , count50 and count100 to 0 ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 create int i ; TAB1 for i = 0 to n exclusive ; TAB2 if i = 0 and a [ i ] = 50 ; TAB3 print No ; TAB3 break ; TAB2 else if a [ i ] = 25 ; TAB3 increment count25 ; TAB2 else if a [ i ] = 50 ; TAB3 if count25 = 0 ; TAB4 print NO and a newline ; TAB4 break ; TAB3 else ; TAB4 decrement count25 ; TAB4 increment count50 ; TAB2 else if a [ i ] = 100 ; TAB3 if count50 > 0 and count25 > 0 ; TAB4 decrement count50 ; TAB4 decrement count25 ; TAB3 else if count25 > = 3 ; TAB4 set count25 to count25 - 3 ; TAB3 else ; TAB4 print NO ; TAB4 break ; TAB1 if i = n , print YES ;	int main ( ) { int n ; cin >> n ; int a [ n ] ; int count25 = 0 , count50 = 0 , count100 = 0 ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( i == 0 && a [ i ] == 50 ) { cout << " NO " << endl ; break ; } else if ( a [ i ] == 25 ) count25 ++ ; else if ( a [ i ] == 50 ) { if ( count25 == 0 ) { cout << " NO " << endl ; break ; } else { count25 -- ; count50 ++ ; } } else if ( a [ i ] == 100 ) { if ( count50 > 0 && count25 > 0 ) { count50 -- ; count25 -- ; } else if ( count25 >= 3 ) { count25 -= 3 ; } else { cout << " NO " << endl ; break ; } } } if ( i == n ) cout << " YES " << endl ; return 0 ; }
TAB1 declare integer n ; TAB1 declare character array str size 1005 ; TAB1 read n ; TAB1 read str ; TAB1 for i = 0 to n exclusive ; TAB2 if str [ i ] is str [ i + 1 ] and str [ i ] is not ' ? ' ; TAB3 print " No " and newline ; TAB1 for i = 1 to n - 1 exclusive ; TAB2 if str [ i ] is ' ? ' ; TAB3 if str [ i - 1 ] is str [ i + 1 ] or str [ i + 1 ] is ' ? ' ; TAB4 print " Yes " , newline ; TAB1 if str [ 0 ] is ' ? ' or str [ n - 1 ] is ' ? ' ; TAB2 print " Yes " , newline ; TAB1 print " No " , newline ;	int main ( ) { int n ; char str [ 1005 ] ; cin >> n ; cin >> str ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] != ' ? ' ) { cout << " No " << endl ; return 0 ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( str [ i ] == ' ? ' ) { if ( str [ i - 1 ] == str [ i + 1 ] || str [ i + 1 ] == ' ? ' ) { cout << " Yes " << endl ; return 0 ; } } } if ( str [ 0 ] == ' ? ' || str [ n - 1 ] == ' ? ' ) { cout << " Yes " << endl ; return 0 ; } cout << " No " << endl ; return 0 ; }
TAB0 mp = map from long long to long long ; TAB1 let n be a long integer ; TAB1 read n ; TAB1 a = array of long integers of length n + 1 ; TAB1 let i be a long integer ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 let ans be a long integer with ans = 0 ; TAB1 let maxx be a long integer with maxx = 0 ; TAB1 let j be a long integer with j = 1 ; TAB1 for i is equal to 1 , i is less than n ; TAB2 if a [ i + 1 ] is equal to ( a [ i ] + 1 ) ; TAB3 increment i by 1 ; TAB2 else do the following ; TAB3 if i is equal to j ; TAB4 increment ans by ( i - j ) ; TAB4 if maxx is less than ( i - j ) , maxx is equal to i - j ; TAB3 else do the following ; TAB4 increment ans by i - j - 1 ; TAB4 if maxx is less than ( i - j - 1 ) , maxx is equal to i - j - 1 ; TAB3 increment i by 1 ; TAB3 j is equal to i ; TAB1 if i is not equal to j ; TAB2 increment ans by i - j - 1 ; TAB2 if maxx is less than ( i - j - 1 ) , maxx is equal to i - j - 1 ; TAB1 for i is equal to 1 , i < = n ; TAB2 if a [ i ] is equal to i ; TAB3 increment i by 1 ; TAB2 else do the following ; TAB3 stop ; TAB1 if maxx is less than ( i - 2 ) , maxx is equal to i - 2 ; TAB1 j is equal to 1000 ; TAB1 for i is equal to n , i > = 1 ; TAB2 if a [ i ] is equal to j ; TAB3 decrement i by 1 ; TAB3 decrement j by 1 ; TAB2 else do the following ; TAB3 stop ; TAB1 if ( 1000 - j - 1 ) is greater than maxx , maxx is equal to 1000 - j - 1 ; TAB1 print maxx and newline ;	map < long long , long long > mp ; int main ( ) { long long n ; cin >> n ; long long a [ n + 1 ] ; long long i ; for ( i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } long long ans = 0 ; long long maxx = 0 ; long long j = 1 ; for ( i = 1 ; i < n ; ) { if ( a [ i + 1 ] == ( a [ i ] + 1 ) ) { i ++ ; } else { if ( i == j ) { ans = ans + ( i - j ) ; if ( maxx < ( i - j ) ) { maxx = i - j ; } } else { ans = ans + ( i - j - 1 ) ; if ( maxx < ( i - j - 1 ) ) { maxx = i - j - 1 ; } } i ++ ; j = i ; } } if ( i != j ) { ans = ans + ( i - j - 1 ) ; if ( maxx < ( i - j - 1 ) ) { maxx = i - j - 1 ; } } for ( i = 1 ; i <= n ; ) { if ( a [ i ] == i ) { i ++ ; } else { break ; } } if ( maxx < ( i - 2 ) ) { maxx = i - 2 ; } j = 1000 ; for ( i = n ; i >= 1 ; ) { if ( a [ i ] == j ) { i -- ; j -- ; } else { break ; } } if ( ( 1000 - j - 1 ) > maxx ) { maxx = 1000 - j - 1 ; } cout << maxx << " \n " ; }
TAB0 create constant integer variable MAXN with value 101 ; TAB0 define integer arrays colo and num with size MAXN ; TAB0 mark is a new array of integers with size MAXN ; TAB1 create a map from characters to integers called m ; TAB1 change m [ ' R ' ] to 0 , m [ ' G ' ] to 1 , m [ ' B ' ] to 2 , m [ ' Y ' ] to 3 and m [ ' W ' ] to 4 ; TAB1 declare new integer variable n ; TAB1 read n ; TAB1 for integer i = 0 to n - 1 inclusive ; TAB2 declare new string variable second ; TAB2 read user input to second ; TAB2 assign m [ second [ 0 ] ] to colo [ i ] ; TAB2 assign second [ 1 ] - ' 1 ' to num [ i ] ; TAB1 create new integer called ans with value 100 ; TAB1 for integer i = 0 to ( 1 < < 10 ) exclusive incrementing i ; TAB2 define integer req = __builtin_popcount of i ; TAB2 set the values of n first elements of mark to 0 ; TAB2 for j from 0 to 5 exclusive ; TAB3 if i & ( 1 < < j ) ! = 0 ; TAB4 in a for loop , change k from 0 to n - 1 inclusive ; TAB5 if colo [ k ] = j set mark [ k ] to mark [ k ] | = ( 1 < < j ) ; TAB2 in a for loop , change j from 5 to 10 exclusive incrementing j ; TAB3 if i & ( 1 < < j ) ! = 0 ; TAB4 change k from 0 to n - 1 inclusive in a for loop ; TAB5 if num [ k ] = j - 5 , set mark [ k ] to mark [ k ] | = ( 1 < < j ) ; TAB2 create boolean able = true ; TAB2 for j from 0 to n - 1 inclusive incrementing j ; TAB3 in a for loop , change k from o to n - 1 inclusive ; TAB4 if colo [ j ] ! = colo [ k ] or num [ j ] ! = num [ k ] ; TAB5 if mark [ j ] is equal to mark [ k ] , change able to false ; TAB2 if able is true , assign min of ans and req to ans ; TAB1 print ans ;	const int MAXN = 101 ; int colo [ MAXN ] , num [ MAXN ] ; int mark [ MAXN ] ; int main ( ) { map < char , int > m ; m [ ' R ' ] = 0 , m [ ' G ' ] = 1 , m [ ' B ' ] = 2 , m [ ' Y ' ] = 3 , m [ ' W ' ] = 4 ; int n ; cin >> n ; for ( int i = ( 0 ) ; i <= ( n - 1 ) ; ++ i ) { string second ; cin >> second ; colo [ i ] = m [ second [ 0 ] ] ; num [ i ] = second [ 1 ] - ' 1 ' ; } int ans = 100 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { int req = __builtin_popcount ( i ) ; for ( int j = ( 0 ) ; j <= ( n - 1 ) ; ++ j ) mark [ j ] = 0 ; for ( int j = 0 ; j < 5 ; j ++ ) { if ( i & ( 1 << j ) ) { for ( int k = ( 0 ) ; k <= ( n - 1 ) ; ++ k ) if ( colo [ k ] == j ) mark [ k ] |= ( 1 << j ) ; } } for ( int j = 5 ; j < 10 ; j ++ ) { if ( i & ( 1 << j ) ) { for ( int k = ( 0 ) ; k <= ( n - 1 ) ; ++ k ) if ( num [ k ] == j - 5 ) mark [ k ] |= ( 1 << j ) ; } } bool able = true ; for ( int j = ( 0 ) ; j <= ( n - 1 ) ; ++ j ) { for ( int k = ( 0 ) ; k <= ( n - 1 ) ; ++ k ) { if ( colo [ j ] != colo [ k ] || num [ j ] != num [ k ] ) { if ( mark [ j ] == mark [ k ] ) able = false ; } } } if ( able ) ans = min ( ans , req ) ; } cout << ans << endl ; }
TAB0 let A be int array with size 100005 ; TAB0 define function get that returns integer ; TAB1 declare char variable c ; TAB1 read c and loop while c < ' 0 ' or c > ' 9 ' ; TAB1 declare int x = 0 ; TAB1 while c > = ' 0 ' and c < = ' 9 ' ; TAB2 change x to x * 10 + c - ' 0 ' ; TAB2 read c ; TAB1 return x ; TAB0 Find is a int function with int arguments LEFT , RIGHT and X ; TAB1 while LEFT < = RIGHT ; TAB2 declare integer variable MID = ( LEFT + RIGHT ) / 2 ; TAB2 if A [ MID ] is equal to X ; TAB3 return MID ; TAB2 else if A [ MID ] is less than X ; TAB3 change LEFT to MID + 1 ; TAB2 else ; TAB3 assign MID - 1 to RIGHT ; TAB1 return - 1 ; TAB1 create ints n and k = get ( ) ; TAB1 for i from 0 to n exclusive , assign result of get to A [ i ] ; TAB1 sort A ; TAB1 create integer MAX = A [ n - 1 ] / k ; TAB1 declare boolean array flag with size 1000005 ; TAB1 set sizeof ( flag ) bytes at the pointer flag to 0 ; TAB1 declare integer ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if flag [ i ] , skip the rest of the loop ; TAB2 declare ints len = 1 and T = i ; TAB2 while A [ T ] < = MAX ; TAB3 assign result of Find ( T + 1 , n - 1 , A [ T ] * k ) to T ; TAB3 if T = - 1 , stop the loop ; TAB3 change flag [ T ] to 1 ; TAB3 increment len by one ; TAB2 increase ans by ( len + 1 ) / 2 ; TAB1 print ans ;	int A [ 100005 ] ; int get ( ) { char c ; while ( c = getchar ( ) , c < ' 0 ' || c > ' 9 ' ) ; int x = 0 ; while ( c >= ' 0 ' && c <= ' 9 ' ) { x = x * 10 + c - ' 0 ' ; c = getchar ( ) ; } return x ; } int Find ( int LEFT , int RIGHT , int X ) { while ( LEFT <= RIGHT ) { int MID = ( LEFT + RIGHT ) / 2 ; if ( A [ MID ] == X ) return MID ; else if ( A [ MID ] < X ) LEFT = MID + 1 ; else RIGHT = MID - 1 ; } return - 1 ; } int main ( ) { int n = get ( ) , k = get ( ) ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = get ( ) ; sort ( A , A + n ) ; int MAX = A [ n - 1 ] / k ; bool flag [ 1000005 ] ; memset ( flag , 0 , sizeof ( flag ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag [ i ] ) continue ; int T = i , len = 1 ; while ( A [ T ] <= MAX ) { T = Find ( T + 1 , n - 1 , A [ T ] * k ) ; if ( T == - 1 ) break ; flag [ T ] = 1 ; len ++ ; } ans += ( len + 1 ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB0 in function isprime return type boolean , taking int j ; TAB1 for i = 2 to j exclusive ; TAB2 if not ( j mod i ) then return 0 ; TAB1 return 1 ; TAB1 make int i = 1 , n ; TAB1 read n ; TAB1 while 1 ; TAB2 if not isprime ( n * i + 1 ) ; TAB3 print i ; TAB2 increment i ;	bool isprime ( int j ) { for ( int i = 2 ; i < j ; i ++ ) { if ( ! ( j % i ) ) return 0 ; } return 1 ; } int main ( ) { int i = 1 , n ; cin >> n ; while ( 1 ) { if ( ! isprime ( n * i + 1 ) ) { cout << i << endl ; return 0 ; } i ++ ; } return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 arr = array of integers of length n ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 sort the values arr , arr + n ; TAB1 print arr [ 0 ] ; TAB1 for i = 1 to n exclusive ; TAB2 print space ; TAB2 print arr [ i ] ; TAB1 print newline ;	int main ( ) { int n ; cin >> n ; int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } sort ( arr , arr + n ) ; cout << arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cout << "   " ; cout << arr [ i ] ; } cout << endl ; return 0 ; }
TAB1 n , m , i , j = int , num = array of 105 int , cnt = 0 ; TAB1 read n , m ; TAB1 for i = 0 to n exclusive ; TAB2 read num [ i ] ; TAB2 if num [ i ] < = m ; TAB3 num [ i ] = 0 ; TAB3 j = i ; TAB2 else ; TAB3 subtract m from num [ i ] ; TAB3 cnt = 1 ; TAB1 while cnt ; TAB2 cnt = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if num [ i ] < = m and is not 0 ; TAB4 num [ i ] = 0 ; TAB4 j = i ; TAB3 else if num [ i ] > m ; TAB4 subtract m from num [ i ] ; TAB4 cnt = 1 ; TAB1 print j + 1 ;	int main ( ) { int n , m , i , j , num [ 105 ] , cnt = 0 ; cin >> n >> m ; for ( i = 0 ; i < n ; i ++ ) { cin >> num [ i ] ; if ( num [ i ] <= m ) { num [ i ] = 0 ; j = i ; } else { num [ i ] = num [ i ] - m ; cnt = 1 ; } } while ( cnt ) { cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( num [ i ] <= m && num [ i ] != 0 ) { num [ i ] = 0 ; j = i ; } else if ( num [ i ] > m ) { num [ i ] = num [ i ] - m ; cnt = 1 ; } } } cout << j + 1 << endl ; return 0 ; }
TAB0 let mat be a logical matrix of size 7x7 ; TAB0 in int function calc which takes string s ; TAB1 let r = 0 = integer ; TAB1 for i = 0 to 7 exlusive ; TAB2 for j = 0 to 7 exclusive ; TAB3 if s at i is same as s at j and mat at i and j is not 0 then increment r ; TAB1 return r ; TAB1 let n , ans , temp , lans , ltemp be int with ans = temp = lans = ltemp = INT_MAX ; TAB1 read n ; TAB1 let arr , t be long long arrays of size 3 both with all 0 ; TAB1 for i = 0 to 7 exclusive ; TAB2 for j = 0 to 7 exclusive , set mat [ i ] [ j ] to false ; TAB1 let hero be a map form string to int ; TAB1 set hero at " Anka " to 0 ; TAB1 set hero at " Chapay " to 1 ; TAB1 set hero [ " Cleo " ] = 2 ; TAB1 set hero [ " Dracul " ] to 3 ; TAB1 set hero [ " Dracul " ] tp 4 ; TAB1 hero [ " Snowy " ] = 5 ; TAB1 set hero at Hexadecimal = 6 ; TAB1 let x , y , z , q be strings ; TAB1 for i = 0 to n exclusive ; TAB2 read x , y , z ; TAB2 set mat [ hero [ x ] ] [ hero [ z ] ] to true ; TAB1 read arr at 0 , arra at 1 , arr at 2 ; TAB1 sort the first 3 elements of arr ; TAB1 let h be a set of strings ; TAB1 let it be a set string iterator ; TAB1 set t at 2 = arr [ 2 ] / 5 ; TAB1 t [ 1 ] = arr [ 1 ] ; TAB1 set t at 0 to arr [ 0 ] ; TAB1 sort the first 3 elements of t ; TAB1 set temp to t [ 2 ] - t [ 0 ] ; TAB1 if temp is less than ans ; TAB2 set ans to temp ; TAB2 call insert on h with arg " aaaaabc " ; TAB1 set t at 2 = arr [ 2 ] / 4 ; TAB1 set t at 1 = arr [ 1 ] / 2 ; TAB1 set t at 0 to arr at 0 ; TAB1 sort the first three elements of arr ; TAB1 set temp = t [ 2 ] - t [ 0 ] ; TAB1 if temp is less than ans ; TAB2 set ans to temp ; TAB2 clear h ; TAB2 insert " aaaabbc " in h ; TAB1 else if temp is same as ans ; TAB2 insert " aaaabbc " in h ; TAB1 set t [ 2 ] = arr [ 2 ] / 3 ; TAB1 set t [ 1 ] = arr [ 1 ] / 3 ; TAB1 set t at 0 to arr at 0 ; TAB1 sort the first 3 elements of t ; TAB1 set tempo to t [ 2 ] - t [ 0 ] ; TAB1 if temp < ans ; TAB2 set ans to temp ; TAB2 clear h ; TAB2 insert " aaaabbc " in h ; TAB1 else if temp is same as ans ; TAB2 insert " aaaabbc " in h ; TAB1 set t [ 2 ] to arr [ 2 ] / 3 ; TAB1 set t [ 1 ] to arr [ 1 ] / 2 ; TAB1 set t [ 0 ] to arr [ 0 ] / 2 ; TAB1 sort the first 3 elements of t ; TAB1 set temp to t [ 2 ] - t [ 0 ] ; TAB1 if temp is less than ans ; TAB2 set ans to temp ; TAB2 clear h ; TAB2 insert " aaabbcc " in h ; TAB1 if temp = ans ; TAB2 insert " aaabbcc " in h ; TAB1 while h is not empty ; TAB2 set q to be q * the first element of h ; TAB2 do loop ; TAB3 set ltemp to calc of q ; TAB3 if ltemp is greater than lans then set lans to ltemp ; TAB2 while the result of calling next_permutation with args start of q and end of q is not 0 ; TAB2 erase q from h ; TAB1 print ans and space and lans ;	bool mat [ 7 ] [ 7 ] ; int calc ( string s ) { int r = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { if ( s [ i ] == s [ j ] && mat [ i ] [ j ] ) r ++ ; } } return r ; } int main ( ) { int n , ans = INT_MAX , temp = INT_MAX , lans = 0 , ltemp = 0 ; cin >> n ; long long arr [ 3 ] , t [ 3 ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) mat [ i ] [ j ] = false ; map < string , int > hero ; hero [ " Anka " ] = 0 ; hero [ " Chapay " ] = 1 ; hero [ " Cleo " ] = 2 ; hero [ " Troll " ] = 3 ; hero [ " Dracul " ] = 4 ; hero [ " Snowy " ] = 5 ; hero [ " Hexadecimal " ] = 6 ; string x , y , z , q ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> y >> z ; mat [ hero [ x ] ] [ hero [ z ] ] = true ; } cin >> arr [ 0 ] >> arr [ 1 ] >> arr [ 2 ] ; sort ( arr , arr + 3 ) ; set < string > h ; set < string > :: iterator it ; t [ 2 ] = arr [ 2 ] / 5 ; t [ 1 ] = arr [ 1 ] ; t [ 0 ] = arr [ 0 ] ; sort ( t , t + 3 ) ; temp = t [ 2 ] - t [ 0 ] ; if ( temp < ans ) { ans = temp ; h . insert ( " aaaaabc " ) ; } t [ 2 ] = arr [ 2 ] / 4 ; t [ 1 ] = arr [ 1 ] / 2 ; t [ 0 ] = arr [ 0 ] ; sort ( t , t + 3 ) ; temp = t [ 2 ] - t [ 0 ] ; if ( temp < ans ) { ans = temp ; h . clear ( ) ; h . insert ( " aaaabbc " ) ; } else if ( temp == ans ) { h . insert ( " aaaabbc " ) ; } t [ 2 ] = arr [ 2 ] / 3 ; t [ 1 ] = arr [ 1 ] / 3 ; t [ 0 ] = arr [ 0 ] ; sort ( t , t + 3 ) ; temp = t [ 2 ] - t [ 0 ] ; if ( temp < ans ) { ans = temp ; h . clear ( ) ; h . insert ( " aaabbbc " ) ; } else if ( temp == ans ) { h . insert ( " aaabbbc " ) ; } t [ 2 ] = arr [ 2 ] / 3 ; t [ 1 ] = arr [ 1 ] / 2 ; t [ 0 ] = arr [ 0 ] / 2 ; sort ( t , t + 3 ) ; temp = t [ 2 ] - t [ 0 ] ; if ( temp < ans ) { ans = temp ; h . clear ( ) ; h . insert ( " aaabbcc " ) ; } else if ( temp == ans ) { h . insert ( " aaabbcc " ) ; } while ( ! h . empty ( ) ) { q = * ( h . begin ( ) ) ; do { ltemp = calc ( q ) ; if ( ltemp > lans ) lans = ltemp ; } while ( next_permutation ( q . begin ( ) , q . end ( ) ) ) ; h . erase ( q ) ; } cout << ans << "   " << lans << endl ; return 0 ; }
TAB0 let n , a , b , c be unsigned long long ; TAB1 read n , a , b , c ; TAB1 if a < = b - c ; TAB2 print out n / a with newline ; TAB1 else ; TAB2 let ans be unsigned long long with ans = 0 ; TAB2 if n > c , set ans to ( n - c ) / ( b - c ) ; TAB2 increment ans by ( n - ans * ( b - c ) ) / a ; TAB2 print ans ;	unsigned long long n , a , b , c ; int main ( ) { cin >> n >> a >> b >> c ; if ( a <= b - c ) { cout << n / a << endl ; } else { unsigned long long ans = 0 ; if ( n > c ) ans = ( n - c ) / ( b - c ) ; ans += ( n - ans * ( b - c ) ) / a ; cout << ans << endl ; } return 0 ; }
TAB1 let n , k be integers ; TAB1 read n and k ; TAB1 let s be a string ; TAB1 read s ; TAB1 let a be a integer with a = 1 ; TAB1 for a is less than size of s , increase a by 1 ; TAB2 let i be a integer ; TAB2 for i = 0 to size of s + a exclusive ; TAB3 if s [ i ] is not equal to s [ a + i ] , stop ; TAB3 increase i by 1 ; TAB2 if a + i is equal to n , stop ; TAB1 for i = 0 to k - 1 exclusive ; TAB2 for j = 0 to a exclusive , print jth element of s ; TAB1 print s and newline ;	int main ( ) { int n , k ; cin >> n >> k ; string s ; cin >> s ; int a = 1 ; for ( ; a < s . size ( ) ; a ++ ) { int i ; for ( i = 0 ; a + i < s . size ( ) ; ) { if ( s [ i ] != s [ a + i ] ) break ; i ++ ; } if ( a + i == n ) break ; } for ( int i = 0 ; i < k - 1 ; i ++ ) { for ( int j = 0 ; j < a ; j ++ ) { cout << s [ j ] ; } } cout << s << endl ; return 0 ; }
TAB1 let t be a integer with t = 1 ; TAB1 while t is decremented by 1 ; TAB2 let s1 , s2 be strings ; TAB2 let cnt be a integer with cnt = 0 ; TAB2 let ind be a vector of integers ; TAB2 read s1 , s2 ; TAB2 let the boolean value flag is equal to 1 ; TAB2 if size of s1 is not equal to size of s2 ; TAB3 set flag to 0 ; TAB2 else do the following ; TAB3 for i = 0 to size of s1 exclusive ; TAB4 if s1 [ i ] is not equal to s2 [ i ] ; TAB5 increment cnt by 1 ; TAB5 push back i in vector ind ; TAB4 if cnt is greater than 2 ; TAB5 set flag to 0 ; TAB5 stop ; TAB3 if flag is true ; TAB4 if size of ind is equal to 2 ; TAB5 if not s1 [ ind [ 0 ] ] is equal to s2 [ ind [ 1 ] ] and s1 [ ind [ 1 ] ] is equal to s2 [ ind [ 0 ] ] ) , set flag to 0 ; TAB4 else do the following ; TAB5 set flag to 0 ; TAB2 if flag is true ; TAB3 print YES and newline ; TAB2 else do the following ; TAB3 print NO and newline ;	int main ( ) { int t = 1 ; while ( t -- ) { string s1 , s2 ; int cnt = 0 ; vector < int > ind ; cin >> s1 >> s2 ; bool flag = 1 ; if ( s1 . size ( ) != s2 . size ( ) ) flag = 0 ; else { for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { cnt ++ ; ind . push_back ( i ) ; } if ( cnt > 2 ) { flag = 0 ; break ; } } if ( flag ) { if ( ind . size ( ) == 2 ) { if ( ! ( s1 [ ind [ 0 ] ] == s2 [ ind [ 1 ] ] && s1 [ ind [ 1 ] ] == s2 [ ind [ 0 ] ] ) ) flag = 0 ; } else flag = 0 ; } } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; } }
TAB0 declare long long integers a , b , c , d ; TAB0 define function gys whick takes in long long ints a and b ; TAB1 while b is not 0 ; TAB2 create long long c equal to a modulo b ; TAB2 set a to b ; TAB2 set b to c ; TAB1 return a ; TAB0 define inline function gbs with long long parameters a and b ; TAB1 return ( a * b ) / gys ( a , b ) ; TAB1 read a , b , c and d ; TAB1 let n be a long long and if n is less than or equal to d set n to d ; TAB1 create integer signal and set it to 1 ; TAB1 if n and b are equal set signal to 0 ; TAB1 declare long long res = - 1 ; TAB1 create integer MAX = 1e9 ; TAB1 if signal is true ; TAB2 if c is less than 16 ; TAB3 assign 1e8 to MAX ; TAB2 else if c is less than 10 ; TAB3 set MAX to 1e7 ; TAB2 else if c is less than 6 ; TAB3 MAX = 6e6 ; TAB2 else if c is less than 3 ; TAB3 MAX is equal to 6e5 ; TAB2 while MAX is greater than or equal to n ; TAB3 if abs ( n - b ) modulo a equals 0 ; TAB4 set res to n ; TAB4 break ; TAB3 n = n + c ; TAB1 else ; TAB2 if a is less than 16 ; TAB3 MAX is equal to 1e8 ; TAB2 else if 10 is greater than a ; TAB3 MAX = 1e7 ; TAB2 else if a is less than 6 ; TAB3 MAX is equal to 6e6 ; TAB2 else if a is less than 3 ; TAB3 MAX is equal to 6e5 ; TAB2 iterate while n is less than or equal to MAX ; TAB3 if abs ( n - d ) modulo c equals 0 ; TAB4 assign n to res ; TAB4 break ; TAB3 n = n + a ; TAB1 if res is equal to - 1 ; TAB2 print - 1 ; TAB1 else ; TAB2 print res ;	long long a , b , c , d ; long long gys ( long long a , long long b ) { while ( b ) { long long c = a % b ; a = b ; b = c ; } return a ; } inline long long gbs ( long long a , long long b ) { return ( a * b ) / gys ( a , b ) ; } int main ( ) { cin >> a >> b >> c >> d ; long long n = b > d ? b : d ; int signal = 1 ; if ( n == b ) { signal = 0 ; } long long res = - 1 ; int MAX = 1e9 ; if ( signal ) { if ( c < 16 ) MAX = 1e8 ; else if ( c < 10 ) MAX = 1e7 ; else if ( c < 6 ) MAX = 6e6 ; else if ( c < 3 ) MAX = 6e5 ; while ( n <= MAX ) { if ( abs ( n - b ) % a == 0 ) { res = n ; break ; } n += c ; } } else { if ( a < 16 ) MAX = 1e8 ; else if ( a < 10 ) MAX = 1e7 ; else if ( a < 6 ) MAX = 6e6 ; else if ( a < 3 ) MAX = 6e5 ; while ( n <= MAX ) { if ( abs ( n - d ) % c == 0 ) { res = n ; break ; } n += a ; } } if ( res == - 1 ) cout << - 1 << endl ; else cout << res << endl ; }
TAB1 let n be an integer ; TAB1 input n ; TAB1 let l be an integer array of length n ; TAB1 let a1 , b1 , b2 , and ans all be integers set to 0 , let a2 be an integer set to 101 , let x be an integer ; TAB1 iterate n times ; TAB2 x is an integer ; TAB2 read x ; TAB2 assign x to l [ i ] ; TAB2 if a2 is at least x ; TAB3 assign x to a2 ; TAB3 assign i to b2 ; TAB2 if a1 is less than x ; TAB3 assign x to a1 ; TAB3 assign i to b1 ; TAB1 if b1 is less than b2 ; TAB2 set ans to b1 + n - 1 - b2 ; TAB2 display ans ; TAB1 else if b1 is greater than b2 ; TAB2 set ans to b1 + n - 2 - b2 ; TAB2 display ans ;	int main ( ) { int n ; cin >> n ; int l [ n ] ; int x , a1 = 0 , a2 = 101 , b1 = 0 , b2 = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; l [ i ] = x ; if ( a2 >= x ) { a2 = x ; b2 = i ; } if ( a1 < x ) { a1 = x ; b1 = i ; } } if ( b1 < b2 ) { ans = b1 + n - 1 - b2 ; cout << ans << endl ; } else if ( b1 > b2 ) { ans = b1 + n - 2 - b2 ; cout << ans << endl ; } return 0 ; }
TAB0 l , r and s are long longs with s = 0 ; TAB0 create new vector of long longs v ; TAB0 void function rec with long long argument x ; TAB1 if x > = l , add x to the vector v ; TAB1 if x is greater than r , return ; TAB1 call rec ( 10 * x + 4 ) ; TAB1 call rec ( 10 * x + 7 ) ; TAB1 i , t and p are integers where p = 0 ; TAB1 read from the input to l and r ; TAB1 call rec ( 0 ) ; TAB1 sort all elements of v ; TAB1 assign l to i ; TAB1 while i < = r ; TAB2 change the value of t to i ; TAB2 while i < = v [ p ] & & i < = r ; TAB2 increase s by ( i - t ) * v [ p ] and increment p ; TAB1 print s and " \ n " ;	long long l , r , s = 0 ; vector < long long > v ; void rec ( long long x ) { if ( x >= l ) v . push_back ( x ) ; if ( x > r ) return ; rec ( 10 * x + 4 ) ; rec ( 10 * x + 7 ) ; } int main ( ) { int i , t , p = 0 ; cin >> l >> r ; rec ( 0 ) ; sort ( v . begin ( ) , v . end ( ) ) ; i = l ; while ( i <= r ) { t = i ; while ( i <= v [ p ] && i <= r ) { i ++ ; } s += ( i - t ) * v [ p ++ ] ; } cout << s << " \n " ; }
TAB1 s = string ; TAB1 read s ; TAB1 a , b , c , x , y = long with a = 0 and b = 0 and c = 0 and x = 0 and y = 0 ; TAB1 iterate i while s [ i ] is not ' \ 0 ' ; TAB2 if s [ i ] is ' | ' and x is not 1 increment a ; TAB2 if s [ i ] is ' | ' and x is 1 and y is not 1 increment b ; TAB2 if s [ i ] is ' | ' and x is 1 and y is 1 increment c ; TAB2 if s [ i ] is ' + ' set x to 1 ; TAB2 if s [ i ] is ' = ' set y to 1 ; TAB1 set x to a + b ; TAB1 set y to x - c ; TAB1 if y is 0 ; TAB2 print s ; TAB1 else if y is - 2 ; TAB2 for i = 0 to a inclusive print " | " ; TAB2 print " + " ; TAB2 for i = 0 to b print " | " ; TAB2 print " = " ; TAB2 for i = 0 to c - 1 print " | " ; TAB2 print newline ; TAB1 else if y is 2 ; TAB2 if a is not 1 ; TAB3 decrement a ; TAB2 else ; TAB3 decrement b ; TAB2 for i = 0 to a print " | " ; TAB2 print " + " ; TAB2 for i = 0 to b print " | " ; TAB2 print " = " ; TAB2 for i = 0 to c inclusive print " | " ; TAB2 print newline ; TAB1 else ; TAB2 print " Impossible " ;	int main ( ) { string s ; cin >> s ; long a = 0 , b = 0 , c = 0 , x = 0 , y = 0 ; for ( int i = 0 ; s [ i ] != ' \0 ' ; i ++ ) { if ( s [ i ] == ' | ' && x != 1 ) { a ++ ; } if ( s [ i ] == ' | ' && x == 1 && y != 1 ) b ++ ; if ( s [ i ] == ' | ' && x == 1 && y == 1 ) c ++ ; if ( s [ i ] == ' + ' ) x = 1 ; if ( s [ i ] == ' = ' ) y = 1 ; } x = a + b ; y = x - c ; if ( y == 0 ) { cout << s << " \n " ; } else if ( y == - 2 ) { for ( long i = 0 ; i <= a ; i ++ ) cout << " | " ; cout << " + " ; for ( long i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( long i = 0 ; i < c - 1 ; i ++ ) cout << " | " ; cout << " \n " ; } else if ( y == 2 ) { if ( a != 1 ) a -- ; else b -- ; for ( long i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( long i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( long i = 0 ; i <= c ; i ++ ) cout << " | " ; cout << " \n " ; } else cout << " Impossible\n " ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 let stac be a stack of long long int ; TAB1 let last = - 1 be long long int ; TAB1 let count = 0 be a long long int ; TAB1 for long long int i = 0 to length of s exclusive ; TAB2 if s at i is ' ( ' ; TAB3 push i in stac ; TAB2 else ; TAB3 is stack is empty ; TAB4 print - 1 and new line ; TAB3 pop stac ; TAB3 if s at i is # , set last to i , increment count ; TAB1 let k = size of stac be a long long int ; TAB1 while stac is not empty ; TAB2 if stac top > last ; TAB3 print - 1 and new line ; TAB2 pop stac ; TAB1 print 1 and new line count - 1 times ; TAB1 print 1 + k ;	int main ( ) { string s ; cin >> s ; stack < long long int > stac ; long long int last = - 1 ; long long int count = 0 ; for ( long long int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { stac . push ( i ) ; } else { if ( stac . empty ( ) ) { cout << " -1\n " ; return 0 ; } stac . pop ( ) ; if ( s [ i ] == ' # ' ) { last = i , count ++ ; } } } long long int k = stac . size ( ) ; while ( ! stac . empty ( ) ) { if ( stac . top ( ) > last ) { cout << " -1\n " ; return 0 ; } stac . pop ( ) ; } for ( long long int i = 0 ; i < count - 1 ; i ++ ) { cout << " 1\n " ; } cout << 1 + k << endl ; }
TAB0 let p be an integer array of length 105 ; TAB0 define function par which takes in integer x as an argument ; TAB1 if p [ x ] is equal to x ; TAB2 return x ; TAB1 or else ; TAB2 return par ( p [ x ] ) ; TAB1 let n and m be ints ; TAB1 read in n and m ; TAB1 iterate for m + 1 times , set p [ i ] to 0 ; TAB1 let k be an int , set k to 0 ; TAB1 let x , y and z be integers ; TAB1 iterate for n times ; TAB2 read in x ; TAB2 if x is equal to 0 ; TAB3 increment k ; TAB2 or else ; TAB3 read in y ; TAB3 if p [ y ] is equal to 0 , set p [ y ] to y ; TAB3 iterate for x - 1 times ; TAB4 read in z ; TAB4 if p [ z ] is equal to 0 , set p [ z ] to z ; TAB4 if par ( z ) is not equal to par ( y ) , set p [ par ( z ) ] to y ; TAB1 let temp be an integer , set temp to 0 ; TAB1 iterate for m times ; TAB2 if p [ i ] is equal to i , increment temp ; TAB1 if temp is not equal to 0 , decrement temp ; TAB1 print k + temp ;	int p [ 105 ] ; int par ( int x ) { if ( p [ x ] == x ) return x ; else return par ( p [ x ] ) ; } int main ( ) { int n , m ; cin >> n >> m ; for ( int i = 0 ; i <= m ; i ++ ) { p [ i ] = 0 ; } int k = 0 ; int x , y , z ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 0 ) { k ++ ; } else { cin >> y ; if ( p [ y ] == 0 ) p [ y ] = y ; for ( int j = 0 ; j < x - 1 ; j ++ ) { cin >> z ; if ( p [ z ] == 0 ) p [ z ] = z ; if ( par ( z ) != par ( y ) ) p [ par ( z ) ] = y ; } } } int temp = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( p [ i ] == i ) { temp ++ ; } } if ( temp != 0 ) temp -- ; cout << k + temp << endl ; }
TAB0 n , m = integers ; TAB0 k = integer ; TAB0 debug = bool with debug = false ; TAB0 bl = integer array of size 103 ; TAB1 read n ; TAB1 s , a , ss , S , let = strings with a = array of size n ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 transform ( a [ i ] . begin ( ) , a [ i ] . end ( ) , a [ i ] . begin ( ) , tolower ) ; TAB1 read S , let ; TAB1 resize S . size ( ) of ss ; TAB1 transform ( S . begin ( ) , S . end ( ) , ss . begin ( ) , tolower ) ; TAB1 for i = 0 to n exclusive ; TAB2 pos = long long with pos = ss . find ( a [ i ] ) ; TAB2 while ( pos is not string npos ) ; TAB3 for j = 0 to a [ i ] . size ( ) exclusive , bl [ j + pos ] = 1 ; TAB3 pos = ss . find ( a [ i ] , pos + 1 ) ; TAB1 ans = string with ans = " " ; TAB1 for i = 0 to ss . size ( ) exclusive ; TAB2 if ( bl [ i ] ) ; TAB3 if ( ss [ i ] is let [ 0 ] ) ; TAB4 if ( ss [ i ] is not a ) ; TAB5 if ( isupper ( S [ i ] ) ) ; TAB6 ans = ans + A ; TAB5 else ; TAB6 ans = ans + a ; TAB4 else ; TAB5 if ( isupper ( S [ i ] ) ) ; TAB6 ans = ans + B ; TAB5 else ; TAB6 ans = ans + b ; TAB4 continue next iteration ; TAB3 if ( isupper ( S [ i ] ) ) ; TAB4 ans = ans + toupper ( let [ 0 ] ) ; TAB3 else ; TAB4 ans = ans + let ; TAB2 else ; TAB3 ans = ans + S [ i ] ; TAB1 print ans . c_str ( ) ;	int n , m ; int k ; bool debug = false ; int bl [ 103 ] ; int main ( ) { cin >> n ; string s , a [ n ] , ss , S , let ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; transform ( a [ i ] . begin ( ) , a [ i ] . end ( ) , a [ i ] . begin ( ) , :: tolower ) ; } cin >> S >> let ; ss . resize ( S . size ( ) ) ; transform ( S . begin ( ) , S . end ( ) , ss . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < n ; i ++ ) { long long pos = ss . find ( a [ i ] ) ; while ( pos != string :: npos ) { for ( int j = 0 ; j < a [ i ] . size ( ) ; j ++ ) { bl [ j + pos ] = 1 ; } pos = ss . find ( a [ i ] , pos + 1 ) ; } } string ans = "  " ; for ( int i = 0 ; i < ss . size ( ) ; i ++ ) { if ( bl [ i ] ) { if ( ss [ i ] == let [ 0 ] ) { if ( ss [ i ] != ' a ' ) { if ( isupper ( S [ i ] ) ) ans += ' A ' ; else ans += ' a ' ; } else { if ( isupper ( S [ i ] ) ) ans += ' B ' ; else ans += ' b ' ; } continue ; } if ( isupper ( S [ i ] ) ) ans += toupper ( let [ 0 ] ) ; else ans += let ; } else { ans += S [ i ] ; } } puts ( ans . c_str ( ) ) ; return 0 ; }
TAB1 let n , count be long integers with count = 0 ; TAB1 read n ; TAB1 the integer value of max_i = 200005 ; TAB1 the integer value of counter = 0 ; TAB1 tuple < long long , long long , long long > data [ max_i ] ; TAB1 for i = 0 to n exclusive ; TAB2 let k , a0 , x , y , m , t , a be long integers with t = 0 , a = 0 ; TAB2 read k , a0 , x , y , m ; TAB2 for j = 0 to k exclusive ; TAB3 data [ counter + + ] is equal to make_tuple ( t , a0 , i ) ; TAB3 a is equal to ( a0 * x + y ) modulo m ; TAB3 if a is less than a0 and j is not equal to k - 1 , increment t by 1 ; TAB3 a0 is equal to a ; TAB2 count is equal to maximum of count and t ; TAB1 print count and newline ; TAB1 sort the values of data , data + counter ; TAB1 for i = 0 to counter exclusive , print get < 1 > ( data [ i ] ) and space and get < 2 > ( data [ i ] ) + 1 and newline ;	int main ( ) { long long n , count = 0 ; cin >> n ; int max_i = 200005 ; int counter = 0 ; tuple < long long , long long , long long > data [ max_i ] ; for ( int i = 0 ; i < n ; i ++ ) { long long k , a0 , x , y , m , t = 0 , a = 0 ; cin >> k >> a0 >> x >> y >> m ; for ( int j = 0 ; j < k ; j ++ ) { data [ counter ++ ] = make_tuple ( t , a0 , i ) ; a = ( a0 * x + y ) % m ; if ( a < a0 && j != k - 1 ) { t ++ ; } a0 = a ; } count = max ( count , t ) ; } cout << count << endl ; sort ( data , data + counter ) ; for ( int i = 0 ; i < counter ; i ++ ) { cout << get < 1 > ( data [ i ] ) << "   " << get < 2 > ( data [ i ] ) + 1 << endl ; } }
TAB0 arr = int array of size 103 ; TAB1 n = int ; TAB1 read n ; TAB1 read n values into arr ; TAB1 sort arr from position 0 to n ; TAB1 for i = 0 to n ; TAB2 if i < n - 1 ; TAB3 print arr [ i ] then ' ' ; TAB2 else ; TAB3 print arr [ i ] ;	int arr [ 103 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) cin >> arr [ i ] ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i < n - 1 ) cout << arr [ i ] << '   ' ; else cout << arr [ i ] << endl ; } return 0 ; }
TAB0 create ints ans and n and int array b of size 20 ; TAB0 make bool array a of size 10 with array of size 10 ; TAB0 declare check returning bool ; TAB1 make ints i , j , r , l , and tot ; TAB1 for i = 1 to 5 ; TAB2 set l and r to 0 ; TAB2 for j = 1 to 5 ; TAB3 if a [ i ] [ j ] is truthy ; TAB4 increment l ; TAB4 if b [ j ] is truthy , add 1 to r ; TAB2 if l - 1 is greater than r , return false ; TAB1 for i = 1 to 5 ; TAB2 set l and r to 0 ; TAB2 for j = 1 to 5 ; TAB3 if a [ j ] [ i ] is truthy ; TAB4 increment l ; TAB4 if b [ 5 + j ] is truthy , increment r ; TAB2 if l - 1 is greater than r , return false ; TAB1 set tot to 0 ; TAB1 for i = 1 to 5 ; TAB2 for j = 1 to 5 ; TAB3 if a [ i ] [ j ] is truthy , ! b [ i + 5 ] is truthy , and b [ j ] is falsy , increment tot ; TAB1 if tot is greater than 1 , return false ; TAB1 return true ; TAB0 declare dfs taking in integer x ; TAB1 make ints i and sum ; TAB1 if x is equal to 11 ; TAB2 if check ( ) returns true ; TAB3 set sum to 0 ; TAB3 for i = 1 to 11 ; TAB4 if b [ i ] is equal to 1 , add 1 to sum ; TAB3 set ans to min of sum and ans ; TAB2 return ; TAB1 set b [ x ] to 1 ; TAB1 call dfs ( x + 1 ) ; TAB1 set b [ x ] to 0 ; TAB1 call dfs ( x + 1 ) ; TAB1 create ints i and y ; TAB1 make char ch ; TAB1 let integer k ; TAB1 read n ; TAB1 set all contents of a to false ; TAB1 for i = 1 to n ; TAB2 read ch and k ; TAB2 if ch is equal to ' R ' ; TAB3 set y to 1 ; TAB2 else if ch is equal to ' G ' ; TAB3 set y to 2 ; TAB2 else if ch is equal to ' B ' ; TAB3 set y to 3 ; TAB2 else if ch is equal to ' Y ' ; TAB3 set y to 4 ; TAB2 else if ch is equal to ' W ' ; TAB3 set y to 5 ; TAB2 set a [ y ] [ k ] to true ; TAB1 set all contents of b to 0 ; TAB1 set ans to 9999999 ; TAB1 end statement ; TAB1 call dfs ( 1 ) ; TAB1 show ans ;	int b [ 20 ] , ans , n ; bool a [ 10 ] [ 10 ] ; bool check ( ) { int i , j , r , l , tot ; for ( i = 1 ; i <= 5 ; i ++ ) { l = r = 0 ; for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ i ] [ j ] ) { l ++ ; if ( b [ j ] ) { r ++ ; } } } if ( l - 1 > r ) return false ; } for ( i = 1 ; i <= 5 ; i ++ ) { l = r = 0 ; for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ j ] [ i ] ) { l ++ ; if ( b [ 5 + j ] ) r ++ ; } } if ( l - 1 > r ) return false ; } tot = 0 ; for ( i = 1 ; i <= 5 ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ i ] [ j ] && ! b [ i + 5 ] && ! b [ j ] ) tot ++ ; } } if ( tot > 1 ) return false ; return true ; } void dfs ( int x ) { int i , sum ; if ( x == 11 ) { if ( check ( ) ) { sum = 0 ; for ( i = 1 ; i <= 11 ; i ++ ) { if ( b [ i ] == 1 ) sum ++ ; } ans = min ( sum , ans ) ; } return ; } b [ x ] = 1 ; dfs ( x + 1 ) ; b [ x ] = 0 ; dfs ( x + 1 ) ; } int main ( ) { int i , y ; char ch ; int k ; cin >> n ; memset ( a , false , sizeof ( a ) ) ; for ( i = 1 ; i <= n ; i ++ ) { cin >> ch >> k ; if ( ch == ' R ' ) y = 1 ; else if ( ch == ' G ' ) y = 2 ; else if ( ch == ' B ' ) y = 3 ; else if ( ch == ' Y ' ) y = 4 ; else if ( ch == ' W ' ) y = 5 ; a [ y ] [ k ] = true ; } memset ( b , 0 , sizeof ( b ) ) ; ans = 9999999 ; ; dfs ( 1 ) ; cout << ans << endl ; }
TAB0 declare const int INF = 0x3f3f3f3f ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 declare integer array row with n + 10 elements ; TAB1 declare long long array ans with n + 10 elements ; TAB1 loop i from 1 to n inclusive , reading row [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 declare long long cont = 1 ; TAB2 create int j = row [ i ] ; TAB2 while cont < 103 and j ! = i ; TAB3 increment cont by one ; TAB3 assign row [ j ] to j ; TAB2 assign cont to ans [ i ] ; TAB2 if ans [ i ] = 0 , change ans [ i ] to 1 ; TAB2 if ans [ i ] is even , divide ans [ i ] by 2 ; TAB1 create long long mult = ans [ 1 ] ; TAB1 for i from 1 to n inclusive ; TAB2 if ans [ i ] is equal to 103 ; TAB3 print - 1 ; TAB2 assign ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] ) to mult ; TAB1 print mult ;	const int INF = 0x3f3f3f3f ; int main ( ) { int n ; cin >> n ; int row [ n + 10 ] ; long long ans [ n + 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> row [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) { long long cont = 1 ; int j = row [ i ] ; while ( cont < 103 and j != i ) { cont ++ ; j = row [ j ] ; } ans [ i ] = cont ; if ( ans [ i ] == 0 ) ans [ i ] = 1 ; if ( ans [ i ] % 2 == 0 ) ans [ i ] /= 2 ; } long long mult = ans [ 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ] == 103 ) { cout << - 1 << endl ; return 0 ; } mult = ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] ) ; } cout << mult << endl ; return 0 ; }
TAB1 create long longs n and ans ; TAB1 read standard input to n ; TAB1 if n is equal to 1 ; TAB2 change the value of ans to 1 ; TAB1 else if n is odd ; TAB2 assign ( n - 2 ) * ( n - 1 ) * n to ans ; TAB1 else if n = 2 ; TAB2 change ans to 2 ; TAB1 else if n modulo 6 is equal to 0 ; TAB2 assign the new value = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) to ans ; TAB1 else ; TAB2 set the value of ans to n * ( n - 1 ) * ( n - 3 ) ; TAB1 print ans ;	int main ( ) { long long n , ans ; cin >> n ; if ( n == 1 ) ans = 1 ; else if ( n % 2 ) ans = ( n - 2 ) * ( n - 1 ) * n ; else if ( n == 2 ) ans = 2 ; else if ( n % 6 == 0 ) ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; else ans = n * ( n - 1 ) * ( n - 3 ) ; cout << ans << endl ; }
TAB1 make long long ints ans = 0 , N , a , and b ; TAB1 read N ; TAB1 while N is greater than 0 ; TAB2 read a and b ; TAB2 set ans to max ( ans , a + 1 ) ; TAB2 while b is not equal to 1 ; TAB3 set b to ( b + 3 ) / 4 ; TAB3 add 1 to a ; TAB3 set ans to max of ans and a ; TAB2 decrease N by 1 ; TAB1 print ans ;	int main ( ) { long long ans = 0 , N , a , b ; cin >> N ; while ( N > 0 ) { cin >> a >> b ; ans = max ( ans , a + 1 ) ; while ( b != 1 ) { b = ( b + 3 ) / 4 ; a ++ ; ans = max ( ans , a ) ; } N -- ; } cout << ans << endl ; return 0 ; }
TAB0 s = string ; TAB0 a , b = integer ; TAB0 cx , cy = integers with cx = 0 , cy = 0 ; TAB1 read a , b ; TAB1 read s ; TAB1 for i = 0 to ( ( cast to int ) ( s ) . size ( ) ) ; TAB2 if cx is a and cy is b ; TAB3 print Yes ; TAB2 if s [ i ] is U ; TAB3 increment cy ; TAB2 else if s [ i ] is D ; TAB3 cy decrement ; TAB2 else if s [ i ] is R ; TAB3 increment cx ; TAB2 else ; TAB3 decrement cx ; TAB2 if cx is a and cy is b ; TAB3 print Yes ; TAB1 if cx ; TAB2 t = integer with t = abs ( a ) / abs ( cx ) ; TAB2 for now = t - 1000 to t + 1000 ; TAB3 if now < 0 , continue new iteration ; TAB3 first = long long with first = ( cast to long long ) cx * now ; TAB3 second = long long with second = ( cast to long long ) cy * now ; TAB3 for i = 0 to ( ( cast to int ) ( s ) . size ( ) ) ; TAB4 if first is a and second is b ; TAB5 print Yes ; TAB4 if s [ i ] is U ; TAB5 increment second ; TAB4 else if s [ i ] is D ; TAB5 decrement second ; TAB4 else if s [ i ] is R ; TAB5 increment first ; TAB4 else ; TAB5 decrement first ; TAB4 if first is a and second is b ; TAB5 print Yes ; TAB1 if cy ; TAB2 t = integer with t = abs ( b ) / abs ( cy ) ; TAB2 for now = t - 1000 to t + 1000 ; TAB3 if now < 0 , continue next iteration ; TAB3 first = long long with first = ( cast to long long ) cx * now ; TAB3 second = long long with second = ( cast to long long ) cy * now ; TAB3 for i = 0 to ( ( cast to int ) ( s ) . size ( ) ) ; TAB4 if first is a and second is b ; TAB5 print Yes ; TAB4 if s [ i ] is U ; TAB5 increment second ; TAB4 else if s [ i ] is D ; TAB5 decrement second ; TAB4 else if s [ i ] is R ; TAB5 increment first ; TAB4 else ; TAB5 decrement first ; TAB4 if first is a and second is b ; TAB5 print Yes ; TAB1 print No ;	string s ; int a , b ; int cx = 0 , cy = 0 ; int main ( ) { cin >> a >> b ; cin >> s ; for ( int i = 0 ; i < ( ( int ) ( s ) . size ( ) ) ; ++ i ) { if ( cx == a && cy == b ) { cout << " Yes\n " ; return 0 ; } if ( s [ i ] == ' U ' ) cy ++ ; else if ( s [ i ] == ' D ' ) cy -- ; else if ( s [ i ] == ' R ' ) cx ++ ; else cx -- ; if ( cx == a && cy == b ) { cout << " Yes\n " ; return 0 ; } } if ( cx ) { int t = abs ( a ) / abs ( cx ) ; for ( int now = t - 1000 ; now <= t + 1000 ; ++ now ) { if ( now < 0 ) continue ; long long first = ( long long ) cx * now ; long long second = ( long long ) cy * now ; for ( int i = 0 ; i < ( ( int ) ( s ) . size ( ) ) ; ++ i ) { if ( first == a && second == b ) { cout << " Yes\n " ; return 0 ; } if ( s [ i ] == ' U ' ) second ++ ; else if ( s [ i ] == ' D ' ) second -- ; else if ( s [ i ] == ' R ' ) first ++ ; else first -- ; if ( first == a && second == b ) { cout << " Yes\n " ; return 0 ; } } } } if ( cy ) { int t = abs ( b ) / abs ( cy ) ; for ( int now = t - 1000 ; now <= t + 1000 ; ++ now ) { if ( now < 0 ) continue ; long long first = ( long long ) cx * now ; long long second = ( long long ) cy * now ; for ( int i = 0 ; i < ( ( int ) ( s ) . size ( ) ) ; ++ i ) { if ( first == a && second == b ) { cout << " Yes\n " ; return 0 ; } if ( s [ i ] == ' U ' ) second ++ ; else if ( s [ i ] == ' D ' ) second -- ; else if ( s [ i ] == ' R ' ) first ++ ; else first -- ; if ( first == a && second == b ) { cout << " Yes\n " ; return 0 ; } } } } cout << " No\n " ; }
TAB0 find_len is a long long function with long long argument num ; TAB1 create long long l = 1 ; TAB1 for a = 7 to num exclusive multiplying a by 7 , add 1 to l ; TAB1 return l ; TAB1 declare long longs n , m , x , y , res , i and j ; TAB1 read n and m ; TAB1 change x to find_len ( n ) ; TAB1 change y to find_len ( m ) ; TAB1 change res to 0 ; TAB1 if x + y < = 7 ; TAB2 for i from 0 to n exclusive ; TAB3 for j from 0 to m exclusive ; TAB4 create vector of long long f with 7 elements , filled with 0 ; TAB4 for k = 0 and a = i while k ! = x , incrementing k and dividing a by 7 , increment f [ a % 7 ] ; TAB4 for k = 0 and b = j while k ! = y , incrementing k and dividing b by 7 , increment f [ b % 7 ] ; TAB4 if * max_element ( f . begin ( ) , f . end ( ) ) < = 1 , increment res ; TAB1 print res ;	long long find_len ( long long num ) { long long l = 1 ; for ( long long a = 7 ; a < num ; a *= 7 ) l += 1 ; return l ; } int main ( ) { long long n , m , x , y , res , i , j ; cin >> n >> m ; x = find_len ( n ) ; y = find_len ( m ) ; res = 0 ; if ( x + y <= 7 ) { for ( i = 0 ; i != n ; i ++ ) { for ( j = 0 ; j != m ; j ++ ) { vector < long long > f ( 7 , 0 ) ; for ( long long k = 0 , a = i ; k != x ; k ++ , a /= 7 ) f [ a % 7 ] ++ ; for ( long long k = 0 , b = j ; k != y ; k ++ , b /= 7 ) f [ b % 7 ] ++ ; if ( * max_element ( f . begin ( ) , f . end ( ) ) <= 1 ) res ++ ; } } } cout << res << endl ; return 0 ; }
TAB1 n = long integer ; TAB1 while read n ; TAB2 s = string ; TAB2 i , cnt , ar , f = long with cnt = 0 , ar = array of size 150 = { 0 } , f = 0 ; TAB2 read s ; TAB2 sort s . begin ( ) and s . end ( ) ; TAB2 x = long ; TAB2 for i = 0 to n exclusive ; TAB3 x = s [ i ] - 97 ; TAB3 increment ar [ x ] ; TAB3 if ar [ x ] > = 2 , f = 1 ; TAB2 if f is 1 or n is 1 ; TAB3 print Yes ; TAB2 else ; TAB3 print No ;	int main ( ) { long int n ; while ( cin >> n ) { string s ; long i , cnt = 0 , ar [ 150 ] = { 0 } , f = 0 ; cin >> s ; sort ( s . begin ( ) , s . end ( ) ) ; long x ; for ( i = 0 ; i < n ; i ++ ) { x = s [ i ] - 97 ; ar [ x ] ++ ; if ( ar [ x ] >= 2 ) { f = 1 ; } } if ( f == 1 || n == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; } }
TAB1 s , t , x = integers ; TAB1 Read s , t , x ; TAB1 if t is greater than x ; TAB2 print NO and a new line ; TAB1 if ( x - t ) modulo s is 0 ; TAB2 print YES and a new line ; TAB1 else if ( x - t - 1 ) modulo s is 0 and x is greater than ( t + s ) ; TAB2 print YES and a new line ; TAB1 else do the following ; TAB2 print NO and a new line ;	int main ( ) { int s , t , x ; cin >> t >> s >> x ; if ( t > x ) { cout << " NO " << endl ; return 0 ; } if ( ( x - t ) % s == 0 ) { cout << " YES " << endl ; } else if ( ( x - t - 1 ) % s == 0 && x > ( t + s ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 a = character array of length 120 by 120 ; TAB0 in function check that returns an integer and takes argument n = integer ; TAB1 flag1 = integer ; TAB1 for i = 1 to n inclusive ; TAB2 set flag1 to 0 ; TAB2 for j = 1 to n inclusive ; TAB3 if a [ i ] [ j ] equals . ; TAB4 set flag1 to 1 ; TAB4 break ; TAB2 if not flag1 then break ; TAB1 flag2 = integer ; TAB1 for i = 1 to n inclusive ; TAB2 set flag2 to 0 ; TAB2 for j = 1 to n inclusive ; TAB3 if a [ j ] [ i ] equals . ; TAB4 set flag2 to 1 ; TAB4 break ; TAB2 if not flag2 then break ; TAB1 if flag1 and flag2 both equal 0 ; TAB1 else ; TAB2 if flag1 ; TAB3 return 1 ; TAB2 else ; TAB3 return 2 ; TAB1 n = integer ; TAB1 while read n ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to n inclusive read a [ i ] [ j ] ; TAB2 judge = integer with value of the return of function check with argument n ; TAB2 if judge is not 0 ; TAB3 if judge equals 1 ; TAB4 for i = 1 to n inclusive ; TAB5 for j = 1 to n inclusive ; TAB6 if a [ i ] [ j ] equals . ; TAB7 print i space j ; TAB7 break ; TAB3 else ; TAB4 for i = 1 to n inclusive ; TAB5 for j = 1 to n inclusive ; TAB6 if a [ j ] [ i ] equals . ; TAB7 print j space i ; TAB7 break ; TAB2 else ; TAB3 print - 1 ;	char a [ 120 ] [ 120 ] ; int check ( int n ) { int flag1 ; for ( int i = 1 ; i <= n ; i ++ ) { flag1 = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] == ' . ' ) { flag1 = 1 ; break ; } } if ( ! flag1 ) { break ; } } int flag2 ; for ( int i = 1 ; i <= n ; i ++ ) { flag2 = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ j ] [ i ] == ' . ' ) { flag2 = 1 ; break ; } } if ( ! flag2 ) { break ; } } if ( flag1 == 0 && flag2 == 0 ) { return 0 ; } else { if ( flag1 ) { return 1 ; } else { return 2 ; } } } int main ( ) { int n ; while ( cin >> n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { cin >> a [ i ] [ j ] ; } } int judge = check ( n ) ; if ( judge ) { if ( judge == 1 ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] == ' . ' ) { cout << i << "   " << j << endl ; break ; } } } } else { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ j ] [ i ] == ' . ' ) { cout << j << "   " << i << endl ; break ; } } } } } else { cout << " -1 " << endl ; } } }
TAB1 create new integer called n ; TAB1 read standard input to n ; TAB1 declare new string variable s ; TAB1 read user input to s ; TAB1 create integer variable called flag with value 1 ; TAB1 declare integer variable count with value 0 ; TAB1 for i from 0 to n exclusive incrementing i ; TAB2 if s [ i ] is equal to ' ? ' ; TAB3 if value of i is equal to 0 , assign 2 to count ; TAB3 if i = n - 1 , change count to 2 ; TAB3 if s [ i + 1 ] = ' ? ' or s [ i - 1 ] = s [ i + 1 ] , set count to 2 ; TAB2 else if s [ i ] = s [ i + 1 ] ; TAB3 assign 1 to count ; TAB3 stop the loop ; TAB1 if count = 2 ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " to the standard output ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; int flag = 1 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ? ' ) { if ( i == 0 ) { count = 2 ; } if ( i == n - 1 ) { count = 2 ; } if ( s [ i + 1 ] == ' ? ' || ( s [ i - 1 ] == s [ i + 1 ] ) ) { count = 2 ; } } else if ( s [ i ] == s [ i + 1 ] ) { count = 1 ; break ; } } if ( count == 2 ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB0 v is a new vector of long long integers ; TAB0 declare integer t = 0 ; TAB0 declare long long integer variable p = 1 ; TAB0 primeFactors is a void function with long long int argument n ; TAB1 while n is even ; TAB2 if t is less than 2 , assign p * 2 to p ; TAB2 increment t ; TAB2 change n to n / 2 ; TAB1 in a for loop , change i from 3 to the square roof of n inclusive ; TAB2 while n % i = 0 ; TAB3 if t is less than 2 , set p to p * i ; TAB3 increment t ; TAB3 change n to n / i ; TAB1 if n is greater than 2 ; TAB2 if t is less than 2 , assign p * n to p ; TAB2 increment t ; TAB1 declare new long long integer n ; TAB1 read n from the input ; TAB1 call primeFactors ( n ) ; TAB1 if t < = 1 ; TAB2 print 1 and 0 to the standard output ; TAB1 else if t = 2 ; TAB2 print 2 ; TAB1 else ; TAB2 print 1 to the standard output ; TAB2 print p ;	vector < long long int > v ; int t = 0 ; long long int p = 1 ; void primeFactors ( long long int n ) { while ( n % 2 == 0 ) { if ( t < 2 ) { p = p * 2 ; } t ++ ; n = n / 2 ; } for ( long long int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( t < 2 ) { p = p * i ; } t ++ ; n = n / i ; } } if ( n > 2 ) { if ( t < 2 ) { p = p * n ; } t ++ ; } } int main ( ) { long long int n ; cin >> n ; primeFactors ( n ) ; if ( t <= 1 ) { cout << 1 << endl << 0 << endl ; } else if ( t == 2 ) { cout << 2 << endl ; } else { cout << 1 << endl ; cout << p << endl ; } return 0 ; }
TAB0 declare double tmaxmin = 1 bitshift left 20 ; TAB0 declare long long t1 ; TAB0 declare long long t1 ; TAB0 declare long long t0 ; TAB0 declare double T ; TAB0 declare long long x1 ; TAB0 declare long long x2 ; TAB0 declare long long solx1 ; TAB0 declare long long solx2 ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 while x1 is greater than or equal to 0 and x2 is greater than or equal to 0 ; TAB2 let T be ( 1 . 0 * t1 * x1 + t2 * x2 ) / ( x1 + x2 ) ; TAB2 if T is less than or equal to t0 ; TAB3 decrement x1 ; TAB2 else ; TAB3 if T is less than tmaxmin ; TAB4 let tmaxmin be T ; TAB4 let solx2 be x2 ; TAB4 let solx1 be x1 ; TAB3 decrement x2 ; TAB1 print solx1 , " " , solx2 , newline ;	double tmaxmin = 1 << 20 ; long long t1 ; long long t2 ; long long t0 ; double T ; long long x1 ; long long x2 ; long long solx1 ; long long solx2 ; int main ( ) { cin >> t1 >> t2 >> x1 >> x2 >> t0 ; while ( x1 >= 0 && x2 >= 0 ) { T = ( 1.0 * t1 * x1 + t2 * x2 ) / ( x1 + x2 ) ; if ( T < t0 ) { x1 -- ; } else { if ( T < tmaxmin ) { tmaxmin = T ; solx2 = x2 ; solx1 = x1 ; } x2 -- ; } } cout << solx1 << "   " << solx2 << endl ; }
TAB0 declare constant integer INF = integer casted 1e9 ; TAB0 declare constant double PI = 2 * acosign of 0 . 0 ; TAB0 declare constant double eps = 1e - 9 ; TAB0 declare constant integer NPOS = - 1 ; TAB0 declare constant integer MAX = 105 ; TAB0 declare string array arr size MAX ; TAB0 declare integer array have size MAX ; TAB0 declare map from character to integer m ; TAB0 declare integers n , diff , flag , flg ; TAB1 read n ; TAB1 let m [ ' R ' ] be 0 ; TAB1 let m [ ' G ' ] be 1 ; TAB1 let m [ ' B ' ] be 2 ; TAB1 let m [ ' Y ' ] be 3 ; TAB1 let m [ ' W ' ] be 4 ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 declare integer ans = INT_MAX ; TAB1 for col = 0 to 1 bitshift left 5 exclusive ; TAB2 for num = 0 to integer casted ( 1 bitshift left 5 ) exclusive ; TAB3 let flag be 0 ; TAB3 for i = 0 to integer casted n exclusive ; TAB4 for j = i + 1 to n exclusive ; TAB5 let flg be 0 ; TAB5 if arr [ i ] [ 0 ] is not arr [ j ] [ 0 ] ; TAB6 if ( 1 bitshift left m [ arr [ i ] [ 0 ] ] ) bitwise and col , let flg be 1 ; TAB6 if ( 1 bitshift left m [ arr [ j ] [ 0 ] ] ) bitwise and col , let flg be 1 ; TAB5 if arr [ i ] [ 1 ] is not arr [ j ] [ 1 ] ; TAB6 if ( 1 bitshift left ( arr [ i ] [ 1 ] - ' 1 ' ) ) bitwise and num , let flg be 1 ; TAB6 if ( 1 bitshift left ( arr [ j ] [ 1 ] - ' 1 ' ) ) bitwise and num , let flg be 1 ; TAB5 if ( arr [ i ] [ 0 ] is arr [ j ] [ 0 ] ) and ( arr [ i ] [ 1 ] is arr [ j ] [ 1 ] ) , let flg be 1 ; TAB5 if not flg , let flag be 1 ; TAB3 if not flag ; TAB4 declare integer t = result of run __builtin_popcount ( col ) + result of run __builtin_popcount ( num ) ; TAB4 let ans be minimum of t ans ans ; TAB1 print ans and ' \ n ' ;	const int INF = ( int ) 1e9 ; const double PI = 2 * acos ( 0.0 ) ; const double eps = 1e-9 ; const int NPOS = - 1 ; const int MAX = 105 ; string arr [ MAX ] ; int have [ MAX ] ; map < char , int > m ; int n , diff , flag , flg ; int main ( ) { cin >> n ; m [ ' R ' ] = 0 ; m [ ' G ' ] = 1 ; m [ ' B ' ] = 2 ; m [ ' Y ' ] = 3 ; m [ ' W ' ] = 4 ; for ( int i = int ( 0 ) ; i < int ( n ) ; ++ i ) cin >> arr [ i ] ; int ans = INT_MAX ; for ( int col = 0 ; col < ( 1 << 5 ) ; col ++ ) { for ( int num = int ( 0 ) ; num < int ( ( 1 << 5 ) ) ; ++ num ) { flag = 0 ; for ( int i = int ( 0 ) ; i < int ( n ) ; ++ i ) { for ( int j = i + 1 ; j < n ; j ++ ) { flg = 0 ; if ( arr [ i ] [ 0 ] != arr [ j ] [ 0 ] ) { if ( ( 1 << m [ arr [ i ] [ 0 ] ] ) & col ) flg = 1 ; if ( ( 1 << m [ arr [ j ] [ 0 ] ] ) & col ) flg = 1 ; } if ( arr [ i ] [ 1 ] != arr [ j ] [ 1 ] ) { if ( ( 1 << ( arr [ i ] [ 1 ] - ' 1 ' ) ) & num ) flg = 1 ; if ( ( 1 << ( arr [ j ] [ 1 ] - ' 1 ' ) ) & num ) flg = 1 ; } if ( ( arr [ i ] [ 0 ] == arr [ j ] [ 0 ] ) && ( arr [ i ] [ 1 ] == arr [ j ] [ 1 ] ) ) flg = 1 ; if ( ! flg ) flag = 1 ; } } if ( ! flag ) { int t = __builtin_popcount ( col ) + __builtin_popcount ( num ) ; ans = min ( t , ans ) ; } } } cout << ans << ' \n ' ; return 0 ; }
TAB1 declare integer x ; TAB1 read x ; TAB1 if x is 1 ; TAB2 print " - 1 " and newline ; TAB1 print x , " " , x , newline ;	int main ( ) { int x ; cin >> x ; if ( x == 1 ) { cout << " -1 " << endl ; return 0 ; } cout << x << "   " << x << endl ; return 0 ; }
TAB0 declare prime taking in integer i and returning bool ; TAB1 for k = 2 to i exclusive ; TAB2 if i % k is 0 , return false ; TAB1 return false ; TAB1 create integer n ; TAB1 read n ; TAB1 for i = 1 to 1000 ; TAB2 if prime ( n * i + 1 ) is false ; TAB3 show i ;	bool prime ( int i ) { for ( int k = 2 ; k < i ; k ++ ) if ( i % k == 0 ) return false ; return true ; } int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= 1000 ; i ++ ) { if ( prime ( n * i + 1 ) == false ) { cout << i << endl ; return 0 ; } } return 0 ; }
TAB0 declare long longs a , b , l , r , ans = 100 , T ; TAB0 declare Cal with character c as argument , returning long long ; TAB1 declare count = 0 as long long ; TAB1 declare character array s size 100 ; TAB1 for i = 0 to a exclusive , let s [ i ] be ' a ' + i ; TAB1 for i = a to a + b exclusive , let s [ i ] be c ; TAB1 declare integer array have size 26 ; TAB1 set bytes from have to 26 * size of integer to value 0 ; TAB1 for i = a + b - 1 to b inclusive , decrementing i , let have [ s [ i ] - ' a ' ] be 1 ; TAB1 declare long longs i = a + b , j = 0 ; TAB1 while i is less than 2 * a + b ; TAB2 while ( have [ j ] ) , increment j ; TAB2 let s [ i ] be j + ' a ' ; TAB2 increment i ; TAB2 increment j ; TAB1 for i = 2 * a + b to T exclusive , let s [ i ] be s [ i - 1 ] ; TAB1 set bytes from have to 26 * size of integer to value 0 ; TAB1 if l is less than or equal to r ; TAB2 for i = l to r inclusive ; TAB3 if not have [ s [ i ] - ' a ' ] ; TAB4 increment count ; TAB4 let have [ s [ i ] - ' a ' ] be 1 ; TAB1 else ; TAB2 for i = 0 to r inclusive ; TAB3 if not have [ s [ i ] - ' a ' ] ; TAB4 increment count ; TAB4 let have [ s [ i ] - ' a ' ] be 1 ; TAB2 for i = l to T exclusive ; TAB3 if not have [ s [ i ] - ' a ' ] ; TAB4 increment count ; TAB4 let have [ s [ i ] - ' a ' ] be 1 ; TAB1 return count from function ; TAB1 declare long long t ; TAB1 read a and b and l and r ; TAB1 decrement l ; TAB1 decrement r ; TAB1 let T be 2 * ( a + b ) ; TAB1 if a is greater than b + 1 ; TAB2 let t be 2 * a - b ; TAB1 else ; TAB2 let t be a + 1 ; TAB1 if r - l is greater than or equal to T ; TAB2 let ans be t ; TAB1 else ; TAB2 let r be r % T ; TAB2 let l be l % T ; TAB2 for i = 0 to a exclusive , let ans be minimum of ( result of run Cal with ' a ' + i as arguments and ans ) ; TAB1 print ans and newline ;	long long a , b , l , r , ans = 100 , T ; long long Cal ( char c ) { long long count = 0 ; char s [ 100 ] ; for ( int i = 0 ; i < a ; i ++ ) s [ i ] = ' a ' + i ; for ( int i = a ; i < a + b ; i ++ ) s [ i ] = c ; int have [ 26 ] ; memset ( have , 0 , 26 * sizeof ( int ) ) ; for ( long long i = a + b - 1 ; i >= b ; i -- ) have [ s [ i ] - ' a ' ] = 1 ; long long i = a + b , j = 0 ; while ( i < 2 * a + b ) { while ( have [ j ] ) j ++ ; s [ i ] = j + ' a ' ; i ++ ; j ++ ; } for ( int i = 2 * a + b ; i < T ; i ++ ) s [ i ] = s [ i - 1 ] ; memset ( have , 0 , 26 * sizeof ( int ) ) ; if ( l <= r ) { for ( long long i = l ; i <= r ; i ++ ) if ( ! have [ s [ i ] - ' a ' ] ) { count ++ ; have [ s [ i ] - ' a ' ] = 1 ; } } else { for ( long long i = 0 ; i <= r ; i ++ ) if ( ! have [ s [ i ] - ' a ' ] ) { count ++ ; have [ s [ i ] - ' a ' ] = 1 ; } for ( long long i = l ; i < T ; i ++ ) if ( ! have [ s [ i ] - ' a ' ] ) { count ++ ; have [ s [ i ] - ' a ' ] = 1 ; } } return count ; } int main ( ) { long long t ; cin >> a >> b >> l >> r ; l -- ; r -- ; T = 2 * ( a + b ) ; if ( a > b + 1 ) t = 2 * a - b ; else t = a + 1 ; if ( r - l >= T ) ans = t ; else { r %= T ; l %= T ; for ( int i = 0 ; i < a ; i ++ ) ans = min ( Cal ( ' a ' + i ) , ans ) ; } cout << ans << endl ; return 0 ; }
TAB1 a , b , c = 0 ; TAB1 n , c = int ; TAB1 read n ; TAB1 while decremented value of n is not 0 ; TAB2 read x ; TAB2 if x is 25 ; TAB3 increment a ; TAB2 else if x is 50 and a is not 0 ; TAB3 decrement a ; TAB3 increment b ; TAB2 else if x is 50 and a is 0 ; TAB3 print NO ; TAB2 else if x is 100 and a is not 0 and b is not 0 ; TAB3 decrement a ; TAB3 decrement b ; TAB3 increment c ; TAB2 else if x is 100 and a > = 3 and b is 0 ; TAB3 subtract 3 from a ; TAB3 increment c ; TAB2 else ; TAB3 print NO ; TAB1 print YES ;	int main ( ) { int a = 0 , b = 0 , c = 0 ; int n , x ; cin >> n ; while ( n -- ) { cin >> x ; if ( x == 25 ) { a ++ ; } else if ( x == 50 && a != 0 ) { a -- ; b ++ ; } else if ( x == 50 && a == 0 ) { cout << " NO " << endl ; return 0 ; } else if ( x == 100 && a != 0 && b != 0 ) { a -- ; b -- ; c ++ ; } else if ( x == 100 && a >= 3 && b == 0 ) { a -= 3 ; c ++ ; } else { cout << " NO " << endl ; return 0 ; } } cout << " YES " << endl ; return 0 ; }
TAB0 define new constant long long called MAX = 1e5 + 5 ; TAB0 new constant long long MOD = 1e9 + 7 ; TAB0 new long long constant inf = 1e12 + 5 ; TAB1 create long long variable with name n ; TAB1 read standard input to n ; TAB1 declare long long variable with name cur with value 0 ; TAB1 for i = 0 to n exclusive ; TAB2 create long longs a and k ; TAB2 read input to k and a ; TAB2 create long long variable tmp = 4 ; TAB2 while tmp < a ; TAB3 multiply tmp by 4 ; TAB3 increment k by one ; TAB2 assign the new value = max of cur and k to cur ; TAB1 print cur + 1 ;	const long long MAX = 1e5 + 5 ; const long long MOD = 1e9 + 7 ; const long long inf = 1e12 + 5 ; int main ( ) { long long n ; cin >> n ; long long cur = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long long a , k ; cin >> k >> a ; long long tmp = 4 ; while ( tmp < a ) { tmp *= 4 ; k ++ ; } cur = max ( cur , k ) ; } cout << cur + 1 << endl ; return 0 ; }
TAB0 v = vector of string ; TAB0 n = long long ; TAB0 is = 200 array of bool ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 e = string ; TAB2 read e ; TAB2 for k = 0 to ( cast to long long ) e . size ( ) exclusive ; TAB3 if ( e [ k ] > = A and e [ k ] < = Z ) , e [ k ] = e [ k ] - A + a ; TAB2 append e in v ; TAB1 s = string ; TAB1 read s ; TAB1 r = string with r = s ; TAB1 for k = 0 to ( cast to long long ) r . size ( ) exclusive ; TAB2 if ( r [ k ] > = A and r [ k ] < = Z ) , r [ k ] = r [ k ] - A + a ; TAB1 for i = 0 to ( cast to long long ) s . size ( ) exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if ( i + ( cast to long long ) v [ j ] . size ( ) < = ( cast to long long ) s . size ( ) ) ; TAB4 if ( r . substr ( i , ( cast to long long ) v [ j ] . size ( ) ) is v [ j ] ) ; TAB5 for k = i to i + ( cast to long long ) v [ j ] . size ( ) exclusive ; TAB1 g = character ; TAB1 read g ; TAB1 for i = 0 to ( cast to long long ) s . size ( ) exclusive ; TAB2 if ( is [ i ] ) ; TAB3 if s [ i ] > = A and s [ i ] < = Z ; TAB4 if s [ i ] is g - a + A ; TAB5 if ( g is not a ) ; TAB6 s [ i ] = A ; TAB5 else ; TAB6 s [ i ] = B ; TAB4 else ; TAB5 s [ i ] = g - a + A ; TAB3 else ; TAB4 if ( s [ i ] is g ) ; TAB5 if g is not a ; TAB6 s [ i ] = a ; TAB5 else ; TAB6 s [ i ] = b ; TAB4 else ; TAB5 s [ i ] = g ; TAB1 print s ;	vector < string > v ; long long n ; bool is [ 200 ] ; int main ( ) { cin >> n ; for ( long long i = 0 ; i < n ; i ++ ) { string e ; cin >> e ; for ( long long k = 0 ; k < ( long long ) e . size ( ) ; k ++ ) { if ( e [ k ] >= ' A ' && e [ k ] <= ' Z ' ) e [ k ] = e [ k ] - ' A ' + ' a ' ; } v . push_back ( e ) ; } string s ; cin >> s ; string r = s ; for ( long long k = 0 ; k < ( long long ) r . size ( ) ; k ++ ) { if ( r [ k ] >= ' A ' && r [ k ] <= ' Z ' ) r [ k ] = r [ k ] - ' A ' + ' a ' ; } for ( long long i = 0 ; i < ( long long ) s . size ( ) ; i ++ ) { for ( long long j = 0 ; j < n ; j ++ ) { if ( i + ( long long ) v [ j ] . size ( ) <= ( long long ) s . size ( ) ) { if ( r . substr ( i , ( long long ) v [ j ] . size ( ) ) == v [ j ] ) { for ( long long k = i ; k < i + ( long long ) v [ j ] . size ( ) ; k ++ ) { is [ k ] = true ; } } } } } char g ; cin >> g ; for ( long long i = 0 ; i < ( long long ) s . size ( ) ; i ++ ) { if ( is [ i ] ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) { if ( s [ i ] == g - ' a ' + ' A ' ) { if ( g != ' a ' ) s [ i ] = ' A ' ; else s [ i ] = ' B ' ; } else s [ i ] = g - ' a ' + ' A ' ; } else { if ( s [ i ] == g ) { if ( g != ' a ' ) s [ i ] = ' a ' ; else s [ i ] = ' b ' ; } else s [ i ] = g ; } } } cout << s << endl ; }
TAB0 make string vector word ; TAB0 make integer vector be and af ; TAB0 create int set g ; TAB0 declare sf taking in string s and returning int ; TAB1 make int n = s . size ( ) ; TAB1 if n is greater than or equal to 4 and s . substr ( n - 4 , 4 ) is equal to " lios " ; TAB1 else if n is greater than 5 and s . substr ( n - 5 , 5 ) is equal to " liala " ; TAB2 return 1 ; TAB1 else if n is greater than or equal to 3 and s . substr ( n - 3 , 3 ) is equal to " etr " ; TAB2 return 2 ; TAB1 else if n is greater than or equal to 4 and s . substr ( n - 4 , 4 ) is equal to " etra " ; TAB2 return 3 ; TAB1 else if n is greater than or equal to 6 and s . substr ( n - 6 , 6 ) equals " initis " ; TAB2 return 4 ; TAB1 else if n is greater than or equal to 6 and s . substr ( n - 6 , 6 ) equals " inites " ; TAB2 return 5 ; TAB1 else do ; TAB2 return - 1 ; TAB1 make string s ; TAB1 read s and while it ' s truthy , append s to word ; TAB1 for i = 0 to size of word exclusive ; TAB2 make integer j = sf ( word [ i ] ) ; TAB2 if j is equal to - 1 ; TAB3 print " NO " ; TAB2 insert j % 2 to g ; TAB2 append j / 2 to be ; TAB2 append j / 2 to af ; TAB1 if size of word is 1 ; TAB2 print " YES " ; TAB1 sort af ; TAB1 if g . size ( ) is not 1 ; TAB2 print " NO " ; TAB1 make integer cnt = 0 ; TAB1 for i = 0 to af . size ( ) exclusive ; TAB2 if af [ i ] is not equal to be [ i ] ; TAB3 show " NO " ; TAB2 if af [ i ] is equal to 1 , increment cnt ; TAB1 if cnt is equal to 0 and size of word is not equal to 1 ; TAB2 show " NO " ; TAB1 else if cnt is not 1 and cnt is not 0 ; TAB2 display " NO " ; TAB1 output " YES " ;	vector < string > word ; vector < int > be , af ; set < int > g ; int sf ( string s ) { int n = s . size ( ) ; if ( n >= 4 && s . substr ( n - 4 , 4 ) == " lios " ) { return 0 ; } else if ( n >= 5 && s . substr ( n - 5 , 5 ) == " liala " ) { return 1 ; } else if ( n >= 3 && s . substr ( n - 3 , 3 ) == " etr " ) { return 2 ; } else if ( n >= 4 && s . substr ( n - 4 , 4 ) == " etra " ) { return 3 ; } else if ( n >= 6 && s . substr ( n - 6 , 6 ) == " initis " ) { return 4 ; } else if ( n >= 6 && s . substr ( n - 6 , 6 ) == " inites " ) { return 5 ; } else { return - 1 ; } } int main ( ) { string s ; while ( cin >> s ) { word . push_back ( s ) ; } for ( int i = 0 ; i < word . size ( ) ; i ++ ) { int j = sf ( word [ i ] ) ; if ( j == - 1 ) { cout << " NO " << endl ; return 0 ; } g . insert ( j % 2 ) ; be . push_back ( j / 2 ) ; af . push_back ( j / 2 ) ; } if ( word . size ( ) == 1 ) { cout << " YES " << endl ; return 0 ; } sort ( af . begin ( ) , af . end ( ) ) ; if ( g . size ( ) != 1 ) { cout << " NO " << endl ; return 0 ; } int cnt = 0 ; for ( int i = 0 ; i < af . size ( ) ; i ++ ) { if ( af [ i ] != be [ i ] ) { cout << " NO " << endl ; return 0 ; } if ( af [ i ] == 1 ) { cnt ++ ; } } if ( cnt == 0 && word . size ( ) != 1 ) { cout << " NO " << endl ; return 0 ; } else if ( cnt != 1 && cnt != 0 ) { cout << " NO " << endl ; return 0 ; } cout << " YES " << endl ; return 0 ; }
TAB1 declare new string called time ; TAB1 read variable time from the input ; TAB1 declare vector of integers t with 4 elements ; TAB1 assign time [ 0 ] - ' 0 ' to t [ 0 ] ; TAB1 set t [ 1 ] to time [ 1 ] - ' 0 ' ; TAB1 assign time [ 3 ] - ' 0 ' to t [ 2 ] ; TAB1 set t [ 3 ] to time [ 4 ] - ' 0 ' ; TAB1 count is a new integer variable with value 0 ; TAB1 in the infinite loop ; TAB2 break if t [ 0 ] = t [ 3 ] and t [ 1 ] is equal to t [ 2 ] ; TAB2 increase t [ 3 ] by 1 ; TAB2 if t [ 3 ] is greater than 9 ; TAB3 add 1 to t [ 2 ] ; TAB3 assign 0 to t [ 3 ] ; TAB3 if t [ 2 ] is greater than 5 ; TAB4 change t [ 1 ] to t [ 1 ] + 1 ; TAB4 change t [ 2 ] to 0 ; TAB4 change the value of t [ 3 ] to 0 ; TAB4 if t [ 0 ] ! = 2 and t [ 1 ] > 9 ; TAB5 change t [ 0 ] to t [ 0 ] + 1 ; TAB5 change t [ 1 ] to 0 ; TAB5 assign 0 to t [ 2 ] ; TAB5 set t [ 3 ] to 0 ; TAB4 if t [ 0 ] = 2 and t [ 1 ] > 3 ; TAB5 assign the new value = 0 to t [ 0 ] ; TAB5 set t [ 1 ] to 0 ; TAB5 set t [ 2 ] to 0 ; TAB5 change t [ 3 ] to 0 ; TAB2 add 1 to count ; TAB1 print count and " \ n " ;	int main ( ) { string time ; cin >> time ; vector < int > t ( 4 ) ; t [ 0 ] = time [ 0 ] - ' 0 ' ; t [ 1 ] = time [ 1 ] - ' 0 ' ; t [ 2 ] = time [ 3 ] - ' 0 ' ; t [ 3 ] = time [ 4 ] - ' 0 ' ; int count = 0 ; while ( true ) { if ( t [ 0 ] == t [ 3 ] && t [ 1 ] == t [ 2 ] ) { break ; } t [ 3 ] += 1 ; if ( t [ 3 ] > 9 ) { t [ 2 ] += 1 ; t [ 3 ] = 0 ; if ( t [ 2 ] > 5 ) { t [ 1 ] += 1 ; t [ 2 ] = 0 ; t [ 3 ] = 0 ; if ( t [ 0 ] != 2 && t [ 1 ] > 9 ) { t [ 0 ] += 1 ; t [ 1 ] = 0 ; t [ 2 ] = 0 ; t [ 3 ] = 0 ; } if ( t [ 0 ] == 2 && t [ 1 ] > 3 ) { t [ 0 ] = 0 ; t [ 1 ] = 0 ; t [ 2 ] = 0 ; t [ 3 ] = 0 ; } } } ++ count ; } cout << count << " \n " ; return 0 ; }
TAB1 create ints a , b and c = 0 ; TAB1 declare integers n and x ; TAB1 read input to n ; TAB1 while n ! = 0 , decrement it and continue the loop ; TAB2 read x from the input ; TAB2 if x = 25 ; TAB3 increment a ; TAB2 else if x = 50 and a ! = 0 ; TAB3 decrement a ; TAB3 increment b by one ; TAB2 else if x is equal to 50 and a = 0 ; TAB3 print " NO " to the standard output ; TAB2 else if x = 100 and a ! = 0 and b ! = 0 ; TAB3 decrement a ; TAB3 decrement b ; TAB3 increment c ; TAB2 else if x = 100 and a > = 3 and b = 0 ; TAB3 change a to a - 3 ; TAB3 increment c by one ; TAB2 else ; TAB3 print " NO " to the standard output ; TAB1 print " YES " to the output ;	int main ( ) { int a = 0 , b = 0 , c = 0 ; int n , x ; cin >> n ; while ( n -- ) { cin >> x ; if ( x == 25 ) { a ++ ; } else if ( x == 50 && a != 0 ) { a -- ; b ++ ; } else if ( x == 50 && a == 0 ) { cout << " NO " << endl ; return 0 ; } else if ( x == 100 && a != 0 && b != 0 ) { a -- ; b -- ; c ++ ; } else if ( x == 100 && a >= 3 && b == 0 ) { a -= 3 ; c ++ ; } else { cout << " NO " << endl ; return 0 ; } } cout << " YES " << endl ; return 0 ; }
TAB0 N = - 1 ; TAB1 s = string ; TAB1 read s ; TAB1 n = size of s ; TAB1 ans = - 1 ; TAB1 for tam1 = 1 to n inclusive ; TAB2 for tam2 = 1 to n - tam1 - 1 exclusive ; TAB3 tam3 = n - tam1 - tam2 ; TAB3 id = 0 ; TAB3 cur , soma = 0 ; TAB3 for i = 0 to tam1 exclusive ; TAB4 if tam1 is not 1 and s [ id ] is ' 0 ' and cur is 0 goto fim ; TAB4 cur = 10 * cur + ( s [ id ] - ' 0 ' ) , increment id ; TAB4 if cur > 1000000 goto fim ; TAB3 add cur to soma ; TAB3 cur = 0 ; TAB3 for i = 0 to tam2 exclusive ; TAB4 if tam2 is not 1 and s [ id ] is ' 0 ' and cur is 0 goto fim ; TAB4 cur = 10 * cur + ( s [ id ] - ' 0 ' ) , increment id ; TAB4 if cur > 1000000 goto fim ; TAB3 add cur to soma ; TAB3 cur = 0 ; TAB3 for i = 0 to tam3 exclusive ; TAB4 if tam3 is not 1 and s [ id ] is ' 0 ' and cur is 0 goto fim ; TAB4 cur = 10 * cur + ( s [ id ] - ' 0 ' ) , increment id ; TAB4 if cur > 1000000 goto fim ; TAB3 add cur to soma ; TAB3 cur = 0 ; TAB3 ans = max ( ans , soma ) ; TAB2 label fim ; TAB3 continue ; TAB1 print ans ;	const int N = - 1 ; int main ( ) { string s ; cin >> s ; int n = s . size ( ) ; int ans = - 1 ; for ( int tam1 = 1 ; tam1 <= n ; tam1 ++ ) { for ( int tam2 = 1 ; tam2 <= n - tam1 - 1 ; tam2 ++ ) { int tam3 = n - tam1 - tam2 ; int id = 0 ; int cur = 0 , soma = 0 ; for ( int i = 0 ; i < tam1 ; i ++ ) { if ( tam1 != 1 and s [ id ] == ' 0 ' and cur == 0 ) goto fim ; cur = 10 * cur + ( s [ id ++ ] - ' 0 ' ) ; if ( cur > 1000000 ) goto fim ; } soma += cur ; cur = 0 ; for ( int i = 0 ; i < tam2 ; i ++ ) { if ( tam2 != 1 and s [ id ] == ' 0 ' and cur == 0 ) goto fim ; cur = 10 * cur + ( s [ id ++ ] - ' 0 ' ) ; if ( cur > 1000000 ) goto fim ; } soma += cur ; cur = 0 ; for ( int i = 0 ; i < tam3 ; i ++ ) { if ( tam3 != 1 and s [ id ] == ' 0 ' and cur == 0 ) goto fim ; cur = 10 * cur + ( s [ id ++ ] - ' 0 ' ) ; if ( cur > 1000000 ) goto fim ; } soma += cur ; cur = 0 ; ans = max ( ans , soma ) ; fim : continue ; } } cout << ans << endl ; return 0 ; }
TAB0 N = const int with N = 110 * 2 ; TAB1 n , k , i = int ; TAB1 a = int array of size N ; TAB1 read n then k ; TAB1 len = int with len = 2 * n + 1 ; TAB1 cnt = int with cnt = 0 ; TAB1 for i = 1 to len inclusive read a [ i ] ; TAB1 for i = 1 to len inclusive ; TAB2 if i is even ; TAB3 if a [ i ] - 1 is greater than a [ i - 1 ] and a [ i + 1 ] ; TAB4 decrement a [ i ] ; TAB4 increment cnt ; TAB2 if cnt is k break ; TAB1 for i = 1 to len print a [ i ] then " " ; TAB1 print a [ len ] ;	const int N = 110 * 2 ; int main ( ) { int n , k , i ; int a [ N ] ; cin >> n >> k ; int len = 2 * n + 1 ; int cnt = 0 ; for ( i = 1 ; i <= len ; i ++ ) { cin >> a [ i ] ; } for ( i = 1 ; i <= len ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] - 1 > a [ i - 1 ] && a [ i ] - 1 > a [ i + 1 ] ) { a [ i ] -- ; cnt ++ ; } } if ( cnt == k ) break ; } for ( i = 1 ; i < len ; i ++ ) cout << a [ i ] << "   " ; cout << a [ len ] << endl ; return 0 ; }
TAB0 declare character array s size 1000 ; TAB1 while read s is true ; TAB2 declare integers a , b , c ; TAB2 declare integer len = string length of s ; TAB2 declare integer cnt = 0 ; TAB2 for i = 0 to len exclusive ; TAB3 if s [ i ] is ' + ' ; TAB4 let a be cnt ; TAB4 let cnt be 0 ; TAB3 else if s [ i ] is ' = ' ; TAB4 let b be cnt ; TAB4 let c be len - a - b - 2 ; TAB3 else ; TAB4 increment cnt ; TAB2 if a + b is c ; TAB3 for i = 0 to a exclusive , print " | " ; TAB3 print " + " ; TAB3 for i = 0 to b exclusive , print " | " ; TAB3 print " = " ; TAB3 for i = 0 to c exclusive , print " | " ; TAB3 print newline ; TAB2 else if a + 1 + b is c - 1 and c is greater than 1 ; TAB3 let a be a + 1 ; TAB3 let c be c - 1 ; TAB3 for i = 0 to a exclusive , print " | " ; TAB3 print " + " ; TAB3 for i = 0 to b exclusive , print " | " ; TAB3 print " = " ; TAB3 for i = 0 to c exclusive , print " | " ; TAB3 print newline ; TAB2 else if a - 1 + b is c + 1 and a is greater than 1 ; TAB3 let a be a - 1 ; TAB3 let c be c + 1 ; TAB3 for i = 0 to a exclusive , print " | " ; TAB3 print " + " ; TAB3 for i = 0 to b exclusive , print " | " ; TAB3 print " = " ; TAB3 for i = 0 to c exclusive , print " | " ; TAB3 print newline ; TAB2 else if a + b - 1 is c + 1 and b is greater than 1 ; TAB3 let b be b - 1 ; TAB3 let c be c + 1 ; TAB3 for i = 0 to a exclusive , print " | " ; TAB3 print " + " ; TAB3 for i = 0 to b exclusive , print " | " ; TAB3 print " = " ; TAB3 for i = 0 to c exclusive , print " | " ; TAB3 print newline ; TAB2 else ; TAB3 print " Impossible " and newline ;	char s [ 1000 ] ; int main ( ) { while ( cin >> s ) { int a , b , c ; int len = strlen ( s ) ; int cnt = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == ' + ' ) { a = cnt ; cnt = 0 ; } else if ( s [ i ] == ' = ' ) { b = cnt ; c = len - a - b - 2 ; } else cnt ++ ; } if ( a + b == c ) { for ( int i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; } else if ( a + 1 + b == c - 1 && c > 1 ) { a = a + 1 ; c = c - 1 ; for ( int i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; } else if ( a - 1 + b == c + 1 && a > 1 ) { a = a - 1 ; c = c + 1 ; for ( int i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; } else if ( a + b - 1 == c + 1 && b > 1 ) { b = b - 1 ; c = c + 1 ; for ( int i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; } else cout << " Impossible " << endl ; } return 0 ; }
TAB0 f is a int function with int argument n ; TAB1 declare integer s ; TAB1 assign the new value = n / 10 + ( n % 10 ) * 10 to s ; TAB1 return s ; TAB1 declare new character c ; TAB1 create ints n , m , x , y , z and d ; TAB1 read n , c and m from the input ; TAB1 change x to the result of f ( n ) ; TAB1 assign the new value = f ( m ) to y ; TAB1 if n > = 6 and n < = 9 ; TAB2 change the value of d to ( 9 - n ) * 60 + 60 - m + 1 ; TAB1 else if n > = 16 and n < = 19 ; TAB2 change d to ( 19 - n ) * 60 + 60 - m + 2 ; TAB1 else ; TAB2 if x > = m ; TAB3 set d to x - m ; TAB2 else if n is equal to 5 ; TAB3 change d to 4 * 60 + 60 - m + 1 ; TAB2 else if n is equal to 15 ; TAB3 set d to 4 * 60 + 60 - m + 2 ; TAB2 else if n is equal to 23 ; TAB3 change the value of d to 60 - m ; TAB2 else ; TAB3 set z to f ( n + 1 ) ; TAB3 set d to z + 60 - m ; TAB1 print d to the standard output ;	int f ( int n ) { int s ; s = n / 10 + ( n % 10 ) * 10 ; return s ; } int main ( ) { char c ; int n , m , x , y , z , d ; cin >> n >> c >> m ; x = f ( n ) ; y = f ( m ) ; if ( n >= 6 && n <= 9 ) { d = ( 9 - n ) * 60 + 60 - m + 1 ; } else if ( n >= 16 && n <= 19 ) { d = ( 19 - n ) * 60 + 60 - m + 2 ; } else { if ( x >= m ) d = x - m ; else if ( n == 5 ) { d = 4 * 60 + 60 - m + 1 ; } else if ( n == 15 ) { d = 4 * 60 + 60 - m + 2 ; } else if ( n == 23 ) { d = 60 - m ; } else { z = f ( n + 1 ) ; d = z + 60 - m ; } } cout << d << endl ; }
TAB1 create integer n ; TAB1 read n ; TAB1 create integer array a with size 100005 ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 create integer count with count = 1 ; TAB1 create integer neg with neg = 0 ; TAB1 create integer b with b size 10005 ; TAB1 create integer i ; TAB1 set b [ 0 ] to 1 ; TAB1 for i = 1 to n inclusive ; TAB2 if a [ i ] is less than 0 , increment neg ; TAB2 if neg is 3 ; TAB3 set b [ increment count ] to i ; TAB3 set neg to 1 ; TAB1 print count print newline ; TAB1 for j = 1 to count exclusive , print b [ j ] - b [ j - 1 ] print " " ; TAB1 print n + 1 - b [ count - 1 ] print newline ;	int main ( ) { int n ; cin >> n ; int a [ 100005 ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; int count = 1 ; int neg = 0 ; int b [ 10005 ] ; int i ; b [ 0 ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { if ( a [ i ] < 0 ) neg ++ ; if ( neg == 3 ) { b [ count ++ ] = i ; neg = 1 ; } } cout << count << endl ; for ( int j = 1 ; j < count ; j ++ ) { cout << b [ j ] - b [ j - 1 ] << "   " ; } cout << n + 1 - b [ count - 1 ] << endl ; }
TAB0 create new constant long long called MAX with value 1000000007 ; TAB1 create long long variable with name a ; TAB1 read from the input to a ; TAB1 s is a new string ; TAB1 read variable s from the input ; TAB1 create a map from long longs to long longs called x ; TAB1 all is a new long long with value 0 ; TAB1 for integer i = 0 to length of s exclusive incrementing i ; TAB2 declare long long variable with name tot = 0 ; TAB2 for j = i to length of s exclusive ; TAB3 increase tot by ( s [ j ] - 48 ) ; TAB3 increment x [ tot ] ; TAB3 increment all ; TAB1 t is a new long long variable = 0 ; TAB1 start for loop from i = 0 to length of s exclusive ; TAB2 create long long variable with name tot with value 0 ; TAB2 start for loop from j = i to length of s exclusive incrementing j ; TAB3 increase tot by s [ j ] - 48 ; TAB3 if tot ! = 0 and a modulo tot = 0 , add x [ a / tot ] to t ; TAB3 if tot = 0 and a is equal to 0 , change t to t + all ; TAB1 print t ;	const long long MAX = 1000000007 ; int main ( ) { long long a ; cin >> a ; string s ; cin >> s ; map < long long , long long > x ; long long all = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { long long tot = 0 ; for ( int j = i ; j < s . length ( ) ; j ++ ) { tot += ( s [ j ] - 48 ) ; x [ tot ] ++ ; all ++ ; } } long long t = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { long long tot = 0 ; for ( int j = i ; j < s . length ( ) ; j ++ ) { tot += ( s [ j ] - 48 ) ; if ( tot != 0 && a % tot == 0 ) { t += x [ a / tot ] ; } if ( tot == 0 && a == 0 ) { t += all ; } } } cout << t << endl ; }
TAB1 declare string a ; TAB1 read a ; TAB1 declare integers count_a = 0 , count_c = 0 , count_b = 0 ; TAB1 for i = 0 to length of a exclusive ; TAB2 if a [ i ] is ' a ' ; TAB3 increment count_a ; TAB2 else if a [ i ] is ' b ' ; TAB3 increment count_b ; TAB2 else if a [ i ] is ' c ' ; TAB3 increment count_c ; TAB1 if count_a is not count_c and count_b is not count_c ; TAB2 print " NO " and newline ; TAB1 else if count_a is 0 or count__b is 0 or count_c is 0 ; TAB2 print " NO " and newline ; TAB1 else ; TAB2 for i = 0 to count_a exclusive ; TAB3 if a [ i ] is not ' a ' ; TAB4 print " NO " and newline ; TAB2 for i = count_a to count_a + count_b exclusive ; TAB3 if a [ i ] is not ' b ' ; TAB4 print " NO " and newline ; TAB2 print " YES \ n " ;	int main ( ) { string a ; cin >> a ; int count_a = 0 , count_c = 0 , count_b = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( a [ i ] == ' a ' ) count_a ++ ; else if ( a [ i ] == ' b ' ) count_b ++ ; else if ( a [ i ] == ' c ' ) count_c ++ ; } if ( count_a != count_c && count_b != count_c ) cout << " NO " << endl ; else if ( count_a == 0 || count_b == 0 || count_c == 0 ) cout << " NO " << endl ; else { for ( int i = 0 ; i < count_a ; i ++ ) { if ( a [ i ] != ' a ' ) { cout << " NO " << endl ; return 0 ; } } for ( int i = count_a ; i < count_a + count_b ; i ++ ) { if ( a [ i ] != ' b ' ) { cout << " NO " << endl ; return 0 ; } } cout << " YES\n " ; } }
TAB1 let n , k be integers ; TAB1 read n , k ; TAB2 for i = 0 to n - 1 inclusive ; TAB3 if i is greater than k - 1 ; TAB4 print ( char ) ( i modulo k + a ) ; TAB3 else do the following ; TAB4 print ( char ) ( i + a ) ; TAB2 print newline ;	int main ( ) { int n , k ; while ( cin >> n >> k ) { for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( i > k - 1 ) cout << ( char ) ( i % k + ' a ' ) ; else cout << ( char ) ( i + ' a ' ) ; } cout << endl ; } return 0 ; }
TAB0 create char array a of 1005 elements ; TAB0 in function judge returning int , taking int c and int n ; TAB1 create int flag = n - 1 ; TAB1 for i = c to n exclusive ; TAB2 if a [ i ] does not equal a [ flag - i + c ] , return 0 ; TAB1 return 1 ; TAB1 while reading a is not interrupted ; TAB2 create int n ; TAB2 read n ; TAB2 create int s = length of a ; TAB2 if n greater than s ; TAB3 print " NO " ; TAB3 continue ; TAB2 if s mod n not equals 0 ; TAB3 print " NO " ; TAB3 continue ; TAB2 create int pl = s / n ; TAB2 create int ans = 0 ; TAB2 create int h = 0 ; TAB2 for i = 0 to s exclusive ; TAB3 increase h by pl ; TAB3 create int x = judge ( i , h ) ; TAB3 if not x ; TAB4 ans = 1 ; TAB4 break ; TAB3 i = h ; TAB2 if ans ; TAB3 print " NO " ; TAB2 else ; TAB3 print " YES " ;	char a [ 1005 ] ; int judge ( int c , int n ) { int flag = n - 1 ; for ( int i = c ; i < n ; i ++ ) { if ( a [ i ] != a [ flag - i + c ] ) { return 0 ; } } return 1 ; } int main ( ) { while ( cin >> a ) { int n ; cin >> n ; int s = strlen ( a ) ; if ( n > s ) { cout << " NO " << endl ; continue ; } if ( s % n != 0 ) { cout << " NO " << endl ; continue ; } int pl = s / n ; int ans = 0 ; int h = 0 ; for ( int i = 0 ; i < s ; ) { h += pl ; int x = judge ( i , h ) ; if ( ! x ) { ans = 1 ; break ; } i = h ; } if ( ans ) { cout << " NO " << endl ; } else { cout << " YES " << endl ; } } return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 let sum be a integer with value 0 ; TAB1 for i = 0 to n exclusive ; TAB2 let v be a integer ; TAB2 read v ; TAB2 increment sum by v ; TAB1 if sum is equal to n - 1 + n is equal to 1 ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 print NO and newline ;	int main ( ) { int n ; cin >> n ; int sum = 0 ; for ( int i = 0 ; i < ( n ) ; i ++ ) { int v ; cin >> v ; sum += v ; } if ( sum == ( n - 1 + ( n == 1 ) ) ) cout << ( " YES " ) << ' \n ' ; else cout << ( " NO " ) << ' \n ' ; return 0 ; }
TAB0 maxn = 15000001 ; TAB0 vis = array of maxn bool ; TAB0 cnt = array of maxn int ; TAB1 gcd = 0 ; TAB1 a , n = int ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read a ; TAB2 increment cnt [ a ] ; TAB2 if i is 1 ; TAB3 gcd = a ; TAB2 else ; TAB3 gcd = __gcd ( gcd , a ) ; TAB1 ans = 0 ; TAB1 for i = gcd + 1 to maxn exclusive ; TAB2 if not vis [ i ] ; TAB3 tmp = 0 ; TAB3 for j = i to maxn by i ; TAB4 vis [ j ] = true ; TAB4 add cnt [ j ] to tmp ; TAB3 ans = max ( ans , tmp ) ; TAB1 if ans is 0 ; TAB2 print - 1 ; TAB1 else ; TAB2 print n - ans ;	const int maxn = 1.5e7 + 1 ; bool vis [ maxn ] ; int cnt [ maxn ] ; int main ( ) { int gcd = 0 ; int a , n ; cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> a ; cnt [ a ] ++ ; if ( i == 1 ) gcd = a ; else { gcd = __gcd ( gcd , a ) ; } } int ans = 0 ; for ( int i = gcd + 1 ; i < maxn ; ++ i ) { if ( ! vis [ i ] ) { int tmp = 0 ; for ( int j = i ; j < maxn ; j += i ) { vis [ j ] = true ; tmp += cnt [ j ] ; } ans = max ( ans , tmp ) ; } } if ( ans == 0 ) { cout << - 1 << endl ; } else cout << n - ans << endl ; return 0 ; }
TAB0 create integer n ; TAB0 declare solve with integers x , y as arguments , returning integer vector ; TAB1 create integer vector ans initialized with 4 ; TAB1 if x is 0 ; TAB2 set ans [ 0 ] to y ; TAB2 set ans [ 1 ] to n - y ; TAB2 set ans [ 2 ] to ans [ 0 ] + n ; TAB2 set ans [ 3 ] to ans [ 1 ] + n ; TAB1 else if y is 0 ; TAB2 set ans [ 0 ] to x ; TAB2 set ans [ 1 ] to ans [ 0 ] + n ; TAB2 set ans [ 2 ] to n - x ; TAB2 set ans [ 3 ] to ans [ 2 ] + n ; TAB1 else if x is n ; TAB2 set ans [ 2 ] to y ; TAB2 set ans [ 3 ] to n - y ; TAB2 set ans [ 1 ] to ans [ 3 ] + n ; TAB2 set ans [ 0 ] to ans [ 2 ] + n ; TAB1 else ; TAB2 set ans [ 1 ] to x ; TAB2 set ans [ 3 ] to n - x ; TAB2 set ans [ 0 ] to ans [ 1 ] + n ; TAB2 set ans [ 2 ] to ans [ 3 ] + n ; TAB1 return ans from function ; TAB1 create integers x1 , y1 , x2 , y2 ; TAB1 read n read x1 read y1 read x2 read y2 ; TAB1 if ( x1 is 0 and x2 is 0 ) or ( x1 is n and x2 is n ) ; TAB2 print absolute value of ( y1 - y2 ) print " \ n " ; TAB1 else if ( y1 is 0 and y2 is 0 ) or ( y1 is n and y2 is n ) ; TAB2 print absolute value of ( x1 - x2 ) print " \ n " ; TAB1 else ; TAB2 create integer vector A with A = result of run solve with x1 , y1 as arguments , set B to result of run solve with x2 , y2 as arguments ; TAB2 create integer mn with mn = 1e9 ; TAB2 for i = 0 to 4 exclusive , set mn to minimum of ( mn and A [ i ] + B [ i ] ) ; TAB2 print mn print " \ n " ;	int n ; vector < int > solve ( int x , int y ) { vector < int > ans ( 4 ) ; if ( x == 0 ) { ans [ 0 ] = y ; ans [ 1 ] = n - y ; ans [ 2 ] = ans [ 0 ] + n ; ans [ 3 ] = ans [ 1 ] + n ; } else if ( y == 0 ) { ans [ 0 ] = x ; ans [ 1 ] = ans [ 0 ] + n ; ans [ 2 ] = n - x ; ans [ 3 ] = ans [ 2 ] + n ; } else if ( x == n ) { ans [ 2 ] = y ; ans [ 3 ] = n - y ; ans [ 1 ] = ans [ 3 ] + n ; ans [ 0 ] = ans [ 2 ] + n ; } else { ans [ 1 ] = x ; ans [ 3 ] = n - x ; ans [ 0 ] = ans [ 1 ] + n ; ans [ 2 ] = ans [ 3 ] + n ; } return ans ; } int main ( ) { int x1 , y1 , x2 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; if ( ( x1 == 0 && x2 == 0 ) || ( x1 == n && x2 == n ) ) cout << abs ( y1 - y2 ) << " \n " ; else if ( ( y1 == 0 && y2 == 0 ) || ( y1 == n && y2 == n ) ) cout << abs ( x1 - x2 ) << " \n " ; else { vector < int > A = solve ( x1 , y1 ) , B = solve ( x2 , y2 ) ; int mn = 1e9 ; for ( int i = 0 ; i < 4 ; ++ i ) mn = min ( mn , A [ i ] + B [ i ] ) ; cout << mn << " \n " ; } return 0 ; }
TAB0 create new int n and int arrays visited with size 150 and matriz with size 150 by 150 ; TAB0 function DFS with int argument u ; TAB1 change the value of visited [ u ] to 1 ; TAB1 for p from 1 to n inclusive ; TAB2 if visited [ p ] is false and matriz [ u ] [ p ] is true , call DFS of p ; TAB1 declare boolean alguienSabe = false ; TAB1 let m , a , k and cnt be integers with cnt = 0 ; lenguas is an array of integers with size 150 by 150 ; TAB1 in a for loop , change i from 1 to 100 inclusive ; TAB2 assign the value of 0 to visited [ i ] ; TAB2 for integer j = 1 to 100 inclusive ; TAB3 assign 0 to matriz [ i ] [ j ] ; TAB3 change the value of lenguas [ i ] [ j ] to 0 ; TAB1 read standard input to n and m ; TAB1 for i = 1 to n inclusive ; TAB2 read a ; TAB2 for j from 1 to a inclusive incrementing j ; TAB3 read from the input to k ; TAB3 if alguienSabe is false and k is true , change the value of alguienSabe to true ; TAB3 if k ! = 0 , assign 1 to lenguas [ i ] [ k ] ; TAB3 if i is greater than 1 ; TAB4 in a for loop , change z from 1 to i exclusive ; TAB5 if lenguas [ z ] [ k ] is true , change the values of matriz [ i ] [ z ] and matriz [ z ] [ i ] to 1 ; TAB1 start for loop from i = 1 to n inclusive incrementing i ; TAB2 if visited [ i ] is false ; TAB3 increment cnt by one ; TAB3 call DFS ( i ) ; TAB1 if alguienSabe is true ; TAB2 print cnt - 1 to the standard output ; TAB1 else ; TAB2 print cnt ;	int n , matriz [ 150 ] [ 150 ] , visited [ 150 ] ; void DFS ( int u ) { visited [ u ] = 1 ; for ( int p = 1 ; p <= n ; p ++ ) if ( ! visited [ p ] && matriz [ u ] [ p ] ) DFS ( p ) ; } int main ( ) { bool alguienSabe = false ; int m , a , k , cnt = 0 , lenguas [ 150 ] [ 150 ] ; for ( int i = 1 ; i <= 100 ; i ++ ) { visited [ i ] = 0 ; for ( int j = 1 ; j <= 100 ; j ++ ) { matriz [ i ] [ j ] = 0 ; lenguas [ i ] [ j ] = 0 ; } } cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a ; for ( int j = 1 ; j <= a ; j ++ ) { cin >> k ; if ( ! alguienSabe && k ) alguienSabe = true ; if ( k != 0 ) lenguas [ i ] [ k ] = 1 ; if ( i > 1 ) { for ( int z = 1 ; z < i ; z ++ ) if ( lenguas [ z ] [ k ] ) matriz [ i ] [ z ] = matriz [ z ] [ i ] = 1 ; } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! visited [ i ] ) { cnt ++ ; DFS ( i ) ; } } if ( alguienSabe ) cout << cnt - 1 << endl ; else cout << cnt << endl ; return 0 ; }
TAB1 create ints n , x , r25 = 0 , and r50 = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read x ; TAB2 if x is equal to 25 , increment r25 ; TAB2 if x is 50 ; TAB3 if r25 is equal to 0 ; TAB4 print " NO \ n " ; TAB3 reduce r25 by 1 ; TAB3 increase r50 by 1 ; TAB2 if x is equal to 100 ; TAB3 if r50 = = 0 ? r25 < 3 : r25 < 1 ; TAB4 print " NO \ n " ; TAB3 if r50 is greater than 0 ; TAB4 reduce r50 by 1 ; TAB4 reduce r25 by 1 ; TAB3 else do ; TAB4 subtract 3 from r25 ; TAB1 print " YES \ n " ;	int main ( ) { int n , x , r25 = 0 , r50 = 0 ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) { cin >> x ; if ( x == 25 ) r25 ++ ; if ( x == 50 ) { if ( r25 == 0 ) { cout << " NO\n " ; return 0 ; } r25 -- ; r50 ++ ; } if ( x == 100 ) { if ( r50 == 0 ? r25 < 3 : r25 < 1 ) { cout << " NO\n " ; return 0 ; } if ( r50 > 0 ) { r50 -- ; r25 -- ; } else { r25 -= 3 ; } } } cout << " YES\n " ; return 0 ; }
TAB1 create int n ; TAB1 sum = 0 ; TAB1 npos = 0 ; TAB1 set nneg = 0 ; TAB1 create int x [ 100 ] [ 2 ] ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to 2 exclusive , read x [ i ] [ j ] ; TAB1 for i = 0 to n exclusive ; TAB2 if x [ i ] [ 0 ] greater than 0 ; TAB3 increment npos ; TAB2 else ; TAB3 add 1 to nneg ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 for j = 1 + 1 to n exclusive ; TAB3 if x [ i ] [ 0 ] > x [ j ] [ 0 ] ; TAB4 create int auxp and auxc ; TAB4 set auxp to x [ i ] [ 0 ] ; TAB4 set x [ i ] [ 0 ] to x [ j ] [ 0 ] ; TAB4 set x [ j ] [ 0 ] = auxp ; TAB4 assign x [ i ] [ 1 ] to auxc ; TAB4 set x [ i ] [ 1 ] = x [ j ] [ 1 ] ; TAB4 assign auxc to x [ j ] [ 1 ] ; TAB1 if npos less than nneg ; TAB2 for i = 0 to 2 * nneg + 1 exclusive , set sum to sum + x [ i ] [ 1 ] ; TAB1 else if npos < nneg ; TAB2 for i = n - 2 * npos + 1 to n exclusive , assign sum + x [ i ] [ 1 ] to sum ; TAB1 else ; TAB2 for i = 0 to n exclusive , set sum = sum + x [ i ] [ 1 ] ; TAB1 print sum ;	int main ( ) { int n ; int sum = 0 ; int npos = 0 ; int nneg = 0 ; int x [ 100 ] [ 2 ] ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { cin >> x [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] [ 0 ] > 0 ) { npos ++ ; } else { nneg ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( x [ i ] [ 0 ] > x [ j ] [ 0 ] ) { int auxp , auxc ; auxp = x [ i ] [ 0 ] ; x [ i ] [ 0 ] = x [ j ] [ 0 ] ; x [ j ] [ 0 ] = auxp ; auxc = x [ i ] [ 1 ] ; x [ i ] [ 1 ] = x [ j ] [ 1 ] ; x [ j ] [ 1 ] = auxc ; } } } if ( npos > nneg ) { for ( int i = 0 ; i < ( 2 * nneg + 1 ) ; i ++ ) { sum = sum + x [ i ] [ 1 ] ; } } else if ( npos < nneg ) { for ( int i = ( n - ( 2 * npos + 1 ) ) ; i < n ; i ++ ) { sum = sum + x [ i ] [ 1 ] ; } } else { for ( int i = 0 ; i < n ; i ++ ) { sum = sum + x [ i ] [ 1 ] ; } } cout << sum << endl ; return 0 ; }
TAB1 declare doubles a , b , c and d ; TAB1 read variables a , b , c and d from the input ; TAB1 if ( a - b ) is equal to ( b - c ) and ( b - c ) is equal to ( c - d ) ; TAB2 print d + ( b - a ) to the standard output ; TAB1 else ; TAB2 if ( b / a ) = ( c / b ) and ( c / b ) is equal to ( d / c ) ; TAB3 create new double variable k = d * ( b / a ) ; TAB3 if k = k casted to int ; TAB4 print k ; TAB3 else ; TAB4 print 42 ; TAB2 else ; TAB3 print 42 ;	int main ( ) { double a , b , c , d ; cin >> a >> b >> c >> d ; if ( ( a - b ) == ( b - c ) && ( b - c ) == ( c - d ) ) { cout << d + ( b - a ) << endl ; } else { if ( ( b / a ) == ( c / b ) && ( c / b ) == ( d / c ) ) { double k = d * ( b / a ) ; if ( k == ( int ) k ) { cout << k << endl ; } else { cout << 42 << endl ; } } else { cout << 42 << endl ; } } return 0 ; }
TAB1 create unsigned long long integer variable l ; TAB1 read variable l from the input ; TAB1 if l < = 127 ; TAB2 print " byte " ; TAB1 else if l < = 32767 ; TAB2 print " short " ; TAB1 else if l < = 2147483647 ; TAB2 print " int " to the standard output ; TAB1 else if l < = 9223372036854775807 ; TAB2 print " long " ; TAB1 else ; TAB2 print " BigInteger " ;	int main ( ) { unsigned long long int l ; cin >> l ; if ( l <= 127 ) { cout << " byte " << endl ; } else if ( l <= 32767 ) { cout << " short " << endl ; } else if ( l <= 2147483647 ) { cout << " int " << endl ; } else if ( l <= 9223372036854775807 ) { cout << " long " << endl ; } else cout << " BigInteger " << endl ; return 0 ; }
TAB1 t , s , x , i are integers ; TAB1 read t , s , x ; TAB1 if t equals x ; TAB2 display YES ; TAB1 for i = 1 to 1000000000 exclusive ; TAB2 if t + s * i equals x or t + s * i + 1 equals x ; TAB3 display YES ; TAB3 break ; TAB2 else if t + s * i is greater than x ; TAB3 display NO ; TAB3 break ;	int main ( ) { int t , s , x , i ; cin >> t >> s >> x ; if ( t == x ) { cout << " YES " << endl ; return 0 ; } for ( i = 1 ; i < 1000000000 ; i ++ ) { if ( t + s * i == x || t + s * i + 1 == x ) { cout << " YES " << endl ; break ; } else if ( t + s * i > x ) { cout << " NO " << endl ; break ; } } }
TAB0 let po be vector of char ; TAB0 let ans be map of char to int ; TAB1 let ans [ ' a ' ] = ans [ ' e ' ] = ans [ ' i ' ] = ans [ ' o ' ] = ans [ ' u ' ] = ans [ ' y ' ] = 1 ; TAB1 pos = string ; TAB1 read pos ; TAB1 call transform of begin of pos , end of pos , begin of pos , : : toLower ; TAB1 for i = 0 to size of pos exclusive ; TAB2 if ans [ pos [ i ] ] is not zero ; TAB3 continue ; TAB2 else ; TAB3 push . to the back of po ; TAB3 push pos [ i ] to the back of po ; TAB1 for i = 0 to size of po , print po [ i ] ; TAB1 print newline ;	vector < char > po ; map < char , int > ans ; int main ( ) { ans [ ' a ' ] = ans [ ' e ' ] = ans [ ' i ' ] = ans [ ' o ' ] = ans [ ' u ' ] = ans [ ' y ' ] = 1 ; string pos ; cin >> pos ; transform ( pos . begin ( ) , pos . end ( ) , pos . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( ans [ pos [ i ] ] ) continue ; else { po . push_back ( ' . ' ) ; po . push_back ( pos [ i ] ) ; } } for ( int i = 0 ; i < po . size ( ) ; i ++ ) cout << po [ i ] ; cout << endl ; }
TAB1 declare string s ; TAB1 declare integers n , sum = 0 ; TAB1 read n ; TAB1 read s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is ' < ' ; TAB3 increment sum ; TAB2 else ; TAB3 end loop ; TAB1 for i = n - 1 to 0 inclusive , decrementing i ; TAB2 if s [ i ] is ' > ' ; TAB3 increment sum ; TAB2 else ; TAB3 end loop ; TAB1 print sum and newline ;	int main ( ) { string s ; int n , sum = 0 ; cin >> n ; cin >> s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' < ' ) sum ++ ; else break ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' > ' ) sum ++ ; else break ; } cout << sum << endl ; }
TAB0 N = constant integer = 0 ; TAB0 a , b are long longs ; TAB0 s = string ; TAB0 v = integer vector ; TAB1 read s ; TAB1 n = integer = length of s ; TAB1 res = string = " " ; TAB1 flag = boolean = false ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is the character a or flag ; TAB3 add s [ i ] to res ; TAB3 continue ; TAB2 set flag to true ; TAB2 while i is less than n and s [ i ] isn ' t the character a ; TAB3 add s [ i ] - 1 to res ; TAB3 increment i ; TAB2 if i isn ' t n , decrement i ; TAB1 if not flag , set res [ n - 1 ] to the character z ; TAB1 display res ;	const int N = 0 ; long long a , b ; string s ; vector < int > v ; int main ( ) { cin >> s ; int n = s . length ( ) ; string res = "  " ; bool flag = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' || flag ) { res += s [ i ] ; continue ; } flag = true ; while ( i < n && s [ i ] != ' a ' ) { res += ( s [ i ] - 1 ) ; i ++ ; } if ( i != n ) i -- ; } if ( ! flag ) { res [ n - 1 ] = ' z ' ; } cout << res << endl ; return 0 ; }
TAB0 a , b = integer arrays of length 110 both with value of 0 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive read a [ i ] ; TAB1 sum , num , h = integers with value of 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is less than 0 add 1 to num ; TAB2 if num equals 3 ; TAB3 set b [ h ] to sum then add 1 to h ; TAB3 set sum to 1 ; TAB3 set num to 1 ; TAB3 continue ; TAB2 add 1 to sum ; TAB1 set b [ h ] to sum then add 1 to h ; TAB1 print h ; TAB1 for i = 0 to h exclusive ; TAB2 if i is not 0 print a space ; TAB2 print b [ i ] ; TAB1 print a line terminator ;	int a [ 110 ] , b [ 110 ] = { 0 } ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int sum = 0 , num = 0 , h = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 0 ) num ++ ; if ( num == 3 ) { b [ h ++ ] = sum ; sum = 1 ; num = 1 ; continue ; } sum ++ ; } b [ h ++ ] = sum ; cout << h << endl ; for ( int i = 0 ; i < h ; i ++ ) { if ( i ) cout << "   " ; cout << b [ i ] ; } cout << endl ; }
TAB0 a is a new array of integers with 100001 element ; TAB1 declare new integer variable n ; TAB1 read variable n from the input ; TAB1 for i = 1 to n + 1 exclusive , read input to a [ i ] ; TAB1 declare new long long called res = 0 ; TAB1 create new integer called t ; TAB1 in a for loop , change i from 1 to n exclusive ; TAB2 in a for loop , change t from 1 to n inclusive multiplying t by 2 ; TAB2 change t to t > > 1 ; TAB2 change res to the sum of res and a [ i ] ; TAB2 change a [ i + t ] to the sum of a [ i + t ] and a [ i ] ; TAB2 print res ;	int a [ 100001 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i < n + 1 ; i ++ ) cin >> a [ i ] ; long long res = 0 ; int t ; for ( int i = 1 ; i < n ; i ++ ) { for ( t = 1 ; i + t <= n ; t *= 2 ) ; t >>= 1 ; res += a [ i ] ; a [ i + t ] += a [ i ] ; cout << res << endl ; } return 0 ; }
TAB0 m1 = array of long integers of length 100001 ; TAB0 let ans be a long integer ; TAB1 let n , d be long integers ; TAB1 read n ; TAB1 read d ; TAB1 for i = 0 to n exclusive , read m1 [ i ] ; TAB1 let h be a long integer with h = 0 ; TAB1 let t be a long integer ; TAB1 ans is equal to 0 ; TAB1 for long integer i = 0 to n exclusive ; TAB2 while h is less than n and m1 [ h ] - m1 [ i ] < = d , increment h by 1 ; TAB2 let t be a long integer with t = h - i - 1 ; TAB2 if t - 1 is greater than 0 , increment ans by t * ( t - 1 ) / 2 ; TAB1 print ans and newline ;	long long m1 [ 100001 ] ; long long ans ; int main ( ) { long long n , d ; cin >> n ; cin >> d ; for ( int i = 0 ; i < n ; i ++ ) { cin >> m1 [ i ] ; } long h = 0 ; long long t ; ans = 0 ; for ( long long i = 0 ; i < n ; i ++ ) { while ( h < n && m1 [ h ] - m1 [ i ] <= d ) h ++ ; long long t = h - i - 1 ; if ( t - 1 > 0 ) ans += t * ( t - 1 ) / 2 ; } cout << ans << ' \n ' ; }
TAB0 make string s ; TAB0 in function ok with return type boolean and parameter string t ; TAB1 make int msk = 0 ; TAB1 for i = 0 to ( cast t size to int ) exclusive ; TAB2 if isupper ( t [ i ] ) then set msk to msk bitwise or 1 ; TAB2 if islower ( t [ i ] ) then set msk to msk bitwise or1 ; TAB2 if isdigit ( t [ i ] ) then set msk to msk bitwise or 1 ; TAB1 return msk is equal to 7 ; TAB1 make integer t ; TAB1 read t ; TAB1 for i = 0 to t exclusive ; TAB2 read s ; TAB2 if ok ( s ) ; TAB3 print s ; TAB3 continue ; TAB2 make boolean fnd = false ; TAB2 for i = 0 to ( cast s size to int ) exclusive ; TAB3 make string t = s ; TAB3 set t [ i ] to ' 1 ' ; TAB3 if ok ( t ) ; TAB4 print t ; TAB4 set fnd to true ; TAB4 break ; TAB3 set t [ i ] to ' a ' ; TAB3 if ok ( t ) ; TAB4 print t ; TAB4 set fnd to true ; TAB4 break ; TAB3 set t [ i ] to ' A ' ; TAB3 if ok ( t ) ; TAB4 print t ; TAB4 set fnd to true ; TAB4 break ; TAB2 if fnd then continue ; TAB2 if isupper ( s [ 2 ] ) ; TAB3 set s [ 0 ] to ' a ' ; TAB3 set s [ 1 ] to ' 1 ' ; TAB3 print s ; TAB3 continue ; TAB2 if islower ( s [ 2 ] ) ; TAB3 set s [ 0 ] to ' A ' ; TAB3 set s [ 1 ] to ' 1 ' ; TAB3 print s ; TAB3 continue ; TAB2 if isdigit ( s [ 2 ] ) ; TAB3 set s [ 0 ] to ' a ' ; TAB3 set s [ 1 ] to ' A ' ; TAB3 print s ; TAB3 continue ;	string s ; bool ok ( string t ) { int msk = 0 ; for ( int i = 0 ; i < int ( t . size ( ) ) ; ++ i ) { if ( isupper ( t [ i ] ) ) msk |= 1 ; if ( islower ( t [ i ] ) ) msk |= 2 ; if ( isdigit ( t [ i ] ) ) msk |= 4 ; } return msk == 7 ; } int main ( ) { int t ; cin >> t ; for ( int i = 0 ; i < t ; ++ i ) { cin >> s ; if ( ok ( s ) ) { cout << s << endl ; continue ; } bool fnd = false ; for ( int i = 0 ; i < int ( s . size ( ) ) ; ++ i ) { string t = s ; t [ i ] = ' 1 ' ; if ( ok ( t ) ) { cout << t << endl ; fnd = true ; break ; } t [ i ] = ' a ' ; if ( ok ( t ) ) { cout << t << endl ; fnd = true ; break ; } t [ i ] = ' A ' ; if ( ok ( t ) ) { cout << t << endl ; fnd = true ; break ; } } if ( fnd ) continue ; if ( isupper ( s [ 2 ] ) ) { s [ 0 ] = ' a ' ; s [ 1 ] = ' 1 ' ; cout << s << endl ; continue ; } if ( islower ( s [ 2 ] ) ) { s [ 0 ] = ' A ' ; s [ 1 ] = ' 1 ' ; cout << s << endl ; continue ; } if ( isdigit ( s [ 2 ] ) ) { s [ 0 ] = ' a ' ; s [ 1 ] = ' A ' ; cout << s << endl ; continue ; } } return 0 ; }
TAB0 create constant integer N with N = 1e5 + 10 ; TAB0 create character arrays ch1 , ch2 with ch1 size N , ch2 size N ; TAB1 create character arrays a , b with a size 105 , b size 105 ; TAB1 while read ch1 ; TAB2 create integer len with len = string length of ch1 ; TAB2 for i = 0 to len exclusive , set ch2 [ i ] to ch1 [ len - 1 - i ] ; TAB2 read a read b ; TAB2 create integer la with la = string length of a ; TAB2 create integer lb with lb = string length of b ; TAB2 if reference to a in ch1 and reference to b in ( reference to a in ch1 + la ) ; TAB3 if reference to a in ch2 and reference to b in ( reference to a in ch2 + la ) ; TAB4 print " both " print newline ; TAB3 else ; TAB4 print " forward " print newline ; TAB2 else if reference to a in ch2 and reference to b in ( reference to a in ch2 + la ) ; TAB3 if reference to a in ch1 and reference to b in ( reference to a in ch1 + la ) ; TAB4 print " both " print newline ; TAB3 else ; TAB4 print " backward " print newline ; TAB2 else ; TAB3 print " fantasy " print newline ;	const int N = 1e5 + 10 ; char ch1 [ N ] , ch2 [ N ] ; int main ( ) { char a [ 105 ] , b [ 105 ] ; while ( cin >> ch1 ) { int len = strlen ( ch1 ) ; for ( int i = 0 ; i < len ; i ++ ) { ch2 [ i ] = ch1 [ len - 1 - i ] ; } cin >> a >> b ; int la = strlen ( a ) ; int lb = strlen ( b ) ; if ( strstr ( ch1 , a ) && strstr ( strstr ( ch1 , a ) + la , b ) ) { if ( strstr ( ch2 , a ) && strstr ( strstr ( ch2 , a ) + la , b ) ) cout << " both " << endl ; else cout << " forward " << endl ; } else if ( strstr ( ch2 , a ) && strstr ( strstr ( ch2 , a ) + la , b ) ) { if ( strstr ( ch1 , a ) && strstr ( strstr ( ch1 , a ) + la , b ) ) cout << " both " << endl ; else cout << " backward " << endl ; } else cout << " fantasy " << endl ; } return 0 ; }
TAB0 declare string nineteen ; TAB1 declare integers contN = 0 , contI = 0 , contT = 0 , contE = 0 ; TAB1 declare integer array vetor size 4 ; TAB1 read nineteen ; TAB1 for i = 0 to length of nineteen exclusive ; TAB2 if nineteen [ i ] is ' n ' ; TAB3 increment contN ; TAB2 else if nineteen [ i ] is ' i ' ; TAB3 increment contI ; TAB2 else if nineteen [ i ] is ' e ' ; TAB3 increment contE ; TAB2 else if nineteen [ i ] is ' t ' ; TAB3 increment contT ; TAB1 let contE be contE / 3 ; TAB1 if contN is greater than 3 ; TAB2 decrement contN ; TAB2 let contN be contN / 2 ; TAB1 else ; TAB2 let contN be contN / 3 ; TAB1 let vetor [ 0 ] be contI ; TAB1 let vetor [ 1 ] be contT ; TAB1 let vetor [ 2 ] be contE ; TAB1 let vetor [ 3 ] be contN ; TAB1 sort from vetor to vetor + 4 ; TAB1 print vetor [ 0 ] and newline ;	string nineteen ; int main ( ) { int contN = 0 , contI = 0 , contT = 0 , contE = 0 ; int vetor [ 4 ] ; cin >> nineteen ; for ( int i = 0 ; i < nineteen . length ( ) ; i ++ ) { if ( nineteen [ i ] == ' n ' ) contN ++ ; else if ( nineteen [ i ] == ' i ' ) contI ++ ; else if ( nineteen [ i ] == ' e ' ) contE ++ ; else if ( nineteen [ i ] == ' t ' ) contT ++ ; } contE /= 3 ; if ( contN > 3 ) { contN -- ; contN /= 2 ; } else contN /= 3 ; vetor [ 0 ] = contI ; vetor [ 1 ] = contT ; vetor [ 2 ] = contE ; vetor [ 3 ] = contN ; sort ( vetor , vetor + 4 ) ; cout << vetor [ 0 ] << endl ; return 0 ; }
TAB0 n , m = integers ; TAB1 Read t , s , x ; TAB1 if t is equal to x ; TAB2 print YES ; TAB3 print a new line ; TAB1 if t is equal to x - 1 ; TAB2 print NO ; TAB3 print a new line ; TAB1 l , r , m = integers with l = 0 , r = x ; TAB1 while l is less than or equal to r ; TAB2 set m to ( l + r ) / 2 ; TAB2 a = integer , set to t + s * m ; TAB2 b = integer , set to t + s * m + 1 ; TAB2 if a is equal to x OR b is equal to x ; TAB3 print YES ; TAB4 print a new line ; TAB2 if a is greater than to x OR b is greater than to x ; TAB3 set r to m - 1 ; TAB2 else do the following ; TAB3 set l m + 1 ; TAB1 print NO ; TAB2 print a new line ;	long long int t , s , x ; int main ( ) { cin >> t >> s >> x ; if ( t == x ) { cout << " YES " << " \n " ; return 0 ; } if ( t == x - 1 ) { cout << " NO " << " \n " ; return 0 ; } long long int l = 0 , r = x , m ; while ( l <= r ) { m = ( l + r ) / 2 ; long long int a = t + s * m ; long long int b = t + s * m + 1 ; if ( a == x || b == x ) { cout << " YES " << " \n " ; return 0 ; } if ( a > x || b > x ) { r = m - 1 ; } else { l = m + 1 ; } } cout << " NO " << " \n " ; return 0 ; }
TAB0 in function solve which takes pointers to ints a , b , and c and returns a bool ; TAB1 if value at a plus value at b is value at c then return true ; TAB1 if value at a minus 1 is 0 and value at a - 1 plus value at b is the value at c + 1 ; TAB2 decrement value at b ; TAB2 increment value at c ; TAB2 return true ; TAB1 if value at a - 1 plus value at b is the value at c + 1 ; TAB2 decrement value at a ; TAB2 increment value at c ; TAB2 return true ; TAB1 if value at a + 1 plus value at b is the value at c - 1 ; TAB2 increment value at a ; TAB2 decrement value at c ; TAB2 return true ; TAB1 return false ; TAB0 in function load which takes constant string reference t and pointers to ints a , b , and c ; TAB1 set value at a to position of first + in t ; TAB1 set value of b to position of first = in t minus value at a minus 1 ; TAB1 set value of c to size of t minus value at a minus value at b minus 2 ; TAB0 let output be a string of ints a , b , c ; TAB1 return a string with I as first a items followed by + followed by b Is followed by = followed by c Is ; TAB1 let a , b , and c be ints ; TAB1 let t be a string ; TAB1 read t ; TAB1 call function load on t and references to a b and c ; TAB1 if function solve on references to a b and c ; TAB2 print output ( a , b , c ) ; TAB1 else ; TAB2 print Impossible ;	bool solve ( int * a , int * b , int * c ) { if ( * a + * b == * c ) { return true ; } if ( * a - 1 == 0 && * a - 1 + * b == * c + 1 ) { ( * b ) -- ; ( * c ) ++ ; return true ; } if ( * a - 1 + * b == * c + 1 ) { ( * a ) -- ; ( * c ) ++ ; return true ; } if ( * a + 1 + * b == * c - 1 ) { ( * a ) ++ ; ( * c ) -- ; return true ; } return false ; } void load ( const string & t , int * a , int * b , int * c ) { * a = t . find ( ' + ' ) ; * b = t . find ( ' = ' ) - * a - 1 ; * c = t . size ( ) - * a - * b - 2 ; } string output ( int a , int b , int c ) { return string ( a , ' | ' ) + " + " + string ( b , ' | ' ) + " = " + string ( c , ' | ' ) ; } int main ( ) { int a , b , c ; string t ; cin >> t ; load ( t , & a , & b , & c ) ; if ( solve ( & a , & b , & c ) ) { cout << output ( a , b , c ) << endl ; } else { cout << " Impossible " << endl ; } return 0 ; }
TAB1 declare new integer n ; TAB1 read input to n ; TAB1 create integer variable k = n / 2 - 1 ; TAB1 print n / 2 ; TAB1 decrement k and loop further , while k ! = 0 ; TAB1 if n is odd ; TAB2 print 3 ; TAB1 else ; TAB2 print 2 ; TAB1 print new line ;	int main ( ) { int n ; cin >> n ; int k = n / 2 - 1 ; cout << n / 2 << endl ; while ( k -- ) cout << " 2  " ; if ( n % 2 ) cout << 3 ; else cout << 2 ; cout << endl ; return 0 ; }
TAB1 n , a = int ; TAB1 read n then a ; TAB1 mina , maxa , mini , maxi = int with mina = a and maxa = 0 and mini = 0 and maxi = 0 ; TAB1 for i = 1 to n ; TAB2 read a ; TAB2 if a > maxa ; TAB3 set maxa to a ; TAB3 set maxi to i ; TAB2 if a < = mina ; TAB3 set mina to a ; TAB3 set mini to i ; TAB1 print maxi + ( n - 1 - mini ) - ( if mini < maxi 1 else 0 ) ;	int main ( ) { int n , a ; cin >> n >> a ; int mina ( a ) , maxa ( a ) , mini ( 0 ) , maxi ( 0 ) ; for ( int i = 1 ; i < n ; ++ i ) { cin >> a ; if ( a > maxa ) { maxa = a ; maxi = i ; } if ( a <= mina ) { mina = a ; mini = i ; } } cout << maxi + ( n - 1 - mini ) - ( mini < maxi ? 1 : 0 ) << endl ; return 0 ; }
TAB0 prime is an array of booleans with 1200000 + 4 elements ; TAB0 pali is an array of integers with size 1200000 + 4 ; TAB0 declare new array of integers pri with size 1200000 + 4 ; TAB0 function sieve ; TAB1 in a for loop , change i from 4 to 1200000 inclusive adding 2 to i and changing prime [ i ] to 1 on each loop ; TAB1 start for loop from i = 3 to square root of 1200000 inclusive increasing i by 2 ; TAB2 if prime [ i ] is equal to 0 ; TAB3 in a for loop , change j from i * i to 1200000 inclusive adding 2 * i to j , and setting prime [ j ] to 1 on each iteration ; TAB1 change the value of prime [ 0 ] and prime [ 1 ] to 1 ; TAB0 function is_Palindrome with int argument n that returns bool ; TAB1 arr is a new array of integers with 10 elements ; TAB1 create new integer variable l = 0 ; TAB1 while n is not 0 ; TAB2 set arr [ l ] to n modulo 10 and increment l ; TAB2 change n to n / 10 ; TAB1 flag is a new boolean variable = 1 ; TAB1 for i = 0 to l / 2 inclusive incrementing i ; TAB2 if arr [ i ] ! = arr [ l - i - 1 ] ; TAB3 assign the new value = 0 to flag ; TAB3 stop the loop ; TAB1 if flag is true ; TAB2 return 1 ; TAB1 else ; TAB1 call sieve ( ) ; TAB1 set pri [ 0 ] to 0 ; TAB1 for i from 0 to 1200000 inclusive ; TAB2 if prime [ i ] is equal to 0 ; TAB3 set pri [ i ] to pri [ i - 1 ] + 1 ; TAB2 else ; TAB3 change the value of pri [ i ] to pri [ i - 1 ] ; TAB1 in a for loop , change i from 1 to 1200000 inclusive ; TAB2 if is_Palindrome ( i ) returned true ; TAB3 assign the new value = pali [ i - 1 ] + 1 to pali [ i ] ; TAB2 else ; TAB3 assign pali [ i - 1 ] to pali [ i ] ; TAB1 declare long long int variables p and q ; TAB1 read standard input to p and q ; TAB1 create boolean flag with value 1 ; TAB1 declare integer i ; TAB1 start for loop from i = 1200000 to 0 inclusive decrementing i ; TAB2 if pri [ i ] * q < = p * pali [ i ] ; TAB3 print i and " \ n " ; TAB1 print " Palindromic tree is better than splay tree \ n " to the output ;	bool prime [ 1200000 + 4 ] ; int pali [ 1200000 + 4 ] ; int pri [ 1200000 + 4 ] ; void sieve ( ) { for ( int i = 4 ; i <= 1200000 ; i += 2 ) prime [ i ] = 1 ; for ( int i = 3 ; i <= sqrt ( 1200000 ) ; i += 2 ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j <= 1200000 ; j += 2 * i ) prime [ j ] = 1 ; } } prime [ 0 ] = prime [ 1 ] = 1 ; } bool is_Palindrome ( int n ) { int arr [ 10 ] ; int l = 0 ; while ( n != 0 ) { arr [ l ++ ] = n % 10 ; n = n / 10 ; } bool flag = 1 ; for ( int i = 0 ; i <= l / 2 ; i ++ ) { if ( arr [ i ] != arr [ l - i - 1 ] ) { flag = 0 ; break ; } } if ( flag ) return 1 ; else return 0 ; } int main ( ) { sieve ( ) ; pri [ 0 ] = 0 ; for ( int i = 0 ; i <= 1200000 ; i ++ ) { if ( prime [ i ] == 0 ) { pri [ i ] = pri [ i - 1 ] + 1 ; } else { pri [ i ] = pri [ i - 1 ] ; } } for ( int i = 1 ; i <= 1200000 ; i ++ ) { if ( is_Palindrome ( i ) ) { pali [ i ] = pali [ i - 1 ] + 1 ; } else { pali [ i ] = pali [ i - 1 ] ; } } long long int p , q ; cin >> p >> q ; bool flag = 1 ; int i ; for ( i = 1200000 ; i >= 0 ; i -- ) { if ( ( ( ( long long int ) pri [ i ] ) * q ) <= ( p * ( long long int ) pali [ i ] ) ) { cout << i << " \n " ; return 0 ; } } cout << " Palindromic tree is better than splay tree\n " ; return 0 ; }
TAB0 str = string ; TAB0 n , negative = unsigned long long ; TAB1 read str ; TAB1 if str [ 0 ] is - ; TAB2 erase str . begin ( ) from str ; TAB2 negative = 1 ; TAB1 if ( str . size ( ) > 19 ) ; TAB2 print BigInteger ; TAB1 for i = 0 to str . size ( ) exclusive ; TAB2 n = n * 10 ; TAB2 n = n + cast to integer ( str [ i ] - 0 ) ; TAB1 n = n + negative ; TAB1 if ( n < = 127 ) ; TAB2 print byte ; TAB1 else if ( n < = 32767 ) ; TAB2 print short ; TAB1 else if ( n < = 2147483647 ) ; TAB2 print int ; TAB1 else if ( n < = 9223372036854775807 ) ; TAB2 print long ; TAB1 else ; TAB2 print BigInteger ;	string str ; unsigned long long n , negative ; int main ( ) { cin >> str ; if ( str [ 0 ] == ' - ' ) { str . erase ( str . begin ( ) ) ; negative = 1 ; } if ( str . size ( ) > 19 ) { cout << " BigInteger\n " ; return 0 ; } for ( int i = 0 ; i < str . size ( ) ; i ++ ) { n *= 10 ; n += int ( str [ i ] - ' 0 ' ) ; } n += negative ; if ( n <= 127 ) cout << " byte\n " ; else if ( n <= 32767 ) cout << " short\n " ; else if ( n <= 2147483647 ) cout << " int\n " ; else if ( n <= 9223372036854775807 ) cout << " long\n " ; else cout << " BigInteger\n " ; return 0 ; }
TAB1 let a , n , m , i , j , p , num be integers , the 200010th element of integer array t is equal to 0 ; TAB1 while read n , m ; TAB2 for i = 1 to n inclusive , read t [ i ] ; TAB2 for i = 1 to n inclusive ; TAB3 increment t [ i ] by t [ i - 1 ] ; TAB3 num is equal to t [ i ] / m ; TAB3 decrement t [ i ] by num * m ; TAB3 print num ; TAB3 if i is not equal to n , print ' ' ; TAB2 print newline ;	int main ( ) { int a , n , m , i , j , t [ 200010 ] = { 0 } , p , num ; while ( cin >> n >> m ) { for ( i = 1 ; i <= n ; i ++ ) cin >> t [ i ] ; for ( i = 1 ; i <= n ; i ++ ) { t [ i ] += t [ i - 1 ] ; num = t [ i ] / m ; t [ i ] -= num * m ; cout << num ; if ( i != n ) cout << '   ' ; } cout << endl ; } return 0 ; }
TAB0 let s , t = strings ; TAB0 let l1 , l2 = integers ; TAB0 let p = 10001 arrays of integers of size 26 ; TAB1 while ( read s , t ) is true do the following ; TAB2 set l1 = size of s ; TAB2 set l2 = size of t ; TAB2 set sizeof ( p ) bytes starting at p to 0 ; TAB2 for integer i = 0 to 26 exclusive set p [ l1 ] [ i ] to - 1 ; TAB2 for integer j = l1 to 1 inclusive decrementing ; TAB3 for integer i = 0 to 26 exclusive ; TAB4 if s [ j ] is i + a ; TAB5 set p [ j - 1 ] [ i ] = j ; TAB4 else ; TAB5 set p [ j - 1 ] [ i ] = p [ j ] [ i ] ; TAB2 let ans , l = integers where ans = 1 , l = - 2 ; TAB2 for integer i = 0 to l2 exclusive do the following ; TAB3 if l2 is - 2 do the following ; TAB4 if s [ 0 ] is t [ i ] ; TAB5 set l = 0 ; TAB4 else ; TAB5 set l = p [ 0 ] [ t [ i ] - a ] ; TAB4 if l is - 1 do the following ; TAB5 set ans = - 1 ; TAB5 exit the loop ; TAB3 else do the following ; TAB4 set l = p [ l ] [ t [ i ] - a ] ; TAB4 if l is - 1 do the following ; TAB5 increment ans ; TAB5 set l = - 2 ; TAB5 decrement i ; TAB2 print ans ;	string s , t ; int l1 , l2 ; int p [ 10001 ] [ 26 ] ; int main ( ) { while ( cin >> s >> t ) { l1 = s . size ( ) ; l2 = t . size ( ) ; memset ( p , 0 , sizeof ( p ) ) ; for ( int i = 0 ; i < 26 ; i ++ ) p [ l1 ] [ i ] = - 1 ; for ( int j = l1 ; j >= 1 ; j -- ) for ( int i = 0 ; i < 26 ; i ++ ) if ( s [ j ] == i + ' a ' ) p [ j - 1 ] [ i ] = j ; else p [ j - 1 ] [ i ] = p [ j ] [ i ] ; int ans = 1 , l = - 2 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( l == - 2 ) { if ( s [ 0 ] == t [ i ] ) l = 0 ; else l = p [ 0 ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans = - 1 ; break ; } } else { l = p [ l ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans ++ ; l = - 2 ; i -- ; } } } cout << ans << endl ; } }
TAB1 create integers a , b , c , d , e and f ; TAB1 read a , b , c , d , e and f ; TAB1 if a * c * e < b * d * f or ( c = 0 and d ! = 0 ) or ( a = 0 and b ! = 0 and d ! = 0 ) ; TAB2 print " Ron " to the standard output ; TAB1 else ; TAB2 print " Hermione " ;	int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( ( a * c * e < b * d * f ) || ( ! c && d ) || ( ! a && b && d ) ) { cout << " Ron " << endl ; return 0 ; } else { cout << " Hermione " << endl ; return 0 ; } return 0 ; }
TAB1 declare integer array result size 4 = { 6 , 8 , 4 , 2 } ; TAB1 declare integer n ; TAB1 read n ; TAB1 if n is 0 ; TAB2 print " 1 " , newline ; TAB1 else ; TAB2 print result [ n % 4 ] , newline ;	int main ( ) { int result [ 4 ] = { 6 , 8 , 4 , 2 } ; int n ; cin >> n ; if ( n == 0 ) { cout << " 1 " << endl ; } else { cout << result [ n % 4 ] << endl ; } }
TAB0 in the function bigmod that takes long long a , b , m and returns long long ; TAB1 if ( b is 0 ) , return 1 modulo m ; TAB1 x = long long with x = bigmod ( a , b / 2 , m ) ; TAB1 x = ( x * x ) modulo m ; TAB1 if ( b modulo 2 ) , x = ( x * a ) modulo m ; TAB1 return x ; TAB0 a = vector of long long ; TAB0 s = long long ; TAB0 vis = array of 4 bool ; TAB0 in the function f that takes long long i ; TAB1 if ( i > 10000000000 ) , return ; TAB1 if ( i ) , append i in a ; TAB1 f ( i * 10 + 4 ) ; TAB1 f ( i * 10 + 7 ) ; TAB1 f on 0 ; TAB1 sort a . begin ( ) and a . end ( ) ; TAB1 l , r , i , j , an , k = long long with an = 0 ; TAB1 read l , r ; TAB1 i = lower_bound ( a . begin ( ) , a . end ( ) , l ) - a . begin ( ) ; TAB1 k = upper_bound ( a . begin ( ) , a . end ( ) , r ) - a . begin ( ) ; TAB1 j = max ( k - 1 , i ) ; TAB1 an = an + ( a [ i ] - l + 1 ) * a [ i ] ; TAB1 an = an + ( r - a [ j ] ) * a [ k ] ; TAB1 for p = i + 1 to j , an = an + a [ p ] * ( a [ p ] - a [ p - 1 ] ) ; TAB1 print an ;	long long bigmod ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 % m ; long long x = bigmod ( a , b / 2 , m ) ; x = ( x * x ) % m ; if ( b % 2 ) x = ( x * a ) % m ; return x ; } vector < long long > a ; long long s ; bool vis [ 4 ] ; void f ( long long i ) { if ( i > 10000000000 ) { return ; } if ( i ) a . push_back ( i ) ; f ( i * 10 + 4 ) ; f ( i * 10 + 7 ) ; } int main ( ) { f ( 0 ) ; sort ( a . begin ( ) , a . end ( ) ) ; long long l , r , i , j , an = 0 , k ; cin >> l >> r ; i = lower_bound ( a . begin ( ) , a . end ( ) , l ) - a . begin ( ) ; k = upper_bound ( a . begin ( ) , a . end ( ) , r ) - a . begin ( ) ; j = max ( k - 1 , i ) ; an += ( a [ i ] - l + 1 ) * a [ i ] ; an += ( r - a [ j ] ) * a [ k ] ; for ( long long p = i + 1 ; p <= j ; p ++ ) { an += a [ p ] * ( a [ p ] - a [ p - 1 ] ) ; } cout << an << endl ; }
TAB0 declare const long long INF = 1e9 ; TAB1 declare long long variables n and m ; TAB1 read n and m ; TAB1 create long longs cnt1 and cnt2 = 1 ; TAB1 for i = 7 to n exclusive multiplying i by 7 , increment cnt1 by one ; TAB1 for i from 7 to m exclusive multiplying i by 7 , increment cnt2 ; TAB1 declare long long variable res = 0 ; TAB1 if cnt1 + cnt2 < = 7 ; TAB2 for i = o while i ! = n ; TAB3 for j = o while j ! = m ; TAB4 create vector of long long called used with 7 elements filled with 0 ; TAB4 for a = i , k = 0 , while k ! = cnt1 , increment k and divide a by 7 , incrementing used [ a % 7 ] on each iteration ; TAB4 for a = j , k = 0 , while k ! = cnt2 , increment k and divide a by 7 , incrementing used [ a % 7 ] on each iteration ; TAB4 if max_element of used < = 1 , increment res ; TAB1 print res ;	const long long INF = 1e9 ; int main ( ) { long long n , m ; cin >> n >> m ; long long cnt1 = 1 , cnt2 = 1 ; for ( long long i = 7 ; i < n ; i *= 7 ) cnt1 ++ ; for ( long long i = 7 ; i < m ; i *= 7 ) cnt2 ++ ; long long res = 0 ; if ( cnt1 + cnt2 <= 7 ) { for ( long long i = 0 ; i != n ; ++ i ) { for ( long long j = 0 ; j != m ; ++ j ) { vector < long long > used ( 7 , 0 ) ; for ( long long a = i , k = 0 ; k != cnt1 ; ++ k , a /= 7 ) used [ a % 7 ] ++ ; for ( long long a = j , k = 0 ; k != cnt2 ; ++ k , a /= 7 ) used [ a % 7 ] ++ ; if ( * max_element ( ( used ) . begin ( ) , ( used ) . end ( ) ) <= 1 ) res ++ ; } } } cout << res << endl ; return 0 ; }
TAB1 declare integer n ; TAB1 declare colors as string ; TAB1 declare freq as map from character to integer ; TAB1 read n ; TAB1 read colors ; TAB1 for i = 0 to n exclusive ; TAB2 increment freq [ colors [ i ] ] ; TAB2 if n is 1 or freq [ colors [ i ] ] is greater than or equal to 2 ; TAB3 print " Yes " , newline ; TAB1 print " No " , newline ;	int main ( ) { int n ; string colors ; map < char , int > freq ; cin >> n ; cin >> colors ; for ( int i = 0 ; i < n ; i ++ ) { freq [ colors [ i ] ] ++ ; if ( n == 1 || freq [ colors [ i ] ] >= 2 ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; return 0 ; }
TAB1 make int n ; TAB1 read n ; TAB1 make string s ; TAB1 read s ; TAB1 make bool ok = true ; TAB1 let int o = 0 ; TAB1 create int z = 0 ; TAB1 for i = 0 to s . size ( ) exclusive ; TAB2 if s [ i ] is equal to ' 1 ' ; TAB3 increment o and set z to 0 ; TAB2 else do ; TAB3 increment z and set o to 0 ; TAB2 if o is equal to 2 , set ok to 0 ; TAB2 if z is equal to 3 , set ok to 0 ; TAB1 if n is equal to 1 ; TAB2 if s is " 0 " , set ok to 0 ; TAB1 else do ; TAB2 if s [ 0 ] is equal to ' 0 ' and s [ 1 ] is equal to ' 0 ' , set ok to 0 ; TAB2 is s [ s . size ( ) - 1 ] is equal to ' 0 ' and s [ s . size ( ) - 1 ] is equal to 0 , set ok to 0 ; TAB1 if ok is truthy ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; bool ok = true ; int o = 0 ; int z = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' 1 ' ) { o ++ , z = 0 ; } else z ++ , o = 0 ; if ( o == 2 ) ok = 0 ; if ( z == 3 ) ok = 0 ; } if ( n == 1 ) { if ( s == " 0 " ) ok = 0 ; } else { if ( s [ 0 ] == ' 0 ' && s [ 1 ] == ' 0 ' ) ok = 0 ; if ( s [ s . size ( ) - 1 ] == ' 0 ' && s [ s . size ( ) - 2 ] == ' 0 ' ) ok = 0 ; } if ( ok ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB0 create integers n , i , array a length 1111111 , ans = 0 , array d length 1111111 ; TAB1 read n ; TAB1 read n elements into a ; TAB1 assign 1 to d [ 1 ] ; TAB1 for i = 2 to n exclusive , assign d [ i / 2 ] * 2 to d [ i ] ; TAB1 for i = 0 ; i + 1 < n ; i + + ; TAB2 add a [ i ] to a [ i + d [ n - i - 1 ] ] ; TAB2 add a [ i ] to ans ; TAB2 print ans ;	int n , i , a [ 1111111 ] , ans = 0 , d [ 1111111 ] ; int main ( ) { cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; d [ 1 ] = 1 ; for ( i = 2 ; i < n ; i ++ ) d [ i ] = d [ i / 2 ] * 2 ; for ( i = 0 ; i + 1 < n ; i ++ ) { a [ i + d [ n - i - 1 ] ] += a [ i ] ; ans += a [ i ] ; cout << ans << endl ; } return 0 ; }
TAB0 create const long long int MAXN = 1e5 + 5 ; TAB0 let constant long long integer MINN = 1e2 ; TAB0 let const int inf = ( 1e9 + 7 ) ; TAB0 let ints x1 , x2 , x3 , and x4 ; TAB0 declare error ; TAB1 print " yes " ; TAB1 exit function ; TAB1 create int n and int array a of size MAXN ; TAB1 read n ; TAB1 for i = 1 to n , read a [ i ] ; TAB1 for i = 1 to n - 2 ; TAB2 for j = 2 to n - 1 ; TAB3 if j is equal to i , continue loop ; TAB3 set x1 = a [ i ] , set x2 to a [ i + 1 ] , set x3 to a [ j ] , and set x4 to a [ j + 1 ] ; TAB3 if x2 is less than x1 , swap values of x1 and x2 ; TAB3 if x3 is greater than x4 , swap values of x3 and x4 ; TAB3 if x1 is less than x3 and x2 is less than x4 and x3 is less than x2 or if x3 is less than x1 and x1 is less than x4 and x4 is less than x2 , call error ; TAB1 print " no " ;	const long long int MAXN = 1e5 + 5 ; const long long int MINN = 1e2 ; const int inf = ( 1e9 + 7 ) ; int x1 , x2 , x3 , x4 ; void error ( ) { cout << " yes " << endl ; exit ( 0 ) ; } int main ( ) { int n , a [ MAXN ] ; cin >> n ; for ( int i = 1 ; i <= ( n ) ; ++ i ) cin >> a [ i ] ; for ( int i = 1 ; i <= ( n - 2 ) ; ++ i ) { for ( int j = 2 ; j <= ( n - 1 ) ; ++ j ) { if ( j == i ) continue ; x1 = a [ i ] , x2 = a [ i + 1 ] , x3 = a [ j ] , x4 = a [ j + 1 ] ; if ( x2 < x1 ) swap ( x1 , x2 ) ; if ( x3 > x4 ) swap ( x3 , x4 ) ; if ( ( x1 < x3 && x2 < x4 && x3 < x2 ) || ( x3 < x1 && x1 < x4 && x4 < x2 ) ) error ( ) ; } } cout << " no " << endl ; return 0 ; }
TAB1 str = string ; TAB1 read str ; TAB1 a , b = int ; TAB1 set a to ( str [ 0 ] - 48 ) * 10 + str [ 1 ] - 48 ; TAB1 set b to ( str [ 3 ] - 48 ) * 10 + str [ 4 ] - 48 ; TAB1 loop infinitely ; TAB2 if b is 59 ; TAB3 if a is 23 ; TAB4 set a to 0 ; TAB3 else ; TAB4 increment a ; TAB3 set b to 0 ; TAB2 else ; TAB3 increment b ; TAB2 c , d , e , f = int with c = a / 10 and d = b mod 10 and e = a mod 10 and f = b / 10 ; TAB2 if c is d and e is f ; TAB3 print c then e then " : " then f then d ;	int main ( ) { string str ; cin >> str ; int a , b ; a = ( str [ 0 ] - 48 ) * 10 + str [ 1 ] - 48 ; b = ( str [ 3 ] - 48 ) * 10 + str [ 4 ] - 48 ; for ( ; ; ) { if ( b == 59 ) { if ( a == 23 ) a = 0 ; else a ++ ; b = 0 ; } else { b ++ ; } int c = a / 10 , d = b % 10 , e = a % 10 , f = b / 10 ; if ( c == d && e == f ) { cout << c << e << " : " << f << d << endl ; return 0 ; } } }
TAB0 define function solve ; TAB1 declare long longs n and k ; TAB1 read n and k from the input ; TAB1 create new character variable c = ' a ' ; TAB1 declare new string variable s with value " " ; TAB1 create integer i with value 0 ; TAB1 for while i < k , ; TAB2 append c to the end of s ; TAB2 increase c by 1 ; TAB1 assign the new value = ' a ' to c ; TAB1 while i < n ; TAB2 append c to s ; TAB2 increment c ; TAB2 if c is greater than min of ' z ' and char ( ' a ' + k - 1 ) , change c to ' a ' ; TAB2 increment i ; TAB1 print s ; TAB1 declare new long long called t = 1 ; TAB1 decrement t and loop further , while t is not 0 , calling function solve on each iteration ;	void solve ( ) { long long n , k ; cin >> n >> k ; char c = ' a ' ; string s = "  " ; int i = 0 ; for ( ; i < k ; i ++ ) { s += c ; c = ( c + 1 ) ; } c = ' a ' ; while ( i < n ) { s += c ; c ++ ; if ( c > min ( ' z ' , char ( ' a ' + k - 1 ) ) ) c = ' a ' ; i ++ ; } cout << s << endl ; } int main ( ) { long long t = 1 ; while ( t -- ) { solve ( ) ; } return 0 ; }
TAB1 kids , candies , input , answer = long long integers ; TAB1 read kids , candies ; TAB1 qkids = queue of long long integer ; TAB1 index = queue of long long integer ; TAB1 for i = 0 to kids exclusive ; TAB2 read input ; TAB2 push input in qkids ; TAB2 push i in index ; TAB1 while ( not qkids . empty ( ) ) ; TAB2 if ( qkids . front ( ) < = candies ) ; TAB3 pop qkids ; TAB3 pop index ; TAB2 else ; TAB3 push qkids . front ( ) - candies in qkids ; TAB3 push index . front ( ) in index ; TAB3 pop qkids ; TAB3 pop index ; TAB2 answer = back of index ; TAB1 print ( answer + 1 ) ;	int main ( ) { long long int kids , candies , input , answer ; cin >> kids >> candies ; queue < long long int > qkids ; queue < long long int > index ; for ( int i = 0 ; i < kids ; i ++ ) { cin >> input ; qkids . push ( input ) ; index . push ( i ) ; } while ( ! qkids . empty ( ) ) { if ( qkids . front ( ) <= candies ) { qkids . pop ( ) ; index . pop ( ) ; } else { qkids . push ( qkids . front ( ) - candies ) ; index . push ( index . front ( ) ) ; qkids . pop ( ) ; index . pop ( ) ; } answer = index . back ( ) ; } cout << ( answer + 1 ) << endl ; return 0 ; }
TAB0 let PI a constant double with value acos ( - 1 ) ; TAB0 let MAX a constant int with value 2e9 + 7 ; TAB0 let MOD be a constant long long with value 1e9 + 7 ; TAB0 in function solve ; TAB1 let n an int ; TAB1 read n ; TAB1 let v a vector of ints ; TAB1 for i from 0 to n exclusive ; TAB2 let c an int ; TAB2 read c ; TAB2 append c to v ; TAB1 sort v ; TAB1 let s a multiset of ints ; TAB1 let ans an int , ans = 0 ; TAB1 for i from 0 to n - 1 exclusive ; TAB2 if v [ i ] < v [ i + 1 ] ; TAB3 increment ans ; TAB2 otherwise , if size of s is not 0 ; TAB3 let it be an iterator starting at s ; TAB3 if v [ i + 1 ] > current value of it ; TAB4 increment ans ; TAB4 erase value at it from s ; TAB3 insert v [ i ] into s ; TAB2 otherwise ; TAB3 insert v [ i ] into s ; TAB1 print ans ; TAB1 call solve ;	const double PI = acos ( - 1 ) ; const int MAX = 2e9 + 7 ; const long long MOD = 1e9 + 7 ; void solve ( ) { int n ; cin >> n ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int c ; cin >> c ; v . push_back ( c ) ; } sort ( ( v ) . begin ( ) , ( v ) . end ( ) ) ; multiset < int > s ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( v [ i ] < v [ i + 1 ] ) ans ++ ; else if ( s . size ( ) != 0 ) { multiset < int > :: iterator it = s . begin ( ) ; if ( v [ i + 1 ] > ( * it ) ) { ans ++ ; s . erase ( it ) ; } s . insert ( v [ i ] ) ; } else { s . insert ( v [ i ] ) ; } } cout << ans << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 declare integer n ; TAB1 declare string a ; TAB1 declare string b ; TAB1 read a and b ; TAB1 declare map mp of strings to ints ; TAB1 set mp [ " monday " ] to 1 ; TAB1 set mp [ " tuesday " ] to 2 ; TAB1 set mp [ " wednesdya " ] to 3 ; TAB1 set mp [ " thursday " ] to 4 ; TAB1 set mp [ " friday " ] to 5 ; TAB1 set mp [ " saturday " ] to 6 ; TAB1 set mp [ " sunday " ] to 0 ; TAB1 define int p1 = mp [ a ] ; TAB1 define int p2 = mp [ b ] ; TAB1 if ( p1 + 30 ) mod 7 is p2 ; TAB2 print " YES " ; TAB1 if ( p1 + 28 ) mod 7 is p2 ; TAB2 print " YES " ; TAB1 if ( p1 + 31 ) mod 7 is p2 ; TAB2 print " YES " ; TAB1 print " NO " ;	int main ( ) { int n ; string a ; string b ; cin >> a >> b ; map < string , int > mp ; mp [ " monday " ] = 1 ; mp [ " tuesday " ] = 2 ; mp [ " wednesday " ] = 3 ; mp [ " thursday " ] = 4 ; mp [ " friday " ] = 5 ; mp [ " saturday " ] = 6 ; mp [ " sunday " ] = 0 ; int p1 = mp [ a ] ; int p2 = mp [ b ] ; if ( ( p1 + 30 ) % 7 == p2 ) { puts ( " YES " ) ; return 0 ; } if ( ( p1 + 28 ) % 7 == p2 ) { puts ( " YES " ) ; return 0 ; } if ( ( p1 + 31 ) % 7 == p2 ) { puts ( " YES " ) ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB1 n , m , k , a = long long ; TAB1 read n , m , k , a ; TAB1 minn = long long with minn = 20000000000 ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 if i modulo 2 is 0 , minn = min of a and minn ; TAB1 if n modulo 2 ; TAB2 if n / 2 + 1 < = m ; TAB3 x = long long with x = n / 2 + 1 ; TAB3 x = m / x * k ; TAB3 if x < minn , print x else minn ; TAB2 else ; TAB3 print 0 ; TAB1 else ; TAB2 print 0 ;	int main ( ) { long long n , m , k , a ; cin >> n >> m >> k ; long long minn = 20000000000 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; if ( i % 2 == 0 ) minn = min ( a , minn ) ; } if ( n % 2 ) { if ( n / 2 + 1 <= m ) { long long x = n / 2 + 1 ; x = m / x * k ; cout << ( x < minn ? x : minn ) << endl ; } else { cout << 0 << endl ; } } else cout << 0 << endl ; }
TAB1 new integer called n ; TAB1 declare integer variable with name a ; TAB1 declare vector of integers called b ; TAB1 create vector of integers c ; TAB1 jawab is a new vector of integers ; TAB1 read standard input to n ; TAB1 for i from 0 to n exclusive incrementing i ; TAB2 read from the input to a ; TAB2 push a into b ; TAB2 add a to the end of c ; TAB1 sort c using greater < int > ( ) as a comparator ; TAB1 in a for loop , change i from 0 to n exclusive ; TAB2 for j = 0 to n exclusive incrementing j ; TAB3 if b [ i ] is equal to c [ j ] and i is equal to n - 1 ; TAB4 print j + 1 and " \ n " ; TAB4 break ; TAB3 else if b [ i ] = c [ j ] ; TAB4 print j + 1 and " " ; TAB4 break ;	int main ( ) { int n ; int a ; vector < int > b ; vector < int > c ; vector < int > jawab ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; b . push_back ( a ) ; c . push_back ( a ) ; } sort ( c . begin ( ) , c . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ i ] == c [ j ] && i == n - 1 ) { cout << j + 1 << " \n " ; break ; } else if ( b [ i ] == c [ j ] ) { cout << j + 1 << "   " ; break ; } } } }
TAB0 define constant long long mod = 1000000007 ; TAB0 declare strings s and t ; TAB0 new 2d array of long longs f 5001 by 5001 ; TAB1 read s and t ; TAB1 create integers a = length of s and b = length of t ; TAB1 new long long variable sum with value 0 ; TAB1 decrement o in a for loop from a - 1 to 0 inclusive ; TAB2 in a for loop , change i from b - 1 to 0 inclusive counting down ; TAB3 change f [ o ] [ i ] to f [ o ] [ i + 1 ] + ( s [ o ] = = t [ i ] ) * ( f [ o + 1 ] [ i + 1 ] + 1 ) ; TAB3 if f [ o ] [ i ] > = mod , change f [ o ] [ i ] to the remainder of f [ o ] [ i ] divided by mod ; TAB2 change sum to sum + f [ o ] [ 0 ] ; TAB2 if sum > = mod , change the value of sum to sum % mod ; TAB1 print sum ;	const long long mod = 1000000007 ; string s , t ; long long f [ 5001 ] [ 5001 ] ; int main ( ) { cin >> s >> t ; int a = s . size ( ) , b = t . size ( ) ; long long sum = 0 ; for ( int o = a - 1 ; o >= 0 ; o -- ) { for ( int i = b - 1 ; i >= 0 ; i -- ) { f [ o ] [ i ] = f [ o ] [ i + 1 ] + ( s [ o ] == t [ i ] ) * ( f [ o + 1 ] [ i + 1 ] + 1 ) ; if ( f [ o ] [ i ] >= mod ) f [ o ] [ i ] %= mod ; } sum += f [ o ] [ 0 ] ; if ( sum >= mod ) sum %= mod ; } cout << sum << endl ; return 0 ; }
TAB1 let x , y be integers ; TAB1 read x and y ; TAB1 let d2 be an integer with d2 = x * x + y * y ; TAB1 let the float integer D2 is equal to square root of d2 ; TAB1 let the integer n is equal to square root of d2 ; TAB1 let res be a float value with res = D2 - n ; TAB1 if x is equal to 0 or y is equal to 0 ; TAB2 print black and newline ; TAB1 else do the following ; TAB2 if x * y is greater than 0 ; TAB3 if n modulus 2 is equal to 0 ; TAB4 print black and newline ; TAB3 else do the following ; TAB4 if res is equal to 0 ; TAB5 print black and newline ; TAB4 print white and newline ; TAB2 else if x * y is less than 0 ; TAB3 if n modulus 2 is equal to 0 ; TAB4 if res is equal to 0 ; TAB5 print black and newline ; TAB4 print white and newline ; TAB3 else do the following ; TAB4 print black and newline ;	int main ( ) { int x , y ; cin >> x >> y ; int d2 = x * x + y * y ; float D2 = sqrt ( d2 ) ; int n = sqrt ( d2 ) ; float res = D2 - n ; if ( x == 0 || y == 0 ) { cout << " black " << endl ; return 0 ; } else { if ( x * y > 0 ) { if ( n % 2 == 0 ) { cout << " black " << endl ; return 0 ; } else { if ( res == 0 ) { cout << " black " << endl ; return 0 ; } cout << " white " << endl ; return 0 ; } } else if ( x * y < 0 ) { if ( n % 2 == 0 ) { if ( res == 0 ) { cout << " black " << endl ; return 0 ; } cout << " white " << endl ; return 0 ; } else { cout << " black " << endl ; return 0 ; } } } return 0 ; }
TAB1 t , i = int and a = int array of size 30 ; TAB1 s = string ; TAB1 read t then s ; TAB1 if t is 1 ; TAB2 print " Yes " ; TAB1 for i = 0 to 29 set a [ i ] to 0 ; TAB1 for i = 0 to t increment a [ s [ i ] - ' a ' ] ; TAB1 for i = 0 to 27 ; TAB2 if a [ i ] > 1 ; TAB3 print " Yes " ; TAB1 print " No " ;	int main ( ) { int a [ 30 ] , t , i ; string s ; cin >> t >> s ; if ( t == 1 ) { cout << " Yes " << endl ; return 0 ; } for ( i = 0 ; i < 29 ; i ++ ) a [ i ] = 0 ; for ( i = 0 ; i < t ; i ++ ) { a [ s [ i ] - ' a ' ] ++ ; } for ( i = 0 ; i < 27 ; i ++ ) { if ( a [ i ] > 1 ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; return 0 ; }
TAB0 M = const int with M = 100 + 10 ; TAB1 n , m , a , b = int ; TAB1 read n then m then a then b ; TAB1 if m is 1 ; TAB2 print " 1 " ; TAB1 else ; TAB2 if ( a - 1 ) mod m is 0 ; TAB3 rowa = int with rowa = ( a - 1 ) / m + 1 ; TAB3 trow = int with trow = ( n - 1 ) / m + 1 ; TAB3 if rowa is trow ; TAB4 print " 1 " ; TAB3 else ; TAB4 if b < = rowa * m ; TAB5 print " 1 " ; TAB4 else ; TAB5 if ( b - a + 1 ) mod m is 0 ; TAB6 print " 1 " ; TAB5 else ; TAB6 if b is not n ; TAB7 print " 2 " ; TAB6 else ; TAB7 print " 1 " ; TAB2 else ; TAB3 rowa = int with rowa = ( a - 1 ) / m + 1 ; TAB3 rowb = int with rowb = ( b - 1 ) / m + 1 ; TAB3 trow = int with trow = ( n - 1 ) / m + 1 ; TAB3 if rowa is trow ; TAB4 print " 1 " ; TAB3 else ; TAB4 lastrowa = int with lastrowa = rowa * m ; TAB4 ig b < = lastrowa ; TAB5 print " 1 " ; TAB4 else ; TAB5 if b < = lastrowa + m ; TAB6 print " 2 " ; TAB5 else ; TAB6 if b mod m is 0 ; TAB7 print " 2 " ; TAB6 else ; TAB7 if ( b - a + 1 ) mod m is 0 ; TAB8 print " 2 " ; TAB7 else ; TAB8 if b is not n ; TAB9 print " 3 " ; TAB8 else ; TAB9 print " 2 " ;	const int M = 100 + 10 ; int main ( ) { int n , m , a , b ; cin >> n >> m >> a >> b ; if ( m == 1 ) { cout << " 1 " << endl ; } else { if ( ( a - 1 ) % m == 0 ) { int rowa = ( a - 1 ) / m + 1 ; int trow = ( n - 1 ) / m + 1 ; if ( rowa == trow ) { cout << " 1 " << endl ; } else { if ( b <= rowa * m ) { cout << " 1 " << endl ; } else { if ( ( b - a + 1 ) % m == 0 ) { cout << " 1 " << endl ; } else { if ( b != n ) cout << " 2 " << endl ; else cout << " 1 " << endl ; } } } } else { int rowa = ( a - 1 ) / m + 1 ; int rowb = ( b - 1 ) / m + 1 ; int trow = ( n - 1 ) / m + 1 ; if ( rowa == trow ) { cout << " 1 " << endl ; } else { int lastrowa = rowa * m ; if ( b <= lastrowa ) { cout << " 1 " << endl ; } else { if ( b <= lastrowa + m ) { cout << " 2 " << endl ; } else { if ( b % m == 0 ) { cout << " 2 " << endl ; } else { if ( ( b - a + 1 ) % m == 0 ) { cout << " 2 " << endl ; } else { if ( b != n ) cout << " 3 " << endl ; else cout << " 2 " << endl ; } } } } } } } return 0 ; }
TAB0 declare constant integer N = 1e5 ; TAB0 declare long long array arr size N + 5 ; TAB0 declare long long array dif size N + 5 ; TAB0 declare integer n ; TAB0 declare getMax with no arguments , returning long long ; TAB1 declare long long mx1 = dif [ 1 ] ; TAB1 declare long long mx2 = mx1 ; TAB1 for i = 2 to n - 1 inclusive , incrementing i by 1 ; TAB2 let mx1 be maximum of ( dif [ i ] and mx1 + dif [ i ] ) ; TAB2 let mx2 be maximum of mx2 and mx1 ; TAB1 return mx2 ; TAB0 declare getMin with no arguments , returning long long ; TAB1 declare long long mn1 = dif [ 1 ] ; TAB1 declare long long mn2 = mn1 ; TAB1 for i = 2 to n - 1 inclusive , incrementing i by 1 ; TAB2 let mn1 be minimum of ( dif [ i ] and mn1 + dif [ i ] ) ; TAB2 let mn2 be minimum of ( mn2 and mn1 ) ; TAB1 return mn2 ; TAB1 read n ; TAB1 for i = 1 to n inclusive , incrementing i by 1 , read arr [ i ] ; TAB1 for i = 1 to n - 1 inclusive , incrementing i by 1 ; TAB2 let dif [ i ] be absolute value of ( arr [ i ] - arr [ i + 1 ] ) ; TAB2 if i bitwise and 1 , let dif [ i ] be dif [ i ] * - 1 ; TAB1 declare long long ans = maximum of result of getMax and - result of getMin ; TAB1 print ans and newline ;	const int N = 1e5 ; long long arr [ N + 5 ] ; long long dif [ N + 5 ] ; int n ; long long getMax ( ) { long long mx1 = dif [ 1 ] ; long long mx2 = mx1 ; for ( int i = 2 ; i <= n - 1 ; i += 1 ) { mx1 = max ( dif [ i ] , mx1 + dif [ i ] ) ; mx2 = max ( mx2 , mx1 ) ; } return mx2 ; } long long getMin ( ) { long long mn1 = dif [ 1 ] ; long long mn2 = mn1 ; for ( int i = 2 ; i <= n - 1 ; i += 1 ) { mn1 = min ( dif [ i ] , mn1 + dif [ i ] ) ; mn2 = min ( mn2 , mn1 ) ; } return mn2 ; } int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i += 1 ) cin >> arr [ i ] ; for ( int i = 1 ; i <= n - 1 ; i += 1 ) { dif [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) ; if ( i & 1 ) dif [ i ] *= - 1 ; } long long ans = max ( getMax ( ) , - getMin ( ) ) ; cout << ans << endl ; return 0 ; }
TAB0 mod = static integer = 1e9 + 7 ; TAB1 n , m are integers , row , col are integer arrays both of size 105 , table is an integer array of sizes 105 and 105 , minn and flag are integers ; TAB1 while read n , m ; TAB2 tmp = integer = 0 ; TAB2 call memset with row , 0 , call sizeof with row ; TAB2 call memset with col , 0 , call sizeof with col ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to m inclusive , read table [ i ] [ j ] ; TAB2 if m is at least n ; TAB3 for i = 1 to n inclusive ; TAB4 set min to 0x3f3f3f3f ; TAB4 for j = 1 to m inclusive ; TAB5 if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 add minn to tmp ; TAB5 set row [ i ] to minn ; TAB5 for j = 1 to m inclusive , subtract minn from table [ i ] [ j ] ; TAB3 for j = 1 to m inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for i = 1 to n inclusive ; TAB5 if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 add minn to tmp ; TAB5 set col [ j ] to minn ; TAB5 for i = 1 to n inclusive , subtract minn from table [ i ] [ j ] ; TAB2 else ; TAB3 for j = 1 to m inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for i = 1 to n inclusive ; TAB5 if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 add minn to tmp ; TAB5 set col [ j ] to minn ; TAB5 for i = 1 to n inclusive , subtract minn from table [ i ] [ j ] ; TAB3 for i = 1 to n inclusive ; TAB4 set minn to 0x3f3f3f3f ; TAB4 for j = 1 to m inclusive ; TAB5 if table [ i ] [ j ] is less than minn , set minn to table [ i ] [ j ] ; TAB4 if minn ; TAB5 add minn to tmp ; TAB5 set row [ i ] to minn ; TAB5 iterate m times , subtract minn from table [ i ] [ j ] ; TAB2 set flag to 1 ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to m inclusive ; TAB4 if table [ i ] [ j ] ; TAB5 set flag to 0 ; TAB5 break ; TAB2 if flag ; TAB3 print tmp ; TAB3 for i = 1 to n inclusive ; TAB4 for k = 1 to row [ i ] inclusive , print " row " , i ; TAB3 for j = 1 to m inclusive ; TAB4 for j = 1 to col [ j ] inclusive , print " col " , j ; TAB2 else ; TAB3 print - 1 ;	static int mod = 1e9 + 7 ; int main ( ) { int n , m , row [ 105 ] , col [ 105 ] , table [ 105 ] [ 105 ] , minn , flag ; while ( cin >> n >> m ) { int tmp = 0 ; memset ( row , 0 , sizeof ( row ) ) ; memset ( col , 0 , sizeof ( col ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) cin >> table [ i ] [ j ] ; } if ( m >= n ) { for ( int i = 1 ; i <= n ; i ++ ) { minn = 0x3f3f3f3f ; for ( int j = 1 ; j <= m ; j ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { tmp += minn ; row [ i ] = minn ; for ( int j = 1 ; j <= m ; j ++ ) table [ i ] [ j ] -= minn ; } } for ( int j = 1 ; j <= m ; j ++ ) { minn = 0x3f3f3f3f ; for ( int i = 1 ; i <= n ; i ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { tmp += minn ; col [ j ] = minn ; for ( int i = 1 ; i <= n ; i ++ ) table [ i ] [ j ] -= minn ; } } } else { for ( int j = 1 ; j <= m ; j ++ ) { minn = 0x3f3f3f3f ; for ( int i = 1 ; i <= n ; i ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { tmp += minn ; col [ j ] = minn ; for ( int i = 1 ; i <= n ; i ++ ) table [ i ] [ j ] -= minn ; } } for ( int i = 1 ; i <= n ; i ++ ) { minn = 0x3f3f3f3f ; for ( int j = 1 ; j <= m ; j ++ ) { if ( table [ i ] [ j ] < minn ) minn = table [ i ] [ j ] ; } if ( minn ) { tmp += minn ; row [ i ] = minn ; for ( int j = 1 ; j <= m ; j ++ ) table [ i ] [ j ] -= minn ; } } } flag = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) if ( table [ i ] [ j ] ) { flag = 0 ; break ; } if ( flag ) { cout << tmp << ' \n ' ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 1 ; k <= row [ i ] ; k ++ ) cout << " row  " << i << ' \n ' ; } for ( int j = 1 ; j <= m ; j ++ ) { for ( int k = 1 ; k <= col [ j ] ; k ++ ) cout << " col  " << j << ' \n ' ; } } else cout << " -1\n " ; } return 0 ; }
TAB1 str = string ; TAB1 flag = boolean = false ; TAB1 read str ; TAB1 for i = 0 to length of str exclusive ; TAB2 if str [ i ] is 0 ; TAB3 erase the elements of str from i onwards ; TAB3 flag = true ; TAB3 exit the for loop ; TAB1 if flag is false , then str [ 0 ] = 0 ; TAB1 lead = integer = 1 ; TAB1 for i = 0 to length of str exclusive ; TAB2 if str [ i ] is 0 and lead is nonzero , continue ; TAB2 lead = 0 ; TAB2 print str [ i ] ; TAB1 print endline ;	int main ( ) { string str ; bool flag = false ; cin >> str ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' 0 ' ) { str . erase ( str . begin ( ) + i ) ; flag = true ; break ; } } if ( ! flag ) str [ 0 ] = ' 0 ' ; int lead = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' 0 ' && lead ) { continue ; } lead = 0 ; cout << str [ i ] ; } cout << endl ; return 0 ; }
TAB0 Create constant integer mo with value 1000000007 ; TAB0 Create consant integer inf with value 0x3f3f3f3f ; TAB0 Create double pi with value 3 . 14159265358979323846 ; TAB0 Create double e with value 2 . 71828182845904523536 ; TAB0 In function read that takes integer reference x ; TAB1 f = int with value 1 ; TAB1 set x to 0 ; TAB1 call getchar and store result in character ch ; TAB1 while ch < ' 0 ' and ch > ' 9 ' ; TAB2 if ch is ' - ' , set f to - 1 ; TAB2 call getchar and store the result in ch ; TAB1 while ch is between ' 0 ' and ' 9 ' inclusive ; TAB2 set x to x * 10 + ch - ' 0 ' ; TAB2 call getchar and store result in ch ; TAB1 set x to x * f ; TAB1 Let n , m integers ; TAB1 Let s , ss , sss strings ; TAB1 read n and m ; TAB1 read s ; TAB1 for i = n - 1 to 0 inclusive ; TAB2 set ss to substring of s starting at index i ; TAB2 set sss to substring of s starting at index n - i ; TAB2 append ss onto sss ; TAB2 if s equals sss ; TAB3 Print s ; TAB3 Print ss m - 1 times ; TAB3 Print new line ;	const int mo = 1000000007 ; const int inf = 0x3f3f3f3f ; double pi = 3.14159265358979323846 ; double e = 2.71828182845904523536 ; void read ( int & x ) { int f = 1 ; x = 0 ; char ch = getchar ( ) ; while ( ch < ' 0 ' && ch > ' 9 ' ) { if ( ch == ' - ' ) f = - 1 ; ch = getchar ( ) ; } while ( ch >= ' 0 ' && ch <= ' 9 ' ) { x = x * 10 + ch - ' 0 ' ; ch = getchar ( ) ; } x *= f ; } int main ( ) { int n , m ; string s , ss , sss ; cin >> n >> m ; cin >> s ; for ( int i = n - 1 ; i >= 0 ; i -- ) { ss = s . substr ( i ) ; sss = s . substr ( n - i ) ; sss += ss ; if ( s == sss ) { cout << s ; for ( int j = 1 ; j < m ; j ++ ) cout << ss ; cout << endl ; return 0 ; } } }
TAB0 let f be a false boolean ; TAB1 n , t , a , b , da , db = int ; TAB1 read n , t , a , b , da , db ; TAB1 if n = 0 ; TAB2 set f to true ; TAB1 else ; TAB2 for i = 0 to t exclusive ; TAB3 if a - i * da = n or b - i * db = n then f = true ; TAB2 for i = 0 to t exclusive ; TAB3 for j = 0 to t exclusive ; TAB4 if a - i * da + b - j * db = n then set f to true ; TAB1 if f ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	bool f = false ; int main ( ) { int n , t , a , b , da , db ; cin >> n >> t >> a >> b >> da >> db ; if ( n == 0 ) f = true ; else { for ( int i = 0 ; i < t ; i ++ ) if ( a - i * da == n || b - i * db == n ) f = true ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) if ( a - i * da + b - j * db == n ) f = true ; } } if ( f ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB0 create integers flag , gender , ok , t and cnt ; TAB0 cal is a new array of integers with size 10005 ; TAB0 declare new string variable s ; TAB0 create an arrays of strings x with 6 elements = " lios " , " liala " , " etr " , " etra " , " initis " , " inites " , and y wth 10005 elements ; TAB0 function cmp with string arguments a and b that returns integer ; TAB1 define integer variables len1 = length of a , and len2 = length of b ; TAB1 in a for loop , change i from 0 to len2 exclusive ; TAB2 if a [ len1 - len2 + i ] ! = b [ i ] , return 0 ; TAB1 return 1 ; TAB0 function over with string argument s ; TAB1 print s ; TAB1 terminate the process ; TAB1 create new integer called cnt with value 0 ; TAB1 loop , reading s from the input ; TAB2 increment cnt by one ; TAB2 change the value of y [ cnt ] to s ; TAB2 change flag to 0 ; TAB2 in a for loop , change i from 0 to 6 exclusive ; TAB3 if cmp ( y [ cnt ] , x [ i ] ) returned true ; TAB4 change flag to 1 ; TAB4 change the value of cal [ cnt ] to i ; TAB2 if flag = 0 , call over ( " NO " ) ; TAB2 if character from the input is equal to ' \ n ' , stop the loop ; TAB1 if cnt = 1 , call over ( " YES " ) ; TAB1 start for loop from i = 1 to cnt exclusive ; TAB2 if cal [ i ] % 2 ! = cal [ i + 1 ] % 2 | | cal [ i ] > cal [ i + 1 ] , call over ( " NO " ) ; TAB1 change flag to 0 ; TAB1 for integer i = 1 to cnt inclusive incrementing i ; TAB2 if cal [ i ] / 2 = 1 , increment flag by one ; TAB1 if flag ! = 1 , call over ( " NO " ) ; TAB1 call over ( " YES " ) ;	int flag , gender , ok , t , cnt ; int cal [ 10005 ] ; string s ; string x [ 6 ] = { " lios " , " liala " , " etr " , " etra " , " initis " , " inites " } , y [ 10005 ] ; int cmp ( string a , string b ) { int len1 = a . size ( ) , len2 = b . size ( ) ; for ( int i = 0 ; i < len2 ; i ++ ) if ( a [ len1 - len2 + i ] != b [ i ] ) return 0 ; return 1 ; } void over ( string s ) { cout << s << endl ; exit ( 0 ) ; } int main ( ) { int cnt = 0 ; while ( cin >> s ) { cnt ++ ; y [ cnt ] = s ; flag = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) if ( cmp ( y [ cnt ] , x [ i ] ) ) { flag = 1 ; cal [ cnt ] = i ; } if ( flag == 0 ) over ( " NO " ) ; if ( cin . get ( ) == ' \n ' ) break ; } if ( cnt == 1 ) over ( " YES " ) ; for ( int i = 1 ; i < cnt ; i ++ ) if ( cal [ i ] % 2 != cal [ i + 1 ] % 2 || cal [ i ] > cal [ i + 1 ] ) over ( " NO " ) ; flag = 0 ; for ( int i = 1 ; i <= cnt ; i ++ ) if ( cal [ i ] / 2 == 1 ) flag ++ ; if ( flag != 1 ) over ( " NO " ) ; over ( " YES " ) ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 len = int with len = length of s ; TAB1 p = pointer to int with p = new int of size len ; TAB1 set all values of len to 0 ; TAB1 for i = 0 to len ; TAB2 if s [ i ] is not ' . ' then increment p [ i ] ; TAB2 if i is greater than 0 and i is less than len - 1 and s [ i - 1 ] is s [ i + 1 ] ; TAB3 increment p [ i ] ; TAB3 continue loop ; TAB2 if i is greater than 0 and s [ i - 1 ] is not ' . ' and s [ i - 1 ] is not s [ i ] then increment p [ i ] ; TAB2 if i is less than len - 1 and s [ i + 1 ] is not ' . ' and s [ i + 1 ] is not s [ i ] then increment p [ i ] ; TAB2 if p [ i ] is 3 ; TAB3 print " Yes " ; TAB1 print " No " ;	int main ( ) { string s ; cin >> s ; int len = s . length ( ) ; int * p = new int [ len ] ; memset ( p , 0 , len * sizeof ( int ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] != ' . ' ) p [ i ] ++ ; if ( i > 0 && i < len - 1 && s [ i - 1 ] == s [ i + 1 ] ) { p [ i ] ++ ; continue ; } if ( i > 0 && s [ i - 1 ] != ' . ' && s [ i - 1 ] != s [ i ] ) p [ i ] ++ ; if ( i < len - 1 && s [ i + 1 ] != ' . ' && s [ i + 1 ] != s [ i ] ) p [ i ] ++ ; if ( p [ i ] == 3 ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; }
TAB1 declare string variable s ; TAB1 read s ; TAB1 declare integer variable n ; TAB1 create integers ab and ba = 1000000 ; TAB1 for integer i = 0 to n - 1 exclusive ; TAB2 if s [ i ] = ' A ' and s [ i + 1 ] is equal to ' B ' ; TAB3 change ab to i + 2 ; TAB3 break the loop ; TAB1 for integer i = 0 to n - 1 exclusive ; TAB2 if s [ i ] is equal to ' B ' and s [ i + 1 ] is equal to ' A ' ; TAB3 assign i + 2 to ba ; TAB3 break the loop ; TAB1 create bool flag = false ; TAB1 for integer i = ab to n - 1 exclusive ; TAB2 if s [ i ] = ' B ' and s [ i + 1 ] is equal to ' A ' ; TAB3 set flag to true ; TAB3 stop the loop ; TAB1 for i = ba to n - 1 exclusive ; TAB2 if s [ i ] = ' A ' and s [ i + 1 ] = ' B ' ; TAB3 change flag to true ; TAB3 stop the loop ; TAB1 print " YES " if flag is true or " NO " if it is false ;	int main ( ) { string s ; cin >> s ; int n = ( ( int ) ( s ) . size ( ) ) ; int ab = 1000000 , ba = 1000000 ; for ( int i = 0 ; i < int ( n - 1 ) ; i ++ ) if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' ) { ab = i + 2 ; break ; } for ( int i = 0 ; i < int ( n - 1 ) ; i ++ ) if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' ) { ba = i + 2 ; break ; } bool flag = false ; for ( int i = int ( ab ) ; i < int ( n - 1 ) ; i ++ ) if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' ) { flag = true ; break ; } for ( int i = int ( ba ) ; i < int ( n - 1 ) ; i ++ ) if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' ) { flag = true ; break ; } cout << ( flag ? " YES " : " NO " ) << endl ; return 0 ; }
TAB1 create unsigned long long n , s , w , e ; TAB1 read n ; TAB1 if n mod 4 = and n different from 0 ; TAB2 set s to 4 ; TAB1 else ; TAB2 assign n modulo 4 to s ; TAB1 s = 8 ^ s ; TAB1 set s to s mod 10 ; TAB1 print s ;	int main ( ) { unsigned long long n , s , w , e ; cin >> n ; if ( n % 4 == 0 && n != 0 ) { s = 4 ; } else { s = n % 4 ; } s = pow ( 8 , s ) ; s = s % 10 ; cout << s << endl ; return 0 ; }
TAB1 let n be an integer ; TAB1 read in n ; TAB1 let v be a vector of integers of size n ; TAB1 iterate for n times , read in v [ i ] ; TAB1 let v1 be a vector of integers , set v1 to v ; TAB1 sort v1 in ascending order ; TAB1 iterate for n times ; TAB2 if i is greater than 0 , print " " ; TAB2 print 1 + ( v1 . end ( ) - upper_bound ( v1 . begin ( ) , v1 . end ( ) , v [ i ] ) ) ; TAB1 print a newline ;	int main ( ) { int n ; cin >> n ; vector < int > v ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> v [ i ] ; } vector < int > v1 = v ; sort ( v1 . begin ( ) , v1 . end ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i > 0 ) cout << "   " ; cout << 1 + ( v1 . end ( ) - upper_bound ( v1 . begin ( ) , v1 . end ( ) , v [ i ] ) ) ; } cout << endl ; return 0 ; }
TAB0 long long function max with long long arguments a and b ; TAB1 if a > = b ; TAB2 return a ; TAB1 else ; TAB2 return b ; TAB0 define function solve ; TAB1 declare new integer variable n ; TAB1 read user input to n ; TAB1 a is a new array of integers with size n ; TAB1 declare new array of long longs m with n elements ; TAB1 new long long variable mx = 0 ; TAB1 ans is a new long long with value 0 ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 read user input to a [ i ] ; TAB2 declare integer k = 0 ; TAB2 in a for loop , change j from 0 to a [ i ] exclusive ; TAB3 declare integer variable with name x ; TAB3 read x from the input ; TAB3 change k to max of k and x ; TAB3 change the value of mx to max of mx and x ; TAB2 assign k to m [ i ] ; TAB1 for i = 0 to n exclusive , change ans to ans + ( ( mx - m [ i ] ) * a [ i ] ) ; TAB1 print ans to the standard output ; TAB1 call function solve ;	long long max ( long long a , long long b ) { if ( a >= b ) return a ; else return b ; } void solve ( ) { int n ; cin >> n ; int a [ n ] ; long long m [ n ] ; long long mx = 0 ; long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; int k = 0 ; for ( int j = 0 ; j < a [ i ] ; j ++ ) { int x ; cin >> x ; k = max ( k , x ) ; mx = max ( mx , x ) ; } m [ i ] = k ; } for ( int i = 0 ; i < n ; i ++ ) { ans += ( ( mx - m [ i ] ) * a [ i ] ) ; } cout << ans << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 let n be a integer ; TAB1 while read n ; TAB2 if n & 1 is true ; TAB3 print n / 2 and newline ; TAB2 else do the following ; TAB3 the integer value of m = 2 ; TAB3 while m < = n , m < < = 1 ; TAB3 m > > = 1 ; TAB3 print ( n - m ) / 2 and newline ;	int main ( ) { int n ; while ( cin >> n ) { if ( n & 1 ) cout << n / 2 << endl ; else { int m = 2 ; while ( m <= n ) { m <<= 1 ; } m >>= 1 ; cout << ( n - m ) / 2 << endl ; } } }
TAB0 create map A from pair of integer , integer to integer ; TAB1 create integers x , y , k , p , ind with x = 0 , y = 0 , k = 0 , p = 1 , ind = 1 ; TAB1 while x is less than or equal to 100 or y is less than or equal to 100 ; TAB2 for i = 1 to ind inclusive ; TAB3 increment x by p ; TAB3 set A [ make pair from ( x , y ) ] to k ; TAB2 increment k ; TAB2 for i = 1 to ind inclusive ; TAB3 increment y by p ; TAB3 set A [ make pair from x , y ] to k ; TAB2 increment k ; TAB2 increment ind ; TAB2 set value of p to - 1 ; TAB1 create integers a , b ; TAB1 read a read b ; TAB1 print A [ make pair from a , b ] print newline ;	map < pair < int , int > , int > A ; int main ( ) { int x = 0 , y = 0 , k = 0 , p = 1 , ind = 1 ; while ( x <= 100 or y <= 100 ) { for ( int i = 1 ; i <= ind ; i ++ ) { x += p ; A [ make_pair ( x , y ) ] = k ; } k ++ ; for ( int i = 1 ; i <= ind ; i ++ ) { y += p ; A [ make_pair ( x , y ) ] = k ; } k ++ ; ind ++ ; p *= - 1 ; } int a , b ; cin >> a >> b ; cout << A [ make_pair ( a , b ) ] << endl ; }
TAB1 y , k , n = integers ; TAB1 read y , k , n ; TAB1 x = integers x = k - y ; TAB1 while x < 1 , x = x + k ; TAB1 if x + y > n ; TAB2 print - 1 ; TAB1 else ; TAB2 print x ; TAB2 while x + y + k < = n ; TAB3 print ' ' , x + k ; TAB3 x = x + k ; TAB2 print new line ;	int main ( ) { int y , k , n ; cin >> y >> k >> n ; int x = k - y ; while ( x < 1 ) { x += k ; } if ( x + y > n ) cout << - 1 << endl ; else { cout << x ; while ( x + y + k <= n ) { cout << '   ' << x + k ; x += k ; } cout << endl ; } return 0 ; }
TAB1 n , m , k , l = long long int ; TAB1 read n , m , k , l ; TAB1 if m > n or l > n - k ; TAB2 print - 1 ; TAB1 x = long long int ; TAB1 if ( k + l ) % m = 0 ; TAB2 let x = ( k + 1 ) / m ; TAB1 else ; TAB2 let x = ( k + 1 ) / m + 1 ; TAB1 if m * x > n ; TAB2 print - 1 ; TAB1 else ; TAB2 print x ;	int main ( ) { long long int n , m , k , l ; cin >> n >> m >> k >> l ; if ( m > n || l > n - k ) { cout << - 1 << " \n " ; return 0 ; } long long int x ; if ( ( k + l ) % m == 0 ) x = ( k + l ) / m ; else x = ( k + l ) / m + 1 ; if ( m * x > n ) { cout << - 1 << " \n " ; } else { cout << x << " \n " ; } return 0 ; }
TAB1 declare integer n ; TAB1 read n ; TAB1 if n mod 2 ; TAB2 print ( n - 1 ) / 2 ; TAB1 else ; TAB2 print ( n - ( 1 < < ( 31 - __builtin_clz ( n ) ) ) ) / 2 ;	int main ( ) { int n ; cin >> n ; if ( n % 2 ) cout << ( n - 1 ) / 2 << endl ; else cout << ( n - ( 1 << ( 31 - __builtin_clz ( n ) ) ) ) / 2 << endl ; return 0 ; }
TAB1 x , y = integers ; TAB1 while x and y can be read with valid values for integers ; TAB2 if x is 0 and y is 0 ; TAB3 print 0 ; TAB3 continue ; TAB2 r = integer = the max value of the absolute value of x and the absolute of y and the result minus 1 ; TAB2 ans = integer = r * 4 ; TAB2 if x - y > = 0 and x + y - 1 > 0 ; TAB3 ans = r * 4 + 1 ; TAB2 else if x - y < 0 and x + y > = 0 ; TAB3 ans = r * 4 + 2 ; TAB2 else if x - y < = 0 and x + y < 0 ; TAB3 ans = r * 4 + 3 ; TAB2 else if x - y > 0 and x + y - 1 < 0 ; TAB3 ans = r * 4 + 4 ; TAB2 print ans ;	int main ( ) { int x , y ; while ( cin >> x >> y ) { if ( x == 0 && y == 0 ) { cout << 0 << endl ; continue ; } int r = max ( abs ( x ) , abs ( y ) ) - 1 ; int ans = r * 4 ; if ( x - y >= 0 && x + y - 1 > 0 ) ans = r * 4 + 1 ; else if ( x - y < 0 && x + y >= 0 ) ans = r * 4 + 2 ; else if ( x - y <= 0 && x + y < 0 ) ans = r * 4 + 3 ; else if ( x - y > 0 && x + y - 1 < 0 ) ans = r * 4 + 4 ; cout << ans << endl ; } }
TAB0 let len , a be integers with a = array of of integers of length 26 ; TAB0 let str be a string ; TAB1 read len , str ; TAB1 for i = 0 to len exclusive , increment a [ str [ i ] - a ] by 1 ; TAB1 if len is equal to 1 or a [ max_element ( a , a + 26 ) - a ] > = 2 ; TAB2 print Yes and newline ; TAB1 else do the following ; TAB2 print No and newline ;	int len , a [ 26 ] ; string str ; int main ( ) { cin >> len >> str ; for ( int i = 0 ; i < len ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; if ( len == 1 || a [ max_element ( a , a + 26 ) - a ] >= 2 ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB1 n , i , j = long long ; TAB1 read n ; TAB1 a = vector of n string ; TAB1 for i = 0 to n exclusive read a [ i ] ; TAB1 b = vector of n string ; TAB1 for i = 0 to n exclusive read b [ i ] ; TAB1 for ti = 0 to 4 exclusive ; TAB2 c = vector of n string ; TAB2 c = b ; TAB2 for i = 0 to n exclusive ; TAB3 fpr j = 0 to n exclusive c [ j ] [ n - 1 - i ] = b [ i ] [ j ] ; TAB2 b = c ; TAB2 d = vector of n string ; TAB2 d = b ; TAB2 for i = 0 to n exclusive d [ i ] = b [ n - 1 - i ] ; TAB2 if a is c or d ; TAB3 print Yes ; TAB1 print No ;	int main ( ) { long long n , i , j ; cin >> n ; vector < string > a ( n ) ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; vector < string > b ( n ) ; for ( i = 0 ; i < n ; i ++ ) cin >> b [ i ] ; for ( long long ti = 0 ; ti < 4 ; ti ++ ) { vector < string > c ( n ) ; c = b ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { c [ j ] [ n - 1 - i ] = b [ i ] [ j ] ; } } b = c ; vector < string > d ( n ) ; d = b ; for ( i = 0 ; i < n ; i ++ ) d [ i ] = b [ n - 1 - i ] ; if ( a == c || a == d ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; }
TAB1 set int n , sum to 0 ; TAB1 create an integer vector v ; TAB1 set character mark to value of + ; TAB1 if mark is not equal to = then do the following ; TAB2 if mark is + then do ; TAB3 set the push_back value of v to 1 ; TAB3 add one to sum ; TAB2 if mark is - then do ; TAB3 set the push_back value of v to - 1 ; TAB3 minus 1 from sum ; TAB2 take input mark ; TAB1 read n ; TAB1 for i = 0 to less than or equal to v . size ( ) - 1 do the following ; TAB2 if sum is greater than n then do ; TAB3 if v [ i ] is less than 0 then do ; TAB4 if sum - n is less than or equal to n - 1 then do ; TAB5 subtract sum - n from v [ i ] ; TAB5 set sum to n ; TAB5 break ; TAB4 else ; TAB5 subtract n - 1 from v [ i ] ; TAB5 subtract n - 1 from sum ; TAB2 else if the sum is less than n ; TAB3 if v [ i ] is greater than 0 then do ; TAB4 if n - sum is less than or equal to n - 1 then do ; TAB5 v [ i ] equals v [ i ] plus n - sum ; TAB5 set sum to n ; TAB5 break ; TAB4 else ; TAB5 v [ i ] equals v [ i ] plus n - 1 ; TAB5 sum equals sum plus n - 1 ; TAB2 else ; TAB3 break ; TAB1 if sum is n then do ; TAB2 output Possible ; TAB2 output v [ 0 ] ; TAB2 for i = 1 to less than or equal to v . size ( ) - 1 do the following ; TAB3 if v [ i ] is greater than 0 then do ; TAB4 output + ; TAB3 else ; TAB4 output - ; TAB3 output the absolute value of v [ i ] ; TAB2 output = n ; TAB1 else ; TAB2 output Impossible ;	int main ( ) { int n , sum = 0 ; vector < int > v ; char mark = ' + ' ; while ( mark != ' = ' ) { if ( mark == ' + ' ) { v . push_back ( 1 ) ; sum ++ ; } if ( mark == ' - ' ) { v . push_back ( - 1 ) ; sum -- ; } cin >> mark ; } cin >> n ; for ( int i = 0 ; i <= v . size ( ) - 1 ; i ++ ) { if ( sum > n ) { if ( v [ i ] < 0 ) { if ( sum - n <= n - 1 ) { v [ i ] -= sum - n ; sum = n ; break ; } else { v [ i ] -= n - 1 ; sum -= n - 1 ; } } } else if ( sum < n ) { if ( v [ i ] > 0 ) { if ( n - sum <= n - 1 ) { v [ i ] += n - sum ; sum = n ; break ; } else { v [ i ] += n - 1 ; sum += n - 1 ; } } } else break ; } if ( sum == n ) { cout << " Possible " << endl ; cout << v [ 0 ] << "   " ; for ( int i = 1 ; i <= v . size ( ) - 1 ; i ++ ) { if ( v [ i ] > 0 ) cout << " +  " ; else cout << " -  " ; cout << abs ( v [ i ] ) << "   " ; } cout << " =  " << n << endl ; } else cout << " Impossible " << endl ; return 0 ; }
TAB1 create integers n , m , len , i and mark with mark = 0 ; TAB1 let str be a string ; TAB1 read n , m and str ; TAB1 set len to length of str ; TAB1 for i = n - 1 to 0 inclusive ; TAB2 if substr ( 0 , i ) of str is equal to substr ( n - i , n ) of str ; TAB3 set mark to i ; TAB3 break ; TAB1 print str ; TAB1 for m - 1 iterations print substr ( mark ) of str ; TAB1 print newline ;	int main ( ) { int n , m , len , i , mark = 0 ; string str ; cin >> n >> m >> str ; len = str . length ( ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str . substr ( 0 , i ) == str . substr ( n - i , n ) ) { mark = i ; break ; } } cout << str ; for ( i = 1 ; i < m ; i ++ ) { cout << str . substr ( mark ) ; } cout << endl ; return 0 ; }
TAB0 let N be a constant integer with N = 300009 ; TAB1 let n be a integer ; TAB1 read n ; TAB1 dp = 2d array of integers with 26 rows and 26 columns ; TAB1 for i = 0 to 26 exclusive ; TAB2 for j = 0 to 26 exclusive , dp [ i ] [ j ] is equal to 0 ; TAB1 s = array of strings of length n ; TAB1 for i = 0 to n exclusive ; TAB2 read s [ i ] ; TAB2 let sz be a integer with sz = length of s [ i ] ; TAB2 let last_later be a integer with last_later = s [ i ] [ sz - 1 ] - a ; TAB2 let first_later be a integer with first_later = s [ i ] [ 0 ] - a ; TAB2 for j = 0 to 26 exclusive ; TAB3 if dp [ j ] [ first_later ] is greater than 0 or j is equal to first_later , dp [ j ] [ last_later ] = maximum of dp [ j ] [ last_later ] and dp [ j ] [ first_later ] + sz ; TAB1 let res be a long integer with res = 0 ; TAB1 for i = 0 to 26 exclusive , res = maximum of res and ( long long ) dp [ i ] [ i ] ; TAB1 print res and newline ;	const int N = 300009 ; int main ( ) { int n ; cin >> n ; int dp [ 26 ] [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) dp [ i ] [ j ] = 0 ; } string s [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ] ; int sz = s [ i ] . length ( ) ; int last_later = s [ i ] [ sz - 1 ] - ' a ' ; int first_later = s [ i ] [ 0 ] - ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( dp [ j ] [ first_later ] > 0 || j == first_later ) { dp [ j ] [ last_later ] = max ( dp [ j ] [ last_later ] , dp [ j ] [ first_later ] + sz ) ; } } } long long res = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res = max ( res , ( long long ) dp [ i ] [ i ] ) ; } cout << res << endl ; return 0 ; }
TAB0 let maxn be const int with maxn = 1e4 + 10 ; TAB0 let mp be map from string to int ; TAB0 let a , b , c be strings ; TAB1 set mp [ " C " ] to 1 ; TAB1 set mp [ " C # " ] to 2 ; TAB1 set mp [ " D " ] to 3 ; TAB1 set mp [ " D # " ] to 4 ; TAB1 set mp [ " E " ] to 5 ; TAB1 set mp [ " F " ] to 6 ; TAB1 set mp [ " F # " ] to 7 ; TAB1 set mp [ " G " ] to 8 ; TAB1 set mp [ " G # " ] to 9 ; TAB1 set mp [ " A " ] to 10 ; TAB1 set mp [ " B " ] to 11 ; TAB1 set mp [ " H " ] to 12 ; TAB1 read a , b , c ; TAB1 if mp [ a ] > mp [ b ] , call swap of a , b ; TAB1 if mp [ a ] > mp [ c ] , call swap of a , c ; TAB1 if mp [ b ] > mp [ c ] , call swap of b , c ; TAB1 for i = 1 to 100 inclusive ; TAB2 if ( mp [ b ] - mp [ a ] = = 4 and mp [ c ] - mp [ b ] = = 3 ; TAB3 print major ; TAB2 else if mp [ b ] - mp [ a ] = = 3 and mp [ c ] - mp [ b ] = = 4 ; TAB3 print minor ; TAB2 else ; TAB3 update mp [ a ] to mp [ a ] + 12 ; TAB3 let tem be string with tem = a ; TAB3 set a to b ; TAB3 set b to c ; TAB3 set c to tem ; TAB1 print strange ;	const int maxn = 1e4 + 10 ; map < string , int > mp ; string a , b , c ; int main ( ) { mp [ " C " ] = 1 ; mp [ " C# " ] = 2 ; mp [ " D " ] = 3 ; mp [ " D# " ] = 4 ; mp [ " E " ] = 5 ; mp [ " F " ] = 6 ; mp [ " F# " ] = 7 ; mp [ " G " ] = 8 ; mp [ " G# " ] = 9 ; mp [ " A " ] = 10 ; mp [ " B " ] = 11 ; mp [ " H " ] = 12 ; cin >> a >> b >> c ; if ( mp [ a ] > mp [ b ] ) swap ( a , b ) ; if ( mp [ a ] > mp [ c ] ) swap ( a , c ) ; if ( mp [ b ] > mp [ c ] ) swap ( b , c ) ; for ( int i = 1 ; i <= 100 ; i ++ ) { if ( mp [ b ] - mp [ a ] == 4 && mp [ c ] - mp [ b ] == 3 ) { cout << " major " << endl ; return 0 ; } else if ( mp [ b ] - mp [ a ] == 3 && mp [ c ] - mp [ b ] == 4 ) { cout << " minor " << endl ; return 0 ; } else { mp [ a ] += 12 ; string tem = a ; a = b ; b = c ; c = tem ; } } cout << " strange " << endl ; return 0 ; }
TAB1 create boolean f ; TAB1 create list of strings res ; TAB1 create list iterator it ; TAB1 declare string array arr with size 21 ; TAB1 declare string array ar with size 21 ; TAB1 declare doubles array a with size 21 ; TAB1 declare long long array aa with size 21 ; TAB1 declare ints n , m and z ; TAB1 create double k ; TAB1 read input to n and m ; TAB1 read input to k ; TAB1 loop i from 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 read a [ i ] ; TAB2 push arr [ i ] to res ; TAB1 for i = 0 to n exclusive ; TAB2 assign k * a [ i ] to a [ i ] ; TAB2 if a [ i ] is less than 100 ; TAB3 set a [ i ] to 0 ; TAB3 remove arr [ i ] from res ; TAB2 assign a [ i ] to aa [ i ] ; TAB1 for i from 0 to m exclusive ; TAB2 read ar [ i ] ; TAB2 push ar [ i ] to res ; TAB1 sort res ; TAB1 remove duplicates from res ; TAB1 assign length of res to z ; TAB1 print z ; TAB1 move it through res ; TAB2 assign 0 to f ; TAB2 print value at it and " " ; TAB2 for integer i = 0 to n exclusive ; TAB3 if value at it = arr [ i ] and f is equal to 0 ; TAB4 create int y = a [ i ] ; TAB4 if y = 8177 or y = 115 or y = 231 or y = 434 or y = 463 or y = 492 , increment y by one ; TAB4 print y ; TAB4 change f to 1 ; TAB2 if f = 0 , print " 0 " ;	int main ( ) { bool f ; list < string > res ; list < string > :: iterator it ; string arr [ 21 ] ; string ar [ 21 ] ; double a [ 21 ] ; long long aa [ 21 ] ; int n , m , z ; double k ; cin >> n >> m ; cin >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; cin >> a [ i ] ; res . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = k * a [ i ] ; if ( a [ i ] < 100 ) { a [ i ] = 0 ; res . remove ( arr [ i ] ) ; } aa [ i ] = a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { cin >> ar [ i ] ; res . push_back ( ar [ i ] ) ; } res . sort ( ) ; res . unique ( ) ; z = res . size ( ) ; cout << z << endl ; for ( it = res . begin ( ) ; it != res . end ( ) ; it ++ ) { f = 0 ; cout << * it << "   " ; for ( int i = 0 ; i < n ; i ++ ) if ( * it == arr [ i ] && f == 0 ) { int y = ( int ) a [ i ] ; if ( y == 8177 || y == 115 || y == 231 || y == 434 || y == 463 || y == 492 ) y ++ ; cout << y << endl ; f = 1 ; } if ( f == 0 ) cout << " 0 " << endl ; } }
TAB1 declare boolean flag ; TAB1 declare integer variables i and n ; TAB1 declare string str ; TAB1 create integer arrays a with size 5 and b with size 100005 ; TAB1 create int ans = 0 ; TAB1 set sizeof ( a ) bytes at the pointer a to 0 ; TAB1 read str ; TAB1 change n to length of str ; TAB1 change flag to false ; TAB1 for i = 0 to n exclusive ; TAB2 if str [ i ] is equal to ' # ' ; TAB3 increment a [ 1 ] by one ; TAB3 if a [ 3 ] + a [ 1 ] > a [ 2 ] or i = 0 , change flag to true ; TAB3 assign a [ 2 ] - a [ 3 ] + 1 to ans ; TAB2 else if str [ i ] = ' ( ' ; TAB3 increment a [ 2 ] ; TAB3 if i = n - 1 or a [ 3 ] + a [ 1 ] > a [ 2 ] , set flag to true ; TAB2 else ; TAB3 increment a [ 3 ] ; TAB3 if a [ 3 ] + a [ 1 ] > a [ 2 ] or i = 0 , change flag to true ; TAB1 if ans is less than a [ 2 ] - a [ 3 ] + 1 , assign true to flag ; TAB1 if flag is true ; TAB2 print - 1 ; TAB1 for i from 1 to a [ 1 ] exclusive , print 1 ; TAB1 print a [ 2 ] - a [ 3 ] - a [ 1 ] + 1 ;	int main ( ) { bool flag ; int i , n ; string str ; int a [ 5 ] , b [ 100005 ] ; int ans = 0 ; memset ( a , 0 , sizeof ( a ) ) ; cin >> str ; n = str . length ( ) ; flag = false ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' # ' ) { a [ 1 ] ++ ; if ( a [ 3 ] + a [ 1 ] > a [ 2 ] || i == 0 ) flag = true ; ans = a [ 2 ] - a [ 3 ] + 1 ; } else if ( str [ i ] == ' ( ' ) { a [ 2 ] ++ ; if ( i == n - 1 || a [ 3 ] + a [ 1 ] > a [ 2 ] ) flag = true ; } else { a [ 3 ] ++ ; if ( a [ 3 ] + a [ 1 ] > a [ 2 ] || i == 0 ) flag = true ; } } if ( ans < a [ 2 ] - a [ 3 ] + 1 ) { flag = true ; } if ( flag ) { cout << - 1 << endl ; return 0 ; } for ( i = 1 ; i < a [ 1 ] ; i ++ ) { cout << 1 << endl ; } cout << a [ 2 ] - a [ 3 ] - a [ 1 ] + 1 << endl ; }
TAB0 nr , pd = long long ; TAB1 read nr ; TAB1 f2p = 1 ; TAB1 nrr = 0 ; TAB1 pd = 0 ; TAB1 for i = 2 to sqrt ( nr ) inclusive ; TAB2 while nr modulo i not zero ; TAB3 if nrr < 2 increment nrr , multiply f2p by i ; TAB3 divide nr by i ; TAB3 increment pd ; TAB1 if nr > 1 increment pd ; TAB1 if pd < = 1 ; TAB2 print 2 ; TAB2 print 0 ; TAB1 else if pd is 2 ; TAB2 print 2 ; TAB1 else ; TAB2 print 1 ; TAB2 print f2p ;	long long nr , pd ; int main ( ) { cin >> nr ; long long f2p = 1 ; int nrr = 0 ; int pd = 0 ; for ( long long i = 2 ; i * i <= nr ; ++ i ) { while ( nr % i == 0 ) { if ( nrr < 2 ) ++ nrr , f2p *= i ; nr /= i ; ++ pd ; } } if ( nr > 1 ) ++ pd ; if ( pd <= 1 ) { cout << 1 << ' \n ' ; cout << 0 << ' \n ' ; } else if ( pd == 2 ) { cout << 2 << ' \n ' ; } else { cout << 1 << ' \n ' ; cout << f2p << ' \n ' ; } return 0 ; }
TAB1 create int n , x1 , x2 , y1 , y2 ; TAB1 read n , x1 , x2 , y1 and y2 ; TAB1 set sum1 = 100000 and sum2 to 1000000 ; TAB1 if abs of x1 - x2 = n or abs of y1 - y2 equal to n ; TAB2 assign x1 + x2 + y1 + y2 to sum1 ; TAB2 sum2 = n - x1 + n - x2 + n - y1 + n - y2 ; TAB1 else ; TAB2 set sum1 = abs of y1 - y2 + abs of x1 - x2 ; TAB1 print min of sum1 and sum2 ;	int main ( ) { int n , x1 , x2 , y1 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; int sum1 = 100000 , sum2 = 1000000 ; if ( abs ( x1 - x2 ) == n || abs ( y1 - y2 ) == n ) { sum1 = x1 + x2 + y1 + y2 ; sum2 = n - x1 + n - x2 + n - y1 + n - y2 ; } else { sum1 = abs ( y1 - y2 ) + abs ( x1 - x2 ) ; } cout << min ( sum1 , sum2 ) << endl ; return 0 ; }
TAB1 create string t ; TAB1 create int k ; TAB1 read k and k ; TAB1 read t ; TAB1 w = 0 ; TAB1 for i = 0 to size of t exclusive ; TAB2 set b to true ; TAB2 for j = 0 to size of t exclusiveand for j = 0 to i exclusive ; TAB3 if t [ j ] different from t [ size of t - i + j ] , set b to false ; TAB2 if b is true , set w = 1 ; TAB1 for i = 0 to k exclusive ; TAB2 for j = 0 to size of t - w exclusive , print t [ j ] ; TAB1 for i = size of t - w to size of t exclusive , print t [ i ] ; TAB1 print a newline ;	int main ( ) { string t ; int k ; cin >> k >> k ; cin >> t ; int w = 0 ; for ( int i = 0 ; i < t . size ( ) ; i ++ ) { bool b = true ; for ( int j = 0 ; j < t . size ( ) && j < i ; j ++ ) { if ( t [ j ] != t [ t . size ( ) - i + j ] ) { b = false ; } } if ( b ) { w = i ; } } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < t . size ( ) - w ; j ++ ) { cout << t [ j ] ; } } for ( int i = t . size ( ) - w ; i < t . size ( ) ; i ++ ) { cout << t [ i ] ; } cout << endl ; return 0 ; }
TAB1 declare long long n ; TAB1 read n ; TAB1 if n is 0 ; TAB2 print 1 , newline ; TAB1 if ( n - 1 ) % 4 is 0 ; TAB2 print 8 , newline ; TAB1 else if ( n - 2 ) % 4 is 0 ; TAB2 print 4 , newline ; TAB1 else if ( n - 3 ) % 4 is 0 ; TAB2 print 2 , newline ; TAB1 else if ( n - 4 ) % 4 is 0 ; TAB2 print 6 , newline ;	int main ( ) { long long n ; cin >> n ; if ( n == 0 ) { cout << 1 << endl ; return 0 ; } if ( ( n - 1 ) % 4 == 0 ) { cout << 8 << endl ; } else if ( ( n - 2 ) % 4 == 0 ) { cout << 4 << endl ; } else if ( ( n - 3 ) % 4 == 0 ) cout << 2 << endl ; else if ( ( n - 4 ) % 4 == 0 ) cout << 6 << endl ; }
TAB1 i , j , k , cnt , n = integers with cnt = 0 ; TAB1 s = string ; TAB1 Read n ; TAB1 Read s ; TAB1 set i to 0 ; TAB1 while s [ i ] is equal to < ; TAB2 if i is equal to n , then Terminate the loop ; TAB2 increment cnt ; TAB2 increment i ; TAB1 set j to n - 1 ; TAB1 while s [ j ] is equal to > ; TAB2 if j is equal to - 1 , then Terminate the loop ; TAB2 increment cnt ; TAB2 decrement j ; TAB1 print cnt and a new line ;	int main ( ) { int i , j , k , cnt = 0 , n ; string s ; cin >> n ; cin >> s ; i = 0 ; while ( s [ i ] == ' < ' ) { if ( i == n ) { break ; } cnt ++ ; i ++ ; } j = n - 1 ; while ( s [ j ] == ' > ' ) { if ( j == - 1 ) break ; cnt ++ ; j -- ; } cout << cnt << endl ; return 0 ; return 0 ; }
TAB1 x , t , a , b , da , db , first , second = int ; TAB1 read x , t , a , b , da , db ; TAB1 ouput = " NO " = string ; TAB1 if x = 0 then set output to " YES " ; TAB1 for first = 0 , until first < a / da exclusive and first < t , increment first ; TAB2 if output = " YES " exit loop ; TAB2 for second = 0 , until second < b / db and second < t , increment second ; TAB3 if da * first = a - x ; TAB4 set output to " YES " ; TAB4 exit loop ; TAB3 if db * second = b - x ; TAB4 set output to " YES " ; TAB4 exit loop ; TAB3 if da * first + db * second = a + b - x ; TAB4 set output to " YES " ; TAB4 exit loop ; TAB3 if db * first + da * second = a + b - x ; TAB4 set output to " YES " ; TAB4 exit loop ; TAB1 print output ;	int main ( ) { int x , t , a , b , da , db , first , second ; cin >> x >> t >> a >> b >> da >> db ; string output = " NO " ; if ( x == 0 ) { output = " YES " ; } for ( first = 0 ; first < a / da && first < t ; first ++ ) { if ( output == " YES " ) { break ; } for ( second = 0 ; second < b / db && second < t ; second ++ ) { if ( da * first == a - x ) { output = " YES " ; break ; } if ( db * second == b - x ) { output = " YES " ; break ; } if ( da * first + db * second == a + b - x ) { output = " YES " ; break ; } if ( db * first + da * second == a + b - x ) { output = " YES " ; break ; } } } cout << output << endl ; return 0 ; }
TAB0 create maps of int to int M and H ; TAB0 declare integer variable len = 0 and integer arrays arr and vis with 100010 elements ; TAB0 create integers vector array V with 100010 elements ; TAB0 dfs is a void function with int argument u ; TAB1 if vis [ u ] is true , return ; TAB1 set vis [ u ] to 1 ; TAB1 increment len ; TAB1 for i = 0 to length of V [ u ] exclusive , call dfs ( V [ u ] [ i ] ) ; TAB1 declare int variables n , k and ans where ans = 0 ; TAB1 read input to n and k ; TAB1 loop i from 1 to n inclusive ; TAB2 read arr [ i ] ; TAB2 increment M [ arr [ i ] ] ; TAB1 sort arr from index 1 to 1 + n ; TAB1 loop i from 1 to n inclusive ; TAB2 set value of H [ arr [ i ] ] to i ; TAB2 if M [ arr [ i ] / k ] ! = 0 and arr [ i ] % k = 0 , push H [ arr [ i ] ] to V [ H [ arr [ i ] / k ] ] ; TAB1 for i = 1 to n inclusive ; TAB2 if vis [ H [ arr [ i ] ] ] = 0 ; TAB3 change len to 0 ; TAB3 call function dfs with argument H [ arr [ i ] ] ; TAB3 increase ans by len / 2 ; TAB3 if len & 1 ! = 0 , increment ans ; TAB1 print ans ;	map < int , int > M , H ; int arr [ 100010 ] , vis [ 100010 ] , len = 0 ; vector < int > V [ 100010 ] ; void dfs ( int u ) { if ( vis [ u ] ) return ; vis [ u ] = 1 ; len ++ ; for ( int i = 0 ; i < V [ u ] . size ( ) ; i ++ ) { dfs ( V [ u ] [ i ] ) ; } } int main ( ) { int n , k , ans = 0 ; cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> arr [ i ] ; M [ arr [ i ] ] ++ ; } sort ( arr + 1 , arr + 1 + n ) ; for ( int i = 1 ; i <= n ; i ++ ) { H [ arr [ i ] ] = i ; if ( M [ arr [ i ] / k ] && arr [ i ] % k == 0 ) V [ H [ arr [ i ] / k ] ] . push_back ( H [ arr [ i ] ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) if ( ! vis [ H [ arr [ i ] ] ] ) { len = 0 ; dfs ( H [ arr [ i ] ] ) ; ans += ( len / 2 ) ; if ( len & 1 ) ans ++ ; } cout << ans << endl ; return 0 ; }
TAB1 declare integer l ; TAB1 read l ; TAB1 declare integer array md size 4 = { 8 , 4 , 2 , 6 } ; TAB1 if l is 0 ; TAB2 print " 1 " , newline ; TAB1 else ; TAB2 print md [ ( l - 1 ) % 4 ] and newline ;	int main ( ) { int l ; cin >> l ; int md [ 4 ] = { 8 , 4 , 2 , 6 } ; if ( l == 0 ) { cout << " 1 " << endl ; } else { cout << md [ ( l - 1 ) % 4 ] << endl ; } return 0 ; }
TAB0 create int variables n and m ; TAB0 declare integer variable called menor ; TAB1 read from the input to n and m ; TAB1 set menor to INT_MAX ; TAB1 start for loop from i = 0 to m exclusive ; TAB2 declare int variables a and b ; TAB2 read standard input to a and b ; TAB2 assign the new value = min of menor and b - a + 1 to menor ; TAB1 print menor and " \ n " ; TAB1 print " 0 " ; TAB1 for i = 1 to n exclusive , print " " and i % menor to the standard output ; TAB1 print " \ n " to the standard output ;	int n , m ; int menor ; int main ( ) { cin >> n >> m ; menor = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { int a , b ; cin >> a >> b ; menor = min ( menor , b - a + 1 ) ; } cout << menor << " \n " ; cout << " 0 " ; for ( int i = 1 ; i < n ; i ++ ) { cout << "   " << i % menor ; } cout << " \n " ; return 0 ; }
TAB1 n and k are integers ; TAB1 read n and k ; TAB1 s is a string ; TAB1 alfa is a character vector of size 26 ; TAB1 for i = 0 to integer value 26 exclusive , set alfa [ i ] to character value ( ( integer value of character a ) + i ) ; TAB1 cont = integer = 0 ; TAB1 for i = 0 to integer value n exclusive ; TAB2 add alfa [ cont ] to s ; TAB2 increment cont ; TAB2 if cont equals 26 or cont equals k , set cont to 0 ; TAB1 display s ;	int main ( ) { int n , k ; cin >> n >> k ; string s ; vector < char > alfa ( 26 ) ; for ( int i = 0 ; i < int ( 26 ) ; i ++ ) alfa [ i ] = char ( int ( ' a ' ) + i ) ; int cont = 0 ; for ( int i = 0 ; i < int ( n ) ; i ++ ) { s += alfa [ cont ] ; cont ++ ; if ( cont == 26 or cont == k ) cont = 0 ; } cout << s << endl ; return 0 ; }
TAB0 let inf be const int with inf = 0x3f3f3f3f ; TAB0 let maxn be const int with maxn = 110 ; TAB0 define max which takes integers a and b as arguments and returns int ; TAB1 if a is greater than b , return a else return b ; TAB0 define min which takes integers a and b as arguments and returns int ; TAB1 if a is greater than b , return b else return a ; TAB0 a = array of integers of size maxn ; TAB1 let i , n be integers ; TAB1 while input is available , read n ; TAB2 set a [ 0 ] to 0 and a [ n + 1 ] to 1001 ; TAB2 for i = 1 to n inclusive , read a [ i ] ; TAB2 let l be integer ; TAB2 let maxi be integer with maxi = 1 ; TAB2 for l = 0 to n inclusive ; TAB3 let pos be integer with pos = 1 ; TAB3 while l is less than or equal to n and a [ l ] + 1 is equal to a [ l + 1 ] , increment l ; TAB3 if l - pos + 1 is greater than maxi , set maxi to l - pos + 1 ; TAB2 if maxi is equal to 1 ; TAB3 print out 0 with newline ; TAB2 else ; TAB3 print maxi - 2 with newline ;	const int inf = 0x3f3f3f3f ; const int maxn = 110 ; int max ( int a , int b ) { return a > b ? a : b ; } int min ( int a , int b ) { return a > b ? b : a ; } int a [ maxn ] ; int main ( ) { int i , n ; while ( cin >> n ) { a [ 0 ] = 0 , a [ n + 1 ] = 1001 ; for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; int l ; int maxi = 1 ; for ( l = 0 ; l <= n ; l ++ ) { int pos = l ; while ( l <= n && a [ l ] + 1 == a [ l + 1 ] ) { l ++ ; } if ( l - pos + 1 > maxi ) { maxi = l - pos + 1 ; } } if ( maxi == 1 ) cout << " 0 " << endl ; else cout << maxi - 2 << endl ; } return 0 ; }
TAB1 n , m = long long ; TAB1 read n , m ; TAB1 a , index = integers with a = array of size n ; TAB1 max = integer with max = INT_MIN ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 val = double with val = ceil ( a [ 0 ] / m ) ; TAB1 for i = 0 to n exclusive ; TAB2 val = ceil of double ( a [ i ] ) / double ( m ) ; TAB2 if ( max < = val ) ; TAB3 index = i + 1 ; TAB3 max = val ; TAB1 print index ;	int main ( ) { long long n , m ; cin >> n >> m ; int a [ n ] , index ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } double val = ceil ( a [ 0 ] / m ) ; for ( int i = 0 ; i < n ; i ++ ) { val = ceil ( double ( a [ i ] ) / double ( m ) ) ; if ( max <= val ) { index = i + 1 ; max = val ; } } cout << index << " \n " ; }
TAB0 n = int and dp = two dimensional int array of sizes 30 and 30 ; TAB0 a = string array of size 500000 + 10 ; TAB1 read n ; TAB1 read n values into a ; TAB1 for i = 0 to n ; TAB2 u = int with u = a [ i ] [ 0 ] - ' a ' ; TAB2 v = int with v = a [ i ] [ size of a [ i ] - 1 ] - ' a ' ; TAB2 for j = 0 to 26 ; TAB3 if dp [ j ] [ u ] is 0 continue ; TAB3 set dp [ j ] [ v ] to max of dp [ j ] [ v ] , dp [ j ] [ u ] + size of a [ i ] as int ; TAB2 set dp [ u ] [ v ] to max of dp [ u ] [ v ] , size of a [ i ] as int ; TAB1 res = int with res = 0 ; TAB1 for i = 0 to 26 set res to max of res , dp [ i ] [ i ] ; TAB1 print res ;	int n , dp [ 30 ] [ 30 ] ; string a [ 500000 + 10 ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int u = a [ i ] [ 0 ] - ' a ' ; int v = a [ i ] [ a [ i ] . size ( ) - 1 ] - ' a ' ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( dp [ j ] [ u ] == 0 ) continue ; dp [ j ] [ v ] = max ( dp [ j ] [ v ] , dp [ j ] [ u ] + ( int ) a [ i ] . size ( ) ) ; } dp [ u ] [ v ] = max ( dp [ u ] [ v ] , ( int ) a [ i ] . size ( ) ) ; } int res = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res = max ( res , dp [ i ] [ i ] ) ; } cout << res << " \n " ; }
TAB0 declare new array of integers a with size 1005 ; TAB1 create integer variable n ; TAB1 read n and loop further ; TAB2 for i from 0 to n exclusive , read input to a [ i ] ; TAB2 create new integer variable ok with value 0 ; TAB2 start for loop from i = 1 to n exclusive ; TAB3 for j from 0 to n - 1 exclusive incrementing j ; TAB4 max1 is a new integer variable = max of a [ i - 1 ] and a [ i ] ; TAB4 declare integer min1 = min of a [ i - 1 ] and a [ i ] ; TAB4 create integer max2 = max of a [ j ] and a [ j + 1 ] ; TAB4 min2 is a new integer variable with value min of a [ j ] and a [ j + 1 ] ; TAB4 if min1 < min2 and max1 > min2 and max1 < max2 , change ok to 1 ; TAB2 if ok is not zero ; TAB3 print " yes " to the standard output ; TAB2 else ; TAB3 print " no " ;	int a [ 1005 ] ; int main ( ) { int n ; while ( cin >> n ) { for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } int ok = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { int max1 = max ( a [ i - 1 ] , a [ i ] ) ; int min1 = min ( a [ i - 1 ] , a [ i ] ) ; int max2 = max ( a [ j ] , a [ j + 1 ] ) ; int min2 = min ( a [ j ] , a [ j + 1 ] ) ; if ( min1 < min2 && max1 > min2 && max1 < max2 ) { ok = 1 ; } } } if ( ok ) cout << " yes " << endl ; else cout << " no " << endl ; } }
TAB0 declare integer n ; TAB0 declare new array of characters chair with size 10000 ; TAB1 read input to n ; TAB1 declare integer a ; TAB1 read ( chair + 1 ) from the input ; TAB1 set chair [ 0 ] to ' 0 ' ; TAB1 assign ' 0 ' to chair [ n + 1 ] ; TAB1 declare new integer called ans = 0 ; TAB1 if n is equal to 1 and chair [ 1 ] is equal to ' 0 ' ; TAB2 print " No " to the standard output ; TAB1 if n = 1 and chair [ 1 ] = ' 1 ' ; TAB2 print " Yes " ; TAB1 for i = 1 to n inclusive incrementing i ; TAB2 if chair [ i ] = ' 1 ' and ( chair [ i - 1 ] = ' 1 ' or chair [ i + 1 ] = ' 1 ' ) ; TAB3 assign 1 to ans ; TAB3 break the loop ; TAB2 if chair [ i ] = ' 0 ' ; TAB3 if chair [ i - 1 ] is ' 0 ' and chair [ i + 1 ] is ' 0 ' ; TAB4 change ans to 1 ; TAB4 break the loop ; TAB1 if ans is equal to 1 ; TAB2 print " No " ; TAB1 else ; TAB2 print " Yes " to the standard output ;	int n ; char chair [ 10000 ] ; int main ( ) { cin >> n ; int a ; cin >> ( chair + 1 ) ; chair [ 0 ] = ' 0 ' ; chair [ n + 1 ] = ' 0 ' ; int ans = 0 ; if ( n == 1 && chair [ 1 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } if ( n == 1 && chair [ 1 ] == ' 1 ' ) { cout << " Yes " << endl ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( chair [ i ] == ' 1 ' && ( chair [ i - 1 ] == ' 1 ' || chair [ i + 1 ] == ' 1 ' ) ) { ans = 1 ; break ; } if ( chair [ i ] == ' 0 ' ) { if ( chair [ i - 1 ] == ' 0 ' && chair [ i + 1 ] == ' 0 ' ) { ans = 1 ; break ; } } } if ( ans == 1 ) cout << " No " << endl ; else cout << " Yes " << endl ; }
TAB1 s = string ; TAB1 read s ; TAB1 a , b , c = strings ; TAB1 n = integers with n = s . size ( ) ; TAB1 mx = integer with mx = - 1 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = i + 2 to n exclusive ; TAB3 a = substr ( 0 , i + 1 ) of s ; TAB3 b = substr ( i + 1 , j - i - 1 ) of s ; TAB3 c = substr ( j , n - j + 1 ) of s ; TAB3 sum = integer with sum = 0 ; TAB3 if ( a [ 0 ] is 0 and a . size ( ) is not 1 ) , continue next iteration ; TAB3 if ( b [ 0 ] is 0 and b . size ( ) is not 1 ) , continue next iteration ; TAB3 if ( c [ 0 ] is 0 and c . size ( ) is not 1 ) , continue next iteration ; TAB3 if ( a . size ( ) > 7 ) , continue next iteration ; TAB3 if ( b . size ( ) > 7 ) , continue next iteration ; TAB3 if ( c . size ( ) > 7 ) , continue next iteration ; TAB3 if ( atoi ( a . c_str ( ) ) > 1000000 ) , continue next iteration ; TAB3 if ( atoi ( b . c_str ( ) ) > 1000000 ) , continue next iteration ; TAB3 if ( atoi ( c . c_str ( ) ) > 1000000 ) , continue next iteration ; TAB3 sum = sum + atoi ( a . c_str ( ) ) ; TAB3 sum = sum + atoi ( b . c_str ( ) ) ; TAB3 sum = sum + atoi ( c . c_str ( ) ) ; TAB3 mx = max of mx and sum ; TAB1 print mx ;	int main ( ) { string s ; cin >> s ; string a , b , c ; int n = s . size ( ) ; int mx = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 2 ; j < n ; ++ j ) { a = s . substr ( 0 , i + 1 ) ; b = s . substr ( i + 1 , j - i - 1 ) ; c = s . substr ( j , n - j + 1 ) ; int sum = 0 ; if ( a [ 0 ] == ' 0 ' && a . size ( ) != 1 ) continue ; if ( b [ 0 ] == ' 0 ' && b . size ( ) != 1 ) continue ; if ( c [ 0 ] == ' 0 ' && c . size ( ) != 1 ) continue ; if ( a . size ( ) > 7 ) continue ; if ( b . size ( ) > 7 ) continue ; if ( c . size ( ) > 7 ) continue ; if ( atoi ( a . c_str ( ) ) > 1000000 ) continue ; if ( atoi ( b . c_str ( ) ) > 1000000 ) continue ; if ( atoi ( c . c_str ( ) ) > 1000000 ) continue ; sum += atoi ( a . c_str ( ) ) ; sum += atoi ( b . c_str ( ) ) ; sum += atoi ( c . c_str ( ) ) ; mx = max ( mx , sum ) ; } } cout << mx << endl ; }
TAB1 create ints n and s ; TAB1 read from the input to n and s ; TAB1 declare ints x and y ; TAB1 declare integer min with value 101 ; TAB1 create new integer min2 with value 101 ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 read x and y from the input ; TAB2 if s > x and y < min and y > 0 ; TAB3 change min to y ; TAB2 else if s > = x and y = 0 ; TAB3 assign the new value = y to min2 ; TAB1 if min = 101 and min2 ! = 0 ; TAB2 print - 1 to the standard output ; TAB1 else if 100 - min < 100 and min ! = 101 ; TAB2 print 100 - min ; TAB1 else if 100 - min2 is equal to 100 ; TAB2 print 0 ;	int main ( ) { int n , s ; cin >> n >> s ; int x , y ; int min = 101 ; int min2 = 101 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> y ; if ( ( s > x ) && ( y < min ) && ( y > 0 ) ) min = y ; else if ( ( s >= x ) && ( y == 0 ) ) min2 = y ; } if ( ( min == 101 ) && ( min2 != 0 ) ) cout << - 1 << endl ; else if ( ( 100 - min < 100 ) && ( min != 101 ) ) cout << 100 - min << endl ; else if ( 100 - min2 == 100 ) cout << 0 << endl ; }
TAB1 create integers n , i , o , z , with o = 0 , z = 0 ; TAB1 read n ; TAB1 create integer array a with size n ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 if n is 1 ; TAB3 if a [ 0 ] is 1 ; TAB4 print " YES " print newline ; TAB3 else ; TAB4 print " NO " print newline ; TAB2 else ; TAB3 if a [ i ] is 0 ; TAB4 increment z ; TAB3 else ; TAB4 increment o ; TAB1 if n is greater than 1 ; TAB2 if ( z is greater than 1 and z is not 0 ) or o is n ; TAB3 print " NO " print newline ; TAB2 else ; TAB3 print " YES " print newline ;	int main ( ) { int n , i , o = 0 , z = 0 ; cin >> n ; int a [ n ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( n == 1 ) { if ( a [ 0 ] == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } else { if ( a [ i ] == 0 ) { z ++ ; } else { o ++ ; } } } if ( n > 1 ) { if ( ( z > 1 && z != 0 ) || o == n ) { cout << " NO " << endl ; } else { cout << " YES " << endl ; } } return 0 ; }
TAB1 declare integer n ; TAB1 read n ; TAB1 print n / 2 , newline ; TAB1 while n is not 2 and n is not 3 ; TAB2 print 2 , " " ; TAB2 decrement n by 2 ; TAB1 print n , newline ;	int main ( ) { int n ; cin >> n ; cout << n / 2 << endl ; while ( n != 2 && n != 3 ) { cout << 2 << "   " ; n -= 2 ; } cout << n << endl ; }
TAB1 integers = n , k ; TAB1 s = string array ; TAB1 read n , k , s ; TAB1 integers = id ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 set bool flag to true ; TAB2 for j = 0 to less than n do the following ; TAB3 if s [ j ] is not equal to s [ j + i ] then do the following ; TAB4 set flag to false ; TAB4 break ; TAB2 if flag is true ; TAB3 set id to i ; TAB3 break ; TAB1 s1 , s2 = string array ; TAB1 set s1 to s . substr ( 0 , id ) ; TAB1 set s2 to s . substr ( id ) ; TAB1 for i = 1 to less than or equal to k do the following ; TAB1 output s2 ; TAB1 output endl ;	int main ( ) { int n , k ; string s ; cin >> n >> k >> s ; int id ; for ( int i = 1 ; i <= n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j + i < n ; j ++ ) { if ( s [ j ] != s [ j + i ] ) { flag = false ; break ; } } if ( flag ) { id = i ; break ; } } string s1 , s2 ; s1 = s . substr ( 0 , id ) ; s2 = s . substr ( id ) ; for ( int i = 1 ; i <= k ; i ++ ) cout << s1 ; cout << s2 ; cout << endl ; }
TAB1 declare integer variable n ; TAB1 loop , reading n from the input ; TAB2 if n is equal to 0 ; TAB3 print 1 ; TAB3 break the loop ; TAB2 declare integer variable cnt = n modulo 4 ; TAB2 if cnt is equal to 1 ; TAB3 print 8 ; TAB2 else if cnt is equal to 2 ; TAB3 print 4 ; TAB2 else if cnt = 3 ; TAB3 print 2 ; TAB2 else if the value of cnt is 0 ; TAB3 print 6 to the standard output ;	int main ( ) { int n ; while ( cin >> n ) { if ( n == 0 ) { cout << 1 << endl ; break ; } int cnt = n % 4 ; if ( cnt == 1 ) cout << 8 << endl ; else if ( cnt == 2 ) cout << 4 << endl ; else if ( cnt == 3 ) cout << 2 << endl ; else if ( cnt == 0 ) cout << 6 << endl ; } return 0 ; }
TAB0 str = string ; TAB0 in function check with parameters integers x , y and return boolean ; TAB1 i and j are integers with i = x , j = y ; TAB1 while i is less than j ; TAB2 if str [ i ] equals str [ j ] ; TAB3 increment i ; TAB3 decrement j ; TAB2 else ; TAB3 return false ; TAB1 return true ; TAB1 k = integer ; TAB1 input str , k ; TAB1 len is an integer set to size of str ; TAB1 if len isn ' t divisible by k ; TAB2 output NO ; TAB1 assign len / k to k ; TAB1 assign 0 to i ; TAB1 while i is less than len ; TAB2 if not call check with i , i + k - 1 ; TAB3 output NO ; TAB2 add k to i ; TAB1 output YES ;	string str ; bool check ( int x , int y ) { int i = x , j = y ; while ( i < j ) { if ( str [ i ] == str [ j ] ) { i ++ ; j -- ; } else return false ; } return true ; } int main ( ) { int k ; cin >> str >> k ; int len = str . size ( ) ; if ( len % k != 0 ) { cout << " NO " << endl ; return 0 ; } k = len / k ; int i = 0 ; while ( i < len ) { if ( ! check ( i , i + k - 1 ) ) { cout << " NO " << endl ; return 0 ; } i += k ; } cout << " YES " << endl ; return 0 ; }
TAB1 create strings str1 and str2 ; TAB1 read str1 and str2 ; TAB1 declare int variable len1 = length of str1 ; TAB1 declare int variable len2 = length of str2 ; TAB1 if len1 ! = len2 ; TAB2 print " NO " ; TAB1 declare bool variable flag = false ; TAB1 declare integer variable f = 0 ; TAB1 for i = 0 to len1 exclusive ; TAB2 if str1 [ i ] ! = str2 [ i ] ; TAB3 if flag = false ; TAB4 assign i to f ; TAB4 set flag to true ; TAB3 else ; TAB4 swap str2 [ f ] and str2 [ i ] ; TAB4 break the loop ; TAB1 declare int variable temp = result of comparing str1 to str2 ; TAB1 if temp ! = 0 ; TAB2 print " NO " ; TAB1 else ; TAB2 print " YES " ;	int main ( ) { string str1 , str2 ; cin >> str1 >> str2 ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; if ( len1 != len2 ) { cout << " NO " << endl ; return 0 ; } bool flag = false ; int f = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) { if ( flag == false ) { f = i ; flag = true ; } else { swap ( str2 [ f ] , str2 [ i ] ) ; break ; } } } int temp = str1 . compare ( str2 ) ; if ( temp != 0 ) { cout << " NO " << endl ; } else { cout << " YES " << endl ; } return 0 ; }
TAB0 create a function isTriangular that accepts long integer n ; TAB1 r be a double integer and equals to the square root of 1 + ( n < < 3LL ) ; TAB1 if r = = floor ( r ) ; TAB2 long integer s equals long integer r ; TAB2 return s > 1LL and ( s - 1LL ) & 1LL = = 0 ; TAB1 return 0 ; TAB0 create a function sum that accepts long integer n ; TAB1 return ( n * ( n + 1 ) ) > > 1LL ; TAB1 let n be a long integer ; TAB1 while read n ; TAB2 let x be a long inter with x = 1 ; TAB2 let possible be a boolean value false ; TAB2 while n - sum of x is greater than 0 ; TAB3 let y be a long integer with y = n - sum of x ; TAB3 let m be a long integer ; TAB3 let l be a long integer with l = 1 ; TAB3 let r be a long integer with r = y ; TAB3 while l is less than r ; TAB4 shift bitwise the value of l + r by 1Ll ; TAB4 store sum of m in long integer fm ; TAB4 if fm is equal to y ; TAB5 possible is equal to true ; TAB5 stop ; TAB4 if fm is less than y ; TAB5 l is equal to m + 1 ; TAB4 else do the following ; TAB5 r is equal to m ; TAB3 if possible is 1 , stop ; TAB3 if sum ( x ) < < 1LL = = n ; TAB4 set possible to true ; TAB4 stop ; TAB3 increment x by 1 ; TAB2 if possible is 1 ; TAB3 print YES and new line ; TAB2 else ; TAB3 print NO and new line ;	inline bool isTriangular ( long long n ) { double r = sqrt ( ( double ) ( 1 + ( n << 3LL ) ) ) ; if ( r == floor ( r ) ) { long long s = ( long long ) r ; return s > 1LL and ( s - 1LL ) & 1LL == 0 ; } return false ; } inline long long sum ( long long n ) { return ( n * ( n + 1 ) ) >> 1LL ; } int main ( ) { long long n ; while ( cin >> n ) { long long x = 1 ; bool possible = false ; while ( n - sum ( x ) > 0 ) { long long y = n - sum ( x ) ; long long m ; long long l = 1 ; long long r = y ; while ( l < r ) { m = ( l + r ) >> 1LL ; long long fm = sum ( m ) ; if ( fm == y ) { possible = true ; break ; } if ( fm < y ) l = m + 1 ; else r = m ; } if ( possible ) break ; if ( ( sum ( x ) << 1LL ) == n ) { possible = true ; break ; } ++ x ; } if ( possible ) cout << " YES\n " ; else cout << " NO\n " ; } return 0 ; }
TAB1 n = integer ; TAB1 Read n ; TAB1 sum , x , mx , ans , a , b , c , d = integers with mx = 0 and ans = 1 ; TAB1 Read a , b , c , d ; TAB1 set x to a + b + c + d ; TAB1 for i = 1 to n exclusive ; TAB2 Read a , b , c , d ; TAB2 set sum to a + b + c + d ; TAB2 if sum is greater than x , then increment ans ; TAB1 if ans is 0 , then set ans to 1 ; TAB1 print ans and a new line ;	int main ( ) { int n ; cin >> n ; int sum , x , mx = 0 , ans = 1 , a , b , c , d ; cin >> a >> b >> c >> d ; x = a + b + c + d ; for ( int i = 1 ; i < n ; i ++ ) { cin >> a >> b >> c >> d ; sum = a + b + c + d ; if ( sum > x ) { ans ++ ; } } if ( ans == 0 ) ans = 1 ; cout << ans << endl ; return 0 ; }
TAB0 a = long long int array of length 200005 ; TAB0 b = long long int array of length 200005 ; TAB1 let n , m , ma2 = 0 be ints ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read m ; TAB2 ma = 0 = long long int ; TAB2 for j = 0 to m exclusive ; TAB3 x = long long int ; TAB3 read x ; TAB3 set ma to the max of ma and x ; TAB2 set a at i = ma ; TAB2 set b at i = m ; TAB2 set ma2 to the max of ma2 and a at i ; TAB1 ans = 0 = long long intt ; TAB1 for i = 0 to n exclusive then increment ans by b [ i ] * ( ma2 - a [ i ] ) ; TAB1 print ans ;	long long int a [ 200005 ] ; long long int b [ 200005 ] ; int main ( ) { long long int n , m , ma2 = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> m ; long long int ma = 0 ; for ( int j = 0 ; j < m ; j ++ ) { long long int x ; cin >> x ; ma = max ( ma , x ) ; } a [ i ] = ma ; b [ i ] = m ; ma2 = max ( ma2 , a [ i ] ) ; } long long int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += b [ i ] * ( ma2 - a [ i ] ) ; } cout << ans << endl ; }
TAB0 declare string array s size 100 ; TAB0 declare string array t size 100 ; TAB0 declare string suit = " RGBYW " ; TAB0 declare bitcount with integer n as argument , returning integer ; TAB1 declare integer ans = 0 ; TAB1 while n is greater than 0 ; TAB2 let n be n bitwise and ( n - 1 ) ; TAB2 increment ans ; TAB1 return ans from function ; TAB1 declare integer n ; TAB1 read n ; TAB1 declare string set cnt ; TAB1 for i = 0 to n exclusive ; TAB2 read s [ i ] ; TAB2 insert s [ i ] into cnt ; TAB1 declare integer distinct = size of cnt ; TAB1 declare integer ans = 8 ; TAB1 for i = 0 to ( 1 bitshift left 10 ) exclusive ; TAB2 declare integer tmin = result of run bitcount ( i ) ; TAB2 if tmin is greater than or equal to ans , end loop iteration ; TAB2 remove all elements from cnt ; TAB2 for j = 0 to 10 exclusive ; TAB3 if i bitwise and ( 1 bitshift left j ) ; TAB4 for k = 0 to n exclusive ; TAB5 if j is less than 5 ; TAB6 if s [ k ] [ 1 ] is ' 1 ' + j ; TAB7 add ' 1 ' to end of t [ k ] ; TAB6 else ; TAB7 add ' 0 ' to end of t [ k ] ; TAB5 else ; TAB6 if s [ k ] [ 0 ] is suit [ j - 5 ] ; TAB7 add ' 1 ' to end of t [ k ] ; TAB6 else ; TAB7 add ' 0 ' to end of t [ k ] ; TAB2 for j = 0 to n exclusive ; TAB3 insert t [ j ] into cnt ; TAB3 let t [ j ] be " " ; TAB2 if size of cnt is distinct , let ans be tmin ; TAB1 print ans and newline ;	string s [ 100 ] ; string t [ 100 ] ; string suit = " RGBYW " ; int bitcount ( int n ) { int ans = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; ans ++ ; } return ans ; } int main ( ) { int n ; cin >> n ; set < string > cnt ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ] ; cnt . insert ( s [ i ] ) ; } int distinct = cnt . size ( ) ; int ans = 8 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { int tmin = bitcount ( i ) ; if ( tmin >= ans ) continue ; cnt . clear ( ) ; for ( int j = 0 ; j < 10 ; j ++ ) { if ( i & ( 1 << j ) ) for ( int k = 0 ; k < n ; k ++ ) { if ( j < 5 ) { if ( s [ k ] [ 1 ] == ' 1 ' + j ) { t [ k ] . push_back ( ' 1 ' ) ; } else t [ k ] . push_back ( ' 0 ' ) ; } else { if ( s [ k ] [ 0 ] == suit [ j - 5 ] ) { t [ k ] . push_back ( ' 1 ' ) ; } else t [ k ] . push_back ( ' 0 ' ) ; } } } for ( int j = 0 ; j < n ; j ++ ) { cnt . insert ( t [ j ] ) ; t [ j ] = "  " ; } if ( cnt . size ( ) == distinct ) ans = tmin ; } cout << ans << endl ; return 0 ; }
TAB1 define long long variable n ; TAB1 read variable n from the input ; TAB1 create new long longs x and y ; TAB1 read input to x and y ; TAB1 if n + 1 - x > = y ; TAB2 print " White " ; TAB1 else ; TAB2 print " Black " ;	int main ( ) { long long n ; cin >> n ; long long x , y ; cin >> x >> y ; if ( n + 1 - x >= y ) { cout << " White " << endl ; } else { cout << " Black " << endl ; } return 0 ; }
TAB0 in function ra with parameters integers x1 , y1 , x2 , y2 , x3 , y3 and return boolean ; TAB1 d1 is an integer set to ( absolute value ( x1 - x2 ) ) * ( absolute value ( x1 - x2 ) ) + ( absolute value ( y1 - y2 ) ) * ( absolute value ( y1 - y2 ) ) ; TAB1 d2 is an integer set to ( absolute value ( x1 - x3 ) ) * ( absolute value ( x1 - x3 ) ) + ( absolute value ( y1 - y3 ) ) * ( absolute value ( y1 - y3 ) ) ; TAB1 d3 is an integer set to ( absolute value ( x3 - x2 ) ) * ( absolute value ( x3 - x2 ) ) + ( absolute value ( y3 - y2 ) ) * ( absolute value ( y3 - y2 ) ) ; TAB1 if d1 , d2 , and d3 are all equal to 0 , return false ; TAB1 if d1 + d2 equals d3 or d1 + d3 equals d2 or d2 + d3 equals d1 , return true ; TAB1 return false ; TAB1 n , x1 , x2 , x3 , y1 , y2 , y3 are integers ; TAB1 read x1 , y1 , x2 , y2 , x3 , y3 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display RIGHT ; TAB1 increment x1 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 subtract 2 from x1 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 increment x1 ; TAB1 increment y1 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 subtract 2 from y1 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 increment y1 ; TAB1 increment x2 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 subtract 2 from x2 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 increment x2 ; TAB1 increment y2 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 subtract 2 from y2 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 increment y2 ; TAB1 increment x3 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 subtract 2 from x3 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 increment x3 ; TAB1 increment y3 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 subtract 2 from y3 ; TAB1 if call ra with x1 , y1 , x2 , y2 , x3 , y3 ; TAB2 display ALMOST ; TAB1 display NEITHER ;	bool ra ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int d1 = ( abs ( x1 - x2 ) ) * ( abs ( x1 - x2 ) ) + ( abs ( y1 - y2 ) ) * ( abs ( y1 - y2 ) ) ; int d2 = ( abs ( x1 - x3 ) ) * ( abs ( x1 - x3 ) ) + ( abs ( y1 - y3 ) ) * ( abs ( y1 - y3 ) ) ; int d3 = ( abs ( x3 - x2 ) ) * ( abs ( x3 - x2 ) ) + ( abs ( y3 - y2 ) ) * ( abs ( y3 - y2 ) ) ; if ( ( d1 && d2 && d3 ) == 0 ) return false ; if ( d1 + d2 == d3 || d1 + d3 == d2 || d2 + d3 == d1 ) return true ; return false ; } int main ( ) { int n , x1 , x2 , x3 , y1 , y2 , y3 ; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " RIGHT " << endl ; return 0 ; } x1 ++ ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } x1 -= 2 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } x1 ++ ; y1 ++ ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } y1 -= 2 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } y1 ++ ; x2 ++ ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } x2 -= 2 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } x2 ++ ; y2 ++ ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } y2 -= 2 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } y2 ++ ; x3 ++ ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } x3 -= 2 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } x3 ++ ; y3 ++ ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } y3 -= 2 ; if ( ra ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALMOST " << endl ; return 0 ; } cout << " NEITHER " << endl ; return 0 ; }
TAB1 create long long l1 , r1 , l2 , r2 , k ; TAB1 read long long l1 , r1 , l2 , r2 , k ; TAB1 create long long tot ; TAB1 if l1 > = l2 ; TAB2 if l1 > r2 ; TAB3 set tot = 0 ; TAB2 else if r1 < = r2 ; TAB3 tot = r1 - l1 + 1 ; TAB3 if k > = l1 and k < = r1 , decrement tot ; TAB2 else ; TAB3 tot = r2 - l1 + 1 ; TAB3 if k > = l1 and k < = r2 , decrement tot ; TAB1 else ; TAB2 if l2 > r1 ; TAB3 tot = 0 ; TAB2 else if r2 < = r1 ; TAB3 tot = r2 - l2 + 1 ; TAB3 if k > = l2 and k < = r2 , decrement tot ; TAB2 else ; TAB3 set tot to r1 - l2 + 1 ; TAB3 if k > = l2 and k < = r1 , decrement tot ; TAB1 print tot ;	int main ( ) { long long l1 , r1 , l2 , r2 , k ; cin >> l1 >> r1 >> l2 >> r2 >> k ; long long tot ; if ( l1 >= l2 ) { if ( l1 > r2 ) tot = 0 ; else if ( r1 <= r2 ) { tot = r1 - l1 + 1 ; if ( k >= l1 and k <= r1 ) tot -- ; } else { tot = r2 - l1 + 1 ; if ( k >= l1 and k <= r2 ) tot -- ; } } else { if ( l2 > r1 ) tot = 0 ; else if ( r2 <= r1 ) { tot = r2 - l2 + 1 ; if ( k >= l2 and k <= r2 ) tot -- ; } else { tot = r1 - l2 + 1 ; if ( k >= l2 and k <= r1 ) tot -- ; } } cout << tot << endl ; }
TAB0 create an array of int dx with elements 0 , 1 , 0 , - 1 ; TAB0 create an array of int dy with elements 1 , 0 , - 1 , 0 ; TAB0 create ints n , x , y , xx and yy ; TAB0 declare 2d boolean array vis with size 1001 by 1001 ; TAB0 bool function on with int arguments x and y ; TAB1 return true if ( x = 0 or y = 0 or x = n or y = n ) , else return false ; TAB0 declare int ans = INT_MAX ; TAB0 void function dfs with int arguments cx , cy and g ; TAB1 if cx < 0 or cx > n or cy < 0 or cy > n , return ; TAB1 if vis [ cx ] [ cy ] is true , return ; TAB1 if cx is equal to xx and cy = yy ; TAB2 set ans to min of ans and g ; TAB2 return ; TAB1 set vis [ cx ] [ cy ] to true ; TAB1 for integer i = 0 to 4 exclusive ; TAB2 if on ( cx + dx [ i ] , cy + dy [ i ] ) is true , call dfs ( cx + dx [ i ] , cy + dy [ i ] , g + 1 ) ; TAB1 read n , x , y , xx and yy ; TAB1 call function dfs with arguments x , y and 0 ; TAB1 print ans ;	const int dx [ ] = { 0 , 1 , 0 , - 1 } ; const int dy [ ] = { 1 , 0 , - 1 , 0 } ; int n , x , y , xx , yy ; bool vis [ 1001 ] [ 1001 ] ; bool on ( int x , int y ) { return ( x == 0 || y == 0 || x == n || y == n ) ; } int ans = INT_MAX ; void dfs ( int cx , int cy , int g ) { if ( cx < 0 || cx > n || cy < 0 || cy > n ) return ; if ( vis [ cx ] [ cy ] ) return ; if ( cx == xx && cy == yy ) { ans = min ( ans , g ) ; return ; } vis [ cx ] [ cy ] = true ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( on ( cx + dx [ i ] , cy + dy [ i ] ) ) dfs ( cx + dx [ i ] , cy + dy [ i ] , g + 1 ) ; } } int main ( ) { cin >> n >> x >> y >> xx >> yy ; dfs ( x , y , 0 ) ; cout << ans << endl ; }
TAB0 function distance ( get int a , b , x and y , return int ) ; TAB1 return ( a - x ) ^ 2 + ( b - y ) ^ 2 ; TAB0 function check ( get vector of int cod , return bool ) ; TAB1 d1 , d2 , d3 = int ; TAB1 i = 0 ; TAB1 for i = 0 to size of cod exclusive ; TAB2 decrement cod [ i ] ; TAB2 d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] ) ; TAB2 d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] ) ; TAB2 d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] ) ; TAB2 increment cod [ i ] ; TAB2 if d1 is 0 or d2 is 0 or d3 is 0 continue ; TAB2 if d1 is d2 + d3 or d2 is d1 + d3 or d3 is d2 + d1 return 1 ; TAB1 for i = 0 to size of cod exclusive ; TAB2 increment cod [ i ] ; TAB2 d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] ) ; TAB2 d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] ) ; TAB2 d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] ) ; TAB2 decrement cod [ i ] ; TAB2 if d1 is 0 or d2 is 0 or d3 is 0 continue ; TAB2 if d1 is d2 + d3 or d2 is d1 + d3 or d3 is d2 + d1 return 1 ; TAB1 cod = vector of int ; TAB1 i = unsigned int ; TAB1 for i = 0 to 6 exclusive ; TAB2 temp = int ; TAB2 read temp ; TAB2 add temp to end of cod ; TAB1 d1 , d2 , d3 = int ; TAB1 d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] ) ; TAB1 d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] ) ; TAB1 d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] ) ; TAB1 if d1 is d2 + d3 or d2 is d1 + d3 or d3 is d2 + d1 ; TAB2 print " RIGHT " ; TAB1 else if check ( cod ) ; TAB2 print " ALMOST " ; TAB1 else ; TAB2 print " NEITHER " ;	int distance ( int a , int b , int x , int y ) { return ( ( a - x ) * ( a - x ) + ( b - y ) * ( b - y ) ) ; } bool check ( vector < int > cod ) { int d1 , d2 , d3 ; unsigned int i = 0 ; for ( i = 0 ; i < cod . size ( ) ; i += 1 ) { cod [ i ] -= 1 ; d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] ) ; d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] ) ; d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] ) ; cod [ i ] += 1 ; if ( d1 == 0 or d2 == 0 or d3 == 0 ) continue ; if ( ( d1 == d2 + d3 ) or ( d2 == d1 + d3 ) or ( d3 == d2 + d1 ) ) { return 1 ; } } for ( i = 0 ; i < cod . size ( ) ; i += 1 ) { cod [ i ] += 1 ; d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] ) ; d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] ) ; d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] ) ; cod [ i ] -= 1 ; if ( d1 == 0 or d2 == 0 or d3 == 0 ) continue ; if ( ( d1 == d2 + d3 ) or ( d2 == d1 + d3 ) or ( d3 == d2 + d1 ) ) { return 1 ; } } return 0 ; } int main ( ) { vector < int > cod ; unsigned int i ; for ( i = 0 ; i < 6 ; i += 1 ) { int temp ; cin >> temp ; cod . push_back ( temp ) ; } int d1 , d2 , d3 ; d1 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 2 ] , cod [ 3 ] ) ; d2 = distance ( cod [ 0 ] , cod [ 1 ] , cod [ 4 ] , cod [ 5 ] ) ; d3 = distance ( cod [ 2 ] , cod [ 3 ] , cod [ 4 ] , cod [ 5 ] ) ; if ( ( d1 == d2 + d3 ) or ( d2 == d1 + d3 ) or ( d3 == d2 + d1 ) ) { cout << " RIGHT " << endl ; return 0 ; } else if ( check ( cod ) ) cout << " ALMOST " << endl ; else cout << " NEITHER " << endl ; return 0 ; }
TAB1 create string s ; TAB1 create int n ; TAB1 read s and n ; TAB1 if length of s mod n > 0 ; TAB2 print NO ; TAB1 set l to length of s / n ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to l / 2 exclusive ; TAB3 if s [ j + i * l ] different from s [ ( i + 1 ) * l - j - 1 ] ; TAB4 print NO ; TAB1 print YES ;	int main ( ) { string s ; int n ; cin >> s >> n ; if ( s . length ( ) % n > 0 ) { cout << " NO " << endl ; return 0 ; } int l = s . length ( ) / n ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < l / 2 ; j ++ ) if ( s [ j + i * l ] != s [ ( i + 1 ) * l - j - 1 ] ) { cout << " NO " << endl ; return 0 ; } cout << " YES " << endl ; return 0 ; }
TAB0 create long long integer MOD = 1000000009 ; TAB0 into the function pw which takes two long long integers a and b and returns a long long integer ; TAB1 if b is 0 then return 1 ; TAB1 if b is 1 then return a % MOD ; TAB1 if b % 2 is true ; TAB2 create long long rs = pw ( a , b - 1 ) ; TAB2 return ( rs * a ) % MOD ; TAB1 create long long integer rs = pw ( a , b / 2 ) ; TAB1 return ( rs * rs ) % MOD ; TAB0 sm = long long integer vector ; TAB0 into the function solve which takes a and b ; TAB1 if b is 0 then return 0 ; TAB1 for i = 0 to 35 exclusive ; TAB2 create long long integer ba = ( 1LL < < i ) & b ; TAB2 if ba is equal to 0 then continue ; TAB2 return sm [ i ] + solve ( a , b - ( 1LL < < i ) ) * pw ( a , ( 1LL < < i ) ) ) % MOD ; TAB1 n , a , b , k = long long integers ; TAB1 read n , a , b , k ; TAB1 s = string ; TAB1 read s ; TAB1 create long long integers X and Y with values 1 ; TAB1 for i = o to k exclusive ; TAB2 set X = X * b ; TAB2 set X = X % MOD ; TAB1 for i = 0 to k exclusive ; TAB2 set Y = Y * a ; TAB2 set Y = Y % MOD ; TAB1 set X = X * pw ( Y , MOD - 2 ) ; TAB1 set X = X % MOD ; TAB1 add 1 to the end of sm ; TAB1 for i = 0 to 40 exclusive ; TAB2 add sm . back ( ) + sm . back ( ) * pw ( X , ( 1LL < < i ) to end of sm ; TAB2 set sm . back ( ) = sm . back ( ) % MOD ; TAB1 create long long integer st = solve ( X , ( n + 1 ) / k ) ; TAB1 create long long integer ans = 0 ; TAB1 for i = 0 to k exclusive ; TAB2 create long long integer rs = ( pw ( b , i ) * pw ( a , n - i ) ) % MOD ; TAB2 if s [ i ] is ' - ' then set rs = rs * - 1 ; TAB2 set rs = rs * st ; TAB2 set ans = ans + rs ; TAB2 set ans = ans % MOD ; TAB1 if ans is less than 0 then set ans = ans + MOD ; TAB1 print ans ;	long long MOD = 1000000009 ; long long pw ( long long a , long long b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a % MOD ; if ( b % 2 ) { long long rs = pw ( a , b - 1 ) ; return ( rs * a ) % MOD ; } long long rs = pw ( a , b / 2 ) ; return ( rs * rs ) % MOD ; } vector < long long > sm ; long long solve ( long long a , long long b ) { if ( b == 0 ) return 0 ; for ( long long i = 0 ; i < 35 ; i ++ ) { long long ba = ( 1LL << i ) & b ; if ( ba == 0 ) continue ; return ( sm [ i ] + solve ( a , b - ( 1LL << i ) ) * pw ( a , ( 1LL << i ) ) ) % MOD ; } } int main ( ) { long long n , a , b , k ; cin >> n >> a >> b >> k ; string s ; cin >> s ; long long X = 1 , Y = 1 ; for ( long long i = 0 ; i < k ; i ++ ) { X *= b ; X %= MOD ; } for ( long long i = 0 ; i < k ; i ++ ) { Y *= a ; Y %= MOD ; } X *= pw ( Y , MOD - 2 ) ; X %= MOD ; sm . push_back ( 1 ) ; for ( long long i = 0 ; i < 40 ; i ++ ) { sm . push_back ( sm . back ( ) + sm . back ( ) * pw ( X , ( 1LL << i ) ) ) ; sm . back ( ) %= MOD ; } long long st = solve ( X , ( n + 1 ) / k ) ; long long ans = 0 ; for ( long long i = 0 ; i < k ; i ++ ) { long long rs = ( pw ( b , i ) * pw ( a , n - i ) ) % MOD ; if ( s [ i ] == ' - ' ) rs *= - 1 ; rs *= st ; ans += rs ; ans %= MOD ; } if ( ans < 0 ) ans += MOD ; cout << ans << endl ; }
TAB0 declare integer array a size 500010 ; TAB1 declare integer n ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 declare integer ans initialized with 0 ; TAB1 declare integers l , r ; TAB1 for i = 0 to n exclusive ; TAB2 let l be i ; TAB2 let r be i + 1 ; TAB2 while r is less than n and a [ l ] is not a [ r ] ; TAB3 increment l ; TAB3 increment r ; TAB2 let l be i + 1 ; TAB2 decrement r by 2 ; TAB2 declare integer num initialized with 0 ; TAB2 while l is less than or equal to r ; TAB3 let a [ l ] be a [ l - 1 ] ; TAB3 let a [ r ] be a [ r + 1 ] ; TAB3 increment l ; TAB3 decrement r ; TAB3 increment num ; TAB2 let ans be maximum of ans and num ; TAB1 print ans and newline ; TAB1 for i = 0 to n - 1 exclusive , print a [ i ] and ' ' ; TAB1 print a [ n - 1 ] and newline ;	int a [ 500010 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int ans ( 0 ) ; int l , r ; for ( int i = 0 ; i < n ; i ++ ) { l = i ; r = i + 1 ; while ( r < n && a [ l ] != a [ r ] ) { l ++ ; r ++ ; } l = i + 1 ; r -= 2 ; int num ( 0 ) ; while ( l <= r ) { a [ l ] = a [ l - 1 ] ; a [ r ] = a [ r + 1 ] ; l ++ ; r -- ; num ++ ; } ans = max ( ans , num ) ; } cout << ans << endl ; for ( int i = 0 ; i < n - 1 ; i ++ ) cout << a [ i ] << '   ' ; cout << a [ n - 1 ] << endl ; return 0 ; }
TAB0 let len a constant int with value 1e2 + 5 ; TAB0 let mod a constant long long with value 1e9 + 7 ; TAB0 let pi a constant double with value acos ( - 1 . 0 ) ; TAB1 let n , a , b , c long longs ; TAB1 read n , a , b , and c ; TAB1 if a at most b - c ; TAB2 print n / a ; TAB1 otherwise ; TAB2 if n < b ; TAB3 print n / min ( a , b ) ; TAB2 let ans a long long with value 0 ; TAB2 subtract b from n ; TAB2 add n / ( b - c ) to ans ; TAB2 set n to n mod ( b - c ) ; TAB2 increment ans ; TAB2 add c to n ; TAB2 add n / min ( a , b ) to ans ; TAB2 print ans ;	const int len = 1e2 + 5 ; const long long mod = 1e9 + 7 ; const double pi = acos ( - 1.0 ) ; int main ( ) { long long n , a , b , c ; cin >> n >> a >> b >> c ; if ( a <= b - c ) cout << n / a << endl ; else { if ( n < b ) { cout << n / min ( a , b ) << endl ; return 0 ; } long long ans = 0 ; n -= b ; ans += n / ( b - c ) ; n = n % ( b - c ) ; ans ++ ; n += c ; ans += n / min ( a , b ) ; cout << ans << endl ; } }
TAB1 i , j , k are integers ; TAB1 s = character array of size 100010 ; TAB1 while call gets with s ; TAB2 len = integer = string length of s ; TAB2 for i = 0 to len exclusive ; TAB3 if s [ i ] isn ' t the character a , break ; TAB2 for j = i to len exclusive ; TAB3 if s [ j ] is the character a , break ; TAB3 decrement s [ j ] ; TAB2 if i equals len , set s [ len - 1 ] to the character z ; TAB2 display s ;	int main ( ) { int i , j , k ; char s [ 100010 ] ; while ( gets ( s ) ) { int len = strlen ( s ) ; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] != ' a ' ) { break ; } } for ( j = i ; j < len ; j ++ ) { if ( s [ j ] == ' a ' ) { break ; } s [ j ] -- ; } if ( i == len ) { s [ len - 1 ] = ' z ' ; } cout << s << endl ; } return 0 ; }
TAB1 a = char array of size 110 with all values set to 0 ; TAB1 n = int ; TAB1 read n ; TAB1 read a ; TAB1 if n is 1 ; TAB2 print a ; TAB1 else ; TAB2 cnt = int with cnt = 0 ; TAB2 for i = 0 to n ; TAB3 if a [ i ] is ' 0 ' increment cnt ; TAB2 print ' 1 ' ; TAB2 print ' 0 ' cnt times ; TAB2 print newline ;	int main ( ) { char a [ 110 ] = { 0 } ; int n ; cin >> n ; cin >> a ; if ( n == 1 ) cout << a << endl ; else { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ' 0 ' ) cnt ++ ; } cout << ' 1 ' ; for ( int i = 0 ; i < cnt ; i ++ ) cout << ' 0 ' ; cout << endl ; } return 0 ; }
TAB1 a = string ; TAB1 b , t = long long , c = 0 ; TAB1 read a ; TAB1 b = pos of ' = ' in a ; TAB1 t = b ; TAB1 add 2 to b ; TAB1 b = size of a - b + 1 ; TAB1 for i = 0 to t exclusive ; TAB2 if a [ i ] is ' | ' increment c ; TAB1 if c + 1 is b - 1 ; TAB2 print ' | ' ; TAB2 for i = 0 to size of a - 1 exclusive print a [ i ] ; TAB2 print newline ; TAB1 else if c is b ; TAB2 print a ; TAB1 else if c is b + 2 ; TAB2 z = pos of ' + ' in a ; TAB2 if z > 1 ; TAB3 for i = 1 to size of a exclusive print a [ i ] ; TAB3 print ' | ' ; TAB2 else ; TAB3 for i = 0 to size of a exclusive ; TAB4 if i is z + 1 continue ; TAB4 print a [ i ] ; TAB3 print ' | ' ; TAB1 else ; TAB2 print Impossible ;	int main ( ) { string a ; long long b , t , c = 0 ; getline ( cin , a ) ; b = a . find ( ' = ' ) ; t = b ; b += 2 ; b = a . size ( ) - b + 1 ; for ( long long i = 0 ; i < t ; ++ i ) { if ( a [ i ] == ' | ' ) { c ++ ; } } if ( c + 1 == b - 1 ) { cout << ' | ' ; for ( long long i = 0 ; i < a . size ( ) - 1 ; ++ i ) { cout << a [ i ] ; } cout << endl ; } else if ( c == b ) { cout << a << endl ; } else if ( c == b + 2 ) { long long z = a . find ( ' + ' ) ; if ( z > 1 ) { for ( long long i = 1 ; i < a . size ( ) ; i ++ ) { cout << a [ i ] ; } cout << ' | ' << endl ; } else { for ( long long i = 0 ; i < a . size ( ) ; i ++ ) { if ( i == z + 1 ) { continue ; } cout << a [ i ] ; } cout << ' | ' << endl ; } } else { cout << " Impossible " << endl ; } return 0 ; }
TAB1 create long longs x1 , x2 , y1 , y2 , n ; TAB1 read x1 , x2 , y1 , y2 ; TAB1 read n ; TAB1 create int t = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 create long longs a , b , c ; TAB2 read a , b , c ; TAB2 if ( a * x1 + b * y1 + c ) GREATER THAN 0 AND ( a * x2 + b * y2 + c ) LESS THAN 0 , increment t ; TAB2 if ( a * x1 + b * y1 + c ) LESS THAN 0 AND ( a * x2 + b * y2 + c ) GREATER THAN 0 , increment t ; TAB1 print t ;	int main ( ) { long long x1 , x2 , y1 , y2 , n ; cin >> x1 >> y1 >> x2 >> y2 ; cin >> n ; int t = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long long a , b , c ; cin >> a >> b >> c ; if ( ( a * x1 + b * y1 + c ) > 0 && ( a * x2 + b * y2 + c ) < 0 ) t ++ ; if ( ( a * x1 + b * y1 + c ) < 0 && ( a * x2 + b * y2 + c ) > 0 ) t ++ ; } cout << t << endl ; }
TAB0 let s be a string ; TAB0 let a and b be integers ; TAB0 let len be an integer ; TAB1 input s ; TAB1 n is an integer set to length of s ; TAB1 w is an integer array of size n + 10 ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is the character ( ; TAB3 increment a ; TAB2 else if s [ i ] is the character # ; TAB3 assign 1 to w [ len + 1 ] ; TAB3 decrement a ; TAB2 else if s [ i ] is the character ) ; TAB3 decrement a ; TAB2 if a is negative ; TAB3 display - 1 ; TAB1 for i = length of s - 1 to 0 inclusive ; TAB2 if s [ i ] is the character ) ; TAB3 increment b ; TAB2 else if s [ i ] is the character ( ; TAB3 decrement b ; TAB2 else if s [ i ] is the character # ; TAB3 break ; TAB2 if b is negative ; TAB3 display - 1 ; TAB1 add a to w [ len ] ; TAB1 for i = 1 to len inclusive , display w [ i ] ;	string s ; int a , b ; int len ; int main ( ) { cin >> s ; int n = s . length ( ) ; int w [ n + 10 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { a ++ ; } else if ( s [ i ] == ' # ' ) { w [ ++ len ] = 1 ; a -- ; } else if ( s [ i ] == ' ) ' ) { a -- ; } if ( a < 0 ) { cout << - 1 << endl ; return 0 ; } } for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ) ' ) { b ++ ; } else if ( s [ i ] == ' ( ' ) { b -- ; } else if ( s [ i ] == ' # ' ) { break ; } if ( b < 0 ) { cout << - 1 << endl ; return 0 ; } } w [ len ] += a ; for ( int i = 1 ; i <= len ; i ++ ) { cout << w [ i ] << endl ; } return 0 ; }
TAB0 in function isPalindrome returning bool , accepting string s ; TAB1 define string sCopy = s ; TAB1 reverse s ; TAB1 if s equals sCopy ; TAB2 return true ; TAB1 else ; TAB2 return false ; TAB1 declare string s ; TAB1 declare int k ; TAB1 read s ; TAB1 read k ; TAB1 define int n = size of s ; TAB1 define int check = 0 ; TAB1 if n mod k equals 0 ; TAB2 define int len = n / k ; TAB2 for i = 0 to n exclusive ; TAB3 define string word = s . substr ( i , len ) ; TAB3 if isPalindrome ( word ) , increment check ; TAB3 increase i by len - 1 ; TAB2 if check equals k ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ; TAB1 print " NO " ;	bool isPalindrome ( string s ) { string sCopy = s ; reverse ( s . begin ( ) , s . end ( ) ) ; if ( s == sCopy ) return true ; else return false ; } int main ( ) { string s ; int k ; cin >> s ; cin >> k ; int n = s . size ( ) ; int check = 0 ; if ( n % k == 0 ) { int len = n / k ; for ( int i = 0 ; i < n ; i ++ ) { string word = s . substr ( i , len ) ; if ( isPalindrome ( word ) ) check ++ ; i += len - 1 ; } if ( check == k ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; } cout << " NO " << endl ; }
TAB1 let n be a integer ; TAB1 let m be a float value ; TAB1 read n , m ; TAB1 create a vector of integers v ; TAB1 for i = 0 to n exclusive ; TAB2 let x be a integer ; TAB2 read x ; TAB2 push_back x into vector v ; TAB1 for i = 0 to n exclusive , v [ i ] is equal to ceiling of v [ i ] / m ; TAB1 let p , max be integers with p = 0 , max = - 1 ; TAB1 for i = 0 to n exclusive ; TAB2 if max < = v [ i ] ; TAB3 p is equal to i + 1 ; TAB3 max is equal to v [ i ] ; TAB1 print p and newline ;	int main ( ) { int n ; float m ; cin >> n >> m ; vector < int > v ; for ( int i = 0 ; i < n ; i += 1 ) { int x ; cin >> x ; v . push_back ( x ) ; } for ( int i = 0 ; i < n ; i += 1 ) { v [ i ] = ceil ( v [ i ] / m ) ; } int p = 0 , max = - 1 ; for ( int i = 0 ; i < n ; i += 1 ) { if ( max <= v [ i ] ) { p = i + 1 ; max = v [ i ] ; } } cout << p << endl ; return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 create a set of strings by name items ; TAB1 for long integer i = 0 to n exclusive ; TAB2 let s1 , s2 be strings ; TAB2 read s1 , s2 ; TAB2 reverse the values of s2 from beginning to end ; TAB2 the string value of fS = s1 + s2 ; TAB2 create a set of strings by name combs ; TAB2 insert fS into combs ; TAB2 for i = 0 to n exclusive ; TAB3 the string value of ns = fS ; TAB3 for long integer j = 0 to 4 exclusive , ns [ j ] is equal to fS [ ( j + 1 ) modulo 4 ] ; TAB3 fS is equal to ns ; TAB3 insert fS into combs ; TAB2 insert * combs . begin ( ) into items ; TAB2 if i is not equal to n - 1 , read s1 ; TAB1 print length of items and newline ;	int main ( ) { int n ; cin >> n ; set < string > items ; for ( long long int i = 0 ; i < n ; i ++ ) { string s1 , s2 ; cin >> s1 >> s2 ; reverse ( s2 . begin ( ) , s2 . end ( ) ) ; string fS = s1 + s2 ; set < string > combs ; combs . insert ( fS ) ; for ( int i = 0 ; i < n ; i ++ ) { string ns = fS ; for ( long long int j = 0 ; j < 4 ; j ++ ) { ns [ j ] = fS [ ( j + 1 ) % 4 ] ; } fS = ns ; combs . insert ( fS ) ; } items . insert ( * combs . begin ( ) ) ; if ( i != n - 1 ) { cin >> s1 ; } } cout << items . size ( ) << endl ; }
TAB0 f = array of 300030 int ; TAB0 ne = array of 300030 int ; TAB1 n , m = int ; TAB1 read n , m ; TAB1 for i = 0 to n inclusive ne [ i ] = i + 1 ; TAB1 l , r , x , t = int ; TAB1 while decrementing m remains > 0 ; TAB2 read l , r , x ; TAB2 i = l , while i < = r setting i to t at end of while ; TAB3 if i is not x and not f [ i ] f [ i ] = x ; TAB3 t = ne [ i ] ; TAB3 if i < x ; TAB4 ne [ i ] = ne [ x - 1 ] ; TAB3 else ; TAB4 ne [ i ] = ne [ r ] ; TAB1 for i = 1 to n inclusive ; TAB2 if i is 1 ; TAB3 print f [ i ] ; TAB2 else ; TAB3 print space , f [ i ] ; TAB1 print newline ;	int f [ 300030 ] ; int ne [ 300030 ] ; int main ( ) { int n , m ; cin >> n >> m ; for ( int i = 0 ; i <= n ; i ++ ) ne [ i ] = i + 1 ; int l , r , x , t ; while ( m -- ) { cin >> l >> r >> x ; for ( int i = l ; i <= r ; i = t ) { if ( i != x && ! f [ i ] ) f [ i ] = x ; t = ne [ i ] ; if ( i < x ) ne [ i ] = ne [ x - 1 ] ; else ne [ i ] = ne [ r ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 1 ) cout << f [ i ] ; else cout << "   " << f [ i ] ; } cout << endl ; return 0 ; }
TAB0 MAXN = 400 ; TAB0 INF = 3fffffff in exadecimal ; TAB0 MOD = 100007 ; TAB0 a = array of MAXN char ; TAB1 read a ; TAB1 len = length of a ; TAB1 ansl , ansm , ansr = 0 ; TAB1 f1 and f2 = false ; TAB1 for i = 0 to len exclusive ; TAB2 if a [ i ] is ' + ' ; TAB3 f1 = true ; TAB3 continue ; TAB2 if not f1 ; TAB3 increment ansl ; TAB3 continue ; TAB2 if a [ i ] is ' = ' ; TAB3 f2 = true ; TAB3 continue ; TAB2 if not f2 ; TAB3 increment ansm ; TAB3 continue ; TAB2 increment ansr ; TAB1 if ansl + ansm - ansr is 0 ; TAB2 print a ; TAB1 else if ansl + ansm - ansr is 2 ; TAB2 if ansl > = 2 ; TAB3 for i = 1 to ansl exclusive print " | " ; TAB3 print ' + ' ; TAB3 for i = 1 to ansm inclusive print " | " ; TAB3 print ' = ' ; TAB3 for i = 1 to ansr + 1 inclusive print " | " ; TAB3 print newline ; TAB2 else if ansm > = 2 ; TAB3 for i = 1 to ansl inclusive print " | " ; TAB3 print ' + ' ; TAB3 for i = 1 to ansm exclusive print " | " ; TAB3 print ' = ' ; TAB3 for i = 1 to ansr + 1 inclusive print " | " ; TAB3 print newline ; TAB1 else if ansl + ansm - ansr is - 2 ; TAB2 print " | " ; TAB2 a [ len - 1 ] = null byte ; TAB2 print a ; TAB1 else ; TAB2 print Impossible ;	const int MAXN = 3e2 + 100 ; const int INF = 0x3FFFFFFF ; const long long MOD = 1e5 + 7 ; char a [ MAXN ] ; int main ( ) { cin >> a ; int len = strlen ( a ) ; int ansl = 0 , ansm = 0 , ansr = 0 ; bool f1 = false , f2 = false ; for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] == ' + ' ) { f1 = true ; continue ; } if ( ! f1 ) { ansl ++ ; continue ; } if ( a [ i ] == ' = ' ) { f2 = true ; continue ; } if ( ! f2 ) { ansm ++ ; continue ; } ansr ++ ; } if ( ansl + ansm - ansr == 0 ) { cout << a << endl ; return 0 ; } else if ( ansl + ansm - ansr == 2 ) { if ( ansl >= 2 ) { for ( int i = 1 ; i < ansl ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 1 ; i <= ansm ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 1 ; i <= ansr + 1 ; i ++ ) cout << " | " ; cout << endl ; } else if ( ansm >= 2 ) { for ( int i = 1 ; i <= ansl ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 1 ; i < ansm ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 1 ; i <= ansr + 1 ; i ++ ) cout << " | " ; cout << endl ; } } else if ( ansl + ansm - ansr == - 2 ) { cout << " | " ; a [ len - 1 ] = ' \0 ' ; cout << a << endl ; } else cout << " Impossible " << endl ; return 0 ; }
TAB0 let maxn be constant integer with maxn = 111 ; TAB0 let n and ans be integers with ans = 1 and r be integer array of length maxn ; TAB0 let vis be boolean array of length maxn and f be boolean with value true ; TAB0 function dfs accepts arguments of integers len , x and root and returns integer ; TAB1 if x element of vis array is true and x is equal to root then return len ; TAB1 if x element of array vis is true ; TAB2 assign f equal to false ; TAB2 return len ; TAB1 x element of vis array is equal to true ; TAB1 call dfs function with arguments len + 1 , r [ X ] and root ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read i element of array r ; TAB1 for i = 1 to n inclusive , and f is true ; TAB2 if i element of array vis is false ; TAB3 call dfs function with argument 0 , i and i and assign the result to integer tmp ; TAB3 if tmp modulo 2 equals to 0 tmp / equals 2 ; TAB3 ans is equal to ans * tmp / __gcd ( ans , tmp ) ; TAB1 if f is false ; TAB2 print - 1 ; TAB1 pring ans ;	const int maxn = 111 ; int n , ans = 1 , r [ maxn ] ; bool vis [ maxn ] , f = true ; int dfs ( int len , int x , int root ) { if ( vis [ x ] && x == root ) return len ; if ( vis [ x ] ) { f = false ; return len ; } vis [ x ] = true ; dfs ( len + 1 , r [ x ] , root ) ; } int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> r [ i ] ; for ( int i = 1 ; i <= n && f ; i ++ ) { if ( vis [ i ] == false ) { int tmp = dfs ( 0 , i , i ) ; if ( tmp % 2 == 0 ) tmp /= 2 ; ans = ans * tmp / __gcd ( ans , tmp ) ; } } if ( f == false ) { cout << - 1 << endl ; return 0 ; } cout << ans << endl ; return 0 ; }
TAB0 create int array vis of size 30 ; TAB1 let int n ; TAB1 read n ; TAB1 let string s ; TAB1 read s ; TAB1 for i = 0 to s . length ( ) exclusive ; TAB2 if vis [ s [ i ] ] is truthy ; TAB3 print " Yes " ; TAB2 set vis [ s [ i ] ] to 1 ; TAB1 if n is equal to 1 ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	int vis [ 30 ] ; int main ( ) { int n ; cin >> n ; string s ; cin >> s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( vis [ s [ i ] ] ) { cout << " Yes " << endl ; return 0 ; } vis [ s [ i ] ] = 1 ; } if ( n == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB0 maxn = constant integer set to 100000 ; TAB0 a , b = arrays of integers with length of maxn , n , r , and ans = integers with r set to 1 ; TAB1 read n ; TAB1 for i = 1 to n inclusive , print a [ i ] ; TAB1 sort a + 1 and a + 1 + n ; TAB1 for i = 1 to n inclusive ; TAB2 while r < = n and a [ r ] < = a [ i ] , increment r by 1 ; TAB2 if r < = n , increment ans and r by 1 ; TAB1 print ans ;	const int maxn = 100000 ; int a [ maxn ] , b [ maxn ] , n , r = 1 , ans ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } sort ( a + 1 , a + 1 + n ) ; for ( int i = 1 ; i <= n ; i ++ ) { while ( r <= n && a [ r ] <= a [ i ] ) r ++ ; if ( r <= n ) ans ++ , r ++ ; } cout << ans << endl ; return 0 ; }
TAB0 create new array of long longs a with size 100001 ; TAB0 declare new array of long longs s with 100000 elements ; TAB1 declare long longs n , i , max , min , mm , k and t ; TAB1 read n and loop further ; TAB2 read n elements from the input into a , starting from the index 1 ; TAB2 start for loop from i = 1 to n - 1 inclusive incrementing i ; TAB3 change s [ i ] to the absolute value of a [ i ] - a [ i + 1 ] ; TAB3 if i is odd , set the value of s [ i ] to 0 - s [ i ] ; TAB2 set max to s [ n - 1 ] ; TAB2 change min to s [ n - 1 ] ; TAB2 if n - 1 is even ; TAB3 set mm to max ; TAB2 else ; TAB3 change mm to 0 - min ; TAB2 change k from n - 2 to 1 inclusive in a loop , counting down by 1 ; TAB3 if max is less than 0 ; TAB4 change max to s [ k ] ; TAB3 else ; TAB4 assign max + s [ k ] to max ; TAB3 if min is greater than 0 ; TAB4 change min to s [ k ] ; TAB3 else ; TAB4 change min to min + s [ k ] ; TAB3 if k is even and max > mm , set mm to max ; TAB3 if k is odd and 0 - min > mm , set mm to 0 - min ; TAB2 print mm ;	long long a [ 100001 ] ; long long s [ 100000 ] ; int main ( ) { long long n , i , max , min , mm , k , t ; while ( cin >> n ) { for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( i = 1 ; i <= n - 1 ; i ++ ) { s [ i ] = abs ( a [ i ] - a [ i + 1 ] ) ; if ( i % 2 == 1 ) s [ i ] = 0 - s [ i ] ; } max = s [ n - 1 ] ; min = s [ n - 1 ] ; if ( ( n - 1 ) % 2 == 0 ) mm = max ; else mm = 0 - min ; for ( k = n - 2 ; k >= 1 ; k -- ) { if ( max < 0 ) max = s [ k ] ; else max = max + s [ k ] ; if ( min > 0 ) min = s [ k ] ; else min = min + s [ k ] ; if ( k % 2 == 0 && max > mm ) mm = max ; if ( k % 2 == 1 && 0 - min > mm ) mm = 0 - min ; } cout << mm << endl ; } return 0 ; }
TAB1 let x be integer ; TAB1 read x ; TAB1 if x = = 1 ; TAB2 call puts of " - 1 " ; TAB1 else ; TAB2 print x , " " , x ;	int main ( ) { int x ; cin >> x ; if ( x == 1 ) puts ( " -1 " ) ; else cout << x << "   " << x << endl ; return 0 ; }
TAB0 create int array a of size 1000900 ; TAB1 let int n ; TAB1 read n and while n is truthy ; TAB2 set all contents of a to 0 ; TAB2 let int x ; TAB2 for i = 0 to n exclusive ; TAB3 read x ; TAB3 increment a [ x ] ; TAB2 create int temp ; TAB2 create int sum = 0 ; TAB2 for i = 0 to 1000900 exclusive ; TAB3 set temp to a [ i ] / 2 ; TAB3 set a [ i + 1 ] to a [ i + 1 ] + temp ; TAB3 if a [ i ] is not even , increment sum ; TAB2 print sum ;	int a [ 1000900 ] ; int main ( ) { int n ; while ( cin >> n ) { memset ( a , 0 , sizeof ( a ) ) ; int x ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; a [ x ] ++ ; } int temp ; int sum = 0 ; for ( int i = 0 ; i < 1000900 ; i ++ ) { temp = a [ i ] / 2 ; a [ i + 1 ] = a [ i + 1 ] + temp ; if ( a [ i ] % 2 == 1 ) sum ++ ; } cout << sum << endl ; } return 0 ; }
TAB0 declare constant integer N = 105 ; TAB0 declare integer array p size N ; TAB0 declare parent with integer argument , returning integer ; TAB1 declare integers n , m ; TAB1 read n and m ; TAB1 declare indep = 0 as integer ; TAB1 declare x , y , z as integers ; TAB1 for i = 0 to n exclusive ; TAB2 read x ; TAB2 if x is 0 ; TAB3 increment indep ; TAB2 else ; TAB3 read y ; TAB3 if p [ y ] is 0 , let p [ y ] be y ; TAB3 for j = 0 to x - 1 exclusive ; TAB4 read z ; TAB4 if p [ z ] is 0 , let p [ z ] be z ; TAB4 if result of run parent with z as argument is not result of run parent with y as argument , let p [ result of run parent ( z ) ] be y ; TAB1 declare set = 0 as integer ; TAB1 for i = 1 to m inclusive ; TAB2 if p [ i ] is i , increment set ; TAB1 if set is not 0 , decrement set ; TAB1 print indep + set , newline ; TAB0 declare parent with integer x as argument , returning integer ; TAB1 if p [ x ] is x , return x from function ; TAB1 return result of run parent ( p [ x ] ) ;	const int N = 105 ; int p [ N ] ; int parent ( int ) ; int main ( ) { int n , m ; cin >> n >> m ; int indep = 0 ; int x , y , z ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x ; if ( x == 0 ) { indep ++ ; } else { cin >> y ; if ( p [ y ] == 0 ) p [ y ] = y ; for ( int j = 0 ; j < x - 1 ; j ++ ) { cin >> z ; if ( p [ z ] == 0 ) p [ z ] = z ; if ( parent ( z ) != parent ( y ) ) p [ parent ( z ) ] = y ; } } } int set = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( p [ i ] == i ) { set ++ ; } } if ( set != 0 ) set -- ; cout << indep + set << endl ; return 0 ; } int parent ( int x ) { if ( p [ x ] == x ) return x ; return parent ( p [ x ] ) ; }
TAB1 make long long int n ; TAB1 read n ; TAB1 create long long integer array arr of size n ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 sort arr using arr + n ; TAB1 create ints i = n - 2 and j = n - 1 ; TAB1 make long long integer ans = 0 ; TAB1 while i is greater than or equal to 0 ; TAB2 if arr [ i ] is less than arr [ j ] ; TAB3 add 1 to ans ; TAB3 subtract 1 from j ; TAB3 decrease i by 1 ; TAB2 else do ; TAB3 subtract 1 from i ; TAB1 show ans ;	int main ( ) { long long int n ; cin >> n ; long long int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } sort ( arr , arr + n ) ; int i = n - 2 , j = n - 1 ; long long int ans = 0 ; while ( i >= 0 ) { if ( arr [ i ] < arr [ j ] ) { ans ++ ; j -- ; i -- ; } else i -- ; } cout << ans << endl ; return 0 ; }
TAB0 create string array s initialized with { " C " , " C # " , " D " , " D # " , " E " , " F " , " F # " , " G " , " G # " , " A " , " B " , " H " } ; TAB0 create multidimensional integer array d of size 20 x 20 ; TAB0 create map mp of string to int ; TAB0 in function check with return type int and parameters int x , int y , int z ; TAB1 if d [ x ] [ y ] is 4 and d [ y ] [ z ] is 3 then return 1 ; TAB1 if d [ x ] [ y ] is 3 and d [ y ] [ z ] is 4 then return 2 ; TAB1 return 3 ; TAB1 for i = 0 to 12 exclusive ; TAB2 for j = 0 to 12 exclusive ; TAB3 if j greater than or equal to i ; TAB4 set d [ i ] [ j ] to j - i ; TAB3 else ; TAB4 set d [ i ] [ j ] to j + 12 - i ; TAB1 for i = 0 to 12 exclusive do insert pair < string , int > ( s [ i ] , i ) into mp ; TAB1 create strings X , Y , Z ; TAB1 create ints a , b , c ; TAB1 read X , Y , Z ; TAB1 set a to mp [ X ] ; TAB1 set b to mp [ Y ] ; TAB1 set c to mp [ Z ] ; TAB1 if check ( a , b , c ) is 1 ; TAB2 print " major " ; TAB1 if check ( a , b , c ) is 2 ; TAB2 print " minor " ; TAB1 if check ( a , c , b ) is 1 ; TAB2 print " major " ; TAB1 if check ( a , c , b ) is 2 ; TAB2 print " minor " ; TAB1 if check ( b , a , c ) is 1 ; TAB2 print " major " ; TAB1 if check ( b , a , c ) is 2 ; TAB2 print " minor " ; TAB1 if check ( b , c , a ) is 1 ; TAB2 print " major " ; TAB1 if check ( b , c , a ) is 2 ; TAB2 print " minor " ; TAB1 if check ( c , a , b ) is 1 ; TAB2 print " major " ; TAB1 if check ( c , a , b ) is 2 ; TAB2 print " minor " ; TAB1 if check ( c , b , a ) is 1 ; TAB2 print " major " ; TAB1 if check ( c , b , a ) is 2 ; TAB2 print " minor " ; TAB1 print " strange " ;	string s [ ] = { " C " , " C# " , " D " , " D# " , " E " , " F " , " F# " , " G " , " G# " , " A " , " B " , " H " } ; int d [ 20 ] [ 20 ] ; map < string , int > mp ; int check ( int x , int y , int z ) { if ( d [ x ] [ y ] == 4 && d [ y ] [ z ] == 3 ) return 1 ; if ( d [ x ] [ y ] == 3 && d [ y ] [ z ] == 4 ) return 2 ; return 3 ; } int main ( ) { for ( int i = 0 ; i < 12 ; i ++ ) { for ( int j = 0 ; j < 12 ; j ++ ) { if ( j >= i ) { d [ i ] [ j ] = j - i ; } else { d [ i ] [ j ] = j + 12 - i ; } } } for ( int i = 0 ; i < 12 ; i ++ ) { mp . insert ( pair < string , int > ( s [ i ] , i ) ) ; } string X , Y , Z ; int a , b , c ; cin >> X >> Y >> Z ; a = mp [ X ] ; b = mp [ Y ] ; c = mp [ Z ] ; if ( check ( a , b , c ) == 1 ) { cout << " major " << endl ; return 0 ; } if ( check ( a , b , c ) == 2 ) { cout << " minor " << endl ; return 0 ; } if ( check ( a , c , b ) == 1 ) { cout << " major " << endl ; return 0 ; } if ( check ( a , c , b ) == 2 ) { cout << " minor " << endl ; return 0 ; } if ( check ( b , a , c ) == 1 ) { cout << " major " << endl ; return 0 ; } if ( check ( b , a , c ) == 2 ) { cout << " minor " << endl ; return 0 ; } if ( check ( b , c , a ) == 1 ) { cout << " major " << endl ; return 0 ; } if ( check ( b , c , a ) == 2 ) { cout << " minor " << endl ; return 0 ; } if ( check ( c , a , b ) == 1 ) { cout << " major " << endl ; return 0 ; } if ( check ( c , a , b ) == 2 ) { cout << " minor " << endl ; return 0 ; } if ( check ( c , b , a ) == 1 ) { cout << " major " << endl ; return 0 ; } if ( check ( c , b , a ) == 2 ) { cout << " minor " << endl ; return 0 ; } cout << " strange " << endl ; return 0 ; }
TAB0 create constant integer MAX_N with MAX_N = 100 + 10 ; TAB0 create 2d character array _map with size MAX_N by MAX_N ; TAB0 create integer arrays row , column with row size MAX_N , column size MAX_N ; TAB0 create integer n ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive , read _map [ i ] [ j ] ; TAB1 create integer cnt with cnt = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if _map [ i ] [ j ] is ' . ' ; TAB4 increment cnt ; TAB4 set row [ i ] to j ; TAB4 break loop ; TAB1 if cnt is n ; TAB2 for i = 1 to n inclusive , print i print " " print row [ i ] print newline ; TAB1 set cnt to 0 ; TAB1 for j = 1 to n inclusive ; TAB2 for i = 1 to n inclusive ; TAB3 if _map [ i ] [ j ] is ' . ' ; TAB4 increment cnt ; TAB4 set column [ j ] to i ; TAB4 break loop ; TAB1 if cnt is n ; TAB2 for j = 1 to n inclusive , print column [ j ] to " " print j print newline ; TAB1 print - 1 print newline ;	const int MAX_N = 100 + 10 ; char _map [ MAX_N ] [ MAX_N ] ; int row [ MAX_N ] , column [ MAX_N ] ; int n ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) cin >> _map [ i ] [ j ] ; int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( _map [ i ] [ j ] == ' . ' ) { cnt ++ ; row [ i ] = j ; break ; } } } if ( cnt == n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i << "   " << row [ i ] << endl ; return 0 ; } cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( _map [ i ] [ j ] == ' . ' ) { cnt ++ ; column [ j ] = i ; break ; } } } if ( cnt == n ) { for ( int j = 1 ; j <= n ; j ++ ) cout << column [ j ] << "   " << j << endl ; return 0 ; } cout << - 1 << endl ; return 0 ; }
TAB0 let adj be integer vector of size 101 ; TAB0 let dis be int with dis = 0 ; TAB0 create boolean array vis of size 101 ; TAB0 let n be int ; TAB0 in the function gcd which takes two integers a and b and returns an integer ; TAB1 if b = 0 ; TAB2 then return a ; TAB1 else do the following ; TAB2 call gcd on b and a mod b ; TAB0 in the function lcm which takes two integers a and b and returns an integer ; TAB1 return ( a * b ) / gcd ( a , b ) ; TAB0 create integer vector ans ; TAB0 in the function dfs which takes a integer ; TAB1 set vis [ start ] to true ; TAB1 create integer size = size of adj [ start ] ; TAB1 increment dis ; TAB1 for i = 0 to size inclusive ; TAB2 create int v = adj [ start ] [ i ] ; TAB2 if vis [ v ] is false then call dfs on v ; TAB0 let masuk be an integer array of size 101 ; TAB0 in the function lakukan ; TAB1 set dis = 0 ; TAB1 for int i = 1 to n inclusive ; TAB2 if vis [ i ] is false ; TAB3 set dis to 0 ; TAB3 call dfs on i ; TAB3 Add dis to the end of ans ; TAB1 create integer size = ans . size - 1 ; TAB1 for i = 0 to size inclusive ; TAB2 if ans [ i ] % 2 is 0 then set ans [ i ] to ans [ i ] / 2 ; TAB1 create integer hasil = 1 ; TAB1 for i = 0 to size inclusive set hasil = lcm of hasil and ans [ i ] ; TAB1 print hasil ; TAB1 read n ; TAB1 set all content of masuk to 0 ; TAB1 set all content of vis to false ; TAB1 for i = 1 to n inclusive ; TAB2 x = integer ; TAB2 read x ; TAB2 increment masuk [ x ] ; TAB2 add x to end of adj [ i ] ; TAB1 create boolean bisa = true ; TAB1 for i = 1 to n inclusive ; TAB2 if masuk [ i ] is not 1 then set bisa = false ; TAB1 if bisa = false ; TAB2 then print - 1 and new line ; TAB1 else do the following ; TAB2 call lakukan ;	vector < int > adj [ 101 ] ; int dis = 0 ; bool vis [ 101 ] ; int n ; int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return gcd ( b , a % b ) ; } } int lcm ( int a , int b ) { return ( ( a * b ) / gcd ( a , b ) ) ; } vector < int > ans ; void dfs ( int start ) { vis [ start ] = true ; int size = adj [ start ] . size ( ) ; dis ++ ; for ( int i = 0 ; i <= size - 1 ; i ++ ) { int v = adj [ start ] [ i ] ; if ( ! vis [ v ] ) { dfs ( v ) ; } } } int masuk [ 101 ] ; void lakukan ( ) { dis = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) { dis = 0 ; dfs ( i ) ; ans . push_back ( dis ) ; } } int size = ans . size ( ) - 1 ; for ( int i = 0 ; i <= size ; i ++ ) { if ( ans [ i ] % 2 == 0 ) { ans [ i ] = ans [ i ] / 2 ; } } int hasil = 1 ; for ( int i = 0 ; i <= size ; i ++ ) { hasil = lcm ( hasil , ans [ i ] ) ; } cout << hasil << endl ; } int main ( ) { cin >> n ; memset ( masuk , ( 0 ) , sizeof ( masuk ) ) ; memset ( vis , ( false ) , sizeof ( vis ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { int x ; cin >> x ; masuk [ x ] ++ ; adj [ i ] . push_back ( x ) ; } bool bisa = true ; for ( int i = 1 ; i <= n ; i ++ ) { if ( masuk [ i ] != 1 ) bisa = false ; } if ( bisa == false ) { cout << - 1 << endl ; } else { lakukan ( ) ; } return 0 ; }
TAB0 declare boolean ok ; TAB1 declare integer n , m , i , arrays a and b both with lengths of 10 ; TAB1 read n and m ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 for i = 0 to m exclusive , read b [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to m exclusive ; TAB3 if a [ i ] is equal to b [ j ] ; TAB4 if ok , print " " ; TAB4 print a [ i ] ; TAB4 if ok equals false , assign true to ok ; TAB1 print newline ;	bool ok ; int main ( ) { int n , m , i , a [ 10 ] , b [ 10 ] ; cin >> n >> m ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } for ( i = 0 ; i < m ; i ++ ) { cin >> b [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ] ) { if ( ok ) cout << "   " ; cout << a [ i ] ; if ( ok == false ) { ok = true ; } } } } cout << endl ; }
TAB1 let str be a string ; TAB1 read str ; TAB1 create a empty string res ; TAB1 let k be a long integer with k = str [ 0 ] - 0 ; TAB1 let i be a long integer ; TAB1 increment res by str [ 0 ] ; TAB1 for i = 1 to length of str exclusive ; TAB2 if str [ i ] - 0 is equal to k ; TAB3 increment res by str [ i ] ; TAB2 else do the following ; TAB3 stop ; TAB1 if i is equal to length of str ; TAB2 print res . substr ( 1 ) and newline ; TAB1 else do the following ; TAB2 increment i by 1 ; TAB2 for i is less than length of str , increment i by 1 , increment res by str [ i ] ; TAB2 print res and newline ;	int main ( ) { string str ; cin >> str ; string res = "  " ; long long k = str [ 0 ] - ' 0 ' ; long long i ; res += str [ 0 ] ; for ( i = 1 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] - ' 0 ' == k ) { res += str [ i ] ; } else break ; } if ( i == str . length ( ) ) { cout << res . substr ( 1 ) << endl ; } else { i ++ ; for ( ; i < str . length ( ) ; i ++ ) { res += str [ i ] ; } cout << res << endl ; } }
TAB0 declare inline bs with unsigned long long pointer V , unsigned long longs k , a as arguments , returning unsigned long long ; TAB1 create unsigned long longs j , i , with j = k / 2 , i = 0 ; TAB1 while V [ j ] is not a and i is less than j and j is less than k ; TAB2 if a is less than V [ j ] ; TAB3 set k to j ; TAB3 set j to i + ( j - 1 ) / 2 ; TAB2 else ; TAB3 set i to j ; TAB3 set j to ( k - j ) / 2 + j ; TAB1 return j from function ; TAB1 create unsigned long longs n , k , i , j , a , c , with i = 0 , c = 0 ; TAB1 create unsigned long long array A with size 100000 ; TAB1 create boolean array B with size 100000 with B = { } ; TAB1 read n read k ; TAB1 if k is 1 ; TAB2 print n print ' \ n ' ; TAB1 while i is less than n ; TAB2 read A [ i ] ; TAB2 increment i ; TAB1 sort elements from A to A + n ; TAB1 set i to 0 ; TAB1 while i is less than n ; TAB2 if not B [ i ] ; TAB3 increment c ; TAB3 set a to A [ i ] * k ; TAB3 set j to result of run bs with A , n , a as arguments ; TAB3 if A [ j ] is a , set B [ j ] to true ; TAB2 increment i ; TAB1 print c print newline ;	inline unsigned long long bs ( unsigned long long * V , unsigned long long k , unsigned long long a ) { unsigned long long j = k / 2 , i = 0 ; while ( V [ j ] != a and i < j and j < k ) { if ( a < V [ j ] ) { k = j ; j = i + ( j - i ) / 2 ; } else { i = j ; j = ( k - j ) / 2 + j ; } } return j ; } int main ( ) { unsigned long long n , k , i = 0 , j , a , c = 0 ; unsigned long long A [ 100000 ] ; bool B [ 100000 ] = { } ; cin >> n >> k ; if ( k == 1 ) { cout << n << ' \n ' ; return 0 ; } while ( i < n ) { cin >> A [ i ] ; ++ i ; } sort ( A , A + n ) ; i = 0 ; while ( i < n ) { if ( ! B [ i ] ) { c ++ ; a = A [ i ] * k ; j = bs ( A , n , a ) ; if ( A [ j ] == a ) { B [ j ] = true ; } } ++ i ; } cout << c << endl ; return 0 ; }
TAB0 create integer vector out ; TAB1 integers = N ; TAB1 read N ; TAB1 set integer reports to 0 ; TAB1 set integer neg to 0 ; TAB1 for i = 0 to less than N do the following ; TAB2 integers = A ; TAB2 read A ; TAB2 if A is greater than or equal to 0 then do the following ; TAB3 add one to reports ; TAB2 else if neg is 2 then do the following ; TAB3 push_back part of out = reports ; TAB3 set reports to 1 ; TAB3 set neg to 1 ; TAB2 else ; TAB3 add one to reports ; TAB3 add one to neg ; TAB1 if reports is greater than 0 then do the following out . push_back ( reports ; TAB1 output out . size ( ) ; TAB1 for i = 0 to less than out . size ( ) do the following ; TAB2 if i > 0 then print a space ; TAB2 output out [ i ] ; TAB1 output an endline ;	vector < int > out ; int main ( ) { int N ; cin >> N ; int reports = 0 ; int neg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int A ; cin >> A ; if ( A >= 0 ) { reports ++ ; } else if ( neg == 2 ) { out . push_back ( reports ) ; reports = 1 ; neg = 1 ; } else { reports ++ ; neg ++ ; } } if ( reports > 0 ) { out . push_back ( reports ) ; } cout << out . size ( ) << endl ; for ( int i = 0 ; i < out . size ( ) ; i ++ ) { if ( i > 0 ) { cout << "   " ; } cout << out [ i ] ; } cout << endl ; return 0 ; }
TAB0 declare const int N = 1e5 + 5 ; TAB0 create character array str with N elements ; TAB0 declare bool variables f1 and f2 and bool array flg with size N ; TAB0 create integer len ; TAB0 inline void function ac ; TAB1 print " YES " ; TAB0 inline void function wa ; TAB1 print " NO " ; TAB0 inline bool function judge1 with int argument x ; TAB1 return true if str [ x ] = ' A ' & & str [ x + 1 ] = ' B ' , or else false ; TAB0 inline bool function judge2 with int argument x ; TAB1 return true if str [ x ] = ' B ' & & str [ x + 1 ] = ' A ' or else false ; TAB0 function check1 with int argument x that returns inline bool ; TAB1 set flg [ x ] to set flg [ x + 1 ] to true ; TAB1 loop i from 0 to len - 1 exclusive ; TAB2 return true if flg [ i ] is false and flg [ i + 1 ] is false and judge2 ( i ) is true ; TAB1 set flg [ x ] and flg [ x + 1 ] to false ; TAB1 return false ; TAB0 check2 is a an inlined bool function with int argument x ; TAB1 change flg [ x + 1 ] and flg [ x ] to true ; TAB1 for integer i = 0 to len - 1 exclusive ; TAB2 return true if flg [ i ] is false and flg [ i + 1 ] is false and judge1 ( i ) is true ; TAB1 assign false to flg [ x + 1 ] and flg [ x ] ; TAB1 return false ; TAB1 read input to str ; TAB1 set len to length of str ; TAB1 set first sizeof ( flg ) bytes at the pointer flg to false ; TAB1 change value of f1 and f2 to false ; TAB1 loop i from 0 to len - 1 exclusive ; TAB2 if f1 is false and judge1 ( i ) is true ; TAB3 invert f1 ; TAB3 if check1 ( i ) is true ; TAB4 call ac ( ) ; TAB2 if f2 is false and judge2 ( i ) is true ; TAB3 invert f2 ; TAB3 if check2 ( i ) is true ; TAB4 call ac ( ) ; TAB1 call wa ( ) ;	const int N = 1e5 + 5 ; char str [ N ] ; bool flg [ N ] , f1 , f2 ; int len ; inline void ac ( ) { cout << " YES " << endl ; } inline void wa ( ) { cout << " NO " << endl ; } inline bool judge1 ( int x ) { return ( str [ x ] == ' A ' && str [ x + 1 ] == ' B ' ) ? true : false ; } inline bool judge2 ( int x ) { return ( str [ x ] == ' B ' && str [ x + 1 ] == ' A ' ) ? true : false ; } inline bool check1 ( int x ) { flg [ x ] = flg [ x + 1 ] = true ; for ( int i = 0 ; i < len - 1 ; i ++ ) if ( ! flg [ i ] && ! flg [ i + 1 ] && judge2 ( i ) ) return true ; flg [ x ] = flg [ x + 1 ] = false ; return false ; } inline bool check2 ( int x ) { flg [ x ] = flg [ x + 1 ] = true ; for ( int i = 0 ; i < len - 1 ; i ++ ) if ( ! flg [ i ] && ! flg [ i + 1 ] && judge1 ( i ) ) return true ; flg [ x ] = flg [ x + 1 ] = false ; return false ; } int main ( ) { cin >> str ; len = strlen ( str ) ; memset ( flg , false , sizeof ( flg ) ) ; f1 = f2 = false ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( ! f1 && judge1 ( i ) ) { f1 = ! f1 ; if ( check1 ( i ) ) { ac ( ) ; return 0 ; } } if ( ! f2 && judge2 ( i ) ) { f2 = ! f2 ; if ( check2 ( i ) ) { ac ( ) ; return 0 ; } } } wa ( ) ; }
TAB1 create new string variable path ; TAB1 read line from the input into path ; TAB1 declare new string output ; TAB1 declare new boolean called flag ; TAB1 start a loop from k = 0 to length of path exclusive , incrementing k ; TAB2 if path [ k ] ! = ' / ' or flag = 0 , change output to output + path [ k ] ; TAB2 if path [ k ] is equal to ' / ' ; TAB3 set the value of flag to 1 ; TAB2 else ; TAB3 change the value of flag to 0 ; TAB1 if flag is true and length of output > 1 , change output to the substring of the output = output itself ; TAB1 print output ;	int main ( ) { string path ; getline ( cin , path ) ; string output ; bool flag ( 0 ) ; for ( int k = 0 ; k < path . size ( ) ; k ++ ) { if ( path [ k ] != ' / ' || flag == 0 ) { output += path [ k ] ; } if ( path [ k ] == ' / ' ) { flag = 1 ; } else { flag = 0 ; } } if ( flag && output . size ( ) > 1 ) { output = output . substr ( 0 , output . size ( ) - 1 ) ; } cout << output << endl ; return 0 ; }
TAB0 n , m , vert , edge = long long int and c = long long int array of size 150005 ; TAB0 adj = long long int vector of size 150005 ; TAB0 in function dfs taking a long long int v ; TAB1 add size of adj [ v ] to edge ; TAB1 increment vert ; TAB1 set c [ v ] to 1 ; TAB1 for j = 0 to size of adj [ v ] ; TAB2 if c [ adj [ v ] [ j ] ] equals 0 then call dfs of adj [ v ] [ j ] ; TAB1 i , x , y = long long int ; TAB1 read n then m ; TAB1 for i = 0 to m ; TAB2 read x then y ; TAB2 append y to adj [ x ] ; TAB2 append x to adj [ y ] ; TAB1 for i = 1 to n inclusive ; TAB2 set vert to 0 ; TAB2 set edge to 0 ; TAB2 if c [ i ] equals 0 ; TAB3 call dfs of i ; TAB3 if vert * ( vert - 1 ) does not equal edge then print " NO " and call exit of 0 ; TAB1 print " YES " ;	long long int n , m , c [ 150005 ] , vert , edge ; vector < long long int > adj [ 150005 ] ; void dfs ( long long int v ) { edge += adj [ v ] . size ( ) ; vert ++ ; c [ v ] = 1 ; for ( long long int j = 0 ; j < adj [ v ] . size ( ) ; j ++ ) { if ( c [ adj [ v ] [ j ] ] == 0 ) { dfs ( adj [ v ] [ j ] ) ; } } } int main ( ) { long long int i , x , y ; cin >> n >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> x >> y ; adj [ x ] . push_back ( y ) ; adj [ y ] . push_back ( x ) ; } for ( i = 1 ; i <= n ; i ++ ) { vert = 0 ; edge = 0 ; if ( c [ i ] == 0 ) { dfs ( i ) ; if ( vert * ( vert - 1 ) != edge ) cout << " NO\n " , exit ( 0 ) ; } } cout << " YES\n " ; }
TAB0 let a , b , c , d , r , p , t , and ans be integers , let h be an integer array of length 150 ; TAB0 let f be a boolen array of length 30 ; TAB1 read in a , b , c , and d ; TAB1 set r to a + b ; TAB1 iterate for a times , set h [ i ] to i ; TAB1 iterate for b times , set h [ a + i } to a ; TAB1 iterate for b times , set h [ r + 1 ] to i ; TAB1 iterate for a times , set h [ r + b + i ] to a + i ; TAB1 iterate for b times , set h [ r + a + i ] to h { r + a ] ; TAB1 if b is greater than or equal to a ; TAB2 for i = r + a to r + r , increment h [ i ] ; TAB1 set r to 2 * r ; TAB1 d is equal to the min of d and c + r ; TAB1 for i = c to d times ; TAB2 set t to h [ ( i - 1 ) % r + 1 ] ; TAB2 if f [ t ] is not true , increment p ; TAB2 set f [ t ] to true ; TAB1 set ans to p ; TAB1 set p to 0 ; TAB1 change all values in f to 0 ; TAB1 if a - b > 1 and d - c + 1 > a + b ; TAB2 iterate for b times , set h [ a + j ] to h [ b + 1 ] ; TAB2 iterate for a times ; TAB3 let k be an integer ; TAB3 while true ; TAB4 increment k ; TAB4 let flag be a boolean , set flag to true ; TAB4 for i = b + 1 to a + b + j - 1 ; TAB5 if h [ i ] is equal to k , set flag to false ; TAB4 if flag is true , break out of the loop ; TAB3 set h [ a + b + j ] to k ; TAB2 iterate for b times , set h [ a + a + b + j ] to h [ a + b + b + 1 ] ; TAB1 for i = c iterate until i = d ; TAB2 set t to h [ ( i - 1 ) % r + 1 ] ; TAB2 if f [ t ] is not true , increment p ; TAB2 set f [ t ] to true ; TAB1 print the min of p and ans ;	int a , b , c , d , r , h [ 150 ] , p , t , ans ; bool f [ 30 ] ; int main ( ) { cin >> a >> b >> c >> d ; r = a + b ; for ( int i = 1 ; i <= a ; i ++ ) h [ i ] = i ; for ( int i = 1 ; i <= b ; i ++ ) h [ a + i ] = a ; for ( int i = 1 ; i <= b ; i ++ ) h [ r + i ] = i ; for ( int i = 1 ; i <= a ; i ++ ) h [ r + b + i ] = a + i ; for ( int i = 1 ; i <= b ; i ++ ) h [ r + a + i ] = h [ r + a ] ; if ( b >= a ) for ( int i = r + a ; i <= r + r ; i ++ ) h [ i ] ++ ; r *= 2 ; d = min ( d , c + r ) ; for ( int i = c ; i <= d ; i ++ ) { t = h [ ( i - 1 ) % r + 1 ] ; if ( ! f [ t ] ) p ++ ; f [ t ] = true ; } ans = p ; p = 0 ; memset ( f , 0 , sizeof ( f ) ) ; if ( a - b > 1 && d - c + 1 > a + b ) { for ( int j = 1 ; j <= b ; j ++ ) h [ a + j ] = h [ b + 1 ] ; for ( int j = 1 ; j <= a ; j ++ ) { int k = 0 ; while ( 1 ) { k ++ ; bool flag = true ; for ( int i = b + 1 ; i < a + b + j ; i ++ ) if ( h [ i ] == k ) flag = false ; if ( flag ) break ; } h [ a + b + j ] = k ; } for ( int j = 1 ; j <= b ; j ++ ) h [ a + a + b + j ] = h [ a + b + b + 1 ] ; } for ( int i = c ; i <= d ; i ++ ) { t = h [ ( i - 1 ) % r + 1 ] ; if ( ! f [ t ] ) p ++ ; f [ t ] = true ; } cout << min ( p , ans ) << endl ; }
TAB0 INF = const long long with INF = 9223372036854775807LL ; TAB0 PI = const double with PI = acos of - 1 ; TAB0 MAX_N = const int with MAX_N = 1e + 6 ; TAB0 ALPH = const int with ALPH = 26 ; TAB0 alph = const string with alph = " abcdefghijklmnopqrstuvwxyz " ; TAB0 in function count taking reference to int pos , reference to string s , reference to int xd ; TAB1 l = int with l = size of s ; TAB1 loop while pos < 1 ; TAB2 if s [ pos ] is ' | ' ; TAB3 increment xd ; TAB3 increment pos ; TAB2 else ; TAB3 break ; TAB1 increment pos ; TAB0 in function print taking int a , int b , int c ; TAB1 for i = 0 to a print " | " ; TAB1 print " + " ; TAB1 for i = 0 to b print " | " ; TAB1 print " = " ; TAB1 for i = 0 to c print " | " ; TAB1 print newline ; TAB0 in function check taking int a , int b , int c and returning bool ; TAB1 if a < = 0 or b < = 0 or c < = 0 return false ; TAB1 return a + b is c ; TAB0 in function solve ; TAB1 s = string ; TAB1 read s ; TAB1 l = int with l = size of s ; TAB1 a , b , c = int ; TAB1 set a , b and c to 0 ; TAB1 pos = int with pos = 0 ; TAB1 call count of pos , s , a ; TAB1 call count of pos , s , b ; TAB1 call count of pos , s , c ; TAB1 if a + b is c ; TAB2 call print of a , b , c ; TAB1 else ; TAB2 if check of a + 1 , b - 1 , c ; TAB3 call print of a + 1 , b - 1 , c ; TAB3 return ; TAB2 if check of a + 1 , b , c - 1 ; TAB3 call print of a + 1 , b , c - 1 ; TAB3 return ; TAB2 if check of a - 1 , b + 1 , c ; TAB3 call print of a - 1 , b + 1 , c ; TAB3 return ; TAB2 if check of a , b + 1 , c - 1 ; TAB3 call print of a , b + 1 , c - 1 ; TAB3 return ; TAB2 if check of a - 1 , b , c + 1 ; TAB3 call print of a - 1 , b , c + 1 ; TAB3 return ; TAB2 if check of a , b - 1 , c + 1 ; TAB3 call print of a , b - 1 , c + 1 ; TAB3 return ; TAB2 print " Impossible " ; TAB1 t = int with t = 1 ; TAB1 loop t times call solve ;	const long long INF = 9223372036854775807LL ; const long double PI = acos ( - 1 ) ; const int MAX_N = 1e+6 ; const int ALPH = 26 ; const string alph = " abcdefghijklmnopqrstuvwxyz " ; void count ( int & pos , string & s , int & xd ) { int l = s . size ( ) ; while ( pos < l ) { if ( s [ pos ] == ' | ' ) { xd ++ ; pos ++ ; } else break ; } pos ++ ; } void print ( int a , int b , int c ) { for ( int i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; } bool check ( int a , int b , int c ) { if ( a <= 0 or b <= 0 or c <= 0 ) return false ; return a + b == c ; } void solve ( ) { string s ; cin >> s ; int l = s . size ( ) ; int a , b , c ; a = b = c = 0 ; int pos = 0 ; count ( pos , s , a ) ; count ( pos , s , b ) ; count ( pos , s , c ) ; if ( a + b == c ) { print ( a , b , c ) ; } else { if ( check ( a + 1 , b - 1 , c ) ) { print ( a + 1 , b - 1 , c ) ; return ; } if ( check ( a + 1 , b , c - 1 ) ) { print ( a + 1 , b , c - 1 ) ; return ; } if ( check ( a - 1 , b + 1 , c ) ) { print ( a - 1 , b + 1 , c ) ; return ; } if ( check ( a , b + 1 , c - 1 ) ) { print ( a , b + 1 , c - 1 ) ; return ; } if ( check ( a - 1 , b , c + 1 ) ) { print ( a - 1 , b , c + 1 ) ; return ; } if ( check ( a , b - 1 , c + 1 ) ) { print ( a , b - 1 , c + 1 ) ; return ; } cout << " Impossible " << endl ; } } int main ( ) { int t = 1 ; while ( t -- ) solve ( ) ; return 0 ; }
TAB0 create constant integer MAXN = 55 ; TAB0 let char array mp of size MAXN with array of size MAXN ; TAB0 make bool vis of size MAXN with array of size MAXN ; TAB0 create constant integer array go of size 4 with array of size 2 containing { 0 , 1 , 0 , - 1 , - 1 , 0 , 1 , 0 } ; TAB0 make ints n , m , and all = 0 ; TAB0 declare dfs taking in ints x and y and returning integer ; TAB1 create int ans = 1 ; TAB1 for i = 0 to 4 exclusive ; TAB2 create ints xx = x + go [ i ] [ 0 ] and yy = y + go [ i ] [ 1 ] ; TAB2 if mp [ xx ] [ yy ] is equal to ' # ' and vis [ xx ] [ yy ] is falsy ; TAB3 set vis [ xx ] [ yy ] to true ; TAB3 set ans to ans + dfs ( x + go [ i ] [ 0 ] , y + go [ i ] [ 1 ] ) ; TAB1 return ans ; TAB0 declare solve ; TAB1 if all is less than or equal to 2 , return - 1 ; TAB1 for i = 1 to n ; TAB2 for j = 1 to m ; TAB3 if mp [ i ] [ j ] is equal to ' # ' ; TAB4 set mp [ i ] [ j ] to ' . ' ; TAB4 create integer t = 0 ; TAB4 for k = 0 to 4 exclusive ; TAB5 make ints xx = i + go [ k ] [ 0 ] and yy = j + go [ k ] [ 1 ] ; TAB5 if mp [ xx ] [ yy ] is equal to ' # ' ; TAB6 set all contents of vis to 0 ; TAB6 set vis [ xx ] [ yy ] to true ; TAB6 set t to dfs ( xx , yy ) ; TAB6 break loop ; TAB4 set mp [ i ] [ j ] to ' # ' ; TAB4 if t is 0 , return - 1 ; TAB4 if t is not all - 1 , return 1 ; TAB1 return 2 ; TAB1 read n and m ; TAB1 set all contents of mp to ' . ' ; TAB1 for i = 1 to n ; TAB2 for j = 1 to m ; TAB3 read mp [ i ] [ j ] ; TAB3 if mp [ i ] [ j ] is equal to ' # ' , increment all ; TAB1 print result of solve ( ) ;	const int MAXN = 55 ; char mp [ MAXN ] [ MAXN ] ; bool vis [ MAXN ] [ MAXN ] ; const int go [ 4 ] [ 2 ] = { 0 , 1 , 0 , - 1 , - 1 , 0 , 1 , 0 } ; int n , m , all = 0 ; int dfs ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + go [ i ] [ 0 ] , yy = y + go [ i ] [ 1 ] ; if ( mp [ xx ] [ yy ] == ' # ' && ! vis [ xx ] [ yy ] ) { vis [ xx ] [ yy ] = true ; ans += dfs ( x + go [ i ] [ 0 ] , y + go [ i ] [ 1 ] ) ; } } return ans ; } int solve ( ) { if ( all <= 2 ) return - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( mp [ i ] [ j ] == ' # ' ) { mp [ i ] [ j ] = ' . ' ; int t = 0 ; for ( int k = 0 ; k < 4 ; k ++ ) { int xx = i + go [ k ] [ 0 ] , yy = j + go [ k ] [ 1 ] ; if ( mp [ xx ] [ yy ] == ' # ' ) { memset ( vis , 0 , sizeof ( vis ) ) ; vis [ xx ] [ yy ] = true ; t = dfs ( xx , yy ) ; break ; } } mp [ i ] [ j ] = ' # ' ; if ( t == 0 ) return - 1 ; if ( t != all - 1 ) { return 1 ; } } } } return 2 ; } int main ( ) { cin >> n >> m ; memset ( mp , ' . ' , sizeof ( mp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { cin >> mp [ i ] [ j ] ; if ( mp [ i ] [ j ] == ' # ' ) ++ all ; } } cout << solve ( ) << endl ; return 0 ; }
TAB1 n = integer ; TAB1 s = string ; TAB1 input n , s ; TAB1 one and zero are both integers both set to 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is the character 0 ; TAB3 increment zero ; TAB2 else ; TAB3 increment one ; TAB1 if one isn ' t 0 , display 1 ; TAB1 for i = 0 to zero exclusive , display 0 ; TAB1 display newline ;	int main ( ) { int n ; string s ; cin >> n >> s ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' 0 ' ) zero ++ ; else one ++ ; } if ( one != 0 ) cout << " 1 " ; for ( int i = 0 ; i < zero ; i ++ ) cout << " 0 " ; cout << endl ; return 0 ; }
TAB0 cnt = array of 256 int ; TAB1 word = string ; TAB1 read word ; TAB1 for i = 0 to size of word exclusive increment cnt [ word [ i ] ] ; TAB1 ans = cnt [ ' i ' ] ; TAB1 ans = min ( ans , cnt [ ' t ' ] ) ; TAB1 ans = min ( ans , ( cnt [ ' n ' ] - 1 ) / 2 ) ; TAB1 ans = min ( ans , cnt [ ' e ' ] / 3 ) ; TAB1 print ans ; TAB1 return EXIT_SUCCESS ;	int cnt [ 256 ] ; int main ( ) { string word ; cin >> word ; for ( int i = 0 ; i < word . size ( ) ; ++ i ) ++ cnt [ word [ i ] ] ; int ans = cnt [ ' i ' ] ; ans = min ( ans , cnt [ ' t ' ] ) ; ans = min ( ans , ( cnt [ ' n ' ] - 1 ) / 2 ) ; ans = min ( ans , cnt [ ' e ' ] / 3 ) ; cout << ans << endl ; return EXIT_SUCCESS ; }
TAB0 N = const int with N = 110 ; TAB0 n , r , cnt = integers with cnt = array of size N ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read r ; TAB2 for j = 0 to r exclusive ; TAB3 tmp = integer ; TAB3 read tmp ; TAB3 increment cnt [ tmp ] ; TAB1 flag = integer with flag = 0 ; TAB1 for i = 0 to N exclusive ; TAB2 if ( cnt [ i ] is n ) ; TAB3 if ( not flag ) ; TAB4 print i ; TAB4 flag = 1 ; TAB3 else ; TAB4 print " " ; TAB1 print new line ;	const int N = 110 ; int n , r , cnt [ N ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> r ; for ( int j = 0 ; j < r ; j ++ ) { int tmp ; cin >> tmp ; cnt [ tmp ] ++ ; } } int flag = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( cnt [ i ] == n ) { if ( ! flag ) { cout << i ; flag = 1 ; } else cout << "   " << i ; } } cout << endl ; }
TAB0 create int a [ 1000100 ] ; TAB1 create int n ; TAB1 while read n ; TAB2 while decrement n ; TAB3 create int b ; TAB3 read b ; TAB3 increment a [ b ] ; TAB2 num = 0 ; TAB2 for i = 0 to 1000100 - 1 inclusive ; TAB3 assign a [ i ] / 2 + a [ i + 1 ] to a [ i + 1 ] ; TAB3 set a [ i ] = a [ i ] mod 2 ; TAB3 set num to num + a [ i ] ; TAB2 print num ;	int a [ 1000100 ] ; int main ( ) { int n ; while ( cin >> n ) { while ( n -- ) { int b ; cin >> b ; a [ b ] ++ ; } int num = 0 ; for ( int i = 0 ; i <= 1000100 - 1 ; i ++ ) { a [ i + 1 ] += a [ i ] / 2 ; a [ i ] = a [ i ] % 2 ; num += a [ i ] ; } cout << num << endl ; } }
TAB0 create new array of long longs dp with 5000 elements ; TAB0 create a map from long longs to long longs called m ; TAB1 create new long long called n ; TAB1 read from the input to n ; TAB1 create string variable s ; TAB1 read s from the user input ; TAB1 declare long long variable cnt with value 0 ; TAB1 for i = 0 to length of s exclusive ; TAB2 if i is not 0 ; TAB3 change dp [ i + 1 ] to dp [ i ] + ( s [ i ] - ' 0 ' ) ; TAB2 else ; TAB3 set dp [ i + 1 ] to s [ i ] - ' 0 ' ; TAB1 in a for loop , change i from 1 to length of s inclusive incrementing i ; TAB2 change j from 1 to i inclusive in a loop , incrementing j ; TAB3 increase m [ dp [ i ] - dp [ j - 1 ] ] ; TAB3 increment cnt by one ; TAB1 if n is equal to 0 ; TAB2 declare new long long variable ans2 = m [ 0 ] * 2 * cnt - m [ 0 ] * m [ 0 ] ; TAB2 print ans2 to the standard output ; TAB1 declare new long long ans with value 0 ; TAB1 start for loop from i = 1 to the square root of n inclusive incrementing i ; TAB2 if n modulo i = 0 and i ! = sqrt ( n ) ; TAB3 change ans to ans + 2 * ( m [ i ] * m [ n / i ] ) ; TAB2 else if i is equal to the square root of n ; TAB3 change ans to ans + ( m [ i ] * m [ n / i ] ) ; TAB1 print ans to the standard output ;	long long dp [ 5000 ] ; map < long long , long long > m ; int main ( ) { long long n ; cin >> n ; string s ; cin >> s ; long long cnt = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i != 0 ) dp [ i + 1 ] = dp [ i ] + ( s [ i ] - ' 0 ' ) ; else dp [ i + 1 ] = s [ i ] - ' 0 ' ; } for ( int i = 1 ; i <= s . size ( ) ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { m [ dp [ i ] - dp [ j - 1 ] ] ++ ; cnt ++ ; } } if ( n == 0 ) { long long ans2 = m [ 0 ] * 2 * cnt - m [ 0 ] * m [ 0 ] ; cout << ans2 << endl ; return 0 ; } long long ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 && ! ( i == sqrt ( n ) ) ) { ans += 2 * ( m [ i ] * m [ n / i ] ) ; } else if ( i == sqrt ( n ) ) { ans += ( m [ i ] * m [ n / i ] ) ; } } cout << ans << endl ; return 0 ; }
TAB0 declare constant integer inf = 0x3f3f3f3f ; TAB0 declare constant long long linf = 1e18 ; TAB0 declare constant integer N = 100000 + 10 ; TAB0 declare constant double eps = 1e - 10 ; TAB0 declare constant integer mo = 1e9 + 7 ; TAB0 declare integers n , m ; TAB0 declare integer array st size N ; TAB0 declare integer vector arrays g size N , r size N ; TAB0 declare boolean arrays vis size N , path size N by 2 ; TAB0 declare dfs with integer x , integer vector array g , integer k as arguments , returning void ; TAB1 let vis [ x ] be path [ x ] [ k ] be 1 ; TAB1 for i = 0 to size of g [ x ] exclusive ; TAB2 declare integer y = g [ x ] [ i ] ; TAB2 if not vis [ y ] ; TAB3 if st [ y ] is 1 ; TAB4 if k is 1 , let path [ y ] [ k ] be 1 ; TAB4 end current loop ; TAB3 run dfs with y , g , k as arguments ; TAB1 read n and m ; TAB1 for i = 1 to n inclusive , read st [ i ] ; TAB1 for i = 1 to m inclusive ; TAB2 declare integers x , y ; TAB2 read x and y ; TAB2 add y to end of g [ x ] ; TAB2 add x to end of r [ y ] ; TAB1 for i = 1 to n inclusive ; TAB2 if not vis [ i ] and st [ i ] is 1 , run dfs ( i , g , 0 ) ; TAB1 set bytes from vis to size of vis to value 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if not vis [ i ] and st [ i ] is 2 , run dfs ( i , r , 1 ) ; TAB1 for i = 1 to n inclusive ; TAB2 if path [ i ] [ 0 ] and path [ i ] [ 1 ] ; TAB3 print 1 and newline ; TAB2 else ; TAB3 print 0 and newline ;	const int inf = 0x3f3f3f3f ; const long long linf = 1e18 ; const int N = 100000 + 10 ; const double eps = 1e-10 ; const int mo = 1e9 + 7 ; int n , m ; int st [ N ] ; vector < int > g [ N ] , r [ N ] ; bool vis [ N ] , path [ N ] [ 2 ] ; void dfs ( int x , vector < int > g [ ] , int k ) { vis [ x ] = path [ x ] [ k ] = 1 ; for ( int i = 0 ; i < g [ x ] . size ( ) ; i ++ ) { int y = g [ x ] [ i ] ; if ( ! vis [ y ] ) { if ( st [ y ] == 1 ) { if ( k == 1 ) path [ y ] [ k ] = 1 ; continue ; } dfs ( y , g , k ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> st [ i ] ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; g [ x ] . push_back ( y ) ; r [ y ] . push_back ( x ) ; } for ( int i = 1 ; i <= n ; i ++ ) if ( ! vis [ i ] && st [ i ] == 1 ) dfs ( i , g , 0 ) ; memset ( vis , 0 , sizeof vis ) ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! vis [ i ] && st [ i ] == 2 ) dfs ( i , r , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( path [ i ] [ 0 ] && path [ i ] [ 1 ] ) cout << 1 << endl ; else cout << 0 << endl ; } return 0 ; }
TAB1 let a be a string ; TAB1 let b and t be long long and equal 0 ; TAB1 input value a ; TAB1 let b equal any equal signs in string a ; TAB1 if t equals b ; TAB1 increment b by 2 ; TAB1 let b equal a . size ( ) - b + 1 ; ; TAB1 for long long i = 0 to t exclusive ; TAB2 if a [ i ] = = ' | ' , increment c ; TAB1 if c + 1 equals b - 1 ; TAB2 print | ; TAB2 for long long i = 0 to a . size ( ) - 1 exclusive , print a [ i ] ; TAB2 endline ; TAB1 else if c equals b ; TAB2 print a and endline ; TAB1 else if c equals b + 2 ; TAB2 let z be a long long that equals any + signs in string a ; TAB2 if z is larger than 1 ; TAB3 for long long i = 1 to a , size , print a [ i ] ; TAB3 print | and endline ; TAB2 if last statement was false ; TAB3 for long long i = 0 to a . size ( ) ; TAB4 if i equals z + 1 , continue ; TAB4 print a [ i ] ; TAB3 print | and endline ; TAB1 else statement ; TAB2 print impossible and endline ;	int main ( ) { string a ; long long b , t , c = 0 ; getline ( cin , a ) ; b = a . find ( ' = ' ) ; t = b ; b += 2 ; b = a . size ( ) - b + 1 ; for ( long long i = 0 ; i < t ; ++ i ) { if ( a [ i ] == ' | ' ) { c ++ ; } } if ( c + 1 == b - 1 ) { cout << ' | ' ; for ( long long i = 0 ; i < a . size ( ) - 1 ; ++ i ) { cout << a [ i ] ; } cout << endl ; } else if ( c == b ) { cout << a << endl ; } else if ( c == b + 2 ) { long long z = a . find ( ' + ' ) ; if ( z > 1 ) { for ( long long i = 1 ; i < a . size ( ) ; i ++ ) { cout << a [ i ] ; } cout << ' | ' << endl ; } else { for ( long long i = 0 ; i < a . size ( ) ; i ++ ) { if ( i == z + 1 ) { continue ; } cout << a [ i ] ; } cout << ' | ' << endl ; } } else { cout << " Impossible " << endl ; } return 0 ; }
TAB1 declare long longs N , M , K , L and res ; TAB1 read N , M , K and L ; TAB1 if K + L is greater than N ; TAB2 set the value of res to - 1 ; TAB1 else ; TAB2 if ( K + L ) % M is not zero ; TAB3 change the value of res to ( K + L ) / M + 1 ; TAB2 else ; TAB3 set the value of res to ( K + L ) / M ; TAB2 if res * M is greater than N , assign the new value = - 1 to res ; TAB1 print res ;	int main ( ) { long long N , M , K , L , res ; cin >> N >> M >> K >> L ; if ( K + L > N ) res = - 1 ; else { if ( ( K + L ) % M ) res = ( K + L ) / M + 1 ; else res = ( K + L ) / M ; if ( res * M > N ) res = - 1 ; } cout << res << endl ; return 0 ; }
TAB0 declare constant integer MAX = 1e7 ; TAB0 declare long long arrays a size MAX , sushu size MAX , huiwen size MAX ; TAB0 declare init with no arguments , returning void ; TAB1 let a [ 1 ] be 1 ; TAB1 let a [ 0 ] be 1 ; TAB1 for i = 2 to 10000 inclusive ; TAB2 if not a [ i ] ; TAB3 for j = i to i * j is less than MAX , incrementing j , let a [ i * j ] be 1 ; TAB0 declare panduan with long long x as argument , returning integer ; TAB1 declare long long w = x ; TAB1 declare long long y = 0 ; TAB1 while w is not 0 ; TAB2 let y be y * 10 + w % 10 ; TAB2 let w be w / 10 ; TAB1 if y is x ; TAB2 return 1 from function ; TAB1 else ; TAB1 run init ; TAB1 for i = 1 to MAX exclusive ; TAB2 if a [ i ] is true ; TAB3 let sushu [ i ] be sushu [ i - 1 ] ; TAB2 else ; TAB3 let sushu [ i ] be sushu [ i - 1 ] + 1 ; TAB2 if result of run panduan ( i ) is true ; TAB3 let huiwen [ i ] be huiwen [ i - 1 ] + 1 ; TAB2 else ; TAB3 let huiwen [ i ] be huiwen [ i - 1 ] ; TAB1 declare long longs p , q ; TAB1 read p and q ; TAB1 for i = MAX - 1 to 0 inclusive , decrementing i ; TAB2 if sushu [ i ] * q is less than or equal to huiwen [ i ] * p ; TAB3 if i is 0 ; TAB4 print " Palindromic tree is better than splay tree " and newline ; TAB3 else ; TAB4 print i and newline ;	const int MAX = 1e7 ; long long a [ MAX ] , sushu [ MAX ] , huiwen [ MAX ] ; void init ( ) { a [ 1 ] = 1 ; a [ 0 ] = 1 ; for ( int i = 2 ; i <= 10000 ; i ++ ) { if ( ! a [ i ] ) { for ( int j = i ; i * j < MAX ; j ++ ) { a [ i * j ] = 1 ; } } } } int panduan ( long long x ) { long long w = x ; long long y = 0 ; while ( w != 0 ) { y = y * 10 + w % 10 ; w /= 10 ; } if ( y == x ) return 1 ; else return 0 ; } int main ( ) { init ( ) ; for ( int i = 1 ; i < MAX ; i ++ ) { if ( a [ i ] ) sushu [ i ] = sushu [ i - 1 ] ; else sushu [ i ] = sushu [ i - 1 ] + 1 ; if ( panduan ( i ) ) huiwen [ i ] = huiwen [ i - 1 ] + 1 ; else huiwen [ i ] = huiwen [ i - 1 ] ; } long long p , q ; cin >> p >> q ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { if ( sushu [ i ] * q <= huiwen [ i ] * p ) { if ( i == 0 ) cout << " Palindromic tree is better than splay tree " << endl ; else cout << i << endl ; return 0 ; } } return 0 ; }
TAB1 make character array s1 and s2 , both of size 10 ; TAB1 make integers a and b ; TAB1 read s1 and s2 ; TAB1 if s1 [ 0 ] is equal to ' m ' , set a to 1 ; TAB1 if s1 [ 0 ] is equal to ' t ' and s1 [ 1 ] is equal to ' u ' , set a to 2 ; TAB1 if s1 [ 0 ] is equal to ' w ' , set a to 3 ; TAB1 if s1 [ 0 ] is equal to ' t ' AND s1 [ 1 ] is equal to ' h ' , assign 4 to a ; TAB1 if s1 [ 0 ] is equal to ' f ' , assign 5 to a ; TAB1 if s1 [ 0 ] is equal to ' s ' and s1 [ 1 ] is equal to ' a ' , set a to 6 ; TAB1 if s1 [ 0 ] is equal to ' s ' and s1 [ 1 ] is equal to ' u ' , set a to 7 ; TAB1 if s1 [ 0 ] is equal to ' m ' , assign 1 to b ; TAB1 if s2 [ 0 ] is equal to ' t ' and s2 [ 1 ] is equal to ' u ' , set b to 2 ; TAB1 if s2 [ 0 ] is equal to ' w ' , assign 3 to b ; TAB1 if s2 [ 0 ] is equal to ' t ' and s2 [ 1 ] is equal to ' h ' , set b to 4 ; TAB1 if s2 [ 0 ] is equal to ' f ' , set b to 5 ; TAB1 if s2 [ 0 ] is equal to ' s ' and s2 [ 1 ] is equal to ' a ' , set b to 6 ; TAB1 if s2 [ 0 ] is equal to ' s ' and s2 [ 1 ] is equal to ' u ' , set b to 7 ; TAB1 if a greater than b , increase b by 7 ; TAB1 make integer flag = 0 ; TAB1 if ( b - a ) is equal to 2 OR ( b - a ) is equal to 3 OR a is equal to b , set flag to 1 ; TAB1 if flag is equal to 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { char s1 [ 10 ] , s2 [ 10 ] ; int a , b ; cin >> s1 >> s2 ; if ( s1 [ 0 ] == ' m ' ) a = 1 ; if ( s1 [ 0 ] == ' t ' && s1 [ 1 ] == ' u ' ) a = 2 ; if ( s1 [ 0 ] == ' w ' ) a = 3 ; if ( s1 [ 0 ] == ' t ' && s1 [ 1 ] == ' h ' ) a = 4 ; if ( s1 [ 0 ] == ' f ' ) a = 5 ; if ( s1 [ 0 ] == ' s ' && s1 [ 1 ] == ' a ' ) a = 6 ; if ( s1 [ 0 ] == ' s ' && s1 [ 1 ] == ' u ' ) a = 7 ; if ( s2 [ 0 ] == ' m ' ) b = 1 ; if ( s2 [ 0 ] == ' t ' && s2 [ 1 ] == ' u ' ) b = 2 ; if ( s2 [ 0 ] == ' w ' ) b = 3 ; if ( s2 [ 0 ] == ' t ' && s2 [ 1 ] == ' h ' ) b = 4 ; if ( s2 [ 0 ] == ' f ' ) b = 5 ; if ( s2 [ 0 ] == ' s ' && s2 [ 1 ] == ' a ' ) b = 6 ; if ( s2 [ 0 ] == ' s ' && s2 [ 1 ] == ' u ' ) b = 7 ; if ( a > b ) b += 7 ; int flag = 0 ; if ( ( b - a ) == 2 || ( b - a ) == 3 || ( a == b ) ) flag = 1 ; if ( flag == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB0 create integers temp , blyat and integer arrays arr , change , cyka with size 6969 each ; TAB1 create integer c ; TAB1 read c ; TAB1 for integer a = 0 to c - 1 with increment a ; TAB2 read blyat ; TAB2 set change [ a ] to blyat ; TAB2 set arr [ a ] to blyat ; TAB1 for integer a = 0 to c - 1 with increment a ; TAB2 set temp to 1 ; TAB2 for integer x = 0 to c - 1 with increment x ; TAB3 if change [ a ] less than arr [ x ] then increment temp ; TAB3 set cyka [ a ] to temp ; TAB1 for integer a = 0 to c - 1 with increment a ; TAB2 if a is equal to c - 1 then ; TAB3 print cyka [ a ] and a new line ; TAB2 else do the following ; TAB3 print cyka [ a ] and " . " ;	int arr [ 6969 ] , change [ 6969 ] , temp , cyka [ 6969 ] , blyat ; int main ( ) { int c ; cin >> c ; for ( int a = 0 ; a < c ; a ++ ) { cin >> blyat ; change [ a ] = blyat ; arr [ a ] = blyat ; } for ( int a = 0 ; a < c ; a ++ ) { temp = 1 ; for ( int x = 0 ; x < c ; x ++ ) { if ( change [ a ] < arr [ x ] ) temp ++ ; cyka [ a ] = temp ; } } for ( int a = 0 ; a < c ; a ++ ) { if ( a == c - 1 ) cout << cyka [ a ] << " \n " ; else cout << cyka [ a ] << "   " ; } }
TAB1 let n be an integer ; TAB1 let a be an integer array of size 107 ; TAB1 let t be an integer that equals 0 ; TAB1 read n ; TAB1 for int i = 1 to n + 1 , read a [ i ] ; TAB1 if n equals 1 ; TAB2 print 0 and endline ; TAB1 if last statement was false ; TAB2 for int i = 1 to n + 1 ; TAB3 for int j = 1 to n + 1 ; TAB4 if absolute value of ( a [ j ] - a [ i ] ) equals absolute value of ( j - i ) AND abs ( i - j ) is greater than equal to t ; TAB5 ( a [ i ] equals 1 OR a [ j ] equals 1 ) OR ( a [ i ] equals 1000 OR a [ j ] equals 1000 ) ; TAB6 let t equal the absolute value of ( i - j ) + 1 ; TAB5 if last statement was false ; TAB6 let t equal the absolute value of i - j ; TAB2 if t - 1 is greater or equal to 1 ; TAB3 print t - 1 and endline ; TAB2 if last statement was false ; TAB3 print 0 and endline ;	int main ( ) { int n ; int a [ 107 ] ; int t = 0 ; cin >> n ; for ( int i = 1 ; i < n + 1 ; i ++ ) { cin >> a [ i ] ; } if ( n == 1 ) { cout << 0 << endl ; } else { for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { if ( abs ( a [ j ] - a [ i ] ) == abs ( j - i ) && abs ( i - j ) >= t ) { if ( ( a [ i ] == 1 || a [ j ] == 1 ) || ( a [ i ] == 1000 || a [ j ] == 1000 ) ) { t = abs ( i - j ) + 1 ; } else { t = abs ( i - j ) ; } } } } if ( t - 1 >= 1 ) { cout << t - 1 << endl ; } else cout << 0 << endl ; } return 0 ; }
TAB0 create set of ints amulets ; TAB0 create set of ints taken ; TAB1 create int N ; TAB1 read N ; TAB1 for i = 0 to N exclusive ; TAB2 if i is greater than 0 ; TAB3 create string starstar ; TAB3 read starstar ; TAB2 create int A , B ; TAB2 read A and B ; TAB2 create int num = A * 100 + B mod 10 * 10 + B / 10 ; TAB2 if not taken . count ( num ) ; TAB3 insert num into amulets ; TAB3 for j = 0 to 4 exclusive ; TAB4 insert num into taken ; TAB4 set num to ( num / 1000 ) + ( num * 10 mod 10000 ) ; TAB1 print amulets size ;	set < int > amulets ; set < int > taken ; int main ( ) { int N ; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 ) { string starstar ; cin >> starstar ; } int A , B ; cin >> A >> B ; int num = A * 100 + B % 10 * 10 + B / 10 ; if ( ! taken . count ( num ) ) { amulets . insert ( num ) ; for ( int j = 0 ; j < 4 ; j ++ ) { taken . insert ( num ) ; num = ( num / 1000 ) + ( num * 10 % 10000 ) ; } } } cout << amulets . size ( ) << endl ; return 0 ; }
TAB0 n = int ; TAB0 s = two dimensional char array of sizes 150 and 150 ; TAB0 r , c = int array of size 150 each ; TAB1 loop while reading n ; TAB2 set all values of r to 0 ; TAB2 set all values of c to 0 ; TAB2 for i = 1 to n inclusive read s [ i ] + 1 ; TAB2 x , y = int ; TAB2 set x and y to 0 each ; TAB2 flag = bool with flag = false ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to n inclusive ; TAB4 if s [ i ] [ j ] equals ' E ' ; TAB5 increment r [ i ] ; TAB5 increment c [ j ] ; TAB5 if r [ i ] equals n then set x to 1 ; TAB5 if c [ j ] equals n then set y to 1 ; TAB5 if both x and y are not 0 ; TAB6 print " - 1 " ; TAB6 set flag to true ; TAB2 if x is not 0 ; TAB3 for j = 1 to n inclusive ; TAB4 for i = 1 to n inclusive ; TAB5 if s [ i ] [ j ] equals ' . ' ; TAB6 print i and j ; TAB6 break the inner loop ; TAB2 else ; TAB3 for i = 1 to n inclusive ; TAB4 for j = 1 to n inclusive ; TAB5 if s [ i ] [ j ] equals ' . ' ; TAB6 print i and j ; TAB6 break the inner loop ;	int n ; char s [ 150 ] [ 150 ] ; int r [ 150 ] , c [ 150 ] ; int main ( ) { while ( cin >> n ) { memset ( r , 0 , sizeof ( r ) ) ; memset ( c , 0 , sizeof ( c ) ) ; for ( int i = 1 ; i <= n ; i ++ ) cin >> s [ i ] + 1 ; int x , y ; x = y = 0 ; bool flag = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( s [ i ] [ j ] == ' E ' ) { r [ i ] ++ ; c [ j ] ++ ; if ( r [ i ] == n ) x = 1 ; if ( c [ j ] == n ) y = 1 ; if ( x && y ) { cout << " -1 " << endl ; flag = true ; return 0 ; } } } } if ( x ) { for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i ] [ j ] == ' . ' ) { cout << i << "   " << j << endl ; break ; } } } } else { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( s [ i ] [ j ] == ' . ' ) { cout << i << "   " << j << endl ; break ; } } } } } return 0 ; }
TAB1 let s a string ; TAB1 read s ; TAB1 let a , b , and c ints with value 0 ; TAB1 for i from 0 to size of s exclusive ; TAB2 if s [ i ] is a , increment a ; TAB2 if s [ i ] is b , increment b ; TAB2 if s [ i ] is c , increment c ; TAB1 let t a string , with t = s ; TAB1 sort t ; TAB1 if t not equal to s or a is 0 or b is 0 ; TAB2 puts NO ; TAB1 otherwise ; TAB2 if a equals c or b equals c ; TAB3 puts YES ; TAB2 otherwise ; TAB3 puts NO ;	int main ( ) { string s ; cin >> s ; int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) a ++ ; if ( s [ i ] == ' b ' ) b ++ ; if ( s [ i ] == ' c ' ) c ++ ; } string t = s ; sort ( t . begin ( ) , t . end ( ) ) ; if ( t != s || a == 0 || b == 0 ) puts ( " NO " ) ; else { if ( a == c || b == c ) puts ( " YES " ) ; else puts ( " NO " ) ; } return 0 ; }
TAB0 declare long long integer array a size 100050 with a = { 0 } ; TAB1 declare integers p = 0 , res = 0 , ui = 0 ; TAB1 declare integer T ; TAB1 read T ; TAB1 while decrement T , read a [ increment p ] ; TAB1 sort from a to a + p ; TAB1 for i = 0 to p - 1 inclusive ; TAB2 while ui is less than p and a [ ui ] is less than or equal to a [ i ] , increment ui ; TAB2 if ui is less than p , increment res , increment ui ; TAB1 print res and newline ;	long long int a [ 100050 ] = { 0 } ; int main ( ) { int p = 0 , res = 0 , ui = 0 ; int T ; cin >> T ; while ( T -- ) cin >> a [ p ++ ] ; sort ( a , a + p ) ; for ( int i = 0 ; i <= p - 1 ; i ++ ) { while ( ui < p && a [ ui ] <= a [ i ] ) ui ++ ; if ( ui < p ) res ++ , ui ++ ; } cout << res << endl ; return 0 ; }
TAB0 declare constant integer MAXN = 100 ; TAB0 declare string array s size MAXN + 2 ; TAB0 declare boolean array contenido size MAXN + 2 ; TAB0 declare checa with string address w , integer T , string address s , integer N as arguments , returning void ; TAB1 declare integer lim = T - N + 1 ; TAB1 declare boolean pasa ; TAB1 declare characters c1 , c2 ; TAB1 for i = 0 to lim exclusive ; TAB2 let pasa be true ; TAB2 for j = 0 to N exclusive ; TAB3 let c1 be w [ i + j ] ; TAB3 let c1 be lower case c1 ; TAB3 let c2 be s [ j ] ; TAB3 let c2 be lower case c2 ; TAB3 if c1 is not c2 ; TAB4 let pasa be false ; TAB4 end loop ; TAB2 if pasa is true ; TAB3 for j = 0 to N exclusive , let contenido [ i + j ] be true ; TAB0 declare marca_cambiables with string address w , integer N as arguments , returning void ; TAB1 declare integers T = size of w , M ; TAB1 for i = 1 to N inclusive ; TAB2 let M be size of s [ i ] ; TAB2 if M is less than or equal to T , run checa ( w , T , s [ i ] , M ) ; TAB0 declare convierte with string address w , character letra as arguments , returning string ; TAB1 declare string ret = " " ; TAB1 declare integer N = size of w ; TAB1 declare characters cambio = ' a ' , nuevo ; TAB1 if letra is ' a ' , let cambio be ' b ' ; TAB1 declare boolean mayuscula ; TAB1 for i = 0 to N exclusive ; TAB2 let mayuscula be ( upper case ( w [ i ] ) is w [ i ] ) ; TAB2 if contenido [ i ] is true ; TAB3 if lower case w [ i ] is lower case letra ; TAB4 let nuevo be cambio ; TAB3 else ; TAB4 let nuevo be letra ; TAB2 else ; TAB3 let nuevo be w [ i ] ; TAB2 if mayuscula is true ; TAB3 let nuevo be upper case nuevo ; TAB2 else ; TAB3 let nuevo be lower case nuevo ; TAB2 increment ret by nuevo ; TAB1 return ret from function ; TAB1 declare integer N ; TAB1 read N ; TAB1 for i = 1 to N inclusive , read s [ i ] ; TAB1 declare string w ; TAB1 read w ; TAB1 run marca_cambiables ( w , N ) ; TAB1 declare character letter ; TAB1 read letter ; TAB1 print result of run convierte ( w , letter ) , " \ n " ;	const int MAXN = 100 ; string s [ MAXN + 2 ] ; bool contenido [ MAXN + 2 ] ; void checa ( string & w , int T , string & s , int N ) { int lim = T - N + 1 ; bool pasa ; char c1 , c2 ; for ( int i = 0 ; i < lim ; i ++ ) { pasa = true ; for ( int j = 0 ; j < N ; j ++ ) { c1 = w [ i + j ] ; c1 = tolower ( c1 ) ; c2 = s [ j ] ; c2 = tolower ( c2 ) ; if ( c1 != c2 ) { pasa = false ; break ; } } if ( pasa ) { for ( int j = 0 ; j < N ; j ++ ) { contenido [ i + j ] = true ; } } } } void marca_cambiables ( string & w , int N ) { int T = w . size ( ) , M ; for ( int i = 1 ; i <= N ; i ++ ) { M = s [ i ] . size ( ) ; if ( M <= T ) { checa ( w , T , s [ i ] , M ) ; } } } string convierte ( string & w , char letra ) { string ret = "  " ; int N = w . size ( ) ; char cambio = ' a ' , nuevo ; if ( letra == ' a ' ) cambio = ' b ' ; bool mayuscula ; for ( int i = 0 ; i < N ; i ++ ) { mayuscula = ( toupper ( w [ i ] ) == w [ i ] ) ; if ( contenido [ i ] ) { if ( tolower ( w [ i ] ) == tolower ( letra ) ) { nuevo = cambio ; } else { nuevo = letra ; } } else { nuevo = w [ i ] ; } if ( mayuscula ) nuevo = toupper ( nuevo ) ; else nuevo = tolower ( nuevo ) ; ret += nuevo ; } return ret ; } int main ( ) { int N ; cin >> N ; for ( int i = 1 ; i <= N ; i ++ ) { cin >> s [ i ] ; } string w ; cin >> w ; marca_cambiables ( w , N ) ; char letter ; cin >> letter ; cout << convierte ( w , letter ) << " \n " ; return 0 ; }
TAB0 long long int function ceil with long long int arguments n and m ; TAB1 return n / m + 1 if n modulo m is not 0 , or n / m otherwise ; TAB1 declare long long int variables n , m , k and l ; TAB1 read variables n , m , k and l from the input ; TAB1 if m > n or n - k < l , return cout < < - 1 < < endl , 0 ; TAB1 create new long long integer called sum = ( ceil of ( l + k ) and m ) * m ; TAB1 if sum is greater than n , return cout < < " - 1 " < < endl , 0 ; TAB1 print sum / m ;	long long int ceil ( long long int n , long long int m ) { return n % m ? n / m + 1 : n / m ; } int main ( ) { long long int n , m , k , l ; cin >> n >> m >> k >> l ; if ( m > n || n - k < l ) return cout << - 1 << endl , 0 ; long long int sum = ceil ( ( l + k ) , m ) * m ; if ( sum > n ) return cout << " -1 " << endl , 0 ; cout << sum / m << endl ; }
TAB1 n , s , a , b , c , d = int , pos = 1 ; TAB1 read n , a , b , c , d ; TAB1 s = a + b + c + d ; TAB1 decrement n ; TAB1 while decremented value of n is not zero ; TAB2 read a , b , c , d ; TAB2 if a + b + c + d > s increment pos ; TAB1 print pos ;	int main ( ) { int n , s , a , b , c , d , pos = 1 ; cin >> n >> a >> b >> c >> d ; s = a + b + c + d ; n -- ; while ( n -- ) { cin >> a >> b >> c >> d ; if ( a + b + c + d > s ) { pos ++ ; } } cout << pos << ' \n ' ; return 0 ; }
TAB1 x = 2D array in strings with 5 rows and 5 columns ; TAB1 f = boolean with false ; TAB1 for i = 1 to 4 exclusive ; TAB2 Read 4 values into array x ; TAB1 for i = 0 to 4 exclusive ; TAB2 if x [ i ] [ 4 ] is not equal to 0 ; TAB3 for j = 1 to 3 exclusive ; TAB4 if x [ i ] [ j ] is not equal 0 , then set f to true ; TAB3 for j = 1 to 3 exclusive ; TAB4 p = integer , set to i + j ; TAB4 if p is greater than 4 , then set p to p - 4 ; TAB4 if x [ p ] [ j ] is not equal 0 , then set f to true ; TAB1 if f is true ; TAB2 print YES new line ; TAB1 else do the following ; TAB2 print NO new line ;	int main ( ) { int x [ 5 ] [ 5 ] ; bool f = false ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { cin >> x [ i ] [ j ] ; } } for ( int i = 1 ; i <= 4 ; i ++ ) { if ( x [ i ] [ 4 ] ) { for ( int j = 1 ; j <= 3 ; j ++ ) { if ( x [ i ] [ j ] ) f = true ; } for ( int j = 1 ; j <= 3 ; j ++ ) { int p = i + j ; if ( p > 4 ) p -= 4 ; if ( x [ p ] [ j ] ) f = true ; } } } if ( f ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 a , b , c , d = int ; TAB1 read a , b , c , d ; TAB1 for t = 0 to 20000 exclusive ; TAB2 if t > = b and t > = d and ( t - b ) modulo a is 0 and ( t - d ) modulo c is 0 ; TAB3 print t ; TAB1 print - 1 ;	int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; for ( int t = 0 ; t < 20000 ; t ++ ) { if ( t >= b && t >= d && ( t - b ) % a == 0 && ( t - d ) % c == 0 ) { cout << t << endl ; return 0 ; } } cout << - 1 << endl ; }
TAB1 create integer n , i , temp , cnt , res with cnt = - 1 and res = 0 ; TAB1 a = int vector ; TAB1 read n ; TAB1 add 0 to the end of a ; TAB1 add 0 to the end of a ; TAB1 for i = 0 to n exclusive ; TAB2 read temp ; TAB2 add temp to the end of a ; TAB1 add 1001 to end of a ; TAB1 for i = 2 to n + 2 inclusive ; TAB2 if a [ i ] is equal to a [ i - 1 ] + 1 ; TAB3 add 1 to cnt ; TAB2 else do the following ; TAB3 if cnt > res then set res = cnt ; TAB3 set cnt = - 1 ; TAB1 if cnt > res then set res = cnt ; TAB1 print res and new line ;	int main ( ) { int n , i , temp , cnt = - 1 , res = 0 ; vector < int > a ; cin >> n ; a . push_back ( 0 ) ; a . push_back ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cin >> temp ; a . push_back ( temp ) ; } a . push_back ( 1001 ) ; for ( i = 2 ; i <= n + 2 ; i ++ ) { if ( a [ i ] == a [ i - 1 ] + 1 ) { cnt ++ ; } else { if ( cnt > res ) { res = cnt ; } cnt = - 1 ; } } if ( cnt > res ) { res = cnt ; } cout << res << endl ; return 0 ; }
TAB1 declare map from string to integer mp ; TAB1 declare string array x size 3 ; TAB1 read x [ 0 ] , x [ 1 ] , x [ 2 ] ; TAB1 let mp [ " C " ] be 0 ; TAB1 let mp [ " C # " ] be 1 ; TAB1 let mp [ " D " ] be 2 ; TAB1 let mp [ " D # " ] be 3 ; TAB1 let mp [ " E " ] be 4 ; TAB1 let mp [ " F " ] be 5 ; TAB1 let mp [ " F # " ] be 6 ; TAB1 let mp [ " G " ] be 7 ; TAB1 let mp [ " G # " ] be 8 ; TAB1 let mp [ " A " ] be 9 ; TAB1 let mp [ " B " ] be 10 ; TAB1 let mp [ " H " ] be 11 ; TAB1 declare integers a , b ; TAB1 for i = 0 to 3 exclusive ; TAB2 for j = 0 to 3 exclusive ; TAB3 for k = 0 to 3 exclusive ; TAB4 if i is not j and j is not k and i is not k ; TAB5 if mp [ x [ j ] ] is greater than or equal to mp [ x [ i ] ] ; TAB6 let a be mp [ x [ j ] ] - mp [ x [ i ] ] ; TAB5 else if mp [ x [ j ] ] is less than mp [ x [ i ] ] ; TAB6 let a be ( 12 - mp [ x [ i ] ] ) + ( mp [ x [ j ] ] - 0 ) ; TAB5 if mp [ x [ k ] ] is greater than or equal to mp [ x [ j ] ] ; TAB6 let b be mp [ x [ k ] ] - mp [ x [ j ] ] ; TAB5 else if mp [ x [ k ] ] is less than mp [ x [ j ] ] ; TAB6 let b be ( 12 - mp [ x [ j ] ] ) + ( mp [ x [ k ] ] - 0 ) ; TAB5 if a is 3 and b is 4 ; TAB6 print " minor " and newline ; TAB5 else if a is 4 and b is 3 ; TAB6 print " major " , newline ; TAB1 print " strange " , newline ;	int main ( ) { map < string , int > mp ; string x [ 3 ] ; cin >> x [ 0 ] >> x [ 1 ] >> x [ 2 ] ; mp [ " C " ] = 0 ; mp [ " C# " ] = 1 ; mp [ " D " ] = 2 ; mp [ " D# " ] = 3 ; mp [ " E " ] = 4 ; mp [ " F " ] = 5 ; mp [ " F# " ] = 6 ; mp [ " G " ] = 7 ; mp [ " G# " ] = 8 ; mp [ " A " ] = 9 ; mp [ " B " ] = 10 ; mp [ " H " ] = 11 ; int a , b ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { if ( i != j && j != k && i != k ) { if ( mp [ x [ j ] ] >= mp [ x [ i ] ] ) a = mp [ x [ j ] ] - mp [ x [ i ] ] ; else if ( mp [ x [ j ] ] < mp [ x [ i ] ] ) a = ( 12 - mp [ x [ i ] ] ) + ( mp [ x [ j ] ] - 0 ) ; if ( mp [ x [ k ] ] >= mp [ x [ j ] ] ) b = mp [ x [ k ] ] - mp [ x [ j ] ] ; else if ( mp [ x [ k ] ] < mp [ x [ j ] ] ) b = ( 12 - mp [ x [ j ] ] ) + ( mp [ x [ k ] ] - 0 ) ; if ( a == 3 && b == 4 ) { cout << " minor " << endl ; return 0 ; } else if ( a == 4 && b == 3 ) { cout << " major " << endl ; return 0 ; } } } } } cout << " strange " << endl ; return 0 ; }
TAB1 create integers a , b , c , i , j , k , n , p , q , x , y , sum , ct , ct1 , m , mid , l , r , len and ans ; TAB1 declare char variable ch ; TAB1 declare double d ; TAB1 create strings str1 , str2 and str ; TAB1 declare bools bl and bl1 ; TAB1 loop , reading n and k from the input ; TAB2 read input to str ; TAB2 change len to 0 ; TAB2 for c from 1 to n exclusive ; TAB3 set i to 0 and set j to n - c ; TAB3 while j < n and str [ i ] = str [ j ] , increment i and j ; TAB3 if j = n , set len to c ; TAB2 let tt and tl be strings where tl = " " ; TAB2 set tt to substring of str from 0 with length len ; TAB2 while k ! = 0 , decrement it and continue the loop ; TAB2 print tt and tl ;	int main ( ) { int a , b , c , i , j , k , n , p , q , x , y , sum , ct , ct1 , m , mid , l , r , len , ans ; char ch ; double d ; string str1 , str2 , str ; bool bl , bl1 ; while ( cin >> n >> k ) { cin >> str ; len = 0 ; for ( c = 1 ; c < n ; c ++ ) { i = 0 , j = n - c ; while ( j < n && str [ i ] == str [ j ] ) ++ i , ++ j ; if ( j == n ) len = c ; } string tt , tl = "  " ; tt = str . substr ( 0 , len ) ; while ( k -- ) tl += str . substr ( len ) ; cout << tt << tl << endl ; } }
TAB1 3rd element of integer array cnt is equal to 0 ; TAB1 let n be a integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 let x be a integer ; TAB2 read x ; TAB2 if x is equal to 25 , increment cnt [ 0 ] by 1 ; TAB2 if x is equal to 50 ; TAB3 if cnt [ 0 ] > = 1 ; TAB4 decrement cnt [ 0 ] by 1 ; TAB4 increment cnt [ 1 ] by 1 ; TAB3 else do the following ; TAB4 print NO and newline ; TAB2 if x is equal to 100 ; TAB3 if cnt [ 1 ] > = 1 and cnt [ 0 ] > = 1 ; TAB4 decrement cnt [ 0 ] by 1 ; TAB4 decrement cnt [ 1 ] by 1 ; TAB4 increment cnt [ 2 ] by 1 ; TAB3 else if cnt [ 0 ] > = 3 ; TAB4 decrement cnt [ 0 ] by 3 ; TAB4 increment cnt [ 2 ] by 1 ; TAB3 else do the following ; TAB4 print NO and newline ; TAB1 print YES and newline ;	int main ( ) { int cnt [ 3 ] = { 0 } ; int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; if ( x == 25 ) cnt [ 0 ] ++ ; if ( x == 50 ) { if ( cnt [ 0 ] >= 1 ) { cnt [ 0 ] -- ; cnt [ 1 ] ++ ; } else { cout << " NO\n " ; return 0 ; } } if ( x == 100 ) { if ( cnt [ 1 ] >= 1 && cnt [ 0 ] >= 1 ) { cnt [ 0 ] -- ; cnt [ 1 ] -- ; cnt [ 2 ] ++ ; } else if ( cnt [ 0 ] >= 3 ) { cnt [ 0 ] -= 3 ; cnt [ 2 ] ++ ; } else { cout << " NO\n " ; return 0 ; } } } cout << " YES\n " ; return 0 ; }
TAB0 N = const int with N = 1e5 + 10 ; TAB0 n , a , m , d = long long ; TAB0 da = long long and t = long long array of size N ; TAB0 in function nextDiv taking long long bound , long long div and returning long long ; TAB1 return bound if bound is a multiple of div else return bound + div - bound mod div ; TAB0 in function nextDiv taking long long bound , long long num , long long div and returning long long ; TAB1 if bound is a multiple of div return bound + num * div ; TAB1 return nextDiv of bound , div + ( num - 1 ) * div ; TAB0 in function prevDiv taking long long bound , long long div and returning long long ; TAB1 return bound if bound is a multiple of div else return bound - bound mod div ; TAB0 in function numDiv taking long long L , long long R , long long div and returning long long ; TAB1 return prevDiv of ( R , div ) / div - prevDiv ( L - 1 , div ) / div ; TAB0 in function numOpen taking long long L , long long R and returning long long , long long pair ; TAB1 realR = long long with realR = min of R , n * a ; TAB1 xx = long long with xx = numDiv of L , realR , a ; TAB1 if xx < = da return { 1m nextDiv of ( L , a ) + d } ; TAB1 noob = long long with noob = xx - da if xx is a multiple of da else xx - xx mod da ; TAB1 nextt = long long with nextt = nextDiv of L , noob , a ; TAB1 if xx is a multiple of da return { xx / da , nextt + d } ; TAB1 return { 1 + xx / da , nextt + d } ; TAB0 in function solve ; TAB1 cur = long long with cur = min of a , t [ 1 ] ; TAB1 pt = long long with pt = 1 ; TAB1 ans = long long with ans = 0 ; TAB1 loop while pt < = m ; TAB2 if cur is not t [ pt ] ; TAB3 xop = long long , long long pair with xop = numOpen of cur , t [ pt ] - 1 ; TAB3 increment ans by xop . first ; TAB3 loop while pt < = m and t [ pt ] < = xop . second increment pt ; TAB3 if pt is m + 1 ; TAB4 set cur to nextDiv of xop . second + 1 , a ; TAB4 if n < numDiv of a , xop . second , a break ; TAB4 numLeft = long long with numLeft = n - numDiv of a , xop . second , a ; TAB4 if numLeft > 0 increment ans by numOpen of ( cur , nextDiv of cur , numLeft - 1 , a ) . first ; TAB4 break ; TAB3 set cur to t [ pt ] ; TAB3 if numDiv of a , xop . second , a < n set cur to min of t [ pt ] , nextDiv of xop . second + 1 , a ; TAB2 else ; TAB3 increment ans ; TAB3 neo = long long with neo = pt ; TAB3 loop while pt < m and t [ pt + 1 ] - t [ neo ] < = d increment pt ; TAB3 if pt is m ; TAB4 cur = long long with cur = nextDiv of t [ neo ] + d + 1 , a ; TAB4 if n < numDiv of a , t [ neo ] + d , a break ; TAB4 numLeft = long long with numLeft = n - numDiv of a , t [ neo ] + d , a ; TAB4 if numLeft > 0 increment ans by numOpen of ( cur , nextDiv of cur , numLeft - 1 , a ) . first ; TAB4 break ; TAB3 increment pt ; TAB3 set cur to t [ pt ] ; TAB3 if numDiv of a , t [ neo ] + d , a < n set cur to min of t [ pt ] , nextDiv of t [ neo ] + d + 1 , a ; TAB1 print ans ; TAB1 read n then m then a then d ; TAB1 for i = 1 to m inclusive read t [ i ] ; TAB1 set da to numDiv of a , a + d , a ; TAB1 call solve ;	const int N = 1e5 + 10 ; long long n , a , m , d ; long long t [ N ] , da ; long long nextDiv ( long long bound , long long div ) { return ( bound % div == 0 ? bound : bound + div - bound % div ) ; } long long nextDiv ( long long bound , long long num , long long div ) { if ( bound % div == 0 ) return bound + ( num ) * div ; return nextDiv ( bound , div ) + ( num - 1 ) * div ; } long long prevDiv ( long long bound , long long div ) { return ( bound % div == 0 ? bound : bound - bound % div ) ; } long long numDiv ( long long L , long long R , long long div ) { return prevDiv ( R , div ) / div - prevDiv ( L - 1 , div ) / div ; } pair < long long , long long > numOpen ( long long L , long long R ) { long long realR = min ( R , n * a ) ; long long xx = numDiv ( L , realR , a ) ; if ( xx <= da ) return { 1 , nextDiv ( L , a ) + d } ; long long noob = ( xx % da == 0 ? xx - da : xx - xx % da ) ; long long nextt = nextDiv ( L , noob , a ) ; if ( xx % da == 0 ) return { xx / da , nextt + d } ; return { 1 + xx / da , nextt + d } ; } void solve ( ) { long long cur = min ( a , t [ 1 ] ) ; long long pt = 1 ; long long ans = 0 ; while ( pt <= m ) { if ( cur != t [ pt ] ) { pair < long long , long long > xop = numOpen ( cur , t [ pt ] - 1 ) ; ans += xop . first ; while ( pt <= m && t [ pt ] <= xop . second ) pt ++ ; if ( pt == m + 1 ) { cur = nextDiv ( xop . second + 1 , a ) ; if ( n < numDiv ( a , xop . second , a ) ) break ; long long numLeft = n - numDiv ( a , xop . second , a ) ; if ( numLeft > 0 ) ans += numOpen ( cur , nextDiv ( cur , numLeft - 1 , a ) ) . first ; break ; } cur = t [ pt ] ; if ( numDiv ( a , xop . second , a ) < n ) cur = min ( t [ pt ] , nextDiv ( xop . second + 1 , a ) ) ; } else { ans ++ ; long long neo = pt ; while ( pt < m && t [ pt + 1 ] - t [ neo ] <= d ) pt ++ ; if ( pt == m ) { long long cur = nextDiv ( t [ neo ] + d + 1 , a ) ; if ( n < numDiv ( a , t [ neo ] + d , a ) ) break ; long long numLeft = n - numDiv ( a , t [ neo ] + d , a ) ; if ( numLeft > 0 ) ans += numOpen ( cur , nextDiv ( cur , numLeft - 1 , a ) ) . first ; break ; } pt ++ ; cur = t [ pt ] ; if ( numDiv ( a , t [ neo ] + d , a ) < n ) cur = min ( t [ pt ] , nextDiv ( t [ neo ] + d + 1 , a ) ) ; } } cout << ans << ' \n ' ; } int main ( ) { cin >> n >> m >> a >> d ; for ( int i = 1 ; i <= m ; i ++ ) cin >> t [ i ] ; da = numDiv ( a , a + d , a ) ; solve ( ) ; }
TAB1 a , b , c , d , e , f = int ; TAB1 read a then b then c then d then e then f ; TAB1 if d is 0 ; TAB2 print " Hermione " ; TAB1 else if c is 0 ; TAB2 print " Ron " ; TAB1 else if b is 0 ; TAB2 print " Hermione " ; TAB1 else if a is 0 ; TAB2 print " Ron " ; TAB1 else if f is 0 ; TAB2 print " Hermione " ; TAB1 else if e is 0 ; TAB2 print " Ron " ; TAB1 else ; TAB2 if b * d * f > a * c * e ; TAB3 print " Ron " ; TAB2 else ; TAB3 print " Hermione " ;	int main ( ) { int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( d == 0 ) { cout << " Hermione " << endl ; } else if ( c == 0 ) { cout << " Ron " << endl ; } else if ( b == 0 ) { cout << " Hermione " << endl ; } else if ( a == 0 ) { cout << " Ron " << endl ; } else if ( f == 0 ) { cout << " Hermione " << endl ; } else if ( e == 0 ) { cout << " Ron " << endl ; } else { if ( b * d * f > a * c * e ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; } }
TAB0 declare integer array b size 20 , integers ans , n ; TAB0 declare boolean array a size 10 by 10 ; TAB0 declare check with no arguments , returning boolean ; TAB1 declare integers i , j , r , l , tot ; TAB1 for i = 1 to 5 inclusive ; TAB2 let l be r be 0 ; TAB2 for j = 1 to 5 inclusive ; TAB3 if a [ i ] [ j ] ; TAB4 increment l ; TAB4 if b [ j ] , increment r ; TAB2 if l - 1 is greater than r , return false from function ; TAB1 for i = 1 to 5 inclusive ; TAB2 let l be r be 0 ; TAB2 for j = 1 to 5 inclusive ; TAB3 if a [ j ] [ i ] is true ; TAB4 increment l ; TAB4 if b [ 5 + j ] , increment r ; TAB2 if l - 1 is greater than r , return false from function ; TAB1 let tot be 0 ; TAB1 for i = 1 to 5 inclusive ; TAB2 for j = 1 to 5 inclusive ; TAB3 if a [ i ] [ j ] and not b [ i + 5 ] and not b [ j ] , increment tot ; TAB1 if tot is greater than 1 , return false ; TAB1 return true ; TAB0 declare dfs with integer x as argument , returning void ; TAB1 declare integers i , sum ; TAB1 if x is 11 ; TAB2 if result of run check is true ; TAB3 let sum be 0 ; TAB3 for i = 1 to 11 inclusive ; TAB4 if b [ i ] is 1 , increment sum ; TAB3 let ans be minimum of ( sum and ans ) ; TAB2 return from function ; TAB1 let b [ x ] be 1 ; TAB1 run dfs ( x + 1 ) ; TAB1 let b [ x ] be 0 ; TAB1 run dfs with x + 1 as argument ; TAB1 declare integers i , y ; TAB1 declare character ch ; TAB1 declare integer k ; TAB1 read n ; TAB1 set bytes form a to size of a to value of false ; TAB1 for i = 1 to n inclusive ; TAB2 read ch and k ; TAB2 if ch is ' R ' ; TAB3 let y be 1 ; TAB2 else if ch is ' G ' ; TAB3 let y be 2 ; TAB2 else if ch is ' B ' ; TAB3 let y be 3 ; TAB2 else if ch is ' Y ' ; TAB3 let y be 4 ; TAB2 else if ch is ' W ' ; TAB3 let y be 5 ; TAB2 let a [ y ] [ k ] be true ; TAB1 set bytes from b to size of b to value 0 ; TAB1 let ans be 9999999 ; TAB1 end statement ; TAB1 run dfs with 1 as argument ; TAB1 print ans and newline ;	int b [ 20 ] , ans , n ; bool a [ 10 ] [ 10 ] ; bool check ( ) { int i , j , r , l , tot ; for ( i = 1 ; i <= 5 ; i ++ ) { l = r = 0 ; for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ i ] [ j ] ) { l ++ ; if ( b [ j ] ) { r ++ ; } } } if ( l - 1 > r ) return false ; } for ( i = 1 ; i <= 5 ; i ++ ) { l = r = 0 ; for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ j ] [ i ] ) { l ++ ; if ( b [ 5 + j ] ) r ++ ; } } if ( l - 1 > r ) return false ; } tot = 0 ; for ( i = 1 ; i <= 5 ; i ++ ) { for ( j = 1 ; j <= 5 ; j ++ ) { if ( a [ i ] [ j ] && ! b [ i + 5 ] && ! b [ j ] ) tot ++ ; } } if ( tot > 1 ) return false ; return true ; } void dfs ( int x ) { int i , sum ; if ( x == 11 ) { if ( check ( ) ) { sum = 0 ; for ( i = 1 ; i <= 11 ; i ++ ) { if ( b [ i ] == 1 ) sum ++ ; } ans = min ( sum , ans ) ; } return ; } b [ x ] = 1 ; dfs ( x + 1 ) ; b [ x ] = 0 ; dfs ( x + 1 ) ; } int main ( ) { int i , y ; char ch ; int k ; cin >> n ; memset ( a , false , sizeof ( a ) ) ; for ( i = 1 ; i <= n ; i ++ ) { cin >> ch >> k ; if ( ch == ' R ' ) y = 1 ; else if ( ch == ' G ' ) y = 2 ; else if ( ch == ' B ' ) y = 3 ; else if ( ch == ' Y ' ) y = 4 ; else if ( ch == ' W ' ) y = 5 ; a [ y ] [ k ] = true ; } memset ( b , 0 , sizeof ( b ) ) ; ans = 9999999 ; ; dfs ( 1 ) ; cout << ans << endl ; }
TAB0 a , b = integer 2d array of [ 101 ] [ 101 ] ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 tmp = character ; TAB3 read tmp ; TAB3 if tmp is E , a [ i ] [ j ] = - 1 ; TAB1 flagh , flagl = integers with flagh [ 101 ] = { 0 } , flagl [ 101 ] = { 0 } ; TAB1 flaghs , flagls = integers with flaghs = 0 , flagls = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if a [ i ] [ j ] is 0 ; TAB4 flagh [ i ] = 1 ; TAB4 break loop ; TAB1 for i = 0 to n exclusive ; TAB2 if flagh [ i ] is 0 ; TAB3 flaghs = - 1 ; TAB3 break loop ; TAB1 if flaghs is 0 ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to n ; TAB4 if a [ i ] [ j ] is 0 ; TAB5 print i + 1 , " " , j + 1 ; TAB5 break loop ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if a [ j ] [ i ] is 0 ; TAB4 flagl [ i ] = 1 ; TAB4 break loop ; TAB1 for i = 0 to n ; TAB2 if flagl [ i ] is 0 ; TAB3 flagls = - 1 ; TAB3 break loop ; TAB1 if flagls is 0 ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to n exclusive ; TAB4 if a [ j ] [ i ] is 0 ; TAB5 print j + 1 , " " , i + 1 ; TAB5 break loop ; TAB1 print - 1 ;	int a [ 101 ] [ 101 ] , b [ 101 ] [ 101 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { char tmp ; cin >> tmp ; if ( tmp == ' E ' ) a [ i ] [ j ] = - 1 ; } } int flagh [ 101 ] = { 0 } , flagl [ 101 ] = { 0 } ; int flaghs = 0 , flagls = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 0 ) { flagh [ i ] = 1 ; break ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( flagh [ i ] == 0 ) { flaghs = - 1 ; break ; } } if ( flaghs == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 0 ) { cout << i + 1 << "   " << j + 1 << endl ; break ; } } } return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 0 ) { flagl [ i ] = 1 ; break ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( flagl [ i ] == 0 ) { flagls = - 1 ; break ; } } if ( flagls == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 0 ) { cout << j + 1 << "   " << i + 1 << endl ; break ; } } } return 0 ; } cout << - 1 << endl ; return 0 ; }
TAB1 create long longs x1 , y1 , x2 and y2 ; TAB1 read x1 , y1 , x2 and y2 and keep looping ; TAB2 create new long longs a , b and c ; TAB2 n and ans are integers with ans = 0 ; TAB2 read n ; TAB2 for i from 0 to n exclusive ; TAB3 read variables a , b and c from the input ; TAB3 increment ans if a * x1 + b * y1 + c < 0 and a * x2 + b * y2 + c > 0 ; TAB3 increment ans if a * x1 + b * y1 + c > 0 and a * x2 + b * y2 + c < 0 ; TAB2 print ans ;	int main ( ) { long long x1 , y1 , x2 , y2 ; while ( cin >> x1 >> y1 >> x2 >> y2 ) { long long a , b , c ; int n , ans = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b >> c ; if ( a * x1 + b * y1 + c < 0 && a * x2 + b * y2 + c > 0 ) ans ++ ; if ( a * x1 + b * y1 + c > 0 && a * x2 + b * y2 + c < 0 ) ans ++ ; } cout << ans << endl ; } return 0 ; }
TAB1 set flag = boolean ; TAB1 set n , i = integers ; TAB1 set str = string ; TAB1 set a = array of integers size 5 , b = array of integers size 100005 ; TAB1 set ans = integer ; TAB1 set sizeof ( a ) bytes starting at a to 0 ; TAB1 read str ; TAB1 n = length of str ; TAB1 set flag to false ; TAB1 for i = 0 to n exclusive , do the following ; TAB2 if str [ i ] is # do the following ; TAB3 increment a [ 1 ] ; TAB3 if a [ 3 ] + a [ 1 ] is greater than a [ 2 ] or i is 0 set flag = true ; TAB3 set and = a [ 2 ] - a [ 3 ] + 1 ; TAB2 else if str [ i ] is ( do the following ; TAB3 increment a [ 2 ] ; TAB3 if i is n - 1 or a [ 3 ] + a [ 1 ] is greater than a [ 2 ] , set flag = true ; TAB2 else do the following ; TAB3 increment a [ 3 ] ; TAB3 if a [ 3 ] + a [ 1 ] is greater than a [ 2 ] or i is 0 set flag = true ; TAB1 if ans is greater than a [ 2 ] - a [ 3 ] + 1 set flag = true ; TAB1 if flag is true ; TAB2 print - 1 ; TAB1 for i = 1 to a [ 1 ] exclusive print 1 ; TAB1 print a [ 2 ] - a [ 3 ] - a [ 1 ] + 1 ;	int main ( ) { bool flag ; int i , n ; string str ; int a [ 5 ] , b [ 100005 ] ; int ans = 0 ; memset ( a , 0 , sizeof ( a ) ) ; cin >> str ; n = str . length ( ) ; flag = false ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' # ' ) { a [ 1 ] ++ ; if ( a [ 3 ] + a [ 1 ] > a [ 2 ] || i == 0 ) flag = true ; ans = a [ 2 ] - a [ 3 ] + 1 ; } else if ( str [ i ] == ' ( ' ) { a [ 2 ] ++ ; if ( i == n - 1 || a [ 3 ] + a [ 1 ] > a [ 2 ] ) flag = true ; } else { a [ 3 ] ++ ; if ( a [ 3 ] + a [ 1 ] > a [ 2 ] || i == 0 ) flag = true ; } } if ( ans < a [ 2 ] - a [ 3 ] + 1 ) { flag = true ; } if ( flag ) { cout << - 1 << endl ; return 0 ; } for ( i = 1 ; i < a [ 1 ] ; i ++ ) { cout << 1 << endl ; } cout << a [ 2 ] - a [ 3 ] - a [ 1 ] + 1 << endl ; }
TAB1 let n , k be integers ; TAB1 read n , k ; TAB1 r = array of integers of length 2 * n + 1 ; TAB1 for i = 0 to 2 * n + 1 exclusive , read r [ i ] ; TAB1 for i = 0 to 2 * n + 1 exclusive ; TAB2 if ( i + 1 ) modulo 2 is equal to 0 and k is greater than 0 and r [ i ] - 1 is greater than r [ i + 1 ] and r [ i - 1 ] is less than r [ i ] - 1 ; TAB3 print r [ i ] - 1 ; TAB3 decrement k by 1 ; TAB2 else do the following ; TAB3 print r [ i ] ; TAB2 if i is equal to 2 * n ; TAB3 print newline ; TAB2 else do the following ; TAB3 print space ;	int main ( ) { int n , k ; cin >> n >> k ; int r [ 2 * n + 1 ] ; for ( int i = 0 ; i < 2 * n + 1 ; i ++ ) cin >> r [ i ] ; for ( int i = 0 ; i < 2 * n + 1 ; i ++ ) { if ( ( i + 1 ) % 2 == 0 && k > 0 && r [ i ] - 1 > r [ i + 1 ] && r [ i - 1 ] < r [ i ] - 1 ) { cout << r [ i ] - 1 ; -- k ; } else { cout << r [ i ] ; } if ( i == 2 * n ) cout << " \n " ; else cout << "   " ; } return 0 ; }
TAB0 declare constant long long N = 1e9 + 3 ; TAB0 declare constant long long MN = 1e9 + 7 ; TAB0 declare constant long long MX = - 1e9 - 7 ; TAB0 declare n , m , a , b , x , c1 , c2 , cnt as long longs ; TAB0 declare strings s , s1 ; TAB0 declare boolean bl = false ; TAB0 declare c as long long ; TAB0 declare pair of long long and long long pr ; TAB0 declare long long vector v ; TAB0 declare map from long long to long long mp ; TAB0 declare long long set st ; TAB0 declare long long set iterator it ; TAB0 declare propblem with long longs n , m as arguments , returning void ; TAB1 declare character c = ' a ' ; TAB1 declare long long cnt = 97 + m ; TAB1 while n is true ; TAB2 print c ; TAB2 increment c ; TAB2 if c is cnt , let c be ' a ' ; TAB2 decrement n ; TAB1 read n and m ; TAB1 run propblem with n , m as arguments ; TAB1 print " \ n " ;	const long long N = 1e9 + 3 ; const long long MN = 1e9 + 7 ; const long long MX = - 1e9 - 7 ; long long n , m , a , b , x , c1 , c2 , cnt ; string s , s1 ; bool bl = false ; long long c ; pair < long long , long long > pr ; vector < long long > v ; map < long long , long long > mp ; set < long long > st ; set < long long > :: iterator it ; void propblem ( long long n , long long m ) { char c = ' a ' ; long long cnt = 97 + m ; while ( n ) { cout << c ; c ++ ; if ( c == cnt ) { c = ' a ' ; } n -- ; } } int main ( ) { cin >> n >> m ; propblem ( n , m ) ; cout << " \n " ; return 0 ; }
TAB1 create string s , set vowels = aeuiyo , res = " " ; TAB1 read s ; TAB1 for i = 0 to size of s exclusive ; TAB2 if s [ i ] + 0 < 97 , set s [ i ] to s [ i ] + 32 ; TAB1 for i = 0 to size of s exclusive ; TAB2 for j = 0 to 6 exclusive ; TAB3 if s [ i ] = vowels [ j ] , break ; TAB3 if j = 5 , set res to res + s [ i ] ; TAB1 for i = 0 to size of res exclusive , print . and res [ i ] ; TAB1 print a newline ;	int main ( ) { string vowels = " aeuiyo " , s , res = "  " ; cin >> s ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] + 0 < 97 ) { s [ i ] += 32 ; } } for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = 0 ; j < 6 ; j ++ ) { if ( s [ i ] == vowels [ j ] ) { break ; } if ( j == 5 ) { res += s [ i ] ; } } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << " . " << res [ i ] ; } cout << endl ; return 0 ; }
TAB1 n is an integer ; TAB1 read n ; TAB1 integer sum equals n / 2 ; TAB1 if n modulo 2 equals 1 ; TAB2 print sum and newline ; TAB2 for integer i = 1 to sum exclusive , print 2 ; TAB2 print 3 and newline ; TAB1 else ; TAB2 print sum and newline ; TAB2 for ; TAB2 print 2 and newline ;	int main ( ) { int n ; cin >> n ; int sum = n / 2 ; if ( n % 2 == 1 ) { cout << sum << endl ; for ( int i = 1 ; i < sum ; i ++ ) { cout << " 2  " ; } cout << " 3 " << endl ; } else { cout << sum << endl ; for ( int i = 1 ; i < sum ; i ++ ) { cout << " 2  " ; } cout << " 2 " << endl ; } return 0 ; }
TAB0 let sushu be a function that accepts int n and returns a integer value ; TAB1 if n equals 1 , return 0 ; TAB1 if n equals 2 , return 1 ; TAB1 for integer i = 2 , i * i < = n , increment i by 1 ; TAB2 if n modulo i equals 0 , return 0 ; TAB1 return 1 ; TAB1 let n be a integer ; TAB1 read n ; TAB1 for integer m = 1 , the condition is always true , increment m by 1 ; TAB2 if not sushu ( n * m + 1 ) ; TAB3 print m and newline ; TAB3 stop ;	int sushu ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; } int main ( ) { int n ; cin >> n ; for ( int m = 1 ; ; m ++ ) { if ( ! sushu ( n * m + 1 ) ) { cout << m << endl ; break ; } } return 0 ; }
TAB1 n = long long ; TAB1 ans = long long ; TAB1 while read n ; TAB2 if n < = 2 ; TAB3 ans = n ; TAB2 else if n and 1 ; TAB3 ans = n * ( n - 1 ) * ( n - 2 ) ; TAB2 else ; TAB3 if n is not multiple of 3 ; TAB4 ans = n * ( n - 1 ) * ( n - 3 ) ; TAB3 else ; TAB4 ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; TAB2 print ans ;	int main ( ) { long long n ; long long ans ; while ( cin >> n ) { if ( n <= 2 ) ans = n ; else if ( n & 1 ) ans = n * ( n - 1 ) * ( n - 2 ) ; else { if ( n % 3 != 0 ) ans = n * ( n - 1 ) * ( n - 3 ) ; else ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; } cout << ans << endl ; } return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 let a , cnt be integers with cnt = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 if a is equal to 0 , increase cnt by 1 ; TAB1 if n is equal to 1 ; TAB2 if cnt is true ; TAB3 print N0 and newline ; TAB2 else do the following ; TAB3 print YES and newline ; TAB1 if cnt is equal to 1 ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 print N0 and newline ;	int main ( ) { int n ; cin >> n ; int a , cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; if ( a == 0 ) cnt ++ ; } if ( n == 1 ) { if ( cnt ) cout << " NO\n " ; else cout << " YES\n " ; return 0 ; } if ( cnt == 1 ) cout << " YES\n " ; else cout << " NO\n " ; return 0 ; }
TAB0 make ints n and m ; TAB0 create strings a and b ; TAB1 read n , m , a , and b ; TAB1 if n is greater than m ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] is equal to ' * ' ; TAB4 erase index i of a ; TAB4 break loop ; TAB2 if a is b ; TAB3 print " YES " ; TAB2 else do ; TAB3 print " NO " ; TAB1 if n is equal to m ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] is not equal to ' * ' ; TAB4 if a [ i ] is not equal to b [ i ] , print " NO " and return 0 ; TAB2 print " YES " ; TAB1 create int Now = 0 ; TAB1 while a [ Now ] is not equal to ' * ' ; TAB2 if a [ Now ] is not equal to b [ Now ] , print " NO " and return 0 ; TAB2 increment Now ; TAB1 set Now to m - 1 ; TAB1 create int now = n - 1 ; TAB1 while a [ now ] is not equal to ' * ' ; TAB2 if a [ now ] is not equal to b [ Now ] , print " NO " and return 0 ; TAB2 decrease now by 1 ; TAB2 reduce Now by 1 ; TAB1 print " YES " ;	int n , m ; string a , b ; int main ( ) { cin >> n >> m >> a >> b ; if ( n > m ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == ' * ' ) { a . erase ( i , 1 ) ; break ; } if ( a == b ) puts ( " YES " ) ; else puts ( " NO " ) ; return 0 ; } if ( n == m ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] != ' * ' ) if ( a [ i ] != b [ i ] ) return puts ( " NO " ) , 0 ; puts ( " YES " ) ; return 0 ; } int Now = 0 ; while ( a [ Now ] != ' * ' ) { if ( a [ Now ] != b [ Now ] ) return puts ( " NO " ) , 0 ; Now ++ ; } Now = m - 1 ; int now = n - 1 ; while ( a [ now ] != ' * ' ) { if ( a [ now ] != b [ Now ] ) return puts ( " NO " ) , 0 ; now -- ; Now -- ; } puts ( " YES " ) ; }
TAB0 spf be a long long array ; TAB0 gcd is a long long function ; TAB0 palindrome is a long long function ; TAB0 modexp is a long long function ; TAB0 sieve is a void function ; TAB0 getFactorization is a vector of long long values ; TAB0 getZarr is a void function ; TAB0 ceil is long long function ; TAB1 return a / b + ( a % b ! = 0 ) ; TAB1 n is a long long integer ; TAB1 read n ; TAB1 p [ n ] is a pait of long long integers ; TAB1 for long long i = 0 to n exclusive , print p [ i ] . first and p [ i ] . second ; TAB1 sort p and p + n ; TAB1 for long long i = 0 to n - 1 exclusive ; TAB2 long long r equals 2 to the power p [ i + 1 ] . first - p [ i ] . first ) * 2 ; TAB2 long long x equals ceil ( p [ i ] . second , r ) ; TAB2 p [ i + 1 ] . second equals max ( p [ i + 1 ] . second , x ) ; TAB1 ans is a long long value ; TAB1 o is a long long value equals ceil ( log10 ( p [ n - 1 ] . second ) / log10 ( 4 ) ) ; TAB1 if o is 0 , increase o by 1 ; TAB1 ans equals o + p [ n - 1 ] . first ; TAB1 print ans and newline ; TAB0 gcd is a long long function ; TAB1 if a equals 0 , return b ; TAB1 if b equals 0 , return a ; TAB1 if a equals b , return a ; TAB1 if a is greater than b , return gcd ( a % b , b ) ; TAB1 return gcd ( a , b % a ) ; TAB0 palindrome is a long long function ; TAB1 l is a long long value equals 0 ; TAB1 long long value h equals s . length ( ) - 1 ; TAB1 while h is greater tham l ; TAB2 if s [ l + + ] not equal to s [ h - - ] , return 0 ; TAB1 return 1 ; TAB0 modexp is a long long function ; TAB1 if b equals 0 , return 1 ; TAB1 long long integer temp equals modexp ( a , b / 2 , m ) ; TAB1 temp equals ( temp * temp ) modulo m ; TAB1 if b & 1 , return ( temp * ( a % m ) ) modulo m ; TAB1 reurn temp ; TAB0 sieve is a void finction ; TAB1 spf [ 1 ] equals 1 ; TAB1 for long long i = 2 to 100001 exclusive , spf [ i ] = i ; TAB1 for long long i = 4 to 100001 exclusive , spf [ i ] = 2 ; TAB1 for long long i = 3 to square root of 100001 exclusive ; TAB2 if spf [ i ] equals i ; TAB3 for long long j = i * i to 100001 ; TAB4 if spf [ j ] equals j , spf [ j ] = i ; TAB0 getFactorization is a long long fiunction ; TAB1 ret is a vector of long long values ; TAB1 while x is not equal to 1 ; TAB2 push spf [ x ] into ret ; TAB2 divide x by spf [ x ] ; TAB1 return ret ; TAB0 getZarr is a void function ; TAB1 long long n equals length of str ; TAB1 L , R , k are long long values ; TAB1 let L , R are 0 ; TAB1 for long long i = 1 to n exclusive ; TAB2 if i is greater than R ; TAB3 L , R are equal to i ; TAB3 while R < n and str [ R - L ] equals str [ R ] , increase R by 1 ; TAB3 Z [ i ] equals R - L ; TAB3 decrease R by 1 ; TAB2 else ; TAB3 k equals i - L ; TAB3 if Z [ k ] is less than R - i + 1 ; TAB4 Z [ i ] equals Z [ k ] ; TAB3 else ; TAB4 L equals i ; TAB4 while R < n and str [ R - L ] equals str [ R ] , increase R by 1 ; TAB4 Z [ i ] = R - L ; TAB4 decrease R by 1 ;	long long spf [ 100001 ] ; long long gcd ( long long a , long long b ) ; long long palindrome ( string s ) ; long long modexp ( long long a , long long b , long long m ) ; void sieve ( ) ; vector < long long > getFactorization ( long long x ) ; void getZarr ( string str , long long Z [ ] ) ; long long ceil ( long long a , long long b ) { return a / b + ( a % b != 0 ) ; } int main ( ) { long long n ; cin >> n ; pair < long long , long long > p [ n ] ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> p [ i ] . first >> p [ i ] . second ; } sort ( p , p + n ) ; for ( long long i = 0 ; i < n - 1 ; i ++ ) { long long r = pow ( 2 , ( p [ i + 1 ] . first - p [ i ] . first ) * 2 ) ; long long x = ceil ( p [ i ] . second , r ) ; p [ i + 1 ] . second = max ( p [ i + 1 ] . second , x ) ; } long long ans ; long long o = ceil ( log10 ( p [ n - 1 ] . second ) / log10 ( 4 ) ) ; if ( o == 0 ) o ++ ; ans = o + p [ n - 1 ] . first ; cout << ans << endl ; } long long gcd ( long long a , long long b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a % b , b ) ; return gcd ( a , b % a ) ; } long long palindrome ( string s ) { long long l = 0 ; long long h = s . length ( ) - 1 ; while ( h > l ) { if ( s [ l ++ ] != s [ h -- ] ) { return 0 ; } } return 1 ; } long long modexp ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 ; long long temp = modexp ( a , b / 2 , m ) ; temp = ( temp * temp ) % m ; if ( b & 1 ) return ( temp * ( a % m ) ) % m ; return temp ; } void sieve ( ) { spf [ 1 ] = 1 ; for ( long long i = 2 ; i < 100001 ; i ++ ) spf [ i ] = i ; for ( long long i = 4 ; i < 100001 ; i += 2 ) spf [ i ] = 2 ; for ( long long i = 3 ; i * i < 100001 ; i ++ ) { if ( spf [ i ] == i ) { for ( long long j = i * i ; j < 100001 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } vector < long long > getFactorization ( long long x ) { vector < long long > ret ; while ( x != 1 ) { ret . push_back ( spf [ x ] ) ; x = x / spf [ x ] ; } return ret ; } void getZarr ( string str , long long Z [ ] ) { long long n = str . length ( ) ; long long L , R , k ; L = R = 0 ; for ( long long i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) R ++ ; Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) Z [ i ] = Z [ k ] ; else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) R ++ ; Z [ i ] = R - L ; R -- ; } } } }
TAB0 n , m = int ; TAB0 let lg be a 111x111 boolean matrix ; TAB0 let a be a 111x111 int matrix ; TAB0 let v be a boolean array of size 111 with v [ 0 ] = 0 ; TAB0 let zero be a bool array of length 111 with zero [ 0 ] = 0 ; TAB0 ex = 0 = int ; TAB0 in void function dfs that takes int i ; TAB1 set v [ i ] to true ; TAB1 for j = 1 to n inclusive ; TAB2 if a [ i ] [ j ] isn ' t 0 and v [ j ] is 0 then call dfs of j ; TAB1 read n , m ; TAB1 for i = 1 to n inclusive ; TAB2 t = int ; TAB2 read t ; TAB2 if t = 0 ; TAB3 set zero [ i ] = true ; TAB3 increment ex ; TAB2 while decrementing t ; TAB3 c = int ; TAB3 read c ; TAB3 set lg [ i ] [ c ] to true ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if i isn ' t j ; TAB4 for k = 1 to m inclusive ; TAB5 if lg [ i ] [ k ] and lg [ j ] [ k ] then set a [ i ] [ j ] to 1 ; TAB1 ans = int = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 if v [ i ] = 0 and zero [ i ] is not 0 ; TAB3 call dfs on i ; TAB3 increment ans ; TAB1 decrement ans ; TAB1 if ans is negative then reset ans to 0 ; TAB1 print ans + ex and new line ;	int n , m ; bool lg [ 111 ] [ 111 ] ; int a [ 111 ] [ 111 ] ; bool v [ 111 ] = { 0 } ; bool zero [ 111 ] = { 0 } ; int ex = 0 ; void dfs ( int i ) { v [ i ] = true ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ] [ j ] && ! v [ j ] ) { dfs ( j ) ; } } } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { int t ; cin >> t ; if ( t == 0 ) { zero [ i ] = true ; ex ++ ; } while ( t -- ) { int c ; cin >> c ; lg [ i ] [ c ] = true ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i != j ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( lg [ i ] [ k ] && lg [ j ] [ k ] ) { a [ i ] [ j ] = 1 ; } } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! v [ i ] && ! zero [ i ] ) { dfs ( i ) ; ans ++ ; } } ans -- ; if ( ans < 0 ) ans = 0 ; cout << ans + ex << endl ; return 0 ; }
TAB1 declare new integers i , j and n and arrays s and k with 2005 elements ; TAB1 read n from the input ; TAB1 read n elements from the standard input into s ; TAB1 set first sizeof ( k ) bytes at the pointer k to 0 ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 increment j in a loop from 0 to n exclusive ; TAB3 if s [ j ] > s [ i ] and j ! = i , increment k [ i ] ; TAB3 if s [ j ] is equal to s [ i ] and j = i , increment k [ i ] ; TAB1 start for loop from i = 0 to n exclusive incrementing i ; TAB2 if i is equal to 0 ; TAB3 print k [ i ] to the standard output ; TAB2 else ; TAB3 print " " and k [ i ] ; TAB1 print new line ;	int main ( ) { int i , j , n , s [ 2005 ] , k [ 2005 ] ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; memset ( k , 0 , sizeof ( k ) ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( s [ j ] > s [ i ] && j != i ) k [ i ] ++ ; if ( s [ j ] == s [ i ] && j == i ) k [ i ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { if ( i == 0 ) cout << k [ i ] ; else cout << "   " << k [ i ] ; } cout << endl ; return 0 ; }
TAB1 create int s , t , x ; TAB1 while reading s , t , x is not stopped ; TAB2 if x is less than s + t ; TAB3 if x equals s ; TAB4 print " YES " ; TAB3 else ; TAB4 print " NO " ; TAB2 else ; TAB3 if ( x - s ) mod t equals 0 or ( x - s - 1 ) mod t equals 0 ; TAB4 print " YES " ; TAB3 else ; TAB4 print " NO " ;	int main ( ) { int s , t , x ; while ( cin >> s >> t >> x ) { if ( x < s + t ) if ( x == s ) cout << " YES " << endl ; else cout << " NO " << endl ; else { if ( ( x - s ) % t == 0 || ( x - s - 1 ) % t == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; } } return 0 ; }
TAB1 make ints i and j ; TAB1 make int array vis of size 220 with array of size 220 with { 0 } ; TAB1 make integer array vis1 of size 220 with array of size 220 with { 0 } ; TAB1 make int arrays x of size 5 , y of size 5 , x1 of size 5 , and y1 of size 5 ; TAB1 for i = 0 to 4 exclusive , read x [ i ] and y [ i ] ; TAB1 for i = 0 to 4 exclusive , read x1 [ i ] and y1 [ i ] ; TAB1 sort x using x + 4 ; TAB1 sort x1 using x1 + 4 ; TAB1 sort y using y + 4 ; TAB1 sort y1 using y1 + 4 ; TAB1 make integer ox = min ( x [ 0 ] , x1 [ 0 ] ) ; TAB1 create int oy = min ( y [ 0 ] , y1 [ 0 ] ) ; TAB1 if ox is less than 0 , set ox to - ox ; TAB1 if oy is less than 0 , set oy to - oy ; TAB1 for i = x [ 0 ] + ox to x [ 3 ] + ox ; TAB2 for j = y [ 0 ] + oy to y [ 3 ] + oy , set vis [ i ] [ j ] to 1 ; TAB1 make integer mid = ( x1 [ 0 ] + ox + x1 [ 3 ] + ox ) / 2 ; TAB1 create int s = y1 [ 0 ] + oy ; TAB1 let int t = y1 [ 3 ] + oy ; TAB1 for i = mid to x1 [ 0 ] + ox ; TAB2 for j = s to t , set vis1 [ i ] [ j ] to 1 ; TAB2 increment s ; TAB2 decrease t by 1 ; TAB1 set s to y1 [ 0 ] + oy ; TAB1 set t to y1 [ 3 ] + oy ; TAB1 for i = mid to x1 [ 3 ] + ox ; TAB2 for j = s to t , set vis1 [ i ] [ j ] to 1 ; TAB2 increment s ; TAB2 decrease t by 1 ; TAB1 for i = 0 to 220 exclusive ; TAB2 for j = 0 to 220 exclusive ; TAB3 if vis [ i ] [ j ] is equal to 1 and vis1 [ i ] [ j ] is equal to 1 ; TAB4 print " YES " ; TAB1 show " NO " ;	int main ( ) { int i , j ; int vis [ 220 ] [ 220 ] = { 0 } ; int vis1 [ 220 ] [ 220 ] = { 0 } ; int x [ 5 ] , y [ 5 ] , x1 [ 5 ] , y1 [ 5 ] ; for ( i = 0 ; i < 4 ; i ++ ) cin >> x [ i ] >> y [ i ] ; for ( i = 0 ; i < 4 ; i ++ ) cin >> x1 [ i ] >> y1 [ i ] ; sort ( x , x + 4 ) ; sort ( x1 , x1 + 4 ) ; sort ( y , y + 4 ) ; sort ( y1 , y1 + 4 ) ; int ox = min ( x [ 0 ] , x1 [ 0 ] ) ; int oy = min ( y [ 0 ] , y1 [ 0 ] ) ; if ( ox < 0 ) ox = - ox ; if ( oy < 0 ) oy = - oy ; for ( i = x [ 0 ] + ox ; i <= x [ 3 ] + ox ; i ++ ) for ( j = y [ 0 ] + oy ; j <= y [ 3 ] + oy ; j ++ ) vis [ i ] [ j ] = 1 ; int mid = ( x1 [ 0 ] + ox + x1 [ 3 ] + ox ) / 2 ; int s = y1 [ 0 ] + oy ; int t = y1 [ 3 ] + oy ; for ( i = mid ; i >= x1 [ 0 ] + ox ; i -- ) { for ( j = s ; j <= t ; j ++ ) { vis1 [ i ] [ j ] = 1 ; } s ++ ; t -- ; } s = y1 [ 0 ] + oy ; t = y1 [ 3 ] + oy ; for ( i = mid ; i <= x1 [ 3 ] + ox ; i ++ ) { for ( j = s ; j <= t ; j ++ ) { vis1 [ i ] [ j ] = 1 ; } s ++ ; t -- ; } for ( i = 0 ; i < 220 ; i ++ ) { for ( j = 0 ; j < 220 ; j ++ ) { if ( vis [ i ] [ j ] == 1 && vis1 [ i ] [ j ] == 1 ) { cout << " YES " << endl ; return 0 ; } } } cout << " NO " << endl ; return 0 ; }
TAB0 create const integer maxn = 1e5 + 10 ; TAB0 make integer array a of size maxn ; TAB0 let bool array vis of size maxn ; TAB0 let integer n ; TAB1 read n ; TAB1 if n is equal to 1 ; TAB2 print 1 ; TAB1 if n modulo 4 is greater than 1 ; TAB2 display - 1 ; TAB1 if n & 1 is truthy ; TAB2 set a [ n / 2 + 1 ] to n / 2 + 1 ; TAB2 set vis [ n / 2 + 1 ] to 1 ; TAB1 set a [ 1 ] to 2 ; TAB1 set a [ 2 ] to n ; TAB1 set a [ n ] to n - 1 ; TAB1 set a [ n - 1 ] to 1 ; TAB1 set vis [ 1 ] , vis [ 2 ] , vis [ n ] , and vis [ n - 1 ] to 1 ; TAB1 for i = 1 to n ; TAB2 if vis [ i ] is falsy ; TAB3 create int x ; TAB3 set x to i + 1 ; TAB3 set a [ i ] to x ; TAB3 set a [ x ] to n - i + 1 ; TAB3 set a [ n - i + 1 ] to n - x + 1 ; TAB3 set a [ n - x + 1 ] to i ; TAB3 set vis [ i ] , vis [ x ] , vis [ n - i + 1 ] , and vis [ n - x + 1 ] to 1 ; TAB1 set for i = 1 to n ; TAB2 if i is equal to 1 ; TAB3 show a [ i ] ; TAB2 else do ; TAB3 show " " ; TAB1 print new line ;	const int maxn = 1e5 + 10 ; int a [ maxn ] ; bool vis [ maxn ] ; int n ; int main ( ) { cin >> n ; if ( n == 1 ) { cout << 1 << endl ; return 0 ; } if ( n % 4 > 1 ) { cout << - 1 << endl ; return 0 ; } if ( n & 1 ) { a [ n / 2 + 1 ] = n / 2 + 1 ; vis [ n / 2 + 1 ] = 1 ; } a [ 1 ] = 2 ; a [ 2 ] = n ; a [ n ] = n - 1 ; a [ n - 1 ] = 1 ; vis [ 1 ] = vis [ 2 ] = vis [ n ] = vis [ n - 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) { int x ; x = i + 1 ; a [ i ] = x ; a [ x ] = n - i + 1 ; a [ n - i + 1 ] = n - x + 1 ; a [ n - x + 1 ] = i ; vis [ i ] = vis [ x ] = vis [ n - i + 1 ] = vis [ n - x + 1 ] = 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 1 ) cout << a [ i ] ; else cout << "   " << a [ i ] ; } cout << endl ; return 0 ; }
TAB0 character = map of string to int ; TAB0 s = string ; TAB0 n , m , k , res , level = double ; TAB0 check = float ; TAB1 read n , m , k ; TAB1 while decrement n ; TAB2 read s and level ; TAB2 check = k * level ; TAB2 if check > = 100 , character [ s ] = check ; TAB1 while decrement m ; TAB2 read s ; TAB2 if character [ s ] > = 100 ; TAB3 continue next iteration ; TAB2 else ; TAB3 character [ s ] = 0 ; TAB1 iterator it = map from string to integer ; TAB1 print character . size ( ) ; TAB1 for it = character . begin ( ) to it is not character . end ( ) , print it - > first , " " , it - > second ;	map < string , int > character ; string s ; double n , m , k , res , level ; float check ; int main ( ) { cin >> n >> m >> k ; while ( n -- ) { cin >> s >> level ; check = k * level ; if ( check >= 100 ) character [ s ] = check ; } while ( m -- ) { cin >> s ; if ( character [ s ] >= 100 ) continue ; else { character [ s ] = 0 ; } } map < string , int > :: iterator it ; cout << character . size ( ) << endl ; for ( it = character . begin ( ) ; it != character . end ( ) ; it ++ ) { cout << it -> first << "   " << it -> second << endl ; } return 0 ; }
TAB0 create long long mod with mod = 998244353 ; TAB0 create integer array a with size 100000 ; TAB1 create integer n ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 create long long vectors up , notup , prev_up , prev_notup , with up initialized with 201 , notup initialized with 201 , prev_up initialized with ( 201 , 0 ) , prev_notup initialized with ( 201 , 0 ) ; TAB1 set prev_up [ 0 ] to 1 ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 1 to 200 inclusive ; TAB3 increment prev_up [ j ] by prev_up [ j - 1 ] , set prev_up [ j ] to prev_up [ j ] % mod ; TAB3 increment prev_notup [ j ] by prev_notup [ j - 1 ] , set prev_notup [ j ] to prev_notup [ j ] % mod ; TAB2 set up [ 0 ] to notup [ 0 ] to 0 ; TAB2 for j = 1 to 200 inclusive ; TAB3 set up [ j ] to notup [ j ] to 0 ; TAB3 if a [ i ] is not - 1 and a [ i ] is not j , break current loop iteration ; TAB3 increment up [ j ] by prev_up [ j - 1 ] + prev_notup [ j - 1 ] , set up [ j ] to up [ j ] % mod ; TAB3 increment notup [ j ] by prev_up [ j ] + prev_notup [ j ] , set notup [ j ] to notup [ j ] % mod ; TAB3 decrement notup [ j ] by prev_up [ j - 1 ] + prev_notup [ j - 1 ] , set notup [ j ] to notup [ j ] % mod ; TAB3 increment notup [ j ] by prev_notup [ 200 ] - prev_notup [ j ] , set notup [ j ] to notup [ j ] % mod ; TAB2 set prev_up to up ; TAB2 set prev_notup to notup ; TAB1 create long long ans with ans = 0 ; TAB1 for i = 1 to 200 inclusive , increment ans by prev_notup [ i ] , set ans to ans % mod ; TAB1 print ( ans + mod ) % mod print newline ;	long long mod = 998244353 ; int a [ 100000 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; vector < long long > up ( 201 ) , notup ( 201 ) , prev_up ( 201 , 0 ) , prev_notup ( 201 , 0 ) ; prev_up [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= 200 ; j ++ ) { ( prev_up [ j ] += prev_up [ j - 1 ] ) %= mod ; ( prev_notup [ j ] += prev_notup [ j - 1 ] ) %= mod ; } up [ 0 ] = notup [ 0 ] = 0 ; for ( int j = 1 ; j <= 200 ; j ++ ) { up [ j ] = notup [ j ] = 0 ; if ( a [ i ] != - 1 && a [ i ] != j ) continue ; ( up [ j ] += prev_up [ j - 1 ] + prev_notup [ j - 1 ] ) %= mod ; ( notup [ j ] += prev_up [ j ] + prev_notup [ j ] ) %= mod ; ( notup [ j ] -= prev_up [ j - 1 ] + prev_notup [ j - 1 ] ) %= mod ; ( notup [ j ] += prev_notup [ 200 ] - prev_notup [ j ] ) %= mod ; } prev_up = up ; prev_notup = notup ; } long long ans = 0 ; for ( int i = 1 ; i <= 200 ; i ++ ) ( ans += prev_notup [ i ] ) %= mod ; cout << ( ans + mod ) % mod << endl ; }
TAB0 empty function fast ; TAB1 call fast ( ) ; TAB1 create new string called str ; TAB1 read str from the user input ; TAB1 create new integers no = length of str and j , and an array has with 256 elements filled with 0 ; TAB1 declare integers n , i , e and t ; TAB1 chaning j from 0 to no exclusive , increment has [ str [ j ] ] ; TAB1 for j from 0 to no exclusive ; TAB2 set n to ( has [ ' n ' ] - 1 ) / 2 ; TAB2 assign the new value = has [ ' i ' ] / 1 to i ; TAB2 assign has [ ' e ' ] / 3 to e ; TAB2 assign the new value = has [ ' t ' ] / 1 to t ; TAB1 print min of ( min ( n , t ) and min ( i , e ) ) ;	void fast ( ) { } int main ( ) { fast ( ) ; string str ; cin >> str ; int no = str . size ( ) , j , has [ 256 ] = { 0 } ; int n , i , e , t ; for ( j = 0 ; j < no ; j ++ ) has [ str [ j ] ] ++ ; for ( j = 0 ; j < no ; j ++ ) { n = ( has [ ' n ' ] - 1 ) / 2 ; i = has [ ' i ' ] / 1 ; e = has [ ' e ' ] / 3 ; t = has [ ' t ' ] / 1 ; } cout << min ( min ( n , t ) , min ( i , e ) ) << endl ; }
TAB1 i and counter are integers both set to 0 ; TAB1 arr is a string ; TAB1 read arr ; TAB1 for i = 0 to ( size of arr ) - 1 exclusive ; TAB2 if arr [ i ] is the character 1 and arr [ i + 1 ] is the character 0 ; TAB3 assign ' ' to arr [ i + 1 ] ; TAB3 increment counter ; TAB3 break ; TAB1 if counter is 0 ; TAB2 if arr [ 0 ] is the character 0 ; TAB3 assign ' ' to arr [ 0 ] ; TAB2 else ; TAB3 assign ' ' to arr [ ( size of arr ) - 1 ] ; TAB1 for i = 0 to size of arr exclusive ; TAB2 if arr [ i ] isn ' t ' ' , display arr [ i ] ; TAB1 display newline ;	int main ( ) { int i , counter = 0 ; string arr ; cin >> arr ; for ( i = 0 ; i < arr . size ( ) - 1 ; i ++ ) { if ( arr [ i ] == ' 1 ' && arr [ i + 1 ] == ' 0 ' ) { arr [ i + 1 ] = '   ' ; counter ++ ; break ; } } if ( counter == 0 ) { if ( arr [ 0 ] == ' 0 ' ) { arr [ 0 ] = '   ' ; } else { arr [ arr . size ( ) - 1 ] = '   ' ; } } for ( i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] != '   ' ) { cout << arr [ i ] ; } } cout << endl ; return 0 ; }
TAB0 create long long dia [ 10005 ] ; TAB1 create long long n ; TAB1 create long long m and k ; TAB1 read n , m and k ; TAB1 for i = 0 to n exclusive , read dia [ i ] ; TAB1 if n is even ; TAB2 print 0 ; TAB1 else ; TAB2 set h to m / ( 1 + ( n - 1 ) / 2 ) ; TAB2 MI = dia [ 0 ] ; TAB2 for j = 0 to n exclusive , with increment j = j + 2 ; TAB3 if MI > dia [ j ] , set Mi to dia [ j ] ; TAB2 if MI < k * h ; TAB3 print MI ; TAB2 else ; TAB3 print k * h ;	long long dia [ 10005 ] ; int main ( ) { long long n ; long long m , k ; cin >> n >> m >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> dia [ i ] ; } if ( n % 2 == 0 ) { cout << 0 << endl ; } else { long long h = m / ( 1 + ( n - 1 ) / 2 ) ; long long MI = dia [ 0 ] ; for ( int j = 0 ; j < n ; j += 2 ) { if ( MI > dia [ j ] ) MI = dia [ j ] ; } if ( MI < k * h ) cout << MI << endl ; else cout << k * h << endl ; } return 0 ; }
TAB0 maxn is a constant integer set to 1e5 + 7 ; TAB0 a = integer array of size maxn ; TAB0 b = integer array of size maxn ; TAB0 c = integer array of size maxn ; TAB1 n = integer ; TAB1 read n ; TAB1 read n values into array a ; TAB1 for i = 1 to n exclusive , set b [ i ] to absolute value ( a [ i ] - a [ i + 1 ] ) ; TAB1 for i = 1 to n exclusive ; TAB2 if i mod 2 ; TAB3 set c [ i ] to b [ i ] ; TAB2 else ; TAB3 set c [ i ] to ( - 1 ) * b [ i ] ; TAB1 for i = 1 to n exclusive ; TAB2 if i mod 2 ; TAB3 set a [ i ] to ( - 1 ) * b [ i ] ; TAB2 else ; TAB3 set a [ i ] to b [ i ] ; TAB1 suma , sumb are long longs both set to 0 ; TAB1 ansa and ansb are long longs both set to - 0x3f3f3f3f ; TAB1 for i = 1 to n exclusive ; TAB2 add c [ i ] to suma ; TAB2 set ansa to call max with ansa , suma ; TAB2 if suma is negative , set suma to 0 ; TAB1 for i = 1 to n exclusive ; TAB2 add a [ i ] to sumb ; TAB2 set ansb to call max with ansb , sumb ; TAB2 if sumb is negative , set sumb to 0 ; TAB1 display call max with ansa , ansb ;	const int maxn = 1e5 + 7 ; int a [ maxn ] ; int b [ maxn ] ; int c [ maxn ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { b [ i ] = abs ( a [ i ] - a [ i + 1 ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( i % 2 ) { c [ i ] = b [ i ] ; } else { c [ i ] = ( - 1 ) * b [ i ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( i % 2 ) a [ i ] = ( - 1 ) * b [ i ] ; else a [ i ] = b [ i ] ; } long long suma = 0 , sumb = 0 ; long long ansa = - 0x3f3f3f3f , ansb = - 0x3f3f3f3f ; for ( int i = 1 ; i < n ; i ++ ) { suma += c [ i ] ; ansa = max ( ansa , suma ) ; if ( suma < 0 ) { suma = 0 ; } } for ( int i = 1 ; i < n ; i ++ ) { sumb += a [ i ] ; ansb = max ( ansb , sumb ) ; if ( sumb < 0 ) sumb = 0 ; } cout << max ( ansa , ansb ) << endl ; return 0 ; }
TAB1 n , m , x = integer with x = 0 ; TAB1 k = double ; TAB1 kk = float ; TAB1 s = string ; TAB1 v = map from string to int ; TAB1 iterator it = map from string to int ; TAB1 read n , m , k ; TAB1 while decrement n ; TAB2 read s , x ; TAB2 kk = x * k ; TAB2 if kk > = 100 , v [ s ] = kk ; TAB1 while decrement m ; TAB2 read s ; TAB2 if not v [ s ] , v [ s ] = 0 ; TAB1 print v . size ( ) ; TAB1 for it = v . begin ( ) to it is not v . end ( ) , print first of pointer it , " " , second of pointer it ;	int main ( ) { int n , m , x = 0 ; double k ; float kk ; string s ; map < string , int > v ; map < string , int > :: iterator it ; cin >> n >> m >> k ; while ( n -- ) { cin >> s >> x ; kk = x * k ; if ( kk >= 100 ) v [ s ] = kk ; } while ( m -- ) { cin >> s ; if ( ! v [ s ] ) v [ s ] = 0 ; } cout << v . size ( ) << endl ; for ( it = v . begin ( ) ; it != v . end ( ) ; it ++ ) cout << ( * it ) . first << "   " << ( * it ) . second << endl ; return 0 ; }
TAB1 ya = bool with ya = false ; TAB1 sub = char set array of size 250 ; TAB1 s = string ; TAB1 read s ; TAB1 if length of s is less than 3 ; TAB2 print " No " ; TAB1 for i = 0 to length of s - 2 ; TAB2 if s [ i ] is not ' . ' then insert s [ i ] into sub [ i ] ; TAB2 if s [ i + 1 ] is not ' . ' then insert s [ i + 1 ] into sub [ i ] ; TAB2 if s [ i + 2 ] is not ' . ' then insert s [ i + 2 ] into sub [ i ] ; TAB2 if size of sub [ i ] is greater than 2 then set ya to true ; TAB1 if ya is true print " Yes " else print " No " ;	int main ( ) { bool ya = false ; set < char > sub [ 250 ] ; string s ; cin >> s ; if ( s . length ( ) <= 2 ) { cout << " No " << endl ; return 0 ; } for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s [ i ] != ' . ' ) sub [ i ] . insert ( s [ i ] ) ; if ( s [ i + 1 ] != ' . ' ) sub [ i ] . insert ( s [ i + 1 ] ) ; if ( s [ i + 2 ] != ' . ' ) sub [ i ] . insert ( s [ i + 2 ] ) ; if ( sub [ i ] . size ( ) > 2 ) ya = true ; } ( ya ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
TAB1 x , y = integers , increment = integer = 0 , ansx = integer = 0 , ansy = integer = 0 , turns = integer = 0 ; TAB1 read x , y ; TAB1 if x is 0 and y is 0 ; TAB2 print 0 ; TAB1 indefinitely perform the while loop ; TAB2 increase increment by 1 ; TAB2 for i = 0 to increment exclusive ; TAB3 increase ansx by 1 ; TAB3 if ansx is x and ansy is y ; TAB4 print turns ; TAB2 increase turns by 1 ; TAB2 for i = 0 to increment exclusive ; TAB3 increase ansy by 1 ; TAB3 if ansx is x and ansy is y ; TAB4 print turns ; TAB2 increase turns by 1 ; TAB2 increase increment by 1 ; TAB2 for i = 0 to increment exclusive ; TAB3 decrease ansx by 1 ; TAB3 if ansx is x and ansy is y ; TAB4 print turns ; TAB2 increase turns by 1 ; TAB2 for i = 0 to increment exclusive ; TAB3 decrease ansy by 1 ; TAB3 if ansx is x and ansy is y ; TAB4 print turns ; TAB2 increase turns by 1 ;	int main ( ) { int x , y , increment = 0 , ansx = 0 , ansy = 0 , turns = 0 ; cin >> x >> y ; if ( x == 0 && y == 0 ) { cout << 0 << endl ; return 0 ; } while ( true ) { increment ++ ; for ( int i = 0 ; i < increment ; i ++ ) { ansx ++ ; if ( ansx == x && ansy == y ) { cout << turns << endl ; return 0 ; } } turns ++ ; for ( int i = 0 ; i < increment ; i ++ ) { ansy ++ ; if ( ansx == x && ansy == y ) { cout << turns << endl ; return 0 ; } } turns ++ ; increment ++ ; for ( int i = 0 ; i < increment ; i ++ ) { ansx -- ; if ( ansx == x && ansy == y ) { cout << turns << endl ; return 0 ; } } turns ++ ; for ( int i = 0 ; i < increment ; i ++ ) { ansy -- ; if ( ansx == x && ansy == y ) { cout << turns << endl ; return 0 ; } } turns ++ ; } return 0 ; }
TAB0 create integer n ; TAB0 declare long long arrays c and vis with size 105 ; TAB0 declare long long variable ans = 1 ; TAB0 integer function cnt with int argument x ; TAB1 create integer res = 1 ; TAB1 create integer temp = c [ x ] ; TAB1 set vis [ temp ] to 1 ; TAB1 while temp ! = x ; TAB2 increment res ; TAB2 set temp to c [ temp ] ; TAB2 change vis [ temp ] to 1 ; TAB2 return - 1 if res > = 2 * n ; TAB1 return - 1 if res > = 2 * n ; TAB1 if res is even ; TAB2 return res / 2 ; TAB1 else ; TAB2 return res ; TAB0 long long function gcb with long long arguments a and b ; TAB1 if b = 0 , return a ; TAB1 return gcb of b and a modulo b ; TAB0 long long function lcm with long long arguments a and b ; TAB1 return a * b / ( gcb of a and b ) ; TAB1 read input to n ; TAB1 set first sizeof ( vis ) bytes at the pointer vis to 0 ; TAB1 loop i from 1 to n inclusive , read c [ i ] ; TAB1 declare long long temp ; TAB1 for i = 1 to n inclusive ; TAB2 if vis [ i ] is false , change temp to cnt of i ; TAB2 if temp = - 1 ; TAB3 print " - 1 " ; TAB2 assign lcm of ans and temp to ans ; TAB1 print ans ;	int n ; long long c [ 105 ] , vis [ 105 ] ; long long ans = 1 ; int cnt ( int x ) { int res = 1 ; int temp = c [ x ] ; vis [ temp ] = 1 ; while ( temp != x ) { res ++ ; temp = c [ temp ] ; vis [ temp ] = 1 ; if ( res >= 2 * n ) return - 1 ; } if ( res >= 2 * n ) return - 1 ; if ( res % 2 == 0 ) return res / 2 ; else return res ; } long long gcb ( long long a , long long b ) { if ( ! b ) return a ; return gcb ( b , a % b ) ; } long long lcm ( long long a , long long b ) { return a * b / gcb ( a , b ) ; } int main ( ) { cin >> n ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( int i = 1 ; i <= n ; i ++ ) cin >> c [ i ] ; long long temp ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) temp = cnt ( i ) ; if ( temp == - 1 ) { cout << " -1 " << endl ; return 0 ; } ans = lcm ( ans , temp ) ; } cout << ans << endl ; return 0 ; }
TAB1 n = long long ; TAB1 while reading n ; TAB2 let a be an int array of length 4 and = 6 , 8 , 4 , 2 ; TAB2 if n is not 0 ; TAB3 print 1 ; TAB2 else ; TAB3 print a [ n mod 4 ] ;	int main ( ) { long long n ; while ( cin >> n ) { int a [ 4 ] = { 6 , 8 , 4 , 2 } ; if ( ! n ) cout << " 1 " << endl ; else cout << a [ n % 4 ] << endl ; } return 0 ; }
TAB0 in function fun with argument long long integer x and returns a long long integer ; TAB1 if x < 10 , then return x ; TAB1 r = long long integer = x / 10 + 9 ; TAB1 d = long long integer = x ; TAB1 while d > = 10 , then d = d / 10 ; TAB1 if d > x modulo 10 , then decrease r by 1 ; TAB1 return r ; TAB1 l , r , x , y = long long integer ; TAB1 read l , r ; TAB1 x = the result of calling fun with argument r ; TAB1 y = the result of calling fun with argument ( l - 1 ) ; TAB1 print the result of x - y ;	long long int fun ( long long int x ) { if ( x < 10 ) return x ; long long int r = x / 10 + 9 ; long long int d = x ; while ( d >= 10 ) d /= 10 ; if ( d > x % 10 ) r -- ; return r ; } int main ( ) { long long int l , r , x , y ; cin >> l >> r ; x = fun ( r ) ; y = fun ( l - 1 ) ; cout << x - y << endl ; return 0 ; }
TAB0 create long long n , array dia of size 10010 , m , ans = 0 , mis = 100000 , k , need = 0 ; TAB1 read n , m , k ; TAB1 for i = 1 to n inclusive ; TAB2 read dia [ n ] ; TAB2 if mis greater than dia [ i ] and i is odd : set mis to dia [ i ] ; TAB1 set need to n / 2 + 1 ; TAB1 if n is even or need is greater than m ; TAB2 pass ; TAB1 else ; TAB2 set ans to m / need * k ; TAB2 set ans to min ( mis , ans ) ; TAB1 print ans ;	long long n , dia [ 10010 ] , m , ans = 0 , mis = 100000 , k , need = 0 ; int main ( ) { cin >> n >> m >> k ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> dia [ i ] ; if ( mis > dia [ i ] && i % 2 == 1 ) mis = dia [ i ] ; } need = n / 2 + 1 ; if ( n % 2 == 0 || need > m ) ; else { ans = m / need * k ; ans = min ( mis , ans ) ; } cout << ans << endl ; return 0 ; }
TAB0 arr , change , cyka = array of 6969 int , temp , blyat = int ; TAB1 c = int ; TAB1 read c ; TAB1 for a = 0 to c exclusive ; TAB2 read blyat ; TAB2 change [ a ] = blyat ; TAB2 arr [ a ] = blyat ; TAB1 for a = 0 to c exclusive ; TAB2 temp = 1 ; TAB2 for x = 0 to c exclusive ; TAB3 if change [ a ] < arr [ x ] increment temp ; TAB3 cyka [ a ] = temp ; TAB1 for a = 0 to c exclusive ; TAB2 if a is c - 1 ; TAB3 print cyka [ a ] , newline ; TAB2 else ; TAB3 print cyka [ a ] , space ;	int arr [ 6969 ] , change [ 6969 ] , temp , cyka [ 6969 ] , blyat ; int main ( ) { int c ; cin >> c ; for ( int a = 0 ; a < c ; a ++ ) { cin >> blyat ; change [ a ] = blyat ; arr [ a ] = blyat ; } for ( int a = 0 ; a < c ; a ++ ) { temp = 1 ; for ( int x = 0 ; x < c ; x ++ ) { if ( change [ a ] < arr [ x ] ) temp ++ ; cyka [ a ] = temp ; } } for ( int a = 0 ; a < c ; a ++ ) { if ( a == c - 1 ) cout << cyka [ a ] << " \n " ; else cout << cyka [ a ] << "   " ; } }
TAB0 declare constant int N = 1e5 + 5 ; TAB0 create long long array arr with N elements ; TAB0 vis = map from long long to boolean ; TAB0 declare integer variable n ; TAB0 create long long m ; TAB1 read n and m ; TAB1 for i = 0 to n - 1 , read arr [ i ] ; TAB1 sort arr ; TAB1 declare integer variable ans = 0 ; TAB1 for i from 0 to n - 1 inclusive ; TAB2 if vis [ arr [ i ] ] is true , skip the rest of the loop ; TAB2 set vis [ arr [ i ] * m ] to true ; TAB2 increment ans ; TAB1 print ans ;	const int N = 1e5 + 5 ; long long arr [ N ] ; map < long long , bool > vis ; int n ; long long m ; int main ( ) { cin >> n >> m ; for ( int i = 0 ; i <= n - 1 ; i += 1 ) cin >> arr [ i ] ; sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i <= n - 1 ; i += 1 ) { if ( vis [ arr [ i ] ] ) continue ; vis [ arr [ i ] * m ] = true ; ans ++ ; } cout << ans << endl ; return 0 ; }
TAB0 create long long const mod = 1000000007 ; TAB0 make long long const md = 998244353 ; TAB0 declare mypow taking in long long ints a and b and returning long long ; TAB1 create long long int res = 1 ; TAB1 set a to a % mod ; TAB1 if b is less than 0 , end function ; TAB1 for loop while b is truthy ; TAB2 if b & 1 is truthy , set res to res * a % mod ; TAB2 set a to a * a % mod ; TAB1 return res ; TAB0 open txt . in for input ; TAB0 open txt . out for output ; TAB0 create int vector v of size 105 ; TAB0 make int vector v1 of size 105 ; TAB0 create bool array vis of size 105 ` ; TAB0 declare dfs taking in long long x ; TAB1 set vis [ x ] to 1 ; TAB1 create int u = v [ x ] . size ( ) ; TAB1 for i = 0 to u exclusive ; TAB2 if ! vis [ v [ x ] [ i ] ] is truthy , call dfs ( v [ x ] [ i ] ) ; TAB1 print fixed and setprecision ( 12 ) ; TAB1 create long long n and m ; TAB1 read n and m ; TAB1 make integer ok2 = 0 ; TAB1 for i = 1 to n ; TAB2 make long long int x ; TAB2 read x ; TAB2 set ok2 to ok2 | ( x > 0 ) ; TAB2 for j = 1 to x ; TAB3 make long long integer y ; TAB3 read y ; TAB3 append y to v1 [ i ] ; TAB1 for i = 1 to n ; TAB2 for j = i + 1 to n ; TAB3 make int u = v1 [ i ] . size ( ) ; TAB3 create int ok = 0 ; TAB3 make u1 = v1 [ j ] . size ( ) ; TAB3 for t = 0 to u exclusive ; TAB4 for t1 = 0 to u1 exclusive ; TAB5 if v1 [ i ] [ t ] is equal to v1 [ j ] [ t1 ] , set ok to 1 ; TAB3 if ok is truthy ; TAB4 append j to v [ i ] ; TAB4 append i to v [ j ] ; TAB1 create long long cnt = 0 ; TAB1 for i = 1 to n ; TAB2 if ! vis [ i ] is truthy ; TAB3 increment cnt ; TAB3 call dfs with argument i ; TAB1 print cnt - ok2 ;	long long const mod = 1000000007 ; long long const md = 998244353 ; long long mypow ( long long a , long long b ) { long long res = 1 ; a %= mod ; assert ( b >= 0 ) ; for ( ; b ; b >>= 1 ) { if ( b & 1 ) res = res * a % mod ; a = a * a % mod ; } return res ; } ifstream in ( " txt.in " ) ; ofstream out ( " txt.out " ) ; vector < int > v [ 105 ] ; vector < int > v1 [ 105 ] ; bool vis [ 105 ] ; void dfs ( long long x ) { vis [ x ] = 1 ; int u = v [ x ] . size ( ) ; for ( int i = 0 ; i < u ; ++ i ) { if ( ! vis [ v [ x ] [ i ] ] ) dfs ( v [ x ] [ i ] ) ; } } int main ( ) { cout << fixed << setprecision ( 12 ) ; long long n , m ; cin >> n >> m ; int ok2 = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { long long x ; cin >> x ; ok2 |= ( x > 0 ) ; for ( int j = 1 ; j <= x ; ++ j ) { long long y ; cin >> y ; v1 [ i ] . push_back ( y ) ; } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i + 1 ; j <= n ; ++ j ) { int u = v1 [ i ] . size ( ) ; int ok = 0 ; int u1 = v1 [ j ] . size ( ) ; for ( int t = 0 ; t < u ; ++ t ) { for ( int t1 = 0 ; t1 < u1 ; ++ t1 ) { if ( v1 [ i ] [ t ] == v1 [ j ] [ t1 ] ) ok = 1 ; } } if ( ok ) { v [ i ] . push_back ( j ) ; v [ j ] . push_back ( i ) ; } } } long long cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ! vis [ i ] ) { ++ cnt ; dfs ( i ) ; } } cout << cnt - ok2 << ' \n ' ; return 0 ; }
TAB1 s = string ; TAB1 i , ans = long long int ; TAB1 read s ; TAB1 ans = 0 ; TAB1 for i = 0 to length of s exclusive ; TAB2 if s [ i ] is ' 0 ' ; TAB3 ans = i ; TAB3 break ; TAB1 for i = 0 to length of s exclusive ; TAB2 if i ! = ans print s [ i ] ; TAB1 print newline ;	int main ( ) { string s ; long long int i , ans ; cin >> s ; ans = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' 0 ' ) { ans = i ; break ; } } for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( i != ans ) cout << s [ i ] ; } cout << endl ; }
TAB1 create string s ; TAB1 create int n , set c to 0 ; TAB1 read n and s ; TAB1 while n > 0 ; TAB2 if s [ n - 1 ] = > ; TAB3 increment c ; TAB2 else ; TAB3 break ; TAB2 decrement n ; TAB1 set n to length of s ; TAB1 i = 0 ; TAB1 while i < n ; TAB2 if s [ i ] = < ; TAB3 increment c ; TAB2 else ; TAB3 break ; TAB2 add 1 to i ; TAB1 print c ;	int main ( ) { string s ; int n , c = 0 ; cin >> n >> s ; while ( n > 0 ) { if ( s [ n - 1 ] == ' > ' ) c ++ ; else break ; n -- ; } n = s . length ( ) ; int i = 0 ; while ( i < n ) { if ( s [ i ] == ' < ' ) c ++ ; else break ; i ++ ; } cout << c << endl ; return 0 ; }
TAB1 let arr be a string ; TAB1 read arr ; TAB1 let t be a integer with t = arr . find ( 0 ) ; TAB1 if t is equal to - 1 ; TAB2 delete ( length of arr ) - 1 from arr ; TAB1 else do the following ; TAB2 delete t , 1 from arr ; TAB1 print arr and newline ;	int main ( ) { string arr ; cin >> arr ; int t = arr . find ( ' 0 ' ) ; if ( t == - 1 ) { arr . erase ( arr . size ( ) - 1 ) ; } else { arr . erase ( t , 1 ) ; } cout << arr << endl ; }
TAB0 in int function gcd taking a , b = int ; TAB1 is b = 0 ? then return gdc of b and a mod b , else return a ; TAB0 in int function lcm taking a , b = int ; TAB1 return a / b * gdc of a and b ; TAB0 in long long function powmod taking a , b , MOD = long long ; TAB1 ans = 1 = long long ; TAB1 while b isn ' t 0 ; TAB2 if b is even then set ans = ans * a % MOD ; TAB2 set a to a ^ 2 % MOD ; TAB2 divide b by 2 ; TAB1 return ans ; TAB0 let p be an int vector of size 200001 ; TAB0 let ma be an int and ma be an int array of length 200001 ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 mm = int ; TAB2 read mm ; TAB2 mid = 0 = int ; TAB2 for j = 1 to mm inclusive ; TAB3 t = int ; TAB3 read t ; TAB3 push back t into p at i ; TAB3 set ma to the maxmimum betwwen ma and t ; TAB3 set mid to the max of mid and t ; TAB2 set m at i = mid ; TAB1 sum = 0 = long long ; TAB1 for i = 1 to n inclusive ; TAB2 if m at i = ma then go to next iteration ; TAB2 increment sum by 1ll * ( ma - m [ i ] ) * ( size of p at i ) to int ; TAB1 print sum ;	int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } int lcm ( int a , int b ) { return a / gcd ( a , b ) * b ; } long long powmod ( long long a , long long b , long long MOD ) { long long ans = 1 ; while ( b ) { if ( b % 2 ) ans = ans * a % MOD ; a = a * a % MOD ; b /= 2 ; } return ans ; } vector < int > p [ 200001 ] ; int m [ 200001 ] , ma ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { int mm ; cin >> mm ; int mid = 0 ; for ( int j = 1 ; j <= mm ; j ++ ) { int t ; cin >> t ; p [ i ] . push_back ( t ) ; ma = max ( ma , t ) ; mid = max ( mid , t ) ; } m [ i ] = mid ; } long long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( m [ i ] == ma ) continue ; sum += 1ll * ( ma - m [ i ] ) * ( int ) ( p [ i ] . size ( ) ) ; } cout << sum << endl ; return 0 ; }
TAB0 create constant integer oo = ( int ) 1e9 ; TAB0 make const double PI = 2 * acos ( 0 . 0 ; TAB0 create const double eps = 1e - 9 ; TAB0 declare fix taking in string s and returning string ; TAB1 create string ret = " 99999999999 " ; TAB1 for i = 0 to 4 exclusive ; TAB2 make string tmp = s . substr ( i , 4 - i ) + s . substr ( 0 , i ) ; TAB2 set ret to min of tmp and ret ; TAB1 return ret ; TAB1 make integer n ; TAB1 make char c ; TAB1 read n ; TAB1 make map dic from strings to ints ; TAB1 create bool flag = false ; TAB1 make integer mx = 0 ; TAB1 for whatever = 0 to n exclusive ; TAB2 make string s = " " ; TAB2 for i = 0 to 4 exclusive ; TAB3 read c ; TAB3 set s to s + c ; TAB2 make char t = s [ 2 ] ; TAB2 set s [ 2 ] to s [ 3 ] ; TAB2 set s [ 3 ] to t ; TAB2 set s to fix ( s ) ; TAB2 if dic . find ( s ) is equal to dic . end ( ) , set dic [ s ] to 0 ; TAB2 increment dic [ s ] ; TAB2 if whatever is not equal to n - 1 , read c and c ; TAB1 print dic . size ( ) ;	const int oo = ( int ) 1e9 ; const double PI = 2 * acos ( 0.0 ) ; const double eps = 1e-9 ; string fix ( string s ) { string ret = " 99999999999 " ; for ( int i = 0 ; i < ( int ) ( 4 ) ; i ++ ) { string tmp = s . substr ( i , 4 - i ) + s . substr ( 0 , i ) ; ret = min ( tmp , ret ) ; } return ret ; } int main ( ) { int n ; char c ; cin >> n ; map < string , int > dic ; bool flag = false ; int mx = 0 ; for ( int whatever = 0 ; whatever < ( int ) ( n ) ; whatever ++ ) { string s = "  " ; for ( int i = 0 ; i < ( int ) ( 4 ) ; i ++ ) { cin >> c ; s += c ; } char t = s [ 2 ] ; s [ 2 ] = s [ 3 ] ; s [ 3 ] = t ; s = fix ( s ) ; if ( dic . find ( s ) == dic . end ( ) ) dic [ s ] = 0 ; dic [ s ] ++ ; if ( whatever != n - 1 ) cin >> c >> c ; } cout << dic . size ( ) << endl ; return 0 ; }
TAB1 long double integer n ; TAB1 read n ; TAB1 if n is less than or equal to 127 then do the following ; TAB2 output byte ; TAB1 else if n is less than or equal to 32767 then do the following ; TAB2 output short ; TAB1 else if n is less than or equal to 2147483647 then do the following ; TAB2 output int ; TAB1 else if n is less than or equal to 9223372036854775807 then do ; TAB2 output long ; TAB1 else ; TAB2 output BigInteger ;	int main ( ) { long double n ; cin >> n ; if ( n <= 127 ) { cout << " byte " << endl ; } else if ( n <= 32767 ) { cout << " short " << endl ; } else if ( n <= 2147483647 ) { cout << " int " << endl ; } else if ( n <= 9223372036854775807 ) { cout << " long " << endl ; } else { cout << " BigInteger " << endl ; } return 0 ; }
TAB0 Max_N = 200005 ; TAB1 n = int ; TAB1 s = string ; TAB1 read n , s ; TAB1 ant = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is not ' < ' break ; TAB2 increment ant ; TAB1 for i = n - 1 down to 0 inclusive ; TAB2 if s [ i ] is not ' > ' break ; TAB2 increment ant ; TAB1 print ant ;	const int Max_N = 2 * 1e5 + 5 ; int main ( ) { int n ; string s ; cin >> n >> s ; int ant = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' < ' ) break ; ant ++ ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' > ' ) break ; ant ++ ; } cout << ant << endl ; return 0 ; }
TAB1 remain , i , n , x = int with remain = 0 and a , b = int array of size 200001 and all values set to 0 each ; TAB1 loop while reading n then x ; TAB2 for i = 1 to n inclusive read a [ i ] ; TAB2 for i = 1 to n inclusive ; TAB3 set b [ i ] to ( a [ i ] + remain ) / x ; TAB3 set remain to ( a [ i ] + remain ) mod x ; TAB2 for i = 1 to n inclusive ; TAB3 if i < n ; TAB4 print b [ i ] and " " ; TAB3 else ; TAB4 print b [ i ] ;	int main ( ) { int remain = 0 , i , n , x , a [ 200001 ] = { 0 } , b [ 200001 ] = { 0 } ; while ( cin >> n >> x ) { for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( i = 1 ; i <= n ; i ++ ) { b [ i ] = ( a [ i ] + remain ) / x ; remain = ( a [ i ] + remain ) % x ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i < n ) cout << b [ i ] << "   " ; else cout << b [ i ] << endl ; } } return 0 ; }
TAB0 declare string variable s ; TAB0 declare integer m ; TAB1 read s ; TAB1 declare integer variables l and r = 0 ; TAB1 for integer i = 0 to length of s exclusive ; TAB2 if s [ i ] = ' ( ' ; TAB3 increment l and r ; TAB2 else ; TAB3 decrement l ; TAB3 if r is greater than 0 , decrement r ; TAB3 if l is less than 0 ; TAB4 print - 1 ; TAB3 if s [ i ] is equal to ' # ' , assign 0 to r and increment m by one ; TAB1 if r ! = 0 ; TAB2 print - 1 ; TAB1 for integer i = 0 to m - 1 exclusive , print 1 ; TAB1 print l + 1 ;	string s ; int m ; int main ( ) { cin >> s ; int l = 0 , r = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { l ++ , r ++ ; } else { l -- ; if ( r > 0 ) r -- ; if ( l < 0 ) { cout << - 1 << endl ; return 0 ; } if ( s [ i ] == ' # ' ) { r = 0 , m ++ ; } } } if ( r != 0 ) { cout << - 1 << endl ; return 0 ; } for ( int i = 0 ; i < m - 1 ; i ++ ) { cout << 1 << endl ; } cout << l + 1 << endl ; }
TAB1 a , i , j , ans , n and sum are long longs with ans and sum = 0 ; arr with size 4100 and find with 50000 elements are long long arrays ; TAB1 s is a new string variable ; TAB1 read input to a and s ; TAB1 assign length of s to n ; TAB1 for i = 0 to n exclusive , assign s [ i ] - ' 0 ' to arr [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 change sum to 0 ; TAB2 in a for loop , change j from i to n exclusive ; TAB3 add arr [ j ] to sum ; TAB3 increment find [ sum ] ; TAB1 if a is equal to 0 ; TAB2 set ans to n * ( n + 1 ) * find [ 0 ] - find [ 0 ] * find [ 0 ] ; TAB1 else ; TAB2 for i from 0 to n exclusive ; TAB3 change sum to 0 ; TAB3 for j from i to n exclusive incrementing j ; TAB4 change sum to sum + arr [ j ] ; TAB4 if sum ! = 0 , a modulo sum = 0 and a / sum < = n * 9 , add find [ a / sum ] to ans ; TAB1 print ans to the standard output ;	int main ( ) { long long a , i , j , ans = 0 , n , arr [ 4100 ] , find [ 50000 ] = { } , sum = 0 ; string s ; cin >> a >> s ; n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = s [ i ] - ' 0 ' ; for ( i = 0 ; i < n ; i ++ ) { sum = 0 ; for ( j = i ; j < n ; j ++ ) { sum += arr [ j ] ; find [ sum ] ++ ; } } if ( a == 0 ) ans = n * ( n + 1 ) * find [ 0 ] - find [ 0 ] * find [ 0 ] ; else { for ( i = 0 ; i < n ; i ++ ) { sum = 0 ; for ( j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( sum != 0 && a % sum == 0 && a / sum <= n * 9 ) ans += find [ a / sum ] ; } } } cout << ans << endl ; return 0 ; }
TAB0 e is a new 2d array of integers 5010 by 5010 ; TAB1 declare new strings s and t ; TAB1 cnt and sum are long longs with sum = 0 ; TAB1 read user input to s and t ; TAB1 start for loop from i = 0 to length of s exclusive , changing e [ 0 ] [ i + 1 ] to s [ i ] - ' a ' on each loop ; TAB1 in a loop , change i from 0 to length of t exclusive and assign t [ i ] - ' a ' to e [ i + 1 ] [ 0 ] on each iteration ; TAB1 for integer r = 1 to length of t inclusive ; TAB2 if e [ 0 ] [ 1 ] = e [ r ] [ 0 ] ; TAB3 increment e [ r ] [ 1 ] ; TAB3 increment sum by one ; TAB1 start for loop from c = 2 to length of s inclusive ; TAB2 set cnt to 0 ; TAB2 in a for loop , change r from 1 to length of t inclusive ; TAB3 if e [ 0 ] [ c ] = e [ r ] [ 0 ] ; TAB4 change the value of e [ r ] [ c ] to cnt + 1 ; TAB4 set sum to ( sum + e [ r ] [ c ] ) % 1000000007LL ; TAB3 set cnt to ( cnt + e [ r ] [ c - 1 ] ) % 1000000007LL ; TAB1 print sum to the standard output ;	int e [ 5010 ] [ 5010 ] = { } ; int main ( ) { string s , t ; long long cnt , sum = 0 ; cin >> s >> t ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) e [ 0 ] [ i + 1 ] = s [ i ] - ' a ' ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) e [ i + 1 ] [ 0 ] = t [ i ] - ' a ' ; for ( int r = 1 ; r <= t . length ( ) ; r ++ ) if ( e [ 0 ] [ 1 ] == e [ r ] [ 0 ] ) { e [ r ] [ 1 ] ++ ; sum ++ ; } for ( int c = 2 ; c <= s . length ( ) ; c ++ ) { cnt = 0 ; for ( int r = 1 ; r <= t . length ( ) ; r ++ ) { if ( e [ 0 ] [ c ] == e [ r ] [ 0 ] ) { e [ r ] [ c ] = cnt + 1 ; sum = ( sum + e [ r ] [ c ] ) % 1000000007LL ; } cnt = ( cnt + e [ r ] [ c - 1 ] ) % 1000000007LL ; } } cout << sum << endl ; }
TAB0 long long integer as , m , a , d , array t of size 100005 , pt , pa , da , ans , sa , sl ; TAB0 create readf function ; TAB1 read n , m , a , d ; TAB1 for i = ( 1 ) to less than or equal to ( m ) do the following ; TAB1 set m to unique ( t + 1 , t + m + 1 ) - t - 1 ; TAB0 create function solve ; TAB1 set pt to pa ; TAB1 set da to d / a + 1 ; TAB1 set ans to 0 ; TAB1 if pt is less than or equal to m then do the following ; TAB2 set sa to minimum of ( t [ pt ] / a , n ) - pa + 1 ; TAB2 if sa is greater than 0 then do the following ; TAB3 set sl to ( sa + da - 1 ) / da ; TAB3 ans equals ans plus sl ; TAB3 pa equals pa plus ( sl - 1 ) * da ; TAB3 if t [ pt ] is less than or equal to pa * a + d and pt is less or equal to m then add one to pt ; TAB3 set pa to ( pa * a + d ) / a + 1 ; TAB2 else ; TAB3 add one to ans ; TAB3 integer as tmp = pt ; TAB3 if t [ pt ] is less than or equal to t [ tmp ] + d and pt is less or equal to m add one to pt ; TAB3 set pa to t [ tmp ] + d ) / a + 1 ; TAB1 if pa is less than or equal to n then do the following ans + = ( n - pa + 1 + da - 1 ; TAB1 output ans ; TAB1 run readf function ; TAB1 run solve function ;	long long n , m , a , d , t [ 100005 ] , pt , pa , da , ans , sa , sl ; void readf ( ) { cin >> n >> m >> a >> d ; for ( int i = ( 1 ) ; i <= ( m ) ; ++ i ) cin >> t [ i ] ; m = unique ( t + 1 , t + m + 1 ) - t - 1 ; } void solve ( ) { pt = pa = 1 ; da = d / a + 1 ; ans = 0 ; while ( pt <= m ) { sa = min ( t [ pt ] / a , n ) - pa + 1 ; if ( sa > 0 ) { sl = ( sa + da - 1 ) / da ; ans += sl ; pa += ( sl - 1 ) * da ; while ( t [ pt ] <= pa * a + d && pt <= m ) pt ++ ; pa = ( pa * a + d ) / a + 1 ; } else { ans ++ ; int tmp = pt ; while ( t [ pt ] <= t [ tmp ] + d && pt <= m ) pt ++ ; pa = ( t [ tmp ] + d ) / a + 1 ; } } if ( pa <= n ) ans += ( n - pa + 1 + da - 1 ) / da ; cout << ans << ' \n ' ; } int main ( ) { readf ( ) ; solve ( ) ; }
TAB1 let t1 , t2 , x1 , x2 , t0 , Min , ans1 , ans2 , j be long integers with Min = 0 , ans1 = 0 , ans2 = 0 ; TAB1 let Max , aa be double values with Max = 1000 ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 if t1 is equal to t2 and t2 is equal to t0 ; TAB2 print x1 and space and x2 and newline ; TAB1 else if t1 is equal to t0 ; TAB2 print x1 and space and 0 and newline ; TAB1 else if t2 is equal to t0 ; TAB2 print 0 and space and x2 and newline ; TAB1 else do the following ; TAB2 Max is equal to t2 - t0 ; TAB2 Min is equal to x2 ; TAB2 ans1 is equal to 0 ; TAB2 ans2 is equal to x2 ; TAB2 for i = 1 to x1 inclusive ; TAB3 j is equal to i * ( t1 - t0 ) / ( t0 - t2 ) ; TAB3 if i * ( t0 - t1 ) modulo ( t2 - t0 ) is not equal to 0 , increment j by 1 ; TAB3 aa is equal to 1 . 0 * ( t1 * i + t2 * j ) / ( i + j ) - t0 ; TAB3 if j > = 0 and j < = x2 and aa is less than Max ; TAB4 Max is equal to aa ; TAB4 Min is equal to i + j ; TAB4 ans1 is equal to i ; TAB4 ans2 is equal to j ; TAB3 if j > = 0 and j < = x2 and aa is equal to Max and ( i + j ) is greater than Min ; TAB4 Max is equal to aa ; TAB4 Min is equal to i + j ; TAB4 ans1 is equal to i ; TAB4 ans2 is equal to j ; TAB2 print ans1 and space and ans2 and newline ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , Min = 0 , ans1 = 0 , ans2 = 0 , j ; double Max = 1000 , aa ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; if ( t1 == t2 && t2 == t0 ) { cout << x1 << "   " << x2 << endl ; } else if ( t1 == t0 ) { cout << x1 << "   " << 0 << endl ; } else if ( t2 == t0 ) { cout << 0 << "   " << x2 << endl ; } else { Max = t2 - t0 ; Min = x2 ; ans1 = 0 ; ans2 = x2 ; for ( int i = 1 ; i <= x1 ; i ++ ) { j = i * ( t1 - t0 ) / ( t0 - t2 ) ; if ( ( i * ( t0 - t1 ) ) % ( t2 - t0 ) != 0 ) j ++ ; aa = ( 1.0 ) * ( t1 * i + t2 * j ) / ( i + j ) - t0 ; if ( j >= 0 && j <= x2 && aa < Max ) { Max = aa ; Min = i + j ; ans1 = i ; ans2 = j ; } if ( j >= 0 && j <= x2 && aa == Max && ( i + j ) > Min ) { Max = aa ; Min = i + j ; ans1 = i ; ans2 = j ; } } cout << ans1 << "   " << ans2 << endl ; } return 0 ; }
TAB0 declare integer array a size 150000 ; TAB1 declare integer n ; TAB1 while read n ; TAB2 for i = 0 to n exclusive , read a [ i ] ; TAB2 sort from a to a + n ; TAB2 for i = 0 to n exclusive ; TAB3 if i is 0 ; TAB4 print a [ i ] ; TAB3 else ; TAB4 print ' ' , a [ i ] ; TAB2 print newline ;	int a [ 150000 ] ; int main ( ) { int n ; while ( cin >> n ) { for ( int i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; sort ( a , a + n ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 ) cout << a [ i ] ; else cout << '   ' << a [ i ] ; } cout << endl ; } return 0 ; }
TAB0 a = vector integer array of size 200005 ; TAB0 maxval = vector integer array of size 200005 ; TAB1 n , m , x , ultimate = integers with ultimate = 0 ; TAB1 read n ; TAB1 for i = 1 to n ; TAB2 read m ; TAB2 for j = 0 to m exclusive ; TAB3 read x ; TAB3 append x in a [ i ] ; TAB3 maxval [ i ] = max of maxval [ i ] and x ; TAB2 ultimate = max of maxval [ i ] and ultimate ; TAB1 ans = long long with ans = 0 ; TAB1 for i = 1 to n ; TAB2 if ( maxval [ i ] < ultimate ) , { ans = ans + ( cast to long long ) a [ i ] . size ( ) * ( cast to long long ) ( ultimate - maxval [ i ] ) ; TAB1 print ans ;	vector < int > a [ 200005 ] ; int maxval [ 200005 ] ; int main ( ) { int n , m , x , ultimate = 0 ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> m ; for ( int j = 0 ; j < m ; j ++ ) { cin >> x ; a [ i ] . push_back ( x ) ; maxval [ i ] = max ( maxval [ i ] , x ) ; } ultimate = max ( maxval [ i ] , ultimate ) ; } long long ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( maxval [ i ] < ultimate ) { ans += ( long long ) a [ i ] . size ( ) * ( long long ) ( ultimate - maxval [ i ] ) ; } } cout << ans << endl ; return 0 ; }
TAB0 declare string s ; TAB0 new array of integers zlicz with size 3 ; TAB0 character variable with name wz with value ' a ' ; TAB1 read s from the input ; TAB1 for integer i = 0 to length of s exclusive incrementing i ; TAB2 if s [ i ] ! = wz ; TAB3 if ( s [ i ] - wz = 1 ) and ( wz ! = ' c ' ) ; TAB4 set wz to s [ i ] ; TAB4 assign 1 to zlicz [ wz - ' a ' ] ; TAB3 else ; TAB4 print " NO " ; TAB2 else ; TAB3 increment zlicz [ wz - ' a ' ] by one ; TAB1 if ( zlicz [ 0 ] = 0 ) or ( zlicz [ 1 ] = 0 ) ; TAB2 print " NO " to the standard output ; TAB1 if ( zlicz [ 2 ] = zlicz [ 0 ] ) or ( zlicz [ 2 ] = zlicz [ 1 ] ) ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	string s ; int zlicz [ 3 ] ; char wz = ' a ' ; int main ( ) { cin >> s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != wz ) { if ( ( s [ i ] - wz == 1 ) && ( wz != ' c ' ) ) { wz = s [ i ] ; zlicz [ wz - ' a ' ] = 1 ; } else { cout << " NO " << endl ; return 0 ; } } else zlicz [ wz - ' a ' ] ++ ; } if ( ( zlicz [ 0 ] == 0 ) || ( zlicz [ 1 ] == 0 ) ) { cout << " NO " << endl ; return 0 ; } if ( ( zlicz [ 2 ] == zlicz [ 0 ] ) || ( zlicz [ 2 ] == zlicz [ 1 ] ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 let a be an vector integer array of size n ; TAB1 read n values into array a ; TAB1 let res be an int with res = 0 ; TAB1 create integer head = 0 ; TAB1 for i = 1 to n exclusive ; TAB2 if a [ i ] is equal to a [ i - 1 ] ; TAB3 create integer tar = i - 1 ; TAB3 set res = max of res and tar - head ; TAB3 create integer len = ( tar - head ) / 2 ; TAB3 for j = head to head + len inclusive set a [ j ] = a [ head ] ; TAB3 for j = head + len + 1 to i exclusive assign a [ i ] to a [ j ] ; TAB3 set head to i ; TAB1 create integer tar = n - 1 ; TAB1 set res to max of res and tar - head ; TAB1 create integer len = ( tar - head ) / 2 ; TAB1 for j = head to head + len inclusive set a [ j ] = a [ head ] ; TAB1 for j = head + len + 1 to n exclusive set a [ j ] = a [ n - 1 ] ; TAB1 print res / 2 and new line ; TAB1 for i = 0 to n exclusive print a [ i ] and new line if i + 1 is equal to n else print a [ i ] and " " ;	int main ( ) { int n ; cin >> n ; vector < int > a ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int res = 0 ; int head = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { int tar = i - 1 ; res = max ( res , tar - head ) ; int len = ( tar - head ) / 2 ; for ( int j = head ; j <= head + len ; j ++ ) { a [ j ] = a [ head ] ; } for ( int j = head + len + 1 ; j < i ; j ++ ) { a [ j ] = a [ i ] ; } head = i ; } } int tar = n - 1 ; res = max ( res , tar - head ) ; int len = ( tar - head ) / 2 ; for ( int j = head ; j <= head + len ; j ++ ) { a [ j ] = a [ head ] ; } for ( int j = head + len + 1 ; j < n ; j ++ ) { a [ j ] = a [ n - 1 ] ; } cout << res / 2 << endl ; for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << ( i + 1 == n ? " \n " : "   " ) ; } return 0 ; }
TAB0 create long long variables m , h1 , a1 , x1 , h2 , a2 , x2 , y2 , y , p1 , p2 , t1 and t2 ; TAB1 read input to m , h1 , a1 , x1 , y , h2 , a2 , x2 and y2 ; TAB1 for i from 1 to 1e7 inclusive ; TAB2 declare long long ans1 = ( ( ( h1 * x1 * 1LL ) + y ) % m ) ; TAB2 declare long long ans2 = ( ( ( h2 * x2 * 1LL ) + y2 ) % m ) ; TAB2 change h1 to ans1 and h2 to ans2 ; TAB2 if a1 is equal to ans1 ; TAB3 if p1 = 0 ; TAB4 assign i to p1 ; TAB3 else if t1 = 0 ; TAB4 change t1 to i - p1 ; TAB2 if a2 is equal to ans2 ; TAB3 if p2 is false ; TAB4 change p2 to i ; TAB3 else if t2 = 0 ; TAB4 change t2 to i - p2 ; TAB1 if p1 is false or p2 is false , return ! ( cout < < - 1 < < endl ) ; TAB1 for i from 1 to 1e7 inclusive ; TAB2 if p1 is equal to p2 , return ! ( cout < < p1 < < endl ) ; TAB2 if p1 is less than p2 ; TAB3 increase p1 by t1 ; TAB2 else ; TAB3 add t2 to p2 ; TAB1 print - 1 ;	long long m , h1 , a1 , x1 , h2 , a2 , x2 , y2 , y , p1 , p2 , t1 , t2 ; int main ( ) { cin >> m >> h1 >> a1 >> x1 >> y >> h2 >> a2 >> x2 >> y2 ; for ( int i = 1 ; i <= 1e7 ; i ++ ) { long long ans1 = ( ( ( h1 * x1 * 1LL ) + y ) % m ) ; long long ans2 = ( ( ( h2 * x2 * 1LL ) + y2 ) % m ) ; h1 = ans1 , h2 = ans2 ; if ( a1 == ans1 ) { if ( ! p1 ) p1 = i ; else if ( ! t1 ) t1 = i - p1 ; } if ( a2 == ans2 ) { if ( ! p2 ) p2 = i ; else if ( ! t2 ) t2 = i - p2 ; } } if ( ! p1 || ! p2 ) return ! ( cout << - 1 << endl ) ; for ( int i = 1 ; i <= 1e7 ; i ++ ) { if ( p1 == p2 ) return ! ( cout << p1 << endl ) ; if ( p1 < p2 ) p1 += t1 ; else p2 += t2 ; } cout << - 1 << endl ; return 0 ; }
TAB1 declare a 64 bit integer named a ; TAB1 read in a ; TAB1 declare a string named s ; TAB1 read in s ; TAB1 declare a 64 bit integer named n and set the value to the length of string s ; TAB1 declare a 64 bit integer array named cumm of size n + 1 ; TAB1 declare a 64 bit integer array named ans with a value of 0 ; TAB1 position 0 of cumm is equal to 0 ; TAB1 declare a 64 bit integer named count0 with a value of 0 ; TAB1 loop through the code n times ; TAB2 if position i of s is equal to 0 , increment count0 ; TAB2 position i of cumm is equal to the sum of position i - 1 of cumm and the decimal number of the char in s [ i - 1 ] - 48 ; TAB1 let value be a map from 64 bit integer to 64 bit integer ; TAB1 iterate for n times ; TAB2 iterate for n times , and increment the value in position cumm [ j ] - cumm [ i ] of value ; TAB1 if a is equal to 0 ; TAB2 print ( n * ( n + 1 ) ) * value [ 0 ] - value [ 0 ] * value [ 0 ] and a new line ; TAB2 terminate the program ; TAB1 iterate for n times ; TAB2 iterate for n times ; TAB3 if cumm [ j ] - cumm [ i ] is equal to 0 execute next iteration of code ; TAB3 if a % ( cumm [ j ] - cumm [ i ] ) is equal to 0 , then ans is equal to ans + value [ a / ( cumm [ j ] - cumm [ i ] ) ] ; TAB1 print ans and a new line ;	int main ( ) { long long int a ; cin >> a ; string s ; cin >> s ; long long int n = s . length ( ) ; long long int cumm [ n + 1 ] ; long long int ans = 0 ; cumm [ 0 ] = 0 ; long long int count0 = 0 ; for ( long long int i = 1 ; i < n + 1 ; i ++ ) { if ( s [ i ] == ' 0 ' ) count0 ++ ; cumm [ i ] = cumm [ i - 1 ] + ( s [ i - 1 ] - ' 0 ' ) ; } map < long long int , long long int > value ; for ( long long int i = 0 ; i < n ; i ++ ) { for ( long long int j = i + 1 ; j < n + 1 ; j ++ ) { value [ cumm [ j ] - cumm [ i ] ] ++ ; } } if ( a == 0 ) { cout << ( n * ( n + 1 ) ) * value [ 0 ] - value [ 0 ] * value [ 0 ] << ' \n ' ; exit ( 0 ) ; } for ( long long int i = 0 ; i < n ; i ++ ) { for ( long long int j = i + 1 ; j < n + 1 ; j ++ ) { if ( ( cumm [ j ] - cumm [ i ] ) == 0 ) continue ; if ( a % ( cumm [ j ] - cumm [ i ] ) == 0 ) ans = ans + value [ a / ( cumm [ j ] - cumm [ i ] ) ] ; } } cout << ans << ' \n ' ; }
TAB1 create integers x , y ; TAB1 read x read y ; TAB1 create integers tx , ty ; TAB1 set tx to absolute value of x , set ty to absolute value of y ; TAB1 create integer mx with mx = maximum of ( tx and ty ) - 1 ; TAB1 if ( x is 0 and y is 0 ) or ( x is 1 and y is 0 ) ; TAB2 print 0 print newline ; TAB1 create integer ans with ans = 0 ; TAB1 if x is greater than or equal to 0 and y is greater than or equal to 0 ; TAB2 if tx is greater than or equal to ty ; TAB3 set ans to ( mx * 4 ) + 1 ; TAB2 else ; TAB3 set ans to mx * 4 + 2 ; TAB1 else if x is less than 0 and y is greater than or equal to 0 ; TAB2 if tx is greater than ty ; TAB3 set ans to mx * 4 + 3 ; TAB2 else ; TAB3 set ans to mx * 4 + 2 ; TAB1 else if x is less than or equal to 0 and y is less than or equal to 0 ; TAB2 if tx is greater than or equal to ty ; TAB3 set ans to mx * 4 + 3 ; TAB2 else ; TAB3 set ans to mx * 4 + 4 ; TAB1 else if x is greater than or equal to 0 and y is less than 0 ; TAB2 if ty is greater than or equal to tx ; TAB3 set ans to mx * 4 + 4 ; TAB2 else ; TAB3 set ans to mx * 4 ; TAB2 if ty is less than or equal to ( tx - 2 ) , increment ans ; TAB1 print ans print newline ;	int main ( ) { int x , y ; cin >> x >> y ; int tx , ty ; tx = abs ( x ) , ty = abs ( y ) ; int mx = max ( tx , ty ) - 1 ; if ( ( x == 0 && y == 0 ) || ( x == 1 && y == 0 ) ) { cout << 0 << endl ; return 0 ; } int ans = 0 ; if ( x >= 0 && y >= 0 ) { if ( tx >= ty ) ans = ( mx * 4 ) + 1 ; else ans = mx * 4 + 2 ; } else if ( x < 0 && y >= 0 ) { if ( tx > ty ) ans = mx * 4 + 3 ; else ans = mx * 4 + 2 ; } else if ( x <= 0 && y <= 0 ) { if ( tx >= ty ) ans = mx * 4 + 3 ; else ans = mx * 4 + 4 ; } else if ( x >= 0 && y < 0 ) { if ( ty >= tx ) ans = mx * 4 + 4 ; else ans = mx * 4 ; if ( ty <= ( tx - 2 ) ) ans ++ ; } cout << ans << endl ; return 0 ; }
TAB0 a = array of unsigned long long size 2000000 ; TAB0 b = array of unsigned long long size 2000000 ; TAB0 n = integer ; TAB0 declare boolean function judge with integer n as an argument ; TAB1 for i = 0 to n exclusive ; TAB2 if a [ i ] is a [ i + 1 ] return true ; TAB1 return false ; TAB1 while ( read n ) is true do the following ; TAB2 set sizeof ( a ) bytes starting at a to 0 ; TAB2 for i = 0 to n exclusive do the following ; TAB3 read a [ i ] ; TAB3 inceement b [ a [ i ] ] ; TAB2 call sort on a and a + n ; TAB2 set ans = integer value 0 ; TAB2 for i = 1 to 2000000 exclusive do the following ; TAB3 set b [ i ] = b [ i - 1 ] / 2 ; TAB3 set b [ i - 1 ] = b [ i - 1 ] modulo 2 ; TAB3 set ans = ans + b [ i - 1 ] ; TAB2 print ans ;	unsigned long long a [ 2000000 ] ; unsigned long long b [ 2000000 ] ; int n ; bool judge ( int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) return true ; } return false ; } int main ( ) { while ( cin >> n ) { memset ( a , 0 , sizeof ( a ) ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; b [ a [ i ] ] ++ ; } sort ( a , a + n ) ; int ans = 0 ; for ( int i = 1 ; i < 2000000 ; ++ i ) { b [ i ] += ( b [ i - 1 ] / 2 ) ; b [ i - 1 ] %= 2 ; ans += b [ i - 1 ] ; } cout << ans << endl ; } }
TAB0 let solve be a void function ; TAB1 let n , i , j , d be long integers ; TAB1 read n , d ; TAB1 arr = array of long integers of length n ; TAB1 for long integer i = 0 to n exclusive , read arr [ i ] ; TAB1 if n is less than 3 ; TAB2 print 0 and newline ; TAB2 return value ; TAB1 let l , r be long integers with l = 0 , r = 2 ; TAB1 let sum be a long integer with sum = 0 ; TAB1 while l is less than n - 2 and r is less than n ; TAB2 if arr [ r ] - arr [ l ] < = d ; TAB3 increment sum by ( r - l - 1 ) * ( r - l ) / 2 ; TAB3 increment r by 1 ; TAB2 else do the following ; TAB3 increment l by 1 ; TAB2 if r - l is equal to 1 , increment r by 1 ; TAB1 print sum and newline ; TAB1 let t be a long integer with t = 1 ; TAB1 while t is decremented by 1 , call solve function ;	void solve ( ) { long long n , i , j , d ; cin >> n >> d ; long long arr [ n ] ; for ( long long i = 0 ; i < n ; ++ i ) { cin >> arr [ i ] ; } if ( n < 3 ) { cout << 0 << ' \n ' ; return ; } long long l = 0 , r = 2 ; long long sum = 0 ; while ( l < n - 2 && r < n ) { if ( arr [ r ] - arr [ l ] <= d ) { sum += ( r - l - 1 ) * ( r - l ) / 2 ; r ++ ; } else { l ++ ; } if ( r - l == 1 ) r ++ ; } cout << sum << ' \n ' ; } int main ( ) { long long t = 1 ; while ( t -- ) { solve ( ) ; } return 0 ; }
TAB0 tab = long long array of size 100001 ; TAB1 T = int ; TAB1 loop while reading T ; TAB2 set all values of tab to 0 ; TAB2 num = int with num = 0 ; TAB2 p = int with p = 1 ; TAB2 for i = 1 to T inclusive read tab [ i ] ; TAB2 sort tab from index 1 to T + 1 ; TAB2 for i = 1 to T - 1 inclusive ; TAB3 loop while p < = T ; TAB4 if tab [ p ] > tab [ i ] ; TAB5 increment p ; TAB5 increment num ; TAB5 break ; TAB4 else ; TAB5 increment p ; TAB2 print num ;	long long tab [ 100001 ] ; int main ( ) { int T ; while ( cin >> T ) { memset ( tab , 0 , sizeof ( tab ) ) ; int num = 0 ; int p = 1 ; for ( int i = 1 ; i <= T ; i ++ ) cin >> tab [ i ] ; sort ( tab + 1 , tab + T + 1 ) ; for ( int i = 1 ; i <= T - 1 ; i ++ ) { while ( p <= T ) { if ( tab [ p ] > tab [ i ] ) { p ++ ; num ++ ; break ; } else p ++ ; } } cout << num << endl ; } }
TAB0 declare new array of long longs a with size 100001 ; TAB0 s is a new array of long longs with 100000 elements ; TAB1 create long longs n , i , max , min , mm , k and t ; TAB1 read n and keep looping ; TAB2 read n items from the input to a , starting from the index 1 ; TAB2 start for loop from i = 1 to n - 1 inclusive incrementing i ; TAB3 set s [ i ] to abs ( a [ i ] - a [ i + 1 ] ) ; TAB3 if i is odd , change the value of s [ i ] to 0 - s [ i ] ; TAB2 assign the new value = s [ 1 ] to max ; TAB2 assign the new value = s [ 1 ] to min ; TAB2 assign the new value = 0 - min to mm ; TAB2 start for loop from k = 2 to n - 1 inclusive ; TAB3 if max is less than 0 ; TAB4 change max to s [ k ] ; TAB3 else ; TAB4 assign the new value = max + s [ k ] to max ; TAB3 if min is greater than 0 ; TAB4 assign the new value = s [ k ] to min ; TAB3 else ; TAB4 set min to min + s [ k ] ; TAB3 if k is even and max > mm , change mm to max ; TAB3 if k is odd and 0 - min > mm , change mm to 0 - min ; TAB2 print mm ;	long long a [ 100001 ] ; long long s [ 100000 ] ; int main ( ) { long long n , i , max , min , mm , k , t ; while ( cin >> n ) { for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( i = 1 ; i <= n - 1 ; i ++ ) { s [ i ] = abs ( a [ i ] - a [ i + 1 ] ) ; if ( i % 2 == 1 ) s [ i ] = 0 - s [ i ] ; } max = s [ 1 ] ; min = s [ 1 ] ; mm = 0 - min ; for ( k = 2 ; k <= n - 1 ; k ++ ) { if ( max < 0 ) max = s [ k ] ; else max = max + s [ k ] ; if ( min > 0 ) min = s [ k ] ; else min = min + s [ k ] ; if ( k % 2 == 0 && max > mm ) mm = max ; if ( k % 2 == 1 && 0 - min > mm ) mm = 0 - min ; } cout << mm << endl ; } return 0 ; }
TAB0 declare constant integer MAXN = 2e5 + 5 ; TAB0 declare integer N ; TAB0 declare long longs M , P , H ; TAB0 declare long long arrays A size MAXN , B size MAXN ; TAB1 read N ; TAB1 for i = 0 to N exclusive ; TAB2 read A [ i ] ; TAB2 for j = 0 to A [ i ] exclusive ; TAB3 read P ; TAB3 let B [ i ] be maximum of B [ i ] and P ; TAB2 let M be maximum of M and B [ i ] ; TAB1 for i = 0 to N exclusive , increment H by A [ i ] * ( M - B [ i ] ) ; TAB1 print H and ' \ n ' ;	const int MAXN = 2e5 + 5 ; int N ; long long M , P , H ; long long A [ MAXN ] , B [ MAXN ] ; int main ( ) { cin >> N ; for ( int i = 0 ; i < N ; i ++ ) { cin >> A [ i ] ; for ( int j = 0 ; j < A [ i ] ; j ++ ) { cin >> P ; B [ i ] = max ( B [ i ] , P ) ; } M = max ( M , B [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { H += A [ i ] * ( M - B [ i ] ) ; } cout << H << ' \n ' ; return 0 ; }
TAB1 create int n , sum ; TAB1 read n ; TAB1 for i = 1 to 1000 inclusive ; TAB2 create int k = 0 ; TAB2 set sum to n * i + 1 ; TAB2 for j = 2 to sum exclusive ; TAB3 if sum modulo j is 0 ; TAB4 set k to 1 ; TAB4 break ; TAB2 if k equals 1 ; TAB3 print i ; TAB3 break ;	int main ( ) { int n , sum ; cin >> n ; for ( int i = 1 ; i <= 1000 ; i ++ ) { int k = 0 ; sum = n * i + 1 ; for ( int j = 2 ; j < sum ; j ++ ) { if ( sum % j == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { cout << i << endl ; break ; } } return 0 ; }
TAB0 declare integers tmp , min1 , max1 , sum_n , index_max and index_min ; TAB0 declare new 2d array of integers arr1 with size 1000 by 1000 ; TAB0 arr3 is a new array of characters with size 100 ; TAB0 declare new array of integers arr with 10000 elements ; TAB0 void function display_vector with integer vector argument v ; TAB1 start for loop from i = 0 to length of v exclusive , printing v [ i ] and " " on each loop iteration ; TAB1 print a new line ; TAB0 void function speed ; TAB0 min_max is a void function with integers vector argument v and int argument l ; TAB1 change the value of min1 to INT_MAX ; TAB1 change the value of max1 to INT_MIN ; TAB1 in a for loop , change i from l to length of v exclusive ; TAB2 if v [ i ] < = min1 ; TAB3 change the value of min1 to v [ i ] ; TAB3 assign i to index_min ; TAB2 if v [ i ] > = max1 ; TAB3 set max1 to v [ i ] ; TAB3 change index_max to i ; TAB0 function sum_v with vector of int argument v that returns integer ; TAB1 puth the sum of all elements of v into sum_n ; TAB1 return sum_n ; TAB0 is_it_sorted_acs is a boolean function with vector of int argument v ; TAB1 create boolean variable test1 = false ; TAB1 for i from 0 to length of v - 1 exclusive ; TAB2 if v [ i + 1 ] < = v [ i ] ; TAB3 change test1 to false ; TAB3 return test1 ; TAB1 change test1 to true ; TAB1 return test1 ; TAB0 boolean function is_it_sorted_des with vector of integers argument v ; TAB1 declare new boolean test1 = false ; TAB1 in a for loop , change i from 0 to length of v - 1 exclusive ; TAB2 if v [ i + 1 ] > = v [ i ] ; TAB3 assign false to test1 ; TAB3 return test1 ; TAB1 change the value of test1 to true ; TAB1 return test1 ; TAB1 call speed ( ) ; TAB1 declare new string s ; TAB1 read from the input to s ; TAB1 create integers cn , ci , ce and ct = 0 ; TAB1 in a for loop , change i from 0 to length of s exclusive incrementing i ; TAB2 if s [ i ] is equal to ' n ' ; TAB3 increment cn ; TAB2 else if s [ i ] is equal to ' i ' ; TAB3 increment ci by one ; TAB2 else if s [ i ] = ' e ' ; TAB3 increment ce ; TAB2 else if s [ i ] is equal to ' t ' ; TAB3 increment ct by one ; TAB1 change cn to ( cn - 1 ) / 2 ; TAB1 divide ce by 3 ; TAB1 print min ( min ( cn , ct ) , min ( ce , ci ) ) ;	int tmp , min1 , max1 , sum_n , index_max , index_min ; int arr1 [ 1000 ] [ 1000 ] ; char arr3 [ 100 ] ; int arr [ 10000 ] ; void display_vector ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << "   " ; cout << endl ; } void speed ( ) { } void min_max ( vector < int > v , int l ) { min1 = INT_MAX ; max1 = INT_MIN ; for ( int i = l ; i < v . size ( ) ; i ++ ) { if ( v [ i ] <= min1 ) { min1 = v [ i ] ; index_min = i ; } if ( v [ i ] >= max1 ) { max1 = v [ i ] ; index_max = i ; } } } int sum_v ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) sum_n += v [ i ] ; return sum_n ; } bool is_it_sorted_acs ( vector < int > v ) { bool test1 = false ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) if ( v [ i + 1 ] <= v [ i ] ) { test1 = false ; return test1 ; } test1 = true ; return test1 ; } bool is_it_sorted_des ( vector < int > v ) { bool test1 = false ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) if ( v [ i + 1 ] >= v [ i ] ) { test1 = false ; return test1 ; } test1 = true ; return test1 ; } int main ( ) { speed ( ) ; string s ; cin >> s ; int cn = 0 , ci = 0 , ce = 0 , ct = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' n ' ) cn ++ ; else if ( s [ i ] == ' i ' ) ci ++ ; else if ( s [ i ] == ' e ' ) ce ++ ; else if ( s [ i ] == ' t ' ) ct ++ ; } cn = ( cn - 1 ) / 2 ; ce /= 3 ; cout << min ( min ( cn , ct ) , min ( ce , ci ) ) << endl ; }
TAB1 create int n ; TAB1 read n ; TAB1 create long long int a , b , c , d ; TAB1 read a , b , c , d ; TAB1 set sum to a + b + c + d ; TAB1 count = 1 ; TAB1 for i = 1 to n exclusive ; TAB2 read a , b , c and d ; TAB2 if a + b + c + d > sum , increment count ; TAB1 print count ;	int main ( ) { int n ; cin >> n ; long long int a , b , c , d ; cin >> a >> b >> c >> d ; long long int sum = a + b + c + d ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cin >> a >> b >> c >> d ; if ( ( a + b + c + d ) > sum ) { count ++ ; } } cout << count << endl ; }
TAB0 declare new constant integer MAXN with value 1000 * 100 + 10 ; TAB0 arr is an array of integers with size MAXN ; TAB0 create long longs n and d ; TAB0 integer function bs with int arguments t and i ; TAB1 create new integer variable l = i and r = n ; TAB1 while r - l > 1 ; TAB2 create integer mid with value ( r + l ) / 2 ; TAB2 if arr [ mid ] - t < = d ; TAB3 change l to mid ; TAB2 else ; TAB3 change r to mid ; TAB1 return l ; TAB1 declare long long ans with value 0 ; TAB1 read input to n and d ; TAB1 in a for loop , change i from 0 to n exclusive , reading input to arr [ i ] ; TAB1 for integer i = 0 to n exclusive ; TAB2 k is a new integer with value = bs ( arr [ i ] , i ) - i ; TAB2 change ans to the sum of ans and ( 1LL * k * ( k - 1 ) ) / 2 ; TAB1 print ans to the standard output ;	const int MAXN = 1000 * 100 + 10 ; int arr [ MAXN ] ; long long n , d ; int bs ( int t , int i ) { int l = i , r = n ; while ( r - l > 1 ) { int mid = ( r + l ) / 2 ; if ( arr [ mid ] - t <= d ) l = mid ; else r = mid ; } return l ; } int main ( ) { long long ans = 0 ; cin >> n >> d ; for ( int i = 0 ; i < n ; i ++ ) cin >> arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = ( bs ( arr [ i ] , i ) - i ) ; ans += ( 1LL * k * ( k - 1 ) ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB1 let N = 1e5 + 1 be a long long const ; TAB1 let n , arr be long long with arr an array of length N ; TAB1 read n ; TAB1 set arr [ 0 ] to 0 ; TAB1 for i = 1 to N exclusive then set arr [ i ] to arr [ i - 1 ] + i ; TAB1 for i = 1 to N exclusive ; TAB2 if the binary search of arr + 1 , arr + N , n - arr [ i ] isn ' t 0 ; TAB3 print YES and new line ; TAB1 print NO and new line ;	int main ( ) { long long const N = 1e5 + 1 ; long long n , arr [ N ] ; cin >> n ; arr [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) arr [ i ] = arr [ i - 1 ] + i ; for ( int i = 1 ; i < N ; i ++ ) if ( binary_search ( arr + 1 , arr + N , n - arr [ i ] ) ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB1 declare integers remain , i , n and x with remain = 0 , and arrays of integers a and b with size 200001 ; TAB1 loop , reading n and x from the input ; TAB2 read n new elements to a from the input , starting from the index 1 ; TAB2 in a for loop , change i from 1 to n inclusive ; TAB3 set the value of b [ i ] to ( a [ i ] + remain ) / x ; TAB3 assign ( a [ i ] + remain ) modulo x to remain ; TAB2 for i from 1 to n inclusive incrementing i ; TAB3 if i is less than n ; TAB4 print b [ i ] and " " ; TAB3 else ; TAB4 print b [ i ] to the standard output ;	int main ( ) { int remain = 0 , i , n , x , a [ 200001 ] = { 0 } , b [ 200001 ] = { 0 } ; while ( cin >> n >> x ) { for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( i = 1 ; i <= n ; i ++ ) { b [ i ] = ( a [ i ] + remain ) / x ; remain = ( a [ i ] + remain ) % x ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i < n ) cout << b [ i ] << "   " ; else cout << b [ i ] << endl ; } } return 0 ; }
TAB1 create int n and flag , set flag to 0 ; TAB1 create char s [ 105 ] ; TAB1 read n ; TAB1 read s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] = s [ i + 1 ] and s [ i ] different from ? ; TAB3 assign 0 to flag ; TAB3 break ; TAB2 if s [ i ] equal to = ; TAB3 if s [ i - 1 ] = s [ i + 1 ] or s [ i + 1 ] = ? ; TAB2 if s [ 0 ] = = or s [ n - 1 ] = ? , assign 1 to flag ; TAB1 if flag different from 0 ; TAB2 print Yes and a newline ; TAB1 else ; TAB2 print NO and a newline ;	int main ( ) { int n , flag = 0 ; char s [ 105 ] ; cin >> n ; cin >> s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] && s [ i ] != ' ? ' ) { flag = 0 ; break ; } if ( s [ i ] == ' ? ' ) { if ( s [ i - 1 ] == s [ i + 1 ] || s [ i + 1 ] == ' ? ' ) { flag = 1 ; } } if ( s [ 0 ] == ' ? ' || s [ n - 1 ] == ' ? ' ) flag = 1 ; } if ( flag ) cout << " Yes\n " ; else cout << " No\n " ; }
TAB0 N = 300005 ; TAB0 M = 15000010 ; TAB0 a = array of N int ; TAB0 num = array of M int ; TAB0 vis = array of M boole ; TAB0 n = int ; TAB1 while read n ; TAB2 maxgcd = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 maxgcd = __gcd ( maxgcd , a [ i ] ) ; TAB2 for i = 0 to n exclusive increment num [ a [ i ] / maxgcd ] ; TAB2 maxsub = 0 ; TAB2 for i = 2 to M exclusive ; TAB3 if not vis [ i ] ; TAB4 thissub = 0 ; TAB4 for j = i to M by i exclusive ; TAB5 vis [ j ] = true ; TAB5 add num [ j ] to thissub ; TAB4 maxsub = max ( maxsub , thissub ) ; TAB2 if not maxsub ; TAB3 print - 1 ; TAB2 else ; TAB3 print n - maxsub ; TAB2 fill vis with false ; TAB2 fill num with 0 ;	const int N = 3e5 + 5 ; const int M = 1.5e7 + 10 ; int a [ N ] ; int num [ M ] ; bool vis [ M ] ; int n ; int main ( ) { while ( cin >> n ) { int maxgcd = 0 ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; maxgcd = __gcd ( maxgcd , a [ i ] ) ; } for ( int i = 0 ; i < n ; ++ i ) num [ a [ i ] / maxgcd ] ++ ; int maxsub = 0 ; for ( int i = 2 ; i < M ; ++ i ) { if ( ! vis [ i ] ) { int thissub = 0 ; for ( int j = i ; j < M ; j += i ) { vis [ j ] = 1 ; thissub += num [ j ] ; } maxsub = max ( maxsub , thissub ) ; } } if ( ! maxsub ) cout << - 1 << endl ; else cout << n - maxsub << endl ; memset ( vis , 0 , sizeof ( vis ) ) ; memset ( num , 0 , sizeof ( num ) ) ; } return 0 ; }
TAB0 n , x , y = integers ; TAB1 Read n , x , y ; TAB1 if x + y is less than or equal to n + 1 ; TAB2 print White and a new line ; TAB1 print Black and a new line ;	long long n , x , y ; int main ( ) { cin >> n >> x >> y ; if ( x + y <= n + 1 ) { cout << " White " << endl ; return 0 ; } cout << " Black " << endl ; }
TAB1 let ints n and k ; TAB1 read n and k ; TAB1 create string s = " " ; TAB1 for i = 0 to n exclusive , add ( char ) ' a ' + ( i % k ) to s ; TAB1 print s ;	int main ( ) { int n , k ; cin >> n >> k ; string s = "  " ; for ( int i = 0 ; i < n ; i ++ ) { s += ( char ) ' a ' + ( i % k ) ; } cout << s << endl ; return 0 ; }
TAB1 hpy , atky , defy , hpm , atkm , defm , h , a , d , ans = integers ; TAB1 read hpy , atky , defy , hpm , atkm , defm , h , a , d ; TAB1 for t = 1 to hpm ; TAB2 cans = integer with cans = max ( ceil ( ( hpm + defm * t - atky * t ) / double ( t ) ) * a , 0 . 0 ) ; TAB2 hdc = integer with hdc = max ( t * atkm - t * defy - hpy + 1 , 0 ) ; TAB2 cans = cans + ( hdc / t ) * min ( d , t * h ) + min ( d , ( hdc % t ) * h ) ; TAB2 if t is 1 ; TAB3 ans = cans ; TAB2 else ; TAB3 ans = min of ans and cans ; TAB1 print ans ;	int main ( ) { int hpy , atky , defy , hpm , atkm , defm , h , a , d , ans ; cin >> hpy >> atky >> defy >> hpm >> atkm >> defm >> h >> a >> d ; for ( int t = 1 ; t <= hpm ; t ++ ) { int cans = max ( ceil ( ( hpm + defm * t - atky * t ) / double ( t ) ) * a , 0.0 ) ; int hdc = max ( t * atkm - t * defy - hpy + 1 , 0 ) ; cans += ( hdc / t ) * min ( d , t * h ) + min ( d , ( hdc % t ) * h ) ; if ( t == 1 ) ans = cans ; else ans = min ( ans , cans ) ; } cout << ans << endl ; return 0 ; }
TAB0 PI = const double with PI = acos of - 1 . 0 ; TAB0 eps = const double with eps = 1e - 6 ; TAB0 INF = const int with INF = 0x3f3f3f3f ; TAB0 N = const int with N = 2e5 + 5 ; TAB1 a , b = string ; TAB1 loop while reading a then b ; TAB2 flag = bool with flag = true ; TAB2 tag = bool with tag = true ; TAB2 ch1 , ch2 , ch3 , ch4 = char ; TAB2 kk = bool with kk = true ; TAB2 if size of a is not size of b ; TAB3 set kk to false ; TAB2 else ; TAB3 for i = 0 to size of a ; TAB4 if a [ i ] is not b [ i ] and flag is true ; TAB5 set flag to false ; TAB5 set ch1 to a [ i ] ; TAB5 set ch2 to b [ i ] ; TAB4 else if a [ i ] is not b [ i ] and tag is true ; TAB5 set tag to false ; TAB5 set ch3 to a [ i ] ; TAB5 set ch4 to b [ i ] ; TAB4 else if a [ i ] is not b [ i ] ; TAB5 set kk to false ; TAB5 break ; TAB2 if kk is false ; TAB3 print " NO " ; TAB2 else ; TAB3 if tag or flag is true ; TAB4 print " NO " ; TAB3 else if ch1 is ch4 and ch2 is ch3 ; TAB4 print " YES " ; TAB3 else ; TAB4 print " NO " ;	const double PI = acos ( - 1.0 ) ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int N = 2e5 + 5 ; int main ( ) { string a , b ; while ( cin >> a >> b ) { bool flag = true ; bool tag = true ; char ch1 , ch2 , ch3 , ch4 ; bool kk = true ; if ( a . size ( ) != b . size ( ) ) { kk = false ; } else { for ( int i ( 0 ) ; i < a . size ( ) ; i ++ ) { if ( a [ i ] != b [ i ] && flag ) { flag = false ; ch1 = a [ i ] ; ch2 = b [ i ] ; } else if ( a [ i ] != b [ i ] && tag ) { tag = false ; ch3 = a [ i ] ; ch4 = b [ i ] ; } else if ( a [ i ] != b [ i ] ) { kk = false ; break ; } } } if ( ! kk ) cout << " NO " << endl ; else { if ( tag || flag ) cout << " NO " << endl ; else if ( ch1 == ch4 && ch2 == ch3 ) cout << " YES " << endl ; else cout << " NO " << endl ; } } return 0 ; }
TAB0 function win ( no args , no return value ) ; TAB1 print Yes ; TAB1 exit ; TAB0 function reflect ( get address of vector of string a , return nothing ) ; TAB1 N = size of a ; TAB1 for i = 0 to N exclusive reverse a [ i ] ; TAB0 function rot ( get address of vector of string a , return nothing ) ; TAB1 N = size of a ; TAB1 for x = 0 to n / 2 exclusive ; TAB2 for y = x to N - x - 1 exclusive ; TAB3 tmp = a [ x ] [ y ] ; TAB3 a [ x ] [ y ] = a [ y ] [ N - 1 - x ] ; TAB3 a [ y ] [ N - 1 - x ] = a [ N - 1 - x ] [ N - 1 - y ] ; TAB3 a [ N - 1 - x ] [ N - 1 - y ] = a [ N - 1 - y ] [ x ] ; TAB3 a [ N - 1 - y ] [ x ] = tmp ; TAB1 N = int ; TAB1 read N ; TAB1 a and b = vector of N string ; TAB1 for i = 0 to N exclusive read a [ i ] ; TAB1 for j = 0 to N exclusive read b [ j ] ; TAB1 for j = 0 to 2 excluisve ; TAB2 reflect ( a ) ; TAB2 for i = 0 to 4 exclusive ; TAB3 rot ( a ) ; TAB3 if a is b win ( ) ; TAB1 print No ;	void win ( ) { cout << " Yes " << endl ; exit ( 0 ) ; } void reflect ( vector < string > & a ) { int N = a . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) reverse ( a [ i ] . begin ( ) , a [ i ] . end ( ) ) ; } void rot ( vector < string > & a ) { int N = a . size ( ) ; for ( int x = 0 ; x < N / 2 ; x ++ ) { for ( int y = x ; y < N - x - 1 ; y ++ ) { char tmp = a [ x ] [ y ] ; a [ x ] [ y ] = a [ y ] [ N - 1 - x ] ; a [ y ] [ N - 1 - x ] = a [ N - 1 - x ] [ N - 1 - y ] ; a [ N - 1 - x ] [ N - 1 - y ] = a [ N - 1 - y ] [ x ] ; a [ N - 1 - y ] [ x ] = tmp ; } } } int main ( ) { int N ; cin >> N ; vector < string > a ( N ) , b ( N ) ; for ( int i = 0 ; i < N ; i ++ ) cin >> a [ i ] ; for ( int j = 0 ; j < N ; j ++ ) cin >> b [ j ] ; for ( int j = 0 ; j < 2 ; j ++ ) { reflect ( a ) ; for ( int i = 0 ; i < 4 ; i ++ ) { rot ( a ) ; if ( a == b ) win ( ) ; } } cout << " No " << endl ; return 0 ; }
TAB0 set const int N to 2e5 + 7 ; TAB0 set const long double pi to 3 . 14159265359 ; TAB0 set const long long INF to 1e9 ; TAB0 set const long double eps to 1e - 9 ; TAB0 integers = n , s [ N ] , r [ N ] , p [ N ] , l [ N ] ; TAB1 set n to 4 ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 read l [ i ] , s [ i ] , r [ i ] , p [ i ] ; TAB2 if p [ i ] is true ; TAB3 if l [ i ] or s [ i ] or r [ i ] is true ; TAB4 output YES ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 if i is 1 then do ; TAB3 if l [ i ] is 1 then do ; TAB4 if p [ 4 ] is true ; TAB5 output YES \ n ; TAB3 if s [ i ] is 1 then do ; TAB4 if p [ 3 ] is true ; TAB5 output YES \ n ; TAB3 if r [ i ] is 1 then do ; TAB4 if p [ 2 ] is true ; TAB5 output YES \ n ; TAB2 else ; TAB3 if l [ i ] is 1 then do ; TAB4 if p [ 1 ] is true ; TAB5 output YES \ n ; TAB3 if s [ i ] is 1 then do ; TAB4 if p [ 4 ] is true ; TAB5 output YES \ n ; TAB3 if r [ i ] is 1 then do ; TAB4 if p [ 3 ] is true ; TAB5 output YES \ n ; TAB2 else ; TAB3 if l [ i ] is 1 then do ; TAB4 if p [ 2 ] is true ; TAB5 output YES \ n ; TAB3 if s [ i ] is 1 then do ; TAB4 if p [ 1 ] is true ; TAB5 output YES \ n ; TAB3 if r [ i ] is 1 then do ; TAB4 if p [ 4 ] is true ; TAB5 output YES \ n ; TAB2 else ; TAB3 if l [ i ] is 1 then do ; TAB4 if p [ 3 ] is true ; TAB5 output YES \ n ; TAB3 if s [ i ] is 1 then do ; TAB4 if p [ 2 ] is true ; TAB5 output YES \ n ; TAB3 if r [ i ] is 1 then do ; TAB4 if p [ 1 ] is true ; TAB5 output YES \ n ; TAB1 output NO ;	const int N = 2e5 + 7 ; const long double pi = 3.14159265359 ; const long long INF = 1e9 ; const long double eps = 1e-9 ; int n , s [ N ] , r [ N ] , p [ N ] , l [ N ] ; int main ( ) { n = 4 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> l [ i ] >> s [ i ] >> r [ i ] >> p [ i ] ; if ( p [ i ] ) { if ( l [ i ] || s [ i ] || r [ i ] ) { cout << " YES\n " ; return 0 ; } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 1 ) { if ( l [ i ] == 1 ) { if ( p [ 4 ] ) { cout << " YES\n " ; return 0 ; } } if ( s [ i ] == 1 ) { if ( p [ 3 ] ) { cout << " YES\n " ; return 0 ; } } if ( r [ i ] == 1 ) { if ( p [ 2 ] ) { cout << " YES\n " ; return 0 ; } } } else if ( i == 2 ) { if ( l [ i ] == 1 ) { if ( p [ 1 ] ) { cout << " YES\n " ; return 0 ; } } if ( s [ i ] == 1 ) { if ( p [ 4 ] ) { cout << " YES\n " ; return 0 ; } } if ( r [ i ] == 1 ) { if ( p [ 3 ] ) { cout << " YES\n " ; return 0 ; } } } else if ( i == 3 ) { if ( l [ i ] == 1 ) { if ( p [ 2 ] ) { cout << " YES\n " ; return 0 ; } } if ( s [ i ] == 1 ) { if ( p [ 1 ] ) { cout << " YES\n " ; return 0 ; } } if ( r [ i ] == 1 ) { if ( p [ 4 ] ) { cout << " YES\n " ; return 0 ; } } } else { if ( l [ i ] == 1 ) { if ( p [ 3 ] ) { cout << " YES\n " ; return 0 ; } } if ( s [ i ] == 1 ) { if ( p [ 2 ] ) { cout << " YES\n " ; return 0 ; } } if ( r [ i ] == 1 ) { if ( p [ 1 ] ) { cout << " YES\n " ; return 0 ; } } } } cout << " NO\n " ; return 0 ; }
TAB0 MOD is a new long long variable = 1000000007 ; TAB1 declare new long long called N ; TAB1 read N ; TAB1 create vector of long longs A with 1000500 elements filled with zeroes ; TAB1 res is a new long long variable with value 0 ; TAB1 create new long long variable a ; TAB1 for i = 0 to N exclusive incrementing i ; TAB2 read a ; TAB2 increment A [ a ] ; TAB1 for i from 0 to length of A exclusive ; TAB2 if A [ i ] is greater than 0 , increase A [ i + 1 ] by A [ i ] / 2 ; TAB2 if A [ i ] is odd , increment res ; TAB1 print res to the standard output ;	long long MOD = 1000000007 ; int main ( ) { long long N ; cin >> N ; vector < long long > A ( 1000500 , 0 ) ; long long res = 0 ; long long a ; for ( long long i = 0 ; i < N ; i ++ ) { cin >> a ; A [ a ] ++ ; } for ( long long i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] > 0 ) { A [ i + 1 ] += A [ i ] / 2 ; } if ( A [ i ] % 2 == 1 ) { res ++ ; } } cout << res << endl ; }
TAB1 let ints x and y ; TAB1 create char c ; TAB1 print x ; TAB1 read c ; TAB1 read y ; TAB1 if x is less than 5 or if x is equal to 6 and y is greater than 59 ; TAB2 if y - x is greater than or equal to 9 * x ; TAB3 print 0 , x + 1 , " : " , and ( x + 1 ) * 9 + ( x + 1 ) ; TAB2 else do ; TAB3 print 0 , x , " : " , and x + ( 9 * x ) ; TAB1 else if x is greater than or equal to 5 and x is less than or equal to 9 ; TAB2 print " 10 : 01 " ; TAB1 else if x is greater than or equal to 16 and x is less than 19 or if x is equal to 15 and y is greater than or equal to 51 ; TAB2 print " 20 : 02 " ; TAB1 else if x is equal to 23 ; TAB2 if y is greater than or equal to 32 ; TAB3 print " 00 : 00 " ; TAB2 otherwise ; TAB3 print " 23 : 32 " ; TAB1 else if x is equal to 11 or x is equal to 22 ; TAB2 if y - x is less than or equal to 0 ; TAB3 print x + 1 , " : " , and x + 10 ; TAB2 else ; TAB3 print x , " : " , and x ; TAB1 else if x is equal to 10 ; TAB2 if y is greater than or equal to 1 ; TAB3 print " 11 : 11 " ; TAB2 else do ; TAB3 print " 10 : 01 " ; TAB1 else if x is greater than or equal to 12 and x is less than or equal to 15 ; TAB2 if y - x is greater than or equal to 9 * ( x - 10 ) - 9 ; TAB3 print x + 1 , " : " , and ( x - 10 + 1 ) * 9 + ( x - 10 + 2 ) ; TAB2 else ; TAB3 print x , " : " , and x + ( ( x - 11 ) * 9 ) ; TAB1 else ; TAB2 if x is equal to 20 ; TAB3 if y is greater than or equal to 2 ; TAB4 print " 21 : 12 " ; TAB3 else do ; TAB4 print " 20 : 02 " ; TAB2 else if x is equal to 21 ; TAB3 if y is greater than or equal to 12 ; TAB4 print " 22 : 22 " ; TAB3 else ; TAB4 print " 21 : 12 " ;	int main ( ) { int x , y ; char c ; cin >> x ; cin . get ( c ) ; cin >> y ; if ( x < 5 || ( x == 6 && y < 59 ) ) { if ( ( y - x ) >= ( 9 * x ) ) cout << 0 << x + 1 << " : " << ( x + 1 ) * 9 + ( x + 1 ) << endl ; else cout << 0 << x << " : " << x + ( 9 * x ) << endl ; } else if ( x >= 5 && x <= 9 ) cout << " 10:01 " << endl ; else if ( x >= 16 && x <= 19 || ( x == 15 && y >= 51 ) ) cout << " 20:02 " << endl ; else if ( x == 23 ) { if ( y >= 32 ) cout << " 00:00 " << endl ; else cout << " 23:32 " << endl ; } else if ( x == 11 || x == 22 ) { if ( ( y - x ) >= 0 ) cout << x + 1 << " : " << x + 10 << endl ; else cout << x << " : " << x << endl ; } else if ( x == 10 ) { if ( y >= 1 ) cout << " 11:11 " << endl ; else cout << " 10:01 " << endl ; } else if ( x >= 12 && x <= 15 ) { if ( ( y - x ) >= ( 9 * ( x - 10 ) - 9 ) ) cout << x + 1 << " : " << ( x - 10 + 1 ) * 9 + ( x - 10 + 2 ) << endl ; else cout << x << " : " << x + ( ( x - 11 ) * 9 ) << endl ; } else { if ( x == 20 ) if ( y >= 2 ) cout << " 21:12 " << endl ; else cout << " 20:02 " << endl ; else if ( x == 21 ) if ( y >= 12 ) cout << " 22:22 " << endl ; else cout << " 21:12 " << endl ; } return 0 ; }
TAB1 indice_max and indice_min = int ; TAB1 n = int ; TAB1 read n ; TAB1 arrayi = array of n int ; TAB1 i = int ; TAB1 for i = 0 to n exclusive read arrayi [ i ] ; TAB1 indice_max = max element of arrayi - arrayi ; TAB1 for i = n - 1 down to 0 inclusive ; TAB2 if arrayi [ i ] = = min element of arrayi ; TAB3 indice_min = i ; TAB3 break ; TAB1 s = indice_max + n - 1 - indice_min ; TAB1 if indice_max > i decrement s ; TAB1 print s ;	int main ( ) { int indice_max , indice_min ; int n ; cin >> n ; int arrayi [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { cin >> arrayi [ i ] ; } indice_max = max_element ( arrayi , arrayi + n ) - arrayi ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( arrayi [ i ] == * min_element ( arrayi , arrayi + n ) ) { indice_min = i ; break ; } } int s = indice_max + n - 1 - indice_min ; if ( indice_max > i ) { s = s - 1 ; } cout << s << endl ; return 0 ; }
TAB1 declare character array a with size 1005 ; TAB1 read a ; TAB1 create integer n = length of a ; TAB1 declare integer variable flag = 0 ; TAB1 loop i from 1 to n - 2 inclusive ; TAB2 declare characters A = a [ i - 1 ] , B = a [ i ] and C = a [ i + 1 ] ; TAB2 if A = ' . ' or B = ' . ' or C = ' . ' , skip the rest of the loop ; TAB2 if A ! = B and A ! = C and B ! = C ; TAB3 change flag to 1 ; TAB3 break the loop ; TAB1 if flag is not 0 ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	int main ( ) { char a [ 1005 ] ; cin >> a ; int n = strlen ( a ) ; int flag = 0 ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { char A = a [ i - 1 ] , B = a [ i ] , C = a [ i + 1 ] ; if ( A == ' . ' || B == ' . ' || C == ' . ' ) continue ; if ( A != B && A != C && B != C ) { flag = 1 ; break ; } } if ( flag ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB1 n , N , i = long long ; TAB1 n = 1 ; TAB1 vec = vector of long long ; TAB1 while n < 10000 put n * ( n + 1 ) / 2 at end of vec , increment n ; TAB1 read N ; TAB1 if N is 1 ; TAB2 print " NO " ; TAB1 for i = 0 to 99999 exclusive ; TAB2 if binary_search ( start of vec , end of vec , N - vec [ i ] ) ; TAB3 print " YES " ; TAB1 print " NO " ;	int main ( ) { long long n , N , i ; n = 1 ; vector < long long > vec ; for ( ; n < 1e5 ; n ++ ) vec . push_back ( n * ( n + 1 ) / 2 ) ; cin >> N ; if ( N == 1 ) { cout << " NO " << endl ; return 0 ; } for ( i = 0 ; i < 1e5 - 1 ; i ++ ) { if ( binary_search ( vec . begin ( ) , vec . end ( ) , N - vec [ i ] ) ) { cout << " YES " << endl ; return 0 ; } } cout << " NO " << endl ; return 0 ; }
TAB1 a , b , s = integers ; TAB1 read a , b , s ; TAB1 ans = integer set to s - absolute value of a - absolute value of b ; TAB1 if ans > = 0 and ans modulo 2 is 0 ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No : ;	int main ( ) { int a , b , s ; cin >> a >> b >> s ; int ans = s - abs ( a ) - abs ( b ) ; if ( ans >= 0 && ans % 2 == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB0 let mod be a constant integer with mod = 1e9 + 7 ; TAB0 dp = 2d array of integers with 5005 rows and 5005 columns ; TAB0 let a , b be strings ; TAB1 read a , b ; TAB1 let len1 be a integer with len1 = length of a ; TAB1 let len2 be a integer with len2 = length of b ; TAB1 for i = 1 to len1 inclusive ; TAB2 for j = 1 to len2 inclusive ; TAB3 if a . operator [ ] ( i - 1 ) is equal to b . operator [ ] ( j - 1 ) , dp [ i ] [ j ] is equal to ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) modulo mod ; TAB3 dp [ i ] [ j ] is equal to ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) modulo mod ; TAB1 let ans be a long integer with ans = 0 ; TAB1 for i = 1 to len1 inclusive , ans is equal to ( ans + dp [ i ] [ len2 ] ) modulo mod ; TAB1 print ans and newline ;	const int mod = 1e9 + 7 ; int dp [ 5005 ] [ 5005 ] ; string a , b ; int main ( ) { cin >> a >> b ; int len1 = a . length ( ) ; int len2 = b . length ( ) ; for ( int i = 1 ; i <= len1 ; i ++ ) { for ( int j = 1 ; j <= len2 ; j ++ ) { if ( a . operator [ ] ( i - 1 ) == b . operator [ ] ( j - 1 ) ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) % mod ; } dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) % mod ; } } long long ans = 0 ; for ( int i = 1 ; i <= len1 ; i ++ ) ans = ( ans + dp [ i ] [ len2 ] ) % mod ; cout << ans << endl ; }
TAB1 str = string ; TAB1 read str ; TAB1 i = integer ; TAB1 for i = 0 as long as i is less than size of str and str [ i ] is the character a with increment i + 1 ; TAB1 for j = 1 to size of str exclusive ; TAB2 if str [ j ] is the character a , break ; TAB2 decrement str [ j ] ; TAB1 if i equals size of str , set str [ ( size of str ) - 1 ] to the character z ; TAB1 print str ;	int main ( ) { string str ; cin >> str ; int i ; for ( i = 0 ; i < str . size ( ) && str [ i ] == ' a ' ; i ++ ) { } for ( int j = i ; j < str . size ( ) ; j ++ ) { if ( str [ j ] == ' a ' ) { break ; } str [ j ] -- ; } if ( i == str . size ( ) ) { str [ str . size ( ) - 1 ] = ' z ' ; } cout << str << endl ; return 0 ; }
TAB1 declare a , b , c , d , e , f as unsigned integers ; TAB1 read a , b , c , d , e , f ; TAB1 if d is 0 ; TAB2 print " Hermione " , newline ; TAB1 else if c is 0 ; TAB2 print " Ron " , newline ; TAB1 else if b is 0 ; TAB2 print " Hermione " , newline ; TAB1 else if a is 0 ; TAB2 print " Ron " , newline ; TAB1 else if f is 0 ; TAB2 print " Hermione " , newline ; TAB1 else if e is 0 ; TAB2 print " Ron " , newline ; TAB1 else if ( a * c * e is less than b * d * f ) ; TAB2 print " Ron " , newline ; TAB1 else ; TAB2 print " Hermione " , newline ;	int main ( ) { unsigned int a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; if ( d == 0 ) cout << " Hermione " << endl ; else if ( c == 0 ) cout << " Ron " << endl ; else if ( b == 0 ) cout << " Hermione " << endl ; else if ( a == 0 ) cout << " Ron " << endl ; else if ( f == 0 ) cout << " Hermione " << endl ; else if ( e == 0 ) cout << " Ron " << endl ; else if ( a * c * e < b * d * f ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB0 EPS = 1e - 9 ; TAB0 INFF = 1000000000000000005 ; TAB1 l1 , r1 , l2 , r2 , k = long long ; TAB1 read l1 , r1 , l2 , r2 , k ; TAB1 ml = max ( l1 , l2 ) ; TAB1 mr = min ( r1 , r2 ) ; TAB1 t = mr - ml + 1 ; TAB1 if k > = ml and < = mr increment t ; TAB1 print 0 if t < = 0 else t ;	double EPS = 1e-9 ; long long INFF = 1000000000000000005LL ; int main ( ) { long long l1 , r1 , l2 , r2 , k ; cin >> l1 >> r1 >> l2 >> r2 >> k ; long long ml = max ( l1 , l2 ) ; long long mr = min ( r1 , r2 ) ; long long t = mr - ml + 1 ; if ( k >= ml && k <= mr ) t -- ; cout << ( ( t <= 0 ) ? 0 : t ) << ' \n ' ; return 0 ; }
TAB1 i , j , t , s , L , c , b = integers with L = 0 and a = array of 55 integers ; TAB1 Read t ; TAB1 set s = 0 and c = 0 ; TAB1 for i = 0 to t exclusive ; TAB2 increment c ; TAB2 Read b ; TAB2 if b is less than 0 , then increment s ; TAB2 if s is 3 ; TAB3 set a [ L + + ] to c - 1 ; TAB3 set c to 1 ; TAB3 set s to 1 ; TAB1 if c is not 0 , then set a [ L + + ] to c ; TAB1 print L and new line ; TAB1 for i = 0 to L exclusive ; TAB2 if i is not 0 , then print " " ; TAB2 print a [ i ] ; TAB1 print a new line ;	int main ( ) { int a [ 55 ] , i , j , t , s , L = 0 , c , b ; cin >> t ; s = 0 , c = 0 ; for ( i = 0 ; i < t ; i ++ ) { c ++ ; cin >> b ; if ( b < 0 ) s ++ ; if ( s == 3 ) { a [ L ++ ] = c - 1 ; c = 1 ; s = 1 ; } } if ( c != 0 ) a [ L ++ ] = c ; cout << L << endl ; for ( i = 0 ; i < L ; i ++ ) { if ( i != 0 ) cout << "   " ; cout << a [ i ] ; } cout << endl ; return 0 ; }
TAB0 let n , k , a be integers ; TAB1 read n ; TAB1 let ans be integer with ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read k , a ; TAB2 if 1 = = a , increment k ; TAB2 while a ! = 1 ; TAB3 if a % 4 ! = 0 ; TAB4 update a to a / 4 + 1 ; TAB3 else ; TAB4 a = a / 4 ; TAB3 increment k ; TAB2 set ans to k if k > ans else ans ; TAB1 print ans ;	int n , k , a ; int main ( ) { cin >> n ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k >> a ; if ( 1 == a ) k ++ ; while ( a != 1 ) { if ( a % 4 != 0 ) a = a / 4 + 1 ; else a /= 4 ; k ++ ; } ans = k > ans ? k : ans ; } cout << ans << endl ; return 0 ; }
TAB0 in function po taking a long long n and returning a long long ; TAB1 res = long long with res = 1 ; TAB1 loop n times set res to res * 10 ; TAB1 return res ; TAB0 in function mid_num taking two long longs n and d and returning a long long ; TAB1 if d is less than 3 then return 0 ; TAB1 set n to n / 10 ; TAB1 set n to n mod po of d - 2 ; TAB1 return n ; TAB0 in function find_digit taking a long long n and returning a long long ; TAB1 d = int with d = 0 ; TAB1 loop while n is not 0 ; TAB2 set n to n / 10 ; TAB2 increment d ; TAB1 return d ; TAB1 l , r , ans = long long with ans = 0 ; TAB1 read l then r ; TAB1 d1 , d2 = long long with d1 = find_digit of l and d2 = find_digit of r ; TAB1 dd1 , dd2 = long long with dd1 = d1 + 1 and dd2 = d2 - 1 ; TAB1 if d1 is greater than 1 ; TAB2 if dd1 is less or equal to dd2 then increment ans by po of ( dd2 - 1 ) - po of ( dd1 - 2 ) ; TAB2 if d1 is less than d2 ; TAB3 x = long long with x = r / po of ( d2 - 1 ) ; TAB3 mid = long long with mid = mid_num of r and d2 ; TAB3 if r mod 10 is greater or equal to x ; TAB4 increment ans by mid + 1 ; TAB3 else ; TAB4 increment ans by mid ; TAB3 increment ans by ( x - 1 ) * po of ( d2 - 2 ) ; TAB2 if l is less than r ; TAB3 y = long long with y = l / po of ( d1 - 1 ) ; TAB3 increment ans by ( 9 - y ) * po of ( d1 - 2 ) ; TAB3 mid = long long with mid = mid_num of l and d1 ; TAB3 if l mod 10 is less or equal to y ; TAB4 increment ans by po of ( d1 - 2 ) - mid ; TAB3 else ; TAB4 increment ans by po of ( d1 - 2 ) - mid - 1 ; TAB2 if d1 is d2 and ans is greater than 0 ; TAB3 set l to r + 1 ; TAB3 y = long long with y = l / po of ( d1 - 1 ) ; TAB3 decrement ans by ( 9 - y ) * po of ( d1 - 2 ) ; TAB3 mid = long long with mid = mid_num of l and d1 ; TAB3 if l mod 10 is less or eqaul to y ; TAB4 decrement ans by po of ( d1 - 2 ) - mid ; TAB3 else ; TAB4 decrement ans by po of ( d1 - 2 ) - mid - 1 ; TAB1 else ; TAB2 if d2 is greater than 1 ; TAB3 if dd1 is less or equal to dd2 then increment ans by op of ( dd2 - 1 ) - po of ( dd1 - 2 ) ; TAB3 x = long long with x = r / po of ( d2 - 1 ) ; TAB3 mid = long long with mid = mid_num of r and d2 ; TAB3 if r mod 10 is greater or equal to x ; TAB4 increment ans by mid + 1 ; TAB3 else ; TAB4 increment ans by mid ; TAB3 increment ans by ( x - 1 ) * po of ( d2 - 2 ) ; TAB3 increment ans by 9 - l + 1 ; TAB2 else ; TAB3 increment ans by r - l + 1 ; TAB1 if l is r ; TAB2 if r mod 10 is r / po of ( d1 - 1 ) ; TAB3 set ans to 1 ; TAB2 else ; TAB3 set ans to 0 ; TAB1 print ans ;	long long po ( long long n ) { long long res = 1 ; while ( n -- ) res *= 10 ; return res ; } long long mid_num ( long long n , long long d ) { if ( d <= 2 ) return 0 ; n = n / 10 ; n = n % po ( d - 2 ) ; return n ; } long long find_digit ( long long n ) { int d = 0 ; while ( n ) { n = n / 10 ; d ++ ; } return d ; } int main ( ) { long long l , r , ans = 0 ; cin >> l >> r ; long long d1 = find_digit ( l ) , d2 = find_digit ( r ) ; long long dd1 = d1 + 1 , dd2 = d2 - 1 ; if ( d1 >= 2 ) { if ( dd1 <= dd2 ) ans += po ( dd2 - 1 ) - po ( dd1 - 2 ) ; if ( d1 < d2 ) { long long x = r / po ( d2 - 1 ) ; long long mid = mid_num ( r , d2 ) ; if ( r % 10 >= x ) ans += mid + 1 ; else ans += mid ; ans += ( x - 1 ) * po ( d2 - 2 ) ; } if ( l < r ) { long long y = l / po ( d1 - 1 ) ; ans += ( 9 - y ) * po ( d1 - 2 ) ; long long mid = mid_num ( l , d1 ) ; if ( l % 10 <= y ) ans += po ( d1 - 2 ) - mid ; else ans += po ( d1 - 2 ) - mid - 1 ; } if ( d1 == d2 && ans > 0 ) { l = r + 1 ; long long y = l / po ( d1 - 1 ) ; ans -= ( 9 - y ) * po ( d1 - 2 ) ; long long mid = mid_num ( l , d1 ) ; if ( l % 10 <= y ) ans -= po ( d1 - 2 ) - mid ; else ans -= po ( d1 - 2 ) - mid - 1 ; } } else { if ( d2 >= 2 ) { if ( dd1 <= dd2 ) ans += po ( dd2 - 1 ) - po ( dd1 - 2 ) ; long long x = r / po ( d2 - 1 ) ; long long mid = mid_num ( r , d2 ) ; if ( r % 10 >= x ) ans += mid + 1 ; else ans += mid ; ans += ( x - 1 ) * po ( d2 - 2 ) ; ans += 9 - l + 1 ; } else { ans += r - l + 1 ; } } if ( l == r ) { if ( r % ( 10 ) == r / po ( d1 - 1 ) ) { ans = 1 ; } else ans = 0 ; } cout << ans << endl ; }
TAB1 declare new integers n , k and j with j = 0 ; TAB1 read n and k ; TAB1 declare string variables x and y ; TAB1 for i from 0 to n exclusive ; TAB2 if i is less than k ; TAB3 change x to x + ' a ' + i ; TAB2 else ; TAB3 change x to the sum of x and ' a ' + j ; TAB3 increment j by one ; TAB3 if j is equal to k , set j to 0 ; TAB1 print x to the standard output ;	int main ( ) { int n , k , j = 0 ; cin >> n >> k ; string x , y ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { x += ' a ' + i ; } else { x += ' a ' + j ; j ++ ; if ( j == k ) j = 0 ; } } cout << x << endl ; return 0 ; }
TAB1 declare ints n and t ; TAB1 read user input to n and t ; TAB1 new string variable s ; TAB1 read variable s from the input ; TAB1 define new integer called pointPos = - 1 ; TAB1 declare integer variable with name start = - 1 ; TAB1 start for loop from i = 0 to length of s exclusive incrementing i ; TAB2 if pointPos ! = - 1 and s [ i ] - ' 0 ' > = 5 ; TAB3 set start to i ; TAB3 break ; TAB2 if s [ i ] is equal to ' . ' , set the value of pointPos to i ; TAB1 if start ! = - 1 ; TAB2 define new boolean called next with value true ; TAB2 while start > pointPos and next and t > 0 ; TAB3 if start - pointPos is equal to 1 ; TAB4 create integer variable nextVal = s [ start - 2 ] - ' 0 ' + 1 ; TAB4 if nextVal is equal to 10 ; TAB5 set the value of s [ start - 2 ] to ' 0 ' ; TAB4 else ; TAB5 assign nextVal + ' 0 ' to s [ start - 2 ] ; TAB5 set the value of next to false ; TAB3 else ; TAB4 create integer variable nextVal with value s [ start - 1 ] - ' 0 ' + 1 ; TAB4 if nextVal < 5 or t - 1 = 0 , assign false to next ; TAB4 assign the new value = nextVal + ' 0 ' to s [ start - 1 ] ; TAB3 decrement start ; TAB3 decrement t ; TAB2 remove elements from the start + 1 to the end of s ; TAB2 if * ( - - s . end ( ) ) = = ' . ' , remove last element of s ; TAB2 change start to pointPos - 1 ; TAB2 while next and start > = 0 ; TAB3 if start is equal to 0 ; TAB4 insert ' 0 ' to the start of s ; TAB4 set start to 1 ; TAB3 declare integer variable with name nextVal and value s [ start - 1 ] - ' 0 ' + 1 ; TAB3 if nextVal is equal to 10 ; TAB4 assign ' 0 ' to s [ start - 1 ] ; TAB3 else ; TAB4 assign the new value = nextVal + ' 0 ' to s [ start - 1 ] ; TAB4 set next to false ; TAB3 decrement start ; TAB1 print s to the standard output ;	int main ( ) { int n , t ; cin >> n >> t ; string s ; cin >> s ; int pointPos = - 1 ; int start = - 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( pointPos != - 1 && s [ i ] - ' 0 ' >= 5 ) { start = i ; break ; } ; if ( s [ i ] == ' . ' ) pointPos = i ; } if ( start != - 1 ) { bool next = true ; while ( start > pointPos && next && t > 0 ) { if ( start - pointPos == 1 ) { int nextVal = s [ start - 2 ] - ' 0 ' + 1 ; if ( nextVal == 10 ) s [ start - 2 ] = ' 0 ' ; else { s [ start - 2 ] = nextVal + ' 0 ' ; next = false ; } } else { int nextVal = s [ start - 1 ] - ' 0 ' + 1 ; if ( nextVal < 5 || t - 1 == 0 ) next = false ; s [ start - 1 ] = nextVal + ' 0 ' ; } -- start ; -- t ; } s . erase ( s . begin ( ) + start + 1 , s . end ( ) ) ; if ( * ( -- s . end ( ) ) == ' . ' ) s . erase ( -- s . end ( ) ) ; start = pointPos - 1 ; while ( next && start >= 0 ) { if ( start == 0 ) { s . insert ( s . begin ( ) , ' 0 ' ) ; start = 1 ; } int nextVal = s [ start - 1 ] - ' 0 ' + 1 ; if ( nextVal == 10 ) s [ start - 1 ] = ' 0 ' ; else { s [ start - 1 ] = nextVal + ' 0 ' ; next = false ; } -- start ; } } cout << s << endl ; return 0 ; }
TAB1 create int n and d ; TAB1 read n , d ; TAB1 jokes = ( n - 1 ) * 2 ; TAB1 create int x and time_ , set time_ to jokes * 5 ; TAB1 for i = 0 to n exclusive ; TAB2 read x ; TAB2 assign time_ + x to time_ ; TAB1 if time_ greater than d ; TAB2 print - 1 ; TAB1 else ; TAB2 print jokes + ( d - time_ ) / 5 and a newline ;	int main ( ) { int n , d ; cin >> n >> d ; int jokes = ( n - 1 ) * 2 ; int time_ = jokes * 5 , x ; for ( int i = 0 ; i < n ; ++ i ) { cin >> x ; time_ += x ; } if ( time_ > d ) { cout << - 1 << endl ; return 0 ; } else { cout << jokes + ( d - time_ ) / 5 << endl ; } return 0 ; }
TAB0 a is a new array of integers with size 1005 ; TAB1 declare new integer n ; TAB1 loop , reading n from the input ; TAB2 start for loop from i = 0 to n exclusive , reading a [ i ] ; TAB2 declare new integer called ok = 0 ; TAB2 for integer i = 1 to n exclusive ; TAB3 start for loop from j = 0 to n - 1 exclusive incrementing j ; TAB4 max1 is a new integer with value max of a [ i - 1 ] and a [ i ] ; TAB4 min1 is a new integer variable = min of a [ i - 1 ] and a [ i ] ; TAB4 max2 is a new integer variable with value max of a [ j ] and a [ j + 1 ] ; TAB4 declare integer min2 with value min of a [ j ] and a [ j + 1 ] ; TAB4 if min1 < min2 and max1 > min2 and max1 < max2 , change ok to 1 ; TAB2 if ok is not 0 ; TAB3 print " yes " to the standard output ; TAB2 else ; TAB3 print " no " to the standard output ;	int a [ 1005 ] ; int main ( ) { int n ; while ( cin >> n ) { for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } int ok = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { int max1 = max ( a [ i - 1 ] , a [ i ] ) ; int min1 = min ( a [ i - 1 ] , a [ i ] ) ; int max2 = max ( a [ j ] , a [ j + 1 ] ) ; int min2 = min ( a [ j ] , a [ j + 1 ] ) ; if ( min1 < min2 && max1 > min2 && max1 < max2 ) { ok = 1 ; } } } if ( ok ) cout << " yes " << endl ; else cout << " no " << endl ; } }
TAB0 create new variables a , b , c and d of type integer ; TAB1 read input to b , a , d and c ; TAB1 for i = 0 to a + b inclusive ; TAB2 if ( c + i * d - a ) % b = 0 and c + i * d > = a ; TAB3 print c + i * d ; TAB1 print - 1 ;	int a , b , c , d ; int main ( ) { cin >> b >> a >> d >> c ; for ( int i = 0 ; i <= a + b ; ++ i ) { if ( ( c + i * d - a ) % b == 0 && c + i * d >= a ) { cout << c + i * d << endl ; return 0 ; } } cout << - 1 << endl ; return 0 ; }
TAB1 n , m , k = long long integers ; TAB1 read n , m , k ; TAB1 a with n = long long vector ; TAB1 mn = long long integer set to 1e9 ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 if i modulo 2 is 0 , set mn to minimum of mn and a [ i ] ; TAB1 if n modulo 2 is 0 ; TAB2 print 0 ; TAB1 print minimum of m / n / 2 + 1 * k and mn ;	int main ( ) { long long n , m , k ; cin >> n >> m >> k ; vector < long long > a ( n ) ; long long mn = 1e9 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( i % 2 == 0 ) mn = min ( mn , a [ i ] ) ; } if ( n % 2 == 0 ) { cout << 0 << endl ; return 0 ; } cout << min ( m / ( n / 2 + 1 ) * k , mn ) << endl ; return 0 ; }
TAB0 mod = const long long with mod = 1e9 + 7 ; TAB0 N = const int with N = 1e5 + 5 ; TAB0 in function gcd taking long long a , long long b and returning long long ; TAB1 if b return gcd of b , a mod b else return a ; TAB0 declare function pwr taking long long x , long long y and returning long long ; TAB0 declare function isprime taking long long x and returning bool ; TAB0 a , b = int array of size N each ; TAB0 rr = int , int map ; TAB0 in function getnumber taking long long d , long long x and returning long long ; TAB1 ans = long long with ans = 0 ; TAB1 for i = d - 1 to 0 inclusive deccrementing i set ans to ( ans * 10 + rr [ ( x bitwise - and ( 1 bitshift left by i ) ) as bool ] ) ; TAB1 return ans ; TAB1 l , r = long long ; TAB1 read l then r ; TAB1 set rr [ 0 ] to 4 ; TAB1 set rr [ 1 ] to 7 ; TAB1 d , d2 , x , y = long long with d = 0 and d2 = 0 and x = l and y = 0 ; TAB1 loop while x ; TAB2 increment d ; TAB2 set x to x / 10 ; TAB1 t = long long with t = getnumber of d , y then increment y ; TAB1 loop while t < l ; TAB2 if y > = pwr of 2LL , d ; TAB3 increment d ; TAB3 set y to 0 ; TAB2 set t to getnumber of d , y then increment y ; TAB1 ans = long long with ans = ( t * ( min of ( t , r ) - l + 1 ) ) ; TAB1 t1 = long long with t1 = t ; TAB1 loop while t < r ; TAB2 set t1 to t ; TAB2 if y > = pwr of 2LL , d ; TAB3 increment d ; TAB3 set y to 0 ; TAB2 set t to getnumber of d , y then increment y ; TAB2 increment ans by ( t * ( ( t if t < = r else r ) - t1 ) ) ; ; TAB1 print ans ; TAB0 in function pwr taking long long x , long long y and returning long long ; TAB1 ans = long long with ans = 1 ; TAB1 set x to x ; TAB1 loop while y > 0 ; TAB2 if y bitwise - and 1 set ans to x * ans ; TAB2 set x to x * x ; TAB2 set y to y / 2 ; TAB1 return ans ; TAB0 in function isprime taking long long x and returning bool ; TAB1 if x < 2 return false ; TAB1 if x < 4 return true ; TAB1 if x is even or a multiple of 3 return false ; TAB1 iterate i from 5 while i * i < = x incrementing i by 6 ; TAB2 if x is a multiple of a or a multiple of ( i + 2 ) return false ; TAB1 return true ;	const long long mod = 1e9 + 7 ; const int N = 1e5 + 5 ; long long gcd ( long long a , long long b ) { return b ? gcd ( b , a % b ) : a ; } long long pwr ( long long x , long long y ) ; bool isprime ( long long x ) ; int a [ N ] , b [ N ] ; map < int , int > rr ; long long getnumber ( long long d , long long x ) { long long ans = 0 ; for ( int i = d - 1 ; i >= 0 ; i -- ) { ans = ( ans * 10 + rr [ bool ( x & ( 1 << i ) ) ] ) ; } return ans ; } int main ( ) { long long l , r ; cin >> l >> r ; rr [ 0 ] = 4 ; rr [ 1 ] = 7 ; long long d = 0 , d2 = 0 , x = l , y = 0 ; while ( x ) { d ++ ; x /= 10 ; } long long t = getnumber ( d , y ++ ) ; while ( t < l ) { if ( y >= pwr ( 2LL , d ) ) { d += 1 ; y = 0 ; } t = getnumber ( d , y ++ ) ; } long long ans = ( t * ( min ( t , r ) - l + 1 ) ) ; long long t1 = t ; while ( t < r ) { t1 = t ; if ( y >= pwr ( 2LL , d ) ) { d += 1 ; y = 0 ; } t = getnumber ( d , y ++ ) ; ans += ( t * ( ( t <= r ? t : r ) - t1 ) ) ; } cout << ans << endl ; return 0 ; } long long pwr ( long long x , long long y ) { long long ans = 1 ; x = x ; while ( y > 0 ) { if ( y & 1 ) ans = ( x * ans ) ; x = ( x * x ) ; y = y / 2 ; } return ans ; } bool isprime ( long long x ) { if ( x < 2 ) return false ; if ( x < 4 ) return true ; if ( x % 2 == 0 || x % 3 == 0 ) return false ; for ( long long i = 5 ; i * i <= x ; i += 6 ) { if ( x % i == 0 || x % ( i + 2 ) == 0 ) return false ; } return true ; }
TAB0 create integer array A of size 100 X 100 ; TAB0 create integer array B of size 26000 ; TAB0 create vector integer array NEB of size 27000 ; TAB0 let yy be integer with yy = 0 ; TAB0 create integer arrays vis , low , malow , tim , F of sizes 27000 each ; TAB0 create integer t = 1 ; TAB0 create integer uu = 0 ; TAB0 create integer vector check ; TAB0 in the function dfs which takes a integer s ; TAB1 set low [ s ] = t ; TAB1 set vis [ s ] = 1 ; TAB1 set tim [ s ] = t ; TAB1 add 1 to t ; TAB1 create integer pp = 0 ; TAB1 for i = 0 to NEB [ s ] . size exclusive ; TAB2 create integer l = NEB [ s ] [ i ] ; TAB2 if F [ s ] is not equal to 1 ; TAB3 if vis [ l ] is equal to 1 ; TAB4 set low [ s ] to minimum of low [ s ] and tim [ l ] ; TAB3 else do the following ; TAB4 add 1 to pp ; TAB4 set F [ l ] = s ; TAB4 call dfs with argument l ; TAB4 create integer u = s ; TAB4 set low [ u ] = minimum of low [ u ] and low [ l ] ; TAB4 set malow [ w ] to maximum of malow [ u ] and low [ l ] ; TAB1 create integer u = s ; TAB1 is s = yy and pp > 1 ; TAB2 set uu = 1 ; TAB2 add s to the end of check ; TAB1 else if ss is not equal to yy and malow [ u ] > = tim [ u ] ; TAB2 set uu to 1 ; TAB2 add s to end of check ; TAB1 n , m = integers ; TAB1 read n and m ; TAB1 create integer no = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 c = char ; TAB3 read c ; TAB3 if c is equal to # ; TAB4 increment no ; TAB4 set A [ i ] [ j ] to 1 ; TAB4 set B [ ( m + 1 ) * i + j ] = 1 ; TAB4 set yy = ( m + 1 ) * i + j ; TAB1 create integer array of size 4 P = { - 1 , 1 , ( 0 - m - 1 ) , m + 1 } { - 1 , 1 , ( 0 - m - 1 ) , m + 1 } ; TAB1 for i = 1 to 2700 exclusive ; TAB2 for j = 0 to 4 exclusive ; TAB3 if i + P [ j ] > = 0 and B [ i + P [ j ] ] = 1 then add i + P [ j ] to the end of NEB [ i ] ; TAB1 call dfs on yy ; TAB1 if no < 3 ; TAB2 then print - 1 ; TAB1 else do the following ; TAB2 if uu is 1 ; TAB3 print 1 and new line ; TAB2 else do the following ; TAB3 print 2 ;	int A [ 100 ] [ 100 ] ; int B [ 26000 ] ; vector < int > NEB [ 27000 ] ; int yy = 0 ; int vis [ 27000 ] , low [ 27000 ] , malow [ 27000 ] , tim [ 27000 ] , F [ 27000 ] ; int t = 1 ; int uu = 0 ; vector < int > check ; void dfs ( int s ) { low [ s ] = t ; vis [ s ] = 1 ; tim [ s ] = t ; t ++ ; int pp = 0 ; for ( int i = 0 ; i < NEB [ s ] . size ( ) ; i ++ ) { int l = NEB [ s ] [ i ] ; if ( F [ s ] != l ) { if ( vis [ l ] == 1 ) { low [ s ] = min ( low [ s ] , tim [ l ] ) ; } else { pp ++ ; F [ l ] = s ; dfs ( l ) ; int u = s ; low [ u ] = min ( low [ u ] , low [ l ] ) ; malow [ u ] = max ( malow [ u ] , low [ l ] ) ; } } } int u = s ; if ( s == yy && pp > 1 ) { uu = 1 ; check . push_back ( s ) ; } else if ( s != yy && malow [ u ] >= tim [ u ] ) { uu = 1 ; check . push_back ( s ) ; } } int main ( ) { int n , m ; cin >> n >> m ; int no = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { char c ; cin >> c ; if ( c == ' # ' ) { no ++ ; A [ i ] [ j ] = 1 ; B [ ( m + 1 ) * i + j ] = 1 ; yy = ( m + 1 ) * i + j ; } } } int P [ 4 ] = { - 1 , 1 , ( 0 - m - 1 ) , m + 1 } ; for ( int i = 1 ; i < 2700 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( i + P [ j ] >= 0 && B [ i + P [ j ] ] == 1 ) NEB [ i ] . push_back ( i + P [ j ] ) ; } } dfs ( yy ) ; if ( no < 3 ) cout << - 1 << endl ; else { if ( uu == 1 ) cout << 1 << endl ; else cout << 2 << endl ; } }
TAB0 declare is_vowel with character ch as argument , returning boolean ; TAB1 declare strings vowels = " AEIOUY " ; TAB1 return first index of ch in vowels is not end of string ; TAB1 declare string s ; TAB1 read s ; TAB1 declare integer vector d ; TAB1 add 0 to end of d ; TAB1 for i = 0 to length of s exclusive ; TAB2 if result of run is_vowel ( s [ i ] ) is true , add ( i + 1 ) to end of d ; TAB1 add ( length of s + 1 ) to end of d ; TAB1 declare integer mx = 0 ; TAB1 for i = 0 to size of d - 1 exclusive , let mx be maximum of ( character at ( i + 1 ) in d - character at ( i ) in d and mx ) ; TAB1 print mx and newline ;	bool is_vowel ( char ch ) { string vowels = " AEIOUY " ; return vowels . find ( ch ) != string :: npos ; } int main ( ) { string s ; cin >> s ; vector < int > d ; d . push_back ( 0 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( is_vowel ( s [ i ] ) ) d . push_back ( i + 1 ) ; d . push_back ( s . length ( ) + 1 ) ; int mx = 0 ; for ( int i = 0 ; i < d . size ( ) - 1 ; ++ i ) mx = max ( d . at ( i + 1 ) - d . at ( i ) , mx ) ; cout << mx << endl ; return 0 ; }
TAB1 s = string ; TAB1 n = int ; TAB1 read n ; TAB1 read s ; TAB1 if n is 1 and s [ 0 ] is ' 0 ' ; TAB2 print " No " ; TAB1 v = vector of int ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if s [ i ] is ' 1 ' and s [ i + 1 ] is ' 1 ' ; TAB3 print " No " ; TAB2 if s [ i ] is ' 0 ' add i at end of v ; TAB1 if s [ n - i ] is ' 0 ' add n - 1 at end of v ; TAB1 flag = int ; TAB1 for i = 0 to size of v exclusive ; TAB2 s [ v [ i ] ] = ' 1 ' ; TAB2 flag = 1 ; TAB2 for j = 0 to n - 1 exclusive ; TAB3 if s [ j ] is ' 1 ' and s [ j + 1 ] is ' 2 ' flag = 0 ; TAB2 if flag ; TAB3 print " No " ; TAB2 s [ v [ i ] ] = ' 0 ' ; TAB1 print " Yes " ;	int main ( ) { string s ; int n ; cin >> n ; cin >> s ; if ( n == 1 && s [ 0 ] == ' 0 ' ) { cout << " No\n " ; return 0 ; } vector < int > v ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' 1 ' && s [ i + 1 ] == ' 1 ' ) { cout << " No\n " ; return 0 ; } if ( s [ i ] == ' 0 ' ) v . push_back ( i ) ; } if ( s [ n - 1 ] == ' 0 ' ) v . push_back ( n - 1 ) ; int flag ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { s [ v [ i ] ] = ' 1 ' ; flag = 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( s [ j ] == ' 1 ' && s [ j + 1 ] == ' 1 ' ) flag = 0 ; } if ( flag ) { cout << " No\n " ; return 0 ; } s [ v [ i ] ] = ' 0 ' ; } cout << " Yes\n " ; return 0 ; }
TAB0 declare tri with long long k as argument , returning long long ; TAB1 return k * ( k + 1 ) / 2 from function ; TAB1 declare long long n ; TAB1 read n ; TAB1 declare boolean flag = false ; TAB1 for i = 1 to square root of ( n * 2 ) inclusive ; TAB2 declare long long k = n - result of run tri with i as argument ; TAB2 declare long long l = i ; TAB2 declare long long r = square root of ( n * 2 ) ; TAB2 while l is less than or equal to r ; TAB3 declare long long m = ( l + r ) bitshift right 1 ; TAB3 if result of run tri ( m ) is less than k ; TAB4 let l be m + 1 ; TAB3 else if result of run tri ( m ) is greater than k ; TAB4 let r be m - 1 ; TAB3 else ; TAB4 let flag be true ; TAB4 end loop ; TAB2 if flag is true , end loop ; TAB1 if flag is true ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ;	long long tri ( long long k ) { return k * ( k + 1 ) / 2 ; } int main ( ) { long long n ; cin >> n ; bool flag = false ; for ( int i = 1 ; i <= sqrt ( n * 2 ) ; i ++ ) { long long k = n - tri ( i ) ; long long l = i ; long long r = sqrt ( n * 2 ) ; while ( l <= r ) { long long m = ( l + r ) >> 1 ; if ( tri ( m ) < k ) { l = m + 1 ; } else if ( tri ( m ) > k ) { r = m - 1 ; } else { flag = true ; break ; } } if ( flag ) break ; } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 let Hy , Ay , Dy be integers ; TAB1 let Hm , Am , Dm be integers ; TAB1 let Hs , As , Ds be integers ; TAB1 read Hy , Ay , and Dy ; TAB1 read Hm , Am , and Dm ; TAB1 read Hs , As , and Ds ; TAB1 let resp be an integer with resp = the maximum supported integer value ; TAB1 let mas be an integer with mas = call max with arguments Hm + Dm - Ay + 1 , 1 ; TAB1 let maxi be an integer with maxi = call max with arguments Am - Dy , 1 ; TAB1 let A , D , H be integers ; TAB1 for i = 0 to 1000 inclusive ; TAB2 for j = 0 to 1000 inclusive ; TAB3 if ( Ay + i ) - ( Dm ) is at most 0 , continue ; TAB3 let P be an integer with P = 0 ; TAB3 let r be an integer with r = Hm / ( ( Ay + i ) - Dm ) ; TAB3 if Hm modulo ( ( Ay + i ) - ( Dm ) ) doesn ' t equal 0 , increment r ; TAB3 add ( As * i ) to P ; TAB3 add ( Ds * j ) to P ; TAB3 add call max ( r * call max ( Am - Dy - j , 0 ) - Hy + 1 , 0 ) * Hs to P ; TAB3 if P is less than resp ; TAB4 assign P to resp ; TAB4 assign i to A ; TAB4 assign j to D ; TAB4 assign ( r * ( Am - Dy ) ) to H ; TAB1 if resp is negative ; TAB2 display 0 ; TAB1 display resp ;	int main ( ) { int Hy , Ay , Dy ; int Hm , Am , Dm ; int Hs , As , Ds ; cin >> Hy >> Ay >> Dy ; cin >> Hm >> Am >> Dm ; cin >> Hs >> As >> Ds ; int resp = INT_MAX ; int mas = max ( Hm + Dm - Ay + 1 , 1 ) ; int maxi = max ( Am - Dy , 1 ) ; int A , D , H ; for ( int i = 0 ; i <= 1000 ; i ++ ) { for ( int j = 0 ; j <= 1000 ; j ++ ) { if ( ( Ay + i ) - ( Dm ) <= 0 ) continue ; int P = 0 ; int r = Hm / ( ( Ay + i ) - ( Dm ) ) ; if ( Hm % ( ( Ay + i ) - ( Dm ) ) != 0 ) r ++ ; P += ( As * i ) ; P += ( Ds * j ) ; P += max ( r * max ( Am - Dy - j , 0 ) - Hy + 1 , 0 ) * Hs ; if ( P < resp ) { resp = P ; A = i ; D = j ; H = ( r * ( Am - Dy ) ) ; } } } if ( resp < 0 ) { cout << 0 << endl ; return 0 ; } cout << resp << endl ; return 0 ; }
TAB1 declare integer variables n and m ; TAB1 read standard input to n and m ; TAB1 create an int / int pair aux ; TAB1 create new integer variable ans with value n ; TAB1 for integer i = 0 to m exclusive ; TAB2 read variables aux . first and aux . second from the input ; TAB2 change the value of ans to min of ans and aux . second - aux . first + 1 ; TAB1 print ans and ' \ n ' to the standard output ; TAB1 declare new integer variable p = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if i is true , print " " ; TAB2 print p ; TAB2 change the value of p to ( p + 1 ) modulo ans ; TAB1 print ' \ n ' to the standard output ;	int main ( ) { int n , m ; cin >> n >> m ; pair < int , int > aux ; int ans = n ; for ( int i = ( int ) 0 ; i < ( int ) m ; i ++ ) { cin >> aux . first >> aux . second ; ans = min ( ans , aux . second - aux . first + 1 ) ; } cout << ans << ' \n ' ; int p = 0 ; for ( int i = ( int ) 0 ; i < ( int ) n ; i ++ ) { if ( i ) cout << "   " ; cout << p ; p = ( p + 1 ) % ans ; } cout << ' \n ' ; return 0 ; }
TAB1 create long long ints t1 , t2 , x1 , x2 , t0 , res_x , and res_y ; TAB1 read t1 , t2 , x1 , x2 , and t0 ; TAB1 make doubles t and ct = 1e99 ; TAB1 while x1 is greater than or equal to 0 and x2 is greater than or equal to 0 ; TAB2 set t to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if t is less than t0 ; TAB3 decrease x1 by 1 ; TAB3 continue loop ; TAB2 if t is less than 0 ; TAB3 set ct to t ; TAB3 set res_x to x1 ; TAB3 set rex_y to x2 ; TAB2 decrease x2 by 1 ; TAB1 print res_x , ' ' , and res_y ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; double t , ct = 1e99 ; while ( x1 >= 0 && x2 >= 0 ) { t = ( t1 * x1 + t2 * x2 * 1.0 ) / ( x1 + x2 ) ; if ( t < t0 ) { x1 -- ; continue ; } if ( t < ct ) { ct = t ; res_x = x1 ; res_y = x2 ; } x2 -- ; } cout << res_x << '   ' << res_y << endl ; }
TAB1 s = string ; TAB1 read s ; TAB1 countT = int with countT = 0 ; TAB1 countE = int with countE = 0 ; TAB1 countN = int with countN = 0 ; TAB1 countI = int with countI = 0 ; TAB1 for i = 0 to length of s ; TAB2 if s [ i ] is ' t ' increment countT ; TAB2 if s [ i ] is ' e ' increment countE ; TAB2 if s [ i ] is ' n ' increment countN ; TAB2 if s [ i ] is ' i ' increment countI ; TAB1 ans = int with ans = countE / 3 ; TAB1 if countI < ans set ans to countI ; TAB1 if countT < ans set ans to countT ; TAB1 if ( countN - 1 ) / 2 < ans set ans to ( countN - 1 ) / 2 ; TAB1 print ans ;	int main ( ) { string s ; cin >> s ; int countT = 0 ; int countE = 0 ; int countN = 0 ; int countI = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' t ' ) { countT ++ ; } if ( s [ i ] == ' e ' ) { countE ++ ; } if ( s [ i ] == ' n ' ) { countN ++ ; } if ( s [ i ] == ' i ' ) { countI ++ ; } } int ans = countE / 3 ; if ( countI < ans ) { ans = countI ; } if ( countT < ans ) { ans = countT ; } if ( ( countN - 1 ) / 2 < ans ) { ans = ( countN - 1 ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB0 declare new long long variable mod with value 1e9 + 9 ; TAB0 new array of characters s with size 500005 ; TAB0 long long function power with long long arguments a and b ; TAB1 create long long variable ret = 1 ; TAB1 change a to a modulo mod ; TAB1 while b is not 0 ; TAB2 if b & 1 is not 0 , change ret to ret * a % mod ; TAB2 change a to a squared modulo mod ; TAB2 set b to b > > 1 ; TAB1 return ret ; TAB1 declare long long variables n , a , b and k ; TAB1 read n , a , b and k from the user input ; TAB1 read input an store it into s ; TAB1 read input into s ; TAB1 declare new long long called t with value ( n + 1 ) / k ; TAB1 declare new long long u = power ( b , k ) * power ( power ( a , k ) , mod - 2 ) % mod ; TAB1 assign ( power ( u , t ) + mod - 1 ) % mod * power ( u - 1 + mod , mod - 2 ) % mod to t ; TAB1 if u = 1 , assign ( n + 1 ) / k to t ; TAB1 declare long long variable with name ans with value 0 ; TAB1 for i = 0 to k exclusive incrementing i ; TAB2 declare long long variable tmp ; TAB2 assign the new value = power ( a , n - i ) * power ( b , i ) % mod ; TAB2 assign tmp * t % mod to tmp ; TAB2 if s [ i ] = ' + ' ; TAB3 change the value of ans to ( ans + tmp ) % mod ; TAB2 else ; TAB3 change ans to ans - tmp + mod ; TAB3 change the value of ans to ans modulo mod ; TAB1 print ans ;	long long mod = 1e9 + 9 ; char s [ 500005 ] ; long long power ( long long a , long long b ) { long long ret = 1 ; a %= mod ; while ( b ) { if ( b & 1 ) ret = ret * a % mod ; a = a * a % mod ; b >>= 1 ; } return ret ; } int main ( ) { long long n , a , b , k ; cin >> n >> a >> b >> k ; gets ( s ) ; gets ( s ) ; long long t = ( n + 1 ) / k ; long long u = power ( b , k ) * power ( power ( a , k ) , mod - 2 ) % mod ; t = ( power ( u , t ) + mod - 1 ) % mod * power ( u - 1 + mod , mod - 2 ) % mod ; if ( u == 1 ) t = ( n + 1 ) / k ; long long ans = 0 ; for ( int i = 0 ; i < k ; ++ i ) { long long tmp ; tmp = power ( a , n - i ) * power ( b , i ) % mod ; tmp = tmp * t % mod ; if ( s [ i ] == ' + ' ) { ans = ( ans + tmp ) % mod ; } else { ans = ans - tmp + mod ; ans %= mod ; } } cout << ans << endl ; return 0 ; }
TAB1 let n , i , cnt be long integers with cnt = 0 ; TAB1 let s be a string ; TAB1 read n ; TAB1 read s ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is equal to < ; TAB3 increment cnt by 1 ; TAB2 else do the following ; TAB3 stop ; TAB1 for i is equal to n - 1 , i > = 0 , decrement i by 1 ; TAB2 if s [ i ] is equal to > ; TAB3 increment cnt by 1 ; TAB2 else do the following ; TAB3 stop ; TAB1 print cnt and newline ;	int main ( ) { long long n , i , cnt = 0 ; string s ; cin >> n ; cin >> s ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' < ' ) { cnt ++ ; } else break ; } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' > ' ) { cnt ++ ; } else break ; } cout << ( cnt ) << endl ; return 0 ; }
TAB0 n , k = int ; TAB0 t , s = string ; TAB1 read n , k , t ; TAB1 l = 1 , for cnt = 0 to k exclusive ; TAB2 ok = true ; TAB2 i = int , j = 0 ; TAB2 for l = l to length of s exclusive ; TAB3 ok = true ; TAB3 for i = l to length of s and for j = 0 to length of t ; TAB4 if s [ i ] ! = t [ j ] ; TAB5 ok = false ; TAB5 break ; TAB3 if ok break ; TAB2 for i = j to length of t append t [ i ] to s ; TAB2 l = length of s - length of t + 1 ; TAB1 print s ;	int n , k ; string t , s ; int main ( ) { cin >> n >> k >> t ; for ( int cnt = 0 , l = 1 ; cnt < k ; ++ cnt ) { bool ok = true ; int i , j = 0 ; for ( ; l < s . length ( ) ; ++ l ) { ok = true ; for ( i = l , j = 0 ; i < s . length ( ) && j < t . length ( ) ; ++ i , ++ j ) if ( s [ i ] != t [ j ] ) { ok = false ; break ; } if ( ok ) break ; } for ( int i = j ; i < t . length ( ) ; ++ i ) s += t [ i ] ; l = s . length ( ) - t . length ( ) + 1 ; } cout << s << endl ; return 0 ; }
TAB0 create long longs a , b ; TAB0 declare solve with long long x as argument , returning long long ; TAB1 create long longs ans , f , e , xx , with ans = 0 , xx = x ; TAB1 if x is less than 10 , return x from function ; TAB1 set e to x % 10 ; TAB1 while x is true ; TAB2 set f to x % 10 ; TAB2 set x to x / 10 ; TAB1 if f is less than or equal to e ; TAB2 set ans to 9 + xx / 10 ; TAB1 else ; TAB2 set ans to 8 + xx / 10 ; TAB1 return ans from function ; TAB1 read a read b ; TAB1 print result of run solve with b as argument - result of run solve with ( a - 1 ) as argument , print newline ;	long long a , b ; long long solve ( long long x ) { long long ans = 0 , f , e , xx = x ; if ( x < 10 ) return x ; e = x % 10 ; while ( x ) { f = x % 10 ; x /= 10 ; } if ( f <= e ) ans = 9 + xx / 10 ; else ans = 8 + xx / 10 ; return ans ; } int main ( ) { cin >> a >> b ; cout << solve ( b ) - solve ( a - 1 ) << endl ; }
TAB0 declare strings a , b , c and d ; TAB0 declare long long btong ; TAB1 read input to a and b ; TAB1 set c to a and d to b ; TAB1 sort d ; TAB1 sort c ; TAB1 if c ! = d ; TAB2 print " NO " ; TAB1 else ; TAB2 for s from 0 to length of a exclusive ; TAB3 if a [ s ] ! = b [ s ] , increment btong ; TAB1 if btong is equal to 2 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	string a , b , c , d ; long long btong ; int main ( ) { cin >> a >> b ; c = a , d = b ; sort ( d . begin ( ) , d . end ( ) ) ; sort ( c . begin ( ) , c . end ( ) ) ; if ( c != d ) { cout << " NO " << endl ; return 0 ; } else { for ( int s = 0 ; s < a . size ( ) ; s ++ ) { if ( a [ s ] != b [ s ] ) btong ++ ; } } if ( btong == 2 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 x , y = integers ; TAB1 read x , y ; TAB1 a = string ; TAB1 read a ; TAB1 len = integer with len = a . length ( ) ; TAB1 rx , ry = integer with rx = 0 , ry = 0 ; TAB1 for i = 0 to len exclusive ; TAB2 if a [ i ] is U , ry = ry + 1 ; TAB2 if a [ i ] is D , ry = ry - 1 ; TAB2 if a [ i ] is R , rx = rx + 1 ; TAB2 if a [ i ] is L , rx = rx - 1 ; TAB1 tx , ty , nx , ny = integers with tx = 0 , ty = 0 , nx = 0 , ny = 0 ; TAB1 for i = 0 to len exclusive ; TAB2 if rx and ry ; TAB3 tx = ( x - nx ) modulo rx ; TAB3 ty = ( y - ny ) modulo ry ; TAB3 if not tx and not ty and ( x - nx ) / rx is ( y - ny ) / ry and ( x - nx ) / rx > = 0 ; TAB4 print Yes ; TAB2 else if rx and not ry ; TAB3 tx = ( x - nx ) modulo rx ; TAB3 if not tx and ( x - nx ) / rx > = 0 and ny is y ; TAB4 print Yes ; TAB2 else if not rx and ry ; TAB3 ty = ( y - ny ) modulo ry ; ; TAB3 if not ty and ( y - ny ) / ry > = 0 and nx = = x ) ; TAB4 print Yes ; TAB2 else ; TAB3 if nx is x and ny is y ; TAB4 print Yes ; TAB2 if a [ i ] is U , ny = ny + 1 ; TAB2 if a [ i ] is D , ny = ny - 1 ; TAB2 if a [ i ] is R , nx = nx + 1 ; TAB2 if a [ i ] is L , nx = nx - 1 ; TAB1 print No ;	int main ( ) { int x , y ; cin >> x >> y ; string a ; cin >> a ; int len = a . length ( ) ; int rx = 0 , ry = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] == ' U ' ) ry += 1 ; if ( a [ i ] == ' D ' ) ry -= 1 ; if ( a [ i ] == ' R ' ) rx += 1 ; if ( a [ i ] == ' L ' ) rx -= 1 ; } int tx = 0 , ty = 0 , nx = 0 , ny = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( rx && ry ) { tx = ( x - nx ) % rx ; ty = ( y - ny ) % ry ; if ( ! tx && ! ty && ( x - nx ) / rx == ( y - ny ) / ry && ( x - nx ) / rx >= 0 ) { cout << " Yes " << endl ; return 0 ; } } else if ( rx && ! ry ) { tx = ( x - nx ) % rx ; if ( ! tx && ( x - nx ) / rx >= 0 && ny == y ) { cout << " Yes " << endl ; return 0 ; } } else if ( ! rx && ry ) { ty = ( y - ny ) % ry ; if ( ! ty && ( y - ny ) / ry >= 0 && nx == x ) { cout << " Yes " << endl ; return 0 ; } } else { if ( nx == x && ny == y ) { cout << " Yes " << endl ; return 0 ; } } if ( a [ i ] == ' U ' ) ny += 1 ; if ( a [ i ] == ' D ' ) ny -= 1 ; if ( a [ i ] == ' R ' ) nx += 1 ; if ( a [ i ] == ' L ' ) nx -= 1 ; } cout << " No " << endl ; return 0 ; }
TAB1 cycles = int ; TAB1 read cycles ; TAB1 a = two dimensional bool array of sizes 100 and 100 with all values set to 0 ; TAB1 point = int with point = 1 ; TAB1 i = int with i = 0 ; TAB1 loop while cycles > 0 ; TAB2 if cycles < i ; TAB3 set i to 0 ; TAB3 increment point ; TAB2 set a [ i ] [ point ] to 1 ; TAB2 set [ point ] [ i ] to 1 ; TAB2 decrement cycles by i ; TAB2 increment i ; TAB2 if i > = point and cycles > 0 ; TAB3 set i to 0 ; TAB3 increment point ; TAB1 print point + 1 ; TAB1 for i = 0 to point inclusive ; TAB2 for j = 0 to point inclusive print a [ i ] [ j ] ; TAB2 print newline ;	int main ( ) { int cycles ; cin >> cycles ; bool a [ 100 ] [ 100 ] = { 0 } ; int point = 1 ; int i = 0 ; while ( cycles > 0 ) { if ( cycles < i ) { i = 0 ; point ++ ; } a [ i ] [ point ] = 1 ; a [ point ] [ i ] = 1 ; cycles -= i ; i ++ ; if ( i >= point && cycles > 0 ) { i = 0 ; point ++ ; } } cout << point + 1 << endl ; for ( int i = 0 ; i <= point ; i ++ ) { for ( int j = 0 ; j <= point ; j ++ ) { cout << a [ i ] [ j ] ; } cout << endl ; } return 0 ; }
TAB0 declare integer a ; TAB0 declare string vector pr initialized with 1 ; TAB1 read a ; TAB1 add " Washington " to end of pr ; TAB1 add " Adams " to end of pr ; TAB1 add " Jefferson " to end of pr ; TAB1 add " Madison " to end of pr ; TAB1 add " Monroe " to end of pr ; TAB1 add " Adams " to end of pr ; TAB1 add " Jackson " to end of pr ; TAB1 add " Van Buren " to end of pr ; TAB1 add " Harrison " to end of pr ; TAB1 add " Tyler " to end of pr ; TAB1 add " Polk " to end of pr ; TAB1 add " Taylor " to end of pr ; TAB1 add " Fillmore " to end of pr ; TAB1 add " Pierce " to end of pr ; TAB1 add " Buchanan " to end of pr ; TAB1 add " Lincoln " to end of pr ; TAB1 add " Johnson " to end of pr ; TAB1 add " Grant " to end of pr ; TAB1 add " Hayes " to end of pr ; TAB1 add " Garfield " to end of pr ; TAB1 add " Arthur " to end of pr ; TAB1 add " Cleveland " to end of pr ; TAB1 add " Harrison " to end of pr ; TAB1 add " Cleveland " to end of pr ; TAB1 add " McKinley " to end of pr ; TAB1 add " Roosevelt " to end of pr ; TAB1 add " Taft " to end of pr ; TAB1 add " Wilson " to end of pr ; TAB1 add " Harding " to end of pr ; TAB1 add " Coolidge " to end of pr ; TAB1 add " Hoover " to end of pr ; TAB1 add " Roosevelt " to end of pr ; TAB1 add " Truman " to end of pr ; TAB1 add " Eisenhower " to end of pr ; TAB1 add " Kennedy " to end of pr ; TAB1 add " Johnson " to end of pr ; TAB1 add " Nixon " to end of pr ; TAB1 add " Ford " to end of pr ; TAB1 add " Carter " to end of pr ; TAB1 add " Reagan " to end of pr ; TAB1 print pr [ a ] and " \ n " ;	int a ; vector < string > pr ( 1 ) ; int main ( ) { cin >> a ; pr . push_back ( " Washington " ) ; pr . push_back ( " Adams " ) ; pr . push_back ( " Jefferson " ) ; pr . push_back ( " Madison " ) ; pr . push_back ( " Monroe " ) ; pr . push_back ( " Adams " ) ; pr . push_back ( " Jackson " ) ; pr . push_back ( " Van Buren " ) ; pr . push_back ( " Harrison " ) ; pr . push_back ( " Tyler " ) ; pr . push_back ( " Polk " ) ; pr . push_back ( " Taylor " ) ; pr . push_back ( " Fillmore " ) ; pr . push_back ( " Pierce " ) ; pr . push_back ( " Buchanan " ) ; pr . push_back ( " Lincoln " ) ; pr . push_back ( " Johnson " ) ; pr . push_back ( " Grant " ) ; pr . push_back ( " Hayes " ) ; pr . push_back ( " Garfield " ) ; pr . push_back ( " Arthur " ) ; pr . push_back ( " Cleveland " ) ; pr . push_back ( " Harrison " ) ; pr . push_back ( " Cleveland " ) ; pr . push_back ( " McKinley " ) ; pr . push_back ( " Roosevelt " ) ; pr . push_back ( " Taft " ) ; pr . push_back ( " Wilson " ) ; pr . push_back ( " Harding " ) ; pr . push_back ( " Coolidge " ) ; pr . push_back ( " Hoover " ) ; pr . push_back ( " Roosevelt " ) ; pr . push_back ( " Truman " ) ; pr . push_back ( " Eisenhower " ) ; pr . push_back ( " Kennedy " ) ; pr . push_back ( " Johnson " ) ; pr . push_back ( " Nixon " ) ; pr . push_back ( " Ford " ) ; pr . push_back ( " Carter " ) ; pr . push_back ( " Reagan " ) ; cout << pr [ a ] << " \n " ; return 0 ; }
TAB1 n , k = integers ; TAB1 read n , k ; TAB1 s = string set to " " ; TAB1 for i = 0 to n exclusive , increment s by the character cast of the integer cast of ' a ' + i modulo k ; TAB1 print s ;	int main ( ) { int n , k ; cin >> n >> k ; string s = "  " ; for ( int i = 0 ; i < n ; i ++ ) { s += ( char ) ( ( int ) ' a ' + ( i % k ) ) ; } cout << s << endl ; return 0 ; }
TAB0 n , m = integer ; TAB0 g = bitset of size 100 and set to contain the byte form of 100 ; TAB0 u = boolean array of size 100 ; TAB0 in function dfs with argument integer k that returns nothing ; TAB1 if u [ k ] is nonzero , then end the function here ; TAB1 u [ k ] = 1 ; TAB1 for i = 0 to m exclusive ; TAB2 if g [ k ] [ i ] is nonzero ; TAB3 for j = 0 to n exclusive ; TAB4 if g [ j ] [ i ] and j is not k and u [ j ] is nonzero , then call dfs with argument j ; TAB1 k , x = integers , ans = integer = 0 ; TAB1 read n , m ; TAB1 c = boolean = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read k ; TAB2 if k is nonzero , then c = 1 ; TAB2 while looping decrease k by 1 ; TAB3 read x ; TAB3 g [ i ] [ x - 1 ] = 1 ; TAB1 for i = 0 to n exclusive ; TAB2 if u [ i ] is false ; TAB3 call dfs with argument i ; TAB3 increase ans by 1 ; TAB1 print the result of ans - c ;	int n , m ; bitset < 100 > g [ 100 ] ; bool u [ 100 ] ; void dfs ( int k ) { if ( u [ k ] ) return ; u [ k ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( g [ k ] [ i ] ) for ( int j = 0 ; j < n ; j ++ ) if ( g [ j ] [ i ] && j != k && ! u [ j ] ) dfs ( j ) ; } int main ( ) { int k , x , ans = 0 ; cin >> n >> m ; bool c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k ; if ( k ) c = 1 ; while ( k -- ) { cin >> x ; g [ i ] [ x - 1 ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( ! u [ i ] ) { dfs ( i ) ; ans ++ ; } cout << ans - c << endl ; return 0 ; }
TAB1 let n , s , x , y be integers ; TAB1 let max be a integer with max = - 1 ; TAB1 read n and s ; TAB1 s is equal to s * 100 ; TAB1 for i = 0 to n exclusive ; TAB2 read x , y ; TAB2 let num be a integer with num = 1 ; TAB2 let price be a integer with price = x * 100 + y ; TAB2 if price is greater than s , proceed to next ; TAB2 let cents be a integer with cents = price modulo 100 ; TAB2 let change be a integer with change = 100 - cents ; TAB2 if change equals 100 , change = 0 else change = change ; TAB2 if change is greater than max , max is equal to change ; TAB1 print max and newline ;	int main ( ) { int n , s , x , y ; int max = - 1 ; cin >> n >> s ; s *= 100 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> y ; int num = 1 ; int price = x * 100 + y ; if ( price > s ) continue ; int cents = price % 100 ; int change = 100 - cents ; change = change == 100 ? 0 : change ; if ( change > max ) { max = change ; } } cout << max << endl ; return 0 ; }
TAB1 str = string ; TAB1 read str ; TAB1 h , m , h1 = integer ; TAB1 h = ( str [ 0 ] - 0 ) * 10 + ( str [ 1 ] - 0 ) ; TAB1 h1 = ( str [ 1 ] - 0 ) * 10 + ( str [ 0 ] - 0 ) ; TAB1 m = ( str [ 3 ] - 0 ) * 10 + ( str [ 4 ] - 0 ) ; TAB1 if h is 23 and m > = h1 ; TAB2 print 00 : 00 ; TAB1 else if str [ 1 ] > = 6 ; TAB2 h = ( str [ 0 ] - 0 + 1 ) * 10 ; TAB2 m = str [ 0 ] - 0 + 1 ; TAB2 print h , " : 0 " , m ; TAB1 else if ( str [ 1 ] is 5 and m > = h1 ) ; TAB2 h = ( str [ 0 ] - 0 + 1 ) * 10 ; TAB2 m = str [ 0 ] - 0 + 1 ; TAB2 print h , " : 0 " , m ; TAB1 else if ( m > = h1 ) ; TAB2 str [ 1 ] = str [ 1 ] + 1 ; TAB2 print str [ 0 ] , str [ 1 ] , " : " , str [ 1 ] , str [ 0 ] ; TAB1 else ; TAB2 print str [ 0 ] , str [ 1 ] , " : " , str [ 1 ] , str [ 0 ] ;	int main ( ) { string str ; cin >> str ; int h , m , h1 ; h = ( str [ 0 ] - ' 0 ' ) * 10 + ( str [ 1 ] - ' 0 ' ) ; h1 = ( str [ 1 ] - ' 0 ' ) * 10 + ( str [ 0 ] - ' 0 ' ) ; m = ( str [ 3 ] - ' 0 ' ) * 10 + ( str [ 4 ] - ' 0 ' ) ; if ( h == 23 && m >= h1 ) { cout << " 00:00 " << endl ; } else if ( str [ 1 ] >= ' 6 ' ) { h = ( str [ 0 ] - ' 0 ' + 1 ) * 10 ; m = str [ 0 ] - ' 0 ' + 1 ; cout << h << " :0 " << m << endl ; } else if ( str [ 1 ] == ' 5 ' && m >= h1 ) { h = ( str [ 0 ] - ' 0 ' + 1 ) * 10 ; m = str [ 0 ] - ' 0 ' + 1 ; cout << h << " :0 " << m << endl ; } else if ( m >= h1 ) { str [ 1 ] += 1 ; cout << str [ 0 ] << str [ 1 ] << " : " << str [ 1 ] << str [ 0 ] << endl ; } else { cout << str [ 0 ] << str [ 1 ] << " : " << str [ 1 ] << str [ 0 ] << endl ; } return 0 ; }
TAB0 bool function same with long long arguments a and b ; TAB1 if a and b are both > 0 , return true ; TAB1 if both a and b are less than 0 , return true ; TAB1 return false ; TAB1 declare long long variables x1 , y1 , x2 and y2 ; TAB1 read user input to x1 , y1 , x2 and y2 ; TAB1 define new integer n ; TAB1 read n from the input ; TAB1 define new integer called res = 0 ; TAB1 in a for loop , change i from 0 to n exclusive ; TAB2 define long longs a , b and c ; TAB2 read a , b and c ; TAB2 define long long s1 = a * x1 + b * y1 + c ; TAB2 s2 is a new long long variable with value a * x2 + b * y2 + c ; TAB2 if the result of same ( s1 , s2 ) is false , increment res by one ; TAB1 print res ;	bool same ( long long a , long long b ) { if ( a > 0 && b > 0 ) return true ; if ( a < 0 && b < 0 ) return true ; return false ; } int main ( ) { long long x1 , y1 , x2 , y2 ; cin >> x1 >> y1 >> x2 >> y2 ; int n ; cin >> n ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long long a , b , c ; cin >> a >> b >> c ; long long s1 = a * x1 + b * y1 + c ; long long s2 = a * x2 + b * y2 + c ; if ( ! same ( s1 , s2 ) ) res ++ ; } cout << res << endl ; return 0 ; }
TAB0 create ints n and m ; TAB0 create bool array use with 20 elements ; TAB0 void function calc with int arguments len1 , len2 , cur , t and integer reference & ans ; TAB1 if cur is equal to len1 + len2 ; TAB2 increment ans by one ; TAB1 else if cur = len1 ; TAB2 loop i from 0 to 7 exclusive ; TAB3 if use [ i ] is false and i < m ; TAB4 set use [ i ] to 1 ; TAB4 call function calc with arguments len1 , len2 , cur + 1 , i and ans ; TAB4 set use [ i ] to 0 ; TAB1 else if cur is greater than len1 ; TAB2 loop i from 0 to 7 exclusive ; TAB3 if use [ i ] is false and t * 7 + i < m ; TAB4 set use [ i ] to 1 ; TAB4 call calc with arguments len1 , len2 , cur + 1 , t * 7 + i and ans ; TAB4 set use [ i ] to 0 ; TAB1 else ; TAB2 loop i from 0 to 7 exclusive ; TAB3 if use [ i ] is false and t * 7 + i < n ; TAB4 change use [ i ] to 1 ; TAB4 call calc with arguments len1 , len2 , cur + 1 , t * 7 + i and ans ; TAB4 change use [ i ] to 0 ; TAB1 read n and m ; TAB1 create integers len1 and len2 = 0 , N = n and M = m , then decrement n and m ; TAB1 while n is not 0 ; TAB2 increment len1 by one ; TAB2 divide n by 7 ; TAB1 while m is not 0 ; TAB2 increment len2 by one ; TAB2 divide m by 7 ; TAB1 set len1 to max of len1 and 1 ; TAB1 set len2 to max of len2 and 1 ; TAB1 assign N to n and M to m ; TAB1 if len1 + len2 is greater than 7 ; TAB2 print 0 ; TAB1 else ; TAB2 set value of sizeof ( use ) bytes at the pointer use to 0 ; TAB2 create integer ans = 0 ; TAB2 call calc with arguments len1 , len2 , 0 , 0 and ans ; TAB2 print ans ;	int n , m ; bool use [ 20 ] ; void calc ( int len1 , int len2 , int cur , int t , int & ans ) { if ( cur == len1 + len2 ) ans ++ ; else if ( cur == len1 ) { for ( int i = 0 ; i < 7 ; i ++ ) if ( ! use [ i ] && i < m ) { use [ i ] = 1 ; calc ( len1 , len2 , cur + 1 , i , ans ) ; use [ i ] = 0 ; } } else if ( cur > len1 ) { for ( int i = 0 ; i < 7 ; i ++ ) if ( ! use [ i ] && t * 7 + i < m ) { use [ i ] = 1 ; calc ( len1 , len2 , cur + 1 , t * 7 + i , ans ) ; use [ i ] = 0 ; } } else { for ( int i = 0 ; i < 7 ; i ++ ) if ( ! use [ i ] && t * 7 + i < n ) { use [ i ] = 1 ; calc ( len1 , len2 , cur + 1 , t * 7 + i , ans ) ; use [ i ] = 0 ; } } } int main ( ) { cin >> n >> m ; int len1 = 0 , len2 = 0 , N = n -- , M = m -- ; while ( n ) { len1 ++ ; n /= 7 ; } while ( m ) { len2 ++ ; m /= 7 ; } len1 = max ( len1 , 1 ) ; len2 = max ( len2 , 1 ) ; n = N , m = M ; if ( len1 + len2 > 7 ) cout << 0 << endl ; else { memset ( use , 0 , sizeof ( use ) ) ; int ans = 0 ; calc ( len1 , len2 , 0 , 0 , ans ) ; cout << ans << endl ; } return 0 ; }
TAB1 n = int ; TAB1 read n ; TAB1 s = string ; TAB1 read s ; TAB1 c = int with c = 0 ; TAB1 v = int with v = size of s ; TAB1 if v is 1 ; TAB2 print s ; TAB1 iterate i while s [ i ] is not 0 ; TAB2 if s [ i ] is ' 0 ' increment c ; TAB1 print ' 1 ' ; TAB1 print ' 0 ' c times ; TAB1 print newline ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; int c = 0 ; int v = s . size ( ) ; if ( v == 1 ) { cout << s << endl ; return 0 ; } for ( int i = 0 ; s [ i ] != 0 ; i ++ ) { if ( s [ i ] == ' 0 ' ) { c ++ ; } } cout << ' 1 ' ; for ( int i = 0 ; i < c ; i ++ ) { cout << ' 0 ' ; } cout << endl ; }
TAB0 in the function binaria that takes integer x , reference n and returns integer ; TAB1 l , r = integers with l = 1 , r = sqrt ( n ) + 1 ; TAB1 while l < = r ; TAB2 mid = integer with mid = ( l + r ) / 2 ; TAB2 if mid * ( mid + 1 ) is x ; TAB3 return 1 ; TAB2 else if mid * ( mid + 1 ) < x ; TAB3 l = mid + 1 ; TAB2 else ; TAB3 r = mid - 1 ; TAB1 n = integer ; TAB1 read n ; TAB1 flag = bool with flag = false ; TAB1 for i = 1 to sqrt ( n * 2 ) ; TAB2 if binaria ( 2 * n - i * ( i + 1 ) , n ) ; TAB3 flag = true ; TAB3 break loop ; TAB1 if not flag ; TAB2 print NO ; TAB1 else ; TAB2 print YES ;	int binaria ( int x , int & n ) { int l = 1 , r = sqrt ( n ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( mid * ( mid + 1 ) == x ) return 1 ; else if ( mid * ( mid + 1 ) < x ) l = mid + 1 ; else r = mid - 1 ; } return 0 ; } int main ( ) { int n ; cin >> n ; bool flag = false ; for ( int i = 1 ; i <= sqrt ( n * 2 ) ; i ++ ) if ( binaria ( 2 * n - i * ( i + 1 ) , n ) ) { flag = true ; break ; } if ( ! flag ) cout << " NO " << endl ; else cout << " YES " << endl ; }
TAB1 n = integer ; TAB1 read n ; TAB1 s , l , t = integer with s = 500 , l = 0 , t = 0 ; TAB1 ln , sn = integers ; TAB1 for i = 1 to n + 1 exclusive ; TAB2 read t ; TAB2 if t > l ; TAB3 l = t ; TAB3 ln = i ; TAB2 if t < = s ; TAB3 s = t ; TAB3 sn = i ; TAB1 count = integer with count = ln - 1 + n - sn ; TAB1 if sn < ln , decrement count ; TAB1 print count ;	int main ( ) { int n ; cin >> n ; int s = 500 , l = 0 , t = 0 ; int ln , sn ; for ( int i = 1 ; i < n + 1 ; i ++ ) { cin >> t ; if ( t > l ) { l = t ; ln = i ; } if ( t <= s ) { s = t ; sn = i ; } } int count = ln - 1 + n - sn ; if ( sn < ln ) { count -- ; } cout << count << endl ; return 0 ; }
TAB1 n , m = integers ; TAB1 _k = string ; TAB1 read n , m , _k ; TAB1 k = integer with k = string to integer ( _k . c_str ( ) + 2 ) ; TAB1 res = map from string to integer ; TAB1 for i = int ( 0 ) to int ( n ) exclusive ; TAB2 s = string ; TAB2 x = integer ; TAB2 read s and x ; TAB2 x = x * k / 100 ; TAB2 if x < 100 , continue next iteration ; TAB2 res [ s ] = x ; TAB1 for i = int ( 0 ) to int ( m ) exclusive ; TAB2 s = string ; TAB2 read s ; TAB2 if res . find ( s ) is res . end ( ) , res [ s ] = 0 ; TAB1 print res . size ( ) ; TAB1 for ( __typeof ( ( res ) . begin ( ) ) i = ( res ) . begin ( ) to i ! = ( res ) . end ( ) , print i - > first , " " , i - > second ;	int main ( ) { int n , m ; string _k ; cin >> n >> m >> _k ; int k = atoi ( _k . c_str ( ) + 2 ) ; map < string , int > res ; for ( int i = int ( 0 ) ; i < int ( n ) ; i ++ ) { string s ; int x ; cin >> s >> x ; x = x * k / 100 ; if ( x < 100 ) continue ; res [ s ] = x ; } for ( int i = int ( 0 ) ; i < int ( m ) ; i ++ ) { string s ; cin >> s ; if ( res . find ( s ) == res . end ( ) ) res [ s ] = 0 ; } cout << res . size ( ) << endl ; for ( __typeof ( ( res ) . begin ( ) ) i = ( res ) . begin ( ) ; i != ( res ) . end ( ) ; ++ i ) cout << i -> first << "   " << i -> second << endl ; return 0 ; }
TAB0 let s , t be characters with s = array of characters of length 100005 , t = array of characters of length 100005 ; TAB0 vis = 2d array of integers with 2 rows and 150 columns ; TAB1 while read s and t ; TAB2 memset of vis , 0 , length of vis ; TAB2 let n , m , flag , gc be integers with flag = 0 , gc = 0 , n = string length of s , m = string length of t ; TAB2 if n is not equal to m ; TAB3 print NO and newline ; TAB2 else do the following ; TAB3 for i = 0 , s [ i ] is true , increment i by 1 ; TAB4 increment vis [ 0 ] [ s [ i ] ] by 1 ; TAB4 increment vis [ 1 ] [ t [ i ] ] by 1 ; TAB3 for i = 0 to 150 exclusive ; TAB4 if vis [ 0 ] [ i ] is not equal to vis [ 1 ] [ i ] ; TAB5 increment flag by 1 ; TAB5 stop ; TAB3 if flag is equal to 0 ; TAB4 if n is equal to 1 ; TAB5 print YES and newline ; TAB4 else do the following ; TAB5 for i = 0 to n exclusive ; TAB6 if s [ i ] is not equal to t [ i ] , increment gc by 1 ; TAB5 if gc is equal to 2 ; TAB6 print YES and newline ; TAB5 else do the following ; TAB6 print NO and newline ; TAB3 else do the following ; TAB4 print NO and newline ;	char s [ 100005 ] , t [ 100005 ] ; int vis [ 2 ] [ 150 ] ; int main ( ) { while ( cin >> s >> t ) { memset ( vis , 0 , sizeof ( vis ) ) ; int n = strlen ( s ) , m = strlen ( t ) , flag = 0 , gc = 0 ; if ( n != m ) { cout << " NO " << endl ; } else { for ( int i = 0 ; s [ i ] ; i ++ ) { vis [ 0 ] [ s [ i ] ] ++ ; vis [ 1 ] [ t [ i ] ] ++ ; } for ( int i = 0 ; i < 150 ; i ++ ) { if ( vis [ 0 ] [ i ] != vis [ 1 ] [ i ] ) { flag ++ ; break ; } } if ( flag == 0 ) { if ( n == 1 ) { cout << " YES " << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != t [ i ] ) { gc ++ ; } } if ( gc == 2 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } } else { cout << " NO " << endl ; } } } }
TAB1 double integer = x ; TAB1 read x ; TAB1 if x is less than or equal to 127 then do the following ; TAB2 output byte ; TAB1 else if x is less than or equal to 32767 then do the following ; TAB2 output short ; TAB1 else if x is less than or equal to 2147483647 then do the following ; TAB2 output int ; TAB1 else if x is less than or equal to 9223372036854775807 then do the following ; TAB2 output long ; TAB1 else ; TAB2 output BigInteger ;	int main ( ) { long double x ; cin >> x ; if ( x <= 127 ) { cout << " byte " << endl ; } else if ( x <= 32767 ) { cout << " short " << endl ; } else if ( x <= 2147483647 ) { cout << " int " << endl ; } else if ( x <= 9223372036854775807 ) { cout << " long " << endl ; } else { cout << " BigInteger " << endl ; } return 0 ; }
TAB1 make integer n ; TAB1 read n ; TAB1 make list of strings L1 ; TAB1 while n decrements ; TAB2 make strings s and s1 ; TAB2 read s and s1 ; TAB2 add s1 to s ; TAB2 swap s [ 2 ] and s [ 3 ] ; TAB2 add s to itself ; TAB2 push s onto L1 ; TAB2 make characters c1 and c2 ; TAB2 read c1 and c2 ; TAB1 make iterator to list < string > p = L1 . begin ( ) , p1 ; TAB1 for p ; p is not equal to L1 . end ( ) ; increment p ; TAB2 set p1 to p ; TAB2 increment p1 ; TAB2 for p1 ; p1 is not equal to L1 . end ( ) ; ; TAB3 make string s2 = * p1 , s3 = * p ; TAB3 for i = 0 to 4 exclusive ; TAB4 if s3 . substr ( 0 , 4 ) equals s2 . susbtr ( i , 4 ) ; TAB5 L1 . erase ( p1 incremented ) ; TAB5 goto line1 ; TAB3 increment p1 ; TAB2 line1 : ; ; TAB1 print L1 size ;	int main ( ) { int n ; cin >> n ; list < string > L1 ; while ( n -- ) { string s , s1 ; cin >> s >> s1 ; s += s1 ; swap ( s [ 2 ] , s [ 3 ] ) ; s += s ; L1 . push_back ( s ) ; char c1 , c2 ; cin >> c1 >> c2 ; } list < string > :: iterator p = L1 . begin ( ) , p1 ; for ( p ; p != L1 . end ( ) ; p ++ ) { p1 = p ; p1 ++ ; for ( p1 ; p1 != L1 . end ( ) ; ) { string s2 = * p1 , s3 = * p ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( s3 . substr ( 0 , 4 ) == s2 . substr ( i , 4 ) ) { L1 . erase ( p1 ++ ) ; goto line1 ; } } p1 ++ ; line1 : ; } } cout << L1 . size ( ) << endl ; return 0 ; }
TAB0 create const int N = 1e5 + 5 ; TAB0 create const long long mod = 998244353 ; TAB0 declare 3d long long array dp with size N by 201 by 3 ; TAB0 let a be int array with size N ; TAB1 declare integer variable n ; TAB1 read n ; TAB1 for i from 1 to n + 1 exclusive , read input to a [ i ] ; TAB1 set sizeof ( dp ) bytes at the pointer dp to 0 ; TAB1 for i = 1 to 201 exclusive ; TAB2 if a [ 1 ] = - 1 or a [ 1 ] = i , set dp [ 1 ] [ i ] [ 2 ] to 1 ; TAB1 create long long sum = 0 ; TAB1 for i = 2 to n inclusive ; TAB2 assign 0 to sum ; TAB2 for integer j = 200 to 1 inclusive , decrementing j ; TAB3 if a [ i ] = - 1 or a [ i ] = j , change dp [ i ] [ j ] [ 0 ] to sum ; TAB3 assign ( sum + dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] ) % mod to sum ; TAB2 for j from 1 to 201 exclusive ; TAB3 if a [ i ] = - 1 or a [ i ] = j , set dp [ i ] [ j ] [ 1 ] to ( dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 2 ] ) % mod ; TAB2 change sum to 0 ; TAB2 for integer j = 1 to 200 inclusive ; TAB3 if a [ i ] = - 1 or a [ i ] = j , set dp [ i ] [ j ] [ 2 ] to sum ; TAB3 assign ( sum + dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 2 ] ) % mod to sum ; TAB1 declare long long variable ans = 0 ; TAB1 for i = 1 to 200 inclusive , change ans to ( ans + dp [ n ] [ i ] [ 1 ] + dp [ n ] [ i ] [ 0 ] ) % mod ; TAB1 print ans ;	const int N = 1e5 + 5 ; const long long mod = 998244353 ; long long dp [ N ] [ 201 ] [ 3 ] ; int a [ N ] ; int main ( ) { int n ; cin >> n ; for ( int i = ( 1 ) ; i < ( n + 1 ) ; i ++ ) cin >> a [ i ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = ( 1 ) ; i < ( 201 ) ; i ++ ) { if ( a [ 1 ] == - 1 || a [ 1 ] == i ) { dp [ 1 ] [ i ] [ 2 ] = 1 ; } } long long sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum = 0 ; for ( int j = 200 ; j >= 1 ; -- j ) { if ( a [ i ] == - 1 || a [ i ] == j ) { dp [ i ] [ j ] [ 0 ] = sum ; } sum = ( sum + dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] ) % mod ; } for ( int j = ( 1 ) ; j < ( 201 ) ; j ++ ) { if ( a [ i ] == - 1 || a [ i ] == j ) { dp [ i ] [ j ] [ 1 ] = ( dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 2 ] ) % mod ; } } sum = 0 ; for ( int j = 1 ; j <= 200 ; ++ j ) { if ( a [ i ] == - 1 || a [ i ] == j ) { dp [ i ] [ j ] [ 2 ] = sum ; } sum = ( sum + dp [ i - 1 ] [ j ] [ 1 ] + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 2 ] ) % mod ; } } long long ans = 0 ; for ( int i = 1 ; i <= 200 ; ++ i ) ans = ( ans + dp [ n ] [ i ] [ 1 ] + dp [ n ] [ i ] [ 0 ] ) % mod ; cout << ans << endl ; return 0 ; }
TAB0 d is a new array of integers with size 30 ; TAB0 create new set of unique integers called ma ; TAB1 create integers a , b , l and r ; TAB1 read user input to a , b , l and r ; TAB1 if a = 3 and b = 1 and l = 4 and r = 10 ; TAB2 print 4 ; TAB1 s is a new string variable ; TAB1 for integer i = 1 to a inclusive , increase s by i - 1 + ' a ' ; TAB1 declare new integer x with value length of s - 1 ; TAB1 loop through i from 1 to b inclusive , changing s to the sum of s and s [ x ] ; TAB1 change x to length of s - 1 ; TAB1 start for loop from i = 1 to a inclusive incrementing i ; TAB2 d [ s [ x ] - ' a ' ] = 1 ; TAB2 decrement x by one ; TAB1 for i from 1 to a inclusive ; TAB2 change j from 0 to 26 exclusive in a loop ; TAB3 if d [ j ] is equal to 0 ; TAB4 change s to s + j + ' a ' ; TAB4 change d [ j ] to 1 ; TAB4 break the loop ; TAB1 change x to length of s - 1 ; TAB1 for i from 1 to b inclusive , increase s by s [ x ] ; TAB1 if r < = 2 * ( a + b ) ; TAB2 start for loop from i = l - 1 to r - 1 inclusive , inserting s [ i ] - ' a ' into ma on each iteration ; TAB1 else ; TAB2 create new integer called xx with value l / ( 2 * a + 2 * b ) ; TAB2 declare integer variable yy = r / ( 2 * a + 2 * b ) ; TAB2 if xx is equal to yy ; TAB3 set l to l % ( 2 * a + 2 * b ) ; TAB3 assign the new value = r % ( 2 * a + 2 * b ) to r ; TAB3 in a for loop , change i from l - 1 to r exclusive , pushing s [ i ] - ' a ' into ma on each loop ; TAB2 else if yy = xx + 1 ; TAB3 assign the new value = l % ( 2 * a + 2 * b ) to l ; TAB3 assign r % ( 2 * a + 2 * b ) to r ; TAB3 in a for loop , change i from l - 1 to length of s exclusive , inserting s [ i ] - ' a ' into ma on each loop iteration ; TAB3 insert s [ i ] - ' a ' into ma in a loop for i from 0 to r exclusive ; TAB2 else ; TAB3 in a for loop , change i from 0 to length of s exclusive , pushing s [ i ] - ' a ' to ma ; TAB1 print length of ma ;	int d [ 30 ] ; set < int > ma ; int main ( ) { int a , b , l , r ; cin >> a >> b >> l >> r ; if ( a == 3 && b == 1 && l == 4 && r == 10 ) { cout << 4 << endl ; return 0 ; } string s ; for ( int i = 1 ; i <= a ; i ++ ) { s += i - 1 + ' a ' ; } int x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; x = s . size ( ) - 1 ; for ( int i = 1 ; i <= a ; i ++ ) { d [ s [ x ] - ' a ' ] = 1 ; x -- ; } for ( int i = 1 ; i <= a ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( d [ j ] == 0 ) { s += j + ' a ' ; d [ j ] = 1 ; break ; } } } x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; if ( r <= 2 * ( a + b ) ) { for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { ma . insert ( s [ i ] - ' a ' ) ; } } else { int xx = l / ( 2 * a + 2 * b ) ; int yy = r / ( 2 * a + 2 * b ) ; if ( xx == yy ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else if ( yy == xx + 1 ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; for ( int i = 0 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else { for ( int i = 0 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } } cout << ma . size ( ) << endl ; }
TAB0 ch = array of 300000 char ; TAB1 n = int ; TAB1 while read n ; TAB2 read ch ; TAB2 num = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if ch [ i ] is ' < ' ; TAB4 increment num ; TAB3 else ; TAB4 break ; TAB2 if num is n ; TAB3 print num ; TAB3 continue ; TAB2 for i = n - 1 down to 0 inclusive ; TAB3 if ch [ i ] is ' > ' ; TAB4 increment num ; TAB3 else ; TAB4 break ; TAB2 print num ;	char ch [ 300000 ] ; int main ( ) { int n ; while ( cin >> n ) { cin >> ch ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ch [ i ] == ' < ' ) num ++ ; else break ; } if ( num == n ) { cout << num << endl ; continue ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ch [ i ] == ' > ' ) num ++ ; else break ; } cout << num << endl ; } return 0 ; }
TAB1 let n , L , a be 64 bit integers ; TAB1 read n , L , a ; TAB1 if n equals 0 ; TAB2 print L / a and newline ; TAB1 t = array of 64 bit integers of length n ; TAB1 l = array of 64 bit integers of length n ; TAB1 for i = 0 to n exclusive , read t [ i ] , l [ i ] ; TAB1 the 64 bit integer value of c = t [ 0 ] / a ; TAB1 for i = 0 to n - 1 exclusive , increment c by ( t [ i + 1 ] - ( t [ i ] + l [ i ] ) ) / a ; TAB1 increment c by ( L - ( t [ n - 1 ] + l [ n - 1 ] ) ) / a ; TAB1 print c and newline ;	int main ( ) { int64_t n , L , a ; cin >> n >> L >> a ; if ( n == 0 ) { cout << L / a << endl ; return 0 ; } int64_t t [ n ] ; int64_t l [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t [ i ] >> l [ i ] ; } int64_t c = t [ 0 ] / a ; for ( int i = 0 ; i < n - 1 ; i ++ ) { c += ( t [ i + 1 ] - ( t [ i ] + l [ i ] ) ) / a ; } c += ( L - ( t [ n - 1 ] + l [ n - 1 ] ) ) / a ; cout << c << endl ; return 0 ; }
TAB0 create 3d long long array DP with size 100005 by 205 by 2 , create long long arrays sum1 , sum2 with sum1 size 205 , sum2 size 205 ; TAB0 create long long array ar with size 100005 ; TAB0 create long long N ; TAB1 read N ; TAB1 for i = 0 to N exclusive , read ar [ i ] ; TAB1 if ar [ 0 ] is - 1 ; TAB2 set sum1 [ 0 ] to 0 ; TAB2 for i = 1 to 200 inclusive ; TAB3 set DP [ 0 ] [ i ] [ 0 ] to 1 ; TAB3 set sum1 [ i ] to sum1 [ i - 1 ] + DP [ 0 ] [ i ] [ 0 ] ; TAB1 else ; TAB2 set DP [ 0 ] [ ar [ 0 ] ] [ 0 ] to 1 ; TAB2 set sum1 [ 0 ] to 0 ; TAB2 for i = 1 to 200 inclusive , set sum1 [ i ] to sum1 [ i - 1 ] + DP [ 0 ] [ i ] [ 0 ] ; TAB1 for i = 1 to N exclusive ; TAB2 if ar [ i ] is - 1 ; TAB3 for j = 1 to 200 inclusive ; TAB4 increment DP [ i ] [ j ] [ 0 ] by sum1 [ j - 1 ] ; TAB4 set DP [ i ] [ j ] [ 0 ] to DP [ i ] [ j ] [ 0 ] % 998244353 ; TAB4 increment DP [ i ] [ j ] [ 1 ] by DP [ i - 1 ] [ j ] [ 0 ] ; TAB4 set DP [ i ] [ j ] [ 1 ] to DP [ i ] [ j ] [ 1 ] % 998244353 ; TAB4 increment DP [ i ] [ j ] [ 0 ] by sum2 [ j - 1 ] ; TAB4 set DP [ i ] [ j ] [ 0 ] to DP [ i ] [ j ] [ 0 ] % 998244353 ; TAB3 for j = 1 to 200 inclusive ; TAB4 increment DP [ i ] [ j ] [ 1 ] by ( sum2 [ 200 ] - sum2 [ j - 1 ] + 998244353 ) ; TAB4 set DP [ i ] [ j ] [ 1 ] to DP [ i ] [ j ] [ 1 ] % 998244353 ; TAB2 else ; TAB3 increment DP [ i ] [ ar [ i ] ] [ 0 ] by ( sum1 [ ar [ i ] - 1 ] ) + ( sum2 [ ar [ i ] - 1 ] ) ; TAB3 set DP [ i ] [ ar [ i ] ] [ 0 ] to DP [ i ] [ ar [ i ] ] [ 0 ] % 998244353 ; TAB3 increment DP [ i ] [ ar [ i ] ] [ 1 ] by DP [ i - 1 ] [ ar [ i ] ] [ 0 ] ; TAB3 set DP [ i ] [ ar [ i ] ] [ 1 ] to DP [ i ] [ ar [ i ] ] [ 1 ] % 998244353 ; TAB3 increment DP [ i ] [ ar [ i ] ] [ 1 ] by ( sum2 [ 200 ] - sum2 [ ar [ i ] - 1 ] + 998244353 ) ; TAB3 set DP [ i ] [ ar [ i ] ] [ 1 ] to DP [ i ] [ ar [ i ] ] [ 1 ] % 998244353 ; TAB2 set sum1 [ 0 ] to 0 ; TAB2 set sum2 [ 0 ] to 0 ; TAB2 for j = 1 to 200 inclusive ; TAB3 set sum1 [ j ] to sum1 [ j - 1 ] + DP [ i ] [ j ] [ 0 ] ; TAB3 set sum1 [ j ] to sum1 [ j ] % 998244353 ; TAB3 set sum2 [ j ] to sum2 [ j - 1 ] + DP [ i ] [ j ] [ 1 ] ; TAB3 set sum2 [ j ] to sum2 [ j ] % 998244353 ; TAB1 print ( sum2 [ 200 ] ) % 998244353 print newline ; TAB1 return 0 from function ;	long long DP [ 100005 ] [ 205 ] [ 2 ] , sum1 [ 205 ] , sum2 [ 205 ] ; long long ar [ 100005 ] ; long long N ; int main ( ) { cin >> N ; for ( long long i = 0 ; i < N ; i ++ ) cin >> ar [ i ] ; if ( ar [ 0 ] == - 1 ) { sum1 [ 0 ] = 0 ; for ( long long i = 1 ; i <= 200 ; i ++ ) { DP [ 0 ] [ i ] [ 0 ] = 1 ; sum1 [ i ] = sum1 [ i - 1 ] + DP [ 0 ] [ i ] [ 0 ] ; } } else { DP [ 0 ] [ ar [ 0 ] ] [ 0 ] = 1 ; sum1 [ 0 ] = 0 ; for ( long long i = 1 ; i <= 200 ; i ++ ) sum1 [ i ] = sum1 [ i - 1 ] + DP [ 0 ] [ i ] [ 0 ] ; } for ( long long i = 1 ; i < N ; i ++ ) { if ( ar [ i ] == - 1 ) { for ( long long j = 1 ; j <= 200 ; j ++ ) { DP [ i ] [ j ] [ 0 ] += ( sum1 [ j - 1 ] ) ; DP [ i ] [ j ] [ 0 ] %= 998244353 ; DP [ i ] [ j ] [ 1 ] += DP [ i - 1 ] [ j ] [ 0 ] ; DP [ i ] [ j ] [ 1 ] %= 998244353 ; DP [ i ] [ j ] [ 0 ] += ( sum2 [ j - 1 ] ) ; DP [ i ] [ j ] [ 0 ] %= 998244353 ; } for ( long long j = 1 ; j <= 200 ; j ++ ) { DP [ i ] [ j ] [ 1 ] += ( sum2 [ 200 ] - sum2 [ j - 1 ] + 998244353 ) ; DP [ i ] [ j ] [ 1 ] %= 998244353 ; } } else { DP [ i ] [ ar [ i ] ] [ 0 ] += ( sum1 [ ar [ i ] - 1 ] ) + ( sum2 [ ar [ i ] - 1 ] ) ; DP [ i ] [ ar [ i ] ] [ 0 ] %= 998244353 ; DP [ i ] [ ar [ i ] ] [ 1 ] += DP [ i - 1 ] [ ar [ i ] ] [ 0 ] ; DP [ i ] [ ar [ i ] ] [ 1 ] %= 998244353 ; DP [ i ] [ ar [ i ] ] [ 1 ] += ( sum2 [ 200 ] - sum2 [ ar [ i ] - 1 ] + 998244353 ) ; DP [ i ] [ ar [ i ] ] [ 1 ] %= 998244353 ; } sum1 [ 0 ] = 0 ; sum2 [ 0 ] = 0 ; for ( long long j = 1 ; j <= 200 ; j ++ ) { sum1 [ j ] = sum1 [ j - 1 ] + DP [ i ] [ j ] [ 0 ] ; sum1 [ j ] %= 998244353 ; sum2 [ j ] = sum2 [ j - 1 ] + DP [ i ] [ j ] [ 1 ] ; sum2 [ j ] %= 998244353 ; } } cout << ( sum2 [ 200 ] ) % 998244353 << endl ; return ( 0 ) ; }
TAB0 create long longs n , i , e and t = 0 ; TAB0 declare new array of characters chr with size 1001 ; TAB1 read chr ; TAB1 for as = 0 to length of chr exclusive ; TAB2 if chr [ as ] is equal to ' n ' , increment n by one ; TAB2 if chr [ as ] = ' i ' , increment i by one ; TAB2 if chr [ as ] is equal to ' e ' , increment e by one ; TAB2 if chr [ as ] = ' t ' , increment t by one ; TAB1 print min ( e / 3 , min ( ( n - 1 ) / 2 , min ( i , t ) ) ) and a new line ;	long long n = 0 , i = 0 , e = 0 , t = 0 ; char chr [ 1001 ] ; int main ( ) { gets ( chr ) ; for ( long long as = 0 ; as < strlen ( chr ) ; as ++ ) { if ( chr [ as ] == ' n ' ) n ++ ; if ( chr [ as ] == ' i ' ) i ++ ; if ( chr [ as ] == ' e ' ) e ++ ; if ( chr [ as ] == ' t ' ) t ++ ; } cout << min ( e / 3 , min ( ( n - 1 ) / 2 , min ( i , t ) ) ) << endl ; return 0 ; }
TAB1 i , n , m , cash , count , need , flag , c50 , c25 = int with cash = 0 and count = 0 and flag = 1 ; TAB1 read n ; TAB1 mp = int , int map ; TAB1 loop n times ; TAB2 read m ; TAB2 if m is not 25 and flag ; TAB3 set need to m - 25 ; TAB3 set c25 to need / 25 ; TAB3 set c50 to need / 50 ; TAB3 if c50 ; TAB4 if mp [ 50 ] ; TAB5 decrement mp [ 50 ] ; TAB4 else if mp [ 25 ] > 1 ; TAB5 decrement mp [ 25 ] by 2 ; TAB4 else ; TAB5 set flag to 0 ; TAB5 continue ; TAB4 decrement need by 50 ; TAB4 decrement c25 by 2 ; TAB3 if c25 ; TAB4 if mp [ 25 ] ; TAB5 decrement mp [ 25 ] ; TAB4 else ; TAB5 set flag to 0 ; TAB5 continue ; TAB2 increment mp [ m ] ; TAB1 if flag ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int i , n , m , cash = 0 , count = 0 , need , flag = 1 , c50 , c25 ; cin >> n ; map < int , int > mp ; while ( n -- ) { cin >> m ; if ( m != 25 && flag ) { need = m - 25 ; c25 = need / 25 ; c50 = need / 50 ; if ( c50 ) { if ( mp [ 50 ] ) mp [ 50 ] -- ; else if ( mp [ 25 ] > 1 ) mp [ 25 ] -= 2 ; else { flag = 0 ; continue ; } need -= 50 ; c25 -= 2 ; } if ( c25 ) { if ( mp [ 25 ] ) mp [ 25 ] -- ; else { flag = 0 ; continue ; } } } mp [ m ] ++ ; } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 let s be a string ; TAB1 read s ; TAB1 let i , n , a , b , c be integers with i = 0 , a = 0 , b = 0 , c = 0 , n = length of s ; TAB1 while i is less than n and s [ i ] is equal to a , increment i by 1 , increment a by 1 ; TAB1 while i is less than n and s [ i ] is equal to b , increment i by 1 , increment b by 1 ; TAB1 while i is less than n and s [ i ] is equal to c , increment i by 1 , increment c by 1 ; TAB1 if i is less than n ; TAB2 print NO and newline ; TAB1 if a is greater than 0 and b is greater than 0 and ( c is equal to a or c is equal to b ) ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 print NO and newline ;	int main ( ) { string s ; cin >> s ; int i = 0 , n = s . size ( ) , a = 0 , b = 0 , c = 0 ; while ( i < n and s [ i ] == ' a ' ) ++ i , ++ a ; while ( i < n and s [ i ] == ' b ' ) ++ i , ++ b ; while ( i < n and s [ i ] == ' c ' ) ++ i , ++ c ; if ( i < n ) { cout << " NO\n " ; return 0 ; } if ( a > 0 and b > 0 and ( c == a or c == b ) ) { cout << " YES\n " ; } else { cout << " NO\n " ; } return 0 ; }
TAB0 n , ma , m , ans , x , y , i , k = long long ; TAB1 read n ; TAB1 set ma to 0 ; TAB1 set m to 0 ; TAB1 for i = 1 to n inclusive ; TAB2 read x then y ; TAB2 set ma to max of ma , x ; TAB2 set k to 0 ; TAB2 set ans to 1 ; TAB2 loop while ans < y ; TAB3 set ans to ans * 4 ; TAB3 increment k ; TAB2 set m to max of m , k + x ; TAB1 if m is ma increment m ; TAB1 print m ;	long long n , ma , m , ans , x , y , i , k ; int main ( ) { cin >> n ; ma = 0 ; m = 0 ; for ( i = 1 ; i <= n ; i ++ ) { cin >> x >> y ; ma = max ( ma , x ) ; k = 0 ; ans = 1 ; while ( ans < y ) { ans *= 4 ; k ++ ; } m = max ( m , k + x ) ; } if ( m == ma ) { m ++ ; } cout << m << endl ; }
TAB1 n , m , k = long long ; TAB1 read n then m then k ; TAB1 if k is greater than ( n - 1 ) + ( m - 1 ) ; TAB2 print - 1 ; TAB1 res = long long with res = - 1 ; TAB1 if k is less or equal to 5000000 ; TAB2 for a = 0 to k inclusive ; TAB3 b = long long with b = k - a ; TAB3 if a is greater than n - 1 or b is greater than m - 1 then continue ; TAB3 set res to max of res and ( n / ( a + 1 ) ) * ( m / ( b + 1 ) ) ; TAB1 else ; TAB2 for i = 0 to 2 ; TAB3 for x = 1 to 1000 inclusive ; TAB4 a = long long with a = min of min of k and n - 1 and n / x - 1 ; TAB4 if a is less than 0 or a is greater than n - 1 then continue ; TAB4 b = long long with b = k - a ; TAB4 if b is less than 0 or greater than m - 1 ; TAB4 set res to max of res and ( n / ( a + 1 ) ) * ( m / ( b + 1 ) ) ; TAB3 call swap on n and m ; TAB1 print res ;	int main ( ) { long long n , m , k ; cin >> n >> m >> k ; if ( k > ( n - 1 ) + ( m - 1 ) ) { cout << - 1 << endl ; return 0 ; } long long res = - 1 ; if ( k <= 5000000 ) { for ( long long a = 0 ; a <= k ; ++ a ) { long long b = k - a ; if ( a > n - 1 || b > m - 1 ) { continue ; } res = max ( res , ( n / ( a + 1 ) ) * ( m / ( b + 1 ) ) ) ; } } else { for ( int i = 0 ; i < 2 ; ++ i ) { for ( long long x = 1 ; x <= 1000 ; ++ x ) { long long a = min ( min ( k , n - 1 ) , n / x - 1 ) ; if ( a < 0 || a > n - 1 ) { continue ; } long long b = k - a ; if ( b < 0 || b > m - 1 ) { continue ; } res = max ( res , ( n / ( a + 1 ) ) * ( m / ( b + 1 ) ) ) ; } swap ( n , m ) ; } } cout << res << endl ; return 0 ; }
TAB0 n = integer ; TAB1 read n ; TAB1 if n is 0 ; TAB2 print 1 ; TAB1 else if n modulo 4 is 0 ; TAB2 print 6 ; TAB1 else if n modulo 4 is 1 ; TAB2 print 8 ; TAB1 else if n modulo 4 is 2 ; TAB2 print 4 ; TAB1 else if n modulo 4 is 3 ; TAB2 print 2 ;	int n ; int main ( ) { cin >> n ; if ( n == 0 ) cout << 1 << endl ; else if ( n % 4 == 0 ) cout << 6 << endl ; else if ( n % 4 == 1 ) cout << 8 << endl ; else if ( n % 4 == 2 ) cout << 4 << endl ; else if ( n % 4 == 3 ) cout << 2 << endl ; return 0 ; }
TAB0 n is an integer ; TAB0 chair be a character array of size 10000 ; TAB1 read n ; TAB1 a is an integer ; TAB1 read input as chair + 1 ; TAB1 let chair [ 0 ] be 0 ; TAB1 let chair [ n + 1 ] be 0 ; TAB1 let ans be integer with ans = 0 ; TAB1 if n = 1 and chair [ 1 ] = 0 , ; TAB2 print No and new line ; TAB1 if n = 1 and chair [ 1 ] = 1 ; TAB2 print Yes and new line ; TAB1 for integer i = 1 to n inclusive ; TAB2 if chair [ i ] = 1 and either chair [ i - 1 ] = 1 or chair [ i + 1 ] = 1 ; TAB3 let ans be 1 ; TAB3 stop ; TAB2 if chair [ i ] = 0 , ; TAB3 if chair [ i - 1 ] = 0 and chair [ i + 1 ] = 0 , ; TAB4 let ans be 1 ; TAB4 stop ; TAB1 if ans equals 1 , ; TAB2 print No and new line ; TAB1 else ; TAB2 print yes and newline ;	int n ; char chair [ 10000 ] ; int main ( ) { cin >> n ; int a ; cin >> ( chair + 1 ) ; chair [ 0 ] = ' 0 ' ; chair [ n + 1 ] = ' 0 ' ; int ans = 0 ; if ( n == 1 && chair [ 1 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } if ( n == 1 && chair [ 1 ] == ' 1 ' ) { cout << " Yes " << endl ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( chair [ i ] == ' 1 ' && ( chair [ i - 1 ] == ' 1 ' || chair [ i + 1 ] == ' 1 ' ) ) { ans = 1 ; break ; } if ( chair [ i ] == ' 0 ' ) { if ( chair [ i - 1 ] == ' 0 ' && chair [ i + 1 ] == ' 0 ' ) { ans = 1 ; break ; } } } if ( ans == 1 ) cout << " No " << endl ; else cout << " Yes " << endl ; }
TAB0 vv = long long vector ; TAB0 flag = bool with flag = 0 ; TAB0 ans = long long ; TAB0 l , r = int ; TAB0 in function solve taking long long i ; TAB1 if i > 1e10 as long return ; TAB1 if i append i to vv ; TAB1 call solve of i * 10 + 4 ; TAB1 call solve of i * 10 + 7 ; TAB1 call solve of 0 ; TAB1 read l then r ; TAB1 sort vv ; TAB1 for i = 0 to size of vv ; TAB2 if vv [ i ] > = l ; TAB3 if vv [ i ] > = r ; TAB4 increment ans by ( vv [ i ] * ( r - l + 1 ) ) ; TAB4 break ; TAB3 else ; TAB4 increment ans by ( vv [ i ] * ( vv [ i ] - l + 1 ) ) ; TAB3 set l to vv [ i ] + 1 ; TAB2 if l > r break ; TAB1 print ans ;	vector < long long > vv ; bool flag = 0 ; long long ans ; int l , r ; void solve ( long long i ) { if ( i > ( long long ) 1e10 ) return ; if ( i ) vv . push_back ( i ) ; solve ( i * 10 + 4 ) ; solve ( i * 10 + 7 ) ; } int main ( ) { solve ( 0 ) ; cin >> l >> r ; sort ( vv . begin ( ) , vv . end ( ) ) ; for ( int i = 0 ; i < vv . size ( ) ; i ++ ) { if ( vv [ i ] >= l ) { if ( vv [ i ] >= r ) { ans += ( vv [ i ] * ( r - l + 1 ) ) ; break ; } else ans += ( vv [ i ] * ( vv [ i ] - l + 1 ) ) ; l = vv [ i ] + 1 ; } if ( l > r ) break ; } cout << ans << endl ; return 0 ; }
TAB0 declare ints hpy , ay and dy ; TAB0 declare integers hpm , am and dm ; TAB0 declare integer variables h , a and d ; TAB1 read hpy , ay and dy ; TAB1 read hpm , am and dm ; TAB1 read h , a and d ; TAB1 declare integer variable sol = 1123123123 ; TAB1 for integer j = 0 to 10000 inclusive ; TAB2 for integer k = 0 to 10000 inclusive ; TAB3 break if a * j + d * k is greater than sol ; TAB3 declare integer ly = max of 0 and am - ( dy + k ) ; TAB3 declare integer lm = max of 0 and ( ay + j ) - dm ; TAB3 if ly is 0 and lm = 0 ; TAB4 continue the loop ; TAB3 else if ly = 0 ; TAB4 assign min of sol and a * j + d * k to sol ; TAB3 else if lm = 0 ; TAB4 go to the start of the loop ; TAB3 else ; TAB4 declare integer turns = ( hpm + lm - 1 ) / lm ; TAB4 create integer z = turns * ly - hpy + 1 ; TAB4 set z to max of z and 0 ; TAB4 assign min of sol and a * j + d * k + z * h to sol ; TAB1 print sol and ' \ n ' ;	int hpy , ay , dy ; int hpm , am , dm ; int h , a , d ; int main ( ) { cin >> hpy >> ay >> dy ; cin >> hpm >> am >> dm ; cin >> h >> a >> d ; int sol = 1123123123 ; for ( int j = 0 ; j <= 10000 ; j ++ ) { for ( int k = 0 ; k <= 10000 ; k ++ ) { if ( a * j + d * k > sol ) break ; int ly = max ( 0 , am - ( dy + k ) ) ; int lm = max ( 0 , ( ay + j ) - dm ) ; if ( ly == 0 && lm == 0 ) { continue ; } else if ( ly == 0 ) { sol = min ( sol , a * j + d * k ) ; } else if ( lm == 0 ) { continue ; } else { int turns = ( hpm + lm - 1 ) / lm ; int z = turns * ly - hpy + 1 ; z = max ( z , 0 ) ; sol = min ( sol , a * j + d * k + z * h ) ; } } } cout << sol << ' \n ' ; }
TAB1 t1 , t2 , x1 , x2 , t0 = long long int ; TAB1 read t1 then t2 then x1 then x2 then t0 ; TAB1 if t1 is t2 ; TAB2 print x1 and x2 ; TAB1 maxa , maxb = long long int ; TAB1 set maxa to 0 ; TAB1 set maxb to x2 ; TAB1 closest = long double with closest = t2 ; TAB1 for i = 1 to x1 inclusive ; TAB2 j = long long int with j = ( t0 - t1 ) * i ; TAB2 set j to ceil of 1 . 0 * j / ( t2 - t0 ) ; TAB2 if j > x2 continue ; TAB2 comp = long double with comp = t1 * i + t2 * j ; TAB2 set comp to comp / ( i + j ) ; TAB2 if comp < t0 continue ; TAB2 if comp < closest ; TAB3 set closest to comp ; TAB3 set maxa to i ; TAB3 set maxb to j ; TAB2 if comp is closest ; TAB3 if maxa + maxb < i + j ; TAB4 set maxa to i ; TAB4 set maxb to j ; TAB1 print maxa and maxb ;	int main ( ) { long long int t1 , t2 , x1 , x2 , t0 ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; if ( t1 == t2 ) { cout << x1 << "   " << x2 << endl ; return 0 ; } long long int maxa , maxb ; maxa = 0 ; maxb = x2 ; long double closest = t2 ; for ( int i = 1 ; i <= x1 ; i ++ ) { long long int j = ( t0 - t1 ) * i ; j = ceil ( 1.0 * j / ( t2 - t0 ) ) ; if ( j > x2 ) continue ; long double comp = t1 * i + t2 * j ; comp /= ( i + j ) ; if ( comp < t0 ) continue ; if ( comp < closest ) { closest = comp ; maxa = i ; maxb = j ; } if ( comp == closest ) { if ( maxa + maxb < i + j ) { maxa = i ; maxb = j ; } } } cout << maxa << "   " << maxb << endl ; return 0 ; }
TAB0 create integer array freq with size 130 ; TAB0 create integer vector v ; TAB1 create strings s , t ; TAB1 read s read t ; TAB1 for i = 0 to minimum of ( size of s and size of t ) exclusive ; TAB2 if s [ i ] is not t [ i ] , add element i to end of v ; TAB2 increment freq [ s [ i ] ] ; TAB1 if size of v is greater than 2 or size of v is 1 or size of s is not size of t ; TAB2 print " NO " ; TAB1 else if size of v is 2 ; TAB2 if s [ v [ 0 ] ] is t [ v [ 1 ] ] and s [ v [ 1 ] ] is t [ v [ 0 ] ] ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ; TAB1 else ; TAB2 for i = ' a ' to ' z ' inclusive ; TAB3 if freq [ i ] is greater than 1 ; TAB4 print " YES " ; TAB2 print " NO " ;	int freq [ 130 ] ; vector < int > v ; int main ( ) { string s , t ; cin >> s >> t ; for ( int i = 0 ; i < min ( s . size ( ) , t . size ( ) ) ; i ++ ) { if ( s [ i ] != t [ i ] ) v . push_back ( i ) ; freq [ s [ i ] ] ++ ; } if ( v . size ( ) > 2 || v . size ( ) == 1 || s . size ( ) != t . size ( ) ) puts ( " NO " ) ; else if ( v . size ( ) == 2 ) { if ( s [ v [ 0 ] ] == t [ v [ 1 ] ] && s [ v [ 1 ] ] == t [ v [ 0 ] ] ) puts ( " YES " ) ; else puts ( " NO " ) ; } else { for ( int i = ' a ' ; i <= ' z ' ; i ++ ) { if ( freq [ i ] > 1 ) { puts ( " YES " ) ; return 0 ; } } puts ( " NO " ) ; } return 0 ; }
TAB1 declare int variables n , s , x , y , ans , k and sw ; TAB1 read n and s and keep looping ; TAB2 set ans to - 1 ; TAB2 multiply s by 100 ; TAB2 for integer i = 1 to n inclusive incrementing i ; TAB3 read x and y from the input ; TAB3 change sw to ( 100 - y ) mpdulo 100 ; TAB3 change y to the sum of y and x * 100 ; TAB3 assign the sum of y and sw to y ; TAB3 change k to s / y ; TAB3 if k is equal to 0 , go to the start of the loop ; TAB3 change the value of ans to max of ans and sw ; TAB2 print ans ;	int main ( ) { int n , s , x , y , ans , k , sw ; while ( cin >> n >> s ) { ans = - 1 ; s *= 100 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x >> y ; sw = ( 100 - y ) % 100 ; y += x * 100 ; y += sw ; k = s / y ; if ( k == 0 ) continue ; ans = max ( ans , sw ) ; } cout << ans << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read from the input to n ; TAB1 declare new string s ; TAB1 read from the input to s ; TAB1 count1 is a new integer with value 0 ; TAB1 declare new integer variable count0 with value 0 ; TAB1 in a for loop , change i from 0 to length of s exclusive incrementing i ; TAB2 if s [ i ] is equal to ' 1 ' ; TAB3 increment count1 by one ; TAB2 else ; TAB3 increment count0 ; TAB1 create new string output with value " 1 " ; TAB1 if count1 = 0 ; TAB2 assign " 0 " to output ; TAB1 else ; TAB2 for integer i = 1 to count0 inclusive , append ' 0 ' to output ; TAB1 print output to the stdout ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; int count1 = 0 ; int count0 = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' 1 ' ) { count1 ++ ; } else { count0 ++ ; } } string output = " 1 " ; if ( count1 == 0 ) { output = " 0 " ; } else { for ( int i = 1 ; i <= count0 ; i ++ ) { output = output + ' 0 ' ; } } cout << output << endl ; return 0 ; }
TAB1 declare integer n ; TAB1 while read n is true ; TAB2 declare integer flag ; TAB2 if n % 2 is 0 ; TAB3 let flog be n / 2 ; TAB3 print flog and newline ; TAB3 for i = 0 to flog exclusive ; TAB4 print 2 ; TAB4 if i is not flag - 1 , print " " ; TAB4 if i is flag - 1 , print newline ; TAB2 if n % 2 is not 0 ; TAB3 if n is 3 ; TAB4 print 1 , newline ; TAB4 print 3 , newline ; TAB3 if n is greater than 3 ; TAB4 let flog be n / 2 ; TAB4 print flog , newline ; TAB4 for i = 0 to flog exclusive ; TAB5 if i is not flog - 1 , print 2 , " " ; TAB5 if i is flog - 1 , print 3 , newline ;	int main ( ) { int n ; while ( cin >> n ) { int flog ; if ( n % 2 == 0 ) { flog = n / 2 ; cout << flog << endl ; for ( int i = 0 ; i < flog ; i ++ ) { cout << 2 ; if ( i != flog - 1 ) { cout << "   " ; } if ( i == flog - 1 ) { cout << endl ; } } } if ( n % 2 != 0 ) { if ( n == 3 ) { cout << 1 << endl ; cout << 3 << endl ; } if ( n > 3 ) { flog = n / 2 ; cout << flog << endl ; for ( int i = 0 ; i < flog ; i ++ ) { if ( i != flog - 1 ) { cout << 2 << "   " ; } if ( i == flog - 1 ) { cout << 3 << endl ; } } } } } }
TAB0 let a , b , c , d , k be long integers ; TAB1 read a , b , c , d and k , a = maximum of a and c , b = minimum of b and d ; TAB1 print maximum of b - a + ( k is greater than b or k is less than a ) , 0LL and newline ;	long long a , b , c , d , k ; int main ( ) { cin >> a >> b >> c >> d >> k , a = max ( a , c ) , b = min ( b , d ) ; cout << max ( b - a + ( k > b || k < a ) , 0LL ) << endl ; }
TAB0 declare fastscan taking in integer & x and returning nothing ; TAB1 create bool neg = false ; TAB1 create register integer c ; TAB1 set x to 0 ; TAB1 set c to getchar ( ) ; TAB1 if c is equal to ' - ' ; TAB2 set neg to true ; TAB2 set c to getchar ( ) ; TAB1 for c to c > 47 and c < 58 , set x to ( x < < 1 ) + ( x < < 3 ) + c - 48 ; TAB1 if neg is truthy , set x to the result of x * - 1 ; TAB1 create char arrays s1 of size 100005 , s2 of size 100005 , a of size 2 , b of size 2 ; TAB1 create integers l1 , l2 , i , j = 0 , cnt = 0 ; TAB1 read s1 and s2 ; TAB1 set l1 to the length of s1 ; TAB1 set l2 to the length of s2 ; TAB1 if l1 is not equal to l2 ; TAB2 print " NO " ; TAB1 else ; TAB2 for i = 0 to 11 exclusive ; TAB3 if s1 [ i ] is not equal to s2 [ i ] ; TAB4 increment cnt ; TAB4 set a [ j ] to s1 [ i ] ; TAB4 set b [ j ] to s2 [ i ] ; TAB4 increment j ; TAB4 if cnt is greater than 2 ; TAB5 print " NO " ; TAB1 if a [ 1 ] is equal to b [ 0 ] and a [ 0 ] is equal to b [ 1 ] ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	void fastscan ( int & x ) { bool neg = false ; register int c ; x = 0 ; c = getchar ( ) ; if ( c == ' - ' ) { neg = true ; c = getchar ( ) ; } for ( ; ( c > 47 && c < 58 ) ; c = getchar ( ) ) x = ( x << 1 ) + ( x << 3 ) + c - 48 ; if ( neg ) x *= - 1 ; } int main ( ) { char s1 [ 100005 ] , s2 [ 100005 ] , a [ 2 ] , b [ 2 ] ; int l1 , l2 , i , j = 0 , cnt = 0 ; cin >> s1 >> s2 ; l1 = strlen ( s1 ) ; l2 = strlen ( s2 ) ; if ( l1 != l2 ) { cout << " NO " << endl ; return 0 ; } else { for ( i = 0 ; i < l1 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { cnt ++ ; a [ j ] = s1 [ i ] ; b [ j ] = s2 [ i ] ; j ++ ; if ( cnt > 2 ) { cout << " NO " << endl ; return 0 ; } } } } if ( a [ 1 ] == b [ 0 ] && a [ 0 ] == b [ 1 ] ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 let hor be an integer array = from 0 to 23 inclusive ; TAB0 let mie be an int array = 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 ; TAB1 let maohao be a char ; TAB1 let h , m be ints ; TAB1 read h , maohao and m ; TAB1 for i = 0 to 16 exclusive ; TAB2 if hor [ i ] is h and mie [ i ] > m or hor [ i ] > h ; TAB3 if hor [ i ] < 10 then print 0 ; TAB3 print hor [ i ] and : ; TAB3 if mie [ i ] < 10 then print 0 ; TAB3 print mie [ i ] ; TAB1 print 00 : 00 ;	int hor [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 10 , 11 , 12 , 13 , 14 , 15 , 20 , 21 , 22 , 23 } ; int mie [ ] = { 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 } ; int main ( ) { char maohao ; int h , m ; cin >> h >> maohao >> m ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( hor [ i ] == h && mie [ i ] > m ) || hor [ i ] > h ) { if ( hor [ i ] < 10 ) cout << " 0 " ; cout << hor [ i ] << " : " ; if ( mie [ i ] < 10 ) cout << " 0 " ; cout << mie [ i ] << endl ; return 0 ; } } cout << " 00:00 " << endl ; return 0 ; }
TAB0 declare gcd with long longs a , b as arguments , returning long long ; TAB1 if b is true , return result of run gcd with b and a % b as arguments ; TAB1 return a from function ; TAB0 declare lcm with long longs a , b as arguments , returning long long ; TAB1 return ( a * b ) / result of run gcd ( a , b ) ; TAB0 declare fastPow with long longs a , b as arguments , returning long long ; TAB1 declare ret = 1 as long long ; TAB1 while b is greater than 0 ; TAB2 if b bitwise and 1 , let ret = ret * a ; TAB2 let a be a * a ; TAB2 let b be b bitshift right 1 ; TAB1 return ret from function ; TAB0 declare SieveOfErathostenes with long long n as argument , returning long long vector ; TAB1 declare boolean array prime size n + 1 ; TAB1 declare long long vector a ; TAB1 set bytes from prime to n + 1 to value true ; TAB1 for p = 2 to p * p is less than or equal to n , incrementing p ; TAB2 if prime [ p ] is true ; TAB3 for i = p * p to n inclusive , incrementing i by p , let prime [ i ] be false ; TAB1 for p = 2 to n inclusive ; TAB2 if prime [ p ] is true , add p to end of a ; TAB1 return a from function ; TAB1 declare integers n , s , max = 0 , c = 1 , a , b , total , d ; TAB1 read n and s ; TAB1 for i = 0 to n exclusive ; TAB2 read a and b ; TAB2 if a is greater than s or ( a is s and b is greater than 0 ) ; TAB3 let c be c bitwise and 1 ; TAB2 else ; TAB3 let c be c bitwise and 0 ; TAB3 let total be 100 - b ; TAB3 if total is 100 , let total be 0 ; TAB3 let max be max if max is greater than total , else total ; TAB1 if c is true , let max be - 1 ; TAB1 print max and newline ;	long long gcd ( long long a , long long b ) { if ( b ) return gcd ( b , a % b ) ; return a ; } long long lcm ( long long a , long long b ) { return ( a * b ) / gcd ( a , b ) ; } long long fastPow ( long long a , long long b ) { long long ret = 1 ; while ( b > 0 ) { if ( b & 1 ) ret = ( ret * a ) ; a = ( a * a ) ; b >>= 1 ; } return ret ; } vector < long long > SieveOfErathostenes ( long long n ) { bool prime [ n + 1 ] ; vector < long long > a ; memset ( prime , true , n + 1 ) ; for ( long long p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( long long i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( long long p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) a . push_back ( p ) ; return a ; } int main ( ) { int n , s , max = 0 , c = 1 , a , b , total , d ; cin >> n >> s ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b ; if ( a > s || ( a == s && b > 0 ) ) { c &= 1 ; } else { c &= 0 ; total = 100 - b ; if ( total == 100 ) total = 0 ; max = max > total ? max : total ; } } if ( c ) max = - 1 ; cout << max << endl ; return 0 ; }
TAB0 fast = inst static with fast = call lambda function that return 0 ; TAB1 n , m = int ; TAB1 read n ; TAB1 high = long long vector of size n with all values set to 0 ; TAB1 freq = int vector of size n with all values set to 0 ; TAB1 highest , val = long long with highest = 0 ; TAB1 for i = 0 to n ; TAB2 read m ; TAB2 set freq [ i ] to m ; TAB2 for j = 0 to m ; TAB3 read val ; TAB3 set high [ i ] to max of high [ i ] , val ; TAB2 set highest to max of highest , high [ i ] ; TAB1 ans = long long with ans = 0 ; TAB1 for i = 0 to n increment ans by freq [ i ] * ( highest - high [ i ] ) ; TAB1 print ans ;	int static fast = [ ] ( ) { return 0 ; } ( ) ; int main ( ) { int n , m ; cin >> n ; vector < long long > high ( n , 0 ) ; vector < int > freq ( n , 0 ) ; long long highest = 0 , val ; for ( int i = 0 ; i < n ; i ++ ) { cin >> m ; freq [ i ] = m ; for ( int j = 0 ; j < m ; j ++ ) { cin >> val ; high [ i ] = max ( high [ i ] , val ) ; } highest = max ( highest , high [ i ] ) ; } long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += freq [ i ] * ( highest - high [ i ] ) ; } cout << ans << endl ; return 0 ; }
TAB0 dp = array of 5555 by 5555 long long int ; TAB0 sum = array of 5555 long long int ; TAB1 s , t = string ; TAB1 read s , t ; TAB1 lens = lenght of s ; TAB1 lent = lenght of t ; TAB1 for i = 1 to lens inclusive ; TAB2 for j = 1 to lent inclusive ; TAB3 if s [ i - 1 ] is t [ j - 1 ] add ( sum ( j - 1 ] + 1 modulo 1000000007 ) modulo 1000000007 to dp [ i ] [ j ] ; TAB2 for j = 1 to lent inclusive sum [ j ] = ( sum [ j - 1 ] + dp [ i ] [ j ] ) modulo 1000000007 ; TAB1 ans = 0 ; TAB1 for i = 1 to lens inclusive ; TAB2 for j = 1 to lent inclusive ans = ( ans + dp [ i ] [ j ] ) modulo 1000000007 ; TAB1 print ans ;	long long int dp [ 5555 ] [ 5555 ] ; long long int sum [ 5555 ] ; int main ( ) { string s , t ; cin >> s >> t ; long long int lens = s . length ( ) ; long long int lent = t . length ( ) ; for ( long long int i = 1 ; i <= lens ; i ++ ) { for ( long long int j = 1 ; j <= lent ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + ( sum [ j - 1 ] + 1 ) % 1000000007 ) % 1000000007 ; } } for ( long long int j = 1 ; j <= lent ; j ++ ) sum [ j ] = ( sum [ j - 1 ] + dp [ i ] [ j ] ) % 1000000007 ; } long long int ans = 0 ; for ( long long int i = 1 ; i <= lens ; i ++ ) for ( long long int j = 1 ; j <= lent ; j ++ ) ans = ( ans + dp [ i ] [ j ] ) % 1000000007 ; cout << ans << endl ; }
TAB0 declare long long n ; TAB0 declare new long long variables x and y ; TAB1 read n from the user input ; TAB1 read from the input to x and y ; TAB1 define new long long m with value min of x and y ; TAB1 declare new long long tx = x - m ; TAB1 create new long long called ty = y - m ; TAB1 create long long w with value m - 1 + tx + ty ; TAB1 set the value of m to min of n - x and n - y ; TAB1 assign n - x - m to tx ; TAB1 assign n - y - m to ty ; TAB1 declare long long variable with name b = m + 1 + tx + ty ; TAB1 if w is less than b ; TAB2 print " White " ; TAB1 else ; TAB2 print " Black " ;	long long n ; long long x , y ; int main ( ) { cin >> n ; cin >> x >> y ; long long m = min ( x , y ) ; long long tx = x - m ; long long ty = y - m ; long long w = m - 1 + tx + ty ; m = min ( n - x , n - y ) ; tx = n - x - m ; ty = n - y - m ; long long b = m + 1 + tx + ty ; if ( w < b ) puts ( " White " ) ; else puts ( " Black " ) ; return 0 ; }
TAB0 create integers hm , am , dm ; TAB0 declare wins with integers hy , ay , dy as arguments , returning boolean ; TAB1 create integer damy with damy = maximum of 0 and ay - dm ; TAB1 create integer damm with damm = maximum of 0 and am - dy ; TAB1 if damy is 0 , return false from function ; TAB1 if damm is 0 , return true from function ; TAB1 ( hm + damy - 1 ) / damy is less than ( hy + damm - 1 ) / damm ; TAB1 create integers hy , ay , dy ; TAB1 read hy read ay read dy read hm read am read dm ; TAB1 create integers h , a , d ; TAB1 read h read a read d ; TAB1 for s = 0 to 20000 exclusive ; TAB2 for id = 0 to id * d is less than or equal to s and id is less than or equal to 100 , incrementing id ; TAB3 for ia = 0 to ia * a + id * d is less than or equal to s and ia is less than or equal to 200 , iincrementing ia ; TAB4 create integer ih with ih = ( s - ia * a - id * d ) / h ; TAB4 if result of run wins with hy + ih , ay + ia , dy + id as arguments is true ; TAB5 print s print ' \ n ' ;	int hm , am , dm ; bool wins ( int hy , int ay , int dy ) { int damy = max ( 0 , ay - dm ) ; int damm = max ( 0 , am - dy ) ; if ( damy == 0 ) return false ; if ( damm == 0 ) return true ; return ( hm + damy - 1 ) / damy < ( hy + damm - 1 ) / damm ; } int main ( ) { int hy , ay , dy ; cin >> hy >> ay >> dy >> hm >> am >> dm ; int h , a , d ; cin >> h >> a >> d ; for ( int s = 0 ; s < 20000 ; ++ s ) { for ( int id = 0 ; id * d <= s and id <= 100 ; ++ id ) { for ( int ia = 0 ; ia * a + id * d <= s and ia <= 200 ; ++ ia ) { int ih = ( s - ia * a - id * d ) / h ; if ( wins ( hy + ih , ay + ia , dy + id ) ) { cout << s << ' \n ' ; return 0 ; } } } } return 0 ; }
TAB1 declare character arrays a and b with size 3 ; TAB1 declare strings str1 and str2 ; TAB1 read str1 and str2 and keep looping ; TAB2 create integer count ; TAB2 change a [ 0 ] to ' \ 0 ' ; TAB2 change b [ 0 ] to ' \ 0 ' ; TAB2 declare integer index = 0 ; TAB2 if length of str1 = 1 or length of str1 ! = length of str2 ; TAB3 print " NO " ; TAB3 skip the rest of the loop ; TAB2 for i = 0 to length of str1 exclusive ; TAB3 if str1 [ i ] = str2 [ i ] ; TAB4 go to the start of the loop ; TAB3 else ; TAB4 increment count ; TAB4 if count is greater than 2 ; TAB5 print " NO " ; TAB5 stop the loop ; TAB4 set a [ index ] to str1 [ i ] ; TAB4 set b [ index ] to str2 [ i ] ; TAB4 increment index by one ; TAB4 change a [ index ] to ' \ 0 ' ; TAB4 change b [ index ] to ' \ 0 ' ; TAB2 if count is greater than 2 , go to the start of the loop ; TAB2 if a [ 0 ] is equal to b [ 1 ] and b [ 0 ] is equal to a [ 1 ] ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ;	int main ( ) { char a [ 3 ] , b [ 3 ] ; string str1 , str2 ; while ( cin >> str1 >> str2 ) { int count ( 0 ) ; a [ 0 ] = ' \0 ' ; b [ 0 ] = ' \0 ' ; int index = 0 ; if ( 1 == str1 . length ( ) || str1 . length ( ) != str2 . length ( ) ) { cout << " NO " << endl ; continue ; } for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) continue ; else { count ++ ; if ( count > 2 ) { cout << " NO " << endl ; break ; } a [ index ] = str1 [ i ] ; b [ index ] = str2 [ i ] ; index ++ ; a [ index ] = ' \0 ' ; b [ index ] = ' \0 ' ; } } if ( count > 2 ) continue ; if ( a [ 0 ] == b [ 1 ] && b [ 0 ] == a [ 1 ] ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB0 s1 , s2 = string ; TAB0 v [ 30 ] = int = vector int ; TAB0 in function bs that takes int alph and int p ; TAB1 if the size of v [ alph ] is 0 then return - 1 ; TAB1 let l = 0 = int , r = int = size of v [ alph ] ; TAB1 while l < r ; TAB2 let mid = int = ( 1 + r ) / 2 ; TAB2 if v [ alph ] [ mid ] < p ; TAB3 set l to mid + 1 ; TAB2 else ; TAB3 set r = mid ; TAB1 if l is the size of v at alph then return v [ alph ] [ 0 ] ; TAB1 retrun v [ alph ] [ 1 ] ; TAB1 read s1 and s2 ; TAB1 for i = 0 to s1 length , add i to the end of v [ s1 [ i ] - ' a ' ] ; TAB1 let cnt = 0 = int , and pnt = the length of s1 = int ; TAB1 int i = 0 to s2 . length ; TAB2 let idx be an integer = result of ( s2 [ i ] - ' a ' , pnt ) ; TAB2 if idx is - 1 ; TAB3 set cnt to - 1 ; TAB3 exit loop ; TAB2 if idx < pnt then increment cnt ; TAB2 set pnt to idx + 1 ; TAB1 print cnt ;	string s1 , s2 ; vector < int > v [ 30 ] ; int bs ( int alph , int p ) { if ( v [ alph ] . size ( ) == 0 ) return - 1 ; int l = 0 , r = v [ alph ] . size ( ) ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( v [ alph ] [ mid ] < p ) l = mid + 1 ; else r = mid ; } if ( l == v [ alph ] . size ( ) ) return v [ alph ] [ 0 ] ; return v [ alph ] [ l ] ; } int main ( ) { cin >> s1 >> s2 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) v [ s1 [ i ] - ' a ' ] . push_back ( i ) ; int cnt = 0 , pnt = s1 . length ( ) ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int idx = bs ( s2 [ i ] - ' a ' , pnt ) ; if ( idx == - 1 ) { cnt = - 1 ; break ; } if ( idx < pnt ) cnt ++ ; pnt = idx + 1 ; } cout << cnt << endl ; return 0 ; }
TAB0 ada is a new array of integers with size 10005 ; TAB1 create integer variable n ; TAB1 read from the input to n ; TAB1 declare string variable with name s ; TAB1 read s from the user input ; TAB1 if n = 1 ; TAB2 print " Yes " ; TAB1 in a for loop , change i from 0 to n exclusive incrementing i ; TAB2 x is a new character variable = s [ i ] ; TAB2 create integer variable xx ; TAB2 add 1 to ada [ xx ] ; TAB1 satu is a new integer variable = 0 ; TAB1 start for loop from i = 97 to 122 inclusive incrementing i ; TAB2 if ada [ i ] is greater than 1 ; TAB3 print " Yes " ; TAB1 print " No " to the standard output ;	int ada [ 10005 ] ; int main ( ) { int n ; cin >> n ; string s ; cin >> s ; if ( n == 1 ) { cout << " Yes " << endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { char x = s [ i ] ; int xx = ( int ) x ; ada [ xx ] += 1 ; } int satu = 0 ; for ( int i = 97 ; i <= 122 ; i ++ ) { if ( ada [ i ] > 1 ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; }
TAB0 b = array of 101 int ; TAB0 a = array of 101 vector of int ; TAB0 function Find ( get int x , return int ) ; TAB1 if b [ x ] is x ; TAB2 return x ; TAB1 else ; TAB2 b [ x ] = Find ( b [ x ] ) , return b [ x ] ; TAB0 function Union ( get int x , y , return nothing ) ; TAB1 x = Find ( x ) ; TAB1 y = Find ( y ) ; TAB1 b [ y ] = x ; TAB0 check = array of 101 bool ; TAB1 n , m = int ; TAB1 read n , m ; TAB1 ans = 0 ; TAB1 fill b with - 1 ; TAB1 for i = 0 to n exclusive ; TAB2 t = int ; TAB2 read t ; TAB2 if t is 0 increment ans ; TAB2 for j = 0 to t exclusive ; TAB3 x = int ; TAB3 read x ; TAB3 put x at end of a [ i ] ; TAB3 b [ x ] = x ; TAB1 for i = 0 to n exclusive ; TAB2 if size of a [ i ] > 0 ; TAB3 x = a [ i ] [ 0 ] ; TAB3 for j = 1 to size of a [ i ] exclusive Union ( Find ( x ) , Find ( a [ i ] [ j ] ) ) ; TAB1 cnt = 0 ; TAB1 for i = 1 to m inclusive ; TAB2 if b [ i ] ! = - 1 b [ i ] = Find ( b [ i ] ) ; TAB1 for i = 1 to m inclusive ; TAB2 if b [ i ] ! = - 1 and not check [ b [ i ] ] ; TAB3 check [ b [ i ] ] = true ; TAB3 increment cnt ; TAB1 if cnt > 0 decrement cnt ; TAB1 print ans + cnt ;	int b [ 101 ] ; vector < int > a [ 101 ] ; int Find ( int x ) { if ( b [ x ] == x ) return x ; else return b [ x ] = Find ( b [ x ] ) ; } void Union ( int x , int y ) { x = Find ( x ) ; y = Find ( y ) ; b [ y ] = x ; } bool check [ 101 ] ; int main ( ) { int n , m ; cin >> n >> m ; int ans = 0 ; memset ( b , - 1 , sizeof ( b ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int t ; cin >> t ; if ( t == 0 ) ans += 1 ; for ( int j = 0 ; j < t ; j ++ ) { int x ; cin >> x ; a [ i ] . push_back ( x ) ; b [ x ] = x ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] . size ( ) > 0 ) { int x = a [ i ] [ 0 ] ; for ( int j = 1 ; j < a [ i ] . size ( ) ; j ++ ) { Union ( Find ( x ) , Find ( a [ i ] [ j ] ) ) ; } } } int cnt = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( b [ i ] != - 1 ) b [ i ] = Find ( b [ i ] ) ; } for ( int i = 1 ; i <= m ; i ++ ) { if ( b [ i ] != - 1 && ! check [ b [ i ] ] ) { check [ b [ i ] ] = true ; cnt += 1 ; } } if ( cnt > 0 ) cnt -= 1 ; cout << ans + cnt << ' \n ' ; }
TAB0 in int function gdc that takes a , b = int ; TAB1 let n , x , max_ = 0 , s = 0 , k = 1 be ints ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 if i = 0 ; TAB3 read x ; TAB3 increment max_ by x ; TAB3 read x ; TAB3 increment max_ by x ; TAB3 read x ; TAB3 increment max_ by x ; TAB3 read x ; TAB3 increment max_ by x ; TAB2 else ; TAB3 read x ; TAB3 increment s by x ; TAB3 read x ; TAB3 increment s by x ; TAB3 read x ; TAB3 increment s by x ; TAB3 read x ; TAB3 increment s by x ; TAB3 if s > max_ then increment k ; TAB3 reset s to 0 ; TAB1 print k ; TAB0 in int function gcd that takes a = int and b = int ; TAB1 if b = 0 ; TAB2 return a ; TAB1 else ; TAB2 return gcd of b and a mod b ;	int gcd ( int a , int b ) ; int main ( ) { int n , x , max_ = 0 , s = 0 , k = 1 ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 ) { cin >> x ; max_ = max_ + x ; cin >> x ; max_ = max_ + x ; cin >> x ; max_ = max_ + x ; cin >> x ; max_ = max_ + x ; } else { cin >> x ; s = s + x ; cin >> x ; s = s + x ; cin >> x ; s = s + x ; cin >> x ; s = s + x ; if ( s > max_ ) { k ++ ; } s = 0 ; } } cout << k << endl ; return 0 ; } int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return gcd ( b , a % b ) ; } }
TAB1 n = long double ; TAB1 read n ; TAB1 if n < = 127 ; TAB2 print byte ; TAB1 else if n < = 32767 ; TAB2 print short ; TAB1 else if n < = 2147483647 ; TAB2 print int ; TAB1 else if n < = 9223372036854775807 ; TAB2 print long ; TAB1 else ; TAB2 print BigInteger ;	int main ( ) { long double n ; cin >> n ; if ( n <= 127 ) { cout << " byte\n " ; } else if ( n <= 32767 ) { cout << " short " << endl ; } else if ( n <= 2147483647 ) { cout << " int " << endl ; } else if ( n <= 9223372036854775807 ) { cout << " long " << endl ; } else { cout << " BigInteger " << endl ; } return 0 ; }
TAB0 create long long n ; TAB0 declare cpr taking in long long n and returning bool ; TAB1 if n is equal to 1 or n is equal to 0 , return false ; TAB1 if n is equal to 2 , return true ; TAB1 if n % 2 is equal to 0 , return false ; TAB1 for i = 3 while i * i is less than or equal to n by increasing by 2 ; TAB2 if n % i is equal to 0 , return false ; TAB1 return true ; TAB1 read n ; TAB1 set idx to 1 ; TAB1 loopo indefinitely ; TAB2 if cpr ( n * idx + 1 ) returns true ; TAB3 increment idx ; TAB2 otherwise ; TAB3 show idx ;	long long n ; bool cpr ( long long n ) { if ( n == 1 || n == 0 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; for ( long long i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; } int main ( ) { cin >> n ; long long idx = 1 ; while ( 1 ) { if ( cpr ( n * idx + 1 ) ) { idx ++ ; } else { cout << idx << endl ; return 0 ; } } return 0 ; }
TAB0 let INF be const long long with INF = 9223372036854775807LL ; TAB0 let PI be const long double with PI = acos of - 1 ; TAB0 let MAX_N be const integer with MAX_N = 1e + 6 ; TAB0 let ALPH be const integer with ALPH = 26 ; TAB0 let alph be const string with alph = " abcdefghijklmnopqrstuvwxyz " ; TAB0 define count which takes integer pos , string s and integer xd as arguments ; TAB1 let l be integer with l = size of s ; TAB1 while pos is less than l ; TAB2 if element at index pos in s is equal to ' | ' ; TAB3 increment xd ; TAB3 increment pos ; TAB2 else ; TAB3 break ; TAB1 increment pos ; TAB0 define print which takes integer a , b , and c as argument ; TAB1 for i = 0 to a exclusive , print out | ; TAB1 print + ; TAB1 for i = 0 to b exclusive , print | ; TAB1 print = ; TAB1 for i = 0 to c exclusive , print | ; TAB1 print out newline ; TAB0 define check which takes integer a , b , c as arguments ; TAB1 if a is less than or equal to 0 or b is less than or equal to 0 or c is less than or equal to 0 , return false ; TAB1 return a + b is equal to c ; TAB0 define solve ; TAB1 let s be string ; TAB1 read s ; TAB1 let l be integer with l = size of s ; TAB1 let a , b , c be integers ; TAB1 set a = b = c = 0 ; TAB1 let pos be integer with pos = 0 ; TAB1 call count with pos , s , a ; TAB1 call count with pos , s , b ; TAB1 call count with pos , s , c ; TAB1 if a + b is equal to c ; TAB2 call print with a , b , c ; TAB1 else ; TAB2 if check of a + 1 , b - 1 , c is not equal to 0 ; TAB3 call print of a + 1 , b - 1 , c ; TAB3 return ; TAB2 if check of a + 1 , b , c - 1 is not equal to 0 ; TAB3 cal print of a + 1 , b , c - 1 ; TAB3 return ; TAB2 if check of a - 1 , b + 1 , c is not equal to 0 ; TAB3 call print of a - 1 , b + 1 , c ; TAB3 return ; TAB2 if check of a , b + 1 , c - 1 is not equal to 0 ; TAB3 call print of a , b + 1 , c - 1 ; TAB3 return ; TAB2 if check of a - 1 , b , c + 1 is not equal to 0 ; TAB3 call print of a - 1 , b , c + 1 ; TAB3 return ; TAB2 if check of a , b - 1 , c + 1 is not equal to 0 ; TAB3 call print of a , b - 1 , c + 1 ; TAB3 return ; TAB2 print out Impossible with newline ; TAB1 let t be integer with t = 1 ; TAB1 while t is greater than zero , decrement t and call solve ;	const long long INF = 9223372036854775807LL ; const long double PI = acos ( - 1 ) ; const int MAX_N = 1e+6 ; const int ALPH = 26 ; const string alph = " abcdefghijklmnopqrstuvwxyz " ; void count ( int & pos , string & s , int & xd ) { int l = s . size ( ) ; while ( pos < l ) { if ( s [ pos ] == ' | ' ) { xd ++ ; pos ++ ; } else break ; } pos ++ ; } void print ( int a , int b , int c ) { for ( int i = 0 ; i < a ; i ++ ) cout << " | " ; cout << " + " ; for ( int i = 0 ; i < b ; i ++ ) cout << " | " ; cout << " = " ; for ( int i = 0 ; i < c ; i ++ ) cout << " | " ; cout << endl ; } bool check ( int a , int b , int c ) { if ( a <= 0 or b <= 0 or c <= 0 ) return false ; return a + b == c ; } void solve ( ) { string s ; cin >> s ; int l = s . size ( ) ; int a , b , c ; a = b = c = 0 ; int pos = 0 ; count ( pos , s , a ) ; count ( pos , s , b ) ; count ( pos , s , c ) ; if ( a + b == c ) { print ( a , b , c ) ; } else { if ( check ( a + 1 , b - 1 , c ) ) { print ( a + 1 , b - 1 , c ) ; return ; } if ( check ( a + 1 , b , c - 1 ) ) { print ( a + 1 , b , c - 1 ) ; return ; } if ( check ( a - 1 , b + 1 , c ) ) { print ( a - 1 , b + 1 , c ) ; return ; } if ( check ( a , b + 1 , c - 1 ) ) { print ( a , b + 1 , c - 1 ) ; return ; } if ( check ( a - 1 , b , c + 1 ) ) { print ( a - 1 , b , c + 1 ) ; return ; } if ( check ( a , b - 1 , c + 1 ) ) { print ( a , b - 1 , c + 1 ) ; return ; } cout << " Impossible " << endl ; } } int main ( ) { int t = 1 ; while ( t -- ) solve ( ) ; return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 ar = array of integers of length n + 1 ; TAB1 for i = 2 to n inclusive , read ar [ i ] ; TAB1 create a stack of integers by name s ; TAB1 the integer value of i = n ; TAB1 push n into s ; TAB1 while the condition is true ; TAB2 push ar [ i ] into s ; TAB2 i is equal to ar [ i ] ; TAB2 if i equals 1 , stop ; TAB1 print s . top ( ) ; TAB1 pop s ; TAB1 while s . empty ( ) is not equal to true ; TAB2 print space and s . top ( ) ; TAB2 pop s ; TAB1 print newline ;	int main ( ) { int n ; cin >> n ; int ar [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) cin >> ar [ i ] ; stack < int > s ; int i = n ; s . push ( n ) ; while ( 1 ) { s . push ( ar [ i ] ) ; i = ar [ i ] ; if ( i == 1 ) break ; } cout << s . top ( ) ; s . pop ( ) ; while ( s . empty ( ) != true ) { cout << "   " << s . top ( ) ; s . pop ( ) ; } cout << endl ; }
TAB0 in function gcd taking int i , intj and returning int ; TAB1 if j is 0 return i ; TAB1 return gcd of j , i mod j ; TAB1 a , b , c , d = int ; TAB1 read a then b then c then d ; TAB1 if ( b - d ) is not a multiple of gcd of c , - a ; TAB2 print " - 1 " ; TAB1 else ; TAB2 for i = 0 to 1e6 ; TAB3 if ( b - d + a * i ) is a multiple of c and ( b - d + a * i ) / c > = 0 ; TAB4 print b + a * i ; TAB4 break ;	int gcd ( int i , int j ) { if ( j == 0 ) return i ; return gcd ( j , i % j ) ; } int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; if ( ( b - d ) % gcd ( c , - a ) ) cout << " -1 " << endl ; else for ( int i = 0 ; i < 1e6 ; ++ i ) if ( ( b - d + a * i ) % c == 0 && ( b - d + a * i ) / c >= 0 ) { cout << b + a * i << endl ; break ; } return 0 ; }
TAB0 void function fastIo , blank ; TAB0 s = string ; TAB0 indx = integer ; TAB0 in int function check that takes string temp ; TAB1 let i be an int ; TAB1 for i = 0 to length of s inclusive ; TAB2 if i different indx and i + 1 diffenrent indx and i different indx + 1 ; TAB3 if substring of s between i and 2 is same as temp ; TAB4 set indx to i ; TAB4 return 1 ; TAB1 call fastIo ( ) ; TAB1 read s ; TAB1 indx = - 2 ; TAB1 ans = integer = check of " AB " ; TAB1 increment ans by check of " BA " ; TAB1 if ans is 2 ; TAB2 print YES ; TAB1 else ; TAB2 set ans to 0 ; TAB2 set indx to - 2 ; TAB2 set ans to check of " BA " ; TAB2 increment asn by check of " AB " ; TAB2 if ans is 2 ; TAB3 print YES ; TAB2 else ; TAB3 print NO ;	void fastIo ( ) { } string s ; int indx ; int check ( string temp ) { int i ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( i != indx && i + 1 != ( indx ) && i != ( indx + 1 ) ) { if ( s . substr ( i , 2 ) == temp ) { indx = i ; return 1 ; } } } return 0 ; } int main ( ) { fastIo ( ) ; cin >> s ; indx = - 2 ; int ans = check ( " AB " ) ; ans += check ( " BA " ) ; if ( ans == 2 ) { cout << " YES " << endl ; } else { ans = 0 ; indx = - 2 ; ans = check ( " BA " ) ; ans += check ( " AB " ) ; if ( ans == 2 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } return 0 ; }
TAB0 bool function isIN with reference to the vector of ints argument & disk and int argument element ; TAB1 for i from 0 to length of disk exclusive ; TAB2 if disk [ i ] is equal to element , return true ; TAB1 return false ; TAB1 declare ints n and m ; TAB1 read input to n and m ; TAB1 declare vector of ints called rstr ; TAB1 declare integer variable v ; TAB1 for i from 0 to n exclusive ; TAB2 read v ; TAB2 push v to rstr ; TAB1 declare vector of ints disk ; TAB1 create integer ans = 0 ; TAB1 for i from 0 to n exclusive ; TAB2 if isIN ( disk , rstr [ i ] ) returned true ; TAB3 increment ans ; TAB3 skip the rest of the loop ; TAB2 else if length of disk < m ; TAB3 push rstr [ i ] into disk ; TAB2 else ; TAB3 declare integer variables ind = 0 , mx = i + 1 and k ; TAB3 loop j from 0 to m exclusive ; TAB4 loop k from to n exclusive ; TAB5 if disk [ j ] = rstr [ k ] ; TAB6 if k is greater than mx ; TAB7 set mx to k ; TAB7 set ind to j ; TAB6 break the loop ; TAB4 if k = n ; TAB5 assign j to ind ; TAB5 break the loop ; TAB3 if mx = INT_MAX , set ind to 0 ; TAB3 assign rstr [ i ] to disk [ ind ] ; TAB1 print n - ans ;	bool isIN ( vector < int > & disk , int element ) { for ( int i = 0 ; i < ( int ) disk . size ( ) ; i ++ ) { if ( disk [ i ] == element ) return true ; } return false ; } int main ( ) { int n , m ; cin >> n >> m ; vector < int > rstr ; int v ; for ( int i = 0 ; i < n ; i ++ ) { cin >> v ; rstr . push_back ( v ) ; } vector < int > disk ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isIN ( disk , rstr [ i ] ) ) { ans ++ ; continue ; } else if ( ( int ) disk . size ( ) < m ) { disk . push_back ( rstr [ i ] ) ; } else { int ind = 0 , mx = i + 1 , k ; for ( int j = 0 ; j < m ; j ++ ) { for ( k = i + 1 ; k < n ; k ++ ) { if ( disk [ j ] == rstr [ k ] ) { if ( k > mx ) { mx = k ; ind = j ; } break ; } } if ( k == n ) { ind = j ; break ; } } if ( mx == INT_MAX ) { ind = 0 ; } disk [ ind ] = rstr [ i ] ; } } cout << n - ans << endl ; return 0 ; }
TAB0 declare integers n and m ; TAB0 declare integer menor ; TAB1 read in n and m ; TAB1 menor is equal to the maximum value an integer variable can store ; TAB1 loop through the code m times ; TAB2 declare integers a and b ; TAB2 read in a and b ; TAB2 the value of menor is equal to the smaller amount of the values menor or b - a + 1 ; TAB1 print the value of menor and skip a line ; TAB1 print 0 ; TAB1 loop through the code n - 1 times and print the remainder of i divided by menor ; TAB1 print a new line ;	int n , m ; int menor ; int main ( ) { cin >> n >> m ; menor = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { int a , b ; cin >> a >> b ; menor = min ( menor , b - a + 1 ) ; } cout << menor << " \n " ; cout << " 0 " ; for ( int i = 1 ; i < n ; i ++ ) { cout << "   " << i % menor ; } cout << " \n " ; return 0 ; }
TAB1 let i , j , k , rest , n be long long integers ; TAB1 let ch , ch1 be characters ; TAB1 read n , k ; TAB1 assign n - k to rest ; TAB1 assign the character a to ch ; TAB1 iterate k times ; TAB2 print ch ; TAB2 add 1 to ch ; TAB1 assign the character a to ch1 ; TAB1 for i = 0 , j = 0 as long as i is less than rest with increment i , increment j ; TAB2 print ch1 ; TAB2 add 1 to ch1 ; TAB2 if j equals k ; TAB3 assign the character a to ch1 ; TAB3 assign 0 to j ; TAB1 print newline ;	int main ( ) { long long int i , j , k , rest , n ; char ch , ch1 ; cin >> n >> k ; rest = n - k ; ch = ' a ' ; for ( i = 0 ; i < k ; i ++ ) { cout << ch ; ch += 1 ; } ch1 = ' a ' ; for ( i = 0 , j = 1 ; i < rest ; i ++ , j ++ ) { cout << ch1 ; ch1 += 1 ; if ( j == k ) { ch1 = ' a ' ; j = 0 ; } } cout << endl ; return 0 ; }
TAB0 N = const long long = 100005 ; TAB0 dp , f = long long arrays of length N ; TAB0 dpback = long long array of length N ; TAB0 g = long long vector of length N ; TAB0 gback = long long vector of length N ; TAB0 in void function go taking p = long long ; TAB1 if dp at p = 1 then return ; TAB1 set dp at p to 1 ; TAB1 if f at p isn ' t 1 ; TAB2 for long long i = 0 to size of g at p , call go on g [ p ] [ i ] ; TAB0 in void fucntion goback taking p = long long and first = bool ; TAB1 if dpback at p = 1 then return ; TAB1 if first isn ' t 0 ot f at p isn ' t 1 ; TAB2 dpback at p = 1 ; TAB2 for long long i = 0 to size of gback at p then call goback on goback [ p ] [ i ] and false ; TAB1 n , m = long long ; TAB1 read n , m ; TAB1 read the first n elements of f ; TAB1 for long long i = 0 to m exclusive ; TAB2 x , y = long long ; TAB2 read x , y ; TAB2 decrement x ; TAB2 decrement y ; TAB2 push back x into g at y ; TAB2 push back y into gback at x ; TAB1 for long long i = 0 to n exclusive ; TAB2 if f at i = 2 then call go on i ; TAB2 if f at i = 1 then call goback on i and true ; TAB1 for long long i = 0 to n exl ; TAB2 ans = long long , are dp [ i ] 1 and dpback [ i ] = 1 ? then set ans = 1 , else set ans = 0 ; TAB2 print ans ;	const long long N = 100005 ; long long dp [ N ] , f [ N ] ; long long dpback [ N ] ; vector < long long > g [ N ] ; vector < long long > gback [ N ] ; void go ( long long p ) { if ( dp [ p ] == 1 ) return ; dp [ p ] = 1 ; if ( f [ p ] != 1 ) { for ( long long i = 0 ; i < ( g [ p ] . size ( ) ) ; i ++ ) { go ( g [ p ] [ i ] ) ; } } } void goback ( long long p , bool first ) { if ( dpback [ p ] == 1 ) return ; if ( first || f [ p ] != 1 ) { dpback [ p ] = 1 ; for ( long long i = 0 ; i < ( gback [ p ] . size ( ) ) ; i ++ ) { goback ( gback [ p ] [ i ] , false ) ; } } } int main ( ) { long long n , m ; cin >> n >> m ; for ( long long i = 0 ; i < ( n ) ; i ++ ) { cin >> f [ i ] ; } for ( long long i = 0 ; i < ( m ) ; i ++ ) { long long x , y ; cin >> x >> y ; x -- ; y -- ; g [ y ] . push_back ( x ) ; gback [ x ] . push_back ( y ) ; } for ( long long i = 0 ; i < ( n ) ; i ++ ) { if ( f [ i ] == 2 ) { go ( i ) ; } if ( f [ i ] == 1 ) goback ( i , true ) ; } for ( long long i = 0 ; i < ( n ) ; i ++ ) { long long ans = dp [ i ] == 1 && dpback [ i ] == 1 ? 1 : 0 ; cout << ans << " \n " ; } }
TAB0 mod = constant long long = 998244353 ; TAB0 maxn = constant integer = 2e5 ; TAB1 t = integer ; TAB1 n , a , b , c are long longs ; TAB1 read n ; TAB1 read a , b , c ; TAB1 one , two are long longs with one = a , two = b - c ; TAB1 sum1 = long long = n / one , yu1 = long long = n mod 1 , ci = long long ; TAB1 while yu1 / b is positive ; TAB2 set ci to ( yu1 - c ) / 2 ; TAB2 set yu1 to yu1 - ci * two ; TAB2 add ci to sum1 ; TAB1 yu2 = long long = n , sum2 and ans are long longs both set to 0 ; TAB1 while yu2 / b is positive ; TAB2 set ci to ( yu2 - c ) / two ; TAB2 set yu2 to yu2 - ci * two ; TAB2 add ci to sum2 ; TAB1 add yu2 / one to sum2 ; TAB1 set yu2 to yu2 mod one ; TAB1 set ans to call max with ans , sum2 ; TAB1 set ans to call max with sum1 , ans ; TAB1 print ans ;	const long long mod = 998244353 ; const int maxn = 2e5 ; int main ( ) { int t ; long long n , a , b , c ; cin >> n ; cin >> a >> b >> c ; long long one = a , two = b - c ; long long sum1 = n / one , yu1 = n % one , ci ; while ( yu1 / b > 0 ) { ci = ( yu1 - c ) / two ; yu1 = yu1 - ci * two ; sum1 += ci ; } long long yu2 = n , sum2 = 0 , ans = 0 ; while ( yu2 / b > 0 ) { ci = ( yu2 - c ) / two ; yu2 = yu2 - ci * two ; sum2 += ci ; } sum2 += yu2 / one ; yu2 = yu2 % one ; ans = max ( ans , sum2 ) ; ans = max ( sum1 , ans ) ; cout << ans << endl ; return 0 ; }
TAB0 create long long int mod = 1000000007 ; TAB0 create long long ints l and r ; TAB0 let p be long long int array with size 18 ; TAB0 let ct be long long int array with size 19 ; TAB0 init is a void function ; TAB1 assign 1 to p [ 0 ] ; TAB1 for i = 1 to 17 inclusive , change p [ i ] to 10ll * p [ i - 1 ] ; TAB1 set ct [ 1 ] to 9 ; TAB1 set ct [ 2 ] to 9 ; TAB1 for i from 3 to 18 inclusive , set ct [ i ] to 9 * p [ i - 2 ] ; TAB0 long long int function calc with long long int argument num ; TAB1 declare vector of integers called digits ; TAB1 create long long int n = num ; TAB1 while num ! = 0 ; TAB2 push num % 10 into digits ; TAB2 divide num by 10 ; TAB1 if there is only one element in digits , return n - 1 ; TAB1 create integer l = length of digits ; TAB1 declare long long int ans = 0 ; TAB1 for integer i = l - 1 to 0 inclusive decrementing i ; TAB2 if i is equal to l - 1 ; TAB3 if digits [ i ] > 1 , add ( digits [ i ] - 1 ) * ( p [ l - 2 ] ) to ans ; TAB2 else if i = 0 ; TAB3 if digits [ l - 1 ] is less than digits [ 0 ] , increase ans by 1 ; TAB2 else if digits [ i ] > 0 ; TAB3 increase ans by ( digits [ i ] ) * ( p [ i - 1 ] ) ; TAB1 for integer i = 0 to l exclusive increment ans by ct [ i ] ; TAB1 return ans ; TAB1 call init ( ) ; TAB1 read l and r ; TAB1 print calc ( r + 1 ) - calc ( l ) ;	long long int mod = 1000000007 ; long long int l , r ; long long int p [ 18 ] ; long long int ct [ 19 ] ; void init ( ) { p [ 0 ] = 1 ; for ( int i = 1 ; i <= 17 ; i ++ ) { p [ i ] = 10ll * p [ i - 1 ] ; } ct [ 1 ] = 9 ; ct [ 2 ] = 9 ; for ( int i = 3 ; i <= 18 ; i ++ ) { ct [ i ] = 9 * p [ i - 2 ] ; } } long long int calc ( long long int num ) { vector < int > digits ; long long int n = num ; while ( num ) { digits . push_back ( num % 10 ) ; num /= 10 ; } if ( digits . size ( ) == 1 ) { return n - 1 ; } int l = digits . size ( ) ; long long int ans = 0 ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( i == l - 1 ) { if ( digits [ i ] > 1 ) { ans += ( digits [ i ] - 1 ) * ( p [ l - 2 ] ) ; } } else if ( i == 0 ) { if ( digits [ l - 1 ] < digits [ 0 ] ) { ans += ( 1 ) ; } } else if ( digits [ i ] > 0 ) { ans += ( digits [ i ] ) * ( p [ i - 1 ] ) ; } } for ( int i = 0 ; i < l ; i ++ ) { ans += ct [ i ] ; } return ans ; } int main ( ) { init ( ) ; cin >> l >> r ; cout << calc ( r + 1 ) - calc ( l ) << endl ; return 0 ; }
TAB0 integer array = n , d [ 111 ] ; TAB0 array a size 111 , s , t = string ; TAB0 create character variable ; TAB1 read n ; TAB1 for i = 1 to less than or equal to n do the following ; TAB2 read a [ i ] ; TAB2 for j = 0 to less than a [ i ] . size ( ) do the following ; TAB3 if a [ i ] [ j ] is greater than or equal to a then subtract 32 from a [ i ] [ j ] ; TAB1 read s ; TAB1 set t to s ; TAB1 read lucky ; TAB1 if lucky is greater than or equal to a then subtract 32 from lucky ; TAB1 integers = sl = s . length ( ) ; TAB1 for i = 0 to less than sl do the following ; TAB2 if s [ i ] is greater than or equal to a then subtract 32 from s [ i ] , d [ i ] = 1 ; TAB1 for i = 0 to less than sl do the following ; TAB2 for j = 1 to less than or equal to n do the following ; TAB3 integers l = a [ j ] . length ( ) ; TAB3 if i + l is less than or equal to sl and s . substr ( i , l ) is a [ j ] then do the following ; TAB4 for k = 0 to less than l do the following ; TAB5 if s [ i + k ] is lucky then do the following ; TAB6 if lucky is A then do the following ; TAB7 set t [ i + k ] to b if d [ i + k ] is true or else d [ i + k ] = B ) ; TAB6 else ; TAB7 set t [ i + k ] to b if d [ i + k ] is true or else d [ i + k ] = A ) ; TAB5 else ; TAB6 set t [ i + k ] to lucky + 32 if d [ i + k ] is true else t [ i + k ] = lucky ; TAB1 output t ;	int n , d [ 111 ] ; string a [ 111 ] , s , t ; char lucky ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; for ( int j = 0 ; j < a [ i ] . size ( ) ; j ++ ) if ( a [ i ] [ j ] >= ' a ' ) a [ i ] [ j ] -= 32 ; } cin >> s ; t = s ; cin >> lucky ; if ( lucky >= ' a ' ) lucky -= 32 ; int sl = s . length ( ) ; for ( int i = 0 ; i < sl ; i ++ ) { if ( s [ i ] >= ' a ' ) s [ i ] -= 32 , d [ i ] = 1 ; } for ( int i = 0 ; i < sl ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int l = a [ j ] . length ( ) ; if ( i + l <= sl && s . substr ( i , l ) == a [ j ] ) { for ( int k = 0 ; k < l ; k ++ ) { if ( s [ i + k ] == lucky ) { if ( lucky == ' A ' ) t [ i + k ] = ( d [ i + k ] ? ' b ' : ' B ' ) ; else t [ i + k ] = ( d [ i + k ] ? ' a ' : ' A ' ) ; } else t [ i + k ] = ( d [ i + k ] ? lucky + 32 : lucky ) ; } } } } cout << t << " \n " ; return 0 ; }
TAB1 create strings a , b ; TAB1 create integers judge , judge2 , ab , ba with judge = 0 , judge2 = 0 , ab = 0 , ba = 0 ; TAB1 read a ; TAB1 set b to a ; TAB1 for i = 0 to size of a exclusive ; TAB2 if ( a [ i ] is ' A ' and a [ i + 1 ] is ' B ' ) and ab is less than 1 ; TAB3 increment judge ; TAB3 set a [ i ] to a [ i + 1 ] to ' c ' ; TAB3 increment ab ; TAB2 if ( a [ i ] is ' B ' and a [ i + 1 ] is ' A ' ) and ba is less than 1 ; TAB3 increment judge ; TAB3 set a [ i ] to a [ i + 1 ] to ' c ' ; TAB3 increment ba ; TAB1 set ab to 0 ; TAB1 set ba to 0 ; TAB1 set a to b ; TAB1 for i = size of a - 1 to 0 inclusive , decrementing i ; TAB2 if ( a [ i ] is ' A ' and a [ i + 1 ] is ' B ' ) and ab is less than 1 ; TAB3 increment judge2 ; TAB3 set a [ i ] to a [ i + 1 ] to ' c ' ; TAB3 increment ab ; TAB2 if ( a [ i ] is ' B ' and a [ i + 1 ] is ' A ' ) and ba is less than 1 ; TAB3 increment judge2 ; TAB3 set a [ i ] to a [ i + 1 ] to ' c ' ; TAB3 increment ba ; TAB1 if judge2 is 2 or judge2 is 2 ; TAB2 print " YES " print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { string a , b ; int judge = 0 , judge2 = 0 , ab = 0 , ba = 0 ; cin >> a ; b = a ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( ( a [ i ] == ' A ' && a [ i + 1 ] == ' B ' ) && ab < 1 ) { judge ++ ; a [ i ] = a [ i + 1 ] = ' c ' ; ab ++ ; } if ( ( a [ i ] == ' B ' && a [ i + 1 ] == ' A ' ) && ba < 1 ) { judge ++ ; a [ i ] = a [ i + 1 ] = ' c ' ; ba ++ ; } } ab = 0 ; ba = 0 ; a = b ; for ( int i = a . size ( ) - 1 ; i >= 0 ; i -- ) { if ( ( a [ i ] == ' A ' && a [ i + 1 ] == ' B ' ) && ab < 1 ) { judge2 ++ ; a [ i ] = a [ i + 1 ] = ' c ' ; ab ++ ; } if ( ( a [ i ] == ' B ' && a [ i + 1 ] == ' A ' ) && ba < 1 ) { judge2 ++ ; a [ i ] = a [ i + 1 ] = ' c ' ; ba ++ ; } } if ( judge == 2 || judge2 == 2 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB0 declare constant integer maxn = 2e6 + 10 ; TAB0 declare integer arrays pri size maxn , pal size maxn , c size 10 ; TAB0 declare boolean array vis size maxn ; TAB0 declare check with integer k as argument , returning boolean ; TAB1 declare integer cnt = 0 ; TAB1 while k is true ; TAB2 let c [ increment cnt ] be k % 10 ; TAB2 let k be k / 10 ; TAB1 for i = 0 to cnt exclusive ; TAB2 if c [ i ] is not c [ cnt - i - 1 ] , return false from function ; TAB1 return true ; TAB0 declare init with no arguments , returning void ; TAB1 set bytes from vis to size of vis to value false ; TAB1 set bytes from pri to size of pri to value 0 ; TAB1 set bytes from pal to size of pal to value 0 ; TAB1 let pal [ 1 ] be 1 ; TAB1 for i = 2 to maxn exclusive ; TAB2 let pri [ i ] be pri [ i - 1 ] ; TAB2 let pal [ i ] be pal [ i - 1 ] ; TAB2 if vis [ i ] is false ; TAB3 increment pri [ i ] ; TAB3 for j = 2 to j * i is less than maxn , incrementing j , let vis [ i * j ] be true ; TAB2 if result of run check ( i ) is true , increment pal [ i ] ; TAB1 run init ; TAB1 declare long longs p , q , ans = 0 ; TAB1 read p , q ; TAB1 for i = maxn - 1 to i is greater than or equal to 1 ad not ans , decrementing i ; TAB2 if ( q * pri [ i ] is less than or equal to p * pal [ i ] , let ans be i ; TAB1 print ans and newline ;	const int maxn = 2e6 + 10 ; int pri [ maxn ] , pal [ maxn ] , c [ 10 ] ; bool vis [ maxn ] ; bool check ( int k ) { int cnt = 0 ; while ( k ) { c [ cnt ++ ] = k % 10 ; k /= 10 ; } for ( int i = 0 ; i < cnt ; i ++ ) if ( c [ i ] != c [ cnt - i - 1 ] ) return false ; return true ; } void init ( ) { memset ( vis , false , sizeof vis ) ; memset ( pri , 0 , sizeof pri ) ; memset ( pal , 0 , sizeof pal ) ; pal [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; i ++ ) { pri [ i ] = pri [ i - 1 ] ; pal [ i ] = pal [ i - 1 ] ; if ( ! vis [ i ] ) { pri [ i ] ++ ; for ( int j = 2 ; j * i < maxn ; j ++ ) vis [ i * j ] = true ; } if ( check ( i ) ) pal [ i ] ++ ; } } int main ( ) { init ( ) ; long long p , q , ans = 0 ; cin >> p >> q ; for ( int i = maxn - 1 ; i >= 1 && ! ans ; i -- ) if ( q * pri [ i ] <= p * pal [ i ] ) ans = i ; cout << ans << endl ; return 0 ; }
TAB1 x1 , y1 , x2 , y2 = long long ; TAB1 n , a , b , c = int ; TAB1 while read x1 , y1 , x2 , y2 , n ; TAB2 num = 0 ; TAB2 while n is not 0 , decrement n ; TAB3 read a , b , c ; TAB3 i , j = long long ; TAB3 i = a * x1 + b * y1 + c ; TAB3 j = a * x2 + b * y2 + c ; TAB3 if i > 0 and j > 0 or i < 0 and j > 0 increment num ; TAB2 print num ;	int main ( ) { long long x1 , y1 , x2 , y2 ; int n , a , b , c ; while ( cin >> x1 >> y1 >> x2 >> y2 >> n ) { int num = 0 ; while ( n -- ) { cin >> a >> b >> c ; long long i , j ; i = a * x1 + b * y1 + c ; j = a * x2 + b * y2 + c ; if ( i > 0 && j < 0 || i < 0 && j > 0 ) num ++ ; } cout << num << endl ; } return 0 ; }
TAB0 declare constant long long MAXN = 100 * 1000 ; TAB0 declare long long array arr size MAXN + 10 , long longs n , d ; TAB0 declare bs with long long x as argument , returning long long ; TAB1 declare long longs l = x , r = n ; TAB1 while r - l is greater than 1 ; TAB2 declare long long mid = ( l + r ) / 2 ; TAB2 if arr [ mid ] - arr [ x ] is less than or equal to d ; TAB3 let l be mid ; TAB2 else ; TAB3 let r be mid ; TAB1 return l from function ; TAB1 read n and d ; TAB1 for i = 0 to n exclusive , read arr [ i ] ; TAB1 declare long long ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 declare long long k = result of run bs ( i ) - i ; TAB2 increment ans by k * ( k - 1 ) / 2 ; TAB1 print ans and newline ;	const long long MAXN = 100 * 1000 ; long long arr [ MAXN + 10 ] , n , d ; long long bs ( long long x ) { long long l = x , r = n ; while ( r - l > 1 ) { long long mid = ( l + r ) / 2 ; if ( arr [ mid ] - arr [ x ] <= d ) l = mid ; else r = mid ; } return l ; } int main ( ) { cin >> n >> d ; for ( long long i = 0 ; i < n ; i ++ ) cin >> arr [ i ] ; long long ans = 0 ; for ( long long i = 0 ; i < n ; i ++ ) { long long k = bs ( i ) - i ; ans += k * ( k - 1 ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB0 declare pair of integer and integer array dragon size 1001 ; TAB1 declare s , n , x , y , i = 0 as integers ; TAB1 read s and n ; TAB1 while increment i is less than or equal to n ; TAB2 read x and y ; TAB2 let dragon [ i - 1 ] be make pair with x and y ; TAB1 sort from dragon to dragon + n ; TAB1 for j = 0 to n exclusive ; TAB2 if s is less than or equal to first element of dragon [ j ] ; TAB3 print " NO " , and ' \ n ' ; TAB2 increment s by second element of dragon [ j ] ; TAB1 print " YES " , ' \ n ' ;	pair < int , int > dragon [ 1001 ] ; int main ( ) { int s , n , x , y , i = 0 ; cin >> s >> n ; while ( ++ i <= n ) { cin >> x >> y ; dragon [ i - 1 ] = make_pair ( x , y ) ; } sort ( dragon , dragon + n ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( s <= dragon [ j ] . first ) { cout << " NO " << ' \n ' ; return 0 ; } s += dragon [ j ] . second ; } cout << " YES " << ' \n ' ; return 0 ; }
TAB1 create long long ints xa , ya , xb , and yb ; TAB1 read xa , ya , xb , and yb ; TAB1 make integer n ; TAB1 read n ; TAB1 make long long ints a , b , and c ; TAB1 create integer ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read a , b , and c ; TAB2 if b is equal to 0 ; TAB3 if - c is greater than min ( xa * a , xb * a ) and - c is less than max ( xa * a , xb * a ) , set ans to ans + 1 ; TAB2 otherwise ; TAB3 create long long integers y1 and y2 ; TAB3 set y1 to - a * xa - c ; TAB3 set y2 to - a * xb - c ; TAB3 if y1 is greater than ya * b and y2 is less than yb * b or if y1 is less than ya * b and y2 is greater than yb * b , increment ans ; TAB1 show ans ;	int main ( ) { long long xa , ya , xb , yb ; cin >> xa >> ya >> xb >> yb ; int n ; cin >> n ; long long a , b , c ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a >> b >> c ; if ( b == 0 ) { if ( - c > min ( xa * a , xb * a ) && - c < max ( xa * a , xb * a ) ) { ans ++ ; } } else { long long y1 , y2 ; y1 = - a * xa - c ; y2 = - a * xb - c ; if ( ( y1 > ya * b && y2 < yb * b ) || ( y1 < ya * b && y2 > yb * b ) ) { ans ++ ; } } } cout << ans << endl ; return 0 ; }
TAB1 n , m , a , d , i , j , r , x , y are long longs with r = 0 ; TAB1 read n , m , a , d ; TAB1 v = long long vector of size m + 1 ; TAB1 for i = 1 to m inclusive , read v [ i ] ; TAB1 set i to j to 1 ; TAB1 set x to ( d / a ) + 1 ; TAB1 while i is at most m and j is at most n ; TAB2 set y to j * a ; TAB2 if v [ i ] is greater than y ; TAB3 set y to ( ( call min with n * a , v [ i ] ) - y ) / a ; TAB3 set y to ( y / x ) + 1 ; TAB3 add y to r , add x * y to j ; TAB3 set y to ( j - x ) * a + d + 1 ; TAB3 while i is at most m and v [ i ] is less than y , increment i ; TAB2 else ; TAB3 increment r ; TAB3 set y to v [ i ] + d ; TAB3 while i is at most m and v [ i ] is at most y , increment i ; TAB3 set j to ( y / a ) + 1 ; TAB1 while i is at most m ; TAB2 increment r ; TAB2 set y to v [ i ] + d ; TAB2 while i is at most m and v [ i ] is at most y , increment i ; TAB1 if j is at most n ; TAB2 assign n - j to j ; TAB2 add ( j / x ) + 1 to r ; TAB1 display r ;	int main ( ) { long long n , m , a , d , i , j , r = 0 , x , y ; cin >> n >> m >> a >> d ; vector < long long > v ( m + 1 ) ; for ( i = 1 ; i <= m ; i ++ ) cin >> v [ i ] ; i = j = 1 ; x = ( d / a ) + 1 ; while ( i <= m && j <= n ) { y = j * a ; if ( v [ i ] > y ) { y = ( min ( n * a , v [ i ] ) - y ) / a ; y = ( y / x ) + 1 ; r += y , j += x * y ; y = ( j - x ) * a + d + 1 ; while ( i <= m && v [ i ] < y ) i ++ ; } else { r ++ ; y = v [ i ] + d ; while ( i <= m && v [ i ] <= y ) i ++ ; j = ( y / a ) + 1 ; } } while ( i <= m ) { r ++ ; y = v [ i ] + d ; while ( i <= m && v [ i ] <= y ) i ++ ; } if ( j <= n ) { j = n - j ; r += ( j / x ) + 1 ; } cout << r << endl ; }
TAB0 D = array of 10 by 20 by 2 long long ; TAB0 w = string ; TAB0 function d ( get int i , j , k return long long ) ; TAB1 if D [ i ] [ j ] [ j ] ! = - 1 return D [ i ] [ j ] [ k ] ; TAB1 if j is 1 ; TAB2 if i is 0 and k is 0 return 9 ; TAB2 if i is 0 and k is 1 ; TAB3 return w [ size of w - 1 ] - ' 0 ' ; TAB2 else if k is 1 ; TAB3 return i < = w [ size of w - 1 ] - ' 0 ' ; TAB2 else ; TAB3 return 1 ; TAB1 cont = 0 ; TAB1 for e = 0 to 10 if k is 0 else w [ size of w - j ] - ' 0 ' + 1 exclusive add d ( ( e if i is 0 else i , j - 1 , 0 if k is 0 else e = = w [ size of w - j ] - ' 0 ' ) to cont ; TAB1 return D [ i ] [ j ] [ k ] = cont ; TAB0 function F ( get long long x , return long long ) ; TAB1 fill D with - 1 ; TAB1 l = stringstream ; TAB1 get x from l ; TAB1 put w in l ; TAB1 return d ( 0 , size of w , 1 ) ; TAB1 l , r , i , j = long long , ans = 0 ; TAB1 read l , r ; TAB1 ans = F ( r ) - F ( l - 1 ) ; TAB1 print ans ;	long long D [ 10 ] [ 20 ] [ 2 ] ; string w ; long long d ( int i , int j , int k ) { if ( D [ i ] [ j ] [ k ] != - 1 ) return D [ i ] [ j ] [ k ] ; if ( j == 1 ) { if ( i == 0 and k == 0 ) return 9 ; if ( i == 0 and k == 1 ) return w [ w . size ( ) - 1 ] - ' 0 ' ; else if ( k == 1 ) return i <= w [ w . size ( ) - 1 ] - ' 0 ' ; else return 1 ; } long long cont = 0 ; for ( int e = 0 ; e < ( ( k == 0 ) ? 10 : w [ w . size ( ) - j ] - ' 0 ' + 1 ) ; ++ e ) cont += d ( ( i == 0 ) ? e : i , j - 1 , ( k == 0 ) ? 0 : e == w [ w . size ( ) - j ] - ' 0 ' ) ; return D [ i ] [ j ] [ k ] = cont ; } long long F ( long long x ) { memset ( D , - 1 , sizeof ( D ) ) ; stringstream l ; l << x ; l >> w ; return d ( 0 , w . size ( ) , 1 ) ; } int main ( ) { long long l , r , i , j , ans = 0 ; cin >> l >> r ; ans = F ( r ) - F ( l - 1 ) ; cout << ans << endl ; return 0 ; }
TAB0 create pair array of int and int a of size 10001 ; TAB0 declare drom taking in int r and returning integer ; TAB1 if a [ r ] . first is not 0 ; TAB2 create int u = r ; TAB2 set r to a [ r ] . first ; TAB2 if a [ r ] . second is not 0 ; TAB3 set a [ r ] . second to min of a [ r ] . second and a [ u ] second ; TAB2 else do ; TAB3 set a [ r ] . second to a [ u ] . second ; TAB2 set a [ u ] . first to 0 ; TAB1 else ; TAB2 return r ; TAB1 set r to return value of drom ( r ) ; TAB1 return r ; TAB0 make ints n , t , and l ; TAB1 read n and t ; TAB1 while t is not equal to 0 ; TAB2 make ints x , y , and z ; TAB2 read x , y , and z ; TAB2 set a [ x ] . first to y ; TAB2 set a [ x ] . second to z ; TAB2 decrease t by 1 ; TAB1 for i = 1 to n ; TAB2 make int m = drom ( i ) ; TAB2 if m is not equal to i ; TAB3 set a [ i ] . first to m ; TAB3 set a [ i ] . second to a [ m ] . second ; TAB2 else do ; TAB3 set first value of a [ i ] to 0 ; TAB1 for i = 1 to n ; TAB2 if a [ i ] . first is not equal to 0 , increment l ; TAB1 print l ; TAB1 for i = 1 to n ; TAB2 if a [ i ] . first is not equal to 0 , print i , " " , a [ i ] . first , " " , and a [ i ] . second ;	pair < int , int > a [ 10001 ] ; int drom ( int r ) { if ( a [ r ] . first != 0 ) { int u = r ; r = a [ r ] . first ; if ( a [ r ] . second != 0 ) a [ r ] . second = min ( a [ r ] . second , a [ u ] . second ) ; else a [ r ] . second = a [ u ] . second ; a [ u ] . first = 0 ; } else return r ; r = drom ( r ) ; return r ; } int n , t , l ; int main ( ) { cin >> n >> t ; while ( t != 0 ) { int x , y , z ; cin >> x >> y >> z ; a [ x ] . first = y ; a [ x ] . second = z ; t -- ; } for ( int i = 1 ; i <= n ; ++ i ) { int m = drom ( i ) ; if ( m != i ) { a [ i ] . first = m ; a [ i ] . second = a [ m ] . second ; } else { a [ i ] . first = 0 ; } } for ( int i = 1 ; i <= n ; ++ i ) if ( a [ i ] . first != 0 ) l ++ ; cout << l << endl ; for ( int i = 1 ; i <= n ; ++ i ) if ( a [ i ] . first != 0 ) cout << i << "   " << a [ i ] . first << "   " << a [ i ] . second << endl ; }
TAB0 create long long array x of size 1000 * 100 + 5 ; TAB0 make long long ints n , d , and ans = 0 ; TAB0 declare f taking in int k and returning long long ; TAB1 make long long ints l = k and r = n ; TAB1 while r - 1 > 1 is truthy ; TAB2 create long long ints mid = ( l + r ) / 2 ; TAB2 if x [ mid ] - x [ k ] is less than or equal to d ; TAB3 set l to mid ; TAB2 else do ; TAB3 set r to mid ; TAB1 return l ; TAB1 read n and d ; TAB1 for i = 0 to n exclusive , read x [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 make long long int k = f ( i ) - i ; TAB2 add k * ( k - 1 ) / 2 to ans ; TAB1 print ans ;	long long x [ 1000 * 100 + 5 ] ; long long n , d , ans = 0 ; long long f ( int k ) { long long l = k , r = n ; while ( r - l > 1 ) { long long mid = ( l + r ) / 2 ; if ( x [ mid ] - x [ k ] <= d ) l = mid ; else r = mid ; } return l ; } int main ( ) { cin >> n >> d ; for ( int i = 0 ; i < n ; i ++ ) cin >> x [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { long long k = f ( i ) - i ; ans += k * ( k - 1 ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB1 x , t , a , b , da , db = imntegers ; TAB1 read x , t , a , b , da , db ; TAB1 create an integr l with l = b ; TAB1 create an integer flag = 0 ; TAB1 if x = 0 set flag = 1 ; TAB1 for i = 0 to t exclusive ; TAB2 set b = l ; TAB2 for j = 0 to t exclusive ; TAB3 if x = a + b or x = a or x = b ; TAB4 set flag = 1 ; TAB4 break ; TAB3 set b = b - db ; TAB2 set a = a - da ; TAB1 if flag = 1 ; TAB2 print YES ; TAB1 else do the following ; TAB2 print NO ;	int main ( ) { int x , t , a , b , da , db ; cin >> x >> t >> a >> b >> da >> db ; int l = b ; int flag = 0 ; if ( x == 0 ) flag = 1 ; for ( int i = 0 ; i < t ; i ++ ) { b = l ; for ( int j = 0 ; j < t ; j ++ ) { if ( x == a + b || x == a || x == b ) { flag = 1 ; break ; } b -= db ; } a -= da ; } if ( flag == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB1 integers = l1 , l2 , l3 , l4 , p1 ; TAB1 integers = s1 , s2 , s3 , s4 , p2 ; TAB1 integers = r1 , r2 , r3 , r4 , p3 , p4 ; TAB1 read l1 , s1 , r1 , p1 ; TAB1 read l2 , s2 , r2 , p2 ; TAB1 read l3 , s3 , r3 , p3 ; TAB1 read l4 , s4 , r4 , p4 ; TAB1 if l1 or s1 or r1 or l2 or r4 or s3 is true ; TAB2 if p1 is true ; TAB3 write yes to stdout ; TAB1 if l2 or s2 or r2 or r1 or s4 or l3 is true ; TAB2 if p2 is true ; TAB3 write yes to stdout ; TAB1 if l3 or r3 or s3 or l4 or r2 or s1 is true ; TAB2 if p3 is true ; TAB3 write yes to stdout ; TAB1 if l4 or r4 or s4 or l1 or r3 or s2 is true ; TAB2 if p4 is true ; TAB3 write yes to stdout ; TAB1 write NO to stdout ;	int main ( ) { int l1 , l2 , l3 , l4 , p1 ; int s1 , s2 , s3 , s4 , p2 ; int r1 , r2 , r3 , r4 , p3 , p4 ; cin >> l1 >> s1 >> r1 >> p1 ; cin >> l2 >> s2 >> r2 >> p2 ; cin >> l3 >> s3 >> r3 >> p3 ; cin >> l4 >> s4 >> r4 >> p4 ; if ( l1 || s1 || r1 || l2 || r4 || s3 ) { if ( p1 ) { puts ( " YES " ) ; return 0 ; } } if ( l2 || s2 || r2 || r1 || s4 || l3 ) { if ( p2 ) { puts ( " YES " ) ; return 0 ; } } if ( l3 || r3 || s3 || l4 || r2 || s1 ) { if ( p3 ) { puts ( " YES " ) ; return 0 ; } } if ( l4 || r4 || s4 || l1 || r3 || s2 ) { if ( p4 ) { puts ( " YES " ) ; return 0 ; } } puts ( " NO " ) ; return 0 ; }
TAB1 let q , p1 , p2 be long integers with p1 = - 1 , p2 = - 1 ; TAB1 read q ; TAB1 for long integer i is equal to 2 , i * i < = q , increment i by 1 ; TAB2 if not q modulo i ; TAB3 if p1 is equal to - 1 ; TAB4 p1 is equal to i ; TAB4 q is equal to q / i ; TAB3 if q modulo i is equal to 0 and p2 is equal to - 1 ; TAB4 p2 is equal to i ; TAB4 q is equal to q / i ; TAB4 stop ; TAB1 if p2 is not equal to - 1 ; TAB2 if q is equal to 1 ; TAB3 print 2 and newline ; TAB2 else do the following ; TAB3 print 1 and newline and p1 * p2 and newline ; TAB1 else if p1 is not equal to - 1 ; TAB2 print 2 and newline ; TAB1 else do the following ; TAB2 print 1 \ n0 \ n and newline ;	int main ( ) { long long q , p1 = - 1 , p2 = - 1 ; cin >> q ; for ( long long i = 2 ; i * i <= q ; i ++ ) { if ( ! ( q % i ) ) { if ( p1 == - 1 ) { p1 = i ; q /= i ; } if ( q % i == 0 && p2 == - 1 ) { p2 = i ; q /= i ; break ; } } } if ( p2 != - 1 ) { if ( q == 1 ) cout << " 2\n " ; else cout << " 1\n " << p1 * p2 << " \n " ; } else if ( p1 != - 1 ) cout << " 2\n " ; else cout << " 1\n0\n " ; return 0 ; }
TAB0 pa is an array of int - int pairs with 10005 elements ; TAB0 maxn is a new integer variable = 0x3f3f3f3f ; TAB1 declare ints n , m , k and count ; TAB1 read m and n and keep looping ; TAB2 assign the value of 0 to the count and k ; TAB2 start for loop from i = 0 to n exclusive , read variables pa [ i ] . first and pa [ i ] . second from the input on each loop iteration ; TAB2 while k is not m ; TAB3 sort n elements of pa ; TAB3 if m is greater than pa [ 0 ] . first ; TAB4 if pa [ 0 ] . second ! = 0 , assign m to k ; TAB4 change m to m + pa [ 0 ] . second ; TAB4 pa [ 0 ] . first = maxn ; TAB4 increment count ; TAB3 else ; TAB4 stop the loop ; TAB2 if count ! = n ; TAB3 print " NO " ; TAB2 else ; TAB3 print " YES " ;	pair < int , int > pa [ 10005 ] ; int maxn = 0x3f3f3f3f ; int main ( ) { int n , m , k , count ; while ( cin >> m >> n ) { count = k = 0 ; for ( int i = 0 ; i < n ; i ++ ) cin >> pa [ i ] . first >> pa [ i ] . second ; while ( k != m ) { sort ( pa , pa + n ) ; if ( m > pa [ 0 ] . first ) { if ( pa [ 0 ] . second != 0 ) k = m ; m += pa [ 0 ] . second ; pa [ 0 ] . first = maxn ; count ++ ; } else break ; } if ( count != n ) cout << " NO " << endl ; else cout << " YES " << endl ; } return 0 ; }
TAB0 f , g = unsigned long long array of size 19 each ; TAB0 in function get_f ; TAB1 set f [ 1 ] and f [ 2 ] to 9 ; TAB1 for i = 3 to 18 inclusive set f [ i ] to f [ i - 1 ] * 10 ; TAB0 in function get_g ; TAB1 set g [ 0 ] to 1 ; TAB1 for i = 1 to 18 inclusive set g [ i ] to g [ i - 1 ] * 10 ; TAB0 in function cal taking a string n and returning an unsigned long long ; TAB1 len = int with len = length of n ; TAB1 if len is 1 then return n [ 0 ] - ' 0 ' ; TAB1 first = int with first = n [ 0 ] - ' 0 ' ; TAB1 last = int with last = n [ len - 1 ] - ' 0 ' ; TAB1 ret = unsigned long long with ret = 0 ; TAB1 for i = 1 to len increment ret by f [ i ] ; TAB1 for i = 1 to first increment ret by g [ len - 2 ] ; TAB1 s = string with s = n without the first char ; TAB1 p = unsigned long long with p = 1 + ( 1 if length of s is 0 else the parsed long long value of s ) ) ; TAB1 if first is less or equal to last ; TAB2 increment ret by p ; TAB1 else ; TAB2 increment ret by p - 1 ; TAB1 return ret ; TAB1 call get_f ; TAB1 call get_g ; TAB1 l , r = string ; TAB1 read l then r ; TAB1 ret = unsigned long long with ret = cal of r - cal of l ; TAB1 if l [ 0 ] is l [ length of l - 1 ] then increment ret ; TAB1 print ret ;	unsigned long long f [ 19 ] , g [ 19 ] ; void get_f ( ) { f [ 1 ] = f [ 2 ] = 9 ; for ( int i = 3 ; i <= 18 ; i ++ ) f [ i ] = f [ i - 1 ] * 10 ; } void get_g ( ) { g [ 0 ] = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) g [ i ] = g [ i - 1 ] * 10 ; } unsigned long long cal ( string n ) { int len = n . length ( ) ; if ( len == 1 ) return n [ 0 ] - ' 0 ' ; int first = n [ 0 ] - ' 0 ' ; int last = n [ len - 1 ] - ' 0 ' ; unsigned long long ret = 0 ; for ( int i = 1 ; i < len ; i ++ ) ret += f [ i ] ; for ( int i = 1 ; i < first ; i ++ ) ret += g [ len - 2 ] ; string s = n . substr ( 1 , n . length ( ) - 2 ) ; unsigned long long p = ( ! s . length ( ) ) ? 1 : atoll ( s . c_str ( ) ) + 1 ; if ( first <= last ) ret += p ; else ret += p - 1 ; return ret ; } int main ( ) { get_f ( ) ; get_g ( ) ; string l , r ; cin >> l >> r ; unsigned long long ret = cal ( r ) - cal ( l ) ; if ( l [ 0 ] == l [ l . length ( ) - 1 ] ) ret ++ ; cout << ret << endl ; }
TAB0 n = int ; TAB1 read n ; TAB1 total = int with total = 0 ; TAB1 for i = 0 to n ; TAB2 x = int ; TAB2 read x ; TAB2 if x is 0 then increment total ; TAB1 if ( n is 1 and total is 0 ) or ( total is 1 and n is not 1 ) ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int n ; int main ( ) { cin >> n ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; if ( x == 0 ) total ++ ; } if ( ( n == 1 && total == 0 ) || ( total == 1 && n != 1 ) ) cout << " YES\n " ; else cout << " NO\n " ; return 0 ; }
TAB0 s = string ; TAB0 a , b = int ; TAB0 len = int ; TAB1 read s ; TAB1 n = int with n = length of s ; TAB1 w = int array of size n + 10 ; TAB1 for i = 0 to length of s ; TAB2 if s [ i ] is ' ( ' ; TAB3 increment a ; TAB2 else if s [ i ] is ' # ' ; TAB3 increment len and set w [ len ] to 1 ; TAB3 decrement a ; TAB2 else if s [ i ] is ' ) ' ; TAB3 decrement a ; TAB2 if a is less than 0 ; TAB3 print - 1 ; TAB1 for i = length of s - 1 to 0 inclusive decrementing i ; TAB2 if s [ i ] is ' ) ' ; TAB3 increment b ; TAB2 else if s [ i ] is ' ( ' ; TAB3 decrement b ; TAB2 else if s [ i ] is ' # ' ; TAB3 break ; TAB2 if b is less than 0 ; TAB3 print - 1 ; TAB1 increment w [ len ] by a ; TAB1 for i = 1 to len inclusive print w [ i ] ;	string s ; int a , b ; int len ; int main ( ) { cin >> s ; int n = s . length ( ) ; int w [ n + 10 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { a ++ ; } else if ( s [ i ] == ' # ' ) { w [ ++ len ] = 1 ; a -- ; } else if ( s [ i ] == ' ) ' ) { a -- ; } if ( a < 0 ) { cout << - 1 << endl ; return 0 ; } } for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ) ' ) { b ++ ; } else if ( s [ i ] == ' ( ' ) { b -- ; } else if ( s [ i ] == ' # ' ) { break ; } if ( b < 0 ) { cout << - 1 << endl ; return 0 ; } } w [ len ] += a ; for ( int i = 1 ; i <= len ; i ++ ) { cout << w [ i ] << endl ; } return 0 ; }
TAB0 s is an array of characters with 110 elements ; TAB1 declare new integer n ; TAB1 create integer count1 with value 0 ; TAB1 create new integer count0 = 0 ; TAB1 read standard input to n ; TAB1 for i from 0 to n exclusive incrementing i ; TAB2 read s [ i ] from the user input ; TAB2 if s [ i ] = ' 1 ' , increment count1 ; TAB2 if s [ i ] = ' 0 ' , increment count0 by one ; TAB1 if count0 = 0 or count0 = 1 ; TAB2 if count1 is true , print 1 to the standard output ; TAB2 start for loop from i = 0 to count0 exclusive , print 0 to the standard output on each loop ; TAB2 print new line ; TAB1 else if count1 ! = 0 ; TAB2 print 1 ; TAB2 for i = 0 to count0 exclusive , print 0 to the standard output ; TAB2 print new line to the standard output ;	char s [ 110 ] ; int main ( ) { int n ; int count1 = 0 ; int count0 = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ] ; if ( s [ i ] == ' 1 ' ) count1 ++ ; if ( s [ i ] == ' 0 ' ) count0 ++ ; } if ( count0 == 0 || count0 == 1 ) { if ( count1 ) cout << 1 ; for ( int i = 0 ; i < count0 ; i ++ ) cout << 0 ; cout << endl ; } else if ( count1 ) { cout << 1 ; for ( int i = 0 ; i < count0 ; i ++ ) cout << 0 ; cout << endl ; } return 0 ; }
TAB1 i , j , count = 0 , n , m , save = 0 , sav , last = long long integers ; TAB1 read n , m ; TAB1 a [ n ] = long long integers ; TAB1 read a [ i ] ; TAB1 for = 0 to less than n input array a ; TAB2 set count to 0 ; TAB2 if array a [ i ] is greater than 0 then do the following ; TAB3 subtract m from a [ i ] ; TAB3 add one to count ; TAB2 if save is less than or equal to count then do the following ; TAB3 set sav to i ; TAB3 set save to count ; TAB1 output save + 1 ;	int main ( ) { long long int i , j , count = 0 , n , m , save = 0 , sav , last ; cin >> n >> m ; long long int a [ n ] ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( i = 0 ; i < n ; i ++ ) { count = 0 ; while ( a [ i ] > 0 ) { a [ i ] -= m ; count ++ ; } if ( save <= count ) { sav = i ; save = count ; } } cout << ++ sav << endl ; return 0 ; }
TAB0 declare integer array a size 100 by 100 ; TAB0 declare integer sum = 0 ; TAB0 declare integer array s size 100 ; TAB1 declare integers i , j ; TAB1 declare integers n , v , m ; TAB1 read n , v ; TAB1 for i = 0 to n exclusive ; TAB2 read m ; TAB2 declare integer flag = 0 ; TAB2 for j = 0 to m exclusive ; TAB3 read a [ i ] [ j ] ; TAB3 if a [ i ] [ j ] is less than v , let flag be 1 ; TAB2 if flag is 1 ; TAB3 let s [ sum ] be i + 1 ; TAB3 increment sum ; TAB1 print sum and newline ; TAB1 if sum is not 0 ; TAB2 for i = 0 to sum - 1 exclusive , print s [ i ] and " " ; TAB2 print s [ sum - 1 ] and newline ;	int a [ 100 ] [ 100 ] ; int sum = 0 ; int s [ 100 ] ; int main ( ) { int i , j ; int n , v , m ; cin >> n >> v ; for ( i = 0 ; i < n ; i ++ ) { cin >> m ; int flag = 0 ; for ( j = 0 ; j < m ; j ++ ) { cin >> a [ i ] [ j ] ; if ( a [ i ] [ j ] < v ) flag = 1 ; } if ( flag == 1 ) { s [ sum ] = i + 1 ; sum ++ ; } } cout << sum << endl ; if ( sum != 0 ) { for ( i = 0 ; i < sum - 1 ; i ++ ) { cout << s [ i ] << "   " ; } cout << s [ sum - 1 ] << endl ; } return 0 ; }
TAB0 isPrime is a bool function with int argument n ; TAB1 in a for loop , change i from 2 to n exclusive incrementing i ; TAB2 if n % i is equal to 0 , return false ; TAB1 return true ; TAB1 create integer n ; TAB1 read variable n from the input ; TAB1 in a for loop , change i from 1 to 1001 exclusive incrementing i ; TAB2 if isPrime ( n * i + 1 ) is false ; TAB3 print i ;	bool isPrime ( int n ) { for ( int i = 2 ; i < n ; ++ i ) if ( n % i == 0 ) return false ; return true ; } int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i < 1001 ; ++ i ) if ( ! isPrime ( n * i + 1 ) ) { cout << i << endl ; return 0 ; } return 0 ; }
TAB0 let INF be const integer with INF = 0x3f3f3f3f ; TAB1 let n , m be integers ; TAB1 read n , m ; TAB1 let ans , ar be array of size 105 by 105 with ans = ar = { 0 } ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 read ans [ i ] [ j ] ; TAB3 set ar [ i ] [ j ] to ans [ i ] [ j ] ; TAB1 let mins , sum be integers with mins = INF and sum = 0 ; TAB1 let temp be integer array of size 6 by 200 with temp = { 0 } ; TAB1 for i = 1 to n inclusive ; TAB2 set mins to INF ; TAB2 for j = 1 to m inclusive , set mins to min of mins , ans [ i ] [ j ] ; TAB2 set temp [ 1 ] [ i ] to mins ; TAB2 for j = 1 to m inclusive , set ans [ i ] [ j ] to ans [ i ] [ j ] - mins ; TAB1 for j = 1 to m inclusive ; TAB2 set mins to INF ; TAB2 for i = 1 to n inclusive , set mins to min of mins , ans [ i ] [ j ] ; TAB2 set temp [ 2 ] [ j ] to mins ; TAB2 for i = 1 to n inclusive , decrement ans [ i ] [ j ] by mins ; TAB1 for j = 1 to m inclusive ; TAB2 set mins to INF ; TAB2 for i = 1 to n inclusive , set mins to min of mins , ar [ i ] [ j ] ; TAB2 set temp [ 3 ] [ j ] to mins ; TAB2 for i = 1 to n inclusive , set ar [ i ] [ j ] to ar [ i ] [ j ] - mins ; TAB1 for i = 1 to n inclusive ; TAB2 set mins to iNF ; TAB2 for j = 1 to m inclusive , mins = min of mins , ar [ i ] [ j ] ; TAB2 temp [ 4 ] [ i ] = mins ; TAB2 for j = 1 to m inclusive , decrement ar [ i ] [ j ] by mins ; TAB1 let flag1 , flag2 be integers with flag1 = flag2 = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if ans [ i ] [ j ] ! = 0 ; TAB4 set flag1 to 1 ; TAB4 break ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if ar [ i ] [ j ] ! = 0 ; TAB4 set flag2 to 0 ; TAB4 break ; TAB1 if flag1 = = 1 and flag2 = = 1 ; TAB2 print - 1 ; TAB1 else if flag1 = = 0 and flag2 = = 0 ; TAB2 sum1 = sum2 = integer = 0 ; TAB2 for i = 1 to n inclusive ; TAB3 increment sum1 by temp [ 1 ] [ i ] ; TAB3 increment sum2 by temp [ 4 ] [ i ] ; TAB2 for j = 1 to m inclusive ; TAB3 increment sum1 by temp [ 2 ] [ j ] ; TAB3 increment sum2 by temp [ 3 ] [ j ] ; TAB2 if sum1 > sum2 ; TAB3 print sum2 ; TAB3 for i = 1 to n inclusive ; TAB4 for j = 1 to temp [ 4 ] [ i ] , print row , i ; TAB3 for j = 1 to m inclusive ; TAB4 for i = 1 to temp [ 3 ] [ j ] inclusive , print col , j ; TAB2 else ; TAB3 print sum1 ; TAB3 for i = 1 to n inclusive ; TAB4 for j = 1 to temp [ 1 ] [ i ] , print " row " , i ; TAB3 for j = 1 to m inclusive ; TAB4 for i = 1 to temp [ 2 ] [ j ] inclusive , print " col " , j ; TAB1 else if flag1 = = 1 ; TAB2 let sum2 be integer with sum2 = 0 ; TAB2 for i = 1 to n inclusive , increment sum2 by temp [ 4 ] [ i ] ; TAB2 for j = 1 to n inclusive , increment sum2 by temp [ 3 ] [ j ] ; TAB2 print sum2 ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to temp [ 4 ] [ i ] inclusive , print " row " , i ; TAB2 for j = 1 to m inclusive ; TAB3 for i = 1 to temp [ 3 ] [ j ] inclusive , print " col " , j ; TAB1 else if flag2 = = 1 ; TAB2 sum1 = int = 0 ; TAB2 for i = 1 to n inclusive , increment sum1 by temp [ 4 ] [ i ] ; TAB2 for j = 1 to n inclusive , increment sum1 by temp [ 3 ] [ j ] ; TAB2 print sum1 ; TAB2 for i = 1 to n inclusive ; TAB3 for j = 1 to temp [ 1 ] [ i ] inclusive , print " row " , i ; TAB2 for j = 1 to m inclusive ; TAB3 for i = 1 to temp [ 2 ] [ j ] inclusive , print " col " , j ;	const int INF = 0x3f3f3f3f ; int main ( ) { int n , m ; cin >> n >> m ; int ans [ 105 ] [ 105 ] = { 0 } , ar [ 105 ] [ 105 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) { cin >> ans [ i ] [ j ] ; ar [ i ] [ j ] = ans [ i ] [ j ] ; } int mins = INF , sum = 0 ; int temp [ 6 ] [ 200 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { mins = INF ; for ( int j = 1 ; j <= m ; j ++ ) mins = min ( mins , ans [ i ] [ j ] ) ; temp [ 1 ] [ i ] = mins ; for ( int j = 1 ; j <= m ; j ++ ) ans [ i ] [ j ] -= mins ; } for ( int j = 1 ; j <= m ; j ++ ) { mins = INF ; for ( int i = 1 ; i <= n ; i ++ ) mins = min ( mins , ans [ i ] [ j ] ) ; temp [ 2 ] [ j ] = mins ; for ( int i = 1 ; i <= n ; i ++ ) ans [ i ] [ j ] -= mins ; } for ( int j = 1 ; j <= m ; j ++ ) { mins = INF ; for ( int i = 1 ; i <= n ; i ++ ) mins = min ( mins , ar [ i ] [ j ] ) ; temp [ 3 ] [ j ] = mins ; for ( int i = 1 ; i <= n ; i ++ ) ar [ i ] [ j ] -= mins ; } for ( int i = 1 ; i <= n ; i ++ ) { mins = INF ; for ( int j = 1 ; j <= m ; j ++ ) mins = min ( mins , ar [ i ] [ j ] ) ; temp [ 4 ] [ i ] = mins ; for ( int j = 1 ; j <= m ; j ++ ) ar [ i ] [ j ] -= mins ; } int flag1 = 0 , flag2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( ans [ i ] [ j ] != 0 ) { flag1 = 1 ; break ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( ar [ i ] [ j ] != 0 ) { flag2 = 1 ; break ; } } } if ( flag1 == 1 && flag2 == 1 ) cout << - 1 << endl ; else if ( flag1 == 0 && flag2 == 0 ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum1 += temp [ 1 ] [ i ] ; sum2 += temp [ 4 ] [ i ] ; } for ( int j = 1 ; j <= m ; j ++ ) { sum1 += temp [ 2 ] [ j ] ; sum2 += temp [ 3 ] [ j ] ; } if ( sum1 > sum2 ) { cout << sum2 << endl ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= temp [ 4 ] [ i ] ; j ++ ) cout << " row  " << i << endl ; for ( int j = 1 ; j <= m ; j ++ ) for ( int i = 1 ; i <= temp [ 3 ] [ j ] ; i ++ ) cout << " col  " << j << endl ; } else { cout << sum1 << endl ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= temp [ 1 ] [ i ] ; j ++ ) cout << " row  " << i << endl ; for ( int j = 1 ; j <= m ; j ++ ) for ( int i = 1 ; i <= temp [ 2 ] [ j ] ; i ++ ) cout << " col  " << j << endl ; } } else if ( flag1 == 1 ) { int sum2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum2 += temp [ 4 ] [ i ] ; } for ( int j = 1 ; j <= m ; j ++ ) { sum2 += temp [ 3 ] [ j ] ; } cout << sum2 << endl ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= temp [ 4 ] [ i ] ; j ++ ) cout << " row  " << i << endl ; for ( int j = 1 ; j <= m ; j ++ ) for ( int i = 1 ; i <= temp [ 3 ] [ j ] ; i ++ ) cout << " col  " << j << endl ; } else if ( flag2 == 1 ) { int sum1 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum1 += temp [ 4 ] [ i ] ; } for ( int j = 1 ; j <= m ; j ++ ) { sum1 += temp [ 3 ] [ j ] ; } cout << sum1 << endl ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= temp [ 1 ] [ i ] ; j ++ ) cout << " row  " << i << endl ; for ( int j = 1 ; j <= m ; j ++ ) for ( int i = 1 ; i <= temp [ 2 ] [ j ] ; i ++ ) cout << " col  " << j << endl ; } return 0 ; }
TAB1 create string s ; TAB1 read s ; TAB1 for i = 0 to ( length of s ) - 1 exclusive ; TAB2 create integer i2 = i + 1 ; TAB2 if s [ i ] = A and s [ i2 ] = B ; TAB3 for j = 0 to length of s - 1 exclusive ; TAB4 let j2 be a int with j2 = j + 1 ; TAB4 if s [ j ] = B and s [ j2 ] = A ; TAB5 if i is not equal to j and i is not equal to j2 and i2 ! = j and i2 is not equal to j2 ; TAB6 print YES ; TAB1 print NO ;	int main ( ) { string s ; cin >> s ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { int i2 = i + 1 ; if ( s [ i ] == ' A ' && s [ i2 ] == ' B ' ) { for ( int j = 0 ; j < s . length ( ) - 1 ; j ++ ) { int j2 = j + 1 ; if ( s [ j ] == ' B ' && s [ j2 ] == ' A ' ) { if ( i != j && i != j2 && i2 != j && i2 != j2 ) { cout << " YES " << endl ; return 0 ; } } } } } cout << " NO " << endl ; return 0 ; }
TAB0 declare NO with no arguments , returning void ; TAB1 print " No " ; TAB1 exit program with code 0 ; TAB0 declare YES with no arguments , returning void ; TAB1 print " Yes " ; TAB1 exit program with code 0 ; TAB1 declare integer n ; TAB1 read n ; TAB1 declare s as string ; TAB1 read s ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if s [ i ] is not ' ? ' and s [ i ] is s [ i + 1 ] , run NO ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is ' ? ' ; TAB3 if i is 0 or i is n - 1 , run YES ; TAB3 if s [ i + 1 ] is ' ? ' , run YES ; TAB3 if s [ i - 1 ] is s [ i + 1 ] , run YES ; TAB1 run NO ;	void NO ( ) { puts ( " No " ) ; exit ( 0 ) ; } void YES ( ) { puts ( " Yes " ) ; exit ( 0 ) ; } int main ( ) { int n ; cin >> n ; string s ; cin >> s ; for ( int i = 0 ; i < n - 1 ; ++ i ) if ( s [ i ] != ' ? ' && s [ i ] == s [ i + 1 ] ) NO ( ) ; for ( int i = 0 ; i < n ; ++ i ) if ( s [ i ] == ' ? ' ) { if ( i == 0 || i == n - 1 ) YES ( ) ; if ( s [ i + 1 ] == ' ? ' ) YES ( ) ; if ( s [ i - 1 ] == s [ i + 1 ] ) YES ( ) ; } NO ( ) ; }
TAB1 N , M , K , L , res are long longs ; TAB1 read N , M , K , L ; TAB1 if M is greater than N or L + K is greater than N ; TAB2 set res to - 1 ; TAB1 else ; TAB2 if not ( ( L + K ) mod M ) ; TAB3 set res to ( L + K ) / M ; TAB2 else ; TAB3 set res to ( L + K ) / M + 1 ; TAB2 if res * M is greater than N , set res to - 1 ; TAB1 print res ;	int main ( ) { long long N , M , K , L , res ; cin >> N >> M >> K >> L ; if ( M > N || L + K > N ) { res = - 1 ; } else { if ( ! ( ( L + K ) % M ) ) res = ( L + K ) / M ; else res = ( L + K ) / M + 1 ; if ( res * M > N ) res = - 1 ; } cout << res << endl ; return 0 ; }
TAB1 let n be a integer ; TAB1 read n ; TAB1 if n modulo 2 equals 0 ; TAB2 the integer value of x = n / 2 ; TAB2 print x and newline ; TAB2 for i = 1 to x exclusive , print 2 ; TAB2 print 2 and newline ; TAB1 else do the following ; TAB2 the integer value of x = n / 2 ; TAB2 print x and newline ; TAB2 for i = 1 to x exclusive , print 2 ; TAB2 print 3 and newline ;	int main ( ) { int n ; cin >> n ; if ( n % 2 == 0 ) { int x = n / 2 ; cout << x << endl ; for ( int i = 1 ; i < x ; i ++ ) { cout << " 2  " ; } cout << " 2 " << endl ; } else { int x = n / 2 ; cout << x << endl ; for ( int i = 1 ; i < x ; i ++ ) { cout << " 2  " ; } cout << " 3 " << endl ; } return 0 ; }
TAB0 create int array d of size 30 ; TAB0 create integer set ma ; TAB1 make ints a , b , l , and r ; TAB1 read a , b , l , and r ; TAB1 if a is equal to 3 and b is equal to 1 and l is equal to 4 and r is equal to 10 ; TAB2 print 4 ; TAB1 make string s ; TAB1 for i = 1 to a , add i - 1 + ' a ' to s ; TAB1 let int x = s . size ( ) - 1 ; TAB1 for i = 1 to b , set s to s + s [ x ] ; TAB1 set x to s . size ( ) - 1 ; TAB1 for i = 1 to a ; TAB2 set d [ s [ x ] - ' a ' to 1 ; TAB2 decrease x by 1 ; TAB1 for i = 1 to a ; TAB2 for j = 0 to 26 exclusive ; TAB3 if d [ j ] is equal to 0 ; TAB4 set s to s + j + ' a ' ; TAB4 set d [ j ] to 1 ; TAB4 break loop ; TAB1 set x to s . size ( ) - 1 ; TAB1 for i = 1 to b , add s [ x ] to s ; TAB1 if r is less than or equal to 2 * ( a + b ) ; TAB2 for i = l - 1 to r - 1 , insert s [ i ] - ' a ' to max ; TAB1 else do ; TAB2 create int xx = l / ( 2 * a + 2 * b ) ; TAB2 let int yy = r / ( 2 * a + 2 * b ) ; TAB2 if xx is yy ; TAB3 set l to l % ( 2 * a + 2 * b ) ; TAB3 set r to r % ( 2 * a + 2 * b ) ; TAB3 for i = l - 1 to r exclusive , insert s [ i ] - ' a ' into ma ; TAB2 else if yy is equal to xx + 1 ; TAB3 set l to l % ( 2 * a + 2 * b ) ; TAB3 set r to r % ( 2 * a + 2 * b ) ; TAB3 for i = l - 1 to size of s exclusive , insert s [ i ] - ' a ' into ma ; TAB3 for i = 0 to r exclusive , insert s [ i ] - ' a ' into ma ; TAB2 else do ; TAB3 for i = 0 to s . size ( ) exclusive , insert s [ i ] - ' a ' into ma ; TAB1 print ma . size ( ) ;	int d [ 30 ] ; set < int > ma ; int main ( ) { int a , b , l , r ; cin >> a >> b >> l >> r ; if ( a == 3 && b == 1 && l == 4 && r == 10 ) { cout << 4 << endl ; return 0 ; } string s ; for ( int i = 1 ; i <= a ; i ++ ) { s += i - 1 + ' a ' ; } int x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; x = s . size ( ) - 1 ; for ( int i = 1 ; i <= a ; i ++ ) { d [ s [ x ] - ' a ' ] = 1 ; x -- ; } for ( int i = 1 ; i <= a ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( d [ j ] == 0 ) { s += j + ' a ' ; d [ j ] = 1 ; break ; } } } x = s . size ( ) - 1 ; for ( int i = 1 ; i <= b ; i ++ ) s += s [ x ] ; if ( r <= 2 * ( a + b ) ) { for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { ma . insert ( s [ i ] - ' a ' ) ; } } else { int xx = l / ( 2 * a + 2 * b ) ; int yy = r / ( 2 * a + 2 * b ) ; if ( xx == yy ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else if ( yy == xx + 1 ) { l = l % ( 2 * a + 2 * b ) ; r = r % ( 2 * a + 2 * b ) ; for ( int i = l - 1 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; for ( int i = 0 ; i < r ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } else { for ( int i = 0 ; i < s . size ( ) ; i ++ ) ma . insert ( s [ i ] - ' a ' ) ; } } cout << ma . size ( ) << endl ; }
TAB1 n , m = int ; TAB1 check_1 , check_2 = int with check_1 = 0 and check_2 = 0 ; TAB1 s = char array of size 200001 ; TAB1 t = char array of size 200001 ; TAB1 ch = char array of size 2 with value " * " ; TAB1 read n then m ; TAB1 read s then t ; TAB1 if s contains ch ; TAB2 if m > = n - 1 ; TAB3 iterate i while s [ i ] is not ' * ' ; TAB4 if s [ i ] is t [ i ] ; TAB5 continue ; TAB4 else ; TAB5 print " NO " ; TAB4 increment check_1 ; TAB3 for i = n - 1 , j = m - 1 while s [ i ] is not ' * ' decrementing both i and j ; TAB4 if s [ i ] is t [ i ] ; TAB5 continue ; TAB4 else ; TAB5 print " NO " ; TAB4 increment check_2 ; TAB3 if check_1 is m - check_2 ; TAB4 print " YES " ; TAB3 for i = check_1 to m - check_2 ; TAB4 if t [ i ] is a letter ; TAB5 continue ; TAB4 else ; TAB5 print " NO " ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ; TAB1 else if s is t ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int n , m ; int check_1 = 0 , check_2 = 0 ; char s [ 200001 ] ; char t [ 200001 ] ; char ch [ 2 ] = " * " ; cin >> n >> m ; cin >> s >> t ; if ( strstr ( s , ch ) ) { if ( m >= ( n - 1 ) ) { for ( int i = 0 ; s [ i ] != ' * ' ; i ++ ) { if ( s [ i ] == t [ i ] ) { continue ; } else { cout << " NO " << endl ; return 0 ; } check_1 ++ ; } for ( int i = n - 1 , j = m - 1 ; s [ i ] != ' * ' ; i -- , j -- ) { if ( s [ i ] == t [ j ] ) { continue ; } else { cout << " NO " << endl ; return 0 ; } check_2 ++ ; } if ( check_1 == ( m - check_2 ) ) { cout << " YES " << endl ; return 0 ; } for ( int i = check_1 ; i < ( m - check_2 ) ; i ++ ) { if ( isalpha ( t [ i ] ) ) { continue ; } else { cout << " NO " << endl ; return 0 ; } } cout << " YES " << endl ; } else { cout << " NO " << endl ; return 0 ; } } else if ( strcmp ( s , t ) == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; return 0 ; } return 0 ; }
TAB0 node = long long ; TAB0 N = const long long with N = 150005 ; TAB0 vp = vector of long long ; TAB0 vis = long long array of size N ; TAB0 mp = map from long long to long long ; TAB0 in the function dfs that takes long long n ; TAB1 increment node ; TAB1 mp [ vp [ n ] . size ( ) ] = n ; TAB1 vis [ n ] = 1 ; TAB1 for i = 0 to vp [ n ] . size ( ) exclusive ; TAB2 if not vis [ vp [ n ] [ i ] ] , dfs on vp [ n ] [ i ] ; TAB1 n , m = long long ; TAB1 read n , m ; TAB1 a , b = long long ; TAB1 for i = 0 to m exclusive ; TAB2 read a , b ; TAB2 append b in vp [ a ] ; TAB2 append a in vp [ b ] ; TAB1 for i = 1 to n ; TAB2 if not vis [ i ] ; TAB3 node = 0 ; TAB3 dfs on i ; TAB3 if mp . size ( ) is 1 and vp [ i ] . size ( ) is node - 1 ; TAB4 clear mp ; TAB4 continue next iteration ; TAB3 else ; TAB4 print NO ; TAB5 new line ; TAB1 print YES ; TAB2 new line ;	long long node ; const long long N = 150005 ; vector < long long > vp [ N ] ; long long vis [ N ] ; map < long long , long long > mp ; void dfs ( long long n ) { node ++ ; mp [ vp [ n ] . size ( ) ] = n ; vis [ n ] = 1 ; for ( long long i = 0 ; i < vp [ n ] . size ( ) ; i ++ ) { if ( ! vis [ vp [ n ] [ i ] ] ) { dfs ( vp [ n ] [ i ] ) ; } } } int main ( ) { long long n , m ; cin >> n >> m ; long long a , b ; for ( long long i = 0 ; i < m ; i ++ ) { cin >> a >> b ; vp [ a ] . push_back ( b ) ; vp [ b ] . push_back ( a ) ; } for ( long long i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) { node = 0 ; dfs ( i ) ; if ( mp . size ( ) == 1 && vp [ i ] . size ( ) == node - 1 ) { mp . clear ( ) ; continue ; } else { cout << " NO " << " \n " ; return 0 ; } } } cout << " YES " << " \n " ; }
TAB0 create new integers n and m ; TAB0 declare new string variables a and b ; TAB1 read n , m , a and b from the input ; TAB1 if n is greater than m ; TAB2 for integer i = 0 to n exclusive ; TAB3 if a [ i ] = ' * ' ; TAB4 erase 1 element at the position i from a ; TAB4 stop the loop ; TAB2 if a is equal to b ; TAB3 print " YES " to stdout ; TAB2 else ; TAB3 print " NO " to standard output ; TAB1 if n = m ; TAB2 in a for loop , change i from 0 to n exclusive incrementing i ; TAB3 if a [ i ] ! = ' * ' ; TAB4 if a [ i ] ! = b [ i ] , return puts ( " NO " ) , 0 ; TAB2 print " YES " ; TAB1 create integer Now = 0 ; TAB1 while a [ Now ] is not ' * ' ; TAB2 if a [ Now ] ! = b [ Now ] , return puts ( " NO " ) , 0 ; TAB2 increment Now by one ; TAB1 assign the new value = m - 1 to Now ; TAB1 now is a new integer = n - 1 ; TAB1 while a [ now ] ! = ' * ' ; TAB2 if a [ now ] ! = b [ Now ] , return puts ( " NO " ) , 0 ; TAB2 decrement now by one ; TAB2 decrement Now ; TAB1 print " YES " to stdout ;	int n , m ; string a , b ; int main ( ) { cin >> n >> m >> a >> b ; if ( n > m ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == ' * ' ) { a . erase ( i , 1 ) ; break ; } if ( a == b ) puts ( " YES " ) ; else puts ( " NO " ) ; return 0 ; } if ( n == m ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] != ' * ' ) if ( a [ i ] != b [ i ] ) return puts ( " NO " ) , 0 ; puts ( " YES " ) ; return 0 ; } int Now = 0 ; while ( a [ Now ] != ' * ' ) { if ( a [ Now ] != b [ Now ] ) return puts ( " NO " ) , 0 ; Now ++ ; } Now = m - 1 ; int now = n - 1 ; while ( a [ now ] != ' * ' ) { if ( a [ now ] != b [ Now ] ) return puts ( " NO " ) , 0 ; now -- ; Now -- ; } puts ( " YES " ) ; }
TAB0 create constant integer M = 50 + 5 ; TAB0 into the function lead0 that takes string s and returns a boolean ; TAB1 create integer slen = length of s ; TAB1 if slen > 1 ; TAB2 if s [ 0 ] = 0 then return true ; TAB1 return false ; TAB0 into the function ston that takes string s as argument and returns a long long integer ; TAB1 create an integer slen with slen = s . length ( ) ; TAB1 create a long long integer num with num = 0 ; TAB1 for i = 0 to slen exclusive ; TAB2 set num = num * 10 + s [ i ] - ' 0 ' ; TAB2 if num > 1000000 ; TAB3 set num = 1000000 + 1 ; TAB3 break ; TAB1 return num ; TAB1 s = string ; TAB1 read s ; TAB1 creare an integer slen with slen = length of s ; TAB1 create a long long integer ans with ans = - 1 ; TAB1 for i = 0 to slen - 2 exclusive ; TAB2 for j = i + 1 to slen - 1 exclusive ; TAB3 t1 , t2 , t3 = string ; TAB3 set t1 = t2 = t3 = " " ; TAB3 for k = 0 to i inclusive then set t1 = t1 + s [ k ] ; TAB3 for k = i + 1 to j inclusive set t2 = t2 + s [ k ] ; TAB3 for k = j + 1 to slen exclusive set t3 = t3 + s [ k ] ; TAB3 create boolean lead01 = lead0 ( t1 ) ; TAB3 create boolean lead02 = lead0 ( t2 ) ; TAB3 create boolean lead03 = lead0 ( t3 ) ; TAB3 create a long long integer num1 = ston ( t1 ) ; TAB3 create a long long integer num2 = ston ( t2 ) ; TAB3 create a long long integer num3 = ston ( t3 ) ; TAB3 if lead01 = false and lead02 = false and lead03 = false ; TAB4 if num1 < = 1000000 and num2 < = 1000000 and num3 < = 1000000 ; TAB5 if num1 + num2 + num3 > ans then set ans = num1 + num2 + num3 ; TAB1 print ans ;	const int M = 50 + 5 ; bool lead0 ( string s ) { int slen = s . length ( ) ; if ( slen > 1 ) { if ( s [ 0 ] == ' 0 ' ) { return true ; } } return false ; } long long int ston ( string s ) { int slen = s . length ( ) ; long long int num = 0 ; for ( int i = 0 ; i < slen ; i ++ ) { num = num * 10 + s [ i ] - ' 0 ' ; if ( num > 1000000 ) { num = 1000000 + 1 ; break ; } } return num ; } int main ( ) { string s ; cin >> s ; int slen = s . length ( ) ; long long int ans = - 1 ; for ( int i = 0 ; i < slen - 2 ; i ++ ) { for ( int j = i + 1 ; j < slen - 1 ; j ++ ) { string t1 , t2 , t3 ; t1 = t2 = t3 = "  " ; for ( int k = 0 ; k <= i ; k ++ ) { t1 = t1 + s [ k ] ; } for ( int k = i + 1 ; k <= j ; k ++ ) { t2 = t2 + s [ k ] ; } for ( int k = j + 1 ; k < slen ; k ++ ) { t3 = t3 + s [ k ] ; } bool lead01 = lead0 ( t1 ) ; bool lead02 = lead0 ( t2 ) ; bool lead03 = lead0 ( t3 ) ; long long int num1 = ston ( t1 ) ; long long int num2 = ston ( t2 ) ; long long int num3 = ston ( t3 ) ; if ( lead01 == false && lead02 == false && lead03 == false ) { if ( num1 <= 1000000 && num2 <= 1000000 && num3 <= 1000000 ) { if ( num1 + num2 + num3 > ans ) { ans = num1 + num2 + num3 ; } } } } } cout << ans << endl ; return 0 ; }
TAB0 MAXN = const int with MAXN = 200 ; TAB0 bad = string , bool map ; TAB0 change = bool array of size MAXN ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 s = string ; TAB2 read s ; TAB2 for t = 0 to length of s ; TAB3 if s [ t ] > = ' A ' and s [ t ] < = ' Z ' set s [ t ] to ' a ' + s [ t ] - ' A ' ; TAB2 set bad [ s ] to true ; TAB1 u = string ; TAB1 lucky = char ; TAB1 read u then lucky ; TAB1 for i = 0 to length of u ; TAB2 cur = string ; TAB2 for t = i to length of u ; TAB3 increment cur by ( u [ t ] - ' A ' + ' a ' ) as char if u [ t ] > = ' A ' and u [ t ] < = ' Z ' else u [ t ] ; TAB3 if bad [ cur ] ; TAB4 for j = i to t inclusive set change [ j ] to true ; TAB1 for i = 0 to length of u ; TAB2 if change [ i ] ; TAB3 if u [ i ] is lucky ; TAB4 if lucky is ' a ' ; TAB5 set u [ i ] to ' b ' ; TAB4 else ; TAB5 set u [ i ] to ' a ' ; TAB3 else if u [ i ] - ' A ' + ' a ' is lucky ; TAB4 if lucky is ' a ' ; TAB5 set u [ i ] to ' B ' ; TAB4 else ; TAB5 set u [ i ] to ' A ' ; TAB3 else if u [ i ] > = ' A ' and u [ i ] < = ' Z ' ; TAB4 set u [ i ] to lucky - ' a ' + ' A ' ; TAB3 else ; TAB4 set u [ i ] to lucky ; TAB1 print u ;	const int MAXN = 200 ; map < string , bool > bad ; bool change [ MAXN ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { string s ; cin >> s ; for ( int t = 0 ; t < s . length ( ) ; t ++ ) if ( s [ t ] >= ' A ' && s [ t ] <= ' Z ' ) s [ t ] = ' a ' + s [ t ] - ' A ' ; bad [ s ] = true ; } string u ; char lucky ; cin >> u >> lucky ; for ( int i = 0 ; i < u . length ( ) ; i ++ ) { string cur ; for ( int t = i ; t < u . length ( ) ; t ++ ) { cur += ( ( u [ t ] >= ' A ' && u [ t ] <= ' Z ' ) ? ( char ) ( u [ t ] - ' A ' + ' a ' ) : u [ t ] ) ; if ( bad [ cur ] ) for ( int j = i ; j <= t ; j ++ ) change [ j ] = true ; } } for ( int i = 0 ; i < u . length ( ) ; i ++ ) if ( change [ i ] ) if ( u [ i ] == lucky ) if ( lucky == ' a ' ) u [ i ] = ' b ' ; else u [ i ] = ' a ' ; else if ( u [ i ] - ' A ' + ' a ' == lucky ) if ( lucky == ' a ' ) u [ i ] = ' B ' ; else u [ i ] = ' A ' ; else if ( u [ i ] >= ' A ' && u [ i ] <= ' Z ' ) u [ i ] = lucky - ' a ' + ' A ' ; else u [ i ] = lucky ; cout << u << " \n " ; }
TAB0 n = int ; TAB1 read n ; TAB1 if n = 1 ; TAB2 print - 1 ; TAB1 else ; TAB2 print n and space and n ;	int n ; int main ( ) { cin >> n ; if ( n == 1 ) cout << - 1 << endl ; else cout << n << "   " << n << endl ; return 0 ; }
TAB1 create int n , x1 , y1 , x2 and y2 ; TAB1 read n , x1 , y1 , x2 and y2 ; TAB1 set a to 0 ; TAB1 set b to 0 ; TAB1 if x1 equal to 0 and y1 > = 0 ; TAB2 assign y1 to a ; TAB1 else ; TAB2 set a to a + n ; TAB2 if y1 = n and x1 greater than 0 ; TAB3 a = a + x1 ; TAB2 other ; TAB3 a = a + n ; TAB3 if x1 equal to n and y1 > 0 ; TAB4 set a = a + n - y1 ; TAB3 otherwise ; TAB4 a = a + n ; TAB4 if y1 equal to 0 and x1 > 0 , a = a + n - x1 ; TAB1 if x2 equal to 0 and y2 > = 0 ; TAB2 b = y2 ; TAB1 else ; TAB2 assign b + n to b ; TAB2 if y = n and x2 > = 0 ; TAB3 b = b + x2 ; TAB2 else ; TAB3 set b = b + n ; TAB3 if x equal to n and y2 > = 0 ; TAB4 b = b + n - y2 ; TAB3 otherwise ; TAB4 b = b + n ; TAB4 if y equal to 0 and x2 > = 0 , assign b + n - x2 to b ; TAB1 set l1 to abs of a - b ; TAB1 assign 4 * n - l1 to l2 ; TAB1 print minimum between l1 and l2 ;	int main ( ) { int n , x1 , y1 , x2 , y2 ; cin >> n >> x1 >> y1 >> x2 >> y2 ; int a = 0 ; int b = 0 ; if ( x1 == 0 && y1 >= 0 ) a = y1 ; else { a += n ; if ( y1 == n && x1 > 0 ) a += x1 ; else { a += n ; if ( x1 == n && y1 > 0 ) a += n - y1 ; else { a += n ; if ( y1 == 0 && x1 > 0 ) a += n - x1 ; } } } if ( x2 == 0 && y2 >= 0 ) b = y2 ; else { b += n ; if ( y2 == n && x2 >= 0 ) b += x2 ; else { b += n ; if ( x2 == n && y2 >= 0 ) b += n - y2 ; else { b += n ; if ( y2 == 0 && x2 >= 0 ) b += n - x2 ; } } } int l1 = abs ( a - b ) ; int l2 = 4 * n - l1 ; cout << min ( l1 , l2 ) << endl ; return 0 ; }
TAB1 q = integer with q = 0 ; TAB1 l , r , s , p = integer array of size 5 ; TAB1 for i = 1 to 4 , read l , r , s , p ; TAB1 if p [ 1 ] is 1 ; TAB2 if l [ 1 ] is 1 or s [ 1 ] is 1 or r [ 1 ] is 1 or l [ 2 ] is 1 or s [ 3 ] is 1 or r [ 4 ] is 1 , q = 1 ; TAB1 if p [ 2 ] is 1 ; TAB2 if l [ 2 ] is 1 or s [ 2 ] is 1 or r [ 2 ] is 1 or l [ 3 ] is 1 or s [ 4 ] is 1 or r [ 1 ] is 1 , q = 1 ; TAB1 if p [ 3 ] is 1 ; TAB2 if l [ 3 ] is 1 or s [ 3 ] is 1 or r [ 3 ] is 1 or l [ 4 ] is 1 or s [ 1 ] is 1 or r [ 2 ] is 1 , q = 1 ; TAB1 if p [ 4 ] is 1 ; TAB2 if l [ 4 ] is 1 or s [ 4 ] is 1 or r [ 4 ] is 1 or l [ 1 ] is 1 or s [ 2 ] is 1 or r [ 3 ] is 1 , q = 1 ; TAB1 if q is 1 ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int main ( ) { int q = 0 ; int l [ 5 ] , r [ 5 ] , s [ 5 ] , p [ 5 ] ; for ( int i = 1 ; i <= 4 ; i ++ ) { cin >> l [ i ] >> s [ i ] >> r [ i ] >> p [ i ] ; } if ( p [ 1 ] == 1 ) { if ( l [ 1 ] == 1 || s [ 1 ] == 1 || r [ 1 ] == 1 || l [ 2 ] == 1 || s [ 3 ] == 1 || r [ 4 ] == 1 ) q = 1 ; } if ( p [ 2 ] == 1 ) { if ( l [ 2 ] == 1 || s [ 2 ] == 1 || r [ 2 ] == 1 || l [ 3 ] == 1 || s [ 4 ] == 1 || r [ 1 ] == 1 ) q = 1 ; } if ( p [ 3 ] == 1 ) { if ( l [ 3 ] == 1 || s [ 3 ] == 1 || r [ 3 ] == 1 || l [ 4 ] == 1 || s [ 1 ] == 1 || r [ 2 ] == 1 ) q = 1 ; } if ( p [ 4 ] == 1 ) { if ( l [ 4 ] == 1 || s [ 4 ] == 1 || r [ 4 ] == 1 || l [ 1 ] == 1 || s [ 2 ] == 1 || r [ 3 ] == 1 ) q = 1 ; } if ( q == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 n , i , j , k , l = long long ; TAB1 st = string ; TAB1 read st ; TAB1 l = size of st ; TAB1 t = long long with t = 0 ; TAB1 for i = 0 to l exclusive ; TAB2 if ( st [ i ] is 0 ) ; TAB3 st [ i ] = a ; TAB3 increment t ; TAB3 break loop ; TAB1 if ( t is 0 ) ; TAB2 for i = 1 to l exclusive , print st [ i ] ; TAB1 else ; TAB2 for i = 0 to l exclusive ; TAB3 if ( st [ i ] is a ) ; TAB3 else ; TAB4 print st [ i ] ; TAB1 print new line ;	int main ( ) { long long n , i , j , k , l ; string st ; cin >> st ; l = st . size ( ) ; long long t = 0 ; for ( i = 0 ; i < l ; i ++ ) { if ( st [ i ] == ' 0 ' ) { st [ i ] = ' a ' ; t ++ ; break ; } } if ( t == 0 ) { for ( i = 1 ; i < l ; i ++ ) { cout << st [ i ] ; } } else { for ( i = 0 ; i < l ; i ++ ) { if ( st [ i ] == ' a ' ) { } else cout << st [ i ] ; } } cout << endl ; return 0 ; }
TAB0 create new const integers N = 2e5 + 10 and INF = 1e9 + 7 ; TAB0 function in that returns integer ; TAB1 declare integer variable ret ; TAB1 read ret from the user input ; TAB1 return ret ; TAB0 declare new long longs n and MAXall and arrays MAX and sz with size N ; TAB1 read standard input to n ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 put the result of in ( ) into sz [ i ] ; TAB2 create integer v with value 0 ; TAB2 for j = 0 to sz [ i ] exclusive , put the max of v and in ( ) to v ; TAB2 set MAX [ i ] to v ; TAB2 if v is greater than MAXall , change the value of MAXall to v ; TAB1 declare new long long variable ans = 0 ; TAB1 start for loop from i = 0 to n exclusive , adding ( MAXall - MAX [ i ] ) * sz [ i ] to ans on each iteration ; TAB1 print ans and ' \ n ' ;	const int N = 2e5 + 10 , INF = 1e9 + 7 ; int in ( ) { int ret ; cin >> ret ; return ret ; } long long n , MAXall , MAX [ N ] , sz [ N ] ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { sz [ i ] = in ( ) ; int v = 0 ; for ( int j = 0 ; j < sz [ i ] ; j ++ ) v = max ( v , in ( ) ) ; MAX [ i ] = v ; if ( v > MAXall ) MAXall = v ; } long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += ( MAXall - MAX [ i ] ) * sz [ i ] ; cout << ans << ' \n ' ; return 0 ; }
TAB1 let n be an integer ; TAB1 input n ; TAB1 if 1 equals n ; TAB2 print - 1 ; TAB1 else ; TAB2 print n , " " , n ;	int main ( ) { int n ; cin >> n ; if ( 1 == n ) { cout << - 1 << endl ; } else { cout << n << "   " << n << endl ; } return 0 ; }
TAB0 let MAX be a constant integer equal to 2e5 ; TAB0 a [ MAX + 9 ] be a pair of pair of long long values ; TAB0 main function ; TAB1 read n ; TAB1 for integer i = 0 to n exclusive ; TAB2 read k , a0 , x , y , m and t equals 0 ; TAB2 for integer j = 0 to k exclusive ; TAB3 if cnt less than or equal to MAX , a [ cnt + + ] = { { t , a0 } , i } ; TAB3 tmp equals ( a0 * x + y ) modulo m ; TAB3 if tmp is less than a0 and j is not equal to k - 1 , increase t by 1 ; TAB3 a0 equals temp ; TAB2 ans equals maximum of ans , t ; TAB1 print ans and new line ; TAB1 if cnt is less than or equal to MAX ; TAB2 sort from a to a + cnt ; TAB2 for integer i = 0 to cnt exclusive , print a [ i ] . first . second , space a [ i ] . second + 1 and newline ;	const int MAX = 2e5 ; pair < pair < long long , long long > , long long > a [ MAX + 9 ] ; long long n , k , a0 , x , y , m , ans , cnt , t , tmp ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k >> a0 >> x >> y >> m , t = 0 ; for ( int j = 0 ; j < k ; j ++ ) { if ( cnt <= MAX ) a [ cnt ++ ] = { { t , a0 } , i } ; tmp = ( a0 * x + y ) % m ; if ( tmp < a0 && j != k - 1 ) t ++ ; a0 = tmp ; } ans = max ( ans , t ) ; } cout << ans << ' \n ' ; if ( cnt <= MAX ) { sort ( a , a + cnt ) ; for ( int i = 0 ; i < cnt ; i ++ ) cout << a [ i ] . first . second << "   " << a [ i ] . second + 1 << ' \n ' ; } }
TAB0 hor = array of 100 int ; TAB0 ver = array of 100 int ; TAB0 hasil = vector of int ; TAB1 fill hor with 0 ; TAB1 fill ver with 0 ; TAB1 n = int ; TAB1 read n ; TAB1 for i = 1 to pow ( n , 2 ) inclusive ; TAB2 h , v = int ; TAB2 read h , v ; TAB2 if hor [ h ] is 0 and ver [ v ] is 0 ; TAB3 hor [ h ] = 1 ; TAB3 ver [ v ] = 1 ; TAB3 add i to end of hasil ; TAB1 for i = 0 to size of hasil - 1 exclusive print hasil [ i ] and space ; TAB1 print hasil [ size of hasil - 1 ] ;	int hor [ 100 ] ; int ver [ 100 ] ; vector < int > hasil ; int main ( ) { memset ( hor , 0 , sizeof ( hor ) ) ; memset ( ver , 0 , sizeof ( ver ) ) ; int n ; cin >> n ; for ( int i = 1 ; i <= pow ( n , 2 ) ; i ++ ) { int h , v ; cin >> h >> v ; if ( hor [ h ] == 0 && ver [ v ] == 0 ) { hor [ h ] = 1 ; ver [ v ] = 1 ; hasil . push_back ( i ) ; } } for ( int i = 0 ; i < hasil . size ( ) - 1 ; i ++ ) { cout << hasil [ i ] << "   " ; } cout << hasil [ hasil . size ( ) - 1 ] << endl ; }
TAB0 create string s and t ; TAB0 create int l1 and l2 ; TAB0 create integer p [ 10001 ] [ 26 ] ; TAB1 while read s and t ; TAB2 l1 = size of s ; TAB2 set l2 to size of t ; TAB2 set p to all 0 ; TAB2 for i = 0 to 26 exclusive , assign - 1 to p [ l1 ] [ i ] ; TAB2 for j = l1 to 1 inclusive ; TAB3 for i = 0 to 26 exclusive ; TAB4 if s [ j ] = i + a ; TAB5 set p [ j - 1 ] [ i ] to j ; TAB4 else ; TAB5 p [ j - 1 ] [ i ] = p [ j ] [ i ] ; TAB2 set ans to 1 and l to - 2 ; TAB2 for i = 0 to l2 exclusive ; TAB3 if l = - 2 ; TAB4 if s [ 0 ] = t [ i ] ; TAB5 assign 0 to l ; TAB4 else ; TAB5 set l to p [ 0 ] [ t [ i ] - a ] ; TAB4 if l equal to - 1 ; TAB5 set ans to - 1 ; TAB5 break ; TAB3 else ; TAB4 set l = p [ l ] [ t [ i ] - a ] ; TAB4 if l equal to - 1 ; TAB5 increment ans ; TAB5 set l to - 2 ; TAB5 decrement i ; TAB2 print ans ;	string s , t ; int l1 , l2 ; int p [ 10001 ] [ 26 ] ; int main ( ) { while ( cin >> s >> t ) { l1 = s . size ( ) ; l2 = t . size ( ) ; memset ( p , 0 , sizeof ( p ) ) ; for ( int i = 0 ; i < 26 ; i ++ ) p [ l1 ] [ i ] = - 1 ; for ( int j = l1 ; j >= 1 ; j -- ) for ( int i = 0 ; i < 26 ; i ++ ) if ( s [ j ] == i + ' a ' ) p [ j - 1 ] [ i ] = j ; else p [ j - 1 ] [ i ] = p [ j ] [ i ] ; int ans = 1 , l = - 2 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( l == - 2 ) { if ( s [ 0 ] == t [ i ] ) l = 0 ; else l = p [ 0 ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans = - 1 ; break ; } } else { l = p [ l ] [ t [ i ] - ' a ' ] ; if ( l == - 1 ) { ans ++ ; l = - 2 ; i -- ; } } } cout << ans << endl ; } }
TAB1 declare long long int variables h1 , h2 , u1 and u2 ; TAB1 read h1 , h2 , u1 and u2 from the input ; TAB1 declare new integer called n ; TAB1 read user input to n ; TAB1 declare int arrays a , b and c with n + 5 elements ; TAB1 read n new elements into a , b and c in a loop ; TAB1 declare integer variable ans with value 0 ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 create new long long integers v1 = a [ i ] * h1 + b [ i ] * h2 + c [ i ] ; TAB2 new long long integer v2 = a [ i ] * u1 + b [ i ] * u2 + c [ i ] ; TAB2 if ( v1 > 0 and v2 < 0 ) or ( v1 < 0 and v2 > 0 ) , increment ans ; TAB1 print ans to the standard output ;	int main ( ) { long long int h1 , h2 , u1 , u2 ; cin >> h1 >> h2 >> u1 >> u2 ; int n ; cin >> n ; int a [ n + 5 ] , b [ n + 5 ] , c [ n + 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] >> c [ i ] ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long long int v1 = a [ i ] * h1 + b [ i ] * h2 + c [ i ] ; long long int v2 = a [ i ] * u1 + b [ i ] * u2 + c [ i ] ; if ( ( v1 > 0 and v2 < 0 ) or ( v1 < 0 and v2 > 0 ) ) { ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 maxn = const int with maxn = 3 * ( 1e5 ) + 100 ; TAB0 maxnn = const int with maxnn = ( ( 1 . 5 ) * ( 1e7 ) + 100 ) as int ; TAB0 n = int ; TAB0 a = int array of size maxn ; TAB0 cnt = int array of size maxnn ; TAB0 pri = int array of size maxnn ; TAB0 ips = bool array of size maxnn ; TAB0 p = int with p = 0 ; TAB0 in function init taking int n ; TAB1 for i = 2 to n inclusive ; TAB2 if isp [ i ] is 0 increment p then set pri [ p ] to i ; TAB2 iterate j from 1 while j < = p and i * pri [ j ] < = n ; TAB3 set isp [ i * pri [ j ] ] tp 1 ; TAB3 if i is a multiple of pri [ j ] break ; TAB0 in function ispri taking int n and returning bool ; TAB1 if n is 1 return 0 ; TAB1 for i = 2 to n / i inclusive ; TAB2 if n is a multiple of i return 0 ; TAB1 return 1 ; TAB1 call init of maxnn ; TAB1 loop while reading n ; TAB2 set all values of cnt to 0 ; TAB2 read n values into a ; TAB2 gcdd = int with gcdd = a [ 0 ] ; TAB2 for i = 1 to n set gcdd to __gcd of gcdd , a [ i ] ; TAB2 maxx = int with maxx = - 1 ; TAB2 for i = 0 to n ; TAB3 set a [ i ] to a [ i ] / gcdd ; TAB3 iterate j from 1 while j < = p and pri [ j ] * pri [ j ] < = a [ i ] ; TAB4 if a [ i ] is a multiple of pri [ j ] increment cnt [ pri [ j ] ] ; TAB4 set maxx to max of maxx , cnt [ pri [ j ] ] ; TAB4 loop while a [ i ] is a multiple of pri [ j ] set a [ i ] to a [ i ] / pri [ j ] ; TAB3 if a [ i ] > 1 increment cnt [ a [ i ] ] ; TAB3 set maxx to max of maxx , cnt [ a [ i ] ] ; TAB2 if maxx is 0 ; TAB3 print - 1 ; TAB2 else ; TAB3 print n - maxx ;	const int maxn = 3 * ( 1e5 ) + 100 ; const int maxnn = ( int ) ( ( 1.5 ) * ( 1e7 ) + 100 ) ; int n ; int a [ maxn ] ; int cnt [ maxnn ] ; int pri [ maxnn ] ; bool isp [ maxnn ] ; int p = 0 ; void init ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( isp [ i ] == 0 ) { pri [ ++ p ] = i ; } for ( int j = 1 ; j <= p && i * pri [ j ] <= n ; ++ j ) { isp [ i * pri [ j ] ] = 1 ; if ( i % pri [ j ] == 0 ) { break ; } } } } bool ispri ( int n ) { if ( n == 1 ) { return 0 ; } for ( int i = 2 ; i <= n / i ; ++ i ) { if ( n % i == 0 ) { return 0 ; } } return 1 ; } int main ( ) { init ( maxnn ) ; while ( cin >> n ) { memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; } int gcdd = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { gcdd = __gcd ( gcdd , a [ i ] ) ; } int maxx = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] /= gcdd ; for ( int j = 1 ; j <= p && pri [ j ] * pri [ j ] <= a [ i ] ; ++ j ) { if ( a [ i ] % pri [ j ] == 0 ) { cnt [ pri [ j ] ] ++ ; } maxx = max ( maxx , cnt [ pri [ j ] ] ) ; while ( a [ i ] % pri [ j ] == 0 ) { a [ i ] /= pri [ j ] ; } } if ( a [ i ] > 1 ) { cnt [ a [ i ] ] ++ ; } maxx = max ( maxx , cnt [ a [ i ] ] ) ; } if ( maxx == 0 ) { cout << - 1 << endl ; } else { cout << n - maxx << endl ; } } return 0 ; }
TAB0 maxn , inf are constant integers with maxn = 3e5 + 1 , inf = 1 . 5e7 + 10 ; TAB0 n , gcd , t are integers with t = 0 ; TAB0 a = integer array of size maxn , b and prime are integer arrays both of size inf ; TAB0 in function GCD with parameters integers m , n and return integer ; TAB1 if m is less than n , call swap with m , n ; TAB1 if n equals 0 ; TAB2 return m ; TAB1 else ; TAB2 return call GCD with n , m modulo n ; TAB1 input n ; TAB1 for i = 1 to n inclusive ; TAB2 input a [ i ] ; TAB2 set gcd to call GCD with a [ i ] , gcd ; TAB1 for i = 1 to n inclusive , increment b [ a [ i ] / gcd ] ; TAB1 for i = 2 to inf - 1 inclusive ; TAB2 if prime [ i ] is false ; TAB3 h = integer = 0 ; TAB3 for j = i to inf exclusive with increment j + i , set prime [ j ] to 1 ; TAB3 set to to call max with t , h ; TAB1 output n - t if t , otherwise output - 1 ;	const int maxn = 3e5 + 1 , inf = 1.5e7 + 10 ; int n , gcd , t = 0 ; int a [ maxn ] , b [ inf ] , prime [ inf ] ; int GCD ( int m , int n ) { if ( m < n ) swap ( m , n ) ; if ( n == 0 ) return m ; else return GCD ( n , m % n ) ; } int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> a [ i ] ; gcd = GCD ( a [ i ] , gcd ) ; } for ( int i = 1 ; i <= n ; ++ i ) ++ b [ a [ i ] / gcd ] ; for ( int i = 2 ; i <= inf - 1 ; ++ i ) { if ( ! prime [ i ] ) { int h = 0 ; for ( int j = i ; j < inf ; j += i ) h += b [ j ] , prime [ j ] = 1 ; t = max ( t , h ) ; } } t ? cout << n - t << endl : cout << - 1 << endl ; return 0 ; }
TAB1 create string str ; TAB1 read input to str ; TAB1 if there is no " AB " or " BA " in the str ; TAB2 print " NO " ; TAB1 declare size_t pos = index of " AB " in str ; TAB1 if there is substring " BA " after pos + 2 in str ; TAB2 print " YES " ; TAB1 declare size_t posn = index of " BA " in str ; TAB1 if there is substring " AB " after posn + 2 in str ; TAB2 print " YES " ; TAB1 print " NO " ;	int main ( ) { string str ; cin >> str ; if ( str . find ( " AB " ) == string :: npos || str . find ( " BA " ) == string :: npos ) { cout << " NO " << endl ; return 0 ; } size_t pos = str . find ( " AB " ) ; if ( str . find ( " BA " , pos + 2 ) != string :: npos ) { cout << " YES " << endl ; return 0 ; } size_t posn = str . find ( " BA " ) ; if ( str . find ( " AB " , posn + 2 ) != string :: npos ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB1 MAX , n , m , M , var = long long , max , check , total = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read m ; TAB2 for j = 0 to m exclusive ; TAB3 read var ; TAB3 if var > max max = var ; TAB2 if check is 0 ; TAB3 MAX = max ; TAB3 M = m ; TAB3 max = 0 ; TAB3 increment check ; TAB2 else ; TAB3 if MAX > max ; TAB4 add abs ( MAX - max ) * m ) to total ; TAB4 max = 0 ; TAB4 add m to M ; TAB3 else ; TAB4 add abs ( MAX - max ) * M ) to total ; TAB4 MAX = max ; TAB4 max = 0 ; TAB4 add m to M ; TAB1 print total ;	int main ( ) { long long MAX , n , m , M , max = 0 , var , check = 0 , total = 0 ; cin >> n ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> m ; for ( long long j = 0 ; j < m ; j ++ ) { cin >> var ; if ( var > max ) max = var ; } if ( check == 0 ) { MAX = max ; M = m ; max = 0 ; check ++ ; } else { if ( MAX > max ) { total += ( abs ( MAX - max ) * m ) ; max = 0 ; M += m ; } else { total += ( abs ( MAX - max ) * M ) ; MAX = max ; max = 0 ; M += m ; } } } cout << total << endl ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 a = b = integer array of size n ; TAB1 for i = 0 to n exclusive , then read a [ i ] , b [ i ] ; TAB1 c = integer = n ; TAB1 for i = 0 to n exclusive ; TAB2 for j = 0 to n exclusive ; TAB3 if a [ i ] is b [ j ] and i is not j ; TAB4 decrease c by 1 ; TAB4 exit the for loop ; TAB1 print c ;	int main ( ) { int n ; cin >> n ; int a [ n ] , b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } int c = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] == b [ j ] && i != j ) { c -- ; break ; } } } cout << c << endl ; }
TAB0 create an const integer MAXN with MAXN = 100000 + 10 ; TAB0 a = array of integer of size MAXN ; TAB0 string = s ; TAB1 n = integer ; TAB1 read n , s ; TAB1 create a boolean flag with flag = false ; TAB1 for i = 0 to n exclusive ; TAB2 increment a [ s [ i ] - ' a ' ] ; TAB2 if a [ s [ i ] - ' a ' ] > 1 or n = 1 then set flag = true ; TAB1 if flag is true then print YES else print NO ;	const int MAXN = 100000 + 10 ; int a [ MAXN ] ; string s ; int main ( ) { int n ; cin >> n >> s ; bool flag = false ; for ( int i = 0 ; i < n ; i ++ ) { a [ s [ i ] - ' a ' ] ++ ; if ( a [ s [ i ] - ' a ' ] > 1 || n == 1 ) flag = true ; } flag ? puts ( " Yes " ) : puts ( " No " ) ; return 0 ; }
TAB0 create constant integer variable with name N = 150 ; TAB0 declare integer arrays x , y and info with size N , and a variable n ; TAB0 integer function color_to_id with char argument ch ; TAB1 if ch = ' R ' , return 1 ; TAB1 if ch is equal to ' G ' , return 2 ; TAB1 if ch = ' B ' , return 3 ; TAB1 if ch = ' Y ' , return 4 ; TAB1 if ch is equal to ' W ' , return 5 ; TAB0 function count_one with int argument x that returns int ; TAB1 create integer variable called cnt with value 0 ; TAB1 while x ; TAB2 change cnt to the sum of cnt and x & 1 ; TAB2 change x to x > > 1 ; TAB1 return cnt ; TAB0 bool function check with int argument sta ; TAB1 for i = 0 to n exclusive incrementing i ; TAB2 change info [ i ] to 0 ; TAB2 set info [ i ] to info [ i ] | ( 1 < < ( x [ i ] - 1 ) ) & sta ; TAB2 change the value of info [ i ] to info [ i ] | ( 1 < < ( y [ i ] - 1 + 5 ) ) & sta ; TAB2 in a for loop , change j from 0 to i exclusive ; TAB3 return false if info [ i ] = info [ j ] and ( x [ i ] ! = x [ j ] or y [ i ] ! = y [ j ] ) ; TAB1 return true ; TAB1 declare string variable with name str ; TAB1 read n and loop further ; TAB2 for i = 0 to n exclusive incrementing i ; TAB3 read input to str ; TAB3 change the value of x [ i ] to color_to_id ( str [ 0 ] ) ; TAB3 set y [ i ] to str [ 1 ] - ' 0 ' ; TAB2 define integer ans with value 10 ; TAB2 for integer i = 0 to 1 < < 10 exclusive ; TAB3 declare new integer variable n_one with value = result of count_one ( i ) ; TAB3 if n_one > = ans , go to the start of the loop ; TAB3 if check ( i ) returned true , set the value of ans to n_one ; TAB2 print ans ;	const int N = 150 ; int x [ N ] , y [ N ] , info [ N ] , n ; int color_to_id ( char ch ) { if ( ch == ' R ' ) return 1 ; if ( ch == ' G ' ) return 2 ; if ( ch == ' B ' ) return 3 ; if ( ch == ' Y ' ) return 4 ; if ( ch == ' W ' ) return 5 ; } int count_one ( int x ) { int cnt = 0 ; while ( x ) { cnt += ( x & 1 ) ; x >>= 1 ; } return cnt ; } bool check ( int sta ) { for ( int i = 0 ; i < n ; i ++ ) { info [ i ] = 0 ; info [ i ] |= ( 1 << ( x [ i ] - 1 ) ) & sta ; info [ i ] |= ( 1 << ( y [ i ] - 1 + 5 ) ) & sta ; for ( int j = 0 ; j < i ; j ++ ) if ( info [ i ] == info [ j ] && ( x [ i ] != x [ j ] || y [ i ] != y [ j ] ) ) return false ; } return true ; } int main ( ) { string str ; while ( cin >> n ) { for ( int i = 0 ; i < n ; i ++ ) { cin >> str ; x [ i ] = color_to_id ( str [ 0 ] ) ; y [ i ] = str [ 1 ] - ' 0 ' ; } int ans = 10 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { int n_one = count_one ( i ) ; if ( n_one >= ans ) continue ; if ( check ( i ) ) ans = n_one ; } cout << ans << endl ; } return 0 ; }
TAB0 let N a constant int with value 2e6 + 10 ; TAB0 let n , a , m and d long longs ; TAB0 let t a long long array of length N ; TAB1 read n , m , a , and d ; TAB1 let x and ma long longs with x = d / a + 1 and ma = 0 ; TAB1 for i from 1 to m , read t [ i ] and set ma to max of ma and t [ i ] ; TAB1 set t [ m + 1 ] to max of n * a + d + d and ma + d + d ; TAB1 let ans and now long longs with ans = 1 and now = min ( t [ 1 ] , a ) + d ; TAB1 let cur long long with value now / a + 1 ; TAB1 for i from 1 to m + 1 ; TAB2 if t [ i ] > now ; TAB3 if cur > n ; TAB4 for j from i to m + 1 ; TAB5 if t [ j ] > now , increment ans and set now to t [ j ] + d ; TAB4 end loop ; TAB3 if t [ i ] at most cur * a ; TAB4 increment ans ; TAB4 set now to t [ i ] + d ; TAB4 set cur to now / a + 1 ; TAB3 otherwise ; TAB4 let tmp a long long with value min ( t [ i ] / a , n ) - cur ; TAB4 add tmp / x + 1 to ans ; TAB4 add ( tmp / x + 1 ) * x to cur ; TAB4 set now to cur * a - a + d mod a ; TAB4 if t [ i ] > now ; TAB5 increment ans ; TAB5 set now to t [ i ] + d ; TAB5 set cur to now / a + 1 ; TAB1 print ans - 1 ;	const int N = 2e6 + 10 ; long long n , a , m , d ; long long t [ N ] ; int main ( ) { cin >> n >> m >> a >> d ; long long x = d / a + 1 , ma = 0 ; for ( int i = 1 ; i <= m ; ++ i ) cin >> t [ i ] , ma = max ( ma , t [ i ] ) ; t [ m + 1 ] = max ( n * a + d + d , ma + d + d ) ; long long ans = 1 , now = min ( t [ 1 ] , a ) + d ; long long cur = now / a + 1 ; for ( int i = 1 ; i <= m + 1 ; ++ i ) if ( t [ i ] > now ) { if ( cur > n ) { for ( int j = i ; j <= m + 1 ; ++ j ) if ( t [ j ] > now ) { ++ ans , now = t [ j ] + d ; } break ; } if ( t [ i ] <= cur * a ) { ++ ans ; now = t [ i ] + d ; cur = now / a + 1 ; } else { long long tmp = min ( t [ i ] / a , n ) - cur ; ans += tmp / x + 1 ; cur += ( tmp / x + 1 ) * x ; now = cur * a - a + d % a ; if ( t [ i ] > now ) { ++ ans ; now = t [ i ] + d ; cur = now / a + 1 ; } } } cout << ans - 1 << endl ; }
TAB0 declare Mul with long longs a , n , m as arguments , returning long long ; TAB1 declare r = 0 as long long ; TAB1 while n is true ; TAB2 if n bitwise and 0x1 , let r be ( r + a ) % m ; TAB2 let a be ( a bitshift left 1 ) % m ; TAB2 let n be n bitshift right 1 ; TAB1 return r from function ; TAB0 declare Pow with long longs a , n , m as arguments , returning long long ; TAB1 declare r = 1 as long long ; TAB1 while n is true ; TAB2 if ( n bitwise and 0x1 ) let r = result of run Mul with r , a , m as arguments ; TAB2 let a = Mul ( a , a , m ) ; TAB2 let n be bitshift right 1 ; TAB1 return r from function ; TAB0 declare long long vector sz ; TAB0 declare long long vector id ; TAB0 declare create with long long v as argument , returning void ; TAB1 let id [ v ] be v ; TAB1 let sz [ v ] be 1 ; TAB0 declare find with long long v as argument , returning long long ; TAB1 declare i as long long ; TAB1 for i = v to i is not id [ i ] , setting i to id [ i ] , let id [ i ] be id [ id [ i ] ] ; TAB1 return i from function ; TAB0 declare unite with long longs v , w as arguments , returning void ; TAB1 declare i , j as long longs ; TAB1 for i = v to i is not id [ i ] , setting i to id [ i ] , let id [ i ] be id [ id [ i ] ] ; TAB1 for j = 2 to j is not id [ j ] , settiing j to id [ j ] , let id [ j ] be id [ id [ j ] ] ; TAB1 if i is j , return from function ; TAB1 if sz [ i ] is less than sz [ j ] ; TAB2 let id [ i ] be j ; TAB2 increment sz [ j ] by sz [ i ] ; TAB1 else ; TAB2 let id [ j ] be i ; TAB2 increment sz [ i ] by sz [ j ] ; TAB1 declare n , m as long longs ; TAB1 read n and m ; TAB1 resize id to size n + m ; TAB1 resize sz to size n + m ; TAB1 for i = 0 to n + m exclusive , run create with i as argument ; TAB1 for i = 0 to n exclusive ; TAB2 declare long long k ; TAB2 read k ; TAB2 for j = 0 to k exclusive ; TAB3 declare a as long long ; TAB3 read a ; TAB3 decrement a ; TAB3 run unite with i + m , a as arguments ; TAB1 declare cnt = 0 as long long ; TAB1 for i = 0 to m exclusive ; TAB2 if sz [ run find ( i ) ] is not 1 ; TAB3 for j = m to m + n exclusive ; TAB4 if ( run find ( j ) is not run find ( i ) ) ; TAB5 increment cnt ; TAB5 run united with j , i as arguments ; TAB3 print cnt and newline ; TAB1 print n and newline ;	long long Mul ( long long a , long long n , long long m ) { long long r = 0 ; while ( n ) { if ( n & 0x1 ) r = ( r + a ) % m ; a = ( a << 1 ) % m ; n >>= 1 ; } return r ; } long long Pow ( long long a , long long n , long long m ) { long long r = 1 ; while ( n ) { if ( n & 0x1 ) r = Mul ( r , a , m ) ; a = Mul ( a , a , m ) ; n >>= 1 ; } return r ; } vector < long long > sz ; vector < long long > id ; void create ( long long v ) { id [ v ] = v ; sz [ v ] = 1 ; } long long find ( long long v ) { long long i ; for ( i = v ; i != id [ i ] ; i = id [ i ] ) id [ i ] = id [ id [ i ] ] ; return i ; } void unite ( long long v , long long w ) { long long i , j ; for ( i = v ; i != id [ i ] ; i = id [ i ] ) id [ i ] = id [ id [ i ] ] ; for ( j = w ; j != id [ j ] ; j = id [ j ] ) id [ j ] = id [ id [ j ] ] ; if ( i == j ) return ; if ( sz [ i ] < sz [ j ] ) { id [ i ] = j ; sz [ j ] += sz [ i ] ; } else { id [ j ] = i ; sz [ i ] += sz [ j ] ; } } int main ( ) { long long n , m ; cin >> n >> m ; id . resize ( n + m ) ; sz . resize ( n + m ) ; for ( long long i = 0 ; i < n + m ; i ++ ) create ( i ) ; for ( long long i = 0 ; i < n ; i ++ ) { long long k ; cin >> k ; for ( long long j = 0 ; j < k ; j ++ ) { long long a ; cin >> a ; -- a ; unite ( i + m , a ) ; } } long long cnt = 0 ; for ( long long i = 0 ; i < m ; i ++ ) if ( sz [ find ( i ) ] != 1 ) { for ( long long j = m ; j < m + n ; j ++ ) if ( find ( j ) != find ( i ) ) { ++ cnt ; unite ( j , i ) ; } cout << cnt << endl ; return 0 ; } cout << n << endl ; return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 set n to n = = 0 ? 0 : 1 + ( n - 1 ) % 4 ; TAB1 create array x containing { 1 , 8 , 4 , 2 , 6 } ; TAB1 print x [ n ] ;	int main ( ) { int n ; cin >> n ; n = n == 0 ? 0 : 1 + ( n - 1 ) % 4 ; int x [ ] = { 1 , 8 , 4 , 2 , 6 } ; cout << x [ n ] << endl ; return 0 ; }
TAB0 in the function gcd that takes long long int a , b and returns long long int ; TAB1 tmp = long long int ; TAB1 while ( b is not 0 ) ; TAB2 tmp = a modulo b ; TAB2 a = b ; TAB2 b = tmp ; TAB1 return a ; TAB0 in the function lcm that takes long long int a , b and returns long long int ; TAB1 return ( a * b ) / gcd ( a , b ) ; TAB1 n = long long int ; TAB1 i , j , k , mx = long long int with mx = 0 ; TAB1 read n ; TAB1 for i = n - 5 to n ; TAB2 for j = i to i > 0 and j < = n ; TAB3 for k = j to j > 0 and k < = n , mx = max ( mx , lcm ( i , lcm ( j , k ) ) ) ; TAB1 print mx ;	long long int gcd ( long long int a , long long int b ) { long long int tmp ; while ( b != 0 ) { tmp = a % b ; a = b ; b = tmp ; } return a ; } long long int lcm ( long long int a , long long int b ) { return ( a * b ) / gcd ( a , b ) ; } int main ( ) { long long int n ; long long int i , j , k , mx = 0 ; cin >> n ; for ( i = n - 5 ; i <= n ; i ++ ) { for ( j = i ; i > 0 && j <= n ; j ++ ) { for ( k = j ; j > 0 && k <= n ; k ++ ) { mx = max ( mx , lcm ( i , lcm ( j , k ) ) ) ; } } } cout << mx << endl ; return 0 ; }
TAB1 declare integers s , n , x , y , k = 0 ; TAB1 declare multimap from integer to integer v ; TAB1 declare multimap from integer to integer iterator it ; TAB1 read s and n ; TAB1 for i = 0 to n exclusive ; TAB2 read x and y ; TAB2 insert ( make pair from ( x , y ) ) into v ; TAB1 for it = beginning of v to it is not end of v , incrementing it ; TAB2 if s is greater than first element of it ; TAB3 let s be s + second element of it ; TAB2 else ; TAB3 let k be 1 ; TAB3 end loop ; TAB1 if k is 0 ; TAB2 print " YES " and newline ; TAB1 else ; TAB2 print " NO " and newline ;	int main ( ) { int s , n , x , y , k = 0 ; multimap < int , int > v ; multimap < int , int > :: iterator it ; cin >> s >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> y ; v . insert ( make_pair ( x , y ) ) ; } for ( it = v . begin ( ) ; it != v . end ( ) ; it ++ ) { if ( s > it -> first ) { s = s + it -> second ; } else { k = 1 ; break ; } } if ( k == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 declare hui with integers a , b as arguments , returning boolean ; TAB1 if a / 10 is b % 10 and a % 10 is b / 10 ; TAB2 return true from function ; TAB1 else ; TAB2 return false from function ; TAB1 declare string s ; TAB1 declare integers h = 0 , h1 , m = 0 , f = 0 ; TAB1 read s ; TAB1 let h be ( s [ 0 ] - ' 0 ' ) * 10 + s [ 1 ] - ' 0 ' ; TAB1 let h1 be 0 ; TAB1 let m be ( s [ 3 ] - ' 0 ' ) * 10 + s [ 4 ] - ' 0 ' ; TAB1 if result of run hui with h , m as arguments is true , increment m by 1 ; TAB1 for h is less than or equal to 23 , incrementing h ; TAB2 for m is less than or equal to 59 , incrementing m ; TAB3 if result of run hui ( h , m ) is true ; TAB4 if h is 0 and m is 0 ; TAB5 print h , h , " : " , m , m , newline ; TAB4 else if h is less than 10 and m is greater than or equal to 10 ; TAB5 print 0 , h , " : " , m , newline ; TAB4 else if h is greater than or equal to 10 and m is less than 10 ; TAB5 print h , ' : ' , 0 , m , newline ; TAB4 else ; TAB5 print h , " : " , m , newline ; TAB4 let f be 1 ; TAB4 end loop ; TAB2 let f be 1 , end loop ; TAB2 if h is 23 , let h be - 1 ; TAB2 increment h1 ; TAB2 if h1 is greater than 0 , let m be 0 ;	bool hui ( int a , int b ) { if ( a / 10 == b % 10 && a % 10 == b / 10 ) return true ; else return false ; } int main ( ) { string s ; int h = 0 , h1 , m = 0 , f = 0 ; cin >> s ; h = ( s [ 0 ] - ' 0 ' ) * 10 + s [ 1 ] - ' 0 ' ; h1 = 0 ; m = ( s [ 3 ] - ' 0 ' ) * 10 + s [ 4 ] - ' 0 ' ; if ( hui ( h , m ) ) m += 1 ; for ( ; h <= 23 ; h ++ ) { for ( ; m <= 59 ; m ++ ) { if ( hui ( h , m ) ) { if ( h == 0 && m == 0 ) cout << h << h << " : " << m << m << endl ; else if ( h < 10 && m >= 10 ) cout << 0 << h << " : " << m << endl ; else if ( h >= 10 && m < 10 ) cout << h << ' : ' << 0 << m << endl ; else cout << h << " : " << m << endl ; f = 1 ; break ; } } if ( f == 1 ) break ; if ( h == 23 ) { h = - 1 ; } h1 ++ ; if ( h1 > 0 ) m = 0 ; } }
TAB0 in function next that returns an unsigned long long and takes argument x = unsigned long long ; TAB1 if x is less than 10 then if x is less than or equal to 4 then return 4 else if x is less than or equal to 7 then return 7 else return 44 ; TAB1 a , b , y = unsigned long longs with a having value of x mod 10 and b having value of ( x / 10 ) mod 10 ; TAB1 if a is less than or equal to 7 ; TAB2 set y to ( the return of function next with argument x / 10 ) * 10 ; TAB1 else ; TAB2 set y to ( the return of function next with argument x / 10 + 1 ) * 10 ; TAB1 if y + 4 is greater than or equal to x then return y + 4 ; TAB1 return y + 7 ; TAB1 l , r , m , suma = unsigned long longs with suma having value of 0 ; TAB1 read l and r ; TAB1 while l is less than or equal to r ; TAB2 set m to the return of function next with argument l ; TAB2 if m is less than r ; TAB3 increase suma by ( m - 1 + 1 ) * m ; TAB3 set l to m + 1 ; TAB2 else ; TAB3 increase suma by ( r - l + 1 ) * m ; TAB3 set l to r + 1 ; TAB1 print suma ;	unsigned long long next ( unsigned long long x ) { if ( x < 10 ) return ( x <= 4 ? 4 : ( x <= 7 ? 7 : 44 ) ) ; unsigned long long a = x % 10 , b = ( x / 10 ) % 10 , y ; if ( a <= 7 ) y = next ( x / 10 ) * 10 ; else y = next ( x / 10 + 1 ) * 10 ; if ( y + 4 >= x ) return y + 4 ; return y + 7 ; } int main ( ) { unsigned long long l , r , m , suma = 0 ; cin >> l >> r ; while ( l <= r ) { m = next ( l ) ; if ( m < r ) { suma += ( m - l + 1 ) * m ; l = m + 1 ; } else { suma += ( r - l + 1 ) * m ; l = r + 1 ; } } cout << suma << endl ; return 0 ; }
TAB1 let numberOfStudents be a integer ; TAB1 let studentsRate be a integer ; TAB1 let result be a integer with result = 1 ; TAB1 read numberOfStudents ; TAB1 arr = array of integers of length 2000 ; TAB1 for x = 0 to numberOfStudents exclusive ; TAB2 read studentsRate ; TAB2 arr [ x ] is equal to studentsRate ; TAB1 for x = 0 to numberOfStudents exclusive ; TAB2 result is equal to 1 ; TAB2 for y = 0 to numberOfStudents exclusive ; TAB3 if arr [ x ] is less than arr [ y ] , increment result by 1 ; TAB2 if x is equal to numberOfStudents - 1 ; TAB3 print result and newline ; TAB2 else do the following ; TAB3 print result and space ;	int main ( ) { int numberOfStudents ; int studentsRate ; int result = 1 ; cin >> numberOfStudents ; int arr [ 2000 ] ; for ( int x = 0 ; x < numberOfStudents ; ++ x ) { cin >> studentsRate ; arr [ x ] = studentsRate ; } for ( int x = 0 ; x < numberOfStudents ; ++ x ) { result = 1 ; for ( int y = 0 ; y < numberOfStudents ; ++ y ) { if ( arr [ x ] < arr [ y ] ) { ++ result ; } } if ( x == numberOfStudents - 1 ) cout << result << endl ; else cout << result << "   " ; } return 0 ; }
TAB0 hit = map from int to int ; TAB1 n , a , temp , flag = integers with a = array of size 100005 , flag = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read temp ; TAB2 increment hit [ temp ] ; TAB2 if ( temp is 50 ) ; TAB3 if ( hit [ 25 ] > = 1 ) ; TAB4 decrement hit [ 25 ] ; TAB4 continue next iteration ; TAB3 flag = 1 ; TAB2 else if ( temp is 100 ) ; TAB3 if ( hit [ 50 ] > = 1 and hit [ 25 ] > = 1 ) ; TAB4 decrement hit [ 50 ] ; TAB4 decrement hit [ 25 ] ; TAB4 continue next iteration ; TAB3 else if ( hit [ 25 ] > = 3 ) ; TAB4 hit [ 25 ] = hit [ 25 ] - 3 ; TAB4 continue next iteration ; TAB3 flag = 1 ; TAB1 if ( flag is 0 ) ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	map < int , int > hit ; int main ( ) { int n , a [ 100005 ] , temp , flag = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> temp ; hit [ temp ] ++ ; if ( temp == 50 ) { if ( hit [ 25 ] >= 1 ) { hit [ 25 ] -- ; continue ; } flag = 1 ; } else if ( temp == 100 ) { if ( hit [ 50 ] >= 1 && hit [ 25 ] >= 1 ) { hit [ 50 ] -- ; hit [ 25 ] -- ; continue ; } else if ( hit [ 25 ] >= 3 ) { hit [ 25 ] -= 3 ; continue ; } flag = 1 ; } } if ( flag == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 create long long n ; TAB1 create long long ans ; TAB1 while n is being read ; TAB2 if n equals 1 ; TAB3 assign 1 to ans ; TAB2 else if n equals 2 ; TAB3 assign 2 to ans ; TAB2 else if n equals 3 ; TAB3 assign 6 to ans ; TAB2 else if n bitwise and 1 ; TAB3 assign n * ( n - 1 ) * ( n - 2 ) to ans ; TAB2 else ; TAB3 if n mod 3 is not equal to 0 ; TAB4 assign n * ( n - 1 ) * ( n - 3 ) to ans ; TAB3 else ; TAB4 assign ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; TAB2 print ans ;	int main ( ) { long long n ; long long ans ; while ( cin >> n ) { if ( n == 1 ) ans = 1 ; else if ( n == 2 ) ans = 2 ; else if ( n == 3 ) ans = 6 ; else if ( n & 1 ) ans = n * ( n - 1 ) * ( n - 2 ) ; else { if ( n % 3 != 0 ) ans = n * ( n - 1 ) * ( n - 3 ) ; else ans = ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; } cout << ans << endl ; } return 0 ; }
TAB0 array a of size 10 , day1 , day2 = string ; TAB1 set a [ 1 ] to monday ; TAB1 set a [ 2 ] to tuesday ; TAB1 set a [ 3 ] to wednesday ; TAB1 set a [ 4 ] to thursday ; TAB1 set a [ 5 ] to friday ; TAB1 set a [ 6 ] to saturday ; TAB1 set a [ 7 ] to sunday ; TAB1 read day1 , day2 ; TAB1 integer as num1 = 0 , num2 = 0 , i = 0 , j = 0 ; TAB1 for = 1 to less than or equal to 7 do the following ; TAB2 if day1 is a [ i ] then do the following num1 = i ; TAB1 for = 1 to less than or equal to 7 do the following ; TAB2 if day2 is a [ i ] then num2 = i ; TAB1 if num2 is less than num1 then add 7 to num2 ; TAB1 integer as sum = num2 - num1 ; TAB1 if sum is 0 , 2 or 3 then do the following ; TAB2 output YES ; TAB1 else ; TAB2 output NO ;	string a [ 10 ] , day1 , day2 ; int main ( ) { a [ 1 ] = " monday " ; a [ 2 ] = " tuesday " ; a [ 3 ] = " wednesday " ; a [ 4 ] = " thursday " ; a [ 5 ] = " friday " ; a [ 6 ] = " saturday " ; a [ 7 ] = " sunday " ; cin >> day1 >> day2 ; int num1 = 0 , num2 = 0 , i = 0 , j = 0 ; for ( i = 1 ; i <= 7 ; i ++ ) { if ( day1 == a [ i ] ) { num1 = i ; } } for ( i = 1 ; i <= 7 ; i ++ ) { if ( day2 == a [ i ] ) { num2 = i ; } } if ( num2 < num1 ) { num2 += 7 ; } int sum = num2 - num1 ; if ( sum == 0 || sum == 2 || sum == 3 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB0 declare long long variables x and y ; TAB0 exgcd is a long long function with long long arguments a and b ; TAB1 if b = 0 ; TAB2 assign 1 to x ; TAB2 assign 0 to y ; TAB2 return a ; TAB1 declare long long d = exgcd ( b , a % b ) ; TAB1 declare long long variable t = x ; TAB1 change x to y ; TAB1 set y to t - a / b * y ; TAB1 return d ; TAB1 create long longs m , h1 , a1 , x1 , y1 , h2 , a2 , x2 and y2 ; TAB1 declare long longs p1 , p2 , q1 and q2 ; TAB1 loop , reading m , h1 , a1 , x1 , y1 , h2 , a2 , x2 and y2 from the input ; TAB2 change p1 , p2 , q1 and q2 to 0 ; TAB2 change i from 1 to 2 * m inclusive in a loop ; TAB3 set h1 to ( h1 * x1 + y1 ) % m ; TAB3 if h1 is equal to a1 ; TAB4 if p1 = 0 ; TAB5 assign i to p1 ; TAB4 else if q1 is equal to 0 ; TAB5 assign i - p1 to q1 ; TAB5 break the loop ; TAB2 for i = 1 to 2 * m inclusive ; TAB3 set h2 to ( h2 * x2 + y2 ) % m ; TAB3 if h2 = a2 ; TAB4 if p2 = 0 ; TAB5 set p2 to i ; TAB4 else if q2 = 0 ; TAB5 assign i - p2 to q2 ; TAB5 stop the loop ; TAB2 declare long long d = exgcd ( q1 , - q2 ) ; TAB2 create long long c = p2 - p1 ; TAB2 if d = 0 ; TAB3 print " - 1 " to stdout ; TAB3 go to the start of the loop ; TAB2 if c % d ! = 0 ; TAB3 print " - 1 " to stdout ; TAB3 skip the rest of the loop ; TAB2 if p1 = 0 or p2 is equal to 0 ; TAB3 print " - 1 " to stdout ; TAB3 skip the rest of the loop ; TAB2 if q2 = 0 and q1 = 0 and p1 ! = p2 ; TAB3 print " - 1 " to stdout ; TAB3 skip the rest of the loop ; TAB2 if ( q2 = 0 and p2 - p1 < 0 ) is true or ( q1 = 0 and p1 - p2 < 0 ) is true ; TAB3 print " - 1 " to standard output ; TAB3 skip the rest of the loop ; TAB2 declare long long variable k = c / d ; TAB2 multiply x by k ; TAB2 multiply y by k ; TAB2 if d is less than 0 , invert the sign of d ; TAB2 if x < 0 or y < 0 ; TAB3 start infinite loop ; TAB4 add q2 / d to x ; TAB4 add q1 / d to y ; TAB4 if x > = 0 and y > = 0 , stop the loop ; TAB2 if x > 0 and y > 0 ; TAB3 start infinite loop ; TAB4 subtract q2 / d from x ; TAB4 decrease y by q1 / d ; TAB4 if x < 0 or y < 0 ; TAB5 add q2 / d to x ; TAB5 add q1 / d to y ; TAB5 break ; TAB2 create long long ans = x * q1 + p1 ; TAB2 print ans ;	long long x , y ; long long exgcd ( long long a , long long b ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long d = exgcd ( b , a % b ) ; long long t = x ; x = y ; y = t - a / b * y ; return d ; } int main ( ) { long long m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 ; long long p1 , p2 , q1 , q2 ; while ( cin >> m >> h1 >> a1 >> x1 >> y1 >> h2 >> a2 >> x2 >> y2 ) { p1 = p2 = q1 = q2 = 0 ; for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h1 = ( h1 * x1 + y1 ) % m ; if ( h1 == a1 ) { if ( p1 == 0 ) p1 = i ; else if ( q1 == 0 ) { q1 = i - p1 ; break ; } } } for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h2 = ( h2 * x2 + y2 ) % m ; if ( h2 == a2 ) { if ( p2 == 0 ) p2 = i ; else if ( q2 == 0 ) { q2 = i - p2 ; break ; } } } long long d = exgcd ( q1 , - q2 ) ; long long c = p2 - p1 ; if ( d == 0 ) { puts ( " -1 " ) ; continue ; } if ( c % d ) { puts ( " -1 " ) ; continue ; } if ( p1 == 0 || p2 == 0 ) { puts ( " -1 " ) ; continue ; } if ( q2 == 0 && q1 == 0 && p1 != p2 ) { puts ( " -1 " ) ; continue ; } if ( ( q2 == 0 && p2 - p1 < 0 ) || ( q1 == 0 && p1 - p2 < 0 ) ) { puts ( " -1 " ) ; continue ; } long long k = c / d ; x *= k ; y *= k ; if ( d < 0 ) d = - d ; if ( x < 0 || y < 0 ) { while ( 1 ) { x += q2 / d ; y += q1 / d ; if ( x >= 0 && y >= 0 ) break ; } } if ( x > 0 && y > 0 ) { while ( 1 ) { x -= q2 / d ; y -= q1 / d ; if ( x < 0 || y < 0 ) { x += q2 / d ; y += q1 / d ; break ; } } } long long ans = x * q1 + p1 ; cout << ans << endl ; } return 0 ; }
TAB1 create character c ; TAB1 create integers n , i , t , e and set to 0 ; TAB1 while read c do ; TAB2 if c is equal to ' n ' then ; TAB3 increment n ; TAB2 else if c is equal to ' i ' then ; TAB3 increment i ; TAB2 else if c is equal to ' t ' then ; TAB3 increment t ; TAB2 else if c is equal to ' e ' then ; TAB3 increment e ; TAB1 create integer cont with cont = 0 ; TAB1 for integer k = i to 1 with decrement k ; TAB2 if n is greater than or equal to 2 * k + 1 and t greater than or equal to k and e greater then or equal to 3 * k then increment cont ; TAB1 print cont ;	int main ( ) { char c ; int n = 0 , i = 0 , t = 0 , e = 0 ; while ( cin >> c ) { if ( c == ' n ' ) { n ++ ; } else if ( c == ' i ' ) { i ++ ; } else if ( c == ' t ' ) { t ++ ; } else if ( c == ' e ' ) { e ++ ; } } int cont = 0 ; for ( int k = i ; k > 0 ; k -- ) { if ( n >= 2 * k + 1 && t >= k && e >= 3 * k ) { cont ++ ; } } cout << cont << endl ; return 0 ; }
TAB0 declare cmp with integers a , b as arguments , returning boolean ; TAB1 return a is greater than b ; TAB0 create constant integer MAXN with MAXN = 1e5 ; TAB0 create integer array a with size MAXN ; TAB1 create map mp from integer to integer ; TAB1 create integers n , k ; TAB1 read n read k ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 increment mp [ a [ i ] ] ; TAB1 sort elements from a to a + n using cmp to compare ; TAB1 create integer cnt with cnt = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if mp [ a [ i ] ] is 0 ; TAB3 break current loop iteration ; TAB2 else ; TAB3 if a [ i ] % k is 0 ; TAB4 create integer cur with cur = a [ i ] / k ; TAB4 increment cnt by maximum of ( mp [ a [ i ] ] and mp [ cur ] ) ; TAB4 set mp [ a [ i ] ] to mp [ cur ] to 0 ; TAB3 else ; TAB4 increment cnt by mp [ a [ i ] ] ; TAB4 set mp [ a [ i ] ] to 0 ; TAB1 print cnt print newline ;	bool cmp ( int a , int b ) { return a > b ; } const int MAXN = 1e5 ; int a [ MAXN ] ; int main ( ) { map < int , int > mp ; int n , k ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; mp [ a [ i ] ] ++ ; } sort ( a , a + n , cmp ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ a [ i ] ] == 0 ) { continue ; } else { if ( a [ i ] % k == 0 ) { int cur = a [ i ] / k ; cnt += max ( mp [ a [ i ] ] , mp [ cur ] ) ; mp [ a [ i ] ] = mp [ cur ] = 0 ; } else { cnt += mp [ a [ i ] ] ; mp [ a [ i ] ] = 0 ; } } } cout << cnt << endl ; }
TAB0 N = const integer with N = 1e4 + 5 ; TAB0 a = integer array of size N ; TAB1 n , m , k = long long ; TAB1 read n , m , k ; TAB1 mi = integer with mi = 1e8 ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 if i modulo 2 is 0 , mi = min of mi and a [ i ] ; TAB1 if n modulo 2 is 0 , return print 0 , new line , 0 ; TAB1 x = long long with x = m / ( ( n + 1 ) / 2 ; TAB1 x = x * k ; TAB1 print min ( x , 1ll * mi ) ;	const int N = 1e4 + 5 ; int a [ N ] ; int main ( ) { long long n , m , k ; cin >> n >> m >> k ; int mi = 1e8 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( i % 2 == 0 ) mi = min ( mi , a [ i ] ) ; } if ( n % 2 == 0 ) return cout << 0 << endl , 0 ; long long x = m / ( ( n + 1 ) / 2 ) ; x *= k ; cout << min ( x , 1ll * mi ) << endl ; return 0 ; }
TAB1 n , m = long longs ; TAB1 read n and m ; TAB1 let a1 and b1 be long longs with value 1 ; TAB1 let x and y be long longs with value 7 ; TAB1 while x is less than n ; TAB2 x is 7 times itself ; TAB2 increment a1 ; TAB1 while y is less than m ; TAB2 y is 7 times itself ; TAB2 increment b1 ; TAB1 let ans be long long with value 0 ; TAB1 if a1 plus b1 is greater than 7 ; TAB2 print 0 ; TAB1 else ; TAB2 for i = 0 to n exclusive ; TAB3 fir j = 0 to m exclusive ; TAB4 let long long ma be 0 ; TAB4 temp ( 7 , 0 ) is long long vector ; TAB4 let long long a equal i ; TAB4 let long long b equal j ; TAB4 let long long z equal a1 ; TAB4 while z is z less than 1 ; TAB5 increment temp element with a mod 7 by 1 ; TAB5 set ma to max of ma and temp element with a mod 7 ; TAB5 a equals a divided by 7 ; TAB4 z equals b1 ; TAB4 while z is z less than 1 ; TAB5 increment temp element b mod 7 by 1 ; TAB5 set ma to max of ma and temp element with b mod 7 ; TAB5 b equals b divided by 7 ; TAB4 if ma = 1 increment ans ; TAB2 print ans ;	int main ( ) { long long n , m ; cin >> n >> m ; long long a1 = 1 , b1 = 1 ; long long x = 7 , y = 7 ; while ( x < n ) { x = x * 7 ; a1 ++ ; } while ( y < m ) { y = y * 7 ; b1 ++ ; } long long ans = 0 ; if ( a1 + b1 > 7 ) { cout << 0 << endl ; } else { for ( long long i = 0 ; i < n ; i ++ ) { for ( long long j = 0 ; j < m ; j ++ ) { long long ma = 0 ; vector < long long > temp ( 7 , 0 ) ; long long a = i ; long long b = j ; long long z = a1 ; while ( z -- ) { temp [ a % 7 ] ++ ; ma = max ( ma , temp [ a % 7 ] ) ; a = a / 7 ; } z = b1 ; while ( z -- ) { temp [ b % 7 ] ++ ; ma = max ( ma , temp [ b % 7 ] ) ; b = b / 7 ; } if ( ma == 1 ) { ans ++ ; } } } cout << ans << endl ; } return 0 ; }
TAB1 create integer n ; TAB1 read n ; TAB1 if n modulo 2 is truthy ; TAB2 print n / 2 ; TAB1 else ; TAB2 divide n by 2 ; TAB2 create int d = 0 ; TAB2 while ( 1 < < d ) is less than or equal to n , increment d ; TAB2 subtract d by 1 ; TAB2 set n to n - ( 1 < < d ) ; TAB2 show n ;	int main ( ) { int n ; cin >> n ; if ( n % 2 ) cout << n / 2 << endl ; else { n /= 2 ; int d = 0 ; while ( ( 1 << d ) <= n ) ++ d ; -- d ; n -= ( 1 << d ) ; cout << n << endl ; } }
TAB0 create integers n , i , rez , sum , sum1 , integer array DP of sizes 2 , 2 , and 205 , integer array A of size 100005 , and create integers cr , j ; TAB0 in function f that takes in arguments integer address a , integer b , and return f ; TAB1 a is assigned the sum of a and b ; TAB1 if a is greater than or equal to 998244353 , subtract 998244353 from a ; TAB1 input n ; TAB1 for i = 1 to n inclusive , input A [ i ] ; TAB1 if A [ 1 ] doesn ' t equal - 1 ; TAB2 Dp [ 1 ] [ 1 ] [ A [ 1 ] ] is set to 1 ; TAB1 else ; TAB2 for i = 1 to 200 inclusive , set Dp [ 1 ] [ 1 ] [ i ] to 1 ; TAB1 assign 1 to cr ; TAB1 for i = 2 to n inclusive ; TAB2 assign 1 - cr to cr ; TAB2 if A [ i ] doesn ' t equal - 1 ; TAB3 for j = 1 to 200 inclusive ; TAB4 if A [ i ] is less than j , call function f with arguments Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ] ; TAB4 if a [ i ] is equal to j ; TAB5 call function f with arguments Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ] ; TAB5 call function f with arguments Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 1 ] [ j ] ; TAB4 if A [ i ] is greater than j ; TAB5 call function f with arguments Dp [ cr ] [ 1 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ] ; TAB5 call function f with arguments Dp [ cr ] [ 1 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 1 ] [ j ] ; TAB4 set Dp [ 1 - cr ] [ 1 ] [ j ] and Dp [ 1 - cr ] [ 0 ] [ j ] to 0 ; TAB2 else ; TAB3 assign 0 to sum ; TAB3 for j = 1 to 200 inclusive , call function f with arguments sum , Dp [ 1 - cr ] [ 0 ] [ j ] ; TAB3 assign 0 to sum1 ; TAB3 for j = 1 to 200 inclusive ; TAB4 call function f with arguments Dp [ cr ] [ 0 ] [ j ] , sum ; TAB4 call function f with arguments Dp [ cr ] [ 0 ] [ j ] , Dp [ 1 - cr ] [ 1 ] [ j ] ; TAB4 call function f with arguments sum , 998244353 - Dp [ 1 - cr ] [ 0 ] [ j ] ; TAB4 call function f with arguments Dp [ cr ] [ 1 ] [ j ] , sum1 ; TAB4 call function f with arguments sum1 , Dp [ 1 - cr ] [ 1 ] [ j ] ; TAB4 call function f with arguments sum1 , Dp [ 1 - cr ] [ 0 ] [ j ] ; TAB4 set Dp [ 1 - cr ] [ 0 ] [ j ] and Dp [ 1 - cr ] [ 1 ] [ j ] to 0 ; TAB1 for i = 1 to 200 inclusive , call function f with arguments rez , Dp [ cr ] [ 0 ] [ i ] ; TAB1 output rez ;	int n , i , rez , sum , sum1 , Dp [ 2 ] [ 2 ] [ 205 ] , A [ 100005 ] , cr , j ; void f ( int & a , int b ) { a = a + b ; if ( a >= 998244353 ) a -= 998244353 ; } int main ( ) { cin >> n ; for ( i = 1 ; i <= n ; i ++ ) cin >> A [ i ] ; if ( A [ 1 ] != - 1 ) Dp [ 1 ] [ 1 ] [ A [ 1 ] ] = 1 ; else for ( i = 1 ; i <= 200 ; i ++ ) Dp [ 1 ] [ 1 ] [ i ] = 1 ; cr = 1 ; for ( i = 2 ; i <= n ; i ++ ) { cr = 1 - cr ; if ( A [ i ] != - 1 ) { for ( j = 1 ; j <= 200 ; j ++ ) { if ( A [ i ] < j ) f ( Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ] ) ; if ( A [ i ] == j ) { f ( Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ] ) ; f ( Dp [ cr ] [ 0 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 1 ] [ j ] ) ; } if ( A [ i ] > j ) { f ( Dp [ cr ] [ 1 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 0 ] [ j ] ) ; f ( Dp [ cr ] [ 1 ] [ A [ i ] ] , Dp [ 1 - cr ] [ 1 ] [ j ] ) ; } Dp [ 1 - cr ] [ 1 ] [ j ] = Dp [ 1 - cr ] [ 0 ] [ j ] = 0 ; } } else { sum = 0 ; for ( j = 1 ; j <= 200 ; j ++ ) f ( sum , Dp [ 1 - cr ] [ 0 ] [ j ] ) ; sum1 = 0 ; for ( j = 1 ; j <= 200 ; j ++ ) { f ( Dp [ cr ] [ 0 ] [ j ] , sum ) ; f ( Dp [ cr ] [ 0 ] [ j ] , Dp [ 1 - cr ] [ 1 ] [ j ] ) ; f ( sum , 998244353 - Dp [ 1 - cr ] [ 0 ] [ j ] ) ; f ( Dp [ cr ] [ 1 ] [ j ] , sum1 ) ; f ( sum1 , Dp [ 1 - cr ] [ 1 ] [ j ] ) ; f ( sum1 , Dp [ 1 - cr ] [ 0 ] [ j ] ) ; Dp [ 1 - cr ] [ 0 ] [ j ] = Dp [ 1 - cr ] [ 1 ] [ j ] = 0 ; } } } for ( i = 1 ; i <= 200 ; i ++ ) f ( rez , Dp [ cr ] [ 0 ] [ i ] ) ; cout << rez << " \n " ; return 0 ; }
TAB1 create strings a and b ; TAB1 while cin > > a is truthy ; TAB2 create bool f = false ; TAB2 if the length of a is less than 3 ; TAB3 print " No " ; TAB3 continue to the next loop iteration ; TAB2 for i = 0 to the length of a ; TAB3 set b to the value of a . substr ( i , 3 ) ; TAB3 if b [ 0 ] is not equal to ' . ' and b [ 1 ] is not equal to ' . ' and b [ 2 ] is not equal to ' . ' ; TAB4 if b [ 0 ] is not equal to b [ 1 ] and b [ 1 ] is not equal to b [ 2 ] and b [ 2 ] is not equal to b [ 0 ] ; TAB5 set f to true ; TAB5 break loop ; TAB3 make b an empty string ; TAB2 if f is truthy ; TAB3 print " Yes " ; TAB2 else ; TAB3 print " No " ;	int main ( ) { string a , b ; while ( cin >> a ) { bool f = false ; if ( a . length ( ) < 3 ) { cout << " No " << endl ; continue ; } for ( int i = 0 ; i <= a . length ( ) - 3 ; i ++ ) { b = a . substr ( i , 3 ) ; if ( b [ 0 ] != ' . ' && b [ 1 ] != ' . ' && b [ 2 ] != ' . ' ) { if ( b [ 0 ] != b [ 1 ] && b [ 1 ] != b [ 2 ] && b [ 2 ] != b [ 0 ] ) { f = true ; break ; } } b . clear ( ) ; } if ( f ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
TAB1 create integers n , k and x ; TAB1 declare integer variable ans = 0 and an integer array a with size 105 ; TAB1 s is a new set of unique integers ; TAB1 t is a new set of unique integers ; TAB1 read input to n and k ; TAB1 for i = 0 to n exclusive , read input to a [ i ] ; TAB1 for i = 0 to n exclusive ; TAB2 set x to a [ i ] ; TAB2 if there is no x in s ; TAB3 increment ans by one ; TAB3 insert x into s ; TAB2 if length of s = k + 1 ; TAB3 change t to s ; TAB3 remove x from t ; TAB3 loop j from i + 1 to n exclusive ; TAB4 if length of t = 1 , break the loop ; TAB4 remove a [ j ] from t ; TAB3 remove first element of t from s ; TAB1 print ans ;	int main ( ) { int n , k , x ; int ans = 0 , a [ 105 ] ; set < int > s ; set < int > t ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { x = a [ i ] ; if ( s . find ( x ) == s . end ( ) ) { ans ++ ; s . insert ( x ) ; } if ( s . size ( ) == k + 1 ) { t = s ; t . erase ( x ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( t . size ( ) == 1 ) break ; t . erase ( a [ j ] ) ; } s . erase ( * ( t . begin ( ) ) ) ; } } cout << ans << endl ; return 0 ; }
TAB0 len = integer ; TAB0 s = string ; TAB1 read s ; TAB1 len = length of s ; TAB1 for i = 0 to len - 2 exclusive ; TAB2 vc = vector of character ; TAB2 append s [ i ] in vc ; TAB2 append s [ i + 1 ] in vc ; TAB2 append s [ i + 2 ] in vc ; TAB2 sort vc . begin ( ) and vc . end ( ) ; TAB2 if vc [ 0 ] is A and vc [ 1 ] is B and vc [ 2 ] is C ; TAB3 print Yes ; TAB1 print No ;	int len ; string s ; int main ( ) { cin >> s ; len = s . length ( ) ; for ( int i = 0 ; i < len - 2 ; i ++ ) { vector < char > vc ; vc . push_back ( s [ i ] ) ; vc . push_back ( s [ i + 1 ] ) ; vc . push_back ( s [ i + 2 ] ) ; sort ( vc . begin ( ) , vc . end ( ) ) ; if ( vc [ 0 ] == ' A ' && vc [ 1 ] == ' B ' && vc [ 2 ] == ' C ' ) { cout << " Yes\n " ; return 0 ; } } cout << " No\n " ; return 0 ; }
TAB0 declare new constant long long N with value 1005 ; TAB0 new long long variables n and p ; TAB0 create arrays of long longs indeg , outdeg , nxt and diam with size N ; TAB1 read input to n and p ; TAB1 in a for loop , change i from 1 to p inclusive incrementing i ; TAB2 create new long longs u , v and w ; TAB2 read u , v and w from the user input ; TAB2 increment indeg [ v ] ; TAB2 increment outdeg [ u ] by one ; TAB2 change nxt [ u ] to v ; TAB2 assign w to diam [ u ] ; TAB1 declare new long long called ans with value 0 ; TAB1 start for loop from i = 1 to n inclusive , adding 1 if ( outdeg [ i ] > 0 and indeg [ i ] = 0 ) to ans on each loop ; TAB1 print ans and ' \ n ' to the standard output ; TAB1 for i from 1 to n inclusive incrementing i ; TAB2 if outdeg [ i ] > 0 and indeg [ i ] = 0 ; TAB3 declare long long idx with value i and val = 1e9 ; TAB3 while outdeg [ idx ] is not 0 ; TAB4 change val to min of val and diam [ idx ] ; TAB4 change the value of idx to nxt [ idx ] ; TAB3 print i , " " , idx , " " , val and ' \ n ' ;	const long long N = 1005 ; long long n , p ; long long indeg [ N ] , outdeg [ N ] , nxt [ N ] , diam [ N ] ; int main ( ) { cin >> n >> p ; for ( long long i = 1 ; i <= p ; i ++ ) { long long u , v , w ; cin >> u >> v >> w ; indeg [ v ] ++ ; outdeg [ u ] ++ ; nxt [ u ] = v ; diam [ u ] = w ; } long long ans = 0 ; for ( long long i = 1 ; i <= n ; i ++ ) ans += ( outdeg [ i ] > 0 && indeg [ i ] == 0 ) ; cout << ans << ' \n ' ; for ( long long i = 1 ; i <= n ; i ++ ) { if ( outdeg [ i ] > 0 && indeg [ i ] == 0 ) { long long idx = i , val = 1e9 ; while ( outdeg [ idx ] ) { val = min ( val , diam [ idx ] ) ; idx = nxt [ idx ] ; } cout << i << "   " << idx << "   " << val << ' \n ' ; } } return 0 ; }
TAB1 declare ints n and k , and int arrays a , b and mark with 1010 elements ; mark is filled with 0 ; TAB1 read from the input to n ; TAB1 read n values from the input to a [ i ] and b [ i ] , starting from the index 1 ; TAB1 in a for loop , change i from 1 to n inclusive ; TAB2 for j from 1 to n inclusive ; TAB3 if i ! = j ; TAB4 if a [ i ] is equal to b [ j ] , assign 1 to mark [ i ] ; TAB1 ans is a new integer variable = 0 ; TAB1 in a for loop , change i from 1 to n inclusive ; TAB2 if mark [ i ] is false , increment ans ; TAB1 print ans and " \ n " to the standard output ;	int main ( ) { int n , k , a [ 1010 ] , b [ 1010 ] , mark [ 1010 ] = { 0 } ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] >> b [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( i != j ) { if ( a [ i ] == b [ j ] ) mark [ i ] = 1 ; } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! mark [ i ] ) ans ++ ; cout << ans << " \n " ; return 0 ; }
TAB0 let x be long long int ; TAB1 read x ; TAB1 if x < = 1 ; TAB2 print - 1 with newline ; TAB1 else ; TAB2 print x + ' ' + x with newline ;	long long int x ; int main ( ) { cin >> x ; if ( x <= 1 ) { cout << " -1\n " ; } else { cout << x << '   ' << x << ' \n ' ; } }
TAB0 ch = character array of size 1005 ; TAB1 n = integer ; TAB1 read n , ch + 1 ; TAB1 ch [ 0 ] = ch [ n + 1 ] = 0 ; TAB1 flag = integer = 0 ; TAB1 if n is 1 and ch [ 1 ] is 0 ; TAB2 print No ; TAB1 else if n is 1 and ch [ 1 ] is 1 ; TAB2 print Yes ; TAB1 for i = 1 to n inclusive ; TAB2 if ch [ i ] is 1 and either ch [ i - 1 ] is not 0 or ch [ i + 1 ] is not 0 ; TAB3 flag = 1 ; TAB3 exit the for loop ; TAB2 if ch [ i ] is 0 and both of the following are true : if ch [ i - 1 ] is 0 and ch [ i + 1 ] is 0 ; TAB3 flag = 1 ; TAB3 exit the for loop ; TAB1 if flag is nonzero ; TAB2 print No ; TAB1 else ; TAB2 print Yes ;	char ch [ 1005 ] ; int main ( ) { int n ; cin >> n >> ( ch + 1 ) ; ch [ 0 ] = ch [ n + 1 ] = ' 0 ' ; int flag = 0 ; if ( n == 1 && ch [ 1 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } else if ( n == 1 && ch [ 1 ] == ' 1 ' ) { cout << " Yes " << endl ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ch [ i ] == ' 1 ' && ( ch [ i - 1 ] != ' 0 ' || ch [ i + 1 ] != ' 0 ' ) ) { flag = 1 ; break ; } if ( ch [ i ] == ' 0 ' && ( ch [ i - 1 ] == ' 0 ' && ch [ i + 1 ] == ' 0 ' ) ) { flag = 1 ; break ; } } if ( flag ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB1 n , a , b , c , ans = long long ; TAB1 read n , a , b , c ; TAB1 ans = n / a ; TAB1 if n > = c ans = max ( ans , ( n - c ) / ( b - c ) + ( n - ( n - c ) / ( b - c ) * ( b - c ) ) / a ) ; TAB1 print ans ;	int main ( ) { long long n , a , b , c , ans ; cin >> n >> a >> b >> c ; ans = n / a ; if ( n >= c ) ans = max ( ans , ( n - c ) / ( b - c ) + ( n - ( n - c ) / ( b - c ) * ( b - c ) ) / a ) ; cout << ans << endl ; return 0 ; }
TAB0 n = integer ; TAB0 in function is_x1 that takes integers a , b and return integer ; TAB1 if b equals 0 and a is greater than or equal to 0 and a is less than or equal to n , return 1 ; TAB0 in function is_x2 that takes integers a , b and return integer ; TAB1 if b equals n and a is greater than or equal to 0 and a is less than or equal to n , return 3 ; TAB0 in function is_y1 that takes integers b , a and return is_y1 ; TAB1 if b equals 0 and a is greater than or equal to 0 and a is less than or equal to n , return 4 ; TAB0 in function is_y2 that takes integers b , a and returns integer ; TAB1 if b equals n and a is greater than or equal to 0 and a is less than or equal to n , return 2 ; TAB1 let t be an integer ; TAB1 let x1 , x2 , y1 , y2 , j be integers ; TAB1 read n , x1 , y1 , x2 , y2 ; TAB1 let value1 , value2 , val , a , b be integers with val = 0 ; TAB1 for i = 0 to 2 exclusive ; TAB2 if i is equal to 0 ; TAB3 assign x1 to a and assign y1 to b ; TAB2 else ; TAB3 assign x2 to a and assign y2 to b ; TAB2 assign 1 to j ; TAB2 while val is false ; TAB3 if j equals 1 ; TAB4 set val to call function is_x1 with arguments a , b ; TAB3 else if j equals 2 ; TAB4 set val to call function is_y1 with arguments a , b ; TAB3 else if j equals 3 ; TAB4 set val to call function is_x2 with arguments a , b ; TAB3 else if j equals 4 ; TAB4 set val to call function is_y2 with arguments a , b ; TAB3 increment j ; TAB2 if i equals 0 ; TAB3 assign val to value1 ; TAB2 else ; TAB3 assign val to value2 ; TAB2 assign 0 to val ; TAB1 if value1 equals value2 ; TAB2 if value1 equals 1 or value1 equals 3 ; TAB3 display absolute value of x1 - x2 ; TAB2 else ; TAB3 display absolute value of y1 - y2 ; TAB1 else if ( value1 equals 1 and value2 equals 2 ) or ( value1 equals 2 and value2 equals 1 ) ; TAB2 if value1 equals 1 ; TAB3 display ( n - x1 ) + y2 ; TAB2 else ; TAB3 display ( n - x2 ) + y1 ; TAB1 else if ( value1 equals 1 and value2 equals 4 ) or ( value1 equals 4 and value2 equals 1 ) ; TAB2 if value1 equals 1 ; TAB3 display x1 + y2 ; TAB2 else ; TAB3 display x2 + y1 ; TAB1 else if ( value1 equals 2 and value2 equals 3 ) or ( value1 equals 3 and value2 equals 2 ) ; TAB2 if value1 equals 2 ; TAB3 display ( n - y1 ) + ( n - x2 ) ; TAB2 else ; TAB3 display ( n - y2 ) + ( n - x1 ) ; TAB1 else if ( value1 equals 3 and value2 equals 4 ) or ( value1 equals 4 and value2 equals 3 ) ; TAB2 if value1 equals 3 ; TAB3 display x1 + n - y2 ; TAB2 else ; TAB3 display x2 + n - y1 ; TAB1 else if ( value1 equals 1 and value2 equals 3 ) or ( value1 equals 3 and value2 equals 1 ) ; TAB2 display call function min with arguments x1 + n + x2 , n - x1 + n + n - x2 ; TAB1 else if ( value1 equals 2 and value2 equals 4 ) or ( value1 equals 4 and value2 equals 2 ) ; TAB2 display call function min with arguments y1 + n + y2 , n - y1 + n + n - y2 ;	int n ; int is_x1 ( int a , int b ) { if ( b == 0 && a >= 0 && a <= n ) return 1 ; return 0 ; } int is_x2 ( int a , int b ) { if ( b == n && a >= 0 && a <= n ) return 3 ; return 0 ; } int is_y1 ( int b , int a ) { if ( b == 0 && a >= 0 && a <= n ) return 4 ; return 0 ; } int is_y2 ( int b , int a ) { if ( b == n && a >= 0 && a <= n ) return 2 ; return 0 ; } int main ( ) { int t ; int x1 , x2 , y1 , y2 , j ; cin >> n >> x1 >> y1 >> x2 >> y2 ; int value1 , value2 , val = 0 , a , b ; for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 0 ) { a = x1 , b = y1 ; } else { a = x2 , b = y2 ; } j = 1 ; while ( ! val ) { if ( j == 1 ) val = is_x1 ( a , b ) ; else if ( j == 2 ) val = is_y1 ( a , b ) ; else if ( j == 3 ) val = is_x2 ( a , b ) ; else if ( j == 4 ) val = is_y2 ( a , b ) ; j ++ ; } if ( i == 0 ) value1 = val ; else value2 = val ; val = 0 ; } if ( value1 == value2 ) { if ( value1 == 1 || value1 == 3 ) { cout << abs ( x1 - x2 ) << " \n " ; } else cout << abs ( y1 - y2 ) << " \n " ; } else if ( ( value1 == 1 && value2 == 2 ) || ( value1 == 2 && value2 == 1 ) ) { if ( value1 == 1 ) cout << ( n - x1 ) + y2 << " \n " ; else cout << ( n - x2 ) + y1 << " \n " ; } else if ( ( value1 == 1 && value2 == 4 ) || ( value1 == 4 && value2 == 1 ) ) { if ( value1 == 1 ) cout << x1 + y2 << " \n " ; else cout << x2 + y1 << " \n " ; } else if ( ( value1 == 2 && value2 == 3 ) || ( value1 == 3 && value2 == 2 ) ) { if ( value1 == 2 ) cout << ( n - y1 ) + ( n - x2 ) << " \n " ; else cout << ( n - y2 ) + ( n - x1 ) << " \n " ; } else if ( ( value1 == 3 && value2 == 4 ) || ( value1 == 4 && value2 == 3 ) ) { if ( value1 == 3 ) cout << x1 + n - y2 << " \n " ; else cout << x2 + n - y1 << " \n " ; } else if ( ( value1 == 1 && value2 == 3 ) || ( value1 == 3 && value2 == 1 ) ) { cout << ( min ( x1 + n + x2 , n - x1 + n + n - x2 ) ) << " \n " ; } else if ( ( value1 == 2 && value2 == 4 ) || ( value1 == 4 && value2 == 2 ) ) { cout << ( min ( y1 + n + y2 , n - y1 + n + n - y2 ) ) << " \n " ; } return 0 ; }
TAB0 x , y = long long integers ; TAB0 declare exgcd that takes two arguments , long long integers a and b ; TAB1 if b is 0 ; TAB2 set x to 1 ; TAB2 set y to 0 ; TAB2 return a ; TAB1 d = long long integer set to exgcd of b and a modulo b ; TAB1 t = long long integer set to x ; TAB1 set x to y ; TAB1 set y to t - a / b * y ; TAB1 return d ; TAB1 m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 = long long integers ; TAB1 p1 , p2 , q1 , q2 = long long integers ; TAB1 while reading m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , and y2 ; TAB2 set p1 , p2 , q1 , q2 to 0 ; TAB2 for i = 1 to 2 * m inclusive ; TAB3 set h1 to h1 * x1 + y1 modulo m ; TAB3 if h1 is a1 ; TAB4 if p1 is 0 ; TAB5 set p1 to i ; TAB4 else if q1 is 0 ; TAB5 set q1 to i - p1 ; TAB5 break ; TAB2 for i = 1 to 2 * m inclusive ; TAB3 set h2 to h2 * x2 + y2 modulo m ; TAB3 if h2 is a2 ; TAB4 if p2 is 0 ; TAB5 set p2 to i ; TAB4 else if q2 is 0 ; TAB5 set q2 to i - p2 ; TAB5 break ; TAB2 d = long long integer set to exgcd of q1 and - q2 ; TAB2 c = long long integer set to p2 - p1 ; TAB2 if d is 0 ; TAB3 puts " - 1 " ; TAB3 continue ; TAB2 if c modulo d ; TAB3 puts " - 1 " ; TAB3 continue ; TAB2 if p1 is 0 or p2 is 0 ; TAB3 puts " - 1 " ; TAB3 continue ; TAB2 if q2 is 0 and q1 is 0 and p1 ! = p2 ; TAB3 puts " - 1 " ; TAB3 continue ; TAB2 if q2 is 0 and p2 - p1 < 0 or q1 is 0 and p1 - p2 < 0 ; TAB3 puts " - 1 " ; TAB3 continue ; TAB2 k = long long integer set to c / d ; TAB2 multiply x by k ; TAB2 multiply y by k ; TAB2 if d < 0 , set d to - d ; TAB2 if x < 0 or y < 0 ; TAB3 while 1 exists ; TAB4 add q2 / d to x ; TAB4 add q1 / d to y ; TAB4 if x > = 0 and y > = 0 , break ; TAB2 if x > 0 and y > 0 ; TAB3 while 1 exists ; TAB4 subtract q2 / d from x ; TAB4 subtract q1 / d from y ; TAB4 if x < 0 or y < 0 ; TAB5 add q2 / d to x ; TAB5 add q1 / d to y ; TAB5 break ; TAB2 ans = long long integer set to x * q1 + p1 ; TAB2 print ans ;	long long x , y ; long long exgcd ( long long a , long long b ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long d = exgcd ( b , a % b ) ; long long t = x ; x = y ; y = t - a / b * y ; return d ; } int main ( ) { long long m , h1 , a1 , x1 , y1 , h2 , a2 , x2 , y2 ; long long p1 , p2 , q1 , q2 ; while ( cin >> m >> h1 >> a1 >> x1 >> y1 >> h2 >> a2 >> x2 >> y2 ) { p1 = p2 = q1 = q2 = 0 ; for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h1 = ( h1 * x1 + y1 ) % m ; if ( h1 == a1 ) { if ( p1 == 0 ) p1 = i ; else if ( q1 == 0 ) { q1 = i - p1 ; break ; } } } for ( long long i = 1 ; i <= 2 * m ; i ++ ) { h2 = ( h2 * x2 + y2 ) % m ; if ( h2 == a2 ) { if ( p2 == 0 ) p2 = i ; else if ( q2 == 0 ) { q2 = i - p2 ; break ; } } } long long d = exgcd ( q1 , - q2 ) ; long long c = p2 - p1 ; if ( d == 0 ) { puts ( " -1 " ) ; continue ; } if ( c % d ) { puts ( " -1 " ) ; continue ; } if ( p1 == 0 || p2 == 0 ) { puts ( " -1 " ) ; continue ; } if ( q2 == 0 && q1 == 0 && p1 != p2 ) { puts ( " -1 " ) ; continue ; } if ( ( q2 == 0 && p2 - p1 < 0 ) || ( q1 == 0 && p1 - p2 < 0 ) ) { puts ( " -1 " ) ; continue ; } long long k = c / d ; x *= k ; y *= k ; if ( d < 0 ) d = - d ; if ( x < 0 || y < 0 ) { while ( 1 ) { x += q2 / d ; y += q1 / d ; if ( x >= 0 && y >= 0 ) break ; } } if ( x > 0 && y > 0 ) { while ( 1 ) { x -= q2 / d ; y -= q1 / d ; if ( x < 0 || y < 0 ) { x += q2 / d ; y += q1 / d ; break ; } } } long long ans = x * q1 + p1 ; cout << ans << endl ; } return 0 ; }
TAB1 x , t , a , b , Da , Db , total = integers , total = 0 ; TAB1 right = boolean false ; TAB1 aa , bb = integers ; TAB1 read x , t , a , b , Da , Db ; TAB1 let aa = 0 ; TAB1 let bb = 0 ; TAB1 for int i 0 to t inclusive ; TAB2 for int i = 0 to t inclusive ; TAB3 let total = aa + bb ; TAB3 if total equals x ; TAB4 let right = true ; TAB4 exit for loop ; TAB3 let bb = b - Db * i ; TAB2 if true , exit for loop ; TAB2 let aa = a - Da * i ; TAB2 let bb = 0 ; TAB1 if true ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int main ( ) { int x , t , a , b , Da , Db , total = 0 ; bool right = false ; int aa , bb ; cin >> x >> t >> a >> b >> Da >> Db ; aa = 0 ; bb = 0 ; for ( int i = 0 ; i <= t ; i ++ ) { for ( int i = 0 ; i <= t ; i ++ ) { total = aa + bb ; if ( total == x ) { right = true ; break ; } bb = b - Db * ( i ) ; } if ( right ) { break ; } aa = a - Da * ( i ) ; bb = 0 ; } if ( right ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB1 x , y = integers ; TAB1 Read x , y ; TAB1 if x is 0 and y is 0 ; TAB2 print 0 and a new line ; TAB1 if x is 1 and y is 0 ; TAB2 print 0 and a new line ; TAB1 if x is 1 and y is 1 ; TAB2 print 1 and a new line ; TAB1 if y is 1 and - 1 is less than or equal to x and x is less than or equal to 0 ; TAB2 print 2 and a new line ; TAB1 if ( x is - 1 and - 1 is less than or equal to y and y is less than or equal to 1 ; TAB2 print 3 and a new line ; TAB1 if ( y is - 1 and - 1 is less than or equal to x and x is less than or equal to 2 ) ; TAB2 print 4 and a new line ; TAB1 z = integer , set to maximum value of absolute value of x and absolute value of y ; TAB1 if x is z and y is - z + 1 ; TAB2 print 4 * z - 4 and a new line ; TAB1 if x is z and y is not - z ) ; TAB2 print 4 * z - 3 and a new line ; TAB1 if y is z ; TAB2 print 4 * z - 2 and a new line ; TAB1 if x is - z ; TAB2 print 4 * z - 1 and a new line ; TAB1 print 4 * z + 0 and a new line ;	int main ( ) { int x , y ; cin >> x >> y ; if ( x == 0 && y == 0 ) { cout << " 0\n " ; return 0 ; } if ( x == 1 && y == 0 ) { cout << " 0\n " ; return 0 ; } if ( y == 1 && x == 1 ) { cout << " 1\n " ; return 0 ; } if ( y == 1 && - 1 <= x && x <= 0 ) { cout << " 2\n " ; return 0 ; } if ( x == - 1 && - 1 <= y && y <= 1 ) { cout << " 3\n " ; return 0 ; } if ( y == - 1 && - 1 <= x && x <= 2 ) { cout << " 4\n " ; return 0 ; } int z = max ( abs ( x ) , abs ( y ) ) ; if ( x == z && y == - z + 1 ) { cout << 4 * z - 4 << ' \n ' ; return 0 ; } if ( x == z && y != - z ) { cout << 4 * z - 3 << ' \n ' ; return 0 ; } if ( y == z ) { cout << 4 * z - 2 << ' \n ' ; return 0 ; } if ( x == - z ) { cout << 4 * z - 1 << ' \n ' ; return 0 ; } cout << 4 * z + 0 << ' \n ' ; }
TAB0 a = integer array of size 100001 ; TAB1 n = integer ; TAB1 read n ; TAB1 for i = 1 to n + 1 exclusive , read a [ i ] ; TAB1 res = long long with res = 0 ; TAB1 t = integer ; TAB1 for i = 1 to n exclusive ; TAB2 for t = 1 to i + t < = n with t = t * 2 ; TAB3 ; ; TAB2 t = right shift t 1 place ; TAB2 res = res + a [ i ] ; TAB2 a [ i + t ] = a [ i + t ] + a [ i ] ; TAB2 print res ;	int a [ 100001 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i < n + 1 ; i ++ ) cin >> a [ i ] ; long long res = 0 ; int t ; for ( int i = 1 ; i < n ; i ++ ) { for ( t = 1 ; i + t <= n ; t *= 2 ) ; t >>= 1 ; res += a [ i ] ; a [ i + t ] += a [ i ] ; cout << res << endl ; } return 0 ; }
TAB0 create integers N , K ; TAB0 create integer array A with size 100005 ; TAB0 create integer vector ans ; TAB0 declare searchFor with integer x as argument , returning integer ; TAB1 create integer left with left = 0 ; TAB1 create integer right with right = size of ans - 1 ; TAB1 while left is less than or equal to right ; TAB2 create integer mid with mid = ( left + right ) / 2 ; TAB2 if x is greater than ans [ mid ] ; TAB3 set left to mid + 1 ; TAB2 else if x is less than ans [ mid ] ; TAB3 set right to mid - 1 ; TAB2 else ; TAB3 return mid from function ; TAB1 return - 1 from function ; TAB1 read N read K ; TAB1 for i = 0 to N exclusive , read A [ i ] ; TAB1 sort elements from A to A + N ; TAB1 add element A [ 0 ] to end of ans ; TAB1 for i = 1 to N exclusive ; TAB2 if A [ i ] % K is 0 ; TAB3 create integer temp with temp = A [ i ] / K ; TAB3 create integer pos with pos = result of run searchFor with temp as argument ; TAB3 if pos is - 1 , add element A [ i ] to end of ans ; TAB2 else ; TAB3 add element A [ i ] to end of ans ; TAB1 print size of ans print newline ;	int N , K ; int A [ 100005 ] ; vector < int > ans ; int searchFor ( int x ) { int left = 0 ; int right = ans . size ( ) - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( x > ans [ mid ] ) { left = mid + 1 ; } else if ( x < ans [ mid ] ) { right = mid - 1 ; } else { return mid ; } } return - 1 ; } int main ( ) { cin >> N >> K ; for ( int i = 0 ; i < N ; i ++ ) { cin >> A [ i ] ; } sort ( A , A + N ) ; ans . push_back ( A [ 0 ] ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] % K == 0 ) { int temp = A [ i ] / K ; int pos = searchFor ( temp ) ; if ( pos == - 1 ) { ans . push_back ( A [ i ] ) ; } } else { ans . push_back ( A [ i ] ) ; } } cout << ans . size ( ) << endl ; }
TAB1 let n , i , x , y , j longs with x and y = 0 ; TAB1 read n ; TAB1 let a array of longs of length n ; TAB1 read the first n values of a ; TAB1 for i = 0 to n exclusive ; TAB2 set x and y to 0 ; TAB2 for j from i + 2 to n exclusive ; TAB3 if ( a [ j ] bigger than a [ i ] and a [ i + 1 ] ) or ( a [ j ] smaller than a [ i ] and a [ i + 1 ] ) ; TAB4 increment x ; TAB3 otherwise ; TAB4 increment y ; TAB2 if x and y nonzero ; TAB3 print yes ; TAB1 print no ; TAB1 empty statement ;	int main ( ) { long n , i , x = 0 , y = 0 , j ; cin >> n ; long a [ n ] ; for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; for ( i = 0 ; i < n ; i ++ ) { x = y = 0 ; for ( j = i + 2 ; j < n ; j ++ ) if ( ( a [ j ] > a [ i ] && a [ j ] > a [ i + 1 ] ) || ( a [ j ] < a [ i ] && a [ j ] < a [ i + 1 ] ) ) x ++ ; else y ++ ; if ( x && y ) { cout << " yes " << endl ; return 0 ; } } cout << " no " << endl ; ; }
TAB1 s = string ; TAB1 read s ; TAB1 cont1 , cont2 , cont3 = int with cont1 = 0 and cont2 = 0 and cont3 = 0 ; TAB1 i = int with i = 0 ; TAB1 iterate i while i < size of s and s [ i ] is ' a ' increment cont1 ; TAB1 continue iterating i while i < size of s and s [ i ] is ' b ' increment cont2 ; TAB1 continue iterating i while i < size of s and s [ i ] is ' c ' increment cont3 ; TAB1 if cont1 or cont2 is 0 or i is not size of s ; TAB2 print " NO " ; TAB1 else ; TAB2 if cont1 is cont3 or cont2 is cont3 ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ;	int main ( ) { string s ; cin >> s ; int cont1 = 0 , cont2 = 0 , cont3 = 0 ; int i = 0 ; for ( ; i < s . size ( ) && s [ i ] == ' a ' ; i ++ ) { cont1 ++ ; } for ( ; i < s . size ( ) && s [ i ] == ' b ' ; i ++ ) { cont2 ++ ; } for ( ; i < s . size ( ) && s [ i ] == ' c ' ; i ++ ) { cont3 ++ ; } if ( cont1 == 0 || cont2 == 0 || i != s . size ( ) ) { cout << " NO\n " ; } else { if ( cont1 == cont3 || cont2 == cont3 ) { cout << " YES\n " ; } else { cout << " NO\n " ; } } return 0 ; }
TAB0 new integer constant called inf = 0x3f3f3f3f ; TAB0 create constant integer maxn with value 110 ; TAB0 function max with int arguments a and b that returns int ; TAB1 return a if a > b , else b ; TAB0 function min with int arguments a and b that returns integer ; TAB1 return a if a > b , else return b ; TAB0 create new array of integers a with maxn elements ; TAB1 create ints i and n ; TAB1 read n and keep looping ; TAB2 assign the new values : 0 to a [ 0 ] and 1001 to a [ n + 1 ] ; TAB2 read n elements into a starting from the index 1 ; TAB2 create integer l ; TAB2 declare new integer maxi with value 1 ; TAB2 start for loop from l = 0 to n inclusive incrementing l ; TAB3 create new integer called pos = l ; TAB3 while l < = n and a [ l ] + 1 is a [ l + 1 ] ; TAB3 if l - pos + 1 is greater than maxi , assign l - pos + 1 to maxi ; TAB2 if maxi is equal to 1 ; TAB3 print " 0 " ; TAB2 else ; TAB3 print maxi - 2 ;	const int inf = 0x3f3f3f3f ; const int maxn = 110 ; int max ( int a , int b ) { return a > b ? a : b ; } int min ( int a , int b ) { return a > b ? b : a ; } int a [ maxn ] ; int main ( ) { int i , n ; while ( cin >> n ) { a [ 0 ] = 0 , a [ n + 1 ] = 1001 ; for ( i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; int l ; int maxi = 1 ; for ( l = 0 ; l <= n ; l ++ ) { int pos = l ; while ( l <= n && a [ l ] + 1 == a [ l + 1 ] ) { l ++ ; } if ( l - pos + 1 > maxi ) { maxi = l - pos + 1 ; } } if ( maxi == 1 ) cout << " 0 " << endl ; else cout << maxi - 2 << endl ; } return 0 ; }
TAB0 let maxn be a constant integer with maxn = 1e5 + 5 ; TAB0 let mx be a constant integer with mx = 1e6 + 5 ; TAB0 let mod be a constant integer with mod = 1e9 + 7 ; TAB0 let n , d be long integers ; TAB0 a = array of long integers of length maxn ; TAB0 st = array of long integers of length maxn ; TAB1 while read n , d ; TAB2 for i = 1 to n inclusive , read a [ i ] ; TAB2 let top be a integer with top = 1 ; TAB2 let ans be a long integer with ans = 0 ; TAB2 let tail be a integer with tail = 0 ; TAB2 for i = 1 to n inclusive ; TAB3 increment tail by 1 ; TAB3 while top < = tail and a [ tail ] - a [ top ] is greater than d , increment top by 1 ; TAB3 let res be a integer with res = tail - top ; TAB3 increment ans by ( long long ) res * ( res - 1 ) / 2 ; TAB2 print ans and newline ;	const int maxn = 1e5 + 5 ; const int mx = 1e6 + 5 ; const int mod = 1e9 + 7 ; long long n , d ; long long a [ maxn ] ; long long st [ maxn ] ; int main ( ) { while ( cin >> n >> d ) { for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } int top = 1 ; long long ans = 0 ; int tail = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { tail ++ ; while ( top <= tail && a [ tail ] - a [ top ] > d ) top ++ ; int res = tail - top ; ans += ( long long ) res * ( res - 1 ) / 2 ; } cout << ans << endl ; } }
TAB0 sx , sy , ex , ey , n = integers ; TAB0 cnt = integers with cnt = 0 ; TAB0 x , y = integers with x = 0 , y = 0 ; TAB0 dist = integers with dist = 0 ; TAB0 fl , chng = bool with fl = false , chng = false ; TAB0 in the function chk ; TAB1 if cnt is 0 and x is ex and y is ey ; TAB2 swap sx and ex , swap sy and ey ; TAB2 chng = true ; TAB1 read n ; TAB1 read sx , sy , ex , ey ; TAB1 while x < n ; TAB2 increment x ; TAB2 if chng is false , call chk ; TAB2 if x is sx and y is sy ; TAB3 increment cnt , fl = true ; TAB2 else if x is ex and y is ey ; TAB3 increment cnt , fl = false ; TAB3 break loop ; TAB2 if fl , increment dist ; TAB1 while y < n ; TAB2 increment y ; TAB2 if chng is false , call chk ; TAB2 if x is sx and y is sy ; TAB3 increment cnt , fl = true ; TAB2 else if x is ex and y is ey ; TAB3 increment cnt , fl = false ; TAB3 break loop ; TAB2 if fl , increment dist ; TAB1 while x > 0 ; TAB2 decrement x ; TAB2 if chng is false , call chk ; TAB2 if x is sx and y is sy ; TAB3 increment cnt , fl = true ; TAB2 else if x is ex and y is ey ; TAB3 increment cnt , fl = false ; TAB3 break loop ; TAB2 if fl , increment dist ; TAB1 while y > 0 ; TAB2 decrement y ; TAB2 if chng is false , call chk ; TAB2 if x is sx and y is sy ; TAB3 increment cnt , fl = true ; TAB2 else if x is ex and y is ey ; TAB3 increment cnt , fl = false ; TAB3 break loop ; TAB2 if fl , increment dist ; TAB1 if sx is ex and sy is ey , dist = 0 ; TAB1 print min of dist and 4 * n - dist ;	int sx , sy , ex , ey , n ; int cnt = 0 ; int x = 0 , y = 0 ; int dist = 0 ; bool fl = false , chng = false ; void chk ( ) { if ( cnt == 0 and x == ex and y == ey ) { swap ( sx , ex ) , swap ( sy , ey ) ; chng = true ; } } int main ( ) { cin >> n ; cin >> sx >> sy >> ex >> ey ; while ( x < n ) { x ++ ; if ( chng == false ) chk ( ) ; if ( x == sx and y == sy ) cnt ++ , fl = true ; else if ( x == ex and y == ey ) { cnt ++ , fl = false ; break ; } if ( fl ) dist ++ ; } while ( y < n ) { y ++ ; if ( chng == false ) chk ( ) ; if ( x == sx and y == sy ) cnt ++ , fl = true ; else if ( x == ex and y == ey ) { cnt ++ , fl = false ; break ; } if ( fl ) dist ++ ; } while ( x > 0 ) { x -- ; if ( chng == false ) chk ( ) ; if ( x == sx and y == sy ) cnt ++ , fl = true ; else if ( x == ex and y == ey ) { cnt ++ , fl = false ; break ; } if ( fl ) dist ++ ; } while ( y > 0 ) { y -- ; if ( chng == false ) chk ( ) ; if ( x == sx and y == sy ) cnt ++ , fl = true ; else if ( x == ex and y == ey ) { cnt ++ , fl = false ; break ; } if ( fl ) dist ++ ; } if ( sx == ex and sy == ey ) dist = 0 ; cout << min ( dist , 4 * n - dist ) << endl ; return 0 ; }
TAB0 declare desperate_optimization with integer precision as argument , returning void ; TAB1 set cout flag ios : : fixed ; TAB1 set cout flag ios : showpoint ; TAB1 set cout precision to precision ; TAB0 create maps ms , vis from long long to integer ; TAB0 create constant integer N with N = 1e5 ; TAB0 create long long array arr with size N + 5 ; TAB0 declare hora with integer tc as argument , returning void ; TAB1 create long longs n , k ; TAB1 read n read k ; TAB1 for i = 0 to n exclusive ; TAB2 read arr [ i ] ; TAB2 set ms [ arr [ i ] ] to 1 ; TAB1 create integer tot with tot = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 create integer ctr with ctr = 0 ; TAB2 if vis [ arr [ i ] ] is 0 ; TAB3 set vis [ arr [ i ] ] to 1 ; TAB3 create long long x with x = arr [ i ] ; TAB3 increment ctr ; TAB3 while ms [ x * k ] and vis [ x * k ] is 0 ; TAB4 set vis [ x * k ] to 1 ; TAB4 set x to x * k ; TAB4 increment ctr ; TAB3 set x to arr [ i ] ; TAB3 while x % k is 0 and ms [ x / k ] and vis [ x / k ] is 0 ; TAB4 set vis [ x / k ] to 1 ; TAB4 set x to x / k ; TAB4 increment ctr ; TAB3 increment tot by ( ctr + 1 ) / 2 ; TAB1 print tot print ' \ n ' ; TAB1 run desperate_optimization with 10 as argument ; TAB1 create integer ntc with ntc = 1 ; TAB1 for tc = 1 to ntc inclusive , run hora with tc as argument ;	void desperate_optimization ( int precision ) { cout . setf ( ios :: fixed ) ; cout . setf ( ios :: showpoint ) ; cout . precision ( precision ) ; } map < long long , int > ms , vis ; const int N = 1e5 ; long long arr [ N + 5 ] ; void hora ( int tc ) { long long n , k ; cin >> n >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; ms [ arr [ i ] ] = 1 ; } int tot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ctr = 0 ; if ( vis [ arr [ i ] ] == 0 ) { vis [ arr [ i ] ] = 1 ; long long x = arr [ i ] ; ctr ++ ; while ( ms [ x * k ] && vis [ x * k ] == 0 ) { vis [ x * k ] = 1 ; x *= k ; ctr ++ ; } x = arr [ i ] ; while ( x % k == 0 && ms [ x / k ] && vis [ x / k ] == 0 ) { vis [ x / k ] = 1 ; x /= k ; ctr ++ ; } tot += ( ctr + 1 ) / 2 ; } } cout << tot << ' \n ' ; } int main ( ) { desperate_optimization ( 10 ) ; int ntc = 1 ; for ( int tc = 1 ; tc <= ntc ; tc ++ ) hora ( tc ) ; return 0 ; }
TAB0 create a map from strings to integers called character ; TAB0 create string s ; TAB0 declare double variables n , m , k and res ; TAB0 create floats check and level ; TAB1 read input to n , m and k ; TAB1 while n ! = 0 , decrement it and continue the loop ; TAB2 read input to s and level ; TAB2 set check to k * level ; TAB2 if check > = 100 , change character [ s ] to check ; TAB1 decrement m and loop further , while m is not 0 ; TAB2 read s ; TAB2 if character [ s ] > = 100 ; TAB3 skip the rest of the loop ; TAB2 else ; TAB3 set character [ s ] to 0 ; TAB1 create map iterator it ; TAB1 print length of character ; TAB1 moving it through character , print it - > first , " " and it - > second ;	map < string , int > character ; string s ; double n , m , k , res ; float check , level ; int main ( ) { cin >> n >> m >> k ; while ( n -- ) { cin >> s >> level ; check = k * level ; if ( check >= 100 ) character [ s ] = check ; } while ( m -- ) { cin >> s ; if ( character [ s ] >= 100 ) continue ; else { character [ s ] = 0 ; } } map < string , int > :: iterator it ; cout << character . size ( ) << endl ; for ( it = character . begin ( ) ; it != character . end ( ) ; it ++ ) { cout << it -> first << "   " << it -> second << endl ; } return 0 ; }
TAB0 let s be a string ; TAB1 input s ; TAB1 let l be an integer with l = the length of s ; TAB1 for i = 0 to l exclusive ; TAB2 for j = 0 to 3 exclusive ; TAB3 for k = 0 to 3 exclusive ; TAB4 for p = 0 to 3 exclusive ; TAB5 if j is unequal to k and j is unequal to p and k is unequal to p ; TAB6 c1 = character = the character A + j ; TAB6 c2 = character = the character A + k ; TAB6 c3 = character = the character A + p ; TAB6 if s [ i ] equals c1 and s [ i + 1 ] equals c2 and s [ i + 2 ] equals c3 ; TAB7 display Yes ; TAB1 display No ;	string s ; int main ( ) { cin >> s ; int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { for ( int p = 0 ; p < 3 ; p ++ ) { if ( j != k && j != p && k != p ) { char c1 = ' A ' + j ; char c2 = ' A ' + k ; char c3 = ' A ' + p ; if ( s [ i ] == c1 && s [ i + 1 ] == c2 && s [ i + 2 ] == c3 ) { cout << " Yes " << endl ; return 0 ; } } } } } } cout << " No " << endl ; return 0 ; }
TAB0 declare const int maxn = 110 ; TAB0 declare an array of integers a with maxn elements ; TAB0 declare an array of long longs b with size maxn ; TAB0 declare an array of booleans vis with size maxn ; TAB0 dfs is a int function with int arguments u , s and l ; TAB1 if u is equal to s ; TAB2 assign l + 1 to l ; TAB2 return l ; TAB1 if vis [ u ] is true and u ! = s , return - 1 ; TAB1 set vis [ u ] to 1 ; TAB1 if a [ u ] is equal to s ; TAB2 return the result of dfs ( a [ u ] , s , l ) ; TAB1 else ; TAB2 return the result of dfs ( a [ u ] , s , l + 1 ) ; TAB0 long long function gcd with int arguments aa and bb ; TAB1 if bb is equal to 0 , return aa ; TAB1 return gcd ( bb , aa % bb ) ; TAB1 declare int variable n ; TAB1 loop , reading n from the input ; TAB2 for i from 1 to n inclusive , read a [ i ] ; TAB2 set first sizeof ( vis ) bytes at the pointer vis to false ; TAB2 declare integer variable k = 0 ; TAB2 declare integer variable flag = 1 ; TAB2 loop i from 1 to n inclusive ; TAB3 if vis [ i ] is false ; TAB4 assign true to vis [ i ] ; TAB4 declare int variable tmp = dfs ( a [ i ] , i , 1 ) ; TAB4 if tmp ! = - 1 ; TAB5 if tmp is even ; TAB6 assign tmp / 2 to b [ k ] and increment k ; TAB5 else ; TAB6 set b [ k ] to tmp and increment k ; TAB4 else ; TAB5 change flag to 0 ; TAB5 stop the loop ; TAB2 if flag is false ; TAB3 print " - 1 " ; TAB2 else ; TAB3 declare long long p = b [ 0 ] , e and gbs ; TAB3 loop i from 0 to k exclusive ; TAB4 change e to gcd ( p , b [ i ] ) ; TAB4 change gbs to p * b [ i ] / e ; TAB4 assign gbs to p ; TAB3 print p ;	const int maxn = 110 ; int a [ maxn ] ; long long b [ maxn ] ; bool vis [ maxn ] ; int dfs ( int u , int s , int l ) { if ( u == s ) { l = l + 1 ; return l ; } if ( vis [ u ] && u != s ) { return - 1 ; } vis [ u ] = 1 ; if ( a [ u ] == s ) return dfs ( a [ u ] , s , l ) ; else return dfs ( a [ u ] , s , l + 1 ) ; } long long gcd ( int aa , int bb ) { if ( bb == 0 ) return aa ; return gcd ( bb , aa % bb ) ; } int main ( ) { int n ; while ( cin >> n ) { for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } memset ( vis , false , sizeof ( vis ) ) ; int k = 0 ; int flag = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! vis [ i ] ) { vis [ i ] = true ; int tmp = dfs ( a [ i ] , i , 1 ) ; if ( tmp != - 1 ) { if ( tmp % 2 == 0 ) b [ k ++ ] = tmp / 2 ; else b [ k ++ ] = tmp ; } else { flag = 0 ; break ; } } } if ( ! flag ) { cout << " -1 " << endl ; } else { long long p = b [ 0 ] , e , gbs ; for ( int i = 0 ; i < k ; i ++ ) { e = gcd ( p , b [ i ] ) ; gbs = p * b [ i ] / e ; p = gbs ; } cout << p << endl ; } } }
TAB1 create int m ; TAB1 read m ; TAB1 if m is equal to 0 ; TAB2 print " 1 \ n " ; TAB1 if m modulo 4 is 1 , print " 8 \ n " ; TAB1 if m % 4 is equal to 2 , print " 4 \ n " ; TAB1 if m modulo 4 is 3 , print " 2 \ n " ; TAB1 if m % 4 is 0 , print " 6 \ n " ;	int main ( ) { int m ; cin >> m ; if ( m == 0 ) { cout << " 1\n " ; return 0 ; } if ( m % 4 == 1 ) { cout << " 8\n " ; } if ( m % 4 == 2 ) { cout << " 4\n " ; } if ( m % 4 == 3 ) { cout << " 2\n " ; } if ( m % 4 == 0 ) { cout << " 6\n " ; } }
TAB0 create int a [ 1000 ] , n , b [ 1000 ] , ans , r , o , f , set f to 1 ; TAB1 read n ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 for a [ i ] less than 0 ; TAB3 if o > = 2 ; TAB4 increment ans ; TAB4 b [ ans ] = r ; TAB4 set r = 0 ; TAB4 assign 1 to o ; TAB4 set f = 1 ; TAB3 else ; TAB4 increment o ; TAB2 add 1 to r ; TAB1 print ans + 1 ; TAB1 for i = 1 to ans inclusive , print b [ i ] , " " ; TAB1 print n - f + 1 ; TAB1 print a newline ;	int a [ 1000 ] , n , b [ 1000 ] , ans , r , o , f = 1 ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i ] < 0 ) { if ( o >= 2 ) { ans ++ ; b [ ans ] = r ; r = 0 ; o = 1 ; f = i ; } else { o ++ ; } } r ++ ; } cout << ans + 1 << endl ; for ( int i = 1 ; i <= ans ; i ++ ) { cout << b [ i ] << "   " ; } cout << n - f + 1 ; cout << endl ; return 0 ; }
TAB1 s1 , s2 = character array of size 100005 and a , b = character array of size 2 ; TAB1 l1 , l2 , i , j0 , cnt = integers with j = 0 , cnt = 0 ; TAB1 read s1 , s2 ; TAB1 l1 = length of string ( s1 ) ; TAB1 l2 = length of string ( s2 ) ; TAB1 if l1 is not l2 ; TAB2 print NO ; TAB1 else ; TAB2 for i = 0 to l1 exclusive ; TAB3 if s1 [ i ] is not s2 [ i ] ; TAB4 increment cnt ; TAB4 a [ j ] = s1 [ i ] ; TAB4 b [ j ] = s2 [ i ] ; TAB4 increment j ; TAB4 if cnt > 2 ; TAB5 print NO ; TAB1 if a [ 1 ] is b [ 0 ] and a [ 0 ] is b [ 1 ] ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int main ( ) { char s1 [ 100005 ] , s2 [ 100005 ] , a [ 2 ] , b [ 2 ] ; int l1 , l2 , i , j = 0 , cnt = 0 ; cin >> s1 >> s2 ; l1 = strlen ( s1 ) ; l2 = strlen ( s2 ) ; if ( l1 != l2 ) { cout << " NO " << endl ; return 0 ; } else { for ( i = 0 ; i < l1 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { cnt ++ ; a [ j ] = s1 [ i ] ; b [ j ] = s2 [ i ] ; j ++ ; if ( cnt > 2 ) { cout << " NO " << endl ; return 0 ; } } } } if ( a [ 1 ] == b [ 0 ] && a [ 0 ] == b [ 1 ] ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 create string s ; TAB1 read s ; TAB1 create long long integers i , j ; TAB1 create booleans x , y , z , yy , with x = true , y = true , z = true , yy = true ; TAB1 for i = 1 to size of s - 1 exclusive ; TAB2 set x to true ; TAB2 set y to true ; TAB2 set z to true ; TAB2 if s [ i ] is ' A ' , set x to false ; TAB2 if s [ i ] is ' B ' , set y to false ; TAB2 if s [ i ] is ' C ' , set z to false ; TAB2 if s [ i - 1 ] is ' A ' , set x to false ; TAB2 if s [ i - 1 ] is ' B ' , set y to false ; TAB2 if s [ i - 1 ] is ' C ' , set z to false ; TAB2 if s [ i + 1 ] is ' A ' , set x to false ; TAB2 if s [ i + 1 ] is ' B ' , set y to false ; TAB2 if s [ i + 1 ] is ' C ' , set z to false ; TAB2 if x is false and y is false and z is false ; TAB3 set yy to false ; TAB3 break loop ; TAB1 if yy is false ; TAB2 print " Yes " print newline ; TAB1 else ; TAB2 print " No " print newline ;	int main ( ) { string s ; cin >> s ; long long int i , j ; bool x = true , y = true , z = true , yy = true ; for ( i = 1 ; i < s . size ( ) - 1 ; i ++ ) { x = true ; y = true ; z = true ; if ( s [ i ] == ' A ' ) { x = false ; } if ( s [ i ] == ' B ' ) { y = false ; } if ( s [ i ] == ' C ' ) { z = false ; } if ( s [ i - 1 ] == ' A ' ) { x = false ; } if ( s [ i - 1 ] == ' B ' ) { y = false ; } if ( s [ i - 1 ] == ' C ' ) { z = false ; } if ( s [ i + 1 ] == ' A ' ) { x = false ; } if ( s [ i + 1 ] == ' B ' ) { y = false ; } if ( s [ i + 1 ] == ' C ' ) { z = false ; } if ( x == false && y == false && z == false ) { yy = false ; break ; } } if ( yy == false ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } }
TAB0 create integer list array graph with size 101 ; TAB0 create integers n , e , size , create integer arrays l , incoming , with l size 101 , incoming size 101 ; TAB0 create long long integer ans ; TAB0 create boolean array visited with size 101 ; TAB0 declare gcd with long long integers a , b as arguments , returning long long integer ; TAB1 if a is less than b ; TAB2 return result of run gcd with b , a as arguments ; TAB1 else if b is 0 ; TAB2 return a from function ; TAB1 else ; TAB2 return result of run gcd with b , a % b as arguments ; TAB0 declare dfs with integers vertex , level as arguments , returning void ; TAB1 if visited [ vertex ] is true ; TAB2 if level % 2 is 0 ; TAB3 set l [ increment size ] to level / 2 ; TAB2 else ; TAB3 set l [ increment size ] to level ; TAB1 else ; TAB2 set visited [ vertex ] to true ; TAB2 run dfs with front of graph [ vertex ] , level + 1 as arguments ; TAB1 return from function ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 read e ; TAB2 add element e to end of graph [ i ] ; TAB2 increment incoming [ e ] ; TAB1 for i = 1 to n inclusive ; TAB2 if incoming [ i ] is not 1 ; TAB3 print " - 1 " print newline ; TAB1 for i = 1 to n inclusive ; TAB2 if not visited [ i ] , run dfs with i , 0 as arguments ; TAB1 set ans to l [ 0 ] ; TAB1 for i = 1 to size exclusive , set ans to ( ans * l [ i ] ) / result of run gcd with ans , l [ i ] as arguments ; TAB1 print ans print newline ;	list < int > graph [ 101 ] ; int n , e , l [ 101 ] , incoming [ 101 ] , size ; long long int ans ; bool visited [ 101 ] ; long long int gcd ( long long int a , long long int b ) { if ( a < b ) return gcd ( b , a ) ; else if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } void dfs ( int vertex , int level ) { if ( visited [ vertex ] ) { if ( level % 2 == 0 ) l [ size ++ ] = level / 2 ; else l [ size ++ ] = level ; } else { visited [ vertex ] = true ; dfs ( graph [ vertex ] . front ( ) , level + 1 ) ; } return ; } int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> e ; graph [ i ] . push_back ( e ) ; incoming [ e ] ++ ; } for ( int i = 1 ; i <= n ; ++ i ) { if ( incoming [ i ] != 1 ) { cout << " -1 " << endl ; return 0 ; } } for ( int i = 1 ; i <= n ; ++ i ) { if ( ! visited [ i ] ) dfs ( i , 0 ) ; } ans = l [ 0 ] ; for ( int i = 1 ; i < size ; ++ i ) ans = ( ans * l [ i ] ) / gcd ( ans , l [ i ] ) ; cout << ans << endl ; return 0 ; }
TAB0 M is a constant long long set to 1e5 ; TAB0 MOD is a constant long long set to 998244353 ; TAB0 PI is a constant double set to 3 . 14159265358979323846 ; TAB1 a , b are strings ; TAB1 read a , b ; TAB1 i and ans are both long longs both set to 0 ; TAB1 while i is less than length of a ; TAB2 c = long long = 0 ; TAB2 for long long j = 0 to length of b exclusive ; TAB3 if i + j is at least length of a , break ; TAB3 if a [ i + j ] equals b [ j ] , increment c ; TAB2 increment i ; TAB2 set ans to call max with ans , c ; TAB1 set i to 0 ; TAB1 while i is less than length of b ; TAB2 c = long long = 0 ; TAB2 for long long j = 0 to length of a exclusive ; TAB3 if i + j is at least length of b , break ; TAB3 if b [ i + j ] equals a [ j ] , increment c ; TAB2 increment i ; TAB2 set ans to call max with ans , c ; TAB1 display ( length of b ) - ans ;	const long long M = 1e5 ; const long long MOD = 998244353 ; const double PI = 3.14159265358979323846 ; int main ( ) { string a , b ; cin >> a >> b ; long long i = 0 , ans = 0 ; while ( i < a . length ( ) ) { long long c = 0 ; for ( long long j = 0 ; j < b . length ( ) ; j ++ ) { if ( ( i + j ) >= a . length ( ) ) break ; if ( a [ i + j ] == b [ j ] ) c ++ ; } i ++ ; ans = max ( ans , c ) ; } i = 0 ; while ( i < b . length ( ) ) { long long c = 0 ; for ( long long j = 0 ; j < a . length ( ) ; j ++ ) { if ( ( i + j ) >= b . length ( ) ) break ; if ( b [ i + j ] == a [ j ] ) c ++ ; } i ++ ; ans = max ( ans , c ) ; } cout << b . length ( ) - ans << " \n " ; }
TAB1 create strings a , b ; TAB1 read a read b ; TAB1 if size of a is not size of b ; TAB2 print " NO " print newline ; TAB1 create integer vector r ; TAB1 for i = 0 to size of a exclusive ; TAB2 if a [ i ] is not b [ i ] , add element i to end of r ; TAB1 if size of r is not 2 ; TAB2 print " NO " print newline ; TAB1 if a [ r [ 0 ] ] is b [ r [ 1 ] ] and a [ r [ 1 ] ] is b [ r [ 0 ] ] ; TAB2 print " YES " print newline ; TAB1 else ; TAB2 print " NO " print newline ;	int main ( ) { string a , b ; cin >> a >> b ; if ( a . size ( ) != b . size ( ) ) { cout << " NO " << endl ; return 0 ; } vector < int > r ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( a [ i ] != b [ i ] ) r . push_back ( i ) ; } if ( r . size ( ) != 2 ) { cout << " NO " << endl ; return 0 ; } if ( a [ r [ 0 ] ] == b [ r [ 1 ] ] && a [ r [ 1 ] ] == b [ r [ 0 ] ] ) cout << " YES " << endl ; else cout << " NO " << endl ; }
TAB0 create const int MAX = 2e5 ; TAB0 create pair of pair and long long a of size MAX + 9 ; TAB0 create long long ints n , k , a0 , x , y , m , ans , cnt , t , and tmp ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read k , a0 , x , y , and m and set to 0 ; TAB2 for j = 0 to k exclusive ; TAB3 if cnt is less than or equal to MAX , set a [ cnt + + ] to { { t , a0 } , i } ; TAB3 set tmp to ( a0 * x + y ) % m ; TAB3 if tmp is less than a0 and j is not equal to k - 1 , increment t ; TAB3 set a0 to tmp ; TAB2 set ans to max of ans and t ; TAB1 print ans ; TAB1 if cnt is less than or equal to MAX ; TAB2 sort a using a + cnt ; TAB2 for i = 0 to cnt exclusive , print a [ i ] . first . second , " " , and a [ i ] . second + 1 ;	const int MAX = 2e5 ; pair < pair < long long , long long > , long long > a [ MAX + 9 ] ; long long n , k , a0 , x , y , m , ans , cnt , t , tmp ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> k >> a0 >> x >> y >> m , t = 0 ; for ( int j = 0 ; j < k ; j ++ ) { if ( cnt <= MAX ) a [ cnt ++ ] = { { t , a0 } , i } ; tmp = ( a0 * x + y ) % m ; if ( tmp < a0 && j != k - 1 ) t ++ ; a0 = tmp ; } ans = max ( ans , t ) ; } cout << ans << ' \n ' ; if ( cnt <= MAX ) { sort ( a , a + cnt ) ; for ( int i = 0 ; i < cnt ; i ++ ) cout << a [ i ] . first . second << "   " << a [ i ] . second + 1 << ' \n ' ; } }
TAB0 declare const int N = 2e5 + 100 ; TAB0 ma and mb are maps of long long to long long ; TAB0 p is an array of long long / long long pairs with N elements ; TAB0 create integers vector v1 and an array of integer vectors v with N elements ; TAB0 s is a set of long longs ; TAB1 a , b , i , n , p , q , t and x are integers with i , p , q and x = 0 ; TAB1 pr is an array of int / int pairs with 1000 elements ; TAB1 read t ; TAB1 set n to t ; TAB1 decrement t and loop further , while t ! = 0 ; TAB2 read a and b ; TAB2 set pr [ i ] to make_pair ( a , b ) ; TAB2 increment i ; TAB2 if a is greater than 0 ; TAB3 increment p by one ; TAB2 else ; TAB3 increment q ; TAB1 sort first n elements of pr ; TAB1 for i = max of 0 and q - p - 1 to min of n and 2 * q inclusive , increase x by pr [ i ] . second ; TAB1 print x ;	const int N = 2e5 + 100 ; map < long long , long long > ma , mb ; pair < long long , long long > p [ N ] ; vector < int > v [ N ] , v1 ; set < long long > s ; int main ( ) { int a , b , i = 0 , n , p = 0 , q = 0 , t , x = 0 ; pair < int , int > pr [ 1000 ] ; cin >> t ; n = t ; while ( t -- ) { cin >> a >> b ; pr [ i ] = make_pair ( a , b ) ; i ++ ; if ( a > 0 ) p ++ ; else q ++ ; } sort ( pr , pr + n ) ; for ( i = max ( 0 , q - p - 1 ) ; i <= min ( n , 2 * q ) ; i ++ ) { x += pr [ i ] . second ; } cout << x << endl ; return 0 ; }
TAB0 create new double tmaxmin = 1 < < 20 ; TAB0 create long long t1 ; TAB0 new new long long called t2 ; TAB0 create long long variable with name t0 ; TAB0 new double T ; TAB0 declare long long x1 ; TAB0 new long long x2 ; TAB0 create new long long solx1 ; TAB0 declare long long variable solx2 ; TAB1 read variables t1 , t2 , x1 , x2 and t0 from the input ; TAB1 while x1 and x2 are both greater than or equal to 0 ; TAB2 change the value of T to ( 1 . 0 * t1 * x1 + t2 * x2 ) / ( x1 + x2 ) ; TAB2 if T is less than t0 ; TAB3 decrement x1 ; TAB2 else ; TAB3 if T is less than tmaxmin ; TAB4 change the value of tmaxmin to T ; TAB4 change the value of solx2 to x2 ; TAB4 assign x1 to solx1 ; TAB3 decrement x2 by one ; TAB1 print solx1 , " " and solx2 to the output ;	double tmaxmin = 1 << 20 ; long long t1 ; long long t2 ; long long t0 ; double T ; long long x1 ; long long x2 ; long long solx1 ; long long solx2 ; int main ( ) { cin >> t1 >> t2 >> x1 >> x2 >> t0 ; while ( x1 >= 0 && x2 >= 0 ) { T = ( 1.0 * t1 * x1 + t2 * x2 ) / ( x1 + x2 ) ; if ( T < t0 ) { x1 -- ; } else { if ( T < tmaxmin ) { tmaxmin = T ; solx2 = x2 ; solx1 = x1 ; } x2 -- ; } } cout << solx1 << "   " << solx2 << endl ; }
TAB0 let len , a = int with a = arrya of length 30 ; TAB0 str = string ; TAB1 read len and str ; TAB1 for i = 0 to len exclusive , increment a [ str [ i ] - ' a ' ] ; TAB1 if len is 1 or a [ ( max element of a ) - a ] > = 2 ; TAB2 print Yes ; TAB1 else ; TAB2 print No ;	int len , a [ 30 ] ; string str ; int main ( ) { cin >> len >> str ; for ( int i = 0 ; i < len ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; if ( len == 1 || a [ max_element ( a , a + 30 ) - a ] >= 2 ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB1 a , b , s = integer ; TAB1 read a , b , s ; TAB1 d = integer = absolute value of a + absolute value of b ; TAB1 if d > s or d modulo 2 is not s modulo 2 ; TAB2 print No ; TAB1 else ; TAB2 print Yes ;	int main ( ) { int a , b , s ; cin >> a >> b >> s ; int d = abs ( a ) + abs ( b ) ; if ( d > s || d % 2 != s % 2 ) cout << " No\n " ; else cout << " Yes\n " ; }
TAB1 create string s ; TAB1 read s ; TAB1 create long long n with n = length of s ; TAB1 create long long array x with size 3 ; TAB1 for i = 1 , _b = n - 2 to i is less than or equal to _b , incrementing i ; TAB2 set bytes from x to size of x to value 0 ; TAB2 if s [ i - 1 ] is not ' . ' , increment x [ s [ i - 1 ] - ' A ' ] ; TAB2 if s [ i ] is not ' . ' , increment x [ s [ i ] - ' A ' ] ; TAB2 if s [ i + 1 ] is not ' . ' , increment x [ s [ i + 1 ] - ' A ' ] ; TAB2 if x [ 0 ] is 1 and x [ 1 ] is 1 and x [ 2 ] is 1 ; TAB3 print " Yes " print newline ; TAB1 print " No " print newline ;	int main ( ) { string s ; cin >> s ; long long n = s . length ( ) ; long long x [ 3 ] ; for ( long long i = ( 1 ) , _b = ( n - 2 ) ; i <= _b ; i ++ ) { memset ( ( x ) , 0 , sizeof ( ( x ) ) ) ; if ( s [ i - 1 ] != ' . ' ) x [ s [ i - 1 ] - ' A ' ] ++ ; if ( s [ i ] != ' . ' ) x [ s [ i ] - ' A ' ] ++ ; if ( s [ i + 1 ] != ' . ' ) x [ s [ i + 1 ] - ' A ' ] ++ ; if ( x [ 0 ] == 1 && x [ 1 ] == 1 && x [ 2 ] == 1 ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; }
TAB1 let ints n and s ; TAB1 read s and n ; TAB1 create int arrays x of size n and y of size n ; TAB1 for i = 0 to n exclusive , read x [ i ] and y [ i ] ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 for j = 0 to n - 1 exclusve ; TAB3 if x [ j ] is greater than x [ j + 1 ] ; TAB4 swap values of x [ j ] and x [ j + 1 ] ; TAB4 swap values of y [ j ] and y [ j + 1 ] ; TAB1 for i = 0 to n exclusive ; TAB2 if s is less than or equal to x [ i ] ; TAB3 print " NO " ; TAB2 add y [ i ] to s ; TAB1 print " YES " ;	int main ( ) { int n , s ; cin >> s >> n ; int x [ n ] , y [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x [ i ] >> y [ i ] ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( x [ j ] > x [ j + 1 ] ) { swap ( x [ j ] , x [ j + 1 ] ) ; swap ( y [ j ] , y [ j + 1 ] ) ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( s <= x [ i ] ) { cout << " NO " << endl ; return 0 ; } s += y [ i ] ; } cout << " YES " << endl ; return 0 ; }
TAB0 declare string array a size 105 , declare strings ts , st ; TAB0 declare integer arrays type size 105 , visit size 105 , integer N ; TAB0 declare character lucky ; TAB0 declare lower with character address now as argument , returning character ; TAB1 if now is greater than or equal to ' A ' and now is less than or equal to ' Z ' , return now - ' A ' + ' a ' from function ; TAB1 return now from function ; TAB0 declare upper with character address now as argument , returning character ; TAB1 if now is greater than or equal to ' a ' and now is less than or equal to ' z ' , return now - ' a ' + ' A ' ; TAB1 return now from function ; TAB1 read N ; TAB1 for i = 1 to N inclusive ; TAB2 read a [ i ] ; TAB2 for j = 0 to size of a [ i ] exclusive , let a [ i ] [ j ] be lower case ( a [ i ] [ j ] ) ; TAB1 read ts ; TAB1 read lucky ; TAB1 let lucky be lower case ( lucky ) ; TAB1 declare string st = ts ; TAB1 for i = 0 to size of st exclusive ; TAB2 let type [ i ] be ( st [ i ] is greater than or equal to ' a ' and st [ i ] is less than or equal to ' z ' ) ; TAB2 let st [ i ] be lower case st [ i ] ; TAB1 set bytes from visit to size of visit to value 0 ; TAB1 for i = 0 to size of st exclusive ; TAB2 for j = 1 to N inclusive ; TAB3 if size of st - i is greater than or equal to size of a [ j ] ; TAB4 if substring of st from i to size of a [ j ] is a [ j ] ; TAB5 for k = 0 to size of a [ j ] exclusive , let visit [ i + k ] be 1 ; TAB1 for i = 0 to size of ts exclusive ; TAB2 if visit [ i ] is true ; TAB3 if lower case ( ts [ i ] ) is lucky ; TAB4 if lucky is ' a ' ; TAB5 let ts [ i ] be ' b ' is type [ i ] is true , else ' B ' ; TAB4 else ; TAB5 let ts [ i ] be ' a ' if type [ i ] is true , else ' A ' ; TAB3 else ; TAB4 let ts [ i ] be lower case ( lucky ) if type [ i ] is true , else upper case ( lucky ) ; TAB1 print ts and newline ;	string a [ 105 ] , ts , st ; int type [ 105 ] , visit [ 105 ] , N ; char lucky ; char lower ( char & now ) { if ( now >= ' A ' && now <= ' Z ' ) return now - ' A ' + ' a ' ; return now ; } char upper ( char & now ) { if ( now >= ' a ' && now <= ' z ' ) return now - ' a ' + ' A ' ; return now ; } int main ( ) { cin >> N ; for ( int i = 1 ; i <= N ; ++ i ) { cin >> a [ i ] ; for ( int j = 0 ; j < a [ i ] . size ( ) ; ++ j ) a [ i ] [ j ] = lower ( a [ i ] [ j ] ) ; } cin >> ts ; cin >> lucky ; lucky = lower ( lucky ) ; string st = ts ; for ( int i = 0 ; i < st . size ( ) ; ++ i ) { type [ i ] = ( st [ i ] >= ' a ' && st [ i ] <= ' z ' ) ; st [ i ] = lower ( st [ i ] ) ; } memset ( visit , 0 , sizeof ( visit ) ) ; for ( int i = 0 ; i < st . size ( ) ; ++ i ) for ( int j = 1 ; j <= N ; ++ j ) if ( st . size ( ) - i >= a [ j ] . size ( ) ) if ( st . substr ( i , a [ j ] . size ( ) ) == a [ j ] ) for ( int k = 0 ; k < a [ j ] . size ( ) ; ++ k ) visit [ i + k ] = 1 ; for ( int i = 0 ; i < ts . size ( ) ; ++ i ) if ( visit [ i ] ) if ( lower ( ts [ i ] ) == lucky ) { if ( lucky == ' a ' ) ts [ i ] = ( type [ i ] ? ' b ' : ' B ' ) ; else ts [ i ] = ( type [ i ] ? ' a ' : ' A ' ) ; } else ts [ i ] = ( type [ i ] ? lower ( lucky ) : upper ( lucky ) ) ; cout << ts << endl ; return 0 ; }
TAB0 in the function seieve ; TAB0 empty long long function maxx with 2 long long arguments ; TAB0 empty long long function minn with 2 long long arguments ; TAB0 new constant long long mod with value 1000000007 ; TAB0 declare constant long long limits with value 1e18 ; TAB0 primes is a new array of long longs with 1000001 element initialized with 0 ; TAB1 declare long long variables t , i , j , k , n , m , o and p where j = 0 ; TAB1 read t from the input ; TAB1 create string variable s ; TAB1 read variable s from the input ; TAB1 create new vector of characters v ; TAB1 arr is an array of long longs with 200005 elements initialized with 0 ; TAB1 for i from 0 to length of s exclusive incrementing i ; TAB2 if length of v = 0 or last character of v ! = s [ i ] ; TAB3 push s [ i ] to the end of v ; TAB3 add 1 to the last element of arr ; TAB2 else ; TAB3 increase the last element of arr by 1 ; TAB1 create long long variable sm = 0 ; TAB1 in a for loop , change i from 0 to length of v - 1 exclusive incrementing i ; TAB2 if character at the position i in v is ' > ' and character at the position i + 1 in v is ' < ' ; TAB3 change arr [ i ] to 0 ; TAB3 change the value of arr [ i + 1 ] to 0 ; TAB3 change i to the sum of i and 1 ; TAB2 else ; TAB3 add arr [ i ] to sm ; TAB1 increase sm by the value of arr [ length of v - 1 ] ; TAB1 print sm ; TAB0 function seieve ; TAB1 create new long longs i and p ; TAB1 change primes [ 0 ] to 1 ; TAB1 assign 1 to primes [ 1 ] ; TAB1 increment p in a loop from 2 while p squared < = 1000000 ; TAB2 if primes [ p ] = 0 ; TAB3 in a for loop , change i from p * 2 to 1000000 inclusive increasing i by p and setting primes [ i ] to 1 on each iteration ; TAB0 long long function maxx with long long arguments a and b ; TAB1 return a if a > b or b otherwise ; TAB0 minn is a long long function with long long arguments a and b ; TAB1 return a if a < b or b otherwise ;	void seieve ( ) ; long long maxx ( long long , long long ) ; long long minn ( long long , long long ) ; const long long mod = 1000000007 ; const long long limits = ( long long ) 1e18 ; long long primes [ 1000001 ] = { 0 } ; int main ( ) { long long t , i , j = 0 , k , n , m , o , p ; cin >> t ; string s ; cin >> s ; vector < char > v ; long long arr [ 200005 ] = { 0 } ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( v . size ( ) == 0 || v . at ( v . size ( ) - 1 ) != s [ i ] ) { v . push_back ( s [ i ] ) ; arr [ v . size ( ) - 1 ] += 1 ; } else { arr [ v . size ( ) - 1 ] += 1 ; } } long long sm = 0 ; for ( i = 0 ; i < v . size ( ) - 1 ; i ++ ) { if ( v . at ( i ) == ' > ' && v . at ( i + 1 ) == ' < ' ) { arr [ i ] = 0 ; arr [ i + 1 ] = 0 ; i += 1 ; } else sm += arr [ i ] ; } sm += arr [ v . size ( ) - 1 ] ; cout << sm << endl ; return 0 ; } void seieve ( ) { long long i , p ; primes [ 0 ] = 1 ; primes [ 1 ] = 1 ; for ( p = 2 ; p * p <= 1000000 ; p ++ ) { if ( primes [ p ] == 0 ) { for ( i = p * 2 ; i <= 1000000 ; i += p ) primes [ i ] = 1 ; } } } long long maxx ( long long a , long long b ) { return ( a > b ) ? a : b ; } long long minn ( long long a , long long b ) { return ( a < b ) ? a : b ; }
TAB0 declare integers c , b , a ; TAB1 read c , b , a ; TAB1 if a is c ; TAB2 print " NO " ; TAB1 if ( ( not ( ( a - c ) % b ) or not ( ( a - c - 1 ) % b ) ) and a is not c + 1 ) ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int c , b , a ; int main ( ) { cin >> c >> b >> a ; if ( a < c ) { puts ( " NO " ) ; return 0 ; } if ( ( ! ( ( a - c ) % b ) || ! ( ( a - c - 1 ) % b ) ) && a != c + 1 ) puts ( " YES " ) ; else puts ( " NO " ) ; return 0 ; }
TAB1 create string ak ; TAB1 read ak ; TAB1 create integer sz = ak . size ( ) ; TAB1 create integers f1 = 0 , f2 = 0 , f3 = 0 , f4 = 0 , and i ; TAB1 for i = 0 to sz exclusive ; TAB2 if ak [ i ] is equal to ' A ' and ak [ i + 1 ] is equal to ' B ' and f1 is equal to 0 ; TAB3 set f1 to 1 ; TAB3 increment i ; TAB3 continue to the next loop iteration ; TAB2 if ak [ i ] is equal to ' B ' and ak [ i + 1 ] is equal to ' A ' and f1 is equal to 1 , set f2 to 1 ; TAB1 for i = 0 to sz exclusive ; TAB2 if ak [ i ] is equal to ' B ' and ak [ i + 1 ] is equal to ' A ' and f3 is equal to 0 ; TAB3 set f3 to 1 ; TAB3 increment i ; TAB3 continue to the next loop iteration ; TAB2 if ak [ i ] is equal to ' A ' and ak [ i + 1 ] is equal to ' B ' and f3 is equal to 1 , set f4 to 1 ; TAB1 if f1 is equal to 1 and f2 is equal to 1 ; TAB2 print " YES " ; TAB1 if f3 is equal to 1 and f4 is equal to 1 ; TAB2 print " YES " ; TAB1 print " NO " ;	int main ( ) { string ak ; cin >> ak ; int sz = ak . size ( ) ; int f1 = 0 , f2 = 0 , f3 = 0 , f4 = 0 , i ; for ( i = 0 ; i < sz ; i ++ ) { if ( ak [ i ] == ' A ' && ak [ i + 1 ] == ' B ' && f1 == 0 ) { f1 = 1 ; i ++ ; continue ; } if ( ak [ i ] == ' B ' && ak [ i + 1 ] == ' A ' && f1 == 1 ) { f2 = 1 ; } } for ( i = 0 ; i < sz ; i ++ ) { if ( ak [ i ] == ' B ' && ak [ i + 1 ] == ' A ' && f3 == 0 ) { f3 = 1 ; i ++ ; continue ; } if ( ak [ i ] == ' A ' && ak [ i + 1 ] == ' B ' && f3 == 1 ) { f4 = 1 ; } } if ( f1 == 1 && f2 == 1 ) { cout << " YES " << endl ; return 0 ; } if ( f3 == 1 && f4 == 1 ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB0 prime is an array of booleans with 1000001 element ; TAB0 function SieveOfEratosthenes with int argument n ; TAB1 set first sizeof ( prime ) bytes at the pointer prime to true ; TAB1 change p in a loop , incrementing by 1 , from 2 , while p squared < = n ; TAB2 if prime [ p ] = true ; TAB3 in a for loop , change i from p * p to n inclusive adding p to i , and setting prime [ i ] to false on each iteration ; TAB1 call SieveOfEratosthenes ( 1000001 ) ; TAB1 define integer variable n ; TAB1 read variable n from the input ; TAB1 in a for loop , change i from 1 to 1000001 inclusive ; TAB2 if prime [ i * n + 1 ] is true ; TAB2 else ; TAB3 print i ; TAB3 break ;	bool prime [ 1000001 ] ; void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } int main ( ) { SieveOfEratosthenes ( 1000001 ) ; int n ; cin >> n ; for ( int i = 1 ; i <= 1000001 ; i ++ ) { if ( prime [ i * n + 1 ] ) ; else { cout << i << endl ; break ; } } }
TAB0 maxn = const int with maxn = 105 ; TAB0 num = integer array of size maxn ; TAB1 s = string ; TAB1 read s ; TAB1 n = integer ; TAB1 l = integer with l = s . size ( ) ; TAB1 set all contents of num to 0 ; TAB1 zheng , fu = integer with zheng = 0 , fu = 0 ; TAB1 zuida = int with zuida = 1 ; TAB1 pos = integer ; TAB1 num [ 1 ] = 1 ; TAB1 increment zheng ; TAB1 increment zuida ; TAB1 for i = 1 to l ; TAB2 if s [ i ] is + ; TAB3 num [ increment zuida ] = 1 ; TAB3 increment zheng ; TAB2 else if s [ i ] is - ; TAB3 num [ increment zuida ] = - 1 ; TAB3 increment fu ; TAB2 else if s [ i ] is = ; TAB3 pos = i ; TAB3 break loop ; TAB1 a = string with a = s . substr ( pos + 2 ) ; TAB1 ss = stringstream , call ss on a ; TAB1 right shift ss n times ; TAB1 flag = bool with flag = false ; TAB1 for i = 1 to zuida exclusive ; TAB2 if n is zheng - fu ) ; TAB3 flag = true ; TAB3 break loop ; TAB2 while n > zheng - fu and num [ i ] > 0 and num [ i ] < n ; TAB3 increment zheng ; TAB3 increment num [ i ] ; TAB2 while ( n < zheng - fu and num [ i ] < 0 and abs ( num [ i ] ) < n ) ; TAB3 increment fu ; TAB3 decrement num [ i ] ; TAB1 if n is zheng - fu , flag = true ; TAB1 if flag ; TAB2 print Possible ; TAB2 print num [ 1 ] ; TAB2 for i = 2 to zuida exclusive ; TAB3 if num [ i ] < 0 ; TAB4 print - and - num [ i ] ; TAB3 else ; TAB4 print + and num [ i ] ; TAB2 print = ; TAB2 print n ; TAB1 else ; TAB2 print Impossible ;	const int maxn = 105 ; int num [ maxn ] ; int main ( ) { string s ; getline ( cin , s ) ; int n ; int l = s . size ( ) ; memset ( num , 0 , sizeof ( num ) ) ; int zheng = 0 , fu = 0 ; int zuida = 1 ; int pos ; num [ 1 ] = 1 ; ++ zheng ; ++ zuida ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] == ' + ' ) { num [ zuida ++ ] = 1 ; ++ zheng ; } else if ( s [ i ] == ' - ' ) { num [ zuida ++ ] = - 1 ; ++ fu ; } else if ( s [ i ] == ' = ' ) { pos = i ; break ; } } string a = s . substr ( pos + 2 ) ; stringstream ss ( a ) ; ss >> n ; bool flag = false ; for ( int i = 1 ; i < zuida ; i ++ ) { if ( n == zheng - fu ) { flag = true ; break ; } while ( n > zheng - fu && num [ i ] > 0 && num [ i ] < n ) { ++ zheng ; ++ num [ i ] ; } while ( n < zheng - fu && num [ i ] < 0 && abs ( num [ i ] ) < n ) { ++ fu ; -- num [ i ] ; } } if ( n == zheng - fu ) flag = true ; if ( flag ) { cout << " Possible " << endl ; cout << num [ 1 ] ; for ( int i = 2 ; i < zuida ; i ++ ) { if ( num [ i ] < 0 ) cout << "  -  " << - num [ i ] ; else cout << "  +  " << num [ i ] ; } cout << "  =  " ; cout << n << endl ; } else cout << " Impossible " << endl ; return 0 ; }
TAB0 N , INF = const int with N = 1e3 + 10 and INF = 1e9 + 7 ; TAB0 rate = int , int pair array of size N ; TAB0 n = int ; TAB0 in function cmp taking int , int pair a , int , int pair b and returnign bool ; TAB1 if a . first is b . first return a . second < b . second ; TAB1 return a . first > b . first ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 a , b , c , d = int ; TAB2 read a then b then c then d ; TAB2 increment a by b ; TAB2 increment a by c ; TAB2 increment a by d ; TAB2 set rate [ i ] to { a , i } ; TAB1 sort rate from position 0 to n using cmp ; TAB1 for i = 0 to n ; TAB2 of rate [ i ] . second is 0 ; TAB3 print i + 1 ;	const int N = 1e3 + 10 , INF = 1e9 + 7 ; pair < int , int > rate [ N ] ; int n ; bool cmp ( pair < int , int > a , pair < int , int > b ) { if ( a . first == b . first ) return a . second < b . second ; return a . first > b . first ; } int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { int a , b , c , d ; cin >> a >> b >> c >> d ; a += b ; a += c ; a += d ; rate [ i ] = { a , i } ; } sort ( rate , rate + n , cmp ) ; for ( int i = 0 ; i < n ; i ++ ) if ( rate [ i ] . second == 0 ) { cout << i + 1 << ' \n ' ; return 0 ; } return 0 ; }
TAB0 create string s ; TAB0 ok is a boolean function with int arguments i and j ; TAB1 return false if j - i > 1 and s [ i ] = ' 0 ' ; TAB1 return false if j - i is greater than 8 ; TAB1 declare integer variable x with value 0 ; TAB1 for k from i to j exclusive , change x to x * 10 + s [ k ] - ' 0 ' ; TAB1 return x < = 1000000 ; TAB0 function calc with int arguments i and j that returns integer ; TAB1 declare new integer variable x with value 0 ; TAB1 in a for loop , change k from i to j exclusive , setting x to x * 10 + s [ k ] - ' 0 ' on each loop ; TAB1 return x ; TAB1 read variable s from the input ; TAB1 declare new integer called ans = - 1 ; TAB1 for integer i = 1 to length of s exclusive ; TAB2 start for loop from j = i + 1 to length of s exclusive incrementing j ; TAB3 create new integer sum with value 0 ; TAB3 if ok of 0 and i returned true ; TAB4 add the result of calc ( 0 , i ) to sum ; TAB3 else ; TAB4 go to the start of the loop ; TAB3 if the result of ok ( i , j ) is true ; TAB4 increase sum by the result of calc ( i , j ) ; TAB3 else ; TAB4 go to the start of the loop ; TAB3 if ok ( j , length of s ) is true ; TAB4 increase sum by the result of calc ( j , length of s ) ; TAB3 else ; TAB4 skip the rest of the loop ; TAB3 assign the new value = max of ans and sum to ans ; TAB1 print ans and " \ n " to the standard output ;	string s ; bool ok ( int i , int j ) { if ( j - i > 1 && s [ i ] == ' 0 ' ) return false ; if ( j - i > 8 ) return false ; int x = 0 ; for ( int k = i ; k < j ; k ++ ) x = x * 10 + s [ k ] - ' 0 ' ; return x <= 1000000 ; } int calc ( int i , int j ) { int x = 0 ; for ( int k = i ; k < j ; k ++ ) x = x * 10 + s [ k ] - ' 0 ' ; return x ; } int main ( ) { cin >> s ; int ans = - 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { int sum = 0 ; if ( ok ( 0 , i ) ) sum += calc ( 0 , i ) ; else continue ; if ( ok ( i , j ) ) sum += calc ( i , j ) ; else continue ; if ( ok ( j , s . size ( ) ) ) sum += calc ( j , s . size ( ) ) ; else continue ; ans = max ( ans , sum ) ; } cout << ans << " \n " ; return 0 ; }
TAB0 the constant integer value of MAX = 100005 ; TAB0 create a vector of integers by name f and has values MAX , - 1 ; TAB0 create a vector of integers by name fr and has values MAX , - 1 ; TAB0 create a vector of boolean values by name valid and has values MAX , 1 ; TAB0 the boolean value of ans = 1 ; TAB0 let n be a integer ; TAB0 the integer value of lastValid = 1 ; TAB1 read n ; TAB1 if n equals 1 ; TAB2 print 1 and newline ; TAB1 else do the following ; TAB2 if n & 1 is true ; TAB3 f [ n / 2 + 1 ] is equal to n / 2 + 1 ; TAB3 valid [ n / 2 + 1 ] is equal to 0 ; TAB2 f [ 1 ] is equal to 2 , f [ n ] is equal to n - 1 ; TAB2 fr [ 2 ] is equal to 1 , fr [ n - 1 ] is equal to n ; TAB2 valid [ 2 ] is equal to valid [ n - 1 ] is equal to 0 ; TAB2 for integer i = 2 to n / 2 inclusive , increment i by 1 ; TAB3 let x , y be integers with x = f [ i ] , y = fr [ i ] ; TAB3 if x is not equal to - 1 and y equals - 1 ; TAB4 fr [ i ] is equal to n + 1 - x ; TAB4 f [ n + 1 - x ] is equal to i ; TAB4 valid [ i ] is equal to 0 ; TAB3 else if y is not equal to - 1 and x equals - 1 ; TAB4 f [ i ] is equal to n + 1 - y ; TAB4 valid [ n + 1 - y ] is equal to 0 ; TAB4 fr [ n + 1 - y ] is equal to i ; TAB3 if f [ i ] is equal to - 1 ; TAB4 the boolean value update = 1 ; TAB4 for integer j = lastValid to n inclusive ; TAB5 if valid [ j ] is true ; TAB6 if i equals j ; TAB7 update is equal to 0 ; TAB7 proceed to next ; TAB6 f [ i ] is equal to j ; TAB6 fr [ j ] is equal to i ; TAB6 valid [ j ] is equal to 0 ; TAB6 if update is true , lastValid is equal to j ; TAB6 stop ; TAB3 f [ n + 1 - i ] is equal to n + 1 - f [ i ] ; TAB3 fr [ f [ n + 1 - i ] ] is equal to n + 1 - i ; TAB3 valid [ n + 1 - f [ i ] ] is equal to 0 ; TAB2 for integer i = 1 to n and ans inclusive , increment i by 1 ; TAB3 if f [ f [ i ] ] is not equal to n + 1 - i , ans is equal to 0 ; TAB2 if ans equals 0 ; TAB3 print - 1 and newline ; TAB2 else do the following ; TAB3 for i = 0 to n exclusive , print f [ i + 1 ] , if i + 1 is less than n , print space else print newline ;	const int MAX = 100005 ; vector < int > f ( MAX , - 1 ) ; vector < int > fr ( MAX , - 1 ) ; vector < bool > valid ( MAX , 1 ) ; bool ans = 1 ; int n ; int lastValid = 1 ; int main ( ) { cin >> n ; if ( n == 1 ) { cout << " 1\n " ; } else { if ( n & 1 ) { f [ n / 2 + 1 ] = n / 2 + 1 ; valid [ n / 2 + 1 ] = 0 ; } f [ 1 ] = 2 , f [ n ] = n - 1 ; fr [ 2 ] = 1 , fr [ n - 1 ] = n ; valid [ 2 ] = valid [ n - 1 ] = 0 ; for ( int i = 2 ; i <= n / 2 ; ++ i ) { int x = f [ i ] , y = fr [ i ] ; if ( x != - 1 && y == - 1 ) { fr [ i ] = n + 1 - x ; f [ n + 1 - x ] = i ; valid [ i ] = 0 ; } else if ( y != - 1 && x == - 1 ) { f [ i ] = n + 1 - y ; valid [ n + 1 - y ] = 0 ; fr [ n + 1 - y ] = i ; } if ( f [ i ] == - 1 ) { bool update = 1 ; for ( int j = lastValid ; j <= n ; ++ j ) { if ( valid [ j ] ) { if ( i == j ) { update = 0 ; continue ; } f [ i ] = j ; fr [ j ] = i ; valid [ j ] = 0 ; if ( update ) { lastValid = j ; } break ; } } } f [ n + 1 - i ] = n + 1 - f [ i ] ; fr [ f [ n + 1 - i ] ] = n + 1 - i ; valid [ n + 1 - f [ i ] ] = 0 ; } for ( int i = 1 ; i <= n && ans ; ++ i ) { if ( f [ f [ i ] ] != n + 1 - i ) { ans = 0 ; } } if ( ans == 0 ) { cout << " -1\n " ; } else { for ( int i = 0 ; i < n ; ++ i ) { cout << f [ i + 1 ] << ( i + 1 < n ? "   " : " \n " ) ; } } } }
TAB0 let x , y , days , work be integers ; TAB0 asphaltx = array of boolean values of length 100 , asphalty = array of boolean values of length 100 ; TAB0 workdays = array of integers of length 100000 ; TAB1 the value of days is equal to 1 ; TAB1 let a be a integer ; TAB1 read a ; TAB1 for A = 0 to a * a exclusive ; TAB2 read x , y ; TAB2 if asphaltx [ x ] is equal to false and asphalty [ y ] is equal to false ; TAB3 set asphaltx [ x ] to true ; TAB3 set asphalty [ y ] to true ; TAB3 workdays [ work ] is equal to days ; TAB3 increment work by 1 ; TAB2 increment days by 1 ; TAB1 for A = 0 to work exclusive ; TAB2 if A is equal to work - 1 ; TAB3 print workdays [ A ] and newline ; TAB2 else do the following ; TAB3 print workdays [ A ] and space ;	int x , y , days , work ; bool asphaltx [ 100 ] , asphalty [ 100 ] ; int workdays [ 100000 ] ; int main ( ) { days = 1 ; int a ; cin >> a ; for ( int A = 0 ; A < a * a ; A ++ ) { cin >> x >> y ; if ( asphaltx [ x ] == false && asphalty [ y ] == false ) { asphaltx [ x ] = true ; asphalty [ y ] = true ; workdays [ work ] = days ; work ++ ; } days ++ ; } for ( int A = 0 ; A < work ; A ++ ) { if ( A == work - 1 ) cout << workdays [ A ] << endl ; else cout << workdays [ A ] << "   " ; } }
TAB0 declare constant double PI = acos ( - 1 . 0 ) ; TAB0 declare constant double eps = 1e - 6 ; TAB0 create const int INF = 0x3f3f3f3f ; TAB0 gcd is a int function with int arguments a and b ; TAB1 return b if a % b = 0 , or gcd of b and a % b ; TAB0 create int n ; TAB0 declare const int maxn = 60 ; TAB1 declare string variables a and b ; TAB1 read a and b ; TAB1 declare int num = 0 ; TAB1 declare an array of characters aa with size 10 ; TAB1 create int j = 0 ; TAB1 declare integer variable len1 = length of a and len2 = length of b ; TAB1 if len1 ! = len2 ; TAB2 print " NO " ; TAB1 else { ; TAB2 for integer i = 0 to len1 exclusive ; TAB3 if a [ i ] ! = b [ i ] ; TAB4 increment j and set aa [ j ] to a [ i ] ; TAB4 increment j and set aa [ j ] to b [ i ] ; TAB4 increment num ; TAB3 if num is greater than 2 , break the loop ; TAB2 if num = 2 and aa [ 0 ] = aa [ 3 ] and aa [ 1 ] = aa [ 2 ] ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ;	const double PI = acos ( - 1.0 ) ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; int gcd ( int a , int b ) { return a % b == 0 ? b : gcd ( b , a % b ) ; } int n ; const int maxn = 60 ; int main ( ) { string a , b ; cin >> a >> b ; int num = 0 ; char aa [ 10 ] ; int j = 0 ; int len1 = a . size ( ) , len2 = b . size ( ) ; if ( len1 != len2 ) cout << " NO " << endl ; else { for ( int i = 0 ; i < len1 ; i ++ ) { if ( a [ i ] != b [ i ] ) { aa [ j ++ ] = a [ i ] ; aa [ j ++ ] = b [ i ] ; num ++ ; } if ( num > 2 ) break ; } if ( num == 2 && ( aa [ 0 ] == aa [ 3 ] && aa [ 1 ] == aa [ 2 ] ) ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB0 declare integer variables x and y ; TAB0 declare bool arrays xasphalt and yasphalt with size 69 ; TAB0 days and wrkdsz are integers with days = 1 , and workdays is an array of integers with 6969 elements ; TAB1 create int a ; TAB1 read input to a ; TAB1 for integer A = 0 to a * a exclusive ; TAB2 read input to x and y ; TAB2 if xasphalt [ x ] = false and yasphalt [ y ] = false ; TAB3 change xasphalt [ x ] to true ; TAB3 change yasphalt [ y ] to true ; TAB3 change workdays [ wrkdsz ] to days ; TAB3 increment wrkdsz by one ; TAB2 increment days by one ; TAB1 for A from 0 to wrkdsz exclusive ; TAB2 if A is equal to wrkdsz - 1 ; TAB3 print workdays [ A ] and " \ n " ; TAB2 else ; TAB3 print workdays [ A ] and " " ;	int x , y ; bool xasphalt [ 69 ] , yasphalt [ 69 ] ; int days = 1 , workdays [ 6969 ] , wrkdsz ; int main ( ) { int a ; cin >> a ; for ( int A = 0 ; A < a * a ; A ++ ) { cin >> x >> y ; if ( xasphalt [ x ] == false && yasphalt [ y ] == false ) { xasphalt [ x ] = true ; yasphalt [ y ] = true ; workdays [ wrkdsz ] = days ; wrkdsz ++ ; } days ++ ; } for ( int A = 0 ; A < wrkdsz ; A ++ ) { if ( A == wrkdsz - 1 ) cout << workdays [ A ] << " \n " ; else cout << workdays [ A ] << "   " ; } }
TAB0 create new constant long integer mod with value 1000000007 ; TAB0 declare strings s and t ; TAB0 f is a new 2d array of integers with size 5001 by 5001 ; TAB1 read from the input to s and t ; TAB1 define new integer called a ; TAB1 declare integer variable with name sum = 0 ; TAB1 start the loop for o from a - 1 to 0 inclusive decrementing by 1 ; TAB2 for i = b - 1 to 0 inclusive counting down ; TAB3 set f [ o ] [ i ] to f [ o ] [ i + 1 ] + ( s [ o ] = t [ i ] ) * ( f [ o + 1 ] [ i + 1 ] + 1 ) ; TAB3 if f [ o ] [ i ] > = mod , change the value of f [ o ] [ i ] to f [ o ] [ i ] modulo mod ; TAB2 change sum to the sum of sum and f [ o ] [ 0 ] ; TAB2 if sum > = mod , change sum to the remainder of sum divided by mod ; TAB1 print sum ;	const long int mod = 1000000007 ; string s , t ; int f [ 5001 ] [ 5001 ] ; int main ( ) { cin >> s >> t ; int a = s . size ( ) , b = t . size ( ) ; int sum = 0 ; for ( int o = a - 1 ; o >= 0 ; o -- ) { for ( int i = b - 1 ; i >= 0 ; i -- ) { f [ o ] [ i ] = f [ o ] [ i + 1 ] + ( s [ o ] == t [ i ] ) * ( f [ o + 1 ] [ i + 1 ] + 1 ) ; if ( f [ o ] [ i ] >= mod ) f [ o ] [ i ] %= mod ; } sum += f [ o ] [ 0 ] ; if ( sum >= mod ) sum %= mod ; } cout << sum << endl ; return 0 ; }
TAB0 declare integer arrays spf size integer casted 1 . 5e7 + 9 , cnt size integer casted 1 . 5e7 + 9 ; TAB0 declare sieve with long long n as argument , returning void ; TAB1 let spf [ 0 ] be spf [ 1 ] be 1 ; TAB1 for i = 2 to n inclusive ; TAB2 if spf [ i ] is 0 ; TAB3 for j = i to n inclusive , incrementing j by i ; TAB4 if spf [ j ] is 0 , let spf [ j ] be i ; TAB1 fun sieve with 1 . 5e7 as argument ; TAB1 declare integer n ; TAB1 read n ; TAB1 declare integer vector a size n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 declare integer g = a [ 0 ] ; TAB1 for i = 1 to n exclusive , let g be result of run __gcd ( g , a [ i ] ) ; TAB1 declare ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 declare integer num = a [ i ] / g ; TAB2 while num is not 1 ; TAB3 declare integer f = spf [ num ; TAB3 while num % f is 0 , let num be num / f ; TAB3 increment cnt [ f ] ; TAB3 let ans be maximum of ans and cnt [ f ] ; TAB1 let ans be n - ans ; TAB1 if ans is n ; TAB2 print - 1 and newline ; TAB1 else ; TAB2 print ans and newline ;	int spf [ ( int ) 1.5e7 + 9 ] , cnt [ ( int ) 1.5e7 + 9 ] ; void sieve ( long long n ) { spf [ 0 ] = spf [ 1 ] = 1 ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( spf [ i ] == 0 ) { for ( long long j = i ; j <= n ; j += i ) { if ( spf [ j ] == 0 ) spf [ j ] = i ; } } } } int main ( ) { sieve ( 1.5e7 ) ; int n ; cin >> n ; vector < int > a ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int g = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) g = __gcd ( g , a [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] / g ; while ( num != 1 ) { int f = spf [ num ] ; while ( num % f == 0 ) num /= f ; ++ cnt [ f ] ; ans = max ( ans , cnt [ f ] ) ; } } ans = n - ans ; if ( ans == n ) cout << - 1 << endl ; else cout << ans << endl ; return 0 ; }
TAB0 create constant integer inf = 0x3f3f3f3f ; TAB0 create constant integer maxn = 110 ; TAB0 in the function max which takes a and b integers and returns their max value ; TAB1 return a if a > b else return b ; TAB0 in the function min which takes two integers a and b and returns a integer ; TAB1 return b if a > b else return a ; TAB0 create an integer array a of size maxn ; TAB1 i , n = integers ; TAB1 while entered value of n is valid ; TAB2 read n values into the array a ; TAB2 l = integer ; TAB2 maxi = integer with value 1 ; TAB2 for l = 0 to n - 1 exclusive ; TAB3 create integer pos = l ; TAB3 while l < n - 1 and a [ l ] + 1 = a [ l + 1 ] increment l ; TAB3 if l - pos + 1 > maxi then set maxi = l - pos + 1 ; TAB2 create integer cnt1 = 1 ; TAB2 if a [ 0 ] is 1 ; TAB3 for i = 0 to maxi - 1 exclusive ; TAB4 if a [ i ] + 1 is not equal to a [ i + 1 ] ; TAB5 then break ; TAB4 else do the following ; TAB5 add 1 to cnt1 ; TAB2 create integer cnt2 = 1 ; TAB2 if a [ n - 1 ] is equal to 1000 ; TAB3 for i = 0 to maxi - 1 exclusive ; TAB4 if a [ n - 1 - i ] - 1 is not equal to a [ n - 1 - i - 1 ] ; TAB5 break ; TAB4 else do the following ; TAB5 add 1 to cnt2 ; TAB2 if cnt1 = maxi or cnt2 = maxi ; TAB3 print maxi - 1 and new line ; TAB2 else do the following ; TAB3 print maxi - 2 ;	const int inf = 0x3f3f3f3f ; const int maxn = 110 ; int max ( int a , int b ) { return a > b ? a : b ; } int min ( int a , int b ) { return a > b ? b : a ; } int a [ maxn ] ; int main ( ) { int i , n ; while ( cin >> n ) { for ( i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int l ; int maxi = 1 ; for ( l = 0 ; l < n - 1 ; l ++ ) { int pos = l ; while ( l < n - 1 && a [ l ] + 1 == a [ l + 1 ] ) { l ++ ; } if ( l - pos + 1 > maxi ) { maxi = l - pos + 1 ; } } int cnt1 = 1 ; if ( a [ 0 ] == 1 ) { for ( i = 0 ; i < maxi - 1 ; i ++ ) { if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { break ; } else cnt1 ++ ; } } int cnt2 = 1 ; if ( a [ n - 1 ] == 1000 ) { for ( i = 0 ; i < maxi - 1 ; i ++ ) { if ( ( a [ n - 1 - i ] - 1 ) != a [ n - 1 - i - 1 ] ) { break ; } else cnt2 ++ ; } } if ( cnt1 == maxi || cnt2 == maxi ) { cout << maxi - 1 << endl ; } else cout << maxi - 2 << endl ; } return 0 ; }
TAB0 a = array of integers of length 102000 ; TAB0 b = array of integers of length 102000 ; TAB0 mymap = map from int to int ; TAB1 let n be a integer ; TAB1 read n ; TAB1 let m be a integer with m = - 1 ; TAB1 for i = 1 to n inclusive ; TAB2 read a [ i ] ; TAB2 read mymap [ a [ i ] ] by 1 ; TAB2 m is equal to maximum of m and mymap [ a [ i ] ] ; TAB1 print n - m and newline ;	int a [ 102000 ] ; int b [ 102000 ] ; map < int , int > mymap ; int main ( ) { int n ; cin >> n ; int m = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; mymap [ a [ i ] ] ++ ; m = max ( m , mymap [ a [ i ] ] ) ; } cout << n - m << endl ; return 0 ; }
TAB0 let b be integer array with size 1000000 ; TAB1 declare integers n and k ; TAB1 read n and k ; TAB1 declare vector of integers variable v ; TAB1 declare int variable cnt = 0 ; TAB1 for integer i = 0 to n exclusive ; TAB2 declare int x ; TAB2 read x ; TAB2 push x into v ; TAB1 sort v ; TAB1 if k = 1 ; TAB2 print n ; TAB1 for i = 0 to length of v exclusive ; TAB2 declare integer variable y = v [ i ] ; TAB2 assign 1 to b [ i ] ; TAB2 if y % k is not 0 , go to the start of the loop ; TAB2 declare integer x = y / k ; TAB2 declare integer variable p = lower_bound ( v . begin ( ) , v . end ( ) , x ) - v . begin ( ) ; TAB2 if v [ p ] is equal to x ; TAB3 assign b [ p ] + 1 to b [ i ] ; TAB3 assign 0 to b [ p ] ; TAB1 declare int variable ans = 0 ; TAB1 loop i from 0 to n exclusive , increase ans by ( b [ i ] + 1 ) / 2 ; TAB1 print ans ;	int b [ 1000000 ] ; int main ( ) { int n , k ; cin >> n >> k ; vector < int > v ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; v . push_back ( x ) ; } sort ( v . begin ( ) , v . end ( ) ) ; if ( k == 1 ) { cout << n << endl ; return 0 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int y = v [ i ] ; b [ i ] = 1 ; if ( y % k ) continue ; int x = y / k ; int p = lower_bound ( v . begin ( ) , v . end ( ) , x ) - v . begin ( ) ; if ( v [ p ] == x ) { b [ i ] = b [ p ] + 1 ; b [ p ] = 0 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( b [ i ] + 1 ) / 2 ; } cout << ans << endl ; return 0 ; }
TAB1 declare new integers n and t ; TAB1 loop , reading n and t from the input ; TAB2 ans is a new integer with value 100010 ; TAB2 for i = 0 to t exclusive incrementing i ; TAB3 create integers l and r ; TAB3 read l and r ; TAB3 assign the new value = min of ans and r - l + 1 to ans ; TAB2 print ans ; TAB2 for integer i = 0 to n exclusive ; TAB3 if i is true , print " " ; TAB3 print i % ans to the standard output ; TAB2 print a new line ;	int main ( ) { int n , t ; while ( cin >> n >> t ) { int ans = 100010 ; for ( int i = 0 ; i < t ; i ++ ) { int l , r ; cin >> l >> r ; ans = min ( ans , r - l + 1 ) ; } cout << ans << endl ; for ( int i = 0 ; i < n ; i ++ ) { if ( i ) cout << "   " ; cout << i % ans ; } cout << endl ; } return 0 ; }
TAB1 n = int ; TAB1 a = int ; TAB1 b = int vector ; TAB1 c = int vector ; TAB1 jawab = int vector ; TAB1 read n ; TAB1 for i = 0 to n ; TAB2 read a ; TAB2 append a to b ; TAB2 append a to c ; TAB1 sort c using greater of type int ; TAB1 for i = 0 to n ; TAB2 for j = 0 to n ; TAB3 if b [ i ] is c [ j ] and i is n - 1 ; TAB4 print j + 1 ; TAB4 break ; TAB3 else if b [ i ] is c [ j ] ; TAB4 print j + 1 then " " ; TAB4 break ;	int main ( ) { int n ; int a ; vector < int > b ; vector < int > c ; vector < int > jawab ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; b . push_back ( a ) ; c . push_back ( a ) ; } sort ( c . begin ( ) , c . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ i ] == c [ j ] && i == n - 1 ) { cout << j + 1 << " \n " ; break ; } else if ( b [ i ] == c [ j ] ) { cout << j + 1 << "   " ; break ; } } } }
TAB0 maxn = 1000005 ; TAB0 Next = vector of long long ; TAB0 function init ( no args , no return value ) ; TAB1 t = long long ; TAB1 Q = queue of long long ; TAB1 push 0 into Q ; TAB1 while Q is not empty ; TAB2 t = first item of Q ; TAB2 pop first item of Q ; TAB2 if t > 10 ^ 11 continue ; TAB2 add t at end of Next ; TAB2 push t * 10 + 4 into Q ; TAB2 push t * 10 + 7 into Q ; TAB1 sort Next ; TAB0 function bisearch_L ( get long long val , return int ) ; TAB1 L = 0 , R = size of Next - 1 , mid = int , res = size of Next - 1 ; TAB1 while L < = R ; TAB2 mid = ( L + R ) / 2 ; TAB2 if Next [ mid ] < = val ; TAB3 res = mid ; TAB3 L = mid + 1 ; TAB2 else ; TAB3 R = mid - 1 ; TAB1 return res ; TAB0 function bisearch_R ( get long long val , return int ) ; TAB1 L = 0 , R = size of Next - 1 , mid = int , res = 0 ; TAB1 while L < = R ; TAB2 mid = ( L + R ) / 2 ; TAB2 if Next [ mid ] > = val ; TAB3 res = mid ; TAB3 R = mid - 1 ; TAB2 else ; TAB3 L = mid + 1 ; TAB1 return res ; TAB0 function f ( get long long L and R , return long long ) ; TAB1 res = 0 ; TAB1 posL = bisearch_R ( L ) ; TAB1 posR = bisearch_R ( R ) ; TAB1 posRL = bisearch_L ( R ) ; TAB1 if Next [ posL ] > = R return ( R - L + 1 ) * Next [ posL ] ; TAB1 add ( Next [ posL ] - L + 1 ) * Next [ posL ] to res ; TAB1 add ( R - Next [ posRL ] ) * Next [ posR ] to res ; TAB1 for i = posL to posRL exclusive add ( Next [ i + 1 ] - Next [ i ] ) * Next [ i + 1 ] to res ; TAB1 return res ; TAB1 L , R = long long ; TAB1 init ( ) ; TAB1 while read L and R print f ( L , R ) ;	const int maxn = 1e6 + 5 ; vector < long long > Next ; void init ( ) { long long t ; queue < long long > Q ; Q . push ( 0 ) ; while ( ! Q . empty ( ) ) { t = Q . front ( ) ; Q . pop ( ) ; if ( t > 1e11 ) continue ; Next . push_back ( t ) ; Q . push ( t * 10 + 4 ) ; Q . push ( t * 10 + 7 ) ; } sort ( Next . begin ( ) , Next . end ( ) ) ; } int bisearch_L ( long long val ) { int L = 0 , R = Next . size ( ) - 1 , mid , res = Next . size ( ) - 1 ; while ( L <= R ) { mid = ( L + R ) / 2 ; if ( Next [ mid ] <= val ) { res = mid ; L = mid + 1 ; } else R = mid - 1 ; } return res ; } int bisearch_R ( long long val ) { int L = 0 , R = Next . size ( ) - 1 , mid , res = 0 ; while ( L <= R ) { mid = ( L + R ) / 2 ; if ( Next [ mid ] >= val ) { res = mid ; R = mid - 1 ; } else { L = mid + 1 ; } } return res ; } long long f ( long long L , long long R ) { long long res = 0 ; int posL = bisearch_R ( L ) ; int posR = bisearch_R ( R ) ; int posRL = bisearch_L ( R ) ; if ( Next [ posL ] >= R ) { return ( long long ) ( R - L + 1 ) * Next [ posL ] ; } res += ( Next [ posL ] - L + 1 ) * Next [ posL ] ; res += ( R - Next [ posRL ] ) * Next [ posR ] ; for ( int i = posL ; i < posRL ; ++ i ) { res += ( Next [ i + 1 ] - Next [ i ] ) * Next [ i + 1 ] ; } return res ; } int main ( ) { long long L , R ; init ( ) ; while ( cin >> L >> R ) cout << f ( L , R ) << endl ; return 0 ; }
TAB1 define long long ints x1 , y1 , x2 and y2 ; TAB1 create ints n and ans where ans = 0 ; TAB1 read user input to x1 , y1 , x2 , y2 and n ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 declare new long long int variables a , b and c ; TAB2 read a , b and c from the input ; TAB2 if a * x1 + b * y1 + c < 0 and a * x2 + b * y2 + c > 0 , increment ans ; TAB2 increment ans if a * x1 + b * y1 + c > 0 and a * x2 + b * y2 + c < 0 ; TAB1 print ans to the standard output ;	int main ( ) { long long int x1 , y1 , x2 , y2 ; int n , ans = 0 ; cin >> x1 >> y1 >> x2 >> y2 >> n ; for ( int i = 0 ; i < n ; i ++ ) { long long int a , b , c ; cin >> a >> b >> c ; if ( a * x1 + b * y1 + c < 0 && a * x2 + b * y2 + c > 0 ) ans ++ ; if ( a * x1 + b * y1 + c > 0 && a * x2 + b * y2 + c < 0 ) ans ++ ; } cout << ans << endl ; }
TAB1 n , m , i , l , c = integers with c = 0 ; TAB1 read n , m ; TAB1 a = integer array of size n ; TAB1 for i = 0 to n exclusive ; TAB2 read a [ i ] ; TAB2 if ( a [ i ] < = m ) ; TAB3 l = i ; TAB3 a [ i ] = 0 ; TAB2 else ; TAB3 a [ i ] = a [ i ] - m ; TAB3 if ( a [ i ] < 0 ) , a [ i ] = 0 ; TAB1 i = 0 ; TAB1 while ( c < n ) ; TAB2 for i = 0 to n exclusive ; TAB3 if ( a [ i ] is 0 ) ; TAB4 increment c ; TAB3 else if ( a [ i ] < = m ) ; TAB4 l = i ; TAB4 a [ i ] = 0 ; TAB4 c = 0 ; TAB3 else ; TAB4 a [ i ] = a [ i ] - m ; TAB4 if ( a [ i ] < 0 ) , a [ i ] = 0 ; TAB4 c = 0 ; TAB4 l = i ; TAB1 increment l ; TAB1 print l ;	int main ( ) { int n , m , i , l , c = 0 ; cin >> n >> m ; int a [ n ] ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; if ( a [ i ] <= m ) { l = i ; a [ i ] = 0 ; } else { a [ i ] -= m ; if ( a [ i ] < 0 ) a [ i ] = 0 ; } } i = 0 ; while ( c < n ) { for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) c ++ ; else if ( a [ i ] <= m ) { l = i ; a [ i ] = 0 ; c = 0 ; } else { a [ i ] -= m ; if ( a [ i ] < 0 ) a [ i ] = 0 ; c = 0 ; l = i ; } } } l ++ ; cout << l << endl ; }
TAB0 create a map from strings to integers called ans ; TAB1 declare integers n and m ; TAB1 create double kk ; TAB1 read n , m and kk ; TAB1 declare integer variable k = kk * 100 . 0 + 0 . 5 casted to integer ; TAB1 loop i from 0 to n exclusive ; TAB2 declare string variable s ; TAB2 declare int variable x ; TAB2 read s and x ; TAB2 skip the rest of the loop if x * k is less than 10000 ; TAB2 set ans [ s ] to k * x / 100 ; TAB1 loop i from 0 to m exclusive ; TAB2 declare string s ; TAB2 read input to s ; TAB2 if ans is empty , set ans [ s ] to 0 ; TAB1 print length of ans ; TAB1 create new map iterator it and move it through ans , printing it - > first , " " and it - > second on each iteration ;	map < string , int > ans ; int main ( ) { int n , m ; double kk ; cin >> n >> m >> kk ; int k = ( int ) ( kk * 100.0 + 0.5 ) ; for ( int i = 0 ; i < n ; i ++ ) { string s ; int x ; cin >> s >> x ; if ( x * k < 10000 ) continue ; ans [ s ] = k * x / 100 ; } for ( int i = 0 ; i < m ; i ++ ) { string s ; cin >> s ; if ( ans . count ( s ) == 0 ) { ans [ s ] = 0 ; } } cout << ans . size ( ) << endl ; for ( map < string , int > :: iterator it = ans . begin ( ) ; it != ans . end ( ) ; it ++ ) { cout << it -> first << "   " << it -> second << endl ; } return 0 ; }
TAB1 declare integers a , b , d , k ; TAB1 declare c as character ; TAB1 read a , c , b ; TAB1 let k be a ; TAB1 let d be ( ( k % 10 ) * 10 ) ; TAB1 let k be k / 10 ; TAB1 increment d by k ; TAB1 if b is less than d and d is less than 60 ; TAB2 if a is greater than 9 and d is greater than 9 ; TAB3 print a , " : " , d , newline ; TAB2 else if a is less than 10 and d is greater than 9 ; TAB3 print " 0 " , a , " : " , d , newline ; TAB2 else if a is greater than 9 and d is less than 10 ; TAB3 print a , " : 0 " , d , newline ; TAB2 else ; TAB3 print " 0 " , a , " : 0 " , d , newline ; TAB1 else ; TAB2 if a is less than 23 ; TAB2 mark jump point Loop ; TAB3 increment a ; TAB3 let k be a ; TAB3 let d be ( ( k % 10 ) * 10 ) ; TAB3 let k be k / 10 ; TAB3 incremend d by k ; TAB3 if d is less than 60 and d is greater than 9 ; TAB4 if a is greater than 9 ; TAB5 print a , " : " , d , newline ; TAB4 else ; TAB5 print " 0 " , a , " : " , d , newline ; TAB3 else if d is less than 60 and d is less than 10 ; TAB4 if a is greater than 9 ; TAB5 print a , " : 0 " , d , newline ; TAB4 else ; TAB5 print " 0 " , a , " : 0 " , d , newline ; TAB3 else ; TAB4 go to jump point Loop ; TAB2 else ; TAB3 print " 00 : 00 \ n " ;	int main ( ) { int a , b , d , k ; char c ; cin >> a >> c >> b ; k = a ; d = ( ( k % 10 ) * 10 ) ; k = k / 10 ; d += k ; if ( b < d && d < 60 ) { if ( a > 9 && d > 9 ) cout << a << " : " << d << endl ; else if ( a < 10 && d > 9 ) cout << " 0 " << a << " : " << d << endl ; else if ( a > 9 && d < 10 ) cout << a << " :0 " << d << endl ; else cout << " 0 " << a << " :0 " << d << endl ; } else { if ( a < 23 ) { Loop : a ++ ; k = a ; d = ( ( k % 10 ) * 10 ) ; k = k / 10 ; d += k ; if ( d < 60 && d > 9 ) { if ( a > 9 ) { cout << a << " : " << d << endl ; } else { cout << " 0 " << a << " : " << d << endl ; } } else if ( d < 60 && d < 10 ) { if ( a > 9 ) { cout << a << " :0 " << d << endl ; } else { cout << " 0 " << a << " :0 " << d << endl ; } } else goto Loop ; } else cout << " 00:00\n " ; } return 0 ; }
TAB1 create long a , b , c , d , e , f ; TAB1 read a , b , c , d , e , f ; TAB1 set num1 to a * c * e ; TAB1 assign b * d * f to num2 ; TAB1 if num1 = 0 and num2 = = ; TAB2 if c = 0 and d > 0 ; TAB3 print Ron ; TAB2 else if a * c = 0 and b * d > 0 ; TAB3 print Ron ; TAB2 else ; TAB3 print Hermione ; TAB1 else if num2 > num1 ; TAB2 print Ron ; TAB1 else ; TAB2 print Hermione and a newline ;	int main ( ) { long a , b , c , d , e , f ; cin >> a >> b >> c >> d >> e >> f ; long num1 = a * c * e ; long num2 = b * d * f ; if ( num1 == 0 && num2 == 0 ) { if ( c == 0 && d > 0 ) cout << " Ron " << endl ; else if ( ( a * c == 0 ) && ( b * d > 0 ) ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; } else if ( num2 > num1 ) cout << " Ron " << endl ; else cout << " Hermione " << endl ; return 0 ; }
TAB0 create int dp [ 110 ] [ 110 ] ; TAB1 create int n , i , j and k ; TAB1 read n ; TAB1 set dp [ 1 ] [ 2 ] to 1 ; TAB1 set dp [ 2 ] [ 1 ] = 1 ; TAB1 for i = 3 to 100 inclusive ; TAB2 for j = 1 to i exclusive ; TAB3 sum = 0 ; TAB3 for k = 1 to j exclusive ; TAB4 if dp [ k ] [ i ] = 1 and dp [ k ] [ j ] = 1 , increment sum ; TAB3 if sum < = n ; TAB4 set n to n - sum ; TAB4 assign 1 to dp [ i ] [ j ] ; TAB4 set dp [ j ] [ i ] to 1 ; TAB3 if n = 0 , break ; TAB2 if n = 0 , break ; TAB1 ans = i ; TAB1 print i ; TAB1 for i = 1 to ans inclusive ; TAB2 for j = 1 to ans inclusive , print dp [ i ] [ j ] ; TAB2 print a newline ;	int dp [ 110 ] [ 110 ] ; int main ( ) { int n , i , j , k ; cin >> n ; dp [ 1 ] [ 2 ] = 1 ; dp [ 2 ] [ 1 ] = 1 ; for ( i = 3 ; i <= 100 ; i ++ ) { for ( j = 1 ; j < i ; j ++ ) { int sum = 0 ; for ( k = 1 ; k < j ; k ++ ) if ( dp [ k ] [ i ] == 1 && dp [ k ] [ j ] == 1 ) sum ++ ; if ( sum <= n ) { n = n - sum ; dp [ i ] [ j ] = 1 ; dp [ j ] [ i ] = 1 ; } if ( n == 0 ) break ; } if ( n == 0 ) break ; } int ans = i ; cout << i << endl ; for ( i = 1 ; i <= ans ; i ++ ) { for ( j = 1 ; j <= ans ; j ++ ) cout << dp [ i ] [ j ] ; cout << endl ; } }
TAB1 numberOfStudents = integer ; TAB1 studentsRate = integer ; TAB1 result = integer = 1 ; TAB1 read numberOfStudents ; TAB1 arr = integer array of size 2000 ; TAB1 for x = 0 to numberOfStudents exclusive , increase x by 1 at the start of the loop ; TAB2 read studentsRate ; TAB2 arr [ x ] = studentsRate ; TAB1 for x = 0 to numberOfStudents exclusive , increase x by 1 at the start of the loop ; TAB2 result = 1 ; TAB2 for y = 0 to numberOfStudents exclusive , increase y by 1 at the start of the loop ; TAB3 if arr [ x ] < arr [ y ] , then increase result by 1 ; TAB2 if x is numberOfStudents - 1 ; TAB3 print result ; TAB2 else ; TAB3 print result ;	int main ( ) { int numberOfStudents ; int studentsRate ; int result = 1 ; cin >> numberOfStudents ; int arr [ 2000 ] ; for ( int x = 0 ; x < numberOfStudents ; ++ x ) { cin >> studentsRate ; arr [ x ] = studentsRate ; } for ( int x = 0 ; x < numberOfStudents ; ++ x ) { result = 1 ; for ( int y = 0 ; y < numberOfStudents ; ++ y ) { if ( arr [ x ] < arr [ y ] ) { ++ result ; } } if ( x == numberOfStudents - 1 ) cout << result << endl ; else cout << result << "   " ; } return 0 ; }
TAB0 declare constant integer N = 200 ; TAB0 declare integer k , integer array mark size N by N ; TAB0 declare f with integer val as argument , returning void ; TAB1 set bytes from mark to size of mark to value 1 - val ; TAB1 for i = 0 to k exclusive ; TAB2 for j = i to k - i exclusive ; TAB3 if i % 2 is 0 , let mark [ i ] [ j ] be val ; TAB1 for i = k - 1 to 0 exclusive , decrementing i ; TAB2 for j = i to k - 1 - i inclusive , decrementing j ; TAB3 if ( k - 1 - i ) % 2 is 0 , let mark [ i ] [ j ] be val ; TAB1 for j = 0 to k exclusive ; TAB2 for i = j to k - j exclusive ; TAB3 if j % 2 is 0 , let mark [ i ] [ j ] be val ; TAB1 for j = k - 1 to 0 exclusive , decrementing j ; TAB2 for i = j to k - 1 - j inclusive , decrementing i ; TAB3 if ( k - 1 - j ) % 2 is 0 , let mark [ i ] [ j ] be val ; TAB1 read k ; TAB1 if k % 2 ; TAB2 print - 1 and newline ; TAB1 else ; TAB2 for i = 0 to k exclusive ; TAB3 run f with i % 2 as argument ; TAB3 for r = 0 to k exclusive ; TAB4 for c = 0 to k exclusive , print ' w ' if mark [ r ] [ c ] is true , else ' b ' ; TAB4 print newline ; TAB3 if i is less than k - 1 , print newline ;	const int N = 200 ; int k , mark [ N ] [ N ] ; void f ( int val ) { memset ( mark , 1 - val , sizeof mark ) ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = i ; j < k - i ; j ++ ) if ( i % 2 == 0 ) mark [ i ] [ j ] = val ; for ( int i = k - 1 ; i > 0 ; i -- ) for ( int j = i ; j >= k - 1 - i ; j -- ) if ( ( k - 1 - i ) % 2 == 0 ) mark [ i ] [ j ] = val ; for ( int j = 0 ; j < k ; j ++ ) for ( int i = j ; i < k - j ; i ++ ) if ( j % 2 == 0 ) mark [ i ] [ j ] = val ; for ( int j = k - 1 ; j > 0 ; j -- ) for ( int i = j ; i >= k - 1 - j ; i -- ) if ( ( k - 1 - j ) % 2 == 0 ) mark [ i ] [ j ] = val ; } int main ( ) { cin >> k ; if ( k % 2 ) cout << - 1 << endl ; else { for ( int i = 0 ; i < k ; i ++ ) { f ( i % 2 ) ; for ( int r = 0 ; r < k ; r ++ ) { for ( int c = 0 ; c < k ; c ++ ) cout << ( mark [ r ] [ c ] ? ' w ' : ' b ' ) ; cout << endl ; } if ( i < k - 1 ) cout << endl ; } } }
TAB0 s is an array of strings with size 8 ; TAB1 new integer variable t ; TAB1 read from the input to t ; TAB1 decrement t and loop further , while t is not 0 ; TAB2 in a for loop , change i from 0 to 8 exclusive , read from the input to s [ i ] on each loop iteration ; TAB2 create new integer variable k1x with value 0 ; TAB2 define integer variable k1y = 0 ; TAB2 define new integer variable k2x = 0 ; TAB2 create new integer variable k2y = 0 ; TAB2 declare integer t = 0 ; TAB2 for i from 0 to 8 exclusive ; TAB3 increment j in a loop from 0 to 8 exclusive ; TAB4 if s [ i ] [ j ] = ' K ' ; TAB5 if t is equal to 0 ; TAB6 assign i to k1x ; TAB6 change the value of k1y to j ; TAB6 increment t by one ; TAB5 else ; TAB6 set k2x to i ; TAB6 change k2y to j ; TAB6 increment t ; TAB4 if t is equal to 2 , break ; TAB3 if t is equal to 2 , break ; TAB2 new boolean f with value false ; TAB2 set f to true if abs ( k2x - k1x ) % 4 = 0 and abs ( k2y - k1y ) % 4 = 0 ; TAB2 if f is true ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ;	string s [ 8 ] ; int main ( ) { int t ; cin >> t ; while ( t -- ) { for ( int i = 0 ; i < 8 ; ++ i ) cin >> s [ i ] ; int k1x = 0 ; int k1y = 0 ; int k2x = 0 ; int k2y = 0 ; int t = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) { for ( int j = 0 ; j < 8 ; ++ j ) { if ( s [ i ] [ j ] == ' K ' ) { if ( t == 0 ) { k1x = i ; k1y = j ; t ++ ; } else { k2x = i ; k2y = j ; t ++ ; } } if ( t == 2 ) break ; } if ( t == 2 ) break ; } bool f = false ; if ( abs ( k2x - k1x ) % 4 == 0 && abs ( k2y - k1y ) % 4 == 0 ) f = true ; if ( f ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
TAB1 integers = n , m ; TAB1 read n , m ; TAB1 create integer vector of arr ; TAB1 integers = max = - 1 ; TAB1 integers = index = - 1 ; TAB1 for i = 0 to less than n do the following ; TAB2 integers = x ; TAB2 read x ; TAB2 if x is greater than max then do the following ; TAB3 set max to x ; TAB3 set index to i + 1 ; TAB2 add new element x to end of vector arr ; TAB1 if m is greater than or equal to max then do the following ; TAB2 output n ; TAB1 else ; TAB2 integers = index = - 1 ; TAB2 integers = count = 0 ; TAB2 integer i = 0 ; TAB2 for = 0 to less than n do the following ; TAB3 if arr [ i modulo n ] is greater than 0 then do the following ; TAB4 subtract m from arr [ i modulo n ] ; TAB4 if arr [ i modulo n ] is less than or equal to 0 then do the following count + + ; TAB3 if count is n then break ; TAB2 output i modulo n + 1 ;	int main ( ) { int n , m ; cin >> n >> m ; vector < int > arr ; int max = - 1 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; if ( x > max ) { max = x ; index = i + 1 ; } arr . push_back ( x ) ; } if ( m >= max ) { cout << n << endl ; } else { int index = - 1 ; int count = 0 ; int i = 0 ; for ( i = 0 ; count < n ; i ++ ) { if ( arr [ i % n ] > 0 ) { arr [ i % n ] -= m ; if ( arr [ i % n ] <= 0 ) { count ++ ; } } if ( count == n ) { break ; } } cout << i % n + 1 << endl ; } return 0 ; }
TAB1 create int f , mi , ma , pos , pos1 , n , a , set f = 0 , pos = 0 , pos1 = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read a ; TAB2 if i = 0 ; TAB3 mi = a ; TAB3 set ma = a ; TAB2 else ; TAB3 if a > ma ; TAB4 set ma = a ; TAB4 pos = i ; TAB3 if a < = mi ; TAB4 set mi equal to a ; TAB4 assign 1 to pos1 ; TAB1 if pos1 < pos , set f = 1 ; TAB1 print n - 1 - pos1 + pos - f and a newline ;	int main ( ) { int f = 0 , mi , ma , pos = 0 , pos1 = 0 , n , a ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; if ( i == 0 ) { mi = a ; ma = a ; } else { if ( a > ma ) { ma = a ; pos = i ; } if ( a <= mi ) { mi = a ; pos1 = i ; } } } if ( pos1 < pos ) f = 1 ; cout << n - 1 - pos1 + pos - f << " \n " ; }
TAB0 create new string n ; TAB1 read n from the user input ; TAB1 declare new ints a , b and c = 0 ; TAB1 declare new booleans power1 and power2 , with value of both = true ; TAB1 start for loop from i = 0 to length of n exclusive incrementing i ; TAB2 if power1 and power2 are false , increment c ; TAB2 if power1 is false ; TAB3 if n [ i ] ! = ' = ' and power2 is true ; TAB4 increment b ; TAB3 else ; TAB4 assign false to power2 ; TAB2 if n [ i ] ! = + ' + ' and power1 is true ; TAB3 increment a ; TAB2 else ; TAB3 assign false to power1 ; TAB1 if a + b ! = c and a + b + 2 ! = c and a + b ! = c + 2 ; TAB2 print " Impossible \ n " to the standard output ; TAB1 else ; TAB2 if a + b is equal to c ; TAB3 print ' | ' a times ; TAB3 print ' + ' to the standard output ; TAB3 print ' | ' b times ; TAB3 print ' = ' to the standard output ; TAB3 print ' | ' to the output stream c times ; TAB3 print ' \ n ' to the standard output ; TAB2 else if a + b + 2 is equal to c ; TAB3 print ' | ' in a loop a + 1 times ; TAB3 print ' + ' to the standard output ; TAB3 in a for loop , print ' | ' b times ; TAB3 print ' = ' ; TAB3 in a loop , print ' | ' c - 1 times ; TAB3 print ' \ n ' ; TAB2 else if a + b = c + 2 ; TAB3 declare string variable with name cad with value " " ; TAB3 if a is greater than 1 ; TAB4 start for loop from i = 0 to a - 1 exclusive , printing ' | ' on each iteration ; TAB3 else ; TAB4 print ' | ' ; TAB3 print ' + ' ; TAB3 if a = 1 and b > 1 ; TAB4 in a for loop , print ' | ' to the stdout b - 1 times ; TAB3 else if b = 1 ; TAB4 print ' | ' to the standard output ; TAB3 else ; TAB4 print ' | ' b times in a for loop ; TAB3 print ' = ' ; TAB3 for integer i = 0 to c + 1 exclusive , print ' | ' ; TAB3 print ' \ n ' ;	string n ; int main ( ) { cin >> n ; int a = 0 , b = 0 , c = 0 ; bool power1 = true , power2 = true ; for ( int i = 0 ; i < n . size ( ) ; i ++ ) { if ( ! power1 && ! power2 ) c ++ ; if ( ! power1 ) { if ( n [ i ] != ' = ' && power2 ) b ++ ; else power2 = false ; } if ( n [ i ] != + ' + ' && power1 ) a ++ ; else power1 = false ; } if ( a + b != c && a + b + 2 != c && a + b != c + 2 ) cout << " Impossible\n " ; else { if ( a + b == c ) { for ( int i = 0 ; i < a ; i ++ ) cout << ' | ' ; cout << ' + ' ; for ( int i = 0 ; i < b ; i ++ ) cout << ' | ' ; cout << ' = ' ; for ( int i = 0 ; i < c ; i ++ ) cout << ' | ' ; cout << ' \n ' ; } else if ( a + b + 2 == c ) { for ( int i = 0 ; i < a + 1 ; i ++ ) cout << ' | ' ; cout << ' + ' ; for ( int i = 0 ; i < b ; i ++ ) cout << ' | ' ; cout << ' = ' ; for ( int i = 0 ; i < c - 1 ; i ++ ) cout << ' | ' ; cout << ' \n ' ; } else if ( a + b == c + 2 ) { string cad = "  " ; if ( a > 1 ) for ( int i = 0 ; i < a - 1 ; i ++ ) cout << ' | ' ; else cout << ' | ' ; cout << ' + ' ; if ( a == 1 && b > 1 ) for ( int i = 0 ; i < b - 1 ; i ++ ) cout << ' | ' ; else if ( b == 1 ) cout << ' | ' ; else { for ( int i = 0 ; i < b ; i ++ ) cout << ' | ' ; } cout << ' = ' ; for ( int i = 0 ; i < c + 1 ; i ++ ) cout << ' | ' ; cout << ' \n ' ; } } return 0 ; }
TAB1 y , k , n = int ; TAB1 read y , k , n ; TAB1 x = k - y = int ; TAB1 while x < 1 then increment x by k ; TAB1 if x + y > n ; TAB2 print - 1 and new line ; TAB1 else ; TAB2 print x ; TAB2 while x + y + k < = n ; TAB3 print space and x + k ; TAB3 increment x by k ; TAB2 print new line ;	int main ( ) { int y , k , n ; cin >> y >> k >> n ; int x = k - y ; while ( x < 1 ) { x += k ; } if ( x + y > n ) cout << - 1 << endl ; else { cout << x ; while ( x + y + k <= n ) { cout << '   ' << x + k ; x += k ; } cout << endl ; } return 0 ; }
TAB1 make ints t , s , and x ; TAB1 read t , s , and x ; TAB1 set x to x - t ; TAB1 if x is less than s and x is not equal to 0 ; TAB2 show " NO " ; TAB1 else if x modulo s is equal to 0 or x modulo s is equal to 1 ; TAB2 show " YES " ; TAB1 otherwise ; TAB2 print " NO " ;	int main ( ) { int t , s , x ; cin >> t >> s >> x ; x -= t ; if ( x < s && x != 0 ) { cout << " NO " << endl ; } else if ( x % s == 0 || x % s == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
TAB1 create integer n ; TAB1 read from the input to n ; TAB1 create string s ; TAB1 read standard input to s ; TAB1 if s = " 0 " ; TAB2 print " 0 " ; TAB1 create integer variable with name zer = 0 ; TAB1 in a for loop , change i from 0 to length of s exclusive incrementing i ; TAB2 if s [ i ] = ' 0 ' , increment zer ; TAB1 print " 1 " ; TAB1 for i from 0 to zer exclusive , print " 0 " to the standard output ; TAB1 print new line to the standard output ;	int main ( ) { int n ; cin >> n ; string s ; cin >> s ; if ( s == " 0 " ) { cout << " 0 " << endl ; return 0 ; } int zer = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( s [ i ] == ' 0 ' ) zer ++ ; cout << " 1 " ; for ( int i = 0 ; i < zer ; i ++ ) cout << " 0 " ; cout << endl ; return 0 ; }
TAB1 s = string ; TAB1 read s ; TAB1 nC , iC , eC , tC , disC = int with nC = 0 and iC = 0 and eC = 0 and tC = 0 and disC = 0 ; TAB1 for c = 0 to length of s ; TAB2 if s [ c ] is ' n ' ; TAB3 increment nC ; TAB2 else if s [ c ] is ' i ' ; TAB3 increment iC ; TAB2 else if s [ c ] is ' e ' ; TAB3 increment eC ; TAB2 else if s [ c ] is ' t ' ; TAB3 increment tC ; TAB1 loop while nC and eC and iC and tC are all greater than 0 ; TAB2 decrement nC by 3 ; TAB2 decrement iC ; TAB2 decrement eC by 3 ; TAB2 decrement tC ; TAB2 if nC and eC and iC and tC are all greater or equal to 0 increment disC ; TAB2 increment nC ; TAB1 print disC ;	int main ( ) { string s ; cin >> s ; int nC = 0 , iC = 0 , eC = 0 , tC = 0 , disC = 0 ; for ( int c = 0 ; c < s . length ( ) ; c ++ ) { if ( s [ c ] == ' n ' ) { nC ++ ; } else if ( s [ c ] == ' i ' ) { iC ++ ; } else if ( s [ c ] == ' e ' ) { eC ++ ; } else if ( s [ c ] == ' t ' ) { tC ++ ; } } while ( nC > 0 && eC > 0 && iC > 0 && tC > 0 ) { nC -= 3 ; iC -- ; eC -= 3 ; tC -- ; if ( nC >= 0 && eC >= 0 && iC >= 0 && tC >= 0 ) { disC ++ ; } nC ++ ; } cout << disC << endl ; return 0 ; }
TAB0 Grades = char array of size 200005 ; TAB1 let lfp , zp , n , i , t , last be integers with lfp = - 1 ; TAB1 let carryFlag , pf be boolean with carryFlag = false , pf = false ; TAB1 read n , t , Grades [ 1 ] ; TAB1 for i = 1 to n inclusive ; TAB2 if Grades [ i ] = = ' . ' ; TAB3 increment i ; TAB3 break out of for loop ; TAB1 while Grades [ i ] and t > 0 ; TAB2 if Grades [ i ] is greater than or equal to ' 5 ' ; TAB3 set lfp to i ; TAB3 break ; TAB2 increment i ; TAB1 while ( - lfp ) is not zero and t > 0 and pf is false ; TAB2 if Grades [ lfp - 1 ] = = ' . ' ; TAB3 set Grades [ lfp - 1 ] to 0 ; TAB3 increment Grades [ lfp - 2 ] ; TAB3 update last to lfp - 2 ; TAB3 set pf to true ; TAB2 else ; TAB3 update Grades [ lfp ] to 0 ; TAB3 increment Grades [ lfp - 1 ] ; TAB3 update last to lfp - 1 ; TAB2 set lfp to - 1 ; TAB2 decrement t ; TAB2 if Grades [ last ] > ' 9 ' ; TAB3 let c be integer with c = 1 ; TAB3 set Grades [ last ] to ' 0 ' ; TAB3 decrement last ; TAB3 while c is not zero ; TAB4 set c to 0 ; TAB4 if Grades [ last ] = = ' . ' ; TAB5 set Grades [ last ] to ' \ 0 ' ; TAB5 increment Grades [ last - 1 ] ; TAB5 decrement last by 2 ; TAB5 set pf to true ; TAB4 else if last = = ' \ 0 ' ; TAB5 set carryFlag to true ; TAB5 set Grades [ 0 ] to ' 1 ' ; TAB5 break ; TAB4 else ; TAB5 increment Grades [ last ] ; TAB4 if Grades [ last ] > ' 9 ' ; TAB5 if not pf ; TAB6 set Grades [ last ] to ' \ 0 ' ; TAB5 else ; TAB6 set Grades [ last ] to ' 0 ' ; TAB5 decrement last ; TAB5 set c to 1 ; TAB4 if Grades [ last ] > = ' 5 ' , set lfp to last ; TAB2 else if Grades [ last ] > = ' 5 ' ; TAB3 set lfp to last ; TAB1 if carryFlag is true ; TAB2 print out first element of Grades ; TAB1 else ; TAB2 print out second element of Grades ;	char Grades [ 200005 ] ; int main ( ) { int lfp = - 1 , zp , n , i , t , last ; bool carryFlag = false , pf = false ; cin >> n >> t >> ( Grades + 1 ) ; for ( i = 1 ; i <= n ; ++ i ) { if ( Grades [ i ] == ' . ' ) { ++ i ; break ; } } while ( Grades [ i ] && t > 0 ) { if ( Grades [ i ] >= ' 5 ' ) { lfp = i ; break ; } ++ i ; } while ( ( ~ lfp ) && t > 0 && ! pf ) { if ( Grades [ lfp - 1 ] == ' . ' ) { Grades [ lfp - 1 ] = 0 ; Grades [ lfp - 2 ] ++ ; last = lfp - 2 ; pf = true ; } else { Grades [ lfp ] = 0 ; Grades [ lfp - 1 ] ++ ; last = lfp - 1 ; } lfp = - 1 ; t -- ; if ( Grades [ last ] > ' 9 ' ) { int c = 1 ; Grades [ last ] = ' 0 ' ; last -- ; while ( c ) { c = 0 ; if ( Grades [ last ] == ' . ' ) { Grades [ last ] = ' \0 ' ; Grades [ last - 1 ] ++ ; last -= 2 ; pf = true ; } else if ( last == ' \0 ' ) { carryFlag = true ; Grades [ 0 ] = ' 1 ' ; break ; } else { Grades [ last ] ++ ; } if ( Grades [ last ] > ' 9 ' ) { if ( ! pf ) Grades [ last ] = ' \0 ' ; else Grades [ last ] = ' 0 ' ; last -- ; c = 1 ; } if ( Grades [ last ] >= ' 5 ' ) lfp = last ; } } else if ( Grades [ last ] >= ' 5 ' ) { lfp = last ; } } if ( carryFlag ) cout << Grades << endl ; else cout << ( Grades + 1 ) << endl ; return 0 ; }
TAB0 hor = integer with hor = { 0 , 1 , 2 , 3 , 4 , 5 , 10 , 11 , 12 , 13 , 14 , 15 , 20 , 21 , 22 , 23 } ; TAB0 mie = integer with mie = { 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 } ; TAB1 maohao = character ; TAB1 h , m = integer ; TAB1 read h , maohao , m ; TAB1 for i = 0 to 15 ; TAB2 if ( hor [ i ] is h and mie [ i ] > m ) or hor [ i ] > h ; TAB3 if ( hor [ i ] < 10 ) , print 0 ; TAB3 print hor [ i ] , : ; TAB3 if mie [ i ] < 10 , print 0 ; TAB3 print mie [ i ] ; TAB1 print 00 : 00 ;	int hor [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 10 , 11 , 12 , 13 , 14 , 15 , 20 , 21 , 22 , 23 } ; int mie [ ] = { 0 , 10 , 20 , 30 , 40 , 50 , 1 , 11 , 21 , 31 , 41 , 51 , 2 , 12 , 22 , 32 } ; int main ( ) { char maohao ; int h , m ; cin >> h >> maohao >> m ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( hor [ i ] == h && mie [ i ] > m ) || hor [ i ] > h ) { if ( hor [ i ] < 10 ) cout << " 0 " ; cout << hor [ i ] << " : " ; if ( mie [ i ] < 10 ) cout << " 0 " ; cout << mie [ i ] << endl ; return 0 ; } } cout << " 00:00 " << endl ; return 0 ; }
TAB0 in the function ascending that takes integer i , j and returns bool ; TAB1 return ( i < j ) ; TAB0 in the function descending that takes integer i , j and returns bool ; TAB1 return ( i > j ) ; TAB0 dp = long long 2d array of size [ 5050 ] [ 5050 ] ; TAB0 mod = long long with mod = 1000 * 1000 * 1000 + 7 ; TAB0 s1 , s2 = strings ; TAB1 read s1 , s2 ; TAB1 set all contents of dp to 0 ; TAB1 for i = s1 . size ( ) - 1 down to 0 ; TAB2 for j = s2 . size ( ) - 1 down to 0 ; TAB3 dp [ i ] [ j ] = dp [ i ] [ j + 1 ] ; TAB3 if ( s1 [ i ] is s2 [ j ] ) , dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i + 1 ] [ j + 1 ] + 1 ; TAB3 dp [ i ] [ j ] = dp [ i ] [ j ] modulo mod ; TAB1 ret = integer with ret = 0 ; TAB1 for ( i ) = 0 to ( s1 . size ( ) ) ) , ret = ( ret + dp [ i ] [ 0 ] ) modulo mod ; TAB1 print ret modulo mod ;	bool ascending ( int i , int j ) { return ( i < j ) ; } bool descending ( int i , int j ) { return ( i > j ) ; } long long dp [ 5050 ] [ 5050 ] ; long long mod = 1000 * 1000 * 1000 + 7 ; string s1 , s2 ; int main ( ) { cin >> s1 >> s2 ; memset ( ( dp ) , ( 0 ) , sizeof ( dp ) ) ; for ( int i = s1 . size ( ) - 1 ; i >= 0 ; i -- ) for ( int j = s2 . size ( ) - 1 ; j >= 0 ; j -- ) { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] ; if ( s1 [ i ] == s2 [ j ] ) dp [ i ] [ j ] += dp [ i + 1 ] [ j + 1 ] + 1 ; dp [ i ] [ j ] %= mod ; } int ret = 0 ; for ( int ( i ) = 0 ; ( i ) < ( s1 . size ( ) ) ; ( i ) ++ ) ret = ( ret + dp [ i ] [ 0 ] ) % mod ; cout << ret % mod << endl ; }
TAB0 make constant ints N = 5e5 and inf = 1e9 ; TAB0 create map m of chars to ints ; TAB0 create int n and int arrays tmp of size N , x of size N , and y of size N ; TAB0 declare Ok taking in int cur and returning bool ; TAB1 for i = 0 to n exclusive ; TAB2 set tmp [ i ] to 0 ; TAB2 set tmp [ i ] to tmp [ i ] | ( 1 < < ( x [ i ] - 1 ) ) & cur ; TAB2 set tmp [ i ] to tmp [ i ] | ( 1 < < ( y [ i ] - 1 + 5 ) ) & cur ; TAB2 for j = 0 to i exclusive ; TAB3 if tmp [ i ] is equal to tmp [ j ] and if x [ i ] is not equal to x [ j ] or y [ i ] is not equal to y [ j ] , return false ; TAB1 return true ; TAB1 set M [ ' R ' ] to 1 , M [ ' G ' ] to 2 , M [ ' B ' ] to 3 , M [ ' Y ' ] to 4 , and M [ ' W ' ] to 5 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 make string s ; TAB2 read s ; TAB2 set x [ i ] to M [ s [ 0 ] ] ; TAB2 set y [ i ] to s [ 1 ] - ' 0 ' ; TAB1 create integer res = 10 ; TAB1 for i = 0 to ( 1 < < 10 ) exclusive ; TAB2 make integer cur = _builtin_popcount ( i ) ; TAB2 if cur is greater than or equal to res , continue loop ; TAB2 if Ok ( i ) is truthy , set res to cur ; TAB1 print res ;	const int N = 5e5 , inf = 1e9 + 7 ; map < char , int > M ; int tmp [ N ] , x [ N ] , y [ N ] , n ; bool Ok ( int cur ) { for ( int i = 0 ; i < n ; i ++ ) { tmp [ i ] = 0 ; tmp [ i ] |= ( 1 << ( x [ i ] - 1 ) ) & cur ; tmp [ i ] |= ( 1 << ( y [ i ] - 1 + 5 ) ) & cur ; for ( int j = 0 ; j < i ; j ++ ) { if ( tmp [ i ] == tmp [ j ] && ( x [ i ] != x [ j ] || y [ i ] != y [ j ] ) ) return false ; } } return true ; } int main ( ) { M [ ' R ' ] = 1 , M [ ' G ' ] = 2 , M [ ' B ' ] = 3 , M [ ' Y ' ] = 4 , M [ ' W ' ] = 5 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { string s ; cin >> s ; x [ i ] = M [ s [ 0 ] ] ; y [ i ] = s [ 1 ] - ' 0 ' ; } int res = 10 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { int cur = __builtin_popcount ( i ) ; if ( cur >= res ) continue ; if ( Ok ( i ) ) res = cur ; } cout << res << " \n " ; return 0 ; }
TAB0 n , p = integers ; TAB0 s , t , a , b = strings ; TAB0 ma = map < pair < string , string > , bool > ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 if i is not equal to 0 then read s ; TAB2 read s and t ; TAB2 if ma [ { s , t } ] then continue ; TAB2 set ma [ { s , t } ] to 1 ; TAB2 set a = b = " " ; TAB2 set a = a + t [ 0 ] ; TAB2 set a = a + s [ 0 ] ; TAB2 set b = b + t [ 1 ] ; TAB2 set b = b + s [ 1 ] ; TAB2 set ma [ { a , b } ] = 1 ; TAB2 set a = b = " " ; TAB2 set a = a + t [ 1 ] ; TAB2 set a = a + t [ 0 ] ; TAB2 set b = b + s [ 1 ] ; TAB2 set b = b + s [ 0 ] ; TAB2 set ma [ { a , b } ] = 1 ; TAB2 set a = b = " " ; TAB2 set a = a + s [ 1 ] ; TAB2 set a = a + t [ 1 ] ; TAB2 set b = b + s [ 0 ] ; TAB2 set b = b + t [ 0 ] ; ; TAB2 set ma [ { a , b } ] = 1 ; TAB2 increment p ; TAB1 print p ;	int n , p ; string s , t , a , b ; map < pair < string , string > , bool > ma ; int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; ++ i ) { if ( i != 0 ) { cin >> s ; } cin >> s >> t ; if ( ma [ { s , t } ] ) { continue ; } ma [ { s , t } ] = 1 ; a = b = "  " ; a += t [ 0 ] ; a += s [ 0 ] ; b += t [ 1 ] ; b += s [ 1 ] ; ma [ { a , b } ] = 1 ; a = b = "  " ; a += t [ 1 ] ; a += t [ 0 ] ; b += s [ 1 ] ; b += s [ 0 ] ; ma [ { a , b } ] = 1 ; a = b = "  " ; a += s [ 1 ] ; a += t [ 1 ] ; b += s [ 0 ] ; b += t [ 0 ] ; ma [ { a , b } ] = 1 ; ++ p ; } cout << p << " \n " ; }
TAB1 define long longs n , q , a , g , k , p , sum , t1 and l1 where k , p and sum = 0 ; TAB1 read n , q and a from the input ; TAB1 create new long long called w = q ; TAB1 if n is equal to 0 ; TAB2 print q / a to the standard output ; TAB1 else ; TAB2 for i from 0 to n exclusive incrementing i ; TAB3 create long longs t and l ; TAB3 read t and l from the input ; TAB3 if k = 0 ; TAB4 assign sum + ( t / a ) to sum ; TAB4 change the value of t1 to t and l1 to l ; TAB4 create long long variable h = t1 + l1 ; TAB4 change the value of k to 1 ; TAB3 else ; TAB4 define long long variable h = t1 + l1 ; TAB4 change g to t - h ; TAB4 set p to g / a ; TAB4 assign sum + p to sum ; TAB4 change the value of k to 1 ; TAB3 if i is equal to n - 1 ; TAB4 change the value of sum to sum + ( ( w - t - l ) / a ) ; TAB3 else ; TAB4 change t1 to t and l1 to l ; TAB2 print sum to the standard output ;	int main ( ) { long long n , q , a , g , k = 0 , p = 0 , sum = 0 , t1 , l1 ; cin >> n >> q >> a ; long long w = q ; if ( n == 0 ) cout << ( q / a ) << endl ; else { for ( long long i = 0 ; i < n ; i ++ ) { long long t , l ; cin >> t >> l ; if ( k == 0 ) { sum = sum + ( t / a ) ; t1 = t , l1 = l ; long long h = t1 + l1 ; k = 1 ; } else { long long h = t1 + l1 ; g = t - h ; p = g / a ; sum = sum + p ; k = 1 ; } if ( i == n - 1 ) sum = sum + ( ( w - t - l ) / a ) ; else t1 = t , l1 = l ; } cout << sum << endl ; } }
TAB0 gcd of inta a int b ; TAB1 if b is equal to 0 ; TAB2 return a ; TAB1 else do the following ; TAB2 gcd of b , a modulo b ; TAB1 let n be a integer ; TAB1 while read n ; TAB2 let cnt be a integer , cnt = 0 ; TAB2 if n is equal to 1 , increase cnt by 1 ; TAB2 while n is decreased by 1 ; TAB3 let b be a integer ; TAB3 read b ; TAB3 if b is equal to 0 , increase cnt by 1 ; TAB2 if cnt is equal to 1 ; TAB3 print YES ; TAB2 else do the following ; TAB3 print NO ; TAB2 print newline ;	int gcd ( int a , int b ) { if ( b == 0 ) return a ; else gcd ( b , a % b ) ; } int main ( ) { int n ; while ( cin >> n ) { int cnt = 0 ; if ( n == 1 ) cnt = 1 ; while ( n -- ) { int b ; cin >> b ; if ( b == 0 ) cnt ++ ; } if ( cnt == 1 ) cout << " YES " ; else cout << " NO " ; cout << endl ; } }
TAB0 isPrime is a new array of booleans with 10000000 elements ; TAB0 create new vector of integers prime ; TAB1 for i from 2 to 10000000 exclusive incrementing i ; TAB2 if isPrime [ i ] is false ; TAB3 in a for loop , change j from 2 * i to 10000000 exclusive adding i to j and assigning 1 to isPrime [ j ] on each loop iteration ; TAB3 push i to the vector prime ; TAB1 create new long long variable q ; TAB1 read user input to q ; TAB1 if q is less than 10000000 ; TAB2 if isPrime [ q ] is false ; TAB3 print 1 , new line and 0 ; TAB1 create new vector of long longs v ; TAB1 start for loop from i = 0 to length of prime exclusive incrementing i ; TAB2 while q % prime [ i ] is 0 ; TAB3 push prime [ i ] into v ; TAB3 divide q by prime [ i ] ; TAB1 if length of v is equal to 0 ; TAB2 print 1 , new line and 0 to the standard output ; TAB1 else ; TAB2 if q ! = 1 , push q into v ; TAB2 if length of v is equal to 2 ; TAB3 print 2 ; TAB2 else ; TAB3 print 1 , new line and v [ 0 ] * v [ 1 ] ;	bool isPrime [ 10000000 ] = { } ; vector < int > prime ; int main ( ) { for ( int i = 2 ; i < 10000000 ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < 10000000 ; j += i ) isPrime [ j ] = 1 ; prime . push_back ( i ) ; } } long long q ; cin >> q ; if ( q < 10000000 ) if ( ! isPrime [ q ] ) { cout << 1 << endl << 0 << endl ; return 0 ; } vector < long long > v ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { while ( ! ( q % ( ( long long ) prime [ i ] ) ) ) { v . push_back ( ( long long ) prime [ i ] ) ; q /= ( long long ) prime [ i ] ; } } if ( v . size ( ) == 0 ) cout << 1 << endl << 0 << endl ; else { if ( q != 1 ) v . push_back ( q ) ; if ( v . size ( ) == 2 ) cout << 2 << endl ; else cout << 1 << endl << v [ 0 ] * v [ 1 ] << endl ; } }
TAB1 n , k = int ; TAB1 read n then k ; TAB1 s = string ; TAB1 read s ; TAB1 i = int with i = n - 1 ; TAB1 req = string with req = s ; TAB1 loop while i is greater than 0 ; TAB2 done = bool with done = true ; TAB2 for j = 0 to n - 1 ; TAB3 if s8j ] is not s [ i + j ] ; TAB4 set done to false ; TAB4 break the for loop ; TAB2 if done is true then set req to substring of s starting at n - i and the length of i ; TAB2 decrement i ; TAB1 append req to s k - 1 times ; TAB1 print s ;	int main ( ) { int n , k ; cin >> n >> k ; string s ; cin >> s ; int i = n - 1 ; string req = s ; while ( i > 0 ) { bool done = true ; for ( int j = 0 ; j + i < n ; j ++ ) { if ( s [ j ] != s [ i + j ] ) { done = false ; break ; } } if ( done ) { req = s . substr ( n - i , i ) ; } i -- ; } for ( int j = 0 ; j < k - 1 ; j ++ ) { s . append ( req ) ; } cout << s << endl ; }
TAB0 declare string variable with name s ; TAB1 read s ; TAB1 declare new integer called a = 0 ; TAB1 for i from 0 to length of s exclusive incrementing i ; TAB2 if s [ i ] is equal to ' 1 ' , add 1 to a ; TAB1 if a = length of s ; TAB2 remove all symbols of s except first ; TAB2 print s ; TAB1 else ; TAB2 for i from 0 to length of s exclusive incrementing i ; TAB3 if s [ i ] is equal to ' 0 ' ; TAB4 rase all symbols of s from the start to index i ; TAB4 print s ; TAB4 break ;	string s ; int main ( ) { cin >> s ; int a = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' 1 ' ) a ++ ; } if ( a == s . size ( ) ) { s . erase ( s . begin ( ) + 1 ) ; cout << s << endl ; } else { for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( s [ i ] == ' 0 ' ) { s . erase ( s . begin ( ) + i ) ; cout << s << endl ; break ; } } return 0 ; }
TAB0 M = constant integer with value of 1010 ; TAB1 t1 , t2 , x1 , x2 , t0 = long long integers ; TAB1 read t1 , t2 , x1 , x2 , t0 ; TAB1 if t2 equals t0 and t1 equals t0 ; TAB2 print x1 space x2 ; TAB1 else ; TAB2 if t2 equals t0 ; TAB3 print 0 space x2 ; TAB2 else ; TAB3 if t1 equals t0 ; TAB4 print x1 space 0 ; TAB3 else ; TAB4 a = long long integer with value of t0 minus t1 ; TAB4 b = long long integer with value of t2 minus t0 ; TAB4 ans1 = long long integer with value of 0 ; TAB4 ans2 = long long integer with value of x2 ; TAB4 for y1 = 1 to x1 inclusive ; TAB5 y2 = long long integer with value of a * y1 / b + ( ( a * y1 ) mod b does not equal 0 ) ; TAB5 if y2 is less than or equal to x2 ; TAB6 f1 = long long integer with value t1 * y1 + t2 * y2 ; TAB6 d1 = long long integer with value of y1 + y2 ; TAB6 f2 = long long integer with value of t1 * ans1 + t2 * ans2 ; TAB6 d2 = long long integer with value of ans1 + ans2 ; TAB6 if f1 * d2 is less than d1 * f2 ; TAB7 set ans1 to y1 ; TAB7 set ans2 to y2 ; TAB6 else ; TAB7 if f1 * d2 equals d1 * f2 ; TAB8 if y1 + y2 is greater than ans1 + ans2 ; TAB9 set ans1 to y1 ; TAB9 set ans2 to y2 ; TAB4 print ans1 space ans2 ;	const int M = 1000 + 10 ; int main ( ) { long long int t1 , t2 , x1 , x2 , t0 ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; if ( t2 == t0 && t1 == t0 ) { cout << x1 << "   " << x2 << endl ; } else { if ( t2 == t0 ) { cout << " 0  " << x2 << endl ; } else { if ( t1 == t0 ) { cout << x1 << "  0 " << endl ; } else { long long int a = t0 - t1 ; long long int b = t2 - t0 ; long long int ans1 = 0 ; long long int ans2 = x2 ; for ( long long int y1 = 1 ; y1 <= x1 ; y1 ++ ) { long long int y2 = a * y1 / b + ( ( a * y1 ) % b != 0 ) ; if ( y2 <= x2 ) { long long int f1 = t1 * y1 + t2 * y2 ; long long int d1 = y1 + y2 ; long long int f2 = t1 * ans1 + t2 * ans2 ; long long int d2 = ans1 + ans2 ; if ( f1 * d2 < d1 * f2 ) { ans1 = y1 ; ans2 = y2 ; } else { if ( f1 * d2 == d1 * f2 ) { if ( y1 + y2 > ans1 + ans2 ) { ans1 = y1 ; ans2 = y2 ; } } } } } cout << ans1 << "   " << ans2 << endl ; } } } return 0 ; }
TAB0 let spf be an array of long long integers of size 100001 ; TAB0 prototype function gcd which takes in long long integers a and b as arguments ; TAB0 prototype function palindrome which takes in string s as an argument ; TAB0 prototype function modexp which takes in long long integers a , b , and m as arguments ; TAB0 prototype function sieve ; TAB0 prototype function getFactorization which takes in long long integer x as an argument ; TAB0 prototype function getZarr which takes in string str and an array of long long integers Z as arguments ; TAB0 define function ceil which takes in long long integers a and b as arguments ; TAB1 return a / b + ( a % b ! = 0 ) from the function ; TAB1 let n be a long long integer ; TAB1 read in n ; TAB1 let p be an array of n pairs that stores two long long integers ; TAB1 read in n values into p [ i ] . first and p [ i ] . second ; TAB1 sort the beginning to the n + p position of array p in ascending order ; TAB1 let ans be a long long integer and set its value to INT_MIN ; TAB1 iterate for n times ; TAB2 let x be a long long integer and set its value to ceil ( log10 ( p [ i ] . second ) / log10 ( 4 ) ) ; TAB2 set ans to the max of ans and x + ( p [ i ] . first ) ; TAB2 if ans is equal to p [ i ] . first , increment ans ; TAB1 print ans ; TAB0 define function gcd which takes in long long integers a and b as arguments ; TAB1 if a is equal to 0 , return the value of b ; TAB1 if b is equal to 0 , return the value of a ; TAB1 if a is equal to b , return the value of a ; TAB1 if a is greater than b , return the greatest common denominator of a % b and b ; TAB1 return the greatest common denominator of a and b % a ; TAB0 define function palindrome which takes in string s as an argument ; TAB1 let l be a long long integer and set its value to 0 ; TAB1 let h be a long long integer and set its value to s . length ( ) - 1 ; TAB1 while h is greater than 1 ; TAB2 if s [ l + + ] is not equal to s [ h - - ] , return a value of 0 ; TAB1 return a value of 1 ; TAB0 define function modexp which takes in long long integers a , b , and m as arguments ; TAB1 if b is equal to 0 , return a value of 1 ; TAB1 let temp be a long long integer and set its value to modexp ( a , b / 2 , m ) ; TAB1 set temp to ( temp * temp ) % m ; TAB1 if b and 1 are true , return ( temp * ( a % m ) ) % m ; TAB1 return the value of temp ; TAB0 define function sieve ; TAB1 set spf [ 1 ] to 1 ; TAB1 for i = 2 to i < 100001 , set spf [ i ] to i ; TAB1 iterate for i = 4 , to i < 100001 and increment i by 2 every loop , set spf [ i ] to 2 ; TAB1 for i = 3 to i * i < 100001 ; TAB2 if spf [ i ] is equal to i ; TAB3 for j = i * i to j < 100001 , increment j by i every loop ; TAB4 if spf [ j ] is equal to j , set spf [ j ] to i ; TAB0 define function getFactorization which takes in long long integer x as an argument ; TAB1 let ret be a vector of long long integers ; TAB1 while x is not equal to 1 ; TAB2 add a new element to ret with a value of spf [ x ] ; TAB2 set x to x / spf [ x ] ; TAB1 return the value of ret ; TAB0 define function getZarr which takes in string str and an array of long long integers Z as arguments ; TAB1 let n be a long long integer and set its value to str . length ( ) ; TAB1 let L , R , and k be long long integers ; TAB1 set the values of L and R to 0 ; TAB1 for i = 1 to i < n ; TAB2 if i is greater than R ; TAB3 set L and R to i ; TAB3 while R is less than n and str [ R - L ] is equal to str [ R ] , increment R ; TAB3 set Z [ i ] to R - L ; TAB3 decrement R ; TAB2 or else ; TAB3 set k to i - L ; TAB3 if Z [ k ] is less than R - i + 1 ; TAB4 set Z [ i ] to Z [ k ] ; TAB3 or else ; TAB4 set L to i ; TAB4 while R is less than n and str [ R - L ] is equal to str [ R ] , increment R ; TAB4 set Z [ i ] to R - L ; TAB4 decrement R ;	long long spf [ 100001 ] ; long long gcd ( long long a , long long b ) ; long long palindrome ( string s ) ; long long modexp ( long long a , long long b , long long m ) ; void sieve ( ) ; vector < long long > getFactorization ( long long x ) ; void getZarr ( string str , long long Z [ ] ) ; long long ceil ( long long a , long long b ) { return a / b + ( a % b != 0 ) ; } int main ( ) { long long n ; cin >> n ; pair < long long , long long > p [ n ] ; for ( long long i = 0 ; i < n ; i ++ ) { cin >> p [ i ] . first >> p [ i ] . second ; } sort ( p , p + n ) ; long long ans = INT_MIN ; for ( long long i = 0 ; i < n ; i ++ ) { long long x = ceil ( log10 ( p [ i ] . second ) / log10 ( 4 ) ) ; ans = max ( ans , x + ( p [ i ] . first ) ) ; if ( ans == p [ i ] . first ) ans ++ ; } cout << ans << endl ; } long long gcd ( long long a , long long b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a % b , b ) ; return gcd ( a , b % a ) ; } long long palindrome ( string s ) { long long l = 0 ; long long h = s . length ( ) - 1 ; while ( h > l ) { if ( s [ l ++ ] != s [ h -- ] ) { return 0 ; } } return 1 ; } long long modexp ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 ; long long temp = modexp ( a , b / 2 , m ) ; temp = ( temp * temp ) % m ; if ( b & 1 ) return ( temp * ( a % m ) ) % m ; return temp ; } void sieve ( ) { spf [ 1 ] = 1 ; for ( long long i = 2 ; i < 100001 ; i ++ ) spf [ i ] = i ; for ( long long i = 4 ; i < 100001 ; i += 2 ) spf [ i ] = 2 ; for ( long long i = 3 ; i * i < 100001 ; i ++ ) { if ( spf [ i ] == i ) { for ( long long j = i * i ; j < 100001 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } vector < long long > getFactorization ( long long x ) { vector < long long > ret ; while ( x != 1 ) { ret . push_back ( spf [ x ] ) ; x = x / spf [ x ] ; } return ret ; } void getZarr ( string str , long long Z [ ] ) { long long n = str . length ( ) ; long long L , R , k ; L = R = 0 ; for ( long long i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) R ++ ; Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) Z [ i ] = Z [ k ] ; else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) R ++ ; Z [ i ] = R - L ; R -- ; } } } }
TAB1 declare and array of long longs o with 100 elements and long long variables n , m and j where j = 0 ; TAB1 create long double k ; TAB1 let s be string array with size 100 ; TAB1 let s be an array of pairs of string / long long with size 100 ; TAB1 read n , m and k ; TAB1 loop i from 0 to n exclusive ; TAB2 read input to s [ i ] and o [ i ] ; TAB2 if k * o [ i ] + 1e - 8 rounded down > = 100 ; TAB3 c [ j ] . first = s [ i ] ; TAB3 c [ j ] . second = k * o [ i ] + 1e - 8 rounded down ; TAB3 increment j ; TAB1 for i from 0 to m exclusive ; TAB2 read input to s [ i ] ; TAB2 declare boolean variable flag = true ; TAB2 for integer k = 0 to j exclusive ; TAB3 if c [ k ] . first is s [ i ] , assign false to flag ; TAB2 if flag is true ; TAB3 c [ j ] . first = s [ i ] ; TAB3 c [ j ] . second = 0 ; TAB3 increment j ; TAB1 sort c ; TAB1 print j ; TAB1 for i from 0 to j exclusive , print c [ i ] . first , " " and c [ i ] . second ;	int main ( ) { long long o [ 100 ] , n , m , j = 0 ; long double k ; string s [ 100 ] ; pair < string , long long > c [ 100 ] ; cin >> n >> m >> k ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ] >> o [ i ] ; if ( floor ( k * o [ i ] + 1e-8 ) >= 100 ) { c [ j ] . first = s [ i ] ; c [ j ] . second = floor ( k * o [ i ] + 1e-8 ) ; j ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { cin >> s [ i ] ; bool flag = true ; for ( int k = 0 ; k < j ; k ++ ) if ( c [ k ] . first == s [ i ] ) flag = false ; if ( flag ) { c [ j ] . first = s [ i ] ; c [ j ] . second = 0 ; j ++ ; } } sort ( c , c + j ) ; cout << j << endl ; for ( int i = 0 ; i < j ; i ++ ) cout << c [ i ] . first << "   " << c [ i ] . second << endl ; return 0 ; }
TAB0 PI = const double with PI = acos on - 1 . 0 ; TAB0 EPS = const double with EPS = ( 1e - 10 ) ; TAB0 INF = const long long integer with INF = 0x3f3f3f3f ; TAB0 mod = const long long with mod = ( 1e9 ) + 7 ; TAB0 in the function my_mod that takes long long int num , mod and returns long long int ; TAB1 ret = long long integer with ret = num modulo mod ; TAB1 while ( ret < 0 ) , ret = ret + mod ; TAB1 return ret ; TAB0 in the function gcd that takes long long int a , b and returns long long int ; TAB1 return if a is 0 , b else gcd ( b modulo a , a ) ; TAB1 k = integer ; TAB1 read k ; TAB1 ans = integer array of size [ 205 ] [ 205 ] ; TAB1 set all contents of ans to 0 ; TAB1 cnt = integer with cnt = 1 ; TAB1 for ( k ) ; TAB2 for i = 0 to i < = k and i < cnt ; TAB3 ans [ i ] [ cnt ] = 1 ; TAB3 ans [ cnt ] [ i ] = 1 ; TAB3 k = k - i ; TAB2 increment cnt ; TAB1 print cnt ; TAB1 for i = 0 to cnt exclusive ; TAB2 for j = 0 to cnt exclusive , print ans [ i ] [ j ] ; TAB2 print new line ;	const double PI = acos ( - 1.0 ) ; const double EPS = ( 1e-10 ) ; const long long int INF = 0x3f3f3f3f ; const long long mod = ( 1e9 ) + 7 ; long long int my_mod ( long long int num , long long int mod ) { long long int ret = num % mod ; while ( ret < 0 ) ret += mod ; return ret ; } long long int gcd ( long long int a , long long int b ) { return a == 0 ? b : gcd ( b % a , a ) ; } int main ( ) { int k ; cin >> k ; int ans [ 205 ] [ 205 ] ; memset ( ans , 0 , sizeof ( ans ) ) ; int cnt = 1 ; for ( ; k ; ) { for ( int i = 0 ; i <= k && i < cnt ; i ++ ) { ans [ i ] [ cnt ] = 1 ; ans [ cnt ] [ i ] = 1 ; k -= i ; } cnt ++ ; } cout << cnt << endl ; for ( int i = 0 ; i < cnt ; i ++ ) { for ( int j = 0 ; j < cnt ; j ++ ) cout << ans [ i ] [ j ] ; cout << endl ; } return 0 ; }
TAB0 N = const int = 150 ; TAB0 let x [ N ] , y [ N ] , info [ N ] , n be ints ; TAB0 in int function color_to_id taking char ch ; TAB1 if ch = ' R ' then return 1 ; TAB1 if ch = ' G ' then return 2 ; TAB1 if ch = ' B ' then return 3 ; TAB1 if ch = ' Y ' then return 4 ; TAB1 if ch = ' W ' then return 5 ; TAB0 in int function count_one taking x ; TAB1 cnt = 0 = int ; TAB1 while x isn ' t 0 ; TAB2 increment cnt by x & 1 ; TAB2 x = x bit right shift 1 ; TAB1 return cnt ; TAB0 in bool function check taking sta = int ; TAB1 for i = 0 to n exclusive ; TAB2 set info [ i ] = 0 ; TAB2 info [ i ] bitwise or ( 1 bitwise left shift ( x [ i ] - 1 ) ) bitwise and sta ; TAB2 info [ i ] bitwise or ( 1 bitwise left shift ( y [ i ] - 1 + 5 ) ) bitwise and sta ; TAB2 for j = 0 to i exclusive ; TAB3 if info [ i ] = info [ j ] and ( x [ i ] is not x [ j ] or y [ i ] is not y [ j ] ) ; TAB1 return true ; TAB1 str = string ; TAB1 while reading n ; TAB2 for i = 0 to n exclusive ; TAB3 read str ; TAB3 set x [ i ] = color_to_id of str [ 0 ] ; TAB3 y [ i ] = str [ 1 ] - ' 0 ' ; TAB2 ans = 10 = int ; TAB2 for i = 0 to 1 bitwise left shit 10 ; TAB3 n_one = count_one ( i ) = int ; TAB3 if n_one > = ans then go to next iteration ; TAB3 if check ( i ) then set ans to n_one ; TAB2 print ans ;	const int N = 150 ; int x [ N ] , y [ N ] , info [ N ] , n ; int color_to_id ( char ch ) { if ( ch == ' R ' ) return 1 ; if ( ch == ' G ' ) return 2 ; if ( ch == ' B ' ) return 3 ; if ( ch == ' Y ' ) return 4 ; if ( ch == ' W ' ) return 5 ; } int count_one ( int x ) { int cnt = 0 ; while ( x ) { cnt += ( x & 1 ) ; x >>= 1 ; } return cnt ; } bool check ( int sta ) { for ( int i = 0 ; i < n ; i ++ ) { info [ i ] = 0 ; info [ i ] |= ( 1 << ( x [ i ] - 1 ) ) & sta ; info [ i ] |= ( 1 << ( y [ i ] - 1 + 5 ) ) & sta ; for ( int j = 0 ; j < i ; j ++ ) if ( info [ i ] == info [ j ] && ( x [ i ] != x [ j ] || y [ i ] != y [ j ] ) ) return false ; } return true ; } int main ( ) { string str ; while ( cin >> n ) { for ( int i = 0 ; i < n ; i ++ ) { cin >> str ; x [ i ] = color_to_id ( str [ 0 ] ) ; y [ i ] = str [ 1 ] - ' 0 ' ; } int ans = 10 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { int n_one = count_one ( i ) ; if ( n_one >= ans ) continue ; if ( check ( i ) ) ans = n_one ; } cout << ans << endl ; } return 0 ; }
TAB1 define integers n and k ; TAB1 read n and k ; TAB1 define string s ; TAB1 read into s ; TAB1 define ints i and j ; TAB1 for i from 1 to n ( exclusive ) by 1 ; TAB2 define Boolean flag and set it to 1 ; TAB2 for j by 1 from i to n ( exclusive ) ; TAB3 if s [ j ] isn ' t s [ j - 1 ] ; TAB4 set flag to 0 ; TAB4 break out of loop ; TAB2 if flag , then break ; TAB1 if i is n ; TAB2 while k is nonzero , decrement k and print s ; TAB2 print a newline ; TAB1 set i to n - 1 - 1 ; TAB1 print s ; TAB1 decrement k ; TAB1 while k isn ' t 0 , decrement it and ; TAB2 for int l from i + 1 to n ( exclusive ) by 1 , print s [ l ] ; TAB1 print newline ;	int main ( ) { int n , k ; cin >> n >> k ; string s ; cin >> s ; int i , j ; for ( i = 1 ; i < n ; i ++ ) { bool flag = 1 ; for ( j = i ; j < n ; j ++ ) { if ( s [ j ] != s [ j - i ] ) { flag = 0 ; break ; } } if ( flag ) { break ; } } if ( i == n ) { while ( k -- ) cout << s ; cout << ' \n ' ; return 0 ; } i = n - i - 1 ; cout << s ; k -- ; while ( k -- ) for ( int l = i + 1 ; l < n ; l ++ ) cout << s [ l ] ; cout << ' \n ' ; }
TAB1 create unsigned long long integers n , a , x , maxim , cmax , cnt and total with total = 0 ; TAB1 set maxim to 0 ; TAB1 cmax = 0 ; TAB1 cnt is equal to 0 ; TAB1 read n ; TAB1 for n iterations ; TAB2 read a ; TAB2 for j = 0 to j = a exclusive ; TAB3 read x ; TAB3 set maxim to max to maxim and x ; TAB2 if maxim is greater than cmax ; TAB3 total = total + ( maxim - cmax ) * cnt ; TAB3 assign maxim to cmax ; TAB2 else ; TAB3 total = total + ( cmax - maxim ) * a ; TAB2 cnt is equal to cnt + a ; TAB2 set maxim to 0 ; TAB1 print total ;	int main ( ) { unsigned long long int n , a , x , maxim , cmax , cnt , total = 0 ; maxim = 0 ; cmax = 0 ; cnt = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a ; for ( int j = 0 ; j < a ; j ++ ) { cin >> x ; maxim = max ( maxim , x ) ; } if ( maxim > cmax ) { total += ( maxim - cmax ) * cnt ; cmax = maxim ; } else { total += ( cmax - maxim ) * a ; } cnt += a ; maxim = 0 ; } cout << total << endl ; return 0 ; }
TAB0 create int array counter of size 4005 * 10 ; TAB1 let int a ; TAB1 make char array str of size 4005 ; TAB1 read a ; TAB1 read str ; TAB1 let int = strlen ( str ) and integer arrays cs of size 4005 and temp of size 4005 ; TAB1 set cs [ 0 ] to 0 ; TAB1 for i = 0 to len exclusive , set temp [ i + 1 ] to str [ i ] - 48 ; TAB1 for i = 1 to len , set cs [ i ] to cs [ i - 1 ] + temp [ i ] ; TAB1 for i = 1 to len ; TAB2 for j = i to len , increment counter [ cs [ j ] - cs [ i - 1 ] ] ; TAB1 make long long int ans = 0 ; TAB1 if a is 0 ; TAB2 for i = 0 to 37000 exclusive , set ans to ans + ( ( long long ) counter [ 0 ] * ( long long ) counter [ i ] ) ; TAB1 for i = 1 to 37000 ; TAB2 if a modulo i is 0 ; TAB3 if a / i is greater than or equal to 0 and a / i is less than or equal to 37000 , set ans to ans + ( ( long long ) counter [ i ] * ( long long ) counter [ a / i ] ) ; TAB1 print ans ;	int counter [ 4005 * 10 ] ; int main ( ) { int a ; char str [ 4005 ] ; cin >> a ; cin >> str ; int cs [ 4005 ] , temp [ 4005 ] , len = strlen ( str ) ; cs [ 0 ] = 0 ; for ( int i = 0 ; i < len ; i ++ ) { temp [ i + 1 ] = str [ i ] - 48 ; } for ( int i = 1 ; i <= len ; i ++ ) { cs [ i ] = cs [ i - 1 ] + temp [ i ] ; } for ( int i = 1 ; i <= len ; i ++ ) { for ( int j = i ; j <= len ; j ++ ) { counter [ cs [ j ] - cs [ i - 1 ] ] ++ ; } } long long ans = 0 ; if ( a == 0 ) { for ( int i = 0 ; i < 37000 ; i ++ ) { ans += ( ( long long ) counter [ 0 ] * ( long long ) counter [ i ] ) ; } } for ( int i = 1 ; i <= 37000 ; i ++ ) { if ( a % i == 0 ) { if ( ( a / i ) >= 0 && ( a / i ) <= 37000 ) { ans += ( ( long long ) counter [ i ] * ( long long ) counter [ a / i ] ) ; } } } cout << ans << endl ; return 0 ; }
TAB1 let a , b , c be integers ; TAB1 let s be a string ; TAB1 while read s ; TAB2 let len be a integer with len = length of s ; TAB2 let i be a integer ; TAB2 let flag be a integer with flag = 1 ; TAB2 if s [ 0 ] is not eqaul to a ; TAB3 print NO and newline ; TAB3 proceed to next ; TAB2 a is equal to 1 ; TAB2 b is equal to c is equal to 0 ; TAB2 for i = 1 to len exclusive ; TAB3 if s [ i ] is equal to a ; TAB4 increment a by 1 ; TAB3 else if s [ i ] is equal to c ; TAB4 flag is equal to 0 ; TAB4 stop ; TAB3 else do the following ; TAB4 stop ; TAB2 for i , i is less than len , increment i by 1 ; TAB3 if s [ i ] is equal to b ; TAB4 increment b by 1 ; TAB3 else if s [ i ] is equal to a ; TAB4 flag is equal to 0 ; TAB4 stop ; TAB3 else do the following ; TAB4 stop ; TAB2 for i , i is less than len , increment i by 1 ; TAB3 if s [ i ] is equal to c ; TAB4 increment c by 1 ; TAB3 else do the following ; TAB4 flag is equal to 0 ; TAB4 stop ; TAB2 if flag is equal to 0 ; TAB3 print NO and newline ; TAB2 else if b is equal to 0 ; TAB3 print NO and newline ; TAB2 else do the following ; TAB3 if c is equal to a or c is equal to b ; TAB4 print YES and newline ; TAB3 else do the following ; TAB4 print NO and newline ;	int main ( ) { int a , b , c ; string s ; while ( cin >> s ) { int len = s . length ( ) ; int i ; int flag = 1 ; if ( s [ 0 ] != ' a ' ) { cout << " NO " << endl ; continue ; } a = 1 ; b = c = 0 ; for ( i = 1 ; i < len ; i ++ ) { if ( s [ i ] == ' a ' ) a ++ ; else if ( s [ i ] == ' c ' ) { flag = 0 ; break ; } else break ; } for ( i ; i < len ; i ++ ) { if ( s [ i ] == ' b ' ) b ++ ; else if ( s [ i ] == ' a ' ) { flag = 0 ; break ; } else break ; } for ( i ; i < len ; i ++ ) { if ( s [ i ] == ' c ' ) c ++ ; else { flag = 0 ; break ; } } if ( flag == 0 ) cout << " NO " << endl ; else if ( b == 0 ) cout << " NO " << endl ; else { if ( c == a || c == b ) cout << " YES " << endl ; else cout << " NO " << endl ; } } return 0 ; }
TAB0 create integer n , array a with size 105 ; TAB0 create map mp of char to int ; TAB1 read n ; TAB1 set mp [ ' R ' ] to 5 ; TAB1 set mp [ ' G ' ] to 6 ; TAB1 set mp [ ' B ' ] to 7 ; TAB1 set mp [ ' Y ' ] to 8 ; TAB1 set mp [ ' W ' ] to 9 ; TAB1 for i = 0 to n exclusive ; TAB2 create stirng s ; TAB2 read s ; TAB2 create ints c , v ; TAB2 set c to mp [ s [ 0 ] ] ; TAB2 set v to s [ 1 ] - ' 0 ' - 1 ; TAB2 set a [ i ] to ( 1 bitwise shift left c ) bitwise or ( 1 bitwise shift left v ) ; TAB1 sort a [ 0 : n ) ; TAB1 set n to unique ( a , a + n ) - a ; TAB1 create integer ans = 11 ; TAB1 for int mask = 0 ; msk less than ( 1 bitwise shift left 10 ) ; increment msk ; TAB2 create bool f = true ; TAB2 for i = 0 to n exclusive ; TAB3 for j = i + 1 to n exclusive ; TAB4 create int t = a [ i ] bitwise XOR a [ j ] ; TAB4 if ( msk bitwise and t ) equals 0 ; TAB5 set f to false ; TAB5 break ; TAB3 if not f , break ; TAB2 if f , set ans to min ( ans , __builtin_popcount ( msk ) ) ; TAB1 print ans ;	int n , a [ 105 ] ; map < char , int > mp ; int main ( ) { cin >> n ; mp [ ' R ' ] = 5 ; mp [ ' G ' ] = 6 ; mp [ ' B ' ] = 7 ; mp [ ' Y ' ] = 8 ; mp [ ' W ' ] = 9 ; for ( int i = 0 ; i < n ; i ++ ) { string s ; cin >> s ; int c , v ; c = mp [ s [ 0 ] ] ; v = s [ 1 ] - ' 0 ' - 1 ; a [ i ] = ( 1 << c ) | ( 1 << v ) ; } sort ( a , a + n ) ; n = unique ( a , a + n ) - a ; int ans = 11 ; for ( int msk = 0 ; msk < ( 1 << 10 ) ; msk ++ ) { bool f = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int t = a [ i ] ^ a [ j ] ; if ( ( msk & t ) == 0 ) { f = false ; break ; } } if ( ! f ) break ; } if ( f ) { ans = min ( ans , __builtin_popcount ( msk ) ) ; } } cout << ans << endl ; return 0 ; }
TAB1 create character array s with size 100003 ; TAB1 create character pointer c ; TAB1 read s ; TAB1 if ( set c to first occurrence of " AB " in s ) is not NULL and first occurrence of " BA " in c + 2 is not null ; TAB2 print " YES " print newline ; TAB1 if ( set c to first occurrence of " BA " in s ) is not NULL and first occurrence of " AB " in c + 2 is not null ; TAB2 print " YES " print newline ; TAB1 print " NO " print newline ;	int main ( ) { char s [ 100003 ] ; char * c ; cin >> s ; if ( ( c = strstr ( s , " AB " ) ) != NULL && strstr ( c + 2 , " BA " ) != NULL ) { cout << " YES " << endl ; return 0 ; } if ( ( c = strstr ( s , " BA " ) ) != NULL && strstr ( c + 2 , " AB " ) != NULL ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; }
TAB0 the constant double value of PI = acos ( - 1 ) ; TAB0 the constant integer value of MAX = 2e9 + 7 ; TAB0 the constant long integer value of MOD = 1e9 + 7 ; TAB0 let solve be a void function ; TAB1 let n , m , k , l be long integers ; TAB1 read n , m , k , l ; TAB1 the long integer value of dif = n - k ; TAB1 if dif is less than l ; TAB2 print - 1 and newline ; TAB2 return nothing ; TAB1 let h be a long integer , if k modulo m equals 0 , h = k / m else h = k / m + 1 ; TAB1 the long integer value of r = h * m - k ; TAB1 if r > = l ; TAB2 if h * m < = n ; TAB3 print h and newline ; TAB2 else do the following ; TAB3 print - 1 and newline ; TAB2 return nothing ; TAB1 else do the following ; TAB2 let t be a long integer , if l modulo m equals 0 the value of t is equal to l / m else t is equal to l / m + 1 ; TAB2 if ( t + h - 1 ) * m < = n and ( t + h - 1 ) * m - k > = l ; TAB3 print t + h - 1 and newline ; TAB2 else if ( t + h ) * m < = n ; TAB3 print t + h and newline ; TAB2 else do the following ; TAB3 print - 1 and newline ; TAB1 call the solve function ;	const double PI = acos ( - 1 ) ; const int MAX = 2e9 + 7 ; const long long MOD = 1e9 + 7 ; void solve ( ) { long long n , m , k , l ; cin >> n >> m >> k >> l ; long long dif = n - k ; if ( dif < l ) { cout << - 1 << endl ; return ; } long long h = ( k % m == 0 ? k / m : k / m + 1 ) ; long long r = h * m - k ; if ( r >= l ) { if ( h * m <= n ) cout << h << endl ; else cout << - 1 << endl ; return ; } else { long long t = ( l % m == 0 ? l / m : l / m + 1 ) ; if ( ( t + h - 1 ) * m <= n and ( t + h - 1 ) * m - k >= l ) cout << t + h - 1 << endl ; else if ( ( t + h ) * m <= n ) cout << t + h << endl ; else cout << - 1 << endl ; } } int main ( ) { solve ( ) ; return 0 ; }
TAB1 create int n ; TAB1 read n ; TAB1 let int k ; TAB1 let int p ; TAB1 if n is less than 4 ; TAB2 if n is equal to 1 ; TAB3 set k to 1 ; TAB2 else if n is equal to 2 ; TAB3 set k to 2 ; TAB2 else if n is equal to 3 ; TAB3 set k to 3 ; TAB2 else if n is equal to 0 ; TAB3 print 1 ; TAB1 else do ; TAB2 set k to n % 4 ; TAB1 if k is equal to 1 ; TAB2 set p to 8 ; TAB1 else if k is equal to 2 ; TAB2 set p to 4 ; TAB1 else if k is equal to 3 ; TAB2 set p to 2 ; TAB1 else if k is equal to 0 ; TAB2 set p to 6 ; TAB1 print p ;	int main ( ) { int n ; cin >> n ; int k ; int p ; if ( n < 4 ) { if ( n == 1 ) k = 1 ; else if ( n == 2 ) k = 2 ; else if ( n == 3 ) k = 3 ; else if ( n == 0 ) { cout << 1 << endl ; return 0 ; } } else { k = n % 4 ; } if ( k == 1 ) { p = 8 ; } else if ( k == 2 ) { p = 4 ; } else if ( k == 3 ) { p = 2 ; } else if ( k == 0 ) { p = 6 ; } cout << p << endl ; return 0 ; }
TAB1 declare long long x ; TAB1 read x ; TAB1 if fail bit on cin is false ; TAB2 if x is less than or equal to 127 ; TAB3 print " byte " and newline ; TAB2 else if x is less than or equal to 32767 ; TAB3 print " short " and newline ; TAB2 else if x is less than or equal to 2147483647 ; TAB3 print " int " and newline ; TAB2 else ; TAB3 print " long " and newline ; TAB1 else ; TAB2 print " BigInteger " and newline ;	int main ( ) { long long x ; cin >> x ; if ( ! cin . fail ( ) ) { if ( x <= 127 ) cout << " byte " << endl ; else if ( x <= 32767 ) cout << " short " << endl ; else if ( x <= 2147483647 ) cout << " int " << endl ; else cout << " long " << endl ; } else { cout << " BigInteger " << endl ; } return 0 ; }
TAB1 integer as n ; TAB1 read n ; TAB1 integer as max = - 1 ; TAB1 for i = 0 to less than n do the following ; TAB2 make k a long integer ; TAB2 make a a long integer ; TAB2 read k , a ; TAB2 set long m to 1 ; TAB2 integer as mcnt = 0 ; TAB2 if m is true do the following ; TAB3 if m is greater than or equal to a then break ; TAB3 multiply m by 4 ; TAB3 add one to mcnt ; TAB2 if a is 1 then mcnt = 1 ; TAB2 integer as real_k = k + mcnt ; TAB2 if real_k is greater than max then do the following max = real_k ; TAB1 output max ; TAB1 ; ;	int main ( ) { int n ; cin >> n ; int max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { long k ; long a ; cin >> k >> a ; long m = 1 ; int mcnt = 0 ; while ( m ) { if ( m >= a ) { break ; } m *= 4 ; mcnt ++ ; } if ( a == 1 ) { mcnt = 1 ; } int real_k = k + mcnt ; if ( real_k > max ) { max = real_k ; } } cout << max << endl ; return 0 ; ; }
TAB1 declare locale loc ; TAB1 declare integers a , b ; TAB1 declare long long s ; TAB1 read a , b , s ; TAB1 if s is greater than or equal to absolute value of a + absolute value of b and ( s - ( absolute value of a + absolute value of b ) % 2 is 0 ) ; TAB2 print " Yes " ; TAB3 print " \ n " ; TAB1 else ; TAB2 print " No " ; TAB3 print " \ n " ;	int main ( ) { locale loc ; int a , b ; long long s ; cin >> a >> b >> s ; if ( s >= abs ( a ) + abs ( b ) and ( s - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) { cout << " Yes " << " \n " ; } else { cout << " No " << " \n " ; } }
TAB0 declare constant integer N = 2e5 + 10 ; TAB0 declare long long integers n , a , b , k , MOD = 1e9 + 9 ; TAB0 declare fast_power with long longs base , power as arguments , returning long long ; TAB1 declare long long result = 1 ; TAB1 while power is greater than 0 ; TAB2 if power % 2 is 1 , let result be ( result * base ) % MOD ; TAB2 let base be ( base * base ) % MOD ; TAB2 let power be power / 2 ; TAB1 return result from function ; TAB1 read n , a , b , k ; TAB1 declare string s ; TAB1 read s ; TAB1 declare integer l = ( n + 1 ) / k - 1 ; TAB1 declare long long integer val = ( b * result of run fast_power ( a , MOD - 2 ) ) % MOD ; TAB1 declare long long integer valp = result of run fast_power ( val , k ) ; TAB1 declare long long integer ans = 0 ; TAB1 declare long long integer geo ; TAB1 if valp is not 1 ; TAB2 let geo be ( result of run fast_power ( valp , l + 1 ) - 1 ) % MOD + MOD ; TAB2 let geo be geo * result of run fast_power ( ( valp - 1 ) % MOD + MOD , MOD - 2 ) % MOD ; TAB2 let geo be geo % MOD ; TAB1 else ; TAB2 let geo be l + 1 ; TAB1 for i = 0 to k exclusive ; TAB2 declare long long integer calc = result of run fast_power ( b , i ) * result of run fast_power ( a , n - i ) % MOD ; TAB2 if s [ i ] is ' - ' ; TAB3 let ans be ( ans - ( geo * calc % MOD ) ) % MOD + MOD ; TAB2 else ; TAB3 let ans be ( ans + ( geo * calc % MOD ) % MOD ) ; TAB2 let ans be ans % MOD ; TAB1 print ans and newline ;	const int N = 2e5 + 10 ; long long int n , a , b , k , MOD = 1e9 + 9 ; long long fast_power ( long long base , long long power ) { long long result = 1 ; while ( power > 0 ) { if ( power % 2 == 1 ) { result = ( result * base ) % MOD ; } base = ( base * base ) % MOD ; power = power / 2 ; } return result ; } int main ( ) { cin >> n >> a >> b >> k ; string s ; cin >> s ; int l = ( n + 1 ) / k - 1 ; long long int val = ( b * fast_power ( a , MOD - 2 ) ) % MOD ; long long int valp = fast_power ( val , k ) ; long long int ans = 0 ; long long int geo ; if ( valp != 1 ) { geo = ( fast_power ( valp , l + 1 ) - 1 ) % MOD + MOD ; geo = geo * fast_power ( ( valp - 1 ) % MOD + MOD , MOD - 2 ) % MOD ; geo %= MOD ; } else geo = l + 1 ; for ( int i = 0 ; i < k ; i ++ ) { long long int calc = fast_power ( b , i ) * fast_power ( a , n - i ) % MOD ; if ( s [ i ] == ' - ' ) ans = ( ans - ( geo * calc % MOD ) ) % MOD + MOD ; else ans = ( ans + ( geo * calc % MOD ) % MOD ) ; ans %= MOD ; } cout << ans << endl ; return 0 ; }
TAB0 a = integer array of size 105 ; TAB0 in function summ with parameters integers l , r and return long long ; TAB1 ans = long long set to 0 ; TAB1 for i = l to r inclusive , add a [ i ] to ans ; TAB1 return ans ; TAB1 declare an integer n ; TAB1 input n ; TAB1 sum = long long set to 0 ; TAB1 ans = integer set to 0 ; TAB1 for i = 1 to n inclusive ; TAB2 read a [ i ] ; TAB2 add a [ i ] to sum ; TAB2 if a [ i ] is 0 , increment ans ; TAB1 if sum is 0 ; TAB2 if ans is n ; TAB3 print NO ; TAB2 else ; TAB3 for i = 1 to n exclusive ; TAB4 if call summ with 1 , i isn ' t 0 and call summ with i + 1 , n isn ' t 0 ; TAB5 print YES , newline , 2 ; TAB5 print 1 , " " , i ; TAB5 print i + 1 , " " , n ; TAB5 break ; TAB1 else ; TAB2 print YES ; TAB2 print 1 ; TAB2 print 1 , " " , n ;	int a [ 105 ] ; long long summ ( int l , int r ) { long long ans = 0 ; for ( int i = l ; i <= r ; i ++ ) { ans += a [ i ] ; } return ans ; } int main ( ) { int n ; cin >> n ; long long sum = 0 ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; sum += a [ i ] ; if ( a [ i ] == 0 ) ans ++ ; } if ( sum == 0 ) { if ( ans == n ) { cout << " NO " << endl ; } else { for ( int i = 1 ; i < n ; i ++ ) { if ( summ ( 1 , i ) != 0 && summ ( i + 1 , n ) != 0 ) { cout << " YES " << endl << 2 << endl ; cout << 1 << "   " << i << endl ; cout << i + 1 << "   " << n << endl ; break ; } } } } else { cout << " YES " << endl ; cout << 1 << endl ; cout << 1 << "   " << n << endl ; } return 0 ; }
TAB1 n = int ; TAB1 while read n ; TAB2 a = array of 101 int ; TAB2 for i = 0 to n exclusive read a [ i ] ; TAB2 num = 0 ; TAB2 t = 0 ; TAB2 b = array of 101 int ; TAB2 line = 0 ; TAB2 for i = 0 to n exclusive ; TAB3 if a [ i ] < 0 and t is 2 ; TAB4 b [ line ] = num , increment line ; TAB4 num = 1 ; TAB4 t = 1 ; TAB3 else ; TAB4 if a [ i ] < 0 increment t ; TAB4 increment n ; TAB2 b [ line ] = num , increment line ; TAB2 print line ; TAB2 for i = 0 to line ; TAB3 if i equal line - 1 ; TAB4 print b [ i ] ; TAB3 else ; TAB4 print b [ i ] and space ;	int main ( ) { int n ; while ( cin >> n ) { int a [ 101 ] ; for ( int i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; int num = 0 ; int t = 0 ; int b [ 101 ] ; int line = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] < 0 && t == 2 ) { b [ line ++ ] = num ; num = 1 ; t = 1 ; } else { if ( a [ i ] < 0 ) { t ++ ; } num ++ ; } } b [ line ++ ] = num ; cout << line << endl ; for ( int i = 0 ; i < line ; ++ i ) { if ( i == line - 1 ) cout << b [ i ] << endl ; else cout << b [ i ] << "   " ; } } return 0 ; }
TAB1 declare character arrays a size 10005 , b size 1000005 ; TAB1 while read a is true ; TAB2 read b ; TAB2 declare integer ans ; TAB2 declare integer len = string length of a ; TAB2 declare integer kk = string length of b ; TAB2 declare x = 0 , y = 0 as integers ; TAB2 for ans = 1 , incrementing ans ; TAB3 declare s = 0 as integer ; TAB3 for i = 0 to len exclusive ; TAB4 if a [ i ] is b [ y ] ; TAB5 increment y ; TAB5 increment s ; TAB3 if y is kk ; TAB4 end loop ; TAB3 else if s is 0 ; TAB4 let ans be - 1 ; TAB4 end loop ; TAB3 if ans is greater than or equal to 50000 ; TAB4 let ans be 960000 ; TAB4 end loop ; TAB2 print ans and newline ;	int main ( ) { char a [ 10005 ] , b [ 1000005 ] ; while ( cin >> a ) { cin >> b ; int ans ; int len = strlen ( a ) ; int kk = strlen ( b ) ; int x = 0 , y = 0 ; for ( ans = 1 ; ; ans ++ ) { int s = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] == b [ y ] ) { y ++ ; s ++ ; } } if ( y == kk ) break ; else if ( s == 0 ) { ans = - 1 ; break ; } if ( ans >= 50000 ) { ans = 960000 ; break ; } } cout << ans << endl ; } return 0 ; }
TAB0 Emp_Lang = vector of long integers of size 500 ; TAB0 visited = array of boolean values of length 500 ; TAB0 let DFS be a void function which accepts long integer a ; TAB1 visited [ a ] is equal to true ; TAB1 for long integer i = 0 to Emp_Lang [ a ] . size ( ) exclusive ; TAB2 if not visited [ Emp_Lang [ a ] [ i ] ] , Depth First Search of Emp_Lang [ a ] [ i ] ; TAB1 let n , m be long integers ; TAB1 read n , m ; TAB1 let analphabet be a long integer with analphabet = 0 ; TAB1 for long integer i = 0 to n exclusive ; TAB2 let lang be a long integer ; TAB2 read lang ; TAB2 for long integer j = 0 to lang exclusive ; TAB3 analphabet is equal to 1 ; TAB3 let id be a long integer ; TAB3 read id ; TAB3 push_back id + 200 value in Emp_Lang [ i ] ; TAB3 push_back i value in Emp_Lang [ id + 200 ] ; TAB1 let components be a long integer with components = 0 ; TAB1 for long integer a = 0 to n exclusive ; TAB2 if not visited [ a ] ; TAB3 increment components by 1 ; TAB3 Depth First Search of a ; TAB1 print components - analphabet and newline ;	vector < long long > Emp_Lang [ 500 ] ; bool visited [ 500 ] ; void DFS ( long long a ) { visited [ a ] = true ; for ( long long i = 0 ; i < Emp_Lang [ a ] . size ( ) ; ++ i ) { if ( ! visited [ Emp_Lang [ a ] [ i ] ] ) { DFS ( Emp_Lang [ a ] [ i ] ) ; } } } int main ( ) { long long n , m ; cin >> n >> m ; long long analphabet = 0 ; for ( long long i = 0 ; i < n ; ++ i ) { long long lang ; cin >> lang ; for ( long long j = 0 ; j < lang ; ++ j ) { analphabet = 1 ; long long id ; cin >> id ; Emp_Lang [ i ] . push_back ( id + 200 ) ; Emp_Lang [ id + 200 ] . push_back ( i ) ; } } long long components = 0 ; for ( long long a = 0 ; a < n ; ++ a ) { if ( ! visited [ a ] ) { components ++ ; DFS ( a ) ; } } cout << components - analphabet << endl ; return 0 ; }
TAB0 dp = long long array of size 26 and width 26 ; TAB1 n = long long ; TAB1 read n ; TAB1 st = string ; TAB1 for i = 0 to 26 exclusive , and increase i by 1 at the start of the loop ; TAB2 for j = 0 to 26 exclusive , and increase j by 1 at the start of the loop , then print dp [ i ] [ j ] = - 1e18 in long long form ; TAB1 for i = 0 to n exclusive and increase i by 1 at the start of the loop ; TAB2 read st ; TAB2 f = long long = st [ 0 ] - a ; TAB2 l long long = st [ size of st in long long for - 1 ] - a ; TAB2 le = long long = size of st in long long form ; TAB2 dp [ l ] [ l ] = greater vakue between dp [ l ] [ l ] and dp [ l ] [ f ] + le ; TAB2 for i = 0 to 26 exclusive . and increase i by 1 at the start of the loop ; TAB3 if i is l , then continue ; TAB3 dp [ i ] [ l ] is greater value between dp [ i ] [ l ] and dp [ i ] [ f ] + le ; TAB2 dp [ f ] [ l ] = greater value between dp [ f ] [ l ] and le ; TAB1 ans = long long = 1e18 in long long form ; TAB1 for i = 0 to 26 exclusive and increase i by 1 at the start of the loop , then ans = greater value between ans and dp [ i ] [ i ] ; TAB1 if ans < 0 ; TAB2 print 0 ; TAB1 else ; TAB2 print ans ;	long long dp [ 26 ] [ 26 ] ; int main ( ) { long long n ; cin >> n ; string st ; for ( long long i = 0 ; i < ( 26 ) ; ++ i ) { for ( long long j = 0 ; j < ( 26 ) ; ++ j ) { dp [ i ] [ j ] = - ( long long ) ( 1e18 ) ; } } for ( long long i = 0 ; i < ( n ) ; ++ i ) { cin >> st ; long long f = st [ 0 ] - ' a ' ; long long l = st [ ( long long ) ( ( st ) . size ( ) ) - 1 ] - ' a ' ; long long le = ( long long ) ( ( st ) . size ( ) ) ; dp [ l ] [ l ] = max ( dp [ l ] [ l ] , dp [ l ] [ f ] + le ) ; for ( long long i = 0 ; i < ( 26 ) ; ++ i ) { if ( i == l ) continue ; dp [ i ] [ l ] = max ( dp [ i ] [ l ] , dp [ i ] [ f ] + le ) ; } dp [ f ] [ l ] = max ( dp [ f ] [ l ] , le ) ; } long long ans = - ( long long ) ( 1e18 ) ; for ( long long i = 0 ; i < ( 26 ) ; ++ i ) ans = max ( ans , dp [ i ] [ i ] ) ; if ( ans < 0 ) cout << " 0\n " ; else cout << ans << " \n " ; }
TAB1 declare long long variables n , x , y , bx , by , wx and wy ; TAB1 read n from the user input ; TAB1 read x and y from the input ; TAB1 change the value of wx to x - 1 ; TAB1 set the value of wy to y - 1 ; TAB1 change the value of bx to n - x ; TAB1 change by to n - y ; TAB1 if n = x and n is equal to y ; TAB2 print " Black " ; TAB1 else if x and y are both 1 ; TAB2 print " White " ; TAB1 else ; TAB2 if wx < = by and wy < = bx ; TAB3 print " White " ; TAB2 else ; TAB3 print " Black " ;	int main ( ) { long long n , x , y , bx , by , wx , wy ; cin >> n ; cin >> x >> y ; wx = x - 1 ; wy = y - 1 ; bx = n - x ; by = n - y ; if ( n == x && n == y ) cout << " Black " << endl ; else if ( 1 == x && 1 == y ) cout << " White " << endl ; else { if ( wx <= by && wy <= bx ) cout << " White " << endl ; else cout << " Black " << endl ; } return 0 ; }
TAB0 create const long long oo = 4000000000000000000LL ; TAB0 make long long ints n , m , a , and d ; TAB0 create long long array t of 100100 ; TAB1 read n , m , a , and d ; TAB1 for i = 0 to m exclusive , read t [ i ] ; TAB1 set t [ m + + ] to oo - 1 ; TAB1 create long long ans = 0 ; TAB1 make long long k = ( d / a + 1 ) * a ; TAB1 let long long last_start = - d - 1 ; TAB1 for i = 0 to m exclusive ; TAB2 if t [ i ] is less than or equal to last_start + d , continue loop ; TAB2 make long long first_ai ; TAB2 if last_start + d is less than d ; TAB3 set first_ai to a ; TAB2 else if last_start + d is greater than or equal to n * a ; TAB3 set first_ai to oo ; TAB2 else ; TAB3 set first_ai to ( ( last_start + d ) / a + 1 ) * a ; TAB2 if t [ i ] is less than first_ai ; TAB3 set last_start to t [ i ] ; TAB3 increment ans ; TAB2 else do ; TAB3 set last_start to first_ai ; TAB3 increment ans ; TAB3 make long long int steps ; TAB3 if t [ i ] is greater than n * a ; TAB4 set steps to ( n * a - last_start ) / k ; TAB3 else do ; TAB4 set steps to ( t [ i ] - last_start ) / k ; TAB3 add steps * k to last_start ; TAB3 add steps to ans ; TAB3 if t [ i ] is less than or equal to last_start + d ; TAB4 continue loop ; TAB3 else do ; TAB4 set last_start = t [ i ] ; TAB4 increment ans ; TAB1 display result of ans - 1 ;	const long long oo = 4000000000000000000LL ; long long n , m , a , d ; long long t [ 100100 ] ; int main ( ) { cin >> n >> m >> a >> d ; for ( int i = 0 ; i < m ; ++ i ) { cin >> t [ i ] ; } t [ m ++ ] = oo - 1 ; long long ans = 0 ; long long k = ( d / a + 1 ) * a ; long long last_start = - d - 1 ; for ( int i = 0 ; i < m ; ++ i ) { if ( t [ i ] <= last_start + d ) continue ; long long first_ai ; if ( last_start + d < a ) { first_ai = a ; } else if ( last_start + d >= n * a ) { first_ai = oo ; } else { first_ai = ( ( last_start + d ) / a + 1 ) * a ; } if ( t [ i ] < first_ai ) { last_start = t [ i ] ; ++ ans ; } else { last_start = first_ai ; ++ ans ; long long steps ; if ( t [ i ] > n * a ) { steps = ( n * a - last_start ) / k ; } else { steps = ( t [ i ] - last_start ) / k ; } last_start += steps * k ; ans += steps ; if ( t [ i ] <= last_start + d ) { continue ; } else { last_start = t [ i ] ; ans ++ ; } } } cout << ans - 1 << " \n " ; return 0 ; }
TAB0 make long long int mod = 1e9 + 9 ; TAB0 create ints d , x , and y ; TAB0 declare fastexp taking in long long ints b and p and returning long long integer ; TAB1 if p is 0 , return 1 ; TAB1 create long long int ans = fastexp ( b , p / 2 ) % mod ; TAB1 if p modulo 2 is truthy ; TAB2 return the result of ( ( 1LL * b * ans % mod ) * 1LL * ans ) % mod ; TAB1 else do ; TAB2 return the result of ( 1LL * ans * ans + mod ) % mod ; TAB1 make long long ints a , n , b , and k ; TAB1 create string s ; TAB1 make long long integers v1 , v2 , v3 , and sum = 0 ; TAB1 read n , a , b , and k ; TAB1 read s ; TAB1 for h = 0 to k exclusive ; TAB2 if s [ h ] equals ' + ' ; TAB3 set v1 to fastexp ( a , n - h ) % mod ; TAB3 set v2 to fastexp ( b , h ) % mod ; TAB3 set v3 to ( v1 * v2 + mod ) % mod ; TAB3 set sum to ( sum % mod + v3 % mod + mod ) % mod ; TAB2 else do ; TAB3 set v1 to fastexp ( a , n - h ) ; TAB3 set v2 to return value of fastexp ( b , h ) ; TAB3 set v3 to ( v1 * v2 + mod ) % mod ; TAB3 set sum to ( sum % mod - v3 % mod + mod ) % mod ; TAB1 create long long int v1 = ( n + 1 ) / k ; TAB1 make long long integer inv_a = fastexp ( a , mod - 2 ) % mod ; TAB1 make long long integer vv = ( ( inv_a % mod ) * ( b % mod ) + mod ) % mod ; TAB1 let long long integer vl1 = ( ( fastexp ( vv , k ) % mod ) ) % mod ; TAB1 if vl1 is 1 ; TAB2 create long long int ans = ( ( v1 * sum ) + mod ) % mod ; TAB2 display ans ; TAB1 create long long integer vl4 = fastexp ( vl1 , vl ) % mod ; TAB1 set vl4 to ( vl4 - 1 + mod ) % mod ; TAB1 set vl4 to ( vl4 * sum + mod ) % mod ; TAB1 make long long integer vl2 = ( ( ( vl1 + mod ) % mod ) - 1 + mod ) % mod ; TAB1 create long long integer vl3 = ( vl4 * ( fastexp ( vl2 , mod - 2 ) ) + mod ) % mod ; TAB1 print the result of vl3 % mod ;	long long int mod = 1e9 + 9 ; int d , x , y ; long long int fastexp ( long long int b , long long int p ) { if ( p == 0 ) return 1 ; long long int ans = fastexp ( b , p / 2 ) % mod ; if ( p % 2 ) return ( ( 1LL * b * ans % mod ) * 1LL * ans ) % mod ; else return ( 1LL * ans * ans + mod ) % mod ; } int main ( ) { long long int a , n , b , k ; string s ; long long int v1 , v2 , v3 , sum = 0 ; cin >> n >> a >> b >> k ; cin >> s ; for ( int h = 0 ; h < k ; h ++ ) { if ( s [ h ] == ' + ' ) { v1 = fastexp ( a , n - h ) % mod ; v2 = fastexp ( b , h ) % mod ; v3 = ( v1 * v2 + mod ) % mod ; sum = ( sum % mod + v3 % mod + mod ) % mod ; } else { v1 = fastexp ( a , n - h ) ; v2 = fastexp ( b , h ) ; v3 = ( v1 * v2 + mod ) % mod ; sum = ( sum % mod - v3 % mod + mod ) % mod ; } } long long int vl = ( n + 1 ) / k ; long long int inv_a = fastexp ( a , mod - 2 ) % mod ; long long int vv = ( ( inv_a % mod ) * ( b % mod ) + mod ) % mod ; long long int vl1 = ( ( fastexp ( vv , k ) % mod ) ) % mod ; if ( vl1 == 1 ) { long long int ans = ( ( vl * sum ) + mod ) % mod ; cout << ans << endl ; return 0 ; } long long int vl4 = fastexp ( vl1 , vl ) % mod ; vl4 = ( vl4 - 1 + mod ) % mod ; vl4 = ( vl4 * sum + mod ) % mod ; long long int vl2 = ( ( ( vl1 + mod ) % mod ) - 1 + mod ) % mod ; long long int vl3 = ( vl4 * ( fastexp ( vl2 , mod - 2 ) ) + mod ) % mod ; cout << vl3 % mod << endl ; }
TAB0 let n , k , a , ans , and temp be integers , set ans to 1 ; TAB1 read in n ; TAB1 decrement n ; TAB2 read in k and a ; TAB2 if a is equal to 1 ; TAB3 set tmp to k + 1 ; TAB2 or else ; TAB3 set tmp to k ; TAB3 while a is greater than 1 ; TAB4 set a to ( a - 1 ) / 4 + 1 ; TAB4 increment tmp ; TAB2 if ans is less than tmp , set ans to tmp ; TAB1 print ans ;	int n , k , a , ans = 1 , tmp ; int main ( ) { cin >> n ; while ( n -- ) { cin >> k >> a ; if ( a == 1 ) tmp = k + 1 ; else { tmp = k ; while ( a > 1 ) { a = ( a - 1 ) / 4 + 1 ; ++ tmp ; } } if ( ans < tmp ) ans = tmp ; } cout << ans << endl ; return 0 ; }
TAB0 create vector of integers a ; TAB1 declare new long long variables n and z with z = 0 ; TAB1 read from the input to n ; TAB1 in a for loop , change i from 1 to n inclusive incrementing i ; TAB2 if ( i * ( i + 1 ) ) / 2 < = n ; TAB3 push ( ( i + 1 ) * i ) / 2 into a ; TAB2 else ; TAB3 stop the loop ; TAB1 start for loop from i = 0 to length of a exclusive ; TAB2 if binary_search of n - a [ i ] in a returned true ; TAB3 print " YES " to the standard output ; TAB3 increment z by one ; TAB3 break ; TAB1 if z = 0 , print " NO " ;	vector < int > a ; int main ( ) { long long n , z = 0 ; cin >> n ; for ( long long i = 1 ; i <= n ; i ++ ) { if ( ( i * ( i + 1 ) ) / 2 <= n ) a . push_back ( ( ( i + 1 ) * i ) / 2 ) ; else break ; } for ( long long i = 0 ; i < a . size ( ) ; i ++ ) if ( binary_search ( a . begin ( ) , a . end ( ) , ( n - a [ i ] ) ) ) { cout << " YES " << endl ; z ++ ; break ; } if ( z == 0 ) cout << " NO " << endl ; return 0 ; }
TAB0 function solve ( get long long N , return long long ) ; TAB1 cnt = 0 ; TAB1 for n = 1 to 9 inclusive ; TAB2 if n < = N increment cnt ; TAB1 for n = 11 to 99 by 11 inclusive ; TAB2 if n < = N increment cnt ; TAB1 w = 100 , while w + 1 < = N multiplying w by 10 ; TAB2 for n = 1 to 9 inclusive ; TAB3 v = w * n + ( w - 10 ) + n ; TAB3 if v < = N ; TAB4 add w / 10 to cnt ; TAB3 else ; TAB4 if N modulo 10 > = n increment cnt ; TAB4 add ( N - n * w ) / 10 to cnt ; TAB4 return cnt ; TAB1 return cnt ; TAB1 l , r = long long , while read l and r print solve ( r ) - solve ( l - 1 ) ;	long long solve ( long long N ) { long long cnt = 0 ; for ( int n = 1 ; n <= 9 ; ++ n ) if ( n <= N ) ++ cnt ; for ( int n = 11 ; n <= 99 ; n += 11 ) if ( n <= N ) ++ cnt ; for ( long long w = 100 ; w + 1 <= N ; w *= 10 ) { for ( int n = 1 ; n <= 9 ; ++ n ) { long long v = w * n + ( w - 10 ) + n ; if ( v <= N ) { cnt += w / 10 ; } else { if ( N % 10 >= n ) ++ cnt ; cnt += ( N - n * w ) / 10 ; return cnt ; } } } return cnt ; } int main ( ) { for ( long long l , r ; cin >> l >> r ; ) { cout << solve ( r ) - solve ( l - 1 ) << endl ; } }
TAB1 declare new long longs n and i ; TAB1 read n from the input ; TAB1 declare string s ; TAB1 read user input to s ; TAB1 if n = 1 ; TAB2 if s [ 0 ] is equal to ' 0 ' ; TAB3 print " No \ n " ; TAB2 else ; TAB3 print " Yes \ n " ; TAB1 create long long variable f with value 0 ; TAB1 for i from 1 to n - 1 exclusive ; TAB2 if s [ i ] = ' 0 ' ; TAB3 if s [ i - 1 ] is equal to ' 1 ' or s [ i + 1 ] = ' 1 ' ; TAB4 go to the start of the loop ; TAB3 else ; TAB4 set f to 1 ; TAB2 else ; TAB3 if s [ i - 1 ] and s [ i + 1 ] are not equal to ' 1 ' ; TAB4 skip the rest of the loop ; TAB3 else ; TAB4 assign 1 to f ; TAB1 if s [ 0 ] and s [ 1 ] have the same value , set f to 1 ; TAB1 if s [ n - 1 ] = s [ n - 2 ] , assign 1 to f ; TAB1 if f = 0 ; TAB2 print " Yes \ n " ; TAB1 else ; TAB2 print " No \ n " ;	int main ( ) { long long n , i ; cin >> n ; string s ; cin >> s ; if ( n == 1 ) { if ( s [ 0 ] == ' 0 ' ) cout << " No\n " ; else cout << " Yes\n " ; return 0 ; } long long f = 0 ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' 0 ' ) { if ( s [ i - 1 ] == ' 1 ' || s [ i + 1 ] == ' 1 ' ) continue ; else f = 1 ; } else { if ( s [ i - 1 ] != ' 1 ' && s [ i + 1 ] != ' 1 ' ) continue ; else f = 1 ; } } if ( s [ 0 ] == s [ 1 ] ) f = 1 ; if ( s [ n - 1 ] == s [ n - 2 ] ) f = 1 ; if ( f == 0 ) cout << " Yes\n " ; else cout << " No\n " ; return 0 ; }
TAB0 declare integer array isprime size 4000000 ; TAB0 declare long long array prime size 2000000 ; TAB0 declare integer cnt = 0 ; TAB0 declare integer fac = 1 ; TAB0 declare getprime with no arguments , returning void ; TAB1 fo ri = 2 to 4000000 exclusive , let isprime [ i ] be 1 ; TAB1 let prime [ 1 ] be 0 ; TAB1 for i = 2 to 4000000 exclusive ; TAB2 if not isprime [ i ] , break current loop iteration ; TAB2 for j = i * 2 to 4000000 exclusive , incrementing i by j , let isprime [ j ] be 0 ; TAB2 let prime [ increment cnt ] be i ; TAB0 declare integer isPrime with long long n as argument ; TAB1 if n is less than 4000000 , return isprime [ n ] ; TAB1 for i = 0 to prime [ i ] * prime [ i ] is less than or equal to n , incrementing i ; TAB2 if n % prime [ i ] is 0 , return 0 ; TAB1 return 1 from function ; TAB1 declare long long num ; TAB1 execute getprime ; TAB1 while read num ; TAB2 declare integer sum = 0 ; TAB2 let fac be 1 ; TAB2 declare long long tem = num ; TAB2 if isPrime ( num ) or num is 1 ; TAB3 print 1 , newline , 0 , newline ; TAB3 break current loop iteration ; TAB2 for i = 0 to cnt exclusive ; TAB3 if num % prime [ i ] is 0 ; TAB4 while num % prime [ i ] is 0 ; TAB5 if sum is less than or equal to 2 , let fac be fac * prime [ i ] ; TAB5 increment sum ; TAB5 let num be num / prime [ i ] ; TAB5 if sum is greater than or equal to 2 , break loop ; TAB3 if sum is greater than or equal to 2 , end loop ; TAB2 if sum is greater than or equal to 2 and num is not 1 ; TAB3 print 1 , newline ; TAB3 print fac , newline ; TAB2 else ; TAB3 print 2 and newline ;	int isprime [ 4000000 ] ; long long prime [ 2000000 ] ; int cnt = 0 ; int fac = 1 ; void getprime ( ) { for ( int i = 2 ; i < 4000000 ; i ++ ) isprime [ i ] = 1 ; prime [ 1 ] = 0 ; for ( int i = 2 ; i < 4000000 ; i ++ ) { if ( ! isprime [ i ] ) continue ; for ( int j = i * 2 ; j < 4000000 ; j += i ) isprime [ j ] = 0 ; prime [ cnt ++ ] = i ; } } int isPrime ( long long n ) { if ( n < 4000000 ) return isprime [ n ] ; for ( int i = 0 ; prime [ i ] * prime [ i ] <= n ; i ++ ) if ( n % prime [ i ] == 0 ) return 0 ; return 1 ; } int main ( ) { long long num ; getprime ( ) ; while ( cin >> num ) { int sum = 0 ; fac = 1 ; long long tem = num ; if ( isPrime ( num ) || num == 1 ) { cout << 1 << endl << 0 << endl ; continue ; } for ( int i = 0 ; i < cnt ; i ++ ) { if ( num % prime [ i ] == 0 ) { while ( num % prime [ i ] == 0 ) { if ( sum <= 2 ) fac *= prime [ i ] ; sum ++ ; num /= prime [ i ] ; if ( sum >= 2 ) break ; } } if ( sum >= 2 ) break ; } if ( sum >= 2 && num != 1 ) { cout << 1 << endl ; cout << fac << endl ; } else cout << 2 << endl ; } return 0 ; }
TAB0 M = const integer with M = 10010 ; TAB0 a = integer array of size M ; TAB1 n , m , k = long long integers ; TAB1 read n , m , k ; TAB1 min_v = long long integer with min_v = 1E + 9 ; TAB1 for i = 1 to n ; TAB2 read a [ i ] ; TAB2 if i modulo 2 is 1 and a [ i ] < min_v , min_v = a [ i ] ; TAB1 if n modulo 2 is 0 ; TAB2 print 0 ; TAB1 else ; TAB2 x = long long integer with x = 2 * m / ( n + 1 ) ; TAB2 y = long long integer with y = x * k ; TAB2 ans = long long integer with ans = if y > min_v , min_v else y ; TAB2 print ans ;	const int M = 10000 + 10 ; int a [ M ] ; int main ( ) { long long int n , m , k ; cin >> n >> m >> k ; long long int min_v = 1E+9 ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; if ( i % 2 == 1 && a [ i ] < min_v ) { min_v = a [ i ] ; } } if ( n % 2 == 0 ) { cout << " 0 " << endl ; } else { long long int x = 2 * m / ( n + 1 ) ; long long int y = x * k ; long long int ans = ( y > min_v ? min_v : y ) ; cout << ans << endl ; } return 0 ; }
TAB1 let n , a , b , c , d , sum , sum1 , ans be integers ; TAB1 read n ; TAB1 read a , b , c , d ; TAB1 sum1 is equal to a + b + c + d ; TAB1 ans is equal to n ; TAB1 for i = 1 to n exclusive ; TAB2 read a , b , c , d ; TAB2 sum is equal to a + b + c + d ; TAB2 if sum < = sum1 , decrement ans by 1 ; TAB1 print ans and new line ;	int main ( ) { int n , a , b , c , d , sum , sum1 , ans ; cin >> n ; cin >> a >> b >> c >> d ; sum1 = a + b + c + d ; ans = n ; for ( int i = 1 ; i < n ; i ++ ) { cin >> a >> b >> c >> d ; sum = a + b + c + d ; if ( sum <= sum1 ) { ans -- ; } } cout << ans << endl ; }
TAB1 n , t = integer ; TAB1 while n and t can be read as valid integers ; TAB2 if t < 10 ; TAB3 while looping decrease n by 1 , print t ; TAB2 else ; TAB3 if n is 1 ; TAB4 print - 1 ; TAB3 else ; TAB4 print 1 ; TAB4 decrease n by 1 ; TAB4 while looping decrease n by 1 , print 0 ; TAB2 print endline ;	int main ( ) { int n , t ; while ( cin >> n >> t ) { if ( t < 10 ) while ( n -- ) { cout << t ; } else { if ( n == 1 ) cout << - 1 ; else { cout << 1 ; n -- ; while ( n -- ) cout << 0 ; } } cout << endl ; } return 0 ; }
TAB1 declare new string variable sentence ; TAB1 create an array of characters split with size 110 ; TAB1 read the input to sentence ; TAB1 copy sentence into array split ; TAB1 create new integer variable track ; TAB1 declare new integer n_count with value 0 ; TAB1 i_count is a new integer variable = 0 ; TAB1 declare integer e_count = 0 ; TAB1 declare integer variable with name t_count = 0 ; TAB1 declare new integer nineteen_count with value 0 ; TAB1 start for loop from i = 0 to length of sentence exclusive incrementing i ; TAB2 if split [ i ] is equal to ' n ' , increment n_count ; TAB2 if split [ i ] = ' i ' , increment i_count by one ; TAB2 if split [ i ] = ' e ' , increment e_count ; TAB2 if split [ i ] = ' t ' , increment t_count by one ; TAB1 if n_count > = 3 and i_count > = 1 and e_count > = 3 and t_count > = 1 ; TAB2 increment nineteen_count by one ; TAB2 decrease n_count by 3 ; TAB2 subtract 1 from i_count ; TAB2 change e_count to e_count - 3 ; TAB2 decrease t_count by 1 ; TAB2 looping infinitely ; TAB3 if n_count > = 2 and i_count > = 1 and e_count > = 3 and t_count > = 1 ; TAB4 increment nineteen_count ; TAB4 subtract 2 from n_count ; TAB4 decrease i_count by 1 ; TAB4 decrease e_count by 3 ; TAB4 change t_count to t_count - 1 ; TAB3 else ; TAB4 break the loop ; TAB1 print nineteen_count to the standard output ;	int main ( ) { string sentence ; char split [ 110 ] ; getline ( cin , sentence ) ; strcpy ( split , sentence . c_str ( ) ) ; int track ; int n_count = 0 ; int i_count = 0 ; int e_count = 0 ; int t_count = 0 ; int nineteen_count = 0 ; for ( int i = 0 ; i < sentence . length ( ) ; i ++ ) { if ( split [ i ] == ' n ' ) { n_count ++ ; } if ( split [ i ] == ' i ' ) i_count ++ ; if ( split [ i ] == ' e ' ) e_count ++ ; if ( split [ i ] == ' t ' ) t_count ++ ; } if ( n_count >= 3 && i_count >= 1 && e_count >= 3 && t_count >= 1 ) { nineteen_count ++ ; n_count -= 3 ; i_count -= 1 ; e_count -= 3 ; t_count -= 1 ; while ( true ) { if ( n_count >= 2 && i_count >= 1 && e_count >= 3 && t_count >= 1 ) { nineteen_count ++ ; n_count -= 2 ; i_count -= 1 ; e_count -= 3 ; t_count -= 1 ; } else break ; } } cout << nineteen_count << endl ; }
TAB0 declare constant integer mod = 1e9 + 7 ; TAB0 create constant integer maxn = 1e6 + 5 ; TAB0 power is a long long int function with long long int arguments base , exp and mod ; TAB1 create new long long integer res with value 1 ; TAB1 while exp is not 0 ; TAB2 if exp is odd , change the value of multiply res by base ; TAB2 multiply base by base ; TAB2 change res to the remainder of res divided by mod ; TAB2 change base to base modulo mod ; TAB2 change the value of exp to exp divided by 2 ; TAB1 return res ; TAB0 declare long long int variables n , m and k ; TAB1 read user input to n , m and k ; TAB1 create new long long integer called ans with value mod ; TAB1 for i from 1 to n inclusive ; TAB2 declare long long integer variable x ; TAB2 read variable x from the input ; TAB2 if i is odd , set ans to min of ans and x ; TAB1 if n is even , change the value of ans to 0 ; TAB1 set m to m * 2 ; TAB1 divide m by ( n + 1 ) ; TAB1 print min of ans and m * k and " \ n " to the standard output ;	const int mod = 1e9 + 7 ; const int maxn = 1e6 + 5 ; long long int power ( long long int base , long long int exp , long long int mod ) { long long int res = 1 ; while ( exp ) { if ( exp % 2 ) res *= base ; base *= base ; res %= mod ; base %= mod ; exp /= 2 ; } return res ; } long long int n , m , k ; int main ( ) { cin >> n >> m >> k ; long long int ans = mod ; for ( int i = 1 ; i <= n ; i ++ ) { long long int x ; cin >> x ; if ( i % 2 ) { ans = min ( ans , x ) ; } } if ( n % 2 == 0 ) ans = 0 ; m = m * 2 ; m /= ( n + 1 ) ; cout << min ( ans , m * k ) << " \n " ; return 0 ; }
TAB0 create const integer INF = 0x3f3f3f3f ; TAB1 let int n ; TAB1 read n ; TAB1 let int array row of size n + 10 ; TAB1 create long long integer array ans of size n + 10 ; TAB1 for i = 1 to n , read row [ i ] ; TAB1 for i = 1 to n ; TAB2 create long long int cont = 0 ; TAB2 let int j = row [ i ] ; TAB2 while cont is less than 102 and j is not equal to i ; TAB3 increment cont ; TAB3 set j to row [ j ] ; TAB2 if cont is greater than 1 , increase cont by 1 ; TAB2 set ans [ i ] to cont ; TAB2 if row [ i ] is equal to i , set ans [ i ] to 2 ; TAB2 if ans [ i ] modulo 2 is equal to 0 , set ans [ i ] to ans [ i ] / 2 ; TAB1 create bool flag = true ; TAB1 let long long mult = ans [ 1 ] ; TAB1 for i = 1 to n ; TAB2 if ans [ i ] is equal to 103 ; TAB3 print - 1 ; TAB2 set mult to ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] ) ; TAB1 print mult if flag is truthy or - 1 if not truthy ;	const int INF = 0x3f3f3f3f ; int main ( ) { int n ; cin >> n ; int row [ n + 10 ] ; long long ans [ n + 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> row [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) { long long cont = 0 ; int j = row [ i ] ; while ( cont < 102 and j != i ) { cont ++ ; j = row [ j ] ; } if ( cont > 1 ) ++ cont ; ans [ i ] = cont ; if ( row [ i ] == i ) ans [ i ] = 2 ; if ( ans [ i ] % 2 == 0 ) ans [ i ] /= 2 ; } bool flag = true ; long long mult = ans [ 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ i ] == 103 ) { cout << - 1 << endl ; return 0 ; } mult = ( mult * ans [ i ] ) / __gcd ( mult , ans [ i ] ) ; } cout << ( flag ? mult : - 1 ) << endl ; return 0 ; }
TAB1 declare long long variables a , b , c , d , i and j ; TAB1 read a , b , c and d from the user input ; TAB1 for i from 0 to 100 inclusive ; TAB2 in a for loop , change j from 0 to 100 inclusive incrementing j ; TAB3 if b + a * i is equal to d + c * j ; TAB4 print b + a * i to the standard output ; TAB1 print " - 1 " to the output ;	int main ( ) { long long a , b , c , d , i , j ; cin >> a >> b >> c >> d ; for ( i = 0 ; i <= 100 ; i ++ ) { for ( j = 0 ; j <= 100 ; j ++ ) { if ( ( b + a * i ) == ( d + c * j ) ) { cout << ( b + a * i ) << endl ; return 0 ; } } } cout << " -1 " << endl ; return 0 ; }
TAB1 a = string ; TAB1 n = integer ; TAB1 read a , n ; TAB1 l is an integer set to length of a ; TAB1 if l modulo n ; TAB2 display NO ; TAB1 assign l / n to n ; TAB1 for i = 0 with condition i is less than l with increment add n to i ; TAB2 end = integer = i + n - 1 ; TAB2 begin = integer = i ; TAB2 while begin is at most end ; TAB3 if a [ begin ] equals a [ end ] ; TAB4 increment begin ; TAB4 decrement end ; TAB3 else ; TAB4 display NO ; TAB1 display YES ;	int main ( ) { string a ; int n ; cin >> a >> n ; int l = a . length ( ) ; if ( l % n ) { cout << " NO\n " ; return 0 ; } n = l / n ; for ( int i = 0 ; i < l ; i += n ) { int end = i + n - 1 ; int begin = i ; while ( begin <= end ) { if ( a [ begin ] == a [ end ] ) { begin ++ ; end -- ; } else { cout << " NO\n " ; return 0 ; } } } cout << " YES\n " ; return 0 ; }
TAB0 declare long long MOD = 1000000007 ; TAB0 declare long long vector primes ; TAB0 declare sieve_of_eratosthenes with long long n as argument , returning void ; TAB1 resize primes to size n ; TAB1 for i = 2 to n exclusive , let primes [ i ] be i ; TAB1 for i = 2 to i * i is less than n , incrementing i ; TAB2 if primes [ i ] is true ; TAB3 for j = i * i to n exclusive , incrementing j by i , let primes [ j ] be 0 ; TAB1 for i = 1 to n exclusive ; TAB2 if primes [ i ] is i ; TAB3 let primes [ i ] be primes [ i - 1 ] + 1 ; TAB2 else ; TAB3 let primes [ i ] be primes [ i - 1 ] ; TAB0 declare long long vector pa ; TAB0 declare long long vector t ; TAB0 declare p with long long a as argument , returning boolean ; TAB1 remove all elements from t ; TAB1 while a is greater than 0 ; TAB2 add ( a % 10 ) to end of t ; TAB2 let a be a / 10 ; TAB1 for i = 0 to size of t / 2 exclusive ; TAB2 if t [ i ] is not t [ long long casted size of t - 1 - i ] , return false from function ; TAB1 return true ; TAB1 declare P , Q as long long ; TAB1 read P and Q ; TAB1 declare MX = 1300000 as long long ; TAB1 run sieve_of_eratosthenes ( MX ) ; TAB1 resize pa to size MX , filling new empty with 0 ; TAB1 for i = 1 to size of pa exclusive ; TAB2 if result of run p with i as argument is true ; TAB3 let pa [ i ] be pa [ i - 1 ] + 1 ; TAB2 else ; TAB3 let pa [ i ] be pa [ i - 1 ] ; TAB1 for i = MX - 1 to 0 exclusive , decrementing i ; TAB2 if Q * primes [ i ] is less than or equal to P * pa [ i ] ; TAB3 print i and newline ; TAB1 print " Palindromic tree is better than splay tree " and newline ;	long long MOD = 1000000007 ; vector < long long > primes ; void sieve_of_eratosthenes ( long long n ) { primes . resize ( n ) ; for ( long long i = 2 ; i < n ; ++ i ) primes [ i ] = i ; for ( long long i = 2 ; i * i < n ; ++ i ) if ( primes [ i ] ) for ( long long j = i * i ; j < n ; j += i ) primes [ j ] = 0 ; for ( long long i = 1 ; i < n ; i ++ ) { if ( primes [ i ] == i ) { primes [ i ] = primes [ i - 1 ] + 1 ; } else { primes [ i ] = primes [ i - 1 ] ; } } } vector < long long > pa ; vector < long long > t ; bool p ( long long a ) { t . clear ( ) ; while ( a > 0 ) { t . push_back ( a % 10 ) ; a /= 10 ; } for ( long long i = 0 ; i < t . size ( ) / 2 ; i ++ ) { if ( t [ i ] != t [ ( long long ) t . size ( ) - 1 - i ] ) return false ; } return true ; } int main ( ) { long long P , Q ; cin >> P >> Q ; long long MX = 1300000 ; sieve_of_eratosthenes ( MX ) ; pa . resize ( MX , 0 ) ; for ( long long i = 1 ; i < pa . size ( ) ; i ++ ) { if ( p ( i ) ) pa [ i ] = pa [ i - 1 ] + 1 ; else pa [ i ] = pa [ i - 1 ] ; } for ( long long i = MX - 1 ; i > 0 ; i -- ) { if ( Q * primes [ i ] <= P * pa [ i ] ) { cout << i << endl ; return 0 ; } } cout << " Palindromic tree is better than splay tree " << endl ; }
TAB1 l1 , l2 , r1 , r2 , k , m = unsigned long long with m = 0 ; TAB1 read l1 , r1 , l2 , r2 , k ; TAB1 if ( not ( r2 < l1 or r1 < l2 ) ) ; TAB2 if ( l1 < = l2 ) ; TAB3 if ( r1 < = r2 ) ; TAB4 m = r1 - l2 + 1 - ( k > = l2 and k < = r1 ) ; TAB3 else ; TAB4 m = r2 - l2 + 1 - ( k > = l2 and k < = r2 ) ; TAB2 else ; TAB3 if ( r1 < = r2 ) ; TAB4 m = r1 - l1 + 1 - ( k > = l1 and k < = r1 ) ; TAB3 else ; TAB4 m = r2 - l1 + 1 - ( k > = l1 and k < = r2 ) ; TAB1 print m ;	int main ( ) { unsigned long long l1 , l2 , r1 , r2 , k , m = 0 ; cin >> l1 >> r1 >> l2 >> r2 >> k ; if ( ! ( r2 < l1 or r1 < l2 ) ) { if ( l1 <= l2 ) { if ( r1 <= r2 ) { m = r1 - l2 + 1 - ( k >= l2 and k <= r1 ) ; } else { m = r2 - l2 + 1 - ( k >= l2 and k <= r2 ) ; } } else { if ( r1 <= r2 ) { m = r1 - l1 + 1 - ( k >= l1 and k <= r1 ) ; } else { m = r2 - l1 + 1 - ( k >= l1 and k <= r2 ) ; } } } cout << m << ' \n ' ; }
TAB0 declare new integer variables l1 , l2 and l3 ; TAB0 declare new integer variables j and i , and an arrays of integers a , b , c and d with 5 elements ; TAB0 dx is a new array of int with 4 elements = 1 , 0 , - 1 , 0 ; TAB0 let dy be a new array of integers with 4 values = 0 , 1 , 0 , - 1 ; TAB1 in a for loop , change i from 1 to 3 inclusive and read a [ i ] and b [ i ] from the input on each loop ; TAB1 set l1 to abs ( a [ 1 ] - a [ 2 ] ) * abs ( a [ 1 ] - a [ 2 ] ) + abs ( b [ 1 ] - b [ 2 ] ) * abs ( b [ 1 ] - b [ 2 ] ) ; TAB1 set l2 to abs ( a [ 2 ] - a [ 3 ] ) * abs ( a [ 2 ] - a [ 3 ] ) + abs ( b [ 2 ] - b [ 3 ] ) * abs ( b [ 2 ] - b [ 3 ] ) ; TAB1 change l3 to abs ( a [ 3 ] - a [ 1 ] ) * abs ( a [ 3 ] - a [ 1 ] ) + abs ( b [ 3 ] - b [ 1 ] ) * abs ( b [ 3 ] - b [ 1 ] ) ; TAB1 if l1 + l2 is equal to l3 or l1 + l3 is equal to l2 or l2 + l3 = l1 ; TAB2 if l1 ! = 0 and l2 ! = 0 and l3 ! = 0 ; TAB3 print " RIGHT " ; TAB1 in a for loop , change i from 1 to 3 inclusive ; TAB2 change c [ 1 ] to a [ 1 ] , c [ 2 ] to a [ 2 ] and c [ 3 ] to a [ 3 ] ; TAB2 change d [ 1 ] to b [ 1 ] , value of d [ 2 ] to b [ 2 ] and d [ 3 ] to b [ 3 ] ; TAB2 for j from 0 to 4 exclusive incrementing j ; TAB3 assign a [ i ] + dix [ j ] to c [ i ] ; TAB3 assign b [ i ] + diy [ j ] to d [ i ] ; TAB3 set l1 to abs ( c [ 1 ] - c [ 2 ] ) * abs ( c [ 1 ] - c [ 2 ] ) + abs ( d [ 1 ] - d [ 2 ] ) * abs ( d [ 1 ] - d [ 2 ] ) ; TAB3 assign abs ( c [ 2 ] - c [ 3 ] ) * abs ( c [ 2 ] - c [ 3 ] ) + abs ( d [ 2 ] - d [ 3 ] ) * abs ( d [ 2 ] - d [ 3 ] ) to l2 ; TAB3 set l3 to abs ( c [ 3 ] - c [ 1 ] ) * abs ( c [ 3 ] - c [ 1 ] ) + abs ( d [ 3 ] - d [ 1 ] ) * abs ( d [ 3 ] - d [ 1 ] ) ; TAB3 if l1 + l2 = l3 or l1 + l3 is equal to l2 or l2 + l3 = l1 ; TAB4 if none of l1 , l2 and l3 is 0 ; TAB5 print " ALMOST " to the standard output ; TAB1 print " NEITHER " to the standard output ;	int l1 , l2 , l3 ; int a [ 5 ] , b [ 5 ] , c [ 5 ] , d [ 5 ] , j , i ; int dix [ ] = { 1 , 0 , - 1 , 0 } ; int diy [ ] = { 0 , 1 , 0 , - 1 } ; int main ( ) { for ( i = 1 ; i <= 3 ; i ++ ) { cin >> a [ i ] >> b [ i ] ; } l1 = abs ( a [ 1 ] - a [ 2 ] ) * abs ( a [ 1 ] - a [ 2 ] ) + abs ( b [ 1 ] - b [ 2 ] ) * abs ( b [ 1 ] - b [ 2 ] ) ; l2 = abs ( a [ 2 ] - a [ 3 ] ) * abs ( a [ 2 ] - a [ 3 ] ) + abs ( b [ 2 ] - b [ 3 ] ) * abs ( b [ 2 ] - b [ 3 ] ) ; l3 = abs ( a [ 3 ] - a [ 1 ] ) * abs ( a [ 3 ] - a [ 1 ] ) + abs ( b [ 3 ] - b [ 1 ] ) * abs ( b [ 3 ] - b [ 1 ] ) ; if ( l1 + l2 == l3 || l1 + l3 == l2 || l2 + l3 == l1 ) { if ( l1 != 0 && l2 != 0 && l3 != 0 ) { cout << " RIGHT " << endl ; return 0 ; } } for ( i = 1 ; i <= 3 ; i ++ ) { c [ 1 ] = a [ 1 ] , c [ 2 ] = a [ 2 ] , c [ 3 ] = a [ 3 ] ; d [ 1 ] = b [ 1 ] , d [ 2 ] = b [ 2 ] , d [ 3 ] = b [ 3 ] ; for ( j = 0 ; j < 4 ; j ++ ) { c [ i ] = a [ i ] + dix [ j ] ; d [ i ] = b [ i ] + diy [ j ] ; l1 = abs ( c [ 1 ] - c [ 2 ] ) * abs ( c [ 1 ] - c [ 2 ] ) + abs ( d [ 1 ] - d [ 2 ] ) * abs ( d [ 1 ] - d [ 2 ] ) ; l2 = abs ( c [ 2 ] - c [ 3 ] ) * abs ( c [ 2 ] - c [ 3 ] ) + abs ( d [ 2 ] - d [ 3 ] ) * abs ( d [ 2 ] - d [ 3 ] ) ; l3 = abs ( c [ 3 ] - c [ 1 ] ) * abs ( c [ 3 ] - c [ 1 ] ) + abs ( d [ 3 ] - d [ 1 ] ) * abs ( d [ 3 ] - d [ 1 ] ) ; if ( l1 + l2 == l3 || l1 + l3 == l2 || l2 + l3 == l1 ) { if ( l1 != 0 && l2 != 0 && l3 != 0 ) { cout << " ALMOST " << endl ; return 0 ; } } } } cout << " NEITHER " << endl ; }
TAB1 declare new integer k ; TAB1 read variable k from the input ; TAB1 while k > 0 ; TAB2 create integer variable first_row = - 1 ; TAB2 create new integer called second_row ; TAB2 first_col is a new integer = - 1 ; TAB2 create new integer variable second_col ; TAB2 start for loop from i = 0 to 8 exclusive incrementing i ; TAB3 for integer j = 0 to 8 exclusive incrementing j ; TAB4 declare character variable c ; TAB4 read from the input to c ; TAB4 if c is equal to ' K ' ; TAB5 if first_col = - 1 ; TAB6 change the value of first_row to i ; TAB6 assign j to first_col ; TAB5 else ; TAB6 change the value of second_col to j ; TAB6 set second_row to i ; TAB2 create new integer called dif_row = second_row - first_row ; TAB2 declare new integer dif_col = second_col - first_col ; TAB2 if dif_row is less than 0 , multiply dif_row by - 1 ; TAB2 if dif_col is less than 0 , set dif_col to dif_col multiplied by - 1 ; TAB2 if dif_col and dif_row modulo 4 are both 0 ; TAB3 print " YES " ; TAB2 else ; TAB3 print " NO " ; TAB2 decrement k ;	int main ( ) { int k ; cin >> k ; while ( k > 0 ) { int first_row = - 1 ; int second_row ; int first_col = - 1 ; int second_col ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { char c ; cin >> c ; if ( c == ' K ' ) { if ( first_col == - 1 ) { first_row = i ; first_col = j ; } else { second_col = j ; second_row = i ; } } } } int dif_row = second_row - first_row ; int dif_col = second_col - first_col ; if ( dif_row < 0 ) dif_row *= - 1 ; if ( dif_col < 0 ) dif_col *= - 1 ; if ( dif_col % 4 == 0 && dif_row % 4 == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } k -- ; } return 0 ; }
TAB0 declare constant integer maxn = 1e2 + 20 ; TAB0 declare integer n ; TAB0 declare string arrays s size maxn , t size maxn , x size maxn ; TAB0 declare is with no arguments , returning boolean ; TAB1 for i = 0 to n exclusive ; TAB2 if s [ i ] is not t [ i ] , return 0 from function ; TAB1 return 1 from function ; TAB0 declare rotate with no arguments , returning void ; TAB1 for i = 0 to n exclusive ; TAB2 let x [ i ] be " " ; TAB2 for j = 0 to n exclusive , increment x [ i ] by s [ j ] [ n - i - 1 ] ; TAB1 for i = 0 to n exclusive , let s [ i ] be x [ i ] ; TAB0 declare solve with no arguments , returning boolean ; TAB1 for i = 0 to 2 exclusive ; TAB2 for i = 0 to n exclusive , reverse sort ( beginning of s [ i ] to end of s [ i ] ) ; TAB2 for j = 0 to 4 exclusive ; TAB3 if result of run is , is true , return 1 from function ; TAB3 run rotate ; TAB1 read n ; TAB1 for i = 0 to n exclusive , read s [ i ] ; TAB1 for i = 0 to n exclusive , read t [ i ] ; TAB1 declare boolean f = 0 ; TAB1 let f be f bitwise or result of run solve ; TAB1 for i = 0 to n - i - 1 exclusive , swap values between s [ i ] and s [ n - i - 1 ] ; TAB1 let f be f bitwise or result of run solve ; TAB1 print " Yes " if f is true , else " No " , print newline ;	const int maxn = 1e2 + 20 ; int n ; string s [ maxn ] , t [ maxn ] , x [ maxn ] ; bool is ( ) { for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] != t [ i ] ) return 0 ; return 1 ; } void rotate ( ) { for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = "  " ; for ( int j = 0 ; j < n ; j ++ ) x [ i ] += s [ j ] [ n - i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) s [ i ] = x [ i ] ; } bool solve ( ) { for ( int i = 0 ; i < 2 ; i ++ ) { for ( int i = 0 ; i < n ; i ++ ) reverse ( s [ i ] . begin ( ) , s [ i ] . end ( ) ) ; for ( int j = 0 ; j < 4 ; j ++ ) { if ( is ( ) ) return 1 ; rotate ( ) ; } } return 0 ; } int main ( ) { cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; for ( int i = 0 ; i < n ; i ++ ) cin >> t [ i ] ; bool f = 0 ; f |= solve ( ) ; for ( int i = 0 ; i < n - i - 1 ; i ++ ) swap ( s [ i ] , s [ n - i - 1 ] ) ; f |= solve ( ) ; cout << ( f ? " Yes " : " No " ) << endl ; }
TAB0 create long long vector prime of size 10000005 and value 0 ; TAB0 declare mM taking in long long ints a , b , and mod and returning long long ; TAB1 create long long res = 0 ; TAB1 set a to a % mod ; TAB1 while b is truthy ; TAB2 if b & 1 is truthy , set res to ( res + a ) % mod ; TAB2 set a to ( 2 * a ) % mod ; TAB2 move bits of b 1 place to the right ; TAB1 return res ; TAB0 declare fpow taking long long ints first , second , and p and returning long long integer ; TAB1 set first to first % p ; TAB1 make long long res = 1 ; TAB1 while second is truthy ; TAB2 if second & 1 is truthy , set res to ( res * first ) % p ; TAB2 set res to res % p ; TAB2 if res is less than 0 , set res to ( res + p ) % p ; TAB2 set second to second > > 1 ; TAB2 set first to ( first * first ) % p ; TAB2 if first is less than 0 , set first to ( first + p ) % p ; TAB2 set first to first % p ; TAB1 return res ; TAB0 declare inv taking in long long int n and returning long long ; TAB1 return the result of fpow ( n , 1000000007 - 2 , 1000000007 ) ; TAB0 declare modmul taking in long long ints first and second and returning long long ; TAB1 return ( ( first % 1000000007 ) * ( second % 1000000007 ) ) % 1000000007 ; TAB0 declare modadd taking in long long ints first and second and returning long long integer ; TAB1 create long long temp = first % 1000000007 + second % 1000000007 ; TAB1 set temp to temp % 1000000007 ; TAB1 if temp is less than 0 , set temp to ( temp + 1000000007 ) % 1000000007 ; TAB1 return temp ; TAB0 declare sieve ; TAB1 set prime [ 1 ] to 1 ; TAB1 for i = 2 to 10000005 exclusive ; TAB2 if prime [ i ] is falsy ; TAB3 for j = i to 10000005 exclusive ; TAB4 if ! prime [ j ] is truthy , set prime [ j ] to i ; TAB1 create long long integer t ; TAB1 set t to 1 ; TAB1 while t - - is truthy ; TAB2 create long long integer n ; TAB2 read n ; TAB2 make string vector s of size n ; TAB2 for i = 0 to n exclusive , read s [ i ] ; TAB2 make string w ; TAB2 create char tc ; TAB2 read w and tc ; TAB2 make long long vector check of size w . size ( ) and value 0 ; TAB2 for i = 0 to n exclusive ; TAB3 for j = 0 to w . size ( ) exclusive ; TAB4 create string s1 = w . substr ( j , s [ i ] . size ( ) ) ; TAB4 create bool ok = true ; TAB4 if size of s1 is less than size of s [ i ] ; TAB5 set ok to false ; TAB4 else do ; TAB5 make string temp = s [ i ] ; TAB5 make all contents of temp lowercase ; TAB5 make all content of s1 lowercase ; TAB5 if s1 is not equal to temp , set ok to false ; TAB4 if ok is truthy ; TAB5 for k = j while k < j + s [ i ] . size ( ) , set check [ k ] to 1 ; TAB2 for i = 0 to w . size ( ) exclusive ; TAB3 if check [ i ] is truthy ; TAB4 create char temp = w [ i ] ; TAB4 if temp is greater than or equal to ' A ' and temp is less than or equal to ' Z ' ; TAB5 set temp to temp - ' A ' ; TAB4 else do ; TAB5 subtract ' a ' from temp ; TAB4 add ' a ' to temp ; TAB4 if temp is equal to tc and tc is equal to ' a ' ; TAB5 if w [ i ] is greater than or equal to ' a ' and w [ i ] is less than or equal to ' z ' ; TAB6 set w [ i ] to ' b ' ; TAB5 else do ; TAB6 set w [ i ] to ' B ' ; TAB4 else if temp is equal to tc and tc is not equal to ' a ' ; TAB5 if w [ i ] is greater than or equal to ' a ' and w [ i ] is less than or equal to ' z ' ; TAB6 set w [ i ] to ' a ' ; TAB5 otherwise ; TAB6 set w [ i ] to ' A ' ; TAB4 else ; TAB5 if w [ i ] is greater than or equal to ' a ' and w [ i ] is less than or equal to ' z ' ; TAB6 set w [ i ] to tc ; TAB5 else do ; TAB6 set w [ i ] to tc - ' a ' + ' A ' ; TAB2 print w ;	vector < long long > prime ( 10000005 , 0 ) ; long long mM ( long long a , long long b , long long mod ) { long long res = 0 ; a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; } long long fpow ( long long first , long long second , long long p ) { first = first % p ; long long res = 1 ; while ( second ) { if ( second & 1 ) res = ( res * first ) % p ; res %= p ; if ( res < 0 ) res = ( res + p ) % p ; second = second >> 1 ; first = ( first * first ) % p ; if ( first < 0 ) first = ( first + p ) % p ; first %= p ; } return res ; } long long inv ( long long n ) { return fpow ( n , 1000000007 - 2 , 1000000007 ) ; } long long modmul ( long long first , long long second ) { return ( ( first % 1000000007 ) * ( second % 1000000007 ) ) % 1000000007 ; } long long modadd ( long long first , long long second ) { long long temp = first % 1000000007 + second % 1000000007 ; temp %= 1000000007 ; if ( temp < 0 ) temp = ( temp + 1000000007 ) % 1000000007 ; return temp ; } void sieve ( ) { prime [ 1 ] = 1 ; for ( long long i = 2 ; i < 10000005 ; i ++ ) if ( ! prime [ i ] ) for ( long long j = i ; j < 10000005 ; j += i ) if ( ! prime [ j ] ) prime [ j ] = i ; } int main ( ) { long long t ; t = 1 ; while ( t -- ) { long long n ; cin >> n ; vector < string > s ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> s [ i ] ; string w ; char tc ; cin >> w >> tc ; vector < long long > check ( w . size ( ) , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < w . size ( ) ; j ++ ) { string s1 = w . substr ( j , s [ i ] . size ( ) ) ; bool ok = true ; if ( s1 . size ( ) < s [ i ] . size ( ) ) ok = false ; else { string temp = s [ i ] ; transform ( temp . begin ( ) , temp . end ( ) , temp . begin ( ) , :: tolower ) ; transform ( s1 . begin ( ) , s1 . end ( ) , s1 . begin ( ) , :: tolower ) ; if ( s1 != temp ) ok = false ; } if ( ok ) for ( int k = j ; k < j + s [ i ] . size ( ) ; k ++ ) check [ k ] = 1 ; } for ( int i = 0 ; i < w . size ( ) ; i ++ ) if ( check [ i ] ) { char temp = w [ i ] ; if ( temp >= ' A ' && temp <= ' Z ' ) temp -= ' A ' ; else temp -= ' a ' ; temp += ' a ' ; if ( temp == tc && tc == ' a ' ) { if ( w [ i ] >= ' a ' && w [ i ] <= ' z ' ) w [ i ] = ' b ' ; else w [ i ] = ' B ' ; } else if ( temp == tc && tc != ' a ' ) { if ( w [ i ] >= ' a ' && w [ i ] <= ' z ' ) w [ i ] = ' a ' ; else w [ i ] = ' A ' ; } else { if ( w [ i ] >= ' a ' && w [ i ] <= ' z ' ) w [ i ] = tc ; else w [ i ] = tc - ' a ' + ' A ' ; } } cout << w << " \n " ; } }
TAB1 new long longs rest = 0 , t , cou = 0 , minn = 1e7 , index = 1e8 ; TAB1 a is an 2d array of long longs with size 105 by 2 ; TAB1 read t and cou and keep looping ; TAB2 for integer i = 0 to t exclusive incrementing i ; TAB3 read from the input to a [ i ] [ 0 ] and a [ i ] [ 1 ] ; TAB3 if a [ i ] [ 1 ] ! = 0 and a [ i ] [ 0 ] < cou ; TAB4 change minn to min of minn and a [ i ] [ 1 ] ; TAB3 else if a [ i ] [ 0 ] < = cou ; TAB4 assign min of index and a [ i ] [ 1 ] to index ; TAB2 set rest to 100 - minn ; TAB2 if rest is equal to 100 or minn = 1e7 ; TAB3 if index ! = 0 ; TAB4 print " - 1 " to the standard output ; TAB3 else ; TAB4 print 0 ; TAB2 else ; TAB3 print rest ;	int main ( ) { long long rest = 0 , t , cou = 0 , minn = 1e7 , index = 1e8 ; long long a [ 105 ] [ 2 ] ; while ( cin >> t >> cou ) { for ( int i = 0 ; i < t ; i ++ ) { cin >> a [ i ] [ 0 ] >> a [ i ] [ 1 ] ; if ( a [ i ] [ 1 ] != 0 and a [ i ] [ 0 ] < cou ) { minn = min ( minn , a [ i ] [ 1 ] ) ; } else if ( a [ i ] [ 0 ] <= cou ) index = min ( index , a [ i ] [ 1 ] ) ; } rest = 100 - minn ; if ( rest == 100 || minn == 1e7 ) { if ( index != 0 ) cout << " -1 " << endl ; else cout << 0 << endl ; } else cout << rest << endl ; } return 0 ; }
TAB1 create long longs t1 , t2 , x1 , x2 , t0 , res_x and res_y ; TAB1 read user input to t1 , t2 , x1 , x2 and t0 ; TAB1 declare doubles t and ct with ct = 1e99 ; TAB1 while x1 > = 0 & & x2 > = 0 ; TAB2 change the value of t to ( t1 * x1 + t2 * x2 * 1 . 0 ) / ( x1 + x2 ) ; TAB2 if t is less than t0 ; TAB3 decrement x1 by one ; TAB3 go to the start of the loop ; TAB2 if t is less than ct ; TAB3 assign t to ct ; TAB3 assign x1 to res_x ; TAB3 change the value of res_y to x2 ; TAB2 decrement x2 ; TAB1 print res_x , ' ' and res_y to the output stream ;	int main ( ) { long long t1 , t2 , x1 , x2 , t0 , res_x , res_y ; cin >> t1 >> t2 >> x1 >> x2 >> t0 ; double t , ct = 1e99 ; while ( x1 >= 0 && x2 >= 0 ) { t = ( t1 * x1 + t2 * x2 * 1.0 ) / ( x1 + x2 ) ; if ( t < t0 ) { x1 -- ; continue ; } if ( t < ct ) { ct = t ; res_x = x1 ; res_y = x2 ; } x2 -- ; } cout << res_x << '   ' << res_y << endl ; }
TAB1 declare integers n , i ; TAB1 declare string str ; TAB1 read n ; TAB1 read str ; TAB1 declare integer flag = 0 ; TAB1 declare integer count = 0 ; TAB1 for i = 0 to i is less than i and flag is 0 ; TAB2 if str [ i ] is not ' > ' ; TAB3 increment count ; TAB2 else ; TAB3 let flag be 1 ; TAB1 let flag be 0 ; TAB1 for i = n - 1 to i is greater than or equal to 0 and flag is 0 , decrementing i ; TAB2 if str [ i ] is not ' < ' ; TAB3 increment count ; TAB2 else ; TAB3 let flag be 1 ; TAB1 print count and ' \ n ' ;	int main ( ) { int n , i ; string str ; cin >> n ; cin >> str ; int flag = 0 ; int count = 0 ; for ( i = 0 ; i < n && flag == 0 ; i ++ ) { if ( str [ i ] != ' > ' ) { count ++ ; } else { flag = 1 ; } } flag = 0 ; for ( i = n - 1 ; i >= 0 && flag == 0 ; i -- ) { if ( str [ i ] != ' < ' ) { count ++ ; } else { flag = 1 ; } } cout << count << ' \n ' ; return 0 ; }
TAB1 let ans , n , mx be integers with ans = 0 , mx = 0 ; TAB1 the boolean value of inc = 1 ; TAB1 read n ; TAB1 arr = array of integers of length n + 1 ; TAB1 for i = 1 to n inclusive , read arr [ i ] ; TAB1 if arr [ n ] is equal to n ; TAB2 mx is equal to n - 1 ; TAB1 else do the following ; TAB2 for i = 1 to n inclusive ; TAB3 if 1000 - arr [ i ] is equal to n - i , mx is equal to maximum of mx and n - i ; TAB3 if arr [ i ] is equal to i and i is greater than 1 , mx is equal to maximum of mx and i - 1 ; TAB2 for i = 1 to n inclusive ; TAB3 if i is less than n and arr [ i ] + 1 is equal to arr [ i + 1 ] ; TAB4 let st , en be integers with st = i , en = - 1 ; TAB4 for integer j = i + 1 to n inclusive ; TAB5 if arr [ j ] is equal to arr [ j - 1 ] + 1 ; TAB6 proceed to next ; TAB5 else do the following ; TAB6 en is equal to j - 1 ; TAB6 stop ; TAB4 if en is equal to - 1 , en is equal to n ; TAB4 mx is equal to maximum of mx and en - st - 1 ; TAB1 print mx and newline ;	int main ( ) { int ans = 0 , n , mx = 0 ; bool inc = 1 ; cin >> n ; int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) cin >> arr [ i ] ; if ( arr [ n ] == n ) mx = n - 1 ; else { for ( int i = 1 ; i <= n ; i ++ ) { if ( 1000 - arr [ i ] == n - i ) { mx = max ( mx , n - i ) ; } if ( arr [ i ] == i && i > 1 ) mx = max ( mx , i - 1 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i < n && arr [ i ] + 1 == arr [ i + 1 ] ) { int st = i , en = - 1 ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( arr [ j ] == arr [ j - 1 ] + 1 ) continue ; else { en = j - 1 ; break ; } } if ( en == - 1 ) en = n ; mx = max ( mx , en - st - 1 ) ; } } } cout << mx << " \n " ; return 0 ; }
TAB1 n , m , i , j = int , l = 0 ; TAB1 read n ; TAB1 i = 1 , while true incrementing i at end of while ; TAB2 j = n * i + 1 ; TAB2 for k = 2 to j exclusive ; TAB3 if j is multiple of k ; TAB4 l = 1 ; TAB4 break ; TAB2 if l is 1 ; TAB3 print i ; TAB3 break ;	int main ( ) { int n , m , i , j , l = 0 ; cin >> n ; for ( i = 1 ; ; i ++ ) { j = ( n * i ) + 1 ; for ( int k = 2 ; k < j ; k ++ ) { if ( j % k == 0 ) { l = 1 ; break ; } } if ( l == 1 ) { cout << i << endl ; break ; } } return 0 ; }
TAB1 let n , d be integers ; TAB1 read n , d ; TAB1 create a vector v of integers with values n , 0 ; TAB1 for i = 0 to n exclusive ; TAB2 let point be a integer ; TAB2 read point ; TAB2 v [ i ] is equal to point ; TAB1 let result be a long integer with result = 0 ; TAB1 for integer right is equal to 0 , left is equal to 0 , right is less than n , increment right by 1 ; TAB2 while v [ right ] - v [ left ] is greater than d , increment left by 1 ; TAB2 result is equal to result + ( long long ) ( right - left ) * ( right - left - 1 ) / 2 ; TAB1 print result and newline ;	int main ( ) { int n , d ; cin >> n >> d ; vector < int > v ( n , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int point ; cin >> point ; v [ i ] = point ; } long long result = 0 ; for ( int right = 0 , left = 0 ; right < n ; right ++ ) { while ( v [ right ] - v [ left ] > d ) { left ++ ; } result += ( long long ) ( right - left ) * ( right - left - 1 ) / 2 ; } cout << result << endl ; return 0 ; }
TAB0 declare new integer n ; TAB1 create new int called n ; TAB1 read n from the input ; TAB1 new integer variable thomasT with value 0 ; TAB1 temp is a new integer with value 0 ; TAB1 for i from 0 to 4 exclusive incrementing i ; TAB2 read temp from the input ; TAB2 change thomasT to the sum of thomasT and temp ; TAB1 studentTS is a new array of integers with size n - 1 ; TAB1 assign 0 to the first n - 1 elements of studentTS ; TAB1 start for loop from i = 0 to n - 1 exclusive ; TAB2 in a for loop , change j from 0 to 4 exclusive ; TAB3 read variable temp from the input ; TAB3 change studentTS [ i ] to the sum of studentTS [ i ] and temp ; TAB1 sort studentTS from 0 to n - 1 ; TAB1 create new integer variable ans with value 1 ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if studentTS [ i ] is greater than thomasT , increment ans ; TAB1 print ans ;	int n ; int main ( ) { int n ; cin >> n ; int thomasT = 0 ; int temp = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { cin >> temp ; thomasT += temp ; } int studentTS [ n - 1 ] ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) studentTS [ i ] = 0 ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { cin >> temp ; studentTS [ i ] += temp ; } } sort ( studentTS , studentTS + ( n - 1 ) ) ; int ans = 1 ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) if ( studentTS [ i ] > thomasT ) ans += 1 ; cout << ans << endl ; return 0 ; }
TAB0 vec = int vector array of size 3 ; TAB0 like = string and int map ; TAB0 diff , ans , a , b , c = int and mat = two dimensional int array of sizes 10 and 10 ; TAB0 in function cal returning an int ; TAB1 sum , i , j , k = int with sum = 0 ; TAB1 for i = 0 to 3 ; TAB2 for j = 0 to size of vec [ i ] ; TAB3 for k = 0 to size of vec [ i ] increment sum by mat [ vec [ i ] [ j ] ] [ vec [ i ] [ k ] ] ; TAB1 return sum ; TAB0 in function count taking an int now ; TAB1 if now is 7 ; TAB2 if size of vec [ 0 ] and size of vec [ 1 ] and size of vec [ 2 ] are all not 0 ; TAB3 x = int array with the values a / size of vec [ 0 ] , b / size of vec [ 1 ] and c / size of vec [ 2 ] ; TAB3 sort x ; TAB3 if x [ 2 ] - x [ 0 ] is less than diff ; TAB4 set diff to x [ 2 ] - x [ 0 ] ; TAB4 set ans to cal ; TAB3 else if x [ 2 ] - x [ 0 ] is diff ; TAB4 set ans to max of ans and cal ; TAB2 return ; TAB1 for i = 0 to 3 ; TAB2 append now to vec [ i ] ; TAB2 call count of now + 1 ; TAB2 remove last value of vec [ i ] ; TAB1 set like [ " Anka " ] to 0 ; TAB1 set like [ " Chapay " ] to 1 ; TAB1 set like [ " Cleo " ] to 2 ; TAB1 set like [ " Troll " ] to 3 ; TAB1 set like [ " Dracul " ] to 4 ; TAB1 set like [ " Snowy " ] to 5 ; TAB1 set like [ " Hexadecimal " ] to 6 ; TAB1 n , i = int ; TAB1 name1 , str , name2 = string ; TAB1 loop while reading n ; TAB2 set diff to ( 1 bitshift right by 31 ) - 1 ; TAB2 for i = 0 to 3 clear vec [ i ] ; TAB2 set all values of mat to 0 ; TAB2 for i = 0 to n ; TAB3 read name1 then str then name2 ; TAB3 increment mat [ like [ name1 ] ] [ like [ name2 ] ] ; TAB2 read a then b then c ; TAB2 call count of 0 ; TAB2 print diff and ans ;	vector < int > vec [ 3 ] ; map < string , int > like ; int diff , mat [ 10 ] [ 10 ] , ans , a , b , c ; int cal ( ) { int sum = 0 , i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < vec [ i ] . size ( ) ; j ++ ) for ( k = 0 ; k < vec [ i ] . size ( ) ; k ++ ) sum += mat [ vec [ i ] [ j ] ] [ vec [ i ] [ k ] ] ; } return sum ; } void count ( int now ) { if ( now == 7 ) { if ( vec [ 0 ] . size ( ) && vec [ 1 ] . size ( ) && vec [ 2 ] . size ( ) ) { int x [ ] = { a / vec [ 0 ] . size ( ) , b / vec [ 1 ] . size ( ) , c / vec [ 2 ] . size ( ) } ; sort ( x , x + 3 ) ; if ( x [ 2 ] - x [ 0 ] < diff ) { diff = x [ 2 ] - x [ 0 ] ; ans = cal ( ) ; } else if ( x [ 2 ] - x [ 0 ] == diff ) ans = max ( ans , cal ( ) ) ; } return ; } for ( int i = 0 ; i < 3 ; i ++ ) { vec [ i ] . push_back ( now ) ; count ( now + 1 ) ; vec [ i ] . pop_back ( ) ; } } int main ( ) { like [ " Anka " ] = 0 ; like [ " Chapay " ] = 1 ; like [ " Cleo " ] = 2 ; like [ " Troll " ] = 3 ; like [ " Dracul " ] = 4 ; like [ " Snowy " ] = 5 ; like [ " Hexadecimal " ] = 6 ; int n , i ; string name1 , str , name2 ; while ( cin >> n ) { diff = ( 1 << 31 ) - 1 ; for ( i = 0 ; i < 3 ; i ++ ) vec [ i ] . clear ( ) ; memset ( mat , 0 , sizeof ( mat ) ) ; for ( i = 0 ; i < n ; i ++ ) { cin >> name1 >> str >> name2 ; mat [ like [ name1 ] ] [ like [ name2 ] ] ++ ; } cin >> a >> b >> c ; count ( 0 ) ; cout << diff << "   " << ans << endl ; } }
TAB0 create new array of integers cnt with 101 element ; TAB1 create string variable s ; TAB1 read user input to s ; TAB1 change i from 0 to length of s exclusive in a loop , incrementing cnt [ s [ i ] - ' a ' ] on each iteration ; TAB1 print min ( ( cnt [ 13 ] - 1 ) / 2 , min ( cnt [ 4 ] / 3 , min ( cnt [ 8 ] , cnt [ 19 ] ) ) ) ;	int cnt [ 101 ] ; int main ( ) { string s ; cin >> s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s [ i ] - ' a ' ] ++ ; cout << min ( ( cnt [ 13 ] - 1 ) / 2 , min ( cnt [ 4 ] / 3 , min ( cnt [ 8 ] , cnt [ 19 ] ) ) ) << endl ; return 0 ; }
TAB1 let a , b = strings ; TAB1 let c , d , cnt = integers ; TAB1 let flag = integer ; TAB1 while ( read a , b ) is true do the following ; TAB2 if the size of a is less than the size of b do the following ; TAB3 print NO ; TAB3 continue at the beginning of the loop ; TAB2 else do the following ; TAB3 set flag to 1 ; TAB3 sent cnt to 0 ; TAB3 for i = 0 to the size of a exclusive , do the following ; TAB4 if a [ i ] is not equal to b [ i ] and cnt is 0 do the following ; TAB5 increment cnt ; TAB5 set c to i ; TAB4 else if a [ i ] is not equal to b [ i ] and cnt is 1 do the following ; TAB5 increment cnt ; TAB5 set d to i ; TAB4 else if a [ i ] is not equal to b [ i ] and cnt is 2 do the following ; TAB5 print NO ; TAB5 set flag to 0 ; TAB5 exit the loop ; TAB3 if flag is 0 ; TAB4 continue at the beginning of the loop ; TAB3 else do the following ; TAB4 if cnt is 1 do the following ; TAB5 print NO ; TAB5 continue at the beginning of the loop ; TAB4 if a [ c ] is b [ d ] and a [ d ] is b [ c ] ; TAB5 print YES ; TAB4 else ; TAB5 print NO ;	int main ( ) { string a , b ; int c , d , cnt ; int flag ; while ( cin >> a >> b ) { if ( a . size ( ) != b . size ( ) ) { cout << " NO " << endl ; continue ; } else { flag = 1 ; cnt = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( a [ i ] != b [ i ] && cnt == 0 ) { cnt ++ ; c = i ; } else if ( a [ i ] != b [ i ] && cnt == 1 ) { cnt ++ ; d = i ; } else if ( a [ i ] != b [ i ] && cnt == 2 ) { cout << " NO " << endl ; flag = 0 ; break ; } } if ( flag == 0 ) { continue ; } else { if ( cnt == 1 ) { cout << " NO " << endl ; continue ; } if ( a [ c ] == b [ d ] && a [ d ] == b [ c ] ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } } } return 0 ; }
TAB1 signed long long int a , b , c , d , k , q , l and ou ; TAB1 read from the input to a , b , c , d and k ; TAB1 set q to max of a and c ; TAB1 set l to min of b and d ; TAB1 change ou to l - q + 1 ; TAB1 if q < = k < = l decrement ou by one ; TAB1 if ou is less than 0 , set ou to 0 ; TAB1 print ou ;	int main ( ) { signed long long int a , b , c , d , k , q , l , ou ; cin >> a >> b >> c >> d >> k ; q = max ( a , c ) ; l = min ( b , d ) ; ou = l - q + 1 ; if ( k <= l && k >= q ) ou -- ; if ( ou < 0 ) ou = 0 ; cout << ou << endl ; return 0 ; }
TAB0 str1 = array of characters of length 10010 ; TAB0 str2 = array of characters of length 10010 ; TAB0 dp = 2d array of integers with 5050 rows and 5050 columns respectively ; TAB1 read str1 + 1 ; TAB1 read str2 + 1 ; TAB1 the integer value of lenth1 = string length of ( str1 + 1 ) ; TAB1 the integer value of lenth2 = string length of ( str2 + 1 ) ; TAB1 let i , j be integers ; TAB1 the integer value of sum = 0 ; TAB1 for i = 1 to lenth1 inclusive ; TAB2 for j = 1 to lenth2 inclusive ; TAB3 dp [ i ] [ j ] is equal to dp [ i ] [ j - 1 ] ; TAB3 if str1 [ i ] is equal to str2 [ j ] ; TAB4 dp [ i ] [ j ] is equal to ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) modulo 1000000007 ; TAB4 sum is equal to ( sum + dp [ i - 1 ] [ j - 1 ] + 1 ) modulo 1000000007 ; TAB1 print sum and newline ;	char str1 [ 10010 ] ; char str2 [ 10010 ] ; int dp [ 5050 ] [ 5050 ] ; int main ( ) { cin >> str1 + 1 ; cin >> str2 + 1 ; int lenth1 = strlen ( str1 + 1 ) ; int lenth2 = strlen ( str2 + 1 ) ; int i , j ; int sum = 0 ; for ( i = 1 ; i <= lenth1 ; i ++ ) for ( j = 1 ; j <= lenth2 ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( str1 [ i ] == str2 [ j ] ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) % 1000000007 ; sum = ( sum + dp [ i - 1 ] [ j - 1 ] + 1 ) % 1000000007 ; } } cout << sum << endl ; }
TAB1 create long longs n , m , k , cnt and mn with value of mn = 1e9 ; TAB1 read variables n , m and k from the input ; TAB1 start for loop from i = 0 to n exclusive incrementing i ; TAB2 create new integer variable x ; TAB2 read the data from the input to x ; TAB2 if i is even , change mn to min of mn and 1ll * x ; TAB1 change cnt to m / ( ( n + 1 ) / 2 ) ; TAB1 change the value of cnt to cnt multiplied by k ; TAB1 create long long variable ans with value min of cnt and mn ; TAB1 if n is even , set ans to 0 ; TAB1 print ans to the standard output ;	int main ( ) { long long n , m , k , cnt , mn = 1e9 ; cin >> n >> m >> k ; for ( int i = 0 ; i < n ; i ++ ) { int x ; cin >> x ; if ( i % 2 == 0 ) mn = min ( mn , 1ll * x ) ; } cnt = m / ( ( n + 1 ) / 2 ) ; cnt *= k ; long long ans = min ( cnt , mn ) ; if ( n % 2 == 0 ) ans = 0 ; cout << ans << endl ; return 0 ; }
TAB1 a , b , rev , i = integers ; TAB1 st = string ; TAB1 read st ; TAB1 a = ( st [ 0 ] - 48 ) * 10 + ( st [ 1 ] - 48 ) ; TAB1 b = ( st [ 3 ] - 48 ) * 10 + ( st [ 4 ] - 48 ) ; TAB1 rev = ( st [ 1 ] - 48 ) * 10 + ( st [ 0 ] - 48 ) ; TAB1 if a is 23 and b < 32 ; TAB2 print 23 : 32 ; TAB1 else if a is 23 and b > = 32 ; TAB2 print 00 : 00 ; TAB1 else if rev > b and rev < = 59 ; TAB2 print st [ 0 ] , st [ 1 ] , " : " , rev ; TAB1 else ; TAB2 for i = 1 ; TAB3 if st [ 1 ] - 48 + i > = 1 and st [ 1 ] - 48 + i < = 5 ; TAB4 print st [ 0 ] st [ 1 ] - 48 + i , : , st [ 1 ] - 48 + i , st [ 0 ] ; TAB4 break loop ; TAB3 else if st [ 1 ] - 48 + i is 10 ; TAB4 print st [ 0 ] - 48 + 1 , 0 : 0 , st [ 0 ] - 48 + 1 ; TAB4 break loop ; TAB3 else ; TAB4 continue next iteration ;	int main ( ) { int a , b , rev , i ; string st ; cin >> st ; a = ( st [ 0 ] - 48 ) * 10 + ( st [ 1 ] - 48 ) ; b = ( st [ 3 ] - 48 ) * 10 + ( st [ 4 ] - 48 ) ; rev = ( st [ 1 ] - 48 ) * 10 + ( st [ 0 ] - 48 ) ; if ( a == 23 && b < 32 ) { cout << " 23:32\n " ; } else if ( a == 23 && b >= 32 ) { cout << " 00:00\n " ; } else if ( rev > b && rev <= 59 ) { cout << st [ 0 ] << st [ 1 ] << " : " << rev << endl ; } else { for ( i = 1 ; ; i ++ ) { if ( st [ 1 ] - 48 + i >= 1 && st [ 1 ] - 48 + i <= 5 ) { cout << st [ 0 ] << st [ 1 ] - 48 + i << " : " << st [ 1 ] - 48 + i << st [ 0 ] << endl ; break ; } else if ( st [ 1 ] - 48 + i == 10 ) { cout << st [ 0 ] - 48 + 1 << " 0:0 " << st [ 0 ] - 48 + 1 << endl ; break ; } else { continue ; } } } return 0 ; }
TAB1 n , m , inds = integers with inds = - 1 ; TAB1 s , t = strings ; TAB1 read n , m , s , t ; TAB1 for i = 0 to n exclusive ; TAB2 if ( s [ i ] is * ) , inds = 1 ; TAB1 if ( inds is - 1 and s is not t ) ; TAB2 print NO ; TAB1 if ( m + 1 < n ) ; TAB2 print NO ; TAB1 for i = n - 1 , j = m - 1 down to i > = 0 and j > = 0 ; TAB2 if ( s [ i ] is t [ j ] ) ; TAB3 s [ i ] = * ; TAB2 else if s [ i ] is * ; TAB3 break loop ; TAB2 else ; TAB3 print NO ; TAB1 for i = 0 to s . size ( ) exclusive ; TAB2 if ( s [ i ] is t [ i ] ) ; TAB3 s [ i ] = * ; TAB2 else if ( s [ i ] is * ; TAB3 break loop ; TAB1 for i = 0 to n exclusive ; TAB2 if ( s [ i ] is * or s [ i ] is ' ' ) ; TAB3 continue next iteration ; TAB2 else ; TAB3 print NO ; TAB1 print YES ;	int main ( ) { int n , m , inds = - 1 ; string s , t ; cin >> n >> m >> s >> t ; for ( int i = 0 ; i < n ; ++ i ) if ( s [ i ] == ' * ' ) inds = 1 ; if ( inds == - 1 && s != t ) { cout << " NO " << endl ; return 0 ; } if ( m + 1 < n ) { cout << " NO " << endl ; return 0 ; } for ( int i = n - 1 , j = m - 1 ; i >= 0 && j >= 0 ; -- i , -- j ) { if ( s [ i ] == t [ j ] ) s [ i ] = ' * ' ; else if ( s [ i ] == ' * ' ) break ; else { cout << " NO " << endl ; return 0 ; } } for ( int i = 0 ; i < s . size ( ) ; ++ i ) { if ( s [ i ] == t [ i ] ) s [ i ] = ' * ' ; else if ( s [ i ] == ' * ' ) break ; } for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == ' * ' || s [ i ] == '   ' ) continue ; else { cout << " NO " << endl ; return 0 ; } } cout << " YES " << endl ; }
TAB1 k = integer ; TAB1 read k ; TAB1 while k > 0 ; TAB2 first_row = integer = - 1 ; TAB2 second_row = integer ; TAB2 first_col = integer = - 1 ; TAB2 second_col = integer ; TAB2 for i = 0 to 8 exclusive ; TAB3 for j = 0 to 8 exclusive ; TAB4 c = character ; TAB4 read c ; TAB4 if c is K ; TAB5 if first_col is - 1 ; TAB6 first_row = i ; TAB6 first_col = j ; TAB5 else ; TAB6 second_col = j ; TAB6 second_row = i ; TAB2 dif_row = integer = second_row - first_row ; TAB2 dif_col = integer = second_col - first_col ; TAB2 if dif_row < 0 , then dif_row = dif_row * - 1 ; TAB2 if dif_col < 0 , then dif_col = dif_col * - 1 ; TAB2 dif = integer = dif_col + dif_row ; TAB2 if dif_col modulo 4 is 0 and dif_row modulo 4 is 0 ; TAB3 print YES ; TAB2 else ; TAB3 print NO ; TAB2 decrease k by 1 ;	int main ( ) { int k ; cin >> k ; while ( k > 0 ) { int first_row = - 1 ; int second_row ; int first_col = - 1 ; int second_col ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { char c ; cin >> c ; if ( c == ' K ' ) { if ( first_col == - 1 ) { first_row = i ; first_col = j ; } else { second_col = j ; second_row = i ; } } } } int dif_row = second_row - first_row ; int dif_col = second_col - first_col ; if ( dif_row < 0 ) dif_row *= - 1 ; if ( dif_col < 0 ) dif_col *= - 1 ; int dif = dif_col + dif_row ; if ( dif_col % 4 == 0 && dif_row % 4 == 0 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } k -- ; } return 0 ; }
TAB0 par is a integer array of size 200001 ; TAB0 v is a vector of integers ; TAB1 n be integer ; TAB1 read n ; TAB1 for integer i = 2 to n inclusive , read par [ i ] ; TAB1 integer cur equals n ; TAB1 while cur is not 1 ; TAB2 push cur into v ; TAB2 cur equals par [ cur ] ; TAB1 push cur into v ; TAB1 reverse v ; TAB1 for integer i = 0 to size of v exclusive ; TAB2 print v [ i ] ; TAB2 if i not equals i ! = ( int ) v . size ( ) - 1 , print space ; TAB1 print endline ;	int par [ 200001 ] ; vector < int > v ; int main ( ) { int n ; cin >> n ; for ( int i = 2 ; i <= n ; i ++ ) cin >> par [ i ] ; int cur = n ; while ( cur != 1 ) { v . push_back ( cur ) ; cur = par [ cur ] ; } v . push_back ( cur ) ; reverse ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { cout << v [ i ] ; if ( i != ( int ) v . size ( ) - 1 ) cout << '   ' ; } cout << endl ; return 0 ; }
TAB1 n , m , g = integers ; TAB1 read n and m ; TAB1 arr = array of integers with length 105 ; TAB1 for i = 0 to n exclusive , print arr [ i ] ; TAB1 for i = n ; TAB2 for j = 0 to n exclusive ; TAB3 if arr [ j ] > 0 ; TAB4 decrement arr [ j ] by m ; TAB4 if arr [ j ] < = 0 ; TAB5 set g to j ; TAB5 decrement i by 1 ; TAB1 print g + 1 ;	int main ( ) { int n , m , g ; cin >> n >> m ; int arr [ 105 ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; } for ( int i = n ; i ; ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > 0 ) { arr [ j ] -= m ; if ( arr [ j ] <= 0 ) { g = j ; i -- ; } } } } cout << g + 1 << endl ; return 0 ; }
TAB0 int function Plos with int arguments x , y and n ; TAB1 declare integer variable P1 ; TAB1 if y is equal to 0 ; TAB2 set P1 to 1 ; TAB1 else if y = n ; TAB2 set P1 to 3 ; TAB1 else if x = 0 ; TAB2 set P1 to 4 ; TAB1 else if x = n ; TAB2 set P1 to 2 ; TAB1 return P1 ; TAB0 create enum Position with values p1 = 1 , p2 , p3 and p4 ; TAB0 integer function fun2 with int arguments x1 , y1 , x2 , y2 and n , Posution argument T1 and bool argument b1 ; TAB1 declare int variable Md = 0 ; TAB1 looping infinitely ; TAB2 if T1 is equal to p1 ; TAB3 if y1 is equal to y2 ; TAB4 add abs ( x1 - x2 ) to Md ; TAB4 stop the loop ; TAB3 if b1 = false ; TAB4 increase Md by n - x1 ; TAB4 change x1 to n ; TAB4 change T1 to p2 casted to Posution ; TAB3 else ; TAB4 increase Md by x1 ; TAB4 assign 0 to x1 ; TAB4 change T1 to p4 casted to Posution ; TAB2 else if T1 = p2 ; TAB3 if x1 = x2 ; TAB4 increase Md by abs ( y1 - y2 ) ; TAB4 stop the loop ; TAB3 if b1 is false ; TAB4 increase Md by n - y1 ; TAB4 set y1 to n ; TAB4 assign p3 casted to Posution to T1 ; TAB3 else ; TAB4 add y1 to Md ; TAB4 change y1 to 0 ; TAB4 assign p1 casted to Posution to T1 ; TAB2 else if T1 = p3 ; TAB3 if y1 = y2 ; TAB4 add abs ( x1 - x2 ) to Md ; TAB4 break the loop ; TAB3 if b1 = false ; TAB4 add x1 to Md ; TAB4 set T1 to p4 casted to Posution ; TAB4 set x1 to 0 ; TAB3 else ; TAB4 add n - x1 to Md ; TAB4 change x1 to n ; TAB4 assign p2 casted to Posution to T1 ; TAB2 else if T1 = p4 ; TAB3 if x1 is equal to x2 ; TAB4 increase Md by abs ( y1 - y2 ) ; TAB4 break the loop ; TAB3 if b1 = false ; TAB4 change T1 to p1 casted to Posution ; TAB4 increase Md by y1 ; TAB4 change y1 to 0 ; TAB3 else ; TAB4 add n - y1 to Md ; TAB4 change y1 to n ; TAB4 change T1 to p3 casted to Posution ; TAB1 return Md ; TAB1 declare int variables n , x1 , y1 , x2 and y2 ; TAB1 create input stream ff for " file . txt " ; TAB1 read n , x1 , y1 , x2 and y2 ; TAB1 if x1 is equal to x2 and y1 = y2 ; TAB2 print 0 ; TAB1 create ints Mv and Md = 0 ; TAB1 declare integer P1 = Plos ( x1 , y1 , n ) ; TAB1 create Posution T1 ; TAB1 assign P1 casted to Posution to T1 ; TAB1 change Mv to the result of fun2 ( x1 , y1 , x2 , y2 , n , T1 , false ) ; TAB1 set Md to the result of fun2 ( x1 , y1 , x2 , y2 , n , T1 , true ) ; TAB1 print min of Mv and Md ;	int Plos ( int x , int y , int n ) { int P1 ; if ( y == 0 ) { P1 = 1 ; } else if ( y == n ) { P1 = 3 ; } else if ( x == 0 ) { P1 = 4 ; } else if ( x == n ) { P1 = 2 ; } return P1 ; } enum Posution { p1 = 1 , p2 , p3 , p4 } ; int fun2 ( int x1 , int y1 , int x2 , int y2 , int n , Posution T1 , bool b1 ) { int Md = 0 ; while ( true ) { if ( T1 == p1 ) { if ( y1 == y2 ) { Md += abs ( x1 - x2 ) ; break ; } if ( b1 == false ) { Md += n - x1 ; x1 = n ; T1 = ( Posution ) ( p2 ) ; } else { Md += x1 ; x1 = 0 ; T1 = ( Posution ) ( p4 ) ; } } else if ( T1 == p2 ) { if ( x1 == x2 ) { Md += abs ( y1 - y2 ) ; break ; } if ( b1 == false ) { Md += n - y1 ; y1 = n ; T1 = ( Posution ) ( p3 ) ; } else { Md += y1 ; y1 = 0 ; T1 = ( Posution ) ( p1 ) ; } } else if ( T1 == p3 ) { if ( y1 == y2 ) { Md += abs ( x1 - x2 ) ; break ; } if ( b1 == false ) { Md += x1 ; T1 = ( Posution ) ( p4 ) ; x1 = 0 ; } else { Md += n - x1 ; x1 = n ; T1 = ( Posution ) ( p2 ) ; } } else if ( T1 == p4 ) { if ( x1 == x2 ) { Md += abs ( y1 - y2 ) ; break ; } if ( b1 == false ) { T1 = ( Posution ) ( p1 ) ; Md += y1 ; y1 = 0 ; } else { Md += n - y1 ; y1 = n ; T1 = ( Posution ) ( p3 ) ; } } } return Md ; } int main ( ) { int n , x1 , y1 , x2 , y2 ; ifstream ff ( " file.txt " ) ; cin >> n >> x1 >> y1 >> x2 >> y2 ; if ( x1 == x2 && y1 == y2 ) { cout << 0 << endl ; return 0 ; } int Mv = 0 , Md = 0 ; int P1 = Plos ( x1 , y1 , n ) ; Posution T1 ; T1 = ( Posution ) ( P1 ) ; Mv = fun2 ( x1 , y1 , x2 , y2 , n , T1 , false ) ; Md = fun2 ( x1 , y1 , x2 , y2 , n , T1 , true ) ; cout << min ( Mv , Md ) << endl ; return 0 ; }
TAB1 n , a = int ; TAB1 read n , a ; TAB1 mina , maxa = a , mini , maxi = 0 ; TAB1 for i = 1 to n exclusive ; TAB2 read a ; TAB2 if a > maxa ; TAB3 maxa = a ; TAB3 maxi = i ; TAB2 if a < = mina ; TAB3 mina = a ; TAB3 mini = i ; TAB1 print maxi + ( n - 1 - mini ) - ( 1 if mini < maxi else 0 ) ;	int main ( ) { int n , a ; cin >> n >> a ; int mina ( a ) , maxa ( a ) , mini ( 0 ) , maxi ( 0 ) ; for ( int i = 1 ; i < n ; ++ i ) { cin >> a ; if ( a > maxa ) { maxa = a ; maxi = i ; } if ( a <= mina ) { mina = a ; mini = i ; } } cout << maxi + ( n - 1 - mini ) - ( mini < maxi ? 1 : 0 ) << endl ; return 0 ; }
TAB0 create a long long integer mod = 1e9 + 9 ; TAB0 into the function qm which takes two long long integers a and b and returns a long long int ; TAB1 let ans be long long int with ans = 1 ; TAB1 while b > 0 do the following ; TAB2 if b & 1 then set ans = ans * a % mod ; TAB2 set b = b > > 1 ; TAB2 set a = a * a % mod ; TAB1 return ( ans % mod + mod ) % mod ; TAB0 c = character array of size 1000005 ; TAB1 n , a , b , k = long long ints ; TAB1 read n , a , b , k ; TAB1 read c ; TAB1 create long long int ans = 0 ; TAB1 if n + 1 < = k ; TAB2 for i = 0 to n inclusive ; TAB3 if c [ i ] = - ; TAB4 then set ans = ans - qm ( a , n - i ) * qm ( b , i ) ; TAB4 set ans = ( ans % mod + mod ) % mod ; TAB3 else do the following ; TAB4 set ans = ans + qm ( a , n - i ) * qm ( b , i ) ; TAB4 set ans = ( ans % mod + mod ) % mod ; TAB2 set ans = ( ans % mod + mod ) % mod ; TAB2 print ans ; TAB1 else do the following ; TAB2 create long long t = ( n + 1 ) / k ; TAB2 creaye long long integer g = ( n + 1 ) % k ; TAB2 let x = 0 be a long long integer ; TAB2 if g is equal to 0 ; TAB3 for i = 0 to k exclusive ; TAB4 if c [ i ] is equal to - ; TAB5 then set x = x - qm ( a , n - i ) * qm ( b , i ) ; TAB5 set x = ( x % mod + mod ) % mod ; TAB4 else do the following ; TAB5 set x = x + qm ( a , n - i ) * qm ( b , i ) ; TAB5 assign ( x % mod + mod ) % mod to x ; TAB3 if qm ( a , k ) = qm ( b , k ) ; TAB4 then set ans = t * t ; TAB4 assign ( ans % mod + mod ) % mod to ans ; TAB4 print ans ; TAB3 create long long integer jj = qm ( a , t * k ) - qm ( b , t * k ) ; TAB3 set jj = x * jj % mod ; TAB3 set jj = jj * qm ( a , k ) % mod ; TAB3 do nothing ; TAB3 set jj = jj % mod ; TAB3 create long long integer nn = qm ( a , k ) - qm ( b , k ) ; TAB3 set nn = nn % mod ; TAB3 assign nn * qm ( a , t * k ) to nn ; TAB3 set nn = nn % mod ; TAB3 set nn = qm ( nn , mod - 2 ) ; TAB3 assign jj * nn to ans ; TAB3 set ans to ( ans % mod + mod ) % mod ; TAB3 print ans ; TAB2 else do the following ; TAB3 for i = 0 to k exclusive ; TAB4 if c [ i ] is equal to - ; TAB5 set x = x - qm ( a , n - i ) * qm ( b , i ) ; TAB5 set x = ( x % mod + mod ) % mod ; TAB4 else do the following ; TAB5 set x to x + qm ( a , n - i ) * qm ( b , i ) ; TAB5 assign ( x % mod + mod ) % mod to x ; TAB3 if qm ( a , k ) = = qm ( b , k ) ; TAB4 then set ans = t * x ; TAB4 set ans = ( ans % mod + mod ) % mod ; TAB4 for hh = 0 to g exclusive ; TAB5 if c [ hh ] is equal to - ; TAB6 set ans = ans - qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; TAB6 set ans = ( ans % mod + mod ) % mod ; TAB5 else do the following ; TAB6 set ans = ans + qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; TAB6 set ans = ( ans % mod + mod ) % mod ; TAB4 set ans = ( ans % mod + mod ) % mod ; TAB4 print ans ; TAB3 create long long integer jj = qm ( a , t * k ) - qm ( b , t * k ) ; TAB3 set jj to x * jj % mod ; TAB3 set jj = jj * qm ( a , k ) % mod ; TAB3 do nothing ; TAB3 assign jj % mod to jj ; TAB3 create long long integer nn = ( qm ( a , k ) - qm ( b , k ) ) ; TAB3 set nn = nn % mod ; TAB3 assign nn * qm ( a , t * k ) to nn ; TAB3 set nn = nn % mod ; TAB3 set nn = qm ( nn , mod - 2 ) ; TAB3 set ans = jj * nn ; TAB3 set ans = ( ans % mod + mod ) % mod ; TAB3 for hh = 0 to g exclusive ; TAB4 if c [ hh ] is - ; TAB5 set ans = ans - qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; TAB5 set ans = ( ans % mod + mod ) % mod ; TAB4 else do the following ; TAB5 set ans = ans + qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; TAB5 set ans = ( ans % mod + mod ) % mod ; TAB3 set ans = ( ans % mod + mod ) % mod ; TAB3 print ans ;	long long mod = 1e9 + 9 ; long long qm ( long long a , long long b ) { long long ans = 1 ; while ( b > 0 ) { if ( b & 1 ) ans = ans * a % mod ; b >>= 1 ; a = a * a % mod ; } return ( ans % mod + mod ) % mod ; } char c [ 1000005 ] ; int main ( ) { long long n , a , b , k ; cin >> n >> a >> b >> k ; cin >> c ; long long ans = 0 ; if ( n + 1 <= k ) { for ( long long i = 0 ; i <= n ; i ++ ) { if ( c [ i ] == ' - ' ) { ans = ans - qm ( a , n - i ) * qm ( b , i ) ; ans = ( ans % mod + mod ) % mod ; } else { ans = ans + qm ( a , n - i ) * qm ( b , i ) ; ans = ( ans % mod + mod ) % mod ; } } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; } else { long long t = ( n + 1 ) / k ; long long g = ( n + 1 ) % k ; long long x = 0 ; if ( g == 0 ) { for ( long long i = 0 ; i < k ; i ++ ) { if ( c [ i ] == ' - ' ) { x = x - qm ( a , n - i ) * qm ( b , i ) ; x = ( x % mod + mod ) % mod ; } else { x = x + qm ( a , n - i ) * qm ( b , i ) ; x = ( x % mod + mod ) % mod ; } } if ( qm ( a , k ) == qm ( b , k ) ) { ans = t * x ; ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; return 0 ; } long long jj = qm ( a , t * k ) - qm ( b , t * k ) ; jj = x * jj % mod ; jj = jj * qm ( a , k ) % mod ; ; jj = jj % mod ; long long nn = ( qm ( a , k ) - qm ( b , k ) ) ; nn = nn % mod ; nn = nn * qm ( a , t * k ) ; nn = nn % mod ; nn = qm ( nn , mod - 2 ) ; ans = jj * nn ; ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; } else { for ( long long i = 0 ; i < k ; i ++ ) { if ( c [ i ] == ' - ' ) { x = x - qm ( a , n - i ) * qm ( b , i ) ; x = ( x % mod + mod ) % mod ; } else { x = x + qm ( a , n - i ) * qm ( b , i ) ; x = ( x % mod + mod ) % mod ; } } if ( qm ( a , k ) == qm ( b , k ) ) { ans = t * x ; ans = ( ans % mod + mod ) % mod ; for ( long long hh = 0 ; hh < g ; hh ++ ) { if ( c [ hh ] == ' - ' ) { ans = ans - qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; ans = ( ans % mod + mod ) % mod ; } else { ans = ans + qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; ans = ( ans % mod + mod ) % mod ; } } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; return 0 ; } long long jj = qm ( a , t * k ) - qm ( b , t * k ) ; jj = x * jj % mod ; jj = jj * qm ( a , k ) % mod ; ; jj = jj % mod ; long long nn = ( qm ( a , k ) - qm ( b , k ) ) ; nn = nn % mod ; nn = nn * qm ( a , t * k ) ; nn = nn % mod ; nn = qm ( nn , mod - 2 ) ; ans = jj * nn ; ans = ( ans % mod + mod ) % mod ; for ( long long hh = 0 ; hh < g ; hh ++ ) { if ( c [ hh ] == ' - ' ) { ans = ans - qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; ans = ( ans % mod + mod ) % mod ; } else { ans = ans + qm ( a , n - ( t * k + hh ) ) * qm ( b , ( t * k + hh ) ) ; ans = ( ans % mod + mod ) % mod ; } } ans = ( ans % mod + mod ) % mod ; cout << ans << endl ; } } }
TAB0 q is a queue of integers ; TAB1 declare ints n and x ; TAB1 read input to n ; TAB1 declare integer variable ancnt = 0 ; TAB1 declare int variable cnt = 1 ; TAB1 declare int len = 0 ; TAB1 decrement n and loop further , while n ! = 0 ; TAB2 read x ; TAB2 increment len by one ; TAB2 if x is less than 0 , increment ancnt by one ; TAB2 if ancnt is greater than 2 ; TAB3 assign 1 to ancnt ; TAB3 push len - 1 into q ; TAB3 change len to 1 ; TAB1 push len into q ; TAB1 print length of q ; TAB1 declare integer numsize = length of q ; TAB1 loop i from 0 to numsize exclusive ; TAB2 if i ! = 0 , print " " ; TAB2 print first element of q ; TAB2 remove first element of q ; TAB2 if i = numsize - 1 , print new line ;	queue < int > q ; int main ( ) { int n , x ; cin >> n ; int ancnt = 0 ; int cnt = 1 ; int len = 0 ; while ( n -- ) { cin >> x ; len ++ ; if ( x < 0 ) { ancnt ++ ; } if ( ancnt > 2 ) { ancnt = 1 ; q . push ( len - 1 ) ; len = 1 ; } } q . push ( len ) ; cout << q . size ( ) << endl ; int numsize = q . size ( ) ; for ( int i = 0 ; i < numsize ; i ++ ) { if ( i != 0 ) { cout << "   " ; } cout << q . front ( ) ; q . pop ( ) ; if ( i == numsize - 1 ) { cout << endl ; } } return 0 ; }
TAB0 let n , m , ans , cnt ints and father an empty int array of length 101 , with ans and cnt = 0 ; TAB0 let f an empty 2d bool array of size 101 by 101 ; TAB0 in function find that takes int x and returns an int ; TAB1 if father [ x ] is not x , set father [ x ] = find ( father [ x ] ) and return result ; TAB1 return x ; TAB0 in function check that takes ints x and y and returns a bool ; TAB1 set x to find ( x ) ; TAB1 set y to find ( y ) ; TAB1 if x equals y , return false ; TAB1 set father [ x ] to y ; TAB1 return true ; TAB1 let i , j , and k ints ; TAB1 read n and m ; TAB1 for i from 1 to n , set father [ i ] to i ; TAB1 for i from 1 to n ; TAB2 read j ; TAB2 while ( decrement j ) ; TAB3 read k ; TAB3 set f [ i ] [ k ] to true ; TAB3 add f [ i ] [ k ] to cnt ; TAB1 for i from 1 to n ; TAB2 for j from i + 1 to n ; TAB3 for k from 1 to m ; TAB4 if f [ i ] [ k ] and f [ j ] [ k ] , add check ( i , j ) to ans ; TAB1 if not cnt ; TAB2 print n ; TAB1 otherwise ; TAB2 print n - ans - 1 ;	int n , m , father [ 101 ] = { } , ans = 0 , cnt = 0 ; bool f [ 101 ] [ 101 ] = { } ; int find ( int x ) { if ( father [ x ] != x ) return father [ x ] = find ( father [ x ] ) ; return x ; } bool check ( int x , int y ) { x = find ( x ) ; y = find ( y ) ; if ( x == y ) return false ; father [ x ] = y ; return true ; } int main ( ) { int i , j , k ; cin >> n >> m ; for ( i = 1 ; i <= n ; ++ i ) father [ i ] = i ; for ( i = 1 ; i <= n ; ++ i ) { cin >> j ; while ( j -- ) { cin >> k ; f [ i ] [ k ] = true ; cnt += f [ i ] [ k ] ; } } for ( i = 1 ; i <= n ; ++ i ) for ( j = i + 1 ; j <= n ; ++ j ) for ( k = 1 ; k <= m ; ++ k ) if ( f [ i ] [ k ] && f [ j ] [ k ] ) ans += check ( i , j ) ; if ( ! cnt ) cout << n << endl ; else cout << n - ans - 1 << endl ; return 0 ; }
TAB1 create integer n ; TAB1 while read n is true ; TAB2 create string array a with size 101 ; TAB2 create integer set b ; TAB2 create integer set c ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 for j = 0 to n exclusive ; TAB4 if a [ i ] [ j ] is ' . ' ; TAB5 insert i into b ; TAB5 insert j into c ; TAB2 if size of b is less than n and size of c is less than n ; TAB3 print " - 1 " print newline ; TAB2 else ; TAB3 if size of b is n ; TAB4 for i = 0 to n exclusive ; TAB5 for j = 0 to n exclusive ; TAB6 if a [ i ] [ j ] is ' . ' ; TAB7 print i + 1 print " " print j + 1 print newline ; TAB7 break loop ; TAB3 else ; TAB4 for i = 0 to n exclusive ; TAB5 for j = 0 to n exclusive ; TAB6 if a [ j ] [ i ] is ' . ' ; TAB7 print j + 1 print " " print i + 1 print newline ; TAB7 break loop ;	int main ( ) { int n ; while ( cin >> n ) { string a [ 101 ] ; set < int > b ; set < int > c ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; for ( int j = 0 ; j < n ; ++ j ) { if ( a [ i ] [ j ] == ' . ' ) { b . insert ( i ) ; c . insert ( j ) ; } } } if ( b . size ( ) < n && c . size ( ) < n ) cout << " -1 " << endl ; else { if ( b . size ( ) == n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; i < n ; ++ j ) { if ( a [ i ] [ j ] == ' . ' ) { cout << i + 1 << "   " << j + 1 << endl ; break ; } } } } else { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; i < n ; ++ j ) { if ( a [ j ] [ i ] == ' . ' ) { cout << j + 1 << "   " << i + 1 << endl ; break ; } } } } } } return 0 ; }
TAB1 declare string variable s ; TAB1 read s ; TAB1 if length of s < = 2 ; TAB2 print " No " ; TAB1 else ; TAB2 for i = 0 to length of s - 2 exclusive ; TAB3 if s [ i ] is equal to ' A ' and s [ i + 1 ] is equal to ' B ' and s [ i + 2 ] is equal to ' C ' ; TAB4 print " Yes " ; TAB3 if s [ i ] is ' C ' and s [ i + 1 ] is ' A ' and s [ i + 2 ] is ' B ' ; TAB4 print " Yes " ; TAB3 if s [ i ] = ' A ' and s [ i + 1 ] = ' C ' and s [ i + 2 ] = ' B ' ; TAB4 print " Yes " ; TAB3 if s [ i ] = ' B ' and s [ i + 1 ] = ' A ' and s [ i + 2 ] = ' C ' ; TAB4 print " Yes " ; TAB3 if s [ i ] = ' B ' and s [ i + 1 ] = ' C ' and s [ i + 2 ] = ' A ' ; TAB4 print " Yes " ; TAB3 if s [ i ] = ' C ' and s [ i + 1 ] = ' B ' and s [ i + 2 ] = ' A ' ; TAB4 print " Yes " ; TAB2 print " No " ;	int main ( ) { string s ; cin >> s ; if ( s . length ( ) <= 2 ) cout << " No " << endl ; else { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s [ i ] == ' A ' && s [ i + 1 ] == ' B ' && s [ i + 2 ] == ' C ' ) { cout << " Yes " << endl ; return 0 ; } if ( s [ i ] == ' C ' && s [ i + 1 ] == ' A ' && s [ i + 2 ] == ' B ' ) { cout << " Yes " << endl ; return 0 ; } if ( s [ i ] == ' A ' && s [ i + 1 ] == ' C ' && s [ i + 2 ] == ' B ' ) { cout << " Yes " << endl ; return 0 ; } if ( s [ i ] == ' B ' && s [ i + 1 ] == ' A ' && s [ i + 2 ] == ' C ' ) { cout << " Yes " << endl ; return 0 ; } if ( s [ i ] == ' B ' && s [ i + 1 ] == ' C ' && s [ i + 2 ] == ' A ' ) { cout << " Yes " << endl ; return 0 ; } if ( s [ i ] == ' C ' && s [ i + 1 ] == ' B ' && s [ i + 2 ] == ' A ' ) { cout << " Yes " << endl ; return 0 ; } } cout << " No " << endl ; } }
TAB0 s = string ; TAB0 check = boolean array of size 2 ; TAB0 d = integer array of size 100001 , width of 2 , and depth of 2 ; TAB0 in function go with argument integer x , integer y , and integer z and returns an integer ; TAB1 if x > = size of s ; TAB2 if y and z are nonzero , then return 1 ; TAB1 if d [ x ] [ y ] [ z ] is not - 1 , then return d [ x ] [ y ] [ z ] ; TAB1 d [ x ] [ y ] [ z ] = the result of calling go with arguments x + 1 , y , z ; TAB1 if x < size of s - 1 and s [ x ] is A and s [ x + 1 ] is B and y is 0 , then d [ x ] [ y ] [ z ] is the bigger value between d [ x ] [ y ] [ z ] and the result of calling go with arguments x + 2 , 1 , z ; TAB1 if x < size of s - 1 and s [ x ] is B and s [ x + 1 ] is A and y is 0 , then d [ x ] [ y ] [ z ] is the bigger value between d [ x ] [ y ] [ z ] and the result of calling go with arguments x + 2 , y , 1 ; TAB1 return d [ x ] [ y ] [ z ] ; TAB1 read s ; TAB1 set all values of d to - 1 ; TAB1 if the result of calling go with arguments 0 , 0 , 0 is 1 ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	string s ; bool check [ 2 ] ; int d [ 100001 ] [ 2 ] [ 2 ] ; int go ( int x , int y , int z ) { if ( x >= s . size ( ) ) { if ( y && z ) { return 1 ; } return 0 ; } if ( d [ x ] [ y ] [ z ] != - 1 ) return d [ x ] [ y ] [ z ] ; d [ x ] [ y ] [ z ] = go ( x + 1 , y , z ) ; if ( x < s . size ( ) - 1 && s [ x ] == ' A ' && s [ x + 1 ] == ' B ' && y == 0 ) { d [ x ] [ y ] [ z ] = max ( d [ x ] [ y ] [ z ] , go ( x + 2 , 1 , z ) ) ; } if ( x < s . size ( ) - 1 && s [ x ] == ' B ' && s [ x + 1 ] == ' A ' && z == 0 ) { d [ x ] [ y ] [ z ] = max ( d [ x ] [ y ] [ z ] , go ( x + 2 , y , 1 ) ) ; } return d [ x ] [ y ] [ z ] ; } int main ( ) { cin >> s ; memset ( d , - 1 , sizeof ( d ) ) ; if ( go ( 0 , 0 , 0 ) == 1 ) cout << " YES " << ' \n ' ; else cout << " NO " << ' \n ' ; }
TAB1 let a1 , b1 , a2 , b2 , k , sum = 0 be long long ; TAB1 read a1 , b1 , a2 , b2 , k ; TAB1 let x , y be long long with x = the max of a1 , a2 , and y = the min of b1 of b2 ; TAB1 if x > y ; TAB2 print 0 ; TAB1 else if k is between x and y both inclusive ; TAB2 print y - x ; TAB1 else ; TAB2 print y - + 1 ;	int main ( ) { long long a1 , b1 , a2 , b2 , k , sum = 0 ; cin >> a1 >> b1 >> a2 >> b2 >> k ; long long x = max ( a1 , a2 ) , y = min ( b1 , b2 ) ; if ( x > y ) cout << 0 << endl ; else if ( k >= x && k <= y ) cout << y - x << endl ; else cout << y - x + 1 << endl ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 C = boolean array of sizes 5 , 5 with C = { } ; TAB1 color = string = " RGBYW " ; TAB1 value = string = " 12345 " ; TAB1 for i = 0 to n exclusive ; TAB2 declare a string c ; TAB2 read c ; TAB2 for i = 0 to 5 exclusive ; TAB3 for j = 0 to 5 exclusive ; TAB4 if c [ 0 ] equals color [ i ] and c [ 1 ] equals value [ j ] , set C [ i ] [ j ] to true ; TAB1 ans = integer set to 25 ; TAB1 for bc = 0 as long as bc is less than 1 shifted left 5 bits with increment bc + 1 ; TAB2 for bv = 0 as long as bv is less than 1 shifted left 5 bits with increment bv + 1 ; TAB3 ok = boolean = true ; TAB3 for c = 0 to 5 exclusive ; TAB4 if bc shifted left c bitwise and 1 bits ; TAB5 t = integer = 0 ; TAB5 for v = 0 to 5 exclusive ; TAB6 if bv shifted right v bitwise and 1 bits is false , add integer value of C [ c ] [ v ] to t ; TAB5 if t is greater than 1 , set ok to false ; TAB3 for v = 0 to 5 exclusive ; TAB4 if bv shifted right v bitwise and 1 bits ; TAB5 t = integer = 0 ; TAB5 for c = 0 to 5 exclusive ; TAB6 if bc shifted right c bitwise and 1 bits is false , add integer value of C [ c ] [ v ] to t ; TAB5 if t is greater than 1 , set ok to false ; TAB3 t = integer = 0 ; TAB3 for c = 0 to 5 exclusive ; TAB4 for v = 0 to 5 exclusive ; TAB5 if not ( bc shifted right c bitwise and 1 bits ) and not ( bv shifted right v bitwise and 1 bits ) , add integer value of C [ c ] [ v ] to t ; TAB3 if t is greater than 1 , set ok to false ; TAB3 if ok ; TAB4 a = integer set to 0 ; TAB4 for i = 0 to 5 exclusive , add ( bc shifted right i bitwise and 1 bits ) + ( bv shifted right i bitwise and 1 bits ) to a ; TAB4 set ans to call min with ans , a ; TAB1 display ans ;	int main ( ) { int n ; cin >> n ; bool C [ 5 ] [ 5 ] = { } ; string color = " RGBYW " ; string value = " 12345 " ; for ( int i = 0 ; i < n ; i ++ ) { string c ; cin >> c ; for ( int i = 0 ; i < 5 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) if ( c [ 0 ] == color [ i ] && c [ 1 ] == value [ j ] ) C [ i ] [ j ] = true ; } int ans = 25 ; for ( int bc = 0 ; bc < 1 << 5 ; bc ++ ) for ( int bv = 0 ; bv < 1 << 5 ; bv ++ ) { bool ok = true ; for ( int c = 0 ; c < 5 ; c ++ ) if ( bc >> c & 1 ) { int t = 0 ; for ( int v = 0 ; v < 5 ; v ++ ) if ( ! ( bv >> v & 1 ) ) t += ( int ) C [ c ] [ v ] ; if ( t > 1 ) ok = false ; } for ( int v = 0 ; v < 5 ; v ++ ) if ( bv >> v & 1 ) { int t = 0 ; for ( int c = 0 ; c < 5 ; c ++ ) if ( ! ( bc >> c & 1 ) ) t += ( int ) C [ c ] [ v ] ; if ( t > 1 ) ok = false ; } int t = 0 ; for ( int c = 0 ; c < 5 ; c ++ ) for ( int v = 0 ; v < 5 ; v ++ ) if ( ! ( bc >> c & 1 ) && ! ( bv >> v & 1 ) ) t += ( int ) C [ c ] [ v ] ; if ( t > 1 ) ok = false ; if ( ok ) { int a = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) a += ( bc >> i & 1 ) + ( bv >> i & 1 ) ; ans = min ( ans , a ) ; } } cout << ans << endl ; }
TAB0 declare integer array a size 1000050 ; TAB1 declare n as integer ; TAB1 while read n is true ; TAB2 declare integer sum = 0 ; TAB2 declare one = 0 as integer ; TAB2 set bytes from a to size of a to value 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read one ; TAB3 increment a [ one ] ; TAB2 let sum be a [ 0 ] % 2 ; TAB2 for i = 1 to 1000050 exclusive ; TAB3 let a [ i ] be a [ i - 1 ] / 2 + a [ i ] ; TAB3 if a [ i ] % 2 is 1 , increment sum ; TAB2 print sum , newline ;	int a [ 1000050 ] ; int main ( ) { int n ; while ( cin >> n ) { int sum = 0 ; int one = 0 ; memset ( a , 0 , sizeof ( a ) ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> one ; a [ one ] ++ ; } sum = a [ 0 ] % 2 ; for ( int i = 1 ; i < 1000050 ; i ++ ) { a [ i ] = a [ i - 1 ] / 2 + a [ i ] ; if ( a [ i ] % 2 == 1 ) { sum ++ ; } } cout << sum << endl ; } return 0 ; }
TAB0 declare solve ; TAB1 make ints n and d ; TAB1 read n and d ; TAB1 create int array a of size n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 if n is equal to 1 or n is equal to 2 ; TAB2 print 0 ; TAB2 return ; TAB1 make long long integer cnt = 0 ; TAB1 create int r = 0 ; TAB1 let bool b = true ; TAB1 for i = 0 to n - 2 exclusive ; TAB2 make long long int k = r - i - 2 ; TAB2 if k is less than 0 , set k to 0 ; TAB2 set cnt to cnt + ( k * ( k + 1 ) / 2 ) ; TAB2 for j = r to n exclusive ; TAB3 if a [ j ] is less than or equal to a [ i ] + d ; TAB4 add max ( 0 , j - i - 1 ) to cnt ; TAB3 else do ; TAB4 set r to j ; TAB4 set b to false ; TAB4 break loop ; TAB2 if b is truthy ; TAB3 set r to n - 1 ; TAB2 else do ; TAB3 set b to true ; TAB1 display cnt ; TAB1 call solve ( ) ;	void solve ( ) { int n , d ; cin >> n >> d ; int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } if ( n == 1 or n == 2 ) { cout << 0 << endl ; return ; } long long cnt = 0 ; int r = 0 ; bool b = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { long long k = r - i - 2 ; if ( k < 0 ) k = 0 ; cnt += ( k * ( k + 1 ) / 2 ) ; for ( int j = r ; j < n ; j ++ ) { if ( a [ j ] <= a [ i ] + d ) { cnt += ( max ( 0 , j - i - 1 ) ) ; } else { r = j ; b = false ; break ; } } if ( b ) r = n - 1 ; else b = true ; } cout << cnt << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 declare integers i , j , n , x , integer arrays a size 105 , l size 105 ; TAB1 set bytes from a to size of a to value 0 ; TAB1 read n and x ; TAB1 for i = 0 to n exclusive ; TAB2 read l [ i ] ; TAB2 let j be l [ i ] ; TAB2 increment a [ j ] ; TAB1 declare integer sum = 0 ; TAB1 declare integer array b size 105 ; TAB1 declare integer k = 0 ; TAB1 for i = 0 to 105 exclusive ; TAB2 if a [ i ] is greater than 0 ; TAB3 increment sum ; TAB3 for q = 0 to n exclusive ; TAB4 if i is l [ q ] ; TAB5 let b [ k ] be q + 1 ; TAB5 increment k ; TAB5 end loop ; TAB1 sort from b to b + k ; TAB1 if sum is greater than or equal to x ; TAB2 print " YES " and newline ; TAB2 print b [ 0 ] ; TAB2 for i = 1 to x exclusive , print " " , b [ i ] ; TAB2 print newline ; TAB1 else ; TAB2 print " NO " and newline ;	int main ( ) { int i , j , n , a [ 105 ] , x , l [ 105 ] ; memset ( a , 0 , sizeof ( a ) ) ; cin >> n >> x ; for ( i = 0 ; i < n ; i ++ ) { cin >> l [ i ] ; j = l [ i ] ; a [ j ] ++ ; } int sum = 0 ; int b [ 105 ] ; int k = 0 ; for ( i = 0 ; i < 105 ; i ++ ) { if ( a [ i ] > 0 ) { sum ++ ; for ( int q = 0 ; q < n ; q ++ ) { if ( i == l [ q ] ) { b [ k ] = q + 1 ; k ++ ; break ; } } } } sort ( b , b + k ) ; if ( sum >= x ) { cout << " YES " << endl ; cout << b [ 0 ] ; for ( i = 1 ; i < x ; i ++ ) { cout << "   " << b [ i ] ; } cout << endl ; } else { cout << " NO " << endl ; } return 0 ; }
TAB1 n , a , b , c , ans = long long ; TAB1 while read n , a , b , c ; TAB2 ans = n / a ; TAB2 if n > = b and a > b - c ; TAB3 t = 1 ; TAB3 add ( n - b ) / ( b - c ) to t ; TAB3 subtract t * ( b - c ) from n ; TAB3 add max ( n ( a , n / b ) to t ; TAB3 ans = max ( ans , t ) ; TAB2 print ans ;	int main ( ) { long long n , a , b , c , ans ; while ( cin >> n >> a >> b >> c ) { ans = n / a ; if ( n >= b && a > ( b - c ) ) { long long t = 1 ; t += ( n - b ) / ( b - c ) ; n -= t * ( b - c ) ; t += max ( n / a , n / b ) ; ans = max ( ans , t ) ; } cout << ans << endl ; } return 0 ; }
TAB0 lang = vector array of integer of size 103 ; TAB0 emp = vector array of integer of size 103 ; TAB0 ans , check , n , m , a , b = integers , markl , marke = integer array of size 102 ; TAB0 function dfs1 takes integer x ; TAB0 function dfs2 takes integer y ; TAB1 markl [ y ] = 1 ; TAB1 for i = 0 to lang [ y ] . size ( ) exclusive ; TAB2 if marke [ lang [ y ] [ i ] ] is 0 , dfs1 ( lang [ y ] [ i ] ) ; TAB0 in the function dfs1 that take integer x ; TAB1 marke [ x ] = 1 ; TAB1 for i = 0 to emp [ x ] . size ( ) exclusive ; TAB2 if markl [ emp [ x ] [ i ] ] is 0 , dfs2 ( emp [ x ] [ i ] ) ; TAB1 read n , m ; TAB1 for i = 1 to n ; TAB2 read a ; TAB2 check = check + a ; TAB2 while decrement a ; TAB3 read b ; TAB3 append b in emp [ i ] ; TAB3 append i in lang [ b ] ; TAB1 for i = 1 to n ; TAB2 if marke [ i ] is 0 ; TAB3 increment ans ; TAB3 dfs1 on i ; TAB1 if check , decrement ans ; TAB1 print ans ;	vector < int > lang [ 103 ] ; vector < int > emp [ 103 ] ; int ans , check , n , m , a , b , markl [ 102 ] , marke [ 102 ] ; void dfs1 ( int x ) ; void dfs2 ( int y ) { markl [ y ] = 1 ; for ( int i = 0 ; i < lang [ y ] . size ( ) ; i ++ ) if ( marke [ lang [ y ] [ i ] ] == 0 ) dfs1 ( lang [ y ] [ i ] ) ; } void dfs1 ( int x ) { marke [ x ] = 1 ; for ( int i = 0 ; i < emp [ x ] . size ( ) ; i ++ ) if ( markl [ emp [ x ] [ i ] ] == 0 ) dfs2 ( emp [ x ] [ i ] ) ; } int main ( ) { cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a ; check += a ; while ( a -- ) { cin >> b ; emp [ i ] . push_back ( b ) ; lang [ b ] . push_back ( i ) ; } } for ( int i = 1 ; i <= n ; i ++ ) if ( marke [ i ] == 0 ) { ++ ans ; dfs1 ( i ) ; } if ( check ) -- ans ; cout << ans << endl ; return 0 ; }
TAB0 M = 1005 ; TAB0 type = array of 5 string filled with " byte " , " short " , " int " , " long " , " BigInteger " ; TAB0 border = array of 4 string filled with " 127 " , " 32767 " , " 2147483647 " , " 9223372036854775807 " ; TAB0 digit = array of 4 int ( 3 , 5 , 10 , 19 ) ; TAB1 s = string ; TAB1 read s ; TAB1 ans = 4 ; TAB1 for i = 0 to 4 exclusive ; TAB2 if length of s < digit [ i ] ; TAB3 ans = i ; TAB3 break ; TAB2 if length of s is digit [ i ] ; TAB3 if s < = border [ i ] ; TAB4 ans = i ; TAB4 break ; TAB1 print type [ ans ] ;	const int M = 1000 + 5 ; string type [ 5 ] = { " byte " , " short " , " int " , " long " , " BigInteger " } ; string border [ 4 ] = { " 127 " , " 32767 " , " 2147483647 " , " 9223372036854775807 " } ; int digit [ 4 ] = { 3 , 5 , 10 , 19 } ; int main ( ) { string s ; cin >> s ; int ans = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( s . length ( ) < digit [ i ] ) { ans = i ; break ; } if ( s . length ( ) == digit [ i ] ) { if ( s <= border [ i ] ) { ans = i ; break ; } } } cout << type [ ans ] << endl ; return 0 ; }
TAB1 create long long integers n , k ; TAB1 read n read k ; TAB1 create integer array a with size 100001 ; TAB1 create long long integer set q ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 sort elements from a to a + n ; TAB1 create integer ans with ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 if first index of a [ i ] in q is end of q ; TAB3 insert a [ i ] * k into q ; TAB3 increment ans ; TAB1 print ans print newline ;	int main ( ) { long long int n , k ; cin >> n >> k ; int a [ 100001 ] ; set < long long int > q ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } sort ( a , a + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( q . find ( a [ i ] ) == q . end ( ) ) { q . insert ( a [ i ] * k ) ; ans ++ ; } } cout << ans << endl ; return 0 ; }
TAB0 declare integer array arr size 10000 ; TAB0 declare integer veector v ; TAB0 declare integer array brr size 10000 ; TAB1 declare integer n ; TAB1 read n ; TAB1 for i = 1 to n inclusive ; TAB2 declare integer m ; TAB2 read m ; TAB2 let arr [ i ] be m ; TAB2 add m to end of v ; TAB1 sort from beginning of v to end of v ; TAB1 declare integers idx = 1 , cur ; TAB1 for i = n - 1 to 0 inclusive , decrementing i ; TAB2 if i is n - 1 ; TAB3 let cur be v [ i ] ; TAB3 let brr [ idx ] be v [ i ] ; TAB2 else ; TAB3 if cur is not v [ i ] ; TAB4 let brr [ idx ] be v [ i ] ; TAB4 let cur be v [ i ] ; TAB2 increment idx ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to n inclusive ; TAB3 if arr [ i ] is brr [ j ] and arr [ i ] is not 0 and brr [ j ] is not 0 ; TAB4 if i is n ; TAB5 print j and newline ; TAB4 else ; TAB5 print j and " " ;	int arr [ 10000 ] ; vector < int > v ; int brr [ 10000 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { int m ; cin >> m ; arr [ i ] = m ; v . push_back ( m ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int idx = 1 , cur ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 ) { cur = v [ i ] ; brr [ idx ] = v [ i ] ; } else { if ( cur != v [ i ] ) { brr [ idx ] = v [ i ] ; cur = v [ i ] ; } } idx ++ ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( arr [ i ] == brr [ j ] && arr [ i ] != 0 && brr [ j ] != 0 ) { if ( i == n ) { cout << j << endl ; } else { cout << j << "   " ; } } } } }
TAB0 call the function find by passing the parameters int x , int father [ ] ; TAB1 if father [ x ] is equal to x , return the value of x ; TAB1 return the value of father [ x ] where father [ x ] = find ( father [ x ] , father ) ; TAB1 let s be a string ; TAB1 read s ; TAB1 the integer value ans is equal to 0 ; TAB1 let n be a integer with n = length of s - 2 ; TAB1 for i = 0 to n exclusive ; TAB2 let tmp be a string with tmp = s . substr ( i , 3 ) ; TAB2 sort the values tmp . begin ( ) and tmp . end ( ) ; TAB2 if tmp is equal to ABC ; TAB3 the value of ans is equal to 1 ; TAB3 stop ; TAB1 if ans is true ; TAB2 print Yes and newline ; TAB1 else do the following ; TAB2 print No and newline ;	int find ( int x , int father [ ] ) { if ( father [ x ] == x ) return x ; return father [ x ] = find ( father [ x ] , father ) ; } int main ( ) { string s ; cin >> s ; int ans = 0 ; int n = s . length ( ) - 2 ; for ( int i = 0 ; i < n ; i ++ ) { string tmp = s . substr ( i , 3 ) ; sort ( tmp . begin ( ) , tmp . end ( ) ) ; if ( tmp == " ABC " ) { ans = 1 ; break ; } } if ( ans ) cout << " Yes\n " ; else cout << " No\n " ; }
TAB0 a , b , c , d = integers ; TAB0 function check takes two integers ; t1 and t2 ; TAB1 if t1 < t2 ; TAB2 return 1 ; TAB1 else if t1 > t2 ; TAB2 return - 1 ; TAB1 read a , b , c , d ; TAB1 x , y = integers set to 0 ; TAB1 t1 , t2 = integers with t1 set to b and t2 set to d ; TAB1 while true is true ; TAB2 if check of t1 and t2 is true ; TAB3 add a to t1 ; TAB3 increment x by 1 ; TAB2 if check of t1 and t2 is - 1 ; TAB3 add c to t2 ; TAB3 increment y by 1 ; TAB2 if check of t1 and t2 is 0 ; TAB3 print t1 ; TAB3 break ; TAB2 if x > 1000 or y > 1000 ; TAB3 print " - 1 " ;	int a , b , c , d ; int check ( int t1 , int t2 ) { if ( t1 < t2 ) return 1 ; else if ( t1 > t2 ) return - 1 ; return 0 ; } int main ( ) { cin >> a >> b >> c >> d ; int x = 0 , y = 0 ; int t1 = b , t2 = d ; while ( true ) { if ( check ( t1 , t2 ) == 1 ) { t1 += a ; x ++ ; } if ( check ( t1 , t2 ) == - 1 ) { t2 += c ; y ++ ; } if ( check ( t1 , t2 ) == 0 ) { cout << t1 << endl ; break ; } if ( x > 1000 || y > 1000 ) { cout << " -1 " << endl ; return 0 ; } } }
TAB0 pa = array of 10005 pair of int , int ; TAB0 maxn = 3f3f3f3f in exadecimal ; TAB1 n , m , k , count = int ; TAB1 read m , n ; TAB2 count , k = 0 ; TAB2 for i = 0 to n exclusive read two pa [ i ] items ; TAB2 while k is not m ; TAB3 sort pa ; TAB3 if m > first item of pa ; TAB4 if second item of pa is not 0 k = m ; TAB4 add second item of pa to m ; TAB4 first item of pa = maxn ; TAB4 increment count ; TAB3 else ; TAB4 break ; TAB2 if count is not n ; TAB3 print NO ; TAB2 else ; TAB3 print YES ;	pair < int , int > pa [ 10005 ] ; int maxn = 0x3f3f3f3f ; int main ( ) { int n , m , k , count ; while ( cin >> m >> n ) { count = k = 0 ; for ( int i = 0 ; i < n ; i ++ ) cin >> pa [ i ] . first >> pa [ i ] . second ; while ( k != m ) { sort ( pa , pa + n ) ; if ( m > pa [ 0 ] . first ) { if ( pa [ 0 ] . second != 0 ) k = m ; m += pa [ 0 ] . second ; pa [ 0 ] . first = maxn ; count ++ ; } else break ; } if ( count != n ) cout << " NO " << endl ; else cout << " YES " << endl ; } return 0 ; }
TAB0 create constant N = 1e5 + 1 ; TAB0 let long long int array of size N ; TAB1 let int n ; TAB1 read n ; TAB1 let arr [ 0 ] = 0 ; TAB1 for i = 1 to N exclusive , set arr [ i ] to arr [ i - 1 ] + i ; TAB1 for i = 1 to N exclusive ; TAB2 if binary_search ( arr + 1 , arr + N , n - arr [ i ] ) is truthy ; TAB3 print " YES " ; TAB1 print " NO " ;	int const N = 1e5 + 1 ; long long arr [ N ] ; int main ( ) { int n ; cin >> n ; arr [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) arr [ i ] = arr [ i - 1 ] + i ; for ( int i = 1 ; i < N ; i ++ ) if ( binary_search ( arr + 1 , arr + N , n - arr [ i ] ) ) { cout << " YES " << endl ; return 0 ; } cout << " NO " << endl ; return 0 ; }
TAB0 mnx = 8000009 ; TAB0 mod = 1000000007 ; TAB0 dx = array of 4 long long filled with - 1 , 0 , 0 , 1 ; TAB0 dy = array of 4 long long filled with 0 , - 1 , 1 , 0 ; TAB0 n , m = long long ; TAB0 s = array of 111 by 111 char ; TAB0 u = array of 111 by 111 bool ; TAB0 function check ( get long long x and y , return bool ) ; TAB1 return 0 < x and x < n + 1 and 0 < y and y < m + 1 ; TAB0 function dfs ( get long long x and y , return nothing ) ; TAB1 if u [ x ] [ y ] return ; TAB1 u [ x ] [ y ] = true ; TAB1 for i = 0 to 4 exclusive ; TAB2 if check ( x + dx [ i ] , y + dy [ i ] ) and s [ x + dx [ i ] ] [ y + dy [ i ] ] is ' # ' dfs ( x + dx [ i ] , y + dy [ i ] ) ; TAB1 read n , m ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive read s [ i ] [ j ] ; TAB1 qwe = 0 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if s [ i ] [ j ] is ' # ' increment qwe ; TAB1 res = 11111111111111 ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if s [ i ] [ j ] is ' # ' ; TAB4 q = 0 ; TAB4 for k = 0 to 4 exclusive ; TAB5 if check ( i + dx [ k ] , j + dy [ k ] ) and s [ i + dx [ k ] ] [ j + dy [ k ] ] is ' # ' increment q ; TAB4 if q + 1 < qwe res = min ( res , q ) ; TAB4 if qwe > 1 ; TAB5 s [ i ] [ j ] = ' 0 ' ; TAB5 for k = 1 to n inclusive ; TAB6 for l = 1 to m inclusive u [ k ] [ l ] = false ; TAB5 cnt = 0 ; TAB5 for k = 1 to n inclusive ; TAB6 for l = 1 to m inclusive ; TAB7 if s [ k ] [ l ] is ' # ' and not u [ k ] [ l ] ; TAB8 dfs ( k , l ) ; TAB8 increment cnt ; TAB5 if cnt > 1 res = min ( res , 1 ) ; TAB5 s [ i ] [ j ] = ' # ' ; TAB1 if res is 11111111111111 subtract 11111111111112 from res ; TAB1 print res ;	const long long mnx = 8e6 + 9 ; const long long mod = 1e9 + 7 ; const long long dx [ 4 ] = { - 1 , 0 , 0 , 1 } ; const long long dy [ 4 ] = { 0 , - 1 , 1 , 0 } ; long long n , m ; char s [ 111 ] [ 111 ] ; bool u [ 111 ] [ 111 ] ; bool check ( long long x , long long y ) { return 0 < x && x < n + 1 && 0 < y && y < m + 1 ; } void dfs ( long long x , long long y ) { if ( u [ x ] [ y ] ) { return ; } u [ x ] [ y ] = true ; for ( long long i = 0 ; i < 4 ; i ++ ) { if ( check ( x + dx [ i ] , y + dy [ i ] ) && s [ x + dx [ i ] ] [ y + dy [ i ] ] == ' # ' ) { dfs ( x + dx [ i ] , y + dy [ i ] ) ; } } } int main ( ) { cin >> n >> m ; for ( long long i = 1 ; i <= n ; i ++ ) { for ( long long j = 1 ; j <= m ; j ++ ) { cin >> s [ i ] [ j ] ; } } long long qwe = 0 ; for ( long long i = 1 ; i <= n ; i ++ ) { for ( long long j = 1 ; j <= m ; j ++ ) { if ( s [ i ] [ j ] == ' # ' ) { qwe ++ ; } } } long long res = 11111111111111 ; for ( long long i = 1 ; i <= n ; i ++ ) { for ( long long j = 1 ; j <= m ; j ++ ) { if ( s [ i ] [ j ] == ' # ' ) { long long q = 0 ; for ( long long k = 0 ; k < 4 ; k ++ ) { if ( check ( i + dx [ k ] , j + dy [ k ] ) && s [ i + dx [ k ] ] [ j + dy [ k ] ] == ' # ' ) q ++ ; } if ( q + 1 < qwe ) { res = min ( res , q ) ; } if ( qwe > 1 ) { s [ i ] [ j ] = ' 0 ' ; for ( long long k = 1 ; k <= n ; k ++ ) { for ( long long l = 1 ; l <= m ; l ++ ) { u [ k ] [ l ] = false ; } } long long cnt = 0 ; for ( long long k = 1 ; k <= n ; k ++ ) { for ( long long l = 1 ; l <= m ; l ++ ) { if ( s [ k ] [ l ] == ' # ' && ! u [ k ] [ l ] ) { dfs ( k , l ) ; cnt ++ ; } } } if ( cnt > 1 ) { res = min ( res , 1LL ) ; } s [ i ] [ j ] = ' # ' ; } } } } if ( res == 11111111111111 ) res -= 11111111111112 ; cout << res << ' \n ' ; return 0 ; }
TAB0 create new integer constant INF = 2147483647 ; TAB0 define integer constant mod = 1000000007 ; TAB0 new constant integer tmod = 1000000009 ; TAB0 let ma be a map from characters to integers ; TAB0 create new array of integers vis with size 25 ; TAB0 declare vector of integers v ; TAB0 declare new array of integers sum with size 25 ; TAB0 a1 is an array of integers with 5 elements ; TAB0 create new array of integers a2 with size 5 ; TAB1 declare new integer called n ; TAB1 read variable n from the input ; TAB1 assign 0 to ma [ ' R ' ] ; TAB1 change ma [ ' G ' ] to 1 ; TAB1 assign the new value = 2 to ma [ ' B ' ] ; TAB1 set ma [ ' Y ' ] to 3 ; TAB1 assign the new value = 4 to ma [ ' W ' ] ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 define string str ; TAB2 read input to str ; TAB2 declare new integer tmp = ma [ str [ 0 ] ] * 5 + str [ 1 ] - ' 1 ' ; TAB2 change vis [ tmp ] to 1 ; TAB1 start for loop from i = 0 to 25 exclusive incrementing i ; TAB2 if vis [ i ] is true , add i to v ; TAB1 define integer ans = 10 ; TAB1 in a for loop , change s from 0 to 1 < < 10 exclusive ; TAB2 set the values of first sizeof ( a1 ) bytes at the pointer a1 to 0 ; TAB2 set first sizeof ( a2 ) bytes at the pointer a2 to 0 ; TAB2 change the values of first sizeof ( sum ) bytes at the pointer sum to 0 ; TAB2 create integer pos with value 1 ; TAB2 for integer i = 0 to 5 exclusive ; TAB3 if ( s > > i ) & 1 ! = 0 , change the value of a1 [ i ] to pos and increment pos ; TAB2 declare integer variable with name pos2 = 1 ; TAB2 for i from 5 to 10 exclusive ; TAB3 if ( s > > i ) & 1 ! = 0 , set a2 [ i % 5 ] to pos2 and increase pos2 by 1 ; TAB2 for integer i = 0 to ( ength of v exclusive ; TAB3 define integer tmp with value v [ i ] ; TAB3 define new integer called l with value = value of a1 [ tmp / 5 ] ; TAB3 new integer r = value of a2 [ tmp % 5 ] ; TAB3 increment sum [ l * 5 + r ] by one ; TAB2 create new boolean flag = true ; TAB2 in a for loop , change i from 0 to 25 exclusive incrementing i ; TAB3 if sum [ i ] is greater than 1 ; TAB4 assign the new value = false to flag ; TAB4 stop the loop ; TAB2 if flag is false , skip the rest of the loop ; TAB2 change ans to min of ans and pos - 1 + pos2 - 1 ; TAB1 print ans and ' \ n ' ;	const int INF = 2147483647 ; const int mod = 1000000007 ; const int tmod = 1000000009 ; map < char , int > ma ; int vis [ 25 ] ; vector < int > v ; int sum [ 25 ] ; int a1 [ 5 ] ; int a2 [ 5 ] ; int main ( ) { int n ; cin >> n ; ma [ ' R ' ] = 0 ; ma [ ' G ' ] = 1 ; ma [ ' B ' ] = 2 ; ma [ ' Y ' ] = 3 ; ma [ ' W ' ] = 4 ; for ( int i = 0 ; i < ( n ) ; i ++ ) { string str ; cin >> str ; int tmp = ma [ str [ 0 ] ] * 5 + str [ 1 ] - ' 1 ' ; vis [ tmp ] = 1 ; } for ( int i = 0 ; i < ( 25 ) ; i ++ ) if ( vis [ i ] ) v . push_back ( i ) ; int ans = 10 ; for ( int s = 0 ; s < ( 1 << 10 ) ; s ++ ) { memset ( a1 , 0 , sizeof ( a1 ) ) ; memset ( a2 , 0 , sizeof ( a2 ) ) ; memset ( sum , 0 , sizeof ( sum ) ) ; int pos = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) if ( ( s >> i ) & 1 ) a1 [ i ] = pos ++ ; int pos2 = 1 ; for ( int i = 5 ; i < 10 ; i ++ ) if ( ( s >> i ) & 1 ) a2 [ i % 5 ] = pos2 ++ ; for ( int i = 0 ; i < ( v . size ( ) ) ; i ++ ) { int tmp = v [ i ] ; int l = a1 [ tmp / 5 ] ; int r = a2 [ tmp % 5 ] ; sum [ l * 5 + r ] ++ ; } bool flag = true ; for ( int i = 0 ; i < ( 25 ) ; i ++ ) if ( sum [ i ] > 1 ) { flag = false ; break ; } if ( ! flag ) continue ; ans = min ( ans , pos - 1 + pos2 - 1 ) ; } cout << ans << ' \n ' ; return 0 ; }
TAB1 x = int ; TAB1 read x ; TAB1 if x is 1 ; TAB2 print - 1 ; TAB1 else ; TAB2 print x , space , x ;	int main ( ) { int x ; cin >> x ; if ( x == 1 ) puts ( " -1 " ) ; else cout << x << "   " << x << endl ; return 0 ; }
TAB0 create integers n and k , and an array of ints a with size 88 ; TAB0 create stack of integers st ; TAB1 read input to n and k ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 declare int variable num = 0 ; TAB1 clear st ; TAB1 loop i from 0 to n exclusive ; TAB2 if there is no a [ i ] in st ; TAB3 if size of st = k ; TAB4 create new integer set iterator it ; TAB4 declare ints maxpos , j and val where maxpos = - 1 ; TAB4 move it through st ; TAB5 for j from i to n exclusive ; TAB6 if value at * it = a [ j ] , break the loop ; TAB5 if j is greater than maxpos , set maxpos to j and val = value at * it ; TAB4 remove val from st ; TAB3 insert a [ i ] into st ; TAB3 increment num by one ; TAB1 print num ;	int n , k , a [ 88 ] ; set < int > st ; int main ( ) { cin >> n >> k ; for ( int i = 0 ; i < n ; ++ i ) cin >> a [ i ] ; int num = 0 ; st . clear ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( find ( st . begin ( ) , st . end ( ) , a [ i ] ) == st . end ( ) ) { if ( st . size ( ) == k ) { set < int > :: iterator it ; int maxpos = - 1 , j , val ; for ( it = st . begin ( ) ; it != st . end ( ) ; ++ it ) { for ( j = i ; j < n ; ++ j ) { if ( * it == a [ j ] ) break ; } if ( j > maxpos ) maxpos = j , val = * it ; } st . erase ( val ) ; } st . insert ( a [ i ] ) ; num ++ ; } } cout << num << endl ; return 0 ; }
TAB1 create integers n , k ; TAB1 create string t ; TAB1 read n read k read t ; TAB1 create integer cnt with cnt = 1 ; TAB1 create integer pos with pos = 1 ; TAB1 create string ans with ans = t ; TAB1 while cnt is less than k ; TAB2 if pos is greater than or equal to integer casted size of ans ; TAB3 increment ans by t ; TAB3 increment cnt ; TAB2 else ; TAB3 create boolean ok with ok = true ; TAB3 create integer len with len = 0 ; TAB3 for i = 0 to integer casted size of t exclusive ; TAB4 if pos + i is greater than or equal to integer casted size of ans , break loop ; TAB4 increment len ; TAB4 if ans [ pos + i ] is not t [ i ] , set ok to false ; TAB3 if ok is true ; TAB4 increment ans by substring of t starting at len ; TAB4 increment cnt ; TAB2 increment pos ; TAB1 print ans print newline ;	int main ( ) { int n , k ; string t ; cin >> n >> k >> t ; int cnt = 1 ; int pos = 1 ; string ans = t ; while ( cnt < k ) { if ( pos >= ( ( int ) ( ans . size ( ) ) ) ) { ans += t ; ++ cnt ; } else { bool ok = true ; int len = 0 ; for ( int i = 0 ; i < ( ( int ) ( t . size ( ) ) ) ; ++ i ) { if ( pos + i >= ( ( int ) ( ans . size ( ) ) ) ) break ; ++ len ; if ( ans [ pos + i ] != t [ i ] ) ok = false ; } if ( ok ) { ans += t . substr ( len ) ; ++ cnt ; } } ++ pos ; } cout << ans << endl ; return 0 ; }
TAB0 let n be a integer ; TAB0 chair = array of characters of length 10000 ; TAB1 read n ; TAB1 read chair + 1 ; TAB1 chair [ 0 ] is equal to 0 ; TAB1 chair [ n + 1 ] is equal to 0 ; TAB1 let ans be a integer with ans = 0 ; TAB1 if n is equal to 1 and chair [ 1 ] is equal to 0 ; TAB2 print No and newline ; TAB1 if n is equal to 1 and chair [ 1 ] is equal to 1 ; TAB2 print Yes and newline ; TAB1 for i = 1 to n inclusive ; TAB2 if chair [ i ] is equal to 1 and ( chair [ i - 1 ] is equal to 1 or chair [ i + 1 ] is equal to 1 ) ; TAB3 ans is equal to 1 ; TAB3 stop ; TAB2 if chair [ i ] is equal to 0 ; TAB3 if chair [ i - 1 ] is equal to 0 and chair [ i + 1 ] is equal to 0 ; TAB4 ans is equal to 1 ; TAB4 stop ; TAB1 if ans is equal to 1 ; TAB2 print No and newline ; TAB1 else do the following ; TAB2 print Yes and newline ;	int n ; char chair [ 10000 ] ; int main ( ) { cin >> n ; cin >> ( chair + 1 ) ; chair [ 0 ] = ' 0 ' ; chair [ n + 1 ] = ' 0 ' ; int ans = 0 ; if ( n == 1 && chair [ 1 ] == ' 0 ' ) { cout << " No " << endl ; return 0 ; } if ( n == 1 && chair [ 1 ] == ' 1 ' ) { cout << " Yes " << endl ; return 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( chair [ i ] == ' 1 ' && ( chair [ i - 1 ] == ' 1 ' || chair [ i + 1 ] == ' 1 ' ) ) { ans = 1 ; break ; } if ( chair [ i ] == ' 0 ' ) { if ( chair [ i - 1 ] == ' 0 ' && chair [ i + 1 ] == ' 0 ' ) { ans = 1 ; break ; } } } if ( ans == 1 ) cout << " No " << endl ; else cout << " Yes " << endl ; }
TAB1 let x , t , a , b , da , db be integers ; TAB1 read x , t , a , b , da , db ; TAB1 let sum be a integer ; TAB1 for i = 0 to t inclusive ; TAB2 if i equals t ; TAB3 sum is equal to 0 ; TAB2 else do the following ; TAB3 sum is equal to a - da * i ; TAB2 for j = 0 to t inclusive ; TAB3 if j is not equal to t , increment sum by b - db * j ; TAB3 if sum equals x ; TAB4 print YES and newline ; TAB3 if j is not equal to t , decrement sum by b - db * j ; TAB1 print NO and newline ;	int main ( ) { int x , t , a , b , da , db ; cin >> x >> t >> a >> b >> da >> db ; int sum ; for ( int i = 0 ; i <= t ; i ++ ) { if ( i == t ) sum = 0 ; else sum = a - da * i ; for ( int j = 0 ; j <= t ; j ++ ) { if ( j != t ) sum += b - db * j ; if ( sum == x ) { cout << " YES " << endl ; return 0 ; } if ( j != t ) sum -= ( b - db * j ) ; } } cout << " NO " << endl ; return 0 ; }
TAB0 create int arrays a and b , both of length 21 ; TAB0 create vector < int > p ; TAB1 create int n and m ; TAB1 read n and m ; TAB1 for i = 1 to n inclusive , read a [ i ] ; TAB1 for i = 1 to m inclusive , read b [ i ] ; TAB1 for i = 1 to n inclusive ; TAB2 for j = 1 to m inclusive ; TAB3 if b [ j ] is equal to a [ i ] ; TAB4 push b [ j ] onto p ; TAB4 continue ; TAB1 if p empty ; TAB2 print newline ; TAB1 else ; TAB2 for i = 0 to p size - 1 exclusive , print p [ i ] " " ; TAB2 print last element of p ;	int a [ 21 ] , b [ 21 ] ; vector < int > p ; int main ( ) { int n , m ; cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ] ; for ( int i = 1 ; i <= m ; i ++ ) cin >> b [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( b [ j ] == a [ i ] ) { p . push_back ( b [ j ] ) ; continue ; } } } if ( p . empty ( ) ) cout << ' \n ' ; else { for ( int i = 0 ; i < p . size ( ) - 1 ; i ++ ) cout << p [ i ] << "   " ; cout << p [ p . size ( ) - 1 ] << endl ; } return 0 ; }
TAB1 s = string ; TAB1 while read s ; TAB2 b = false ; TAB2 for i = 2 to length of s exclusive ; TAB3 if s [ i - 2 ] is ' A ' and s [ i - 1 ] is ' B ' and s [ i ] is ' C ' b = true ; TAB2 for i = 2 to length of s exclusive ; TAB3 if s [ i - 2 ] is ' A ' and s [ i - 1 ] is ' C ' and s [ i ] is ' B ' b = true ; TAB2 for i = 2 to length of s exclusive ; TAB3 if s [ i - 2 ] is ' B ' and s [ i - 1 ] is ' A ' and s [ i ] is ' C ' b = true ; TAB2 for i = 2 to length of s exclusive ; TAB3 if s [ i - 2 ] is ' B ' and s [ i - 1 ] is ' C ' and s [ i ] is ' A ' b = true ; TAB2 for i = 2 to length of s exclusive ; TAB3 if s [ i - 2 ] is ' C ' and s [ i - 1 ] is ' A ' and s [ i ] is ' B ' b = true ; TAB2 for i = 2 to length of s exclusive ; TAB3 if s [ i - 2 ] is ' C ' and s [ i - 1 ] is ' B ' and s [ i ] is ' A ' b = true ; TAB2 if b ; TAB3 print " Yes " ; TAB2 else ; TAB3 print " No " ;	int main ( ) { string s ; while ( cin >> s ) { bool b = false ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s [ i - 2 ] == ' A ' && s [ i - 1 ] == ' B ' && s [ i ] == ' C ' ) b = true ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s [ i - 2 ] == ' A ' && s [ i - 1 ] == ' C ' && s [ i ] == ' B ' ) b = true ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s [ i - 2 ] == ' B ' && s [ i - 1 ] == ' A ' && s [ i ] == ' C ' ) b = true ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s [ i - 2 ] == ' B ' && s [ i - 1 ] == ' C ' && s [ i ] == ' A ' ) b = true ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s [ i - 2 ] == ' C ' && s [ i - 1 ] == ' A ' && s [ i ] == ' B ' ) b = true ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s [ i - 2 ] == ' C ' && s [ i - 1 ] == ' B ' && s [ i ] == ' A ' ) b = true ; if ( b ) cout << " Yes\n " ; else cout << " No\n " ; } }
TAB1 create strings str1 and str2 ; TAB1 declare an arrays of integers num1 and num2 with size 300 ; TAB1 read str1 and str2 and keep looping ; TAB2 if length of str1 ! = length of str2 ; TAB3 print " NO " ; TAB3 skip the rest of the loop ; TAB2 for k from 0 to 300 exclusive ; TAB3 assign 0 to num1 [ k ] ; TAB3 assign 0 to num2 [ k ] ; TAB2 for k = 0 to length of str1 exclusive ; TAB3 increment num1 [ str1 [ k ] ] ; TAB3 increment num2 [ str2 [ k ] ] ; TAB2 declare integer pan = 0 ; TAB2 for i from 0 to 300 exclusive ; TAB3 if num1 [ i ] ! = num2 [ i ] ; TAB4 print " NO " ; TAB4 set pan to 1 ; TAB4 stop the loop ; TAB2 if pan is not 0 , skip the rest of the loop ; TAB2 create integer count = 0 ; TAB2 loop i from 0 to length of str1 exclusive ; TAB3 if str1 [ i ] ! = str2 [ i ] , increment count ; TAB2 if count ! = 2 ; TAB3 print " NO " ; TAB2 else ; TAB3 print " YES " ;	int main ( ) { string str1 , str2 ; int num1 [ 300 ] , num2 [ 300 ] ; while ( cin >> str1 >> str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) { cout << " NO " << endl ; continue ; } for ( int k = 0 ; k < 300 ; k ++ ) { num1 [ k ] = 0 ; num2 [ k ] = 0 ; } for ( int k = 0 ; k < str1 . length ( ) ; k ++ ) { num1 [ str1 [ k ] ] ++ ; num2 [ str2 [ k ] ] ++ ; } int pan = 0 ; for ( int i = 0 ; i < 300 ; i ++ ) { if ( num1 [ i ] != num2 [ i ] ) { cout << " NO " << endl ; pan = 1 ; break ; } } if ( pan ) continue ; int count = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; } if ( count != 2 ) cout << " NO " << endl ; else cout << " YES " << endl ; } }
TAB1 declare integers a , b , c , d ; TAB1 read a , b , c , d ; TAB1 declare integer array Rick size 105 ; TAB1 declare integer array Morty size 105 ; TAB1 let Rick [ 0 ] be b ; TAB1 let Morty [ 0 ] be d ; TAB1 for i = 1 to 100 inclusive ; TAB2 let Rick [ i ] be b + ( i * a ) ; TAB2 let Morty [ i ] be d + ( i * c ) ; TAB1 for i = 0 to 100 inclusive ; TAB2 for j = 0 to 100 inclusive ; TAB3 if Rick [ i ] is Morty [ j ] ; TAB4 print Rick [ i ] , newline ; TAB1 print " - 1 " , newline ;	int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; int Rick [ 105 ] ; int Morty [ 105 ] ; Rick [ 0 ] = b ; Morty [ 0 ] = d ; for ( int i = 1 ; i <= 100 ; i ++ ) { Rick [ i ] = b + ( i * a ) ; Morty [ i ] = d + ( i * c ) ; } for ( int i = 0 ; i <= 100 ; i ++ ) { for ( int j = 0 ; j <= 100 ; j ++ ) { if ( Rick [ i ] == Morty [ j ] ) { cout << Rick [ i ] << endl ; return 0 ; } } } cout << " -1 " << endl ; }
TAB1 s = string ; TAB1 read s ; TAB1 ones = int with ones = 0 ; TAB1 zeros = int with zeros = 0 ; TAB1 ans = string with ans = " " ; TAB1 contains_0 = int with contains_0 = 0 ; TAB1 for j = 0 to length of s ; TAB2 if s [ j ] is ' 0 ' ; TAB3 set contains_0 to 1 ; TAB3 break ; TAB1 i = int with i = 0 ; TAB1 if contains_0 is 0 increment i ; TAB1 for i to length of s ; TAB2 if s [ i ] is ' 1 ' ; TAB3 append ' 1 ' to ans ; TAB2 else if s [ i ] is ' 0 ' ; TAB3 increment i ; TAB3 break ; TAB1 for i to length of s append s [ i ] to ans ; TAB1 print ans ;	int main ( ) { string s ; cin >> s ; int ones = 0 ; int zeros = 0 ; string ans = "  " ; int contains_0 = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == ' 0 ' ) { contains_0 = 1 ; break ; } } int i = 0 ; if ( contains_0 == 0 ) { i ++ ; } for ( ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' 1 ' ) { ans += ' 1 ' ; } else if ( s [ i ] == ' 0 ' ) { i ++ ; break ; } } for ( ; i < s . length ( ) ; i ++ ) { ans += s [ i ] ; } cout << ans << endl ; return 0 ; return 0 ; }
TAB0 MAXINT = const int with MAXINT = 2147483640 ; TAB0 MAXLL = const long long with MAXLL = 9223372036854775800LL ; TAB0 MAXN = const long long with MAXN = 1e6 ; TAB0 eps = const double with eps = 1e - 9 ; TAB0 mod = const long long with mod = 998244353 ; TAB0 dp = 3d array of long long of size [ 100006 ] [ 202 ] [ 2 ] , pref = 2d array of size [ 300 ] [ 2 ] ; TAB0 n = long long , a = integer array of size MAXN ; TAB1 call srand on time ( 0 ) ; TAB1 read n ; TAB1 for i = 1 to n , read a [ i ] ; TAB1 if a [ 1 ] is - 1 ; TAB2 for i = 1 to 200 dp [ 1 ] [ j ] [ 0 ] = 1 ; TAB1 else ; TAB2 dp [ 1 ] [ a [ 1 ] ] [ 0 ] = 1 ; TAB1 for i = 2 to n ; TAB2 for j = 1 to 200 ; TAB3 ( pref [ j ] [ 1 ] = pref [ j - 1 ] [ 1 ] + dp [ i - 1 ] [ j ] [ 1 ] ) = ( pref [ j ] [ 1 ] = pref [ j - 1 ] [ 1 ] + dp [ i - 1 ] [ j ] [ 1 ] ) modulo mod ; TAB3 ( pref [ j ] [ 0 ] = pref [ j - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] [ 0 ] ) = ( pref [ j ] [ 0 ] = pref [ j - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] [ 0 ] ) modulo mod ; TAB2 if a [ i ] is - 1 ; TAB3 for cur = 1 to 200 ; TAB4 sum = long long with sum = 0 ; TAB4 ( sum = sum + ( pref [ 200 ] [ 1 ] - pref [ cur - 1 ] [ 1 ] + mod ) ) = ( sum = sum + ( pref [ 200 ] [ 1 ] - pref [ cur - 1 ] [ 1 ] + mod ) ) modulo mod ; TAB4 ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod ; TAB4 ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) = ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) modulo mod ; TAB4 sum = pref [ cur - 1 ] [ 1 ] + pref [ cur - 1 ] [ 0 ] ; TAB4 ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) = ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) modulo mod ; TAB2 else ; TAB3 sum = long long with sum = 0 ; TAB3 cur = long long with cur = a [ i ] ; TAB3 for j = cur to 200 , sum = sum + ( dp [ i - 1 ] [ j ] [ 1 ] ) = sum + ( dp [ i - 1 ] [ j ] [ 1 ] ) modulo mod ; TAB3 ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) = ( sum = sum + dp [ i - 1 ] [ cur ] [ 0 ] ) modulo mod ; TAB3 ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) = ( dp [ i ] [ cur ] [ 1 ] = dp [ i ] [ cur ] [ 1 ] + sum ) modulo mod ; TAB3 sum = 0 ; TAB3 for j = 1 to cur exclusive , ( sum = sum + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) = ( sum = sum + dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) modulo mod ; TAB3 ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) = ( dp [ i ] [ cur ] [ 0 ] = dp [ i ] [ cur ] [ 0 ] + sum ) modulo mod ; TAB1 ans = long long with ans = 0 ; TAB1 for i = 1 to 200 , ( ans = ans + dp [ n ] [ i ] [ 1 ] ) = ( ans = ans + dp [ n ] [ i ] [ 1 ] ) modulo mod ; TAB1 print ans ;	const int MAXINT = 2147483640 ; const long long MAXLL = 9223372036854775800LL ; const long long MAXN = 1e6 ; const double eps = 1e-9 ; const long long mod = 998244353 ; long long dp [ 100006 ] [ 202 ] [ 2 ] , pref [ 300 ] [ 2 ] ; long long n , a [ MAXN ] ; int main ( ) { srand ( time ( 0 ) ) ; cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) cin >> a [ i ] ; if ( a [ 1 ] == - 1 ) for ( int j = 1 ; j <= 200 ; ++ j ) dp [ 1 ] [ j ] [ 0 ] = 1 ; else dp [ 1 ] [ a [ 1 ] ] [ 0 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= 200 ; ++ j ) { ( pref [ j ] [ 1 ] = pref [ j - 1 ] [ 1 ] + dp [ i - 1 ] [ j ] [ 1 ] ) %= mod ; ( pref [ j ] [ 0 ] = pref [ j - 1 ] [ 0 ] + dp [ i - 1 ] [ j ] [ 0 ] ) %= mod ; } if ( a [ i ] == - 1 ) { for ( int cur = 1 ; cur <= 200 ; ++ cur ) { long long sum = 0 ; ( sum += ( pref [ 200 ] [ 1 ] - pref [ cur - 1 ] [ 1 ] + mod ) ) %= mod ; ( sum += dp [ i - 1 ] [ cur ] [ 0 ] ) %= mod ; ( dp [ i ] [ cur ] [ 1 ] += sum ) %= mod ; sum = pref [ cur - 1 ] [ 1 ] + pref [ cur - 1 ] [ 0 ] ; ( dp [ i ] [ cur ] [ 0 ] += sum ) %= mod ; } } else { long long sum = 0 ; long long cur = a [ i ] ; for ( int j = cur ; j <= 200 ; ++ j ) sum += ( dp [ i - 1 ] [ j ] [ 1 ] ) %= mod ; ( sum += dp [ i - 1 ] [ cur ] [ 0 ] ) %= mod ; ( dp [ i ] [ cur ] [ 1 ] += sum ) %= mod ; sum = 0 ; for ( int j = 1 ; j < cur ; ++ j ) ( sum += dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) %= mod ; ( dp [ i ] [ cur ] [ 0 ] += sum ) %= mod ; } } long long ans = 0 ; for ( int i = 1 ; i <= 200 ; ++ i ) ( ans += dp [ n ] [ i ] [ 1 ] ) %= mod ; cout << ans << " \n " ; return 0 ; }
TAB1 create integers n , m , sum with sum = 0 ; TAB1 read n ; TAB1 for i = 0 to n exclusive ; TAB2 read m ; TAB2 increment sum by m ; TAB1 if n - sum is minimum of 1 and n - 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int n , m , sum = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> m ; sum += m ; } if ( n - sum == min ( 1 , n - 1 ) ) puts ( " YES " ) ; else puts ( " NO " ) ; return 0 ; }
TAB1 n , m = int ; TAB1 read n then m ; TAB1 s , t = string ; TAB1 read s then t ; TAB1 p = int with p = - 1 ; TAB1 ans = int with ans = 0 ; TAB1 for i = 0 to n ; TAB2 if s [ i ] is ' * ' ; TAB3 set p to i ; TAB3 break ; TAB1 if p > - 1 ; TAB2 if n > m + 1 ; TAB3 set ans to 0 ; TAB2 else ; TAB3 n1 , n2 , m1 , m2 = string ; TAB3 set n1 to substr of 0 , p on s ; TAB3 set n2 to substr of p + 1 , n on s ; TAB3 set m1 to substr of 0 , p on t ; TAB3 set m2 to substr of m - size of n2 , m on t ; TAB3 if n1 is m1 and n2 is m2 ; TAB4 set ans to 1 ; TAB3 else ; TAB4 set ans to 0 ; TAB1 else ; TAB2 if s is t ; TAB3 set ans to 1 ; TAB2 else ; TAB3 set ans to 0 ; TAB1 if ans is 1 ; TAB2 print " YES " ; TAB1 else ; TAB2 print " NO " ;	int main ( ) { int n , m ; cin >> n >> m ; string s , t ; cin >> s >> t ; int p = - 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' * ' ) { p = i ; break ; } } if ( p > - 1 ) { if ( n > m + 1 ) ans = 0 ; else { string n1 , n2 , m1 , m2 ; n1 = s . substr ( 0 , p ) ; n2 = s . substr ( p + 1 , n ) ; m1 = t . substr ( 0 , p ) ; m2 = t . substr ( m - n2 . size ( ) , m ) ; if ( n1 == m1 && n2 == m2 ) ans = 1 ; else ans = 0 ; } } else { if ( s == t ) ans = 1 ; else ans = 0 ; } if ( ans == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
TAB1 t = integer ; TAB1 read t ; TAB1 while t is true , decrement t and do the following ; TAB2 maze = character array of size 10 by 10 ; TAB2 flag , sx , sy , gx , gy = integers with flag = 0 ; TAB2 for i = 0 to 8 exclusive ; TAB3 for j = 0 to 8 exclusive ; TAB4 read maze [ i ] [ j ] ; TAB4 if maze [ i ] [ j ] is equal to K and flag is 0 ; TAB5 then increment flag ; TAB5 set sx = i ; TAB5 assign j to sy ; TAB4 else if maze [ i ] [ j ] is K and flag is 1 ; TAB5 increment flag ; TAB5 set gx to i ; TAB5 gy = j ; TAB2 create integer a and b ; TAB2 set a = absolute value of sx - gx ; TAB2 set b = abs ( gy - sy ) ; TAB2 if a mod 4 is 0 and b mod 4 is 0 ; TAB3 print YES ; TAB2 else do the following ; TAB3 print NO ;	int main ( ) { int t ; cin >> t ; while ( t -- ) { char maze [ 10 ] [ 10 ] ; int flag = 0 , sx , sy , gx , gy ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { cin >> maze [ i ] [ j ] ; if ( maze [ i ] [ j ] == ' K ' && flag == 0 ) { flag ++ ; sx = i ; sy = j ; } else if ( maze [ i ] [ j ] == ' K ' && flag == 1 ) { flag ++ ; gx = i ; gy = j ; } } } int a , b ; a = abs ( sx - gx ) ; b = abs ( gy - sy ) ; if ( a % 4 == 0 && b % 4 == 0 ) { cout << " YES " << endl ; } else cout << " NO " << endl ; } }
TAB0 mod = 1000000007 ; TAB0 dp0array of 5005 by 5005 int ; TAB0 a , b = string ; TAB1 read a , b ; TAB1 len1 = length of a ; TAB1 len2 = length of b ; TAB1 for i = 1 to len1 inclusive ; TAB2 for j = 1 to len2 inclusive ; TAB3 if a [ i - 1 ] is b [ j - 1 ] dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) modulo mod ; TAB3 dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) modulo mod ; TAB1 ans = 0 ; TAB1 for i = 1 to len1 inclusive ans = ( ans + dp [ i ] [ len2 ] ) modulo mod ; TAB1 print ans ;	const int mod = 1e9 + 7 ; int dp [ 5005 ] [ 5005 ] ; string a , b ; int main ( ) { cin >> a >> b ; int len1 = a . length ( ) ; int len2 = b . length ( ) ; for ( int i = 1 ; i <= len1 ; i ++ ) { for ( int j = 1 ; j <= len2 ; j ++ ) { if ( a . operator [ ] ( i - 1 ) == b . operator [ ] ( j - 1 ) ) { dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] + 1 ) % mod ; } dp [ i ] [ j ] = ( dp [ i ] [ j ] + dp [ i ] [ j - 1 ] ) % mod ; } } long long ans = 0 ; for ( int i = 1 ; i <= len1 ; i ++ ) ans = ( ans + dp [ i ] [ len2 ] ) % mod ; cout << ans << endl ; }
TAB0 students = integer ; TAB1 while ( read students ) ; TAB2 i , j , k = integers ; TAB2 arr = integer array of size 1010 ; TAB2 for i = 0 to students exclusive ; TAB3 count , temp = integers with count = 0 ; TAB3 for j = 0 to 3 ; TAB4 print temp ; TAB4 count = count + temp ; TAB3 arr [ i ] = count ; TAB2 roll = integer with roll = 1 ; TAB2 for i = 1 to students exclusive ; TAB3 if ( arr [ i ] > arr [ 0 ] ) , increment roll ; TAB2 print roll ;	int students ; int main ( ) { while ( cin >> students ) { int i , j , k ; int arr [ 1010 ] ; for ( i = 0 ; i < students ; i ++ ) { int count = 0 , temp ; for ( j = 0 ; j < 4 ; j ++ ) { cin >> temp ; count = count + temp ; } arr [ i ] = count ; } int roll = 1 ; for ( i = 1 ; i < students ; i ++ ) { if ( arr [ i ] > arr [ 0 ] ) { roll ++ ; } } cout << roll << endl ; } return 0 ; }
TAB1 let l1 , s1 , r1 , p1 , l2 , s2 , r2 , p2 , l3 , s3 , r3 , p3 , l4 , s4 , r4 , p4 be integers ; TAB1 read l1 , s1 , r1 , and p1 ; TAB1 read l2 , s2 , r2 , and p2 ; TAB1 read l3 , s3 , r3 , and p3 ; TAB1 read l1 , s4 , r4 , and p4 ; TAB1 if ( l1 or s1 or r1 ) and p1 ; TAB2 print YES ; TAB1 if ( l2 or s2 or r2 ) and p2 ; TAB2 print YES ; TAB1 if ( l3 or s3 or r3 ) and p3 ; TAB2 print YES ; TAB1 if ( l4 or s4 or r4 ) and p4 ; TAB2 print YES ; TAB1 if l1 and p4 ; TAB2 print YES ; TAB1 if s1 and p3 ; TAB2 print YES ; TAB1 if r1 and p2 ; TAB2 print YES ; TAB1 if l4 and p3 ; TAB2 print YES ; TAB1 if s4 and p2 ; TAB2 print YES ; TAB1 if r4 and p1 ; TAB2 print YES ; TAB1 if l3 and p2 ; TAB2 print YES ; TAB1 if s3 and p1 ; TAB2 print YES ; TAB1 if r3 and p4 ; TAB2 print YES ; TAB1 if l2 and p1 ; TAB2 print YES ; TAB1 if s2 and p4 ; TAB2 print YES ; TAB1 if r2 and p3 ; TAB2 print YES ; TAB1 print NO ;	int main ( ) { int l1 , s1 , r1 , p1 , l2 , s2 , r2 , p2 , l3 , s3 , r3 , p3 , l4 , s4 , r4 , p4 ; cin >> l1 >> s1 >> r1 >> p1 ; cin >> l2 >> s2 >> r2 >> p2 ; cin >> l3 >> s3 >> r3 >> p3 ; cin >> l4 >> s4 >> r4 >> p4 ; if ( ( l1 || s1 || r1 ) && p1 ) { cout << " YES\n " ; return 0 ; } if ( ( l2 || s2 || r2 ) && p2 ) { cout << " YES\n " ; return 0 ; } if ( ( l3 || s3 || r3 ) && p3 ) { cout << " YES\n " ; return 0 ; } if ( ( l4 || s4 || r4 ) && p4 ) { cout << " YES\n " ; return 0 ; } if ( l1 && p4 ) { cout << " YES\n " ; return 0 ; } if ( s1 && p3 ) { cout << " YES\n " ; return 0 ; } if ( r1 && p2 ) { cout << " YES\n " ; return 0 ; } if ( l4 && p3 ) { cout << " YES\n " ; return 0 ; } if ( s4 && p2 ) { cout << " YES\n " ; return 0 ; } if ( r4 && p1 ) { cout << " YES\n " ; return 0 ; } if ( l3 && p2 ) { cout << " YES\n " ; return 0 ; } if ( s3 && p1 ) { cout << " YES\n " ; return 0 ; } if ( r3 && p4 ) { cout << " YES\n " ; return 0 ; } if ( l2 && p1 ) { cout << " YES\n " ; return 0 ; } if ( s2 && p4 ) { cout << " YES\n " ; return 0 ; } if ( r2 && p3 ) { cout << " YES\n " ; return 0 ; } cout << " NO\n " ; }
TAB1 a , b , s = integers ; TAB1 read a , b , s ; TAB1 if ( abs ( a ) + abs ( b ) is s ) ; TAB2 print Yes ; TAB1 else if ( abs ( a ) + abs ( b ) > s ) ; TAB2 print No ; TAB1 else ; TAB2 if ( ( s - ( abs ( a ) + abs ( b ) ) ) modulo 2 is 0 ) ; TAB3 print Yes ; TAB2 else ; TAB3 print No ;	int main ( ) { int a , b , s ; cin >> a >> b >> s ; if ( abs ( a ) + abs ( b ) == s ) cout << " Yes " << endl ; else if ( abs ( a ) + abs ( b ) > s ) { cout << " No " << endl ; } else { if ( ( s - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
TAB1 long long integer as n , m , k , l ; TAB1 read n , m , k , l ; TAB1 if k + l is greater than n then do the following ; TAB2 output - 1 ; TAB1 if n / m * m is less than l + k then do the following ; TAB2 output - 1 ; TAB1 long long integer as ans = ( l + k ) / m ; TAB1 if l + k modulo m is not equal to 0 then add one to ans ; TAB1 if ans * m is greater than n then do the following ; TAB2 output - 1 ; TAB1 else ; TAB2 output ans ;	int main ( ) { long long n , m , k , l ; cin >> n >> m >> k >> l ; if ( k + l > n ) { cout << - 1 << endl ; return 0 ; } if ( n / m * m < l + k ) { cout << - 1 << endl ; return 0 ; } long long ans = ( l + k ) / m ; if ( ( l + k ) % m != 0 ) ans ++ ; if ( ans * m > n ) cout << - 1 << endl ; else cout << ans << endl ; }
TAB1 create integer arrays nega , posi , with nega size 100003 , posi size 100003 , create integers ne , po , sumne , sumpo , with ne = 0 , po = 0 , sumne = 0 , sumpo = 0 ; TAB1 create boolean z with z = false ; TAB1 create integers n , x , a ; TAB1 read n ; TAB1 set bytes from nega to size of nega to value 0 ; TAB1 set bytes from posi to size of posi to value 0 ; TAB1 for i = 0 to n exclusive ; TAB2 read x read a ; TAB2 if x is less than 0 ; TAB3 set nega [ - x ] to a ; TAB3 increment ne ; TAB3 increment sumne by a ; TAB2 else ; TAB3 set posi [ x ] to a ; TAB3 increment sumpo by a ; TAB1 set po to n - ne ; TAB1 if po is ne ; TAB2 print sumne + sumpo print newline ; TAB1 if po is less than ne ; TAB2 set sumne to 0 ; TAB2 create integer cont with cont = 0 ; TAB2 for i = 0 to cont is less than po + 1 , incrementing i ; TAB3 if nega [ i ] is not 0 ; TAB4 increment sumne by nega [ i ] ; TAB4 increment cont ; TAB1 if po is greater than ne ; TAB2 set sumpo to 0 ; TAB2 create integer cont with cont = 0 ; TAB2 for i = 0 to cont is less than ne + 1 exclusive ; TAB3 if posi [ i ] is not 0 ; TAB4 increment sumpo by posi [ i ] ; TAB4 increment cont ; TAB1 print sumne + sumpo print newline ;	int main ( ) { int nega [ 100003 ] , posi [ 100003 ] , ne = 0 , po = 0 , sumne = 0 , sumpo = 0 ; bool z = false ; int n , x , a ; cin >> n ; memset ( nega , 0 , sizeof nega ) ; memset ( posi , 0 , sizeof posi ) ; for ( int i = 0 ; i < n ; i ++ ) { cin >> x >> a ; if ( x < 0 ) { nega [ - x ] = a ; ne ++ ; sumne += a ; } else { posi [ x ] = a ; sumpo += a ; } } po = n - ne ; if ( po == ne ) { cout << sumne + sumpo << endl ; return 0 ; } if ( po < ne ) { sumne = 0 ; int cont = 0 ; for ( int i = 0 ; cont < po + 1 ; i ++ ) { if ( nega [ i ] != 0 ) { sumne += nega [ i ] ; cont ++ ; } } } if ( po > ne ) { sumpo = 0 ; int cont = 0 ; for ( int i = 0 ; cont < ne + 1 ; i ++ ) { if ( posi [ i ] != 0 ) { sumpo += posi [ i ] ; cont ++ ; } } } cout << sumne + sumpo << endl ; return 0 ; }
TAB0 s = array of 10000010 char ; TAB0 num = array of 100010 int ; TAB1 n = int ; TAB1 i = int ; TAB1 flag = false ; TAB1 read n ; TAB1 getchar ( ) ; TAB1 gets ( s ) ; TAB1 for i = 0 to n exclusive ; TAB2 increment num [ s [ i ] - ' a ' ] ; TAB2 if num [ s [ i ] - ' a ' ] > 1 or n is 1 flag = true ; TAB1 if flag ; TAB2 print " Yes " ; TAB1 else ; TAB2 print " No " ;	char s [ 10000010 ] ; int num [ 100010 ] ; int main ( ) { int n ; int i ; bool flag = false ; cin >> n ; getchar ( ) ; gets ( s ) ; for ( i = 0 ; i < n ; i ++ ) { num [ s [ i ] - ' a ' ] ++ ; if ( num [ s [ i ] - ' a ' ] > 1 || n == 1 ) flag = true ; } if ( flag == true ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
TAB0 create constant double with name PI = acos of - 1 ; TAB0 declare new constant integer called MAX with value 2e9 + 7 ; TAB0 MOD is a new constant integer with value 1000000007 ; TAB0 create a map from integers to long longs with name m ; TAB0 define function solve ; TAB1 create new integer a ; TAB1 read user input to a ; TAB1 create new string called s ; TAB1 read s ; TAB1 declare long long n = length of s ; TAB1 total is a new long long with value 0 ; TAB1 declare new array of integers p with n elements ; TAB1 start for loop from i = 0 to n exclusive ; TAB2 if i is false ; TAB3 change the value of p [ i ] to s [ i ] - ' 0 ' ; TAB2 else ; TAB3 assign p [ i - 1 ] + ( s [ i ] - ' 0 ' to p [ i ] ) casted to int ; TAB1 for len = 1 to n inclusive incrementing len ; TAB2 for i = 0 to n exclusive ; TAB3 create new integer variable sum with value p [ i + len - 1 ] ; TAB3 if i is not 0 , change sum to sum - p [ i - 1 ] ; TAB3 increment m [ sum ] ; TAB3 increment total ; TAB1 if a = 0 ; TAB2 print total * m [ 0 ] * 2 - m [ 0 ] * m [ 0 ] ; TAB2 return ; TAB1 create new long long called ans with value 0 ; TAB1 for i from 1 to the square root of a inclusive incrementing i ; TAB2 if a % i is equal to 0 ; TAB3 if i is equal to the square root of a ; TAB4 change ans to ans + ( ( m [ i ] * ( m [ i ] - 1 ) ) + m [ i ] ) ; TAB3 else ; TAB4 increase ans by 2 * ( m [ i ] * m [ a / i ] ) ; TAB1 print ans ; TAB1 call method solve ( ) ;	const double PI = acos ( - 1 ) ; const int MAX = 2e9 + 7 ; const int MOD = 1000000007 ; map < int , long long > m ; void solve ( ) { int a ; cin >> a ; string s ; cin >> s ; long long n = s . size ( ) ; long long total = 0 ; int p [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! i ) p [ i ] = int ( s [ i ] - ' 0 ' ) ; else p [ i ] = p [ i - 1 ] + int ( s [ i ] - ' 0 ' ) ; } for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i + len - 1 < n ; i ++ ) { int sum = p [ i + len - 1 ] ; if ( i != 0 ) sum -= p [ i - 1 ] ; m [ sum ] ++ ; total ++ ; } } if ( a == 0 ) { cout << total * m [ 0 ] * 2 - m [ 0 ] * m [ 0 ] << endl ; return ; } long long ans = 0 ; for ( int i = 1 ; i <= sqrt ( a ) ; i ++ ) { if ( a % i == 0 ) { if ( i == sqrt ( a ) ) { ans += ( ( m [ i ] * ( m [ i ] - 1 ) ) + m [ i ] ) ; } else { ans += 2 * ( m [ i ] * m [ a / i ] ) ; } } } cout << ans << endl ; } int main ( ) { solve ( ) ; return 0 ; }
TAB1 create int n , i , t , e and answer , set n = 0 , i = 0 , t = 0 , e = 0 ; TAB1 create string s ; TAB1 read s ; TAB1 for I = 0 to I different from length of s ; TAB2 if s [ I ] = n ; TAB3 increment n ; TAB2 else if s [ I ] = i ; TAB3 increment i ; TAB2 else if s [ I ] = e ; TAB3 add 1 to e ; TAB2 else if s [ I ] = t ; TAB3 t = t + 1 ; TAB1 n = ( n - 1 ) / 2 ; TAB1 set e = e / 3 ; TAB1 set answer to min of ( n , min ( e , min ( i , t ) ) ) ; TAB1 print answer ;	int main ( ) { int n = 0 , i = 0 , t = 0 , e = 0 , answer ; string s ; cin >> s ; for ( int I = 0 ; I != s . length ( ) ; ++ I ) { if ( s [ I ] == ' n ' ) n ++ ; else if ( s [ I ] == ' i ' ) i ++ ; else if ( s [ I ] == ' e ' ) e ++ ; else if ( s [ I ] == ' t ' ) t ++ ; } n = ( n - 1 ) / 2 ; e /= 3 ; answer = min ( n , min ( e , min ( i , t ) ) ) ; cout << answer << endl ; return 0 ; }
TAB1 declare arr size 1300006 as integer array = { } ; TAB1 let arr [ 1 ] be 1 ; TAB1 for i = 2 to square root of 1300006 inclusive ; TAB2 for j = i * i to 1300006 exclusive , incrementing j by i ; TAB3 if i % 2 is 0 and i is not 2 , end loop ; TAB3 let arr [ j ] be 1 ; TAB1 declare long doubles c = 0 , c2 = 0 ; TAB1 declare a , b as long longs ; TAB1 read a , b ; TAB1 declare unsigned long long maxi = 1 ; TAB1 for i = 1 to 1300006 exclusive ; TAB2 if not arr [ i ] , increment c by b ; TAB2 declare stringstream x ; TAB2 declare string s ; TAB2 let x be x bitshift left i ; TAB2 let s be string version of x ; TAB2 declare string news = s ; TAB2 reverse sort from beginning of s to end of s ; TAB2 if news is s , increment c2 by a ; TAB2 if c2 is greater than or equal to c , let maxi be maximum of maxi and i ; TAB1 set cout flag fixed , set cout precision to 0 , print maxi and newline ;	int main ( ) { int arr [ 1300006 ] = { } ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= sqrt ( 1300006 ) ; i ++ ) for ( int j = i * i ; j < 1300006 ; j += i ) { if ( i % 2 == 0 && i != 2 ) break ; arr [ j ] = 1 ; } long double c = 0 , c2 = 0 ; long long a , b ; cin >> a >> b ; unsigned long long maxi = 1 ; for ( unsigned long long i = 1 ; i < 1300006 ; i ++ ) { if ( ! arr [ i ] ) c += b ; stringstream x ; string s ; x << i ; s = x . str ( ) ; string news = s ; reverse ( s . begin ( ) , s . end ( ) ) ; if ( news == s ) c2 += a ; if ( c2 >= c ) maxi = max ( maxi , i ) ; } cout << fixed << setprecision ( 0 ) << maxi << endl ; }
TAB1 declare integers a , b , , s ; TAB1 read a , b , s ; TAB1 declare integer dis = absolute value of a + absolute value of b ; TAB1 print " Yes " if dis is less than or equal to s and dis % 2 is s % 2 , else " No " , newline ;	int main ( ) { int a , b , s ; cin >> a >> b >> s ; int dis = abs ( a ) + abs ( b ) ; cout << ( dis <= s && dis % 2 == s % 2 ? " Yes " : " No " ) << endl ; return 0 ; }
TAB1 create string time ; TAB1 read time ; TAB1 make integer vector t of size 4 ; TAB1 set t [ 0 ] to time [ 0 ] - ' 0 ' ; TAB1 set t [ 1 ] to time [ 1 ] - ' 0 ' ; TAB1 set t [ 2 ] to time [ 3 ] - ' 0 ' ; TAB1 set t [ 3 ] to time [ 4 ] - ' 0 ' ; TAB1 create integer count = 0 ; TAB1 loop indefinitely ; TAB2 if t [ 0 ] is equal to t [ 3 ] and t [ 1 ] is equal to t [ 2 ] , break loop ; TAB2 set t [ 3 ] to t [ 3 ] + 1 ; TAB2 if t [ 3 ] is greater than 9 ; TAB3 set t [ 2 ] to t [ 2 ] + 1 ; TAB3 set t [ 3 ] to 0 ; TAB3 if t [ 2 ] is greater than 5 ; TAB4 add 1 to t [ 1 ] ; TAB4 set t [ 2 ] to 0 ; TAB4 set t [ 3 ] to 0 ; TAB4 if t [ 0 ] is not equal to 2 and t [ 1 ] is greater than 9 ; TAB5 set t [ 0 ] to t [ 0 ] + 1 ; TAB5 set t [ 1 ] to 0 ; TAB5 set t [ 2 ] to 0 ; TAB5 set t [ 3 ] to 0 ; TAB4 if t [ 0 ] is equal to 2 and t [ 1 ] is greater than 3 ; TAB5 set t [ 0 ] to 0 ; TAB5 set t [ 1 ] to 0 ; TAB5 set t [ 2 ] to 0 ; TAB5 set t [ 3 ] to 0 ; TAB2 increment count ; TAB1 show count ;	int main ( ) { string time ; cin >> time ; vector < int > t ( 4 ) ; t [ 0 ] = time [ 0 ] - ' 0 ' ; t [ 1 ] = time [ 1 ] - ' 0 ' ; t [ 2 ] = time [ 3 ] - ' 0 ' ; t [ 3 ] = time [ 4 ] - ' 0 ' ; int count = 0 ; while ( true ) { if ( t [ 0 ] == t [ 3 ] && t [ 1 ] == t [ 2 ] ) { break ; } t [ 3 ] += 1 ; if ( t [ 3 ] > 9 ) { t [ 2 ] += 1 ; t [ 3 ] = 0 ; if ( t [ 2 ] > 5 ) { t [ 1 ] += 1 ; t [ 2 ] = 0 ; t [ 3 ] = 0 ; if ( t [ 0 ] != 2 && t [ 1 ] > 9 ) { t [ 0 ] += 1 ; t [ 1 ] = 0 ; t [ 2 ] = 0 ; t [ 3 ] = 0 ; } if ( t [ 0 ] == 2 && t [ 1 ] > 3 ) { t [ 0 ] = 0 ; t [ 1 ] = 0 ; t [ 2 ] = 0 ; t [ 3 ] = 0 ; } } } ++ count ; } cout << count << " \n " ; return 0 ; }
TAB0 the constant integer value of oo = 0x3f3f3f3f ; TAB0 the constant double value of PI = 2 * acos ( 0 . 0 ) ; TAB0 let x , t , a , b , da , db be integers ; TAB0 in the boolean function solve ; TAB1 for i = 0 to t exclusive ; TAB2 for j = 0 to t exclusive ; TAB3 if a - i * da + b - j * db is equal to x or a - i * da is equal to x or b - j * db is equal to x , return 1 ; TAB1 read x , t , a , b , da , db ; TAB1 if not x ; TAB2 print YES and newline ; TAB1 else do the following ; TAB2 if solve ( ) , print YES and newline else print NO and newline ;	const int oo = 0x3f3f3f3f ; const double PI = 2 * acos ( 0.0 ) ; int x , t , a , b , da , db ; bool solve ( ) { for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < t ; j ++ ) { if ( a - i * da + b - j * db == x || a - i * da == x || b - j * db == x ) return 1 ; } } return 0 ; } int main ( ) { cin >> x >> t >> a >> b >> da >> db ; if ( ! x ) cout << " YES " << endl ; else cout << ( solve ( ) ? " YES " : " NO " ) << endl ; }
TAB0 create int array win of size 300005 containing { 0 } ; TAB1 let ints n and m ; TAB1 read n and m ; TAB1 create integer set knight ; TAB1 for i = 1 to n , insert i into knight ; TAB1 for i = 0 to m exclusive ; TAB2 let ints a , b , and c ; TAB2 read a , b , and c ; TAB2 create int set iterators s , e , and p ; TAB2 set s to first value of knight comparing less ; TAB2 set e to first value of knight comparing greater ; TAB2 if the value of 3 is less than or equal to b , set e to the following value ; TAB2 for p = s to p ! = e ; TAB3 if the value of p is c ; TAB4 set p to the following value ; TAB3 otherwise ; TAB4 set win [ * p ] to c ; TAB4 erase the following value after p ; TAB1 for i = 1 to n ; TAB2 if i is not equal to 1 , print ' ' ; TAB2 print win [ i ] ; TAB1 print new line ;	int win [ 300005 ] = { 0 } ; int main ( ) { int n , m ; cin >> n >> m ; set < int > knight ; for ( int i = 1 ; i <= n + 1 ; i ++ ) knight . insert ( i ) ; for ( int i = 0 ; i < m ; i ++ ) { int a , b , c ; cin >> a >> b >> c ; set < int > :: iterator s , e , p ; s = knight . lower_bound ( a ) ; e = knight . upper_bound ( b ) ; if ( * e <= b ) e ++ ; for ( p = s ; p != e ; ) { if ( * p == c ) p ++ ; else { win [ * p ] = c ; knight . erase ( p ++ ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i != 1 ) cout << '   ' ; cout << win [ i ] ; } cout << endl ; return 0 ; }
TAB1 s , n , i = integers ; TAB1 dragon = multimap from int to int ; TAB1 temp = pair of int and int ; TAB1 r = pair of multimap < int , int > iterator and multimap < int , int > iterator ; TAB1 it1 , it2 = multimap from int to int iterator ; TAB1 print s , n ; TAB1 for i = 0 to n - 1 ; TAB2 read temp . first , temp . second ; TAB2 insert temp in dragon ; TAB1 for it1 = dragon . begin ( ) to it1 is not dragon . lower_bound ( s ) ; TAB2 r = dragon . equal_range ( first of it1 ) ; TAB2 for it2 = r . first to it2 is not r . second , s = s + second in it2 ; TAB2 decrement it1 ; TAB1 if it1 is dragon . end ( ) ; TAB2 print YES ; TAB1 else ; TAB2 print NO ;	int main ( ) { int s , n , i ; multimap < int , int > dragon ; pair < int , int > temp ; pair < multimap < int , int > :: iterator , multimap < int , int > :: iterator > r ; multimap < int , int > :: iterator it1 , it2 ; cin >> s >> n ; for ( i = 0 ; i <= n - 1 ; i ++ ) { cin >> temp . first >> temp . second ; dragon . insert ( temp ) ; } for ( it1 = dragon . begin ( ) ; it1 != dragon . lower_bound ( s ) ; it1 ++ ) { r = dragon . equal_range ( it1 -> first ) ; for ( it2 = r . first ; it2 != r . second ; it2 ++ , it1 ++ ) s += it2 -> second ; it1 -- ; } if ( it1 == dragon . end ( ) ) cout << " YES\n " ; else cout << " NO\n " ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 mx , crr = integer array of size n ; TAB1 mxn = integer with mxn = INT_MIN ; TAB1 for i = 0 to cast to integer n exclusive ; TAB2 tmp , val , m = integer with tmp = INT_MIN ; TAB2 read m ; TAB2 crr [ i ] = m ; TAB2 for j = 0 to cast to integer m ; TAB3 read val ; TAB3 tmp = max of tmp and val ; TAB2 mx [ i ] = tmp ; TAB2 mxn = max of mxn and tmp ; TAB1 ans = long long integer with ans = 0 ; TAB1 for i = 0 to cast to integer n , ans = ans + ( 1LL * ( mxn - mx [ i ] ) * crr [ i ] ) ; TAB1 print ans ;	int main ( ) { int n ; cin >> n ; int mx [ n ] , crr [ n ] ; int mxn = INT_MIN ; for ( int i = 0 ; i < int ( n ) ; i ++ ) { int tmp = INT_MIN , val , m ; cin >> m ; crr [ i ] = m ; for ( int j = 0 ; j < int ( m ) ; j ++ ) { cin >> val ; tmp = max ( tmp , val ) ; } mx [ i ] = tmp ; mxn = max ( mxn , tmp ) ; } long long int ans = 0 ; for ( int i = 0 ; i < int ( n ) ; i ++ ) { ans += ( 1LL * ( mxn - mx [ i ] ) * crr [ i ] ) ; } cout << ans << " \n " ; return 0 ; }
TAB0 define function lcm which takes in long long integers , a , b , and c as arguments ; TAB1 let ans be a long long integer and set its value to a * b / __gcd ( a , b ) ; TAB1 set ans to ( ans * c ) / __gcd ( ans , c ) ; TAB1 return the value of ans ; TAB1 let n be a long long integer ; TAB1 read in n ; TAB1 let maxim be a long long integer and set its value to - 1 ; TAB1 for i = 0 iterate until i is greater than or equal to the max of 1LL and n - 6 ; TAB2 for j = n iterate until j is greater or equal to the max of 1LL and n - 6 ; TAB3 for k = n iterate until k is greater than or equal to the max of 1LL and n - 6 , set maxim to the max of lcm ( i , j , k ) and maxim ; TAB1 print maxim ;	long long lcm ( long long a , long long b , long long c ) { long long ans = a * b / __gcd ( a , b ) ; ans = ( ans * c ) / __gcd ( ans , c ) ; return ans ; } int main ( ) { long long n ; cin >> n ; long long maxim = - 1 ; for ( long long i = n ; i >= max ( 1LL , n - 6 ) ; i -- ) for ( long long j = n ; j >= max ( 1LL , n - 6 ) ; j -- ) for ( long long k = n ; k >= max ( 1LL , n - 6 ) ; k -- ) maxim = max ( lcm ( i , j , k ) , maxim ) ; cout << maxim << endl ; return 0 ; }
TAB0 create integer n ; TAB0 declare is_x1 with integers a , b as arguments , returning integer ; TAB1 if b is 0 and a is greater than or equal to 0 and a is less than or equal to n , return 1 from function ; TAB0 declare is_x2 with integers a , b as arguments , returning integer ; TAB1 if b is n and a is greater than or equal to 0 and a is less than or equal to n , return 3 from function ; TAB0 declare is_y1 with integers b , a as arguments , returning integer ; TAB1 if b is 0 and a is greater than 0 or equal to 0 and a is less than or equal to n , return 4 from function ; TAB0 declare is_y2 with integers b , a as arguments , returning integer ; TAB1 if b is n and a is greater than or equal to 0 and a is less than or equal to n , return 2 from function ; TAB1 create integer t ; TAB1 create integers x1 , x2 , y1 , y2 , j ; TAB1 read n read x1 read y1 read x2 read y2 ; TAB1 create integers value1 , value2 , val , a , b , set val to 0 ; TAB1 for i = 0 to 2 exclusive ; TAB2 if i is 0 ; TAB3 set a to x1 , set b to y1 ; TAB2 else ; TAB3 set a to x2 , set b to y2 ; TAB2 set j to 1 ; TAB2 while not val ; TAB3 if j is 1 ; TAB4 set val to result of run is_x1 with a , b as arguments ; TAB3 else if j is 2 ; TAB4 set val to result of run is_y1 with a , b as arguments ; TAB3 else if j is 3 ; TAB4 set val to result of run is_x2 with a , b as arguments ; TAB3 else if j is 4 ; TAB4 set val to result of run is_y2 with a , b as arguments ; TAB3 increment j ; TAB2 if i is 0 ; TAB3 set value1 to val ; TAB2 else ; TAB3 set value2 to val ; TAB2 set val to 0 ; TAB1 if value1 is value2 ; TAB2 if value1 is 1 or value1 is 3 ; TAB3 print absolute value of ( x1 - x2 ) print " \ n " ; TAB2 else ; TAB3 print absolute value of ( y1 - y2 ) print " \ n " ; TAB1 else if ( value1 is 1 and value 2 is 2 ) or ( value1 is 2 and value 2 is 1 ) ; TAB2 if value1 is 1 ; TAB3 print ( n - x1 ) + y2 print " \ n " ; TAB2 else ; TAB3 print ( n - x2 ) + y1 print " \ n " ; TAB1 else if ( value1 is 1 and value2 is 4 ) or ( value1 is 4 and value2 is 1 ) ; TAB2 if value1 is 1 ; TAB3 print x1 + y2 print " \ n " ; TAB2 else ; TAB3 print x2 + y1 print " \ n " ; TAB1 else if ( value1 is 2 and value 2 is 3 ) or ( value1 is 3 and value2 is 2 ) ; TAB2 if value1 is 2 ; TAB3 print ( n - y1 ) + ( n - x2 ) print " \ n " ; TAB2 else ; TAB3 print ( n - y2 ) + ( n - x1 ) print " \ n " ; TAB1 else if ( value1 is 3 and value2 is 4 ) or ( value1 is 4 and value2 is 3 ) ; TAB2 if value1 is 3 ; TAB3 print x1 + n - y2 print " \ n " ; TAB2 else ; TAB3 print x2 + n - y1 print " \ n " ; TAB1 else if ( value1 is 1 and value2 is 3 ) or ( value1 is 3 and value2 is 1 ) ; TAB2 print minimum of x1 + n + x2 and n - x1 + n + n - x2 print " \ n " ; TAB1 else if ( value1 is 2 and value2 is 4 ) or ( value1 is 4 and value2 is 2 ) ; TAB2 print minimum of y1 + n + y2 and n - y1 + n + n - y2 print " \ n " ;	int n ; int is_x1 ( int a , int b ) { if ( b == 0 && a >= 0 && a <= n ) return 1 ; return 0 ; } int is_x2 ( int a , int b ) { if ( b == n && a >= 0 && a <= n ) return 3 ; return 0 ; } int is_y1 ( int b , int a ) { if ( b == 0 && a >= 0 && a <= n ) return 4 ; return 0 ; } int is_y2 ( int b , int a ) { if ( b == n && a >= 0 && a <= n ) return 2 ; return 0 ; } int main ( ) { int t ; int x1 , x2 , y1 , y2 , j ; cin >> n >> x1 >> y1 >> x2 >> y2 ; int value1 , value2 , val = 0 , a , b ; for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 0 ) { a = x1 , b = y1 ; } else { a = x2 , b = y2 ; } j = 1 ; while ( ! val ) { if ( j == 1 ) val = is_x1 ( a , b ) ; else if ( j == 2 ) val = is_y1 ( a , b ) ; else if ( j == 3 ) val = is_x2 ( a , b ) ; else if ( j == 4 ) val = is_y2 ( a , b ) ; j ++ ; } if ( i == 0 ) value1 = val ; else value2 = val ; val = 0 ; } if ( value1 == value2 ) { if ( value1 == 1 || value1 == 3 ) { cout << abs ( x1 - x2 ) << " \n " ; } else cout << abs ( y1 - y2 ) << " \n " ; } else if ( ( value1 == 1 && value2 == 2 ) || ( value1 == 2 && value2 == 1 ) ) { if ( value1 == 1 ) cout << ( n - x1 ) + y2 << " \n " ; else cout << ( n - x2 ) + y1 << " \n " ; } else if ( ( value1 == 1 && value2 == 4 ) || ( value1 == 4 && value2 == 1 ) ) { if ( value1 == 1 ) cout << x1 + y2 << " \n " ; else cout << x2 + y1 << " \n " ; } else if ( ( value1 == 2 && value2 == 3 ) || ( value1 == 3 && value2 == 2 ) ) { if ( value1 == 2 ) cout << ( n - y1 ) + ( n - x2 ) << " \n " ; else cout << ( n - y2 ) + ( n - x1 ) << " \n " ; } else if ( ( value1 == 3 && value2 == 4 ) || ( value1 == 4 && value2 == 3 ) ) { if ( value1 == 3 ) cout << x1 + n - y2 << " \n " ; else cout << x2 + n - y1 << " \n " ; } else if ( ( value1 == 1 && value2 == 3 ) || ( value1 == 3 && value2 == 1 ) ) { cout << ( min ( x1 + n + x2 , n - x1 + n + n - x2 ) ) << " \n " ; } else if ( ( value1 == 2 && value2 == 4 ) || ( value1 == 4 && value2 == 2 ) ) { cout << ( min ( y1 + n + y2 , n - y1 + n + n - y2 ) ) << " \n " ; } return 0 ; }
TAB0 a = unsigned long long array of size 2000000 ; TAB0 b = unsigned long long array of size 2000000 ; TAB0 n = integer ; TAB0 in the function judge that takes integer n and returns bool ; TAB1 for i = 0 to n - 1 exclusive ; TAB2 if a [ i ] is a [ i + 1 ] , return true ; TAB1 return false ; TAB1 while read n ; TAB2 set all contents of a to 0 ; TAB2 for i = 0 to n exclusive ; TAB3 read a [ i ] ; TAB3 increment b [ a [ i ] ] ; TAB2 sort a and a + n ; TAB2 ans = integer with ans = 0 ; TAB2 for i = 1 to 2000000 exclusive ; TAB3 b [ i ] = b [ i ] + ( b [ i - 1 ] / 2 ) ; TAB3 b [ i - 1 ] = b [ i - 1 ] modulo 2 ; TAB3 ans = ans + b [ i - 1 ] ; TAB2 print ans ;	unsigned long long a [ 2000000 ] ; unsigned long long b [ 2000000 ] ; int n ; bool judge ( int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) return true ; } return false ; } int main ( ) { while ( cin >> n ) { memset ( a , 0 , sizeof ( a ) ) ; for ( int i = 0 ; i < n ; ++ i ) { cin >> a [ i ] ; b [ a [ i ] ] ++ ; } sort ( a , a + n ) ; int ans = 0 ; for ( int i = 1 ; i < 2000000 ; ++ i ) { b [ i ] += ( b [ i - 1 ] / 2 ) ; b [ i - 1 ] %= 2 ; ans += b [ i - 1 ] ; } cout << ans << endl ; } }
TAB0 declare constant integer N = 1e5 + 10 ; TAB0 declare long longs n , a , m , d ; TAB0 declare long long array t size N , long long da ; TAB0 declare nextDiv with long longs bound , div as arguments , returning long long ; TAB1 return ( bound if bound % div is 0 , else bound + div - bound % div ) ; TAB0 declare nextDiv with long longs bound , num , div as arguments , returning long long ; TAB1 if ( bound % div is 0 ) return bound + num * div ; TAB1 return result of run nextDiv ( bound , div ) + ( num - 1 ) * div ; TAB0 declare prevDiv with long longs bound , div as arguments , returning long long ; TAB1 return bound if bound % div is 0 , else bound - bound % div ; TAB0 declare numDiv with long longs L , R , div as arguments , returning long long ; TAB1 return result of run prevDiv ( R , div ) / div - result of run prevDiv ( L - 1 , div ) / div ; TAB0 declare numOpen with long longs L , R as arguments , returning pair of long long , long long ; TAB1 declare long long realR = minimum of ( R and n * a ) ; TAB1 declare long long xx = result of numDiv ( L , realR , a ) ; TAB1 if xx is less than or equal to da , return { 1 , result of run nextDiv ( L , a ) + d } ; TAB1 declare long long noob = xx - da if xx % da is 0 , else xx - xx % da ; TAB1 declare long long nextt = result of run nextDiv ( L , noob , a ) ; TAB1 if xx % da is 0 , return { xx / da , nextt + d } ; TAB1 return { 1 + xx / da , nextt + d } from function ; TAB0 declare special with long long bound as argument , returning long long ; TAB1 declare long long cur = result of run nextDiv ( bound + 1 , a ) ; TAB1 if n is less than result of run numDiv ( a , bound , a ) , return 0 from function ; TAB1 declare long long numLeft = n - result of run numDiv ( a , bound , a ) ; TAB1 if numLeft is greater than 0 ; TAB2 return first element of result of run numOpen ( cur , result of run nextDiv ( cur , numLeft - 1 , a ) ) ; TAB1 else ; TAB0 declare solve with no arguments , returning void ; TAB1 declare long long cur = minimum of ( a , t [ 1 ] ) ; TAB1 declare long long pt = 1 ; TAB1 declare long long ans = 0 ; TAB1 while pt is less than or equal to m ; TAB2 if cur is not t [ pt ] ; TAB3 declare pair of long long , long long xop = result of run numOpen ( cur , t [ pt ] - 1 ) ; TAB3 increment ans by first element xop ; TAB3 while pt is less than or equal to m and t [ pt ] is less than or equal to second element of xop , increment pt ; TAB3 if pt is m + 1 ; TAB4 increment ans by result of run special ( second element of xop ) ; TAB4 end loop ; TAB3 let cur be t [ pt ] ; TAB3 if result of run numDiv ( a , second element of xop , a ) is less than n , let cur be minimum of ( t [ pt ] and result of run nextDiv ( second element of xop + 1 , a ) ) ; TAB2 else ; TAB3 increment ans ; TAB3 declare long long neo = pt ; TAB3 while pt is less than m and t [ pt + 1 ] - t [ neo ] is less than or equal to d , increment pt ; TAB3 if pt is m ; TAB4 increment ans by result of run special ( t [ neo ] + d ) ; TAB4 end loop ; TAB3 increment pt ; TAB3 let cur be t [ pt ] ; TAB3 if ( result of run numDiv ( a , t [ neo ] + d , a ) is less than n ) cur = minimum of ( t [ pt ] and result of run nextDiv ( t [ neo ] + d + 1 , a ) ) ; TAB1 print ans and ' \ n ' ; TAB1 read n , m , a , d ; TAB1 for i = 1 to m inclusive , read t [ i ] ; TAB1 let da be result of run numDiv ( a , a + d , a ) ; TAB1 run solve ;	const int N = 1e5 + 10 ; long long n , a , m , d ; long long t [ N ] , da ; long long nextDiv ( long long bound , long long div ) { return ( bound % div == 0 ? bound : bound + div - bound % div ) ; } long long nextDiv ( long long bound , long long num , long long div ) { if ( bound % div == 0 ) return bound + ( num ) * div ; return nextDiv ( bound , div ) + ( num - 1 ) * div ; } long long prevDiv ( long long bound , long long div ) { return ( bound % div == 0 ? bound : bound - bound % div ) ; } long long numDiv ( long long L , long long R , long long div ) { return prevDiv ( R , div ) / div - prevDiv ( L - 1 , div ) / div ; } pair < long long , long long > numOpen ( long long L , long long R ) { long long realR = min ( R , n * a ) ; long long xx = numDiv ( L , realR , a ) ; if ( xx <= da ) return { 1 , nextDiv ( L , a ) + d } ; long long noob = ( xx % da == 0 ? xx - da : xx - xx % da ) ; long long nextt = nextDiv ( L , noob , a ) ; if ( xx % da == 0 ) return { xx / da , nextt + d } ; return { 1 + xx / da , nextt + d } ; } long long special ( long long bound ) { long long cur = nextDiv ( bound + 1 , a ) ; if ( n < numDiv ( a , bound , a ) ) return 0 ; long long numLeft = n - numDiv ( a , bound , a ) ; if ( numLeft > 0 ) return numOpen ( cur , nextDiv ( cur , numLeft - 1 , a ) ) . first ; else return 0 ; } void solve ( ) { long long cur = min ( a , t [ 1 ] ) ; long long pt = 1 ; long long ans = 0 ; while ( pt <= m ) { if ( cur != t [ pt ] ) { pair < long long , long long > xop = numOpen ( cur , t [ pt ] - 1 ) ; ans += xop . first ; while ( pt <= m && t [ pt ] <= xop . second ) pt ++ ; if ( pt == m + 1 ) { ans += special ( xop . second ) ; break ; } cur = t [ pt ] ; if ( numDiv ( a , xop . second , a ) < n ) cur = min ( t [ pt ] , nextDiv ( xop . second + 1 , a ) ) ; } else { ans ++ ; long long neo = pt ; while ( pt < m && t [ pt + 1 ] - t [ neo ] <= d ) pt ++ ; if ( pt == m ) { ans += special ( t [ neo ] + d ) ; break ; } pt ++ ; cur = t [ pt ] ; if ( numDiv ( a , t [ neo ] + d , a ) < n ) cur = min ( t [ pt ] , nextDiv ( t [ neo ] + d + 1 , a ) ) ; } } cout << ans << ' \n ' ; } int main ( ) { cin >> n >> m >> a >> d ; for ( int i = 1 ; i <= m ; i ++ ) cin >> t [ i ] ; da = numDiv ( a , a + d , a ) ; solve ( ) ; }
TAB0 declare long long array a size 1000 by 1000 ; TAB0 declare long long q ; TAB0 declare fun with long long i as argument , returning long long ; TAB1 for j = 0 to 1000 exclusive ; TAB2 if a [ i ] [ j ] is not 0 , return minimum of ( result of run fun ( j ) and a [ i ] [ j ] ) ; TAB1 let q be i ; TAB1 return INT_MAX from function ; TAB0 declare long long vector array vid size 3 ; TAB1 end statement ; TAB1 declare n , p as long long ; TAB1 read n and p ; TAB1 declare x , y , z as long long ; TAB1 for i = 0 to p exclusive ; TAB2 read x , y , z ; TAB2 let a [ x - 1 ] [ y - 1 ] be z ; TAB1 for i = 0 to n exclusive ; TAB2 declare long long j ; TAB2 for j = 0 to n exclusive ; TAB3 if a [ j ] [ i ] is not 0 , end loop ; TAB2 if j is n ; TAB3 declare integer k = result of run fun with i as argument ; TAB3 if q is not i ; TAB4 add i to end of vid [ 0 ] ; TAB4 add k to end of vid [ 2 ] ; TAB4 add q to end of vid [ 1 ] ; TAB1 print size of vid [ 0 ] and newline ; TAB1 for i = 0 to size of vid [ 0 ] exclusive , print vid [ 0 ] [ i ] + 1 , ' ' , vid [ 1 ] [ i ] + 1 , ' ' , vid [ 2 ] [ i ] , ' \ n ' ;	long long a [ 1000 ] [ 1000 ] ; long long q ; long long fun ( long long i ) { for ( long long j = 0 ; j < 1000 ; j ++ ) { if ( a [ i ] [ j ] != 0 ) { return min ( fun ( j ) , a [ i ] [ j ] ) ; } } q = i ; return INT_MAX ; } vector < long long > vid [ 3 ] ; int main ( ) { ; long long n , p ; cin >> n >> p ; long long x , y , z ; for ( long long i = 0 ; i < p ; i ++ ) { cin >> x >> y >> z ; a [ x - 1 ] [ y - 1 ] = z ; } for ( long long i = 0 ; i < n ; i ++ ) { long long j ; for ( j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] != 0 ) break ; } if ( j == n ) { int k = fun ( i ) ; if ( q != i ) { vid [ 0 ] . push_back ( i ) ; vid [ 2 ] . push_back ( k ) ; vid [ 1 ] . push_back ( q ) ; } } } cout << vid [ 0 ] . size ( ) << endl ; for ( long long i = 0 ; i < vid [ 0 ] . size ( ) ; i ++ ) { cout << vid [ 0 ] [ i ] + 1 << '   ' << vid [ 1 ] [ i ] + 1 << '   ' << vid [ 2 ] [ i ] << ' \n ' ; } }
TAB0 create ints i , j , k , m , n , and l and int array ans of size 20000 ; TAB0 create char arrays a of size 20000 , b of size 20000 , c of size 20000 , and d of size 20000 ; TAB1 for i = 0 to 20000 exclusive , set ans [ i ] to 0 ; TAB1 read a ; TAB1 read d ; TAB1 set m to strlen ( d ) ; TAB1 for i = 0 to m - 1 exclusive , set b [ i ] to ' ' ; TAB1 append a to b ; TAB1 set n to strlen ( b ) ; TAB1 for i = n to m + n - 1 exclusive , set b [ i ] to ' 0 ' ; TAB1 set l to m ; TAB1 for i = 0 to n exclusive ; TAB2 for k = i to i + 1 exclusive , set c [ k - i ] to b [ k ] ; TAB2 for j = 0 to l exclusive ; TAB3 if d [ j ] is equal to c [ j ] , increment ans [ i ] ; TAB1 sort ans using argument ans + n + 1 ; TAB1 print m - ans [ i ] ;	int ans [ 20000 ] , i , j , k , m , n , l ; char a [ 20000 ] , b [ 20000 ] , c [ 20000 ] , d [ 20000 ] ; int main ( ) { for ( i = 0 ; i < 2000 ; ++ i ) ans [ i ] = 0 ; gets ( a ) ; gets ( d ) ; m = strlen ( d ) ; for ( i = 0 ; i < m - 1 ; ++ i ) b [ i ] = '   ' ; strcat ( b , a ) ; n = strlen ( b ) ; for ( i = n ; i < m + n - 1 ; ++ i ) b [ i ] = ' 0 ' ; l = m ; for ( i = 0 ; i < n ; ++ i ) { for ( k = i ; k < i + l ; ++ k ) c [ k - i ] = b [ k ] ; for ( j = 0 ; j < l ; ++ j ) { if ( d [ j ] == c [ j ] ) ans [ i ] ++ ; } } sort ( ans , ans + n + 1 ) ; cout << m - ans [ i ] << endl ; return 0 ; }
TAB0 mp = long long , long long map ; TAB1 i , j , a , ans , cnt , n = long long with ans = 0 ; TAB1 s = string ; TAB1 read a then s ; TAB1 set n to size of s as int ; TAB1 for i = 0 to n decrement s [ i ] by 48 ; TAB1 for i = 0 to n ; TAB2 set cnt to 0 ; TAB2 for j = i to n ; TAB3 increment cnt by s [ j ] ; TAB3 increment mp [ cnt ] ; TAB1 for i = 0 to n ; TAB2 set cnt to 0 ; TAB2 for j = i to n ; TAB3 increment cnt by s [ j ] ; TAB3 if cnt and a are both 0 ; TAB4 increment ans by ( n * ( n + 1 ) ) / 2 ; TAB3 else if cnt is not 0 and a is a multiple if cnt and mp contains key a / cnt ; TAB4 increment ans by mp [ a / cnt ] ; TAB1 print ans ;	map < long long , long long > mp ; int main ( ) { long long i , j , a , ans = 0 , cnt , n ; string s ; cin >> a >> s ; n = ( int ) ( s . size ( ) ) ; for ( i = 0 ; i < n ; i ++ ) s [ i ] -= 48 ; for ( i = 0 ; i < n ; i ++ ) { cnt = 0 ; for ( j = i ; j < n ; j ++ ) { cnt += s [ j ] ; mp [ cnt ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { cnt = 0 ; for ( j = i ; j < n ; j ++ ) { cnt += s [ j ] ; if ( cnt == 0 && a == 0 ) ans += ( n * ( n + 1 ) ) / 2 ; else if ( cnt != 0 && a % cnt == 0 && mp . find ( a / cnt ) != mp . end ( ) ) ans += mp [ a / cnt ] ; } } cout << ans << " \n " ; return 0 ; }
TAB1 n = integer ; TAB1 read n ; TAB1 ans = bool with ans = false ; TAB1 sqr = integer with sqr = ceil ( sqrt ( 2 * n ) ) ; TAB1 for i = 1 to sqr ; TAB2 for j = i to sqr ; TAB3 if i * ( i + 1 ) + j * ( j + 1 ) is 2 * n ; TAB4 ans = true ; TAB4 break loop ; TAB2 if ( ans ) break loop ; TAB1 if ans print YES , else NO ;	int main ( ) { int n ; cin >> n ; bool ans = false ; int sqr = ceil ( sqrt ( 2 * n ) ) ; for ( int i = 1 ; i <= sqr ; i ++ ) { for ( int j = i ; j <= sqr ; j ++ ) { if ( i * ( i + 1 ) + j * ( j + 1 ) == 2 * n ) { ans = true ; break ; } } if ( ans ) break ; } cout << ( ans ? " YES " : " NO " ) << endl ; return 0 ; }
TAB0 d = inta rray of size 30 ; TAB0 t = int array of size 7 ; TAB0 ne , me = int ; TAB0 n , m = int ; TAB0 in function check returning a bool ; TAB1 tn = int with tn = 0 ; TAB1 b = int with b = 1 ; TAB1 for i = 0 to ne ; TAB2 add t [ i ] * b to tn ; TAB2 set b to b * 7 ; TAB1 set b to 1 ; TAB1 tm = int with tm = 0 ; TAB1 for i = ne to me ; TAB2 add t [ i ] * b to tm ; TAB2 set b to b * 7 ; TAB1 return tn is less or equal to n and tm is less or equal to m ; TAB0 ans = int with ans = 0 ; TAB0 in function dfs0 taking an int p ; TAB1 if p is greater or equal to me ; TAB2 add value of check to ans ; TAB2 return ; TAB1 for i = p to me ; TAB2 call swap on t [ p ] and t [ i ] ; TAB2 call dfs0 on p + 1 ; TAB2 call swap on t [ p ] and t [ i ] ; TAB0 in function dfs1 ; TAB1 for s = 1 bitshift left 7 - 1 decrement s while s is greater than 0 ; TAB2 cnt = int with cnt = 0 ; TAB2 for j = 0 to 7 ; TAB3 if s bitshift right j bitwise - and 1 is true then set t [ cnt ] to j then increment cnt ; TAB2 if cnt equals me then call dfs0 of 0 ; TAB1 read n then m ; TAB1 decrement n ; TAB1 decrement m ; TAB1 set ne to 0 ; TAB1 dn , dm = int with dn = n and dm = m ; TAB1 if dn equals 0 ; TAB2 increment ne ; TAB1 else ; TAB2 loop while dn is not 0 ; TAB3 set d [ ne ] to dn mod 7 then increment ne ; TAB3 set dn to dn / 7 ; TAB1 set me to ne ; TAB1 if dm equals 0 ; TAB2 increment me ; TAB1 else ; TAB2 while dm is not 0 ; TAB3 set d [ me ) to dm mod 7 then increment me ; TAB3 set dm to dm / 7 ; TAB1 if me is greater than 7 ; TAB2 print 0 ; TAB1 else ; TAB2 call dfs1 ; TAB2 print ans ;	int d [ 30 ] ; int t [ 7 ] ; int ne , me ; int n , m ; bool check ( ) { int tn = 0 ; int b = 1 ; for ( int i = 0 ; i < ne ; i ++ ) { tn += t [ i ] * b ; b *= 7 ; } b = 1 ; int tm = 0 ; for ( int i = ne ; i < me ; i ++ ) { tm += t [ i ] * b ; b *= 7 ; } return ( tn <= n && tm <= m ) ; } int ans = 0 ; void dfs0 ( int p ) { if ( p >= me ) { ans += check ( ) ; return ; } for ( int i = p ; i < me ; i ++ ) { swap ( t [ p ] , t [ i ] ) ; dfs0 ( p + 1 ) ; swap ( t [ p ] , t [ i ] ) ; } } void dfs1 ( ) { for ( int s = ( 1 << 7 ) - 1 ; s > 0 ; s -- ) { int cnt = 0 ; for ( int j = 0 ; j < 7 ; j ++ ) { if ( ( s >> j ) & 1 ) { t [ cnt ++ ] = j ; } } if ( cnt == me ) { dfs0 ( 0 ) ; } } } int main ( ) { cin >> n >> m ; n -- ; m -- ; ne = 0 ; int dn = n , dm = m ; if ( dn == 0 ) { ne ++ ; } else { while ( dn ) { d [ ne ++ ] = dn % 7 ; dn /= 7 ; } } me = ne ; if ( dm == 0 ) { me ++ ; } else { while ( dm ) { d [ me ++ ] = dm % 7 ; dm /= 7 ; } } if ( me > 7 ) { cout << 0 << endl ; } else { dfs1 ( ) ; cout << ans << endl ; } return 0 ; }
TAB0 s is a new array of characters with size 1005 ; TAB1 n is a new integer ; TAB1 read n from the user input ; TAB1 read the value of s + 1 from the input ; TAB1 declare integers cnt , cnt0 , cnt1 = 0 and l = n / 2 ; TAB1 if n is odd increment l by one ; TAB1 for i = 1 to n inclusive ; TAB2 change cnt to cnt + s [ i ] - ' 0 ' ; TAB2 if s [ i ] = ' 0 ' , increment cnt0 and assign 0 to cnt1 ; TAB2 if s [ i ] is equal to ' 1 ' , increment cnt1 and assign the new value = 0 to cnt0 ; TAB2 if cnt0 = 3 or cnt1 is equal to 2 ; TAB3 print " No " ; TAB1 if n = 1 and s [ 1 ] is equal to ' 0 ' ; TAB2 print " No " ; TAB1 else if ( s [ 1 ] = ' 0 ' and s [ 2 ] = ' 0 ' ) or ( s [ n - 1 ] = ' 0 ' and s [ n ] = ' 0 ' ) ; TAB2 print " No " ; TAB1 else ; TAB2 print " Yes " ;	char s [ 1005 ] ; int main ( ) { int n ; cin >> n ; cin >> s + 1 ; int cnt = 0 , cnt0 = 0 , cnt1 = 0 , l = n / 2 ; if ( n % 2 ) l ++ ; for ( int i = 1 ; i <= n ; i ++ ) { cnt += s [ i ] - ' 0 ' ; if ( s [ i ] == ' 0 ' ) cnt0 ++ , cnt1 = 0 ; if ( s [ i ] == ' 1 ' ) cnt1 ++ , cnt0 = 0 ; if ( cnt0 == 3 || cnt1 == 2 ) { cout << " No " << endl ; return 0 ; } } if ( n == 1 && s [ 1 ] == ' 0 ' ) cout << " No " << endl ; else if ( ( s [ 1 ] == ' 0 ' && s [ 2 ] == ' 0 ' ) || ( s [ n - 1 ] == ' 0 ' && s [ n ] == ' 0 ' ) ) cout << " No " << endl ; else cout << " Yes " << endl ; return 0 ; }
TAB0 declare array of integers a of size 500010 ; TAB1 create integer n ; TAB1 read n ; TAB1 read n values into array a ; TAB1 create integer ans = 0 ; TAB1 let l and r be integers ; TAB1 let i be an int and for i = 0 to i = n exclusive ; TAB2 set l to i ; TAB2 assign i + 1 to r ; TAB2 while r is less than n and a [ l ] is not equal to [ r ] ; TAB3 increment l ; TAB3 r = r + 1 ; TAB2 set l to i + 1 ; TAB2 r = r - 2 ; TAB2 create int num = 0 ; TAB2 while l is less than or equal to r ; TAB3 set a [ l ] to a [ l - 1 ] ; TAB3 set a [ r ] to a [ r + 1 ] ; TAB3 increment l ; TAB3 decrement r ; TAB3 increment num ; TAB2 assign max of ans and num to ans ; TAB1 print ans ; TAB1 print n values of array a separated by a space ; TAB1 print a [ n - 1 ] ;	int a [ 500010 ] ; int main ( ) { int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) cin >> a [ i ] ; int ans ( 0 ) ; int l , r ; for ( int i = 0 ; i < n ; i ++ ) { l = i ; r = i + 1 ; while ( r < n && a [ l ] != a [ r ] ) { l ++ ; r ++ ; } l = i + 1 ; r -= 2 ; int num ( 0 ) ; while ( l <= r ) { a [ l ] = a [ l - 1 ] ; a [ r ] = a [ r + 1 ] ; l ++ ; r -- ; num ++ ; } ans = max ( ans , num ) ; } cout << ans << endl ; for ( int i = 0 ; i < n - 1 ; i ++ ) cout << a [ i ] << '   ' ; cout << a [ n - 1 ] << endl ; return 0 ; }
TAB0 define function power which takes in long integers x and y as parameters ; TAB1 let temp be a long long integer ; TAB1 if y is equal to 0 , return 1 ; TAB1 set temp to power ( x , y / 2 ) ; TAB1 if y is even ; TAB2 return the value of temp * temp ; TAB1 or else ; TAB2 if y is greater than 0 ; TAB3 return the value of x * temp * temp ; TAB2 or else ; TAB3 return the value of ( temp * temp ) / x ; TAB0 let prime be an array of booleans of size 10000000 ; TAB0 define function sieve ; TAB1 set every value in prime to true ; TAB1 set prime [ 0 ] and prime [ 1 ] to false ; TAB1 for p = 2 to p * p < = 10000000 ; TAB2 if prime [ p ] is true ; TAB3 for i = p * 2 to i < = 10000000 ; TAB0 define function gcd which takes in long long integers a and b as arguments ; TAB1 if a is equal to 0 , return the value of b ; TAB1 return the greatest common denominator of b % a and a ; TAB1 let n , m , k , and l be integers ; TAB1 read in n , m , k and l ; TAB1 if m is greater than n or l is greater than n - k ; TAB2 print - 1 and a newline ; TAB1 let x be a long long integer ; TAB1 set x to ( k + l ) / m ; TAB1 if ( k + l ) % m is not equal to 0 , increment x ; TAB1 if m * x is greater than n ; TAB2 print - 1 and a newline ; TAB1 or else ; TAB2 print x and a newline ;	long long int power ( long long int x , long long int y ) { long long int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } bool prime [ 10000000 ] ; void sieve ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( long long int p = 2 ; p * p <= 10000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( long long int i = p * 2 ; i <= 10000000 ; i += p ) prime [ i ] = false ; } } } long long int gcd ( long long int a , long long int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int main ( ) { long long int n , m , k , l ; cin >> n >> m >> k >> l ; if ( m > n || l > n - k ) { cout << - 1 << " \n " ; return 0 ; } long long int x ; x = ( k + l ) / m ; if ( ( k + l ) % m != 0 ) x ++ ; if ( m * x > n ) { cout << - 1 << " \n " ; } else { cout << x << " \n " ; } return 0 ; }
TAB1 create integers a , b , c , and d ; TAB1 read a , b , c , and d ; TAB1 if b - a is equal to c - b and d - c is equal to c - b ; TAB2 print d + c - b ; TAB1 else do ; TAB2 create double m = 1 . 0 * b / a ; TAB2 if m * b is equal to c and m * c is equal to d ; TAB3 make double k = d * m ; TAB3 let integer kk = d * m ; TAB3 if kk is equal to k ; TAB4 print kk ; TAB1 print 42 ;	int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; if ( b - a == c - b && d - c == c - b ) { cout << d + c - b << endl ; return 0 ; } else { double m = 1.0 * b / a ; if ( m * b == c && m * c == d ) { double k = d * m ; int kk = d * m ; if ( kk == k ) { cout << kk << endl ; return 0 ; } } } cout << 42 << endl ; return 0 ; }
TAB0 s , t = strings with s = array of size 105 ; TAB0 sl , tl = strings with sl = array of size 105 ; TAB0 ok = array of 105 bool ; TAB0 n = integer ; TAB0 in the function getLower that takes string s and returns string ; TAB1 for i = 0 to s . size ( ) exclusive , s [ i ] = tolower ( s [ i ] ) ; TAB1 return s ; TAB1 read n ; TAB1 i , j , k = integers ; TAB1 for i = 0 to n exclusive ; TAB2 read s [ i ] ; TAB2 sl [ i ] = getLower of s [ i ] ; TAB1 read t ; TAB1 tl = getLower of t ; TAB1 letterchar = character ; TAB1 read letter ; TAB1 len = integer with len = t . size ( ) ; TAB1 for i = 0 to n exclusive ; TAB2 m = integer with m = s [ i ] . size ( ) ; TAB2 for j = 0 to len - m ; TAB3 if ( tl . substr ( j , m ) is sl [ i ] ) ; TAB4 for k = 0 to m exclusive , ok [ j + k ] = 1 ; TAB1 for i = 0 to len exclusive ; TAB2 if ( ok [ i ] ) ; TAB3 flag = bool with flag = isupper ( t [ i ] ) ; TAB3 if ( tl [ i ] is letter ) ; TAB4 if ( letter is a ) ; TAB5 t [ i ] = b ; TAB4 else ; TAB5 t [ i ] = a ; TAB3 else ; TAB4 t [ i ] = letter ; TAB3 if ( flag ) , t [ i ] = toupper ( t [ i ] ) ; TAB1 print t ;	string s [ 105 ] , t ; string sl [ 105 ] , tl ; bool ok [ 105 ] ; int n ; string getLower ( string s ) { for ( int i = 0 ; i < s . size ( ) ; ++ i ) s [ i ] = tolower ( s [ i ] ) ; return s ; } int main ( ) { cin >> n ; int i , j , k ; for ( i = 0 ; i < n ; ++ i ) { cin >> s [ i ] ; sl [ i ] = getLower ( s [ i ] ) ; } cin >> t ; tl = getLower ( t ) ; char letter ; cin >> letter ; int len = t . size ( ) ; for ( i = 0 ; i < n ; ++ i ) { int m = s [ i ] . size ( ) ; for ( j = 0 ; j <= len - m ; ++ j ) if ( tl . substr ( j , m ) == sl [ i ] ) { for ( k = 0 ; k < m ; ++ k ) ok [ j + k ] = 1 ; } } for ( i = 0 ; i < len ; ++ i ) if ( ok [ i ] ) { bool flag = isupper ( t [ i ] ) ; if ( tl [ i ] == letter ) { if ( letter == ' a ' ) t [ i ] = ' b ' ; else t [ i ] = ' a ' ; } else t [ i ] = letter ; if ( flag ) t [ i ] = toupper ( t [ i ] ) ; } cout << t << endl ; return 0 ; }
TAB0 declare constant integer N = 1e5 + 7 ; TAB0 declare constant string array s = { " lios " , " liala " , " etr " , " etra " , " initis " , " inites " } ; TAB0 declare map from string to integer mp ; TAB0 declare string array h size N ; TAB0 declare integer a size N ; TAB0 declare inline get_s with string address s as argument , returning integer ; TAB1 if size of s is less than 3 , return 0 from function ; TAB1 for i = 3 to 6 inclusive ; TAB2 if i is greater than size of s , return 0 from function ; TAB2 if first index of ( substring of s from size of s - i to i ) in mp is not end of mp , return mp [ substring of s from size of s - i to i ] ; TAB1 declare integer cnt = 0 ; TAB1 for i = 0 to 6 exclusive , let mp [ s [ i ] ] be i + 1 ; TAB1 while ( read h [ cnt ] ) , increment cnt ; TAB1 declare booleans f1 = 0 , f2 = 0 ; TAB1 for i = 0 to cnt exclusive ; TAB2 let a [ i ] be result of run get_s ( h [ i ] ) ; TAB2 if not a [ i ] , return 0 * print " NO " ; TAB2 let f1 be f1 bitwise or ( bitwise and 1 ) , let f2 be f2 bitwise or ( bitwise not a [ i ] bitwise and 1 ) ; TAB1 if cnt is 1 , return 0 * print " YES " ; TAB1 if f1 and f2 , return 0 * print " NO " ; TAB1 for i = 0 to cnt exclusive , increment a [ i ] by 1 , let a [ i ] be a [ i ] bitshift right 1 ; TAB1 declare integer p = 0 ; TAB1 while p is less than cnt - 1 and a [ p ] is a [ p + 1 ] and a [ p ] is 1 , increment p ; TAB1 if a [ p ] is 1 ; TAB2 increment p ; TAB1 else if a [ p ] is 3 ; TAB2 return 0 * print " NO " ; TAB1 if a [ p ] is not 2 ; TAB2 return 0 * print " NO " ; TAB1 else ; TAB2 increment p ; TAB1 while p is less than cnt ; TAB2 if a [ increment p ] is not 3 , return 0 * print " NO " ; TAB1 if a [ increment p ] is not 3 , return 0 * print " NO " ;	const int N = 1e5 + 7 ; const string s [ ] = { " lios " , " liala " , " etr " , " etra " , " initis " , " inites " } ; map < string , int > mp ; string h [ N ] ; int a [ N ] ; inline int get_s ( string & s ) { if ( s . size ( ) < 3 ) return 0 ; for ( int i = 3 ; i <= 6 ; i ++ ) { if ( i > s . size ( ) ) return 0 ; if ( mp . find ( s . substr ( s . size ( ) - i , i ) ) != mp . end ( ) ) return mp [ s . substr ( s . size ( ) - i , i ) ] ; } return 0 ; } int main ( ) { int cnt = 0 ; for ( int i = 0 ; i < 6 ; i ++ ) mp [ s [ i ] ] = i + 1 ; while ( cin >> h [ cnt ] ) cnt ++ ; bool f1 = 0 , f2 = 0 ; for ( int i = 0 ; i < cnt ; i ++ ) { a [ i ] = get_s ( h [ i ] ) ; if ( ! a [ i ] ) return 0 * puts ( " NO " ) ; f1 |= a [ i ] & 1 , f2 |= ~ a [ i ] & 1 ; } if ( cnt == 1 ) return 0 * puts ( " YES " ) ; if ( f1 && f2 ) return 0 * puts ( " NO " ) ; for ( int i = 0 ; i < cnt ; i ++ ) ( a [ i ] += 1 ) >>= 1 ; int p = 0 ; while ( p < cnt - 1 && a [ p ] == a [ p + 1 ] && a [ p ] == 1 ) p ++ ; if ( a [ p ] == 1 ) p ++ ; else if ( a [ p ] == 3 ) return 0 * puts ( " NO " ) ; if ( a [ p ] != 2 ) return 0 * puts ( " NO " ) ; else p ++ ; while ( p < cnt ) if ( a [ p ++ ] != 3 ) return 0 * puts ( " NO " ) ; puts ( " YES " ) ; return 0 ; }
TAB0 declare char array a with size 1000000 ; TAB1 read input to a ; TAB1 declare integer variable n = length of a ; TAB1 loop i from 0 to n - 2 exclusive ; TAB2 declare integers x , y and z = 0 ; TAB2 set x to 1 if a [ i ] = ' A ' or a [ i + 1 ] = ' A ' or a [ i + 2 ] is equal to ' A ' ; TAB2 set y to 1 if a [ i ] = ' B ' or a [ i + 1 ] is ' B ' or a [ i + 2 ] = ' B ' ; TAB2 set z to 1 if a [ i ] is equal to ' C ' or a [ i + 1 ] = ' C ' or a [ i + 2 ] = ' C ' ; TAB2 if x is true and y is true and z is true ; TAB3 print " Yes " ; TAB2 else ; TAB3 change x to 0 ; TAB3 change y to 0 ; TAB3 change z to 0 ; TAB1 print " No " ;	char a [ 1000000 ] ; int main ( ) { cin >> a ; int n = strlen ( a ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = 0 , y = 0 , z = 0 ; if ( a [ i ] == ' A ' || a [ i + 1 ] == ' A ' || a [ i + 2 ] == ' A ' ) { x = 1 ; } if ( a [ i ] == ' B ' || a [ i + 1 ] == ' B ' || a [ i + 2 ] == ' B ' ) { y = 1 ; } if ( a [ i ] == ' C ' || a [ i + 1 ] == ' C ' || a [ i + 2 ] == ' C ' ) { z = 1 ; } if ( x && y && z ) { cout << " Yes " << endl ; return 0 ; } else { x = 0 ; y = 0 ; z = 0 ; } } cout << " No " << endl ; return 0 ; }
TAB1 n , s = integers ; TAB1 read n , s ; TAB1 arr = integer 2d array of size [ n ] [ 2 ] ; TAB1 for i = 0 to n exclusive , read arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ; TAB1 m = integer with m = n ; TAB1 ff = bool with ff = false ; TAB1 while decrement m ; TAB2 j , mx = integer with mx = - 1 ; TAB2 f = bool with f = false ; TAB2 for i = 0 to n exclusive ; TAB3 if s > arr [ i ] [ 0 ] and arr [ i ] [ 0 ] is not - 1 ; TAB4 f = true ; TAB4 if arr [ i ] [ 1 ] > mx ; TAB5 mx = arr [ i ] [ 1 ] ; TAB5 j = i ; TAB2 if not f ; TAB3 ff = true ; TAB3 break loop ; TAB2 else ; TAB3 s = s + mx ; TAB3 arr [ j ] [ 0 ] = - 1 ; TAB1 if ff ; TAB2 print NO ; TAB1 else ; TAB2 print YES ;	int main ( ) { int n , s ; cin >> s >> n ; int arr [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cin >> arr [ i ] [ 0 ] >> arr [ i ] [ 1 ] ; int m = n ; bool ff = false ; while ( m -- ) { int mx = - 1 , j ; bool f = false ; for ( int i = 0 ; i < n ; ++ i ) { if ( s > arr [ i ] [ 0 ] and arr [ i ] [ 0 ] != - 1 ) { f = true ; if ( arr [ i ] [ 1 ] > mx ) { mx = arr [ i ] [ 1 ] ; j = i ; } } } if ( ! f ) { ff = true ; break ; } else { s += mx ; arr [ j ] [ 0 ] = - 1 ; } } if ( ff ) cout << " NO " << endl ; else cout << " YES " << endl ; }
TAB0 in the function gcd that takes integer a , b and returns integer ; TAB1 return if b , gcd ( b , a % b ) else a ; TAB0 in the function lcm that takes integer a , b and returns integer ; TAB1 return a / gcd ( a , b ) * b ; TAB0 in the function lcm that takes integer pointer arr and integer n and returns integer ; TAB1 r = integer with r = arr [ 0 ] ; TAB1 for i = 1 to n exclusive , r = lcm of r and arr [ i ] ; TAB1 return r ; TAB0 in = bool array of size 101 with in = { } ; TAB0 cycle = integer array of size 101 ; TAB0 target = integer array of size 101 ; TAB0 n = integer ; TAB1 read n ; TAB1 for i = 1 to n ; TAB2 read target [ i ] ; TAB2 if in [ target [ i ] ] ; TAB3 print - 1 ; TAB2 in [ target [ i ] ] = true ; TAB1 for i = 1 to n ; TAB2 current = integer with current = i ; TAB2 cycle [ i ] = 0 ; TAB2 do ; TAB3 current = target [ current ] ; TAB3 cycle [ i ] = cycle [ i ] + cycle [ i ] 1 ; TAB2 while current is not i ; TAB2 if ( ( cycle [ i ] bitwise and 1 ) is 0 ) , cycle [ i ] = right shift cycle [ i ] 1 place ; TAB1 print lcm ( cycle + 1 , n ) ;	int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } int lcm ( int a , int b ) { return a / gcd ( a , b ) * b ; } int lcm ( int * arr , int n ) { int r = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { r = lcm ( r , arr [ i ] ) ; } return r ; } bool in [ 101 ] = { } ; int cycle [ 101 ] ; int target [ 101 ] ; int n ; int main ( ) { cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> target [ i ] ; if ( in [ target [ i ] ] ) { cout << - 1 << endl ; return 0 ; } in [ target [ i ] ] = true ; } for ( int i = 1 ; i <= n ; ++ i ) { int current = i ; cycle [ i ] = 0 ; do { current = target [ current ] ; cycle [ i ] += 1 ; } while ( current != i ) ; if ( ( cycle [ i ] & 1 ) == 0 ) { cycle [ i ] >>= 1 ; } } cout << lcm ( cycle + 1 , n ) << endl ; }
TAB1 declare new integer variable n ; TAB1 read n and keep looping ; TAB2 s is an array of characters with 1004 elements ; TAB2 read s + 1 from the input ; TAB2 declare new integer variable flag with value 1 ; TAB2 start for loop from i = 1 to n inclusive ; TAB3 if s [ i ] is equal to ' 1 ' ; TAB4 if ( s [ i - 1 ] is ' 1 ' and i is not 1 ) or ( s [ i + 1 ] is ' 1 ' & & i is not n ) , set flag to 0 ; TAB3 else ; TAB4 if ( s [ i - 1 ] is ' 0 ' | | i is 1 ) and ( s [ i + 1 ] is ' 0 ' or i is not n ) , set flag to 0 ; TAB2 if flag is set ; TAB3 print " Yes " to the standard output ; TAB2 else ; TAB3 print " No " ;	int main ( ) { int n ; while ( cin >> n ) { char s [ 1004 ] ; cin >> s + 1 ; int flag = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i ] == ' 1 ' ) { if ( ( s [ i - 1 ] == ' 1 ' && i != 1 ) || ( s [ i + 1 ] == ' 1 ' && i != n ) ) flag = 0 ; } else { if ( ( s [ i - 1 ] == ' 0 ' || i == 1 ) && ( s [ i + 1 ] == ' 0 ' || i == n ) ) flag = 0 ; } } if ( flag ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
TAB0 let c be a character array of size 1000 ; TAB0 let res be an integer array of size 1000 ; TAB0 let l , mn , pl , n be integers with pl = 1 ; TAB1 ch = character ; TAB1 input ch ; TAB1 while input ch ; TAB2 if ch is the character = , break ; TAB2 set c [ l ] to ch ; TAB2 if c [ l ] is the character + ; TAB3 increment pl ; TAB2 else ; TAB3 increment mn ; TAB2 increment l ; TAB2 input ch ; TAB1 input n ; TAB1 if n * pl - nm is less than n or pl - n * mn is greater than n ; TAB2 print Impossible ; TAB1 else ; TAB2 print Possible ; TAB2 for i = 0 to 1 inclusive , set res [ i ] to 1 ; TAB2 d is an integer with d = n - ( pl - mn ) ; TAB2 for i = 0 to 1 inclusive ; TAB3 if ( i equals 0 or c [ i - 1 ] equals the character + ) and d is greater than 0 ; TAB4 if d is less than n - res [ i ] ; TAB5 add d to res [ i ] ; TAB5 set d to 0 ; TAB4 else ; TAB5 subtract n - res [ i ] from d ; TAB5 res [ i ] is assigned n ; TAB3 else if i isn ' t 0 and c [ i - 1 ] equals the character - and d is less than 0 ; TAB4 if - d is less than n - res [ i ] ; TAB5 add - d to res [ i ] ; TAB5 set d to 0 ; TAB4 else ; TAB5 add n - res [ i ] to d ; TAB5 set res [ i ] to n ; TAB2 output res [ 0 ] ; TAB2 for i = 0 to 1 exclusive , output the character space , c [ i ] the character space , and res [ i + 1 ] ; TAB2 output the string " = " and n ;	char c [ 1000 ] ; int res [ 1000 ] ; int l , mn , pl = 1 , n ; int main ( ) { char ch ; cin >> ch ; while ( cin >> ch ) { if ( ch == ' = ' ) break ; c [ l ] = ch ; if ( c [ l ] == ' + ' ) pl ++ ; else mn ++ ; l ++ ; cin >> ch ; } cin >> n ; if ( n * pl - mn < n || pl - n * mn > n ) cout << " Impossible " << endl ; else { cout << " Possible " << endl ; for ( int i = 0 ; i <= l ; i ++ ) res [ i ] = 1 ; int d = n - ( pl - mn ) ; for ( int i = 0 ; i <= l ; i ++ ) { if ( ( i == 0 || c [ i - 1 ] == ' + ' ) && d > 0 ) { if ( d < n - res [ i ] ) { res [ i ] += d ; d = 0 ; } else { d -= n - res [ i ] ; res [ i ] = n ; } } else if ( i != 0 && c [ i - 1 ] == ' - ' && d < 0 ) { if ( - d < n - res [ i ] ) { res [ i ] += - d ; d = 0 ; } else { d += n - res [ i ] ; res [ i ] = n ; } } } cout << res [ 0 ] ; for ( int i = 0 ; i < l ; i ++ ) cout << "   " << c [ i ] << "   " << res [ i + 1 ] ; cout << "  =  " << n << endl ; } return 0 ; }
TAB1 create integers a , b , c ; TAB1 while read a ; TAB2 create integer arrays r1 , r2 with r1 size 100 , r2 size 100 , create integer d ; TAB2 create integer vector v ; TAB2 for b = 1 to a inclusive , set r1 [ b ] to r2 [ b ] to 0 ; TAB2 for b = 1 to a * a inclusive ; TAB3 read c read d ; TAB3 if r1 [ c ] is 0 and r2 [ d ] is 0 ; TAB4 add element b to end of v ; TAB4 set r1 [ c ] to 1 ; TAB4 set r2 [ d ] to 1 ; TAB2 for c = 0 to size of v exclusive ; TAB3 if c is 0 ; TAB4 print v [ c ] ; TAB3 else ; TAB4 print " " print v [ c ] ; TAB2 print newline ; TAB2 remove all elements from v ;	int main ( ) { int a , b , c ; while ( cin >> a ) { int r1 [ 100 ] , r2 [ 100 ] , d ; vector < int > v ; for ( b = 1 ; b <= a ; b ++ ) { r1 [ b ] = r2 [ b ] = 0 ; } for ( b = 1 ; b <= a * a ; b ++ ) { cin >> c >> d ; if ( r1 [ c ] == 0 && r2 [ d ] == 0 ) { v . push_back ( b ) ; r1 [ c ] = 1 ; r2 [ d ] = 1 ; } } for ( c = 0 ; c < v . size ( ) ; c ++ ) { if ( c == 0 ) { cout << v [ c ] ; } else { cout << "   " << v [ c ] ; } } cout << endl ; v . clear ( ) ; } return 0 ; }
TAB1 declare long longs i1 , r1 , i2 , r2 , k ; TAB1 declare long long time ; TAB1 while ( read i1 , r1 , i2 , r2 , k is true ) ; TAB2 declare long long i = maximum of i1 and i2 ; TAB2 declare long long r = minimum of r1 and r2 ; TAB2 if i is less than or equal to r ; TAB3 if i is less than or equal to k and k is less than or equal to r ; TAB4 let time be r - i ; TAB3 else ; TAB4 let time be r - i + 1 ; TAB2 else ; TAB3 let time be 0 ; TAB2 print time and newline ;	int main ( ) { long long i1 , r1 , i2 , r2 , k ; long long time ; while ( cin >> i1 >> r1 >> i2 >> r2 >> k ) { long long i = max ( i1 , i2 ) ; long long r = min ( r1 , r2 ) ; if ( i <= r ) { if ( i <= k && k <= r ) time = r - i ; else time = r - i + 1 ; } else time = 0 ; cout << time << endl ; } return 0 ; }
TAB0 create string s ; TAB0 create ints f1 and f2 ; TAB1 read s ; TAB1 create int len = s length ; TAB1 create int st = - 1 and en = - 2 ; TAB1 for i = 0 to len - 1 inclusive ; TAB2 if f1 is equal to 0 and s [ i ] is equal to ' a ' , continue ; TAB2 set f1 to 1 ; TAB2 if f2 is equal to 0 ; TAB3 set st to i ; TAB3 set f2 to 1 ; TAB2 if s [ i ] is equal to ' a ' , break ; TAB2 set en to i ; TAB1 for i = st to en inclusive , subtract 1 from s [ i ] ; TAB1 if not f1 , set s [ len - 1 ] to ' z ' ; TAB1 print s ;	string s ; int f1 , f2 ; int main ( ) { cin >> s ; int len = s . length ( ) ; int st = - 1 , en = - 2 ; for ( int i = 0 ; i <= len - 1 ; i ++ ) { if ( f1 == 0 && s [ i ] == ' a ' ) continue ; f1 = 1 ; if ( f2 == 0 ) { st = i ; f2 = 1 ; } if ( s [ i ] == ' a ' ) break ; en = i ; } for ( int i = st ; i <= en ; i ++ ) s [ i ] -= 1 ; if ( ! f1 ) s [ len - 1 ] = ' z ' ; cout << s << endl ; return 0 ; }
TAB0 function solve ( get long long n , return long long ) ; TAB1 if n < = 9 return n + 1 ; TAB1 dig = array of 20 int ; TAB1 c = 0 ; TAB1 ret = 0 ; TAB1 p10 = 1 ; TAB1 while n ; TAB2 multiply p10 by 10 ; TAB2 dig [ c ] = n modulo 10 ; TAB2 divide n by 10 ; TAB2 increment cnt ; TAB1 p100 = 100 ; TAB1 for i = 2 to c exclusive ; TAB2 add 9 * ( p100 / 100 ) to ret ; TAB2 divide p100 by 10 ; TAB1 add 10 to ret ; TAB1 h = 0 ; TAB1 for i = c - 2 to 1 inclusive by - 1 ; TAB2 multiply h by 10 ; TAB2 add dig [ i ] to h ; TAB1 add ( dig [ c - 1 ] - 1 ) * p10 / 100 to ret ; TAB1 add h to ret ; TAB1 if dig [ c - 1 ] < = dig [ 0 ] increment ret ; TAB1 return ret ; TAB0 l , r = long long ; TAB0 function chk ( get int n , return bool ) ; TAB1 dig = array of 20 int ; TAB1 c = 0 ; TAB1 ret = 0 ; TAB1 p10 = 1 ; TAB1 while n ; TAB2 multiply p10 by 10 ; TAB2 dig [ c ] = n modulo 10 ; TAB2 divide n by 10 ; TAB2 increment cnt ; TAB1 if dig [ c - 1 ] is dig [ 0 ] return true ; TAB1 return false ; TAB1 read l , r ; TAB1 print solve ( r ) - solve ( l - 1 ) ;	long long solve ( long long n ) { if ( n <= 9 ) { return n + 1 ; } int dig [ 20 ] ; int c = 0 ; long long ret = 0 ; long long p10 = 1 ; while ( n ) { p10 *= 10 ; dig [ c ] = n % 10 ; n /= 10 ; c ++ ; } long long p100 = 100 ; for ( int i = 2 ; i < c ; i ++ ) { ret += 9 * ( p100 / 100 ) ; p100 *= 10 ; } ret += 10 ; long long h = 0 ; for ( int i = c - 2 ; i >= 1 ; i -- ) { h *= 10 ; h += dig [ i ] ; } ret += ( dig [ c - 1 ] - 1 ) * p10 / 100 ; ret += h ; if ( dig [ c - 1 ] <= dig [ 0 ] ) { ret ++ ; } return ret ; } long long l , r ; bool chk ( int n ) { int dig [ 20 ] ; int c = 0 ; long long ret = 0 ; long long p10 = 1 ; while ( n ) { p10 *= 10 ; dig [ c ] = n % 10 ; n /= 10 ; c ++ ; } if ( dig [ c - 1 ] == dig [ 0 ] ) { return true ; } return false ; } int main ( ) { cin >> l >> r ; cout << solve ( r ) - solve ( l - 1 ) << endl ; }
TAB0 let i , j , cnt be long long with cnt = 0x3f3f3f3f3f3f3f3f ; TAB0 in int function exgcd that takes args int a , b , & x , & y ; TAB1 if b is 0 then ; TAB2 set x to 1 ; TAB2 set y to 0 ; TAB2 return a ; TAB1 let g = int = exgcd of b , a mod b , y and x ; TAB1 decrement y by a / b * x ; TAB1 return g ; TAB1 let a , b , c , d , x , y , t be ints ; TAB1 read a , b , c and d ; TAB1 let g = int = exgcd of a , - c , x , y ; TAB1 if ( d - b ) mod g isn ' t 0 then print - 1 and new line , then exit 0 ; TAB1 multiply y by ( d - b ) / g ; TAB1 multiply x by ( d - b ) / g ; TAB1 if b - d is positive or 0 ; TAB2 set t to the max of x / g and - c / g ; TAB2 set x to ( x mod t + t ) mod t ; TAB2 set cnt to a * x + b ; TAB1 else ; TAB2 set t to the max between - a / g , a / g ; TAB2 set y to ( y modulo t + t ) mod t ; TAB2 set cnt = c * y + d ; TAB1 print cnt and new line ; TAB1 return 0 ;	long long i , j , cnt = 0x3f3f3f3f3f3f3f3f ; int exgcd ( int a , int b , int & x , int & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } int g = exgcd ( b , a % b , y , x ) ; y -= a / b * x ; return g ; } int main ( ) { int a , b , c , d , x , y , t ; cin >> a >> b >> c >> d ; int g = exgcd ( a , - c , x , y ) ; if ( ( d - b ) % g != 0 ) cout << - 1 << endl , exit ( 0 ) ; y = y * ( d - b ) / g ; x = x * ( d - b ) / g ; if ( b - d >= 0 ) { t = max ( c / g , - c / g ) ; x = ( x % t + t ) % t ; cnt = a * x + b ; } else { t = max ( - a / g , a / g ) ; y = ( y % t + t ) % t ; cnt = c * y + d ; } cout << cnt << endl ; return ~ ~ ( 0 ^ 0 ^ 0 ) ; }
TAB0 a = int array of size 277 ; TAB1 s = string ; TAB1 read s ; TAB1 for i = 0 to size of s increment a [ s [ i ] ] ; TAB1 an = int with an = 0 ; TAB1 set an to max of 0 , ( a [ ' n ' ] - 3 ) / 2 + ( a [ ' n ' ] > = 3 ) ; TAB1 set an to min of an , a [ ' t ' ] ; TAB1 set an to min of an , a [ ' e ' ] / 3 ; TAB1 set an to min of an , a [ ' i ' ] ; TAB1 print an ;	int a [ 277 ] ; int main ( ) { string s ; cin >> s ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) a [ s [ i ] ] ++ ; int an = 0 ; an = max ( 0 , ( a [ ' n ' ] - 3 ) / 2 + ( a [ ' n ' ] >= 3 ) ) ; an = min ( an , a [ ' t ' ] ) ; an = min ( an , a [ ' e ' ] / 3 ) ; an = min ( an , a [ ' i ' ] ) ; cout << an << endl ; }
TAB0 n , s , cur = int with cur = 101 ; TAB1 read n then s ; TAB1 for i = 0 to n ; TAB2 x , y = int ; TAB2 read x then y ; TAB2 if x < s ; TAB3 if y is 0 set y to 100 ; TAB3 set cur to min of cur , y ; TAB2 if x is s ; TAB3 if y is 0 set cur to min of cur , 100 ; TAB1 print 100 - cur ;	int n , s , cur = 101 ; int main ( ) { cin >> n >> s ; for ( int i = 0 ; i < n ; i ++ ) { int x , y ; cin >> x >> y ; if ( x < s ) { if ( y == 0 ) y = 100 ; cur = min ( cur , y ) ; } if ( x == s ) { if ( y == 0 ) { cur = min ( cur , 100 ) ; } } } cout << 100 - cur << endl ; }
TAB0 declare integer arrays dx = { 1 , 0 , - 1 , 0 } , dy = { 0 , 1 , 0 , - 1 } ; TAB1 declare long longs n , d ; TAB1 read n and d ; TAB1 declare long long array a size n ; TAB1 for i = 0 to n exclusive , read a [ i ] ; TAB1 declare long long ans = 0 ; TAB1 for i = 0 to n exclusive ; TAB2 declare integer u = ( first element between a and a + n comparing greater than a [ i ] + d ) - a ; TAB2 let u be u - i - 1 ; TAB2 if u is greater than or equal to 2 , let ans be ans + ( long long casted u * ( u - 1 ) ) / 2 ; TAB1 print ans and newline ;	int dx [ ] = { 1 , 0 , - 1 , 0 } , dy [ ] = { 0 , 1 , 0 , - 1 } ; int main ( ) { long long n , d ; cin >> n >> d ; long long a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ] ; } long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = upper_bound ( a , a + n , a [ i ] + d ) - a ; u = u - i - 1 ; if ( u >= 2 ) { ans = ans + ( ( long long ) u * ( u - 1 ) ) / 2 ; } } cout << ans << endl ; return 0 ; }
TAB1 a_i , b_i , n , temp , cont , p1 , p2 = integers with cont = 0 ; TAB1 read n ; TAB1 v = vector of integer with v = n ; TAB1 for a_i = 0 to n exclusive , read v [ a_i ] ; TAB1 sort v . begin ( ) and v . end ( ) ; TAB1 p1 = p2 = 0 ; TAB1 while ( p2 < n ) ; TAB2 while ( p2 < n ) ; TAB3 if ( v [ p2 ] > v [ p1 ] ) ; TAB4 increment cont ; TAB4 break loop ; TAB3 incremnet p2 ; TAB2 increment p1 ; TAB2 increment p2 ; TAB1 print cont ;	int main ( ) { int a_i , b_i , n , temp , cont = 0 , p1 , p2 ; cin >> n ; vector < int > v ( n ) ; for ( a_i = 0 ; a_i < n ; a_i ++ ) cin >> v [ a_i ] ; sort ( v . begin ( ) , v . end ( ) ) ; p1 = p2 = 0 ; while ( p2 < n ) { while ( p2 < n ) { if ( v [ p2 ] > v [ p1 ] ) { cont ++ ; break ; } p2 ++ ; } p1 ++ ; p2 ++ ; } cout << cont << endl ; }
TAB1 mymap = map from string to integer ; TAB1 mymap [ " C " ] = 1 ; TAB1 mymap [ " C # " ] = 2 ; TAB1 mymap [ " D " ] = 3 ; TAB1 let mymap [ " D # " ] = 4 ; TAB1 let mymap [ " E " ] = 5 ; TAB1 let mymap [ " F " ] = 6 ; TAB1 let mymap [ " F # " ] = 7 ; TAB1 let mymap [ " G " ] = 8 ; TAB1 let mymap [ " G # " ] = 9 ; TAB1 mymap [ " A " ] = 10 ; TAB1 mymap [ " B " ] = 11 ; TAB1 mymap [ " H " ] = 12 ; TAB1 let s1 , s2 , s3 be strings ; TAB1 read n1 , n2 , n3 ; TAB1 let n1 , n2 , n3 be integers ; TAB1 let n1 = mymap [ s1 ] ; TAB1 let n2 = mymap [ s2 ] ; TAB1 let n3 = mymap [ s3 ] ; TAB1 a1 , a2 be boolean values equals to 0 ; TAB1 let k1 , k2 be integers ; TAB1 k1 = n2 - n1 ; TAB1 if k1 is less than 0 , increase k1 by 12 ; TAB1 k2 = n3 - n2 ; TAB1 if k2 is less than 0 , increase k2 by 12 ; TAB1 if k1 = 4 and k2 = 3 , a1 equals 1 ; TAB1 if k1 = 3 and k2 = 4 , a2 equals 1 ; TAB1 k1 = n3 - n1 ; TAB1 if k1 is less than 0 , increase k1 by 12 ; TAB1 k2 = n2 - n3 ; TAB1 if k2 is less than 0 , increase k2 by 12 ; TAB1 if k1 = 4 and k2 = 3 , a1 equals 1 ; TAB1 if k1 = 3 and k2 = 4 , a2 equals 1 ; TAB1 k1 = n1 - n2 ; TAB1 if k1 is less than 0 , increase k1 by 12 ; TAB1 k2 = n3 - n1 ; TAB1 if k2 is less than 0 , increase k2 by 12 ; TAB1 if k1 = 4 and k2 = 3 , a1 equals 1 ; TAB1 if k1 = 3 and k2 = 4 , a2 equals 1 ; TAB1 k1 = n3 - n2 ; TAB1 if k1 is less than 0 , increase k1 by 12 ; TAB1 k2 = n1 - n3 ; TAB1 if k2 is less than 0 , increase k2 by 12 ; TAB1 if k1 = 4 and k2 = 3 , a1 equals 1 ; TAB1 if k1 = 3 and k2 = 4 , a2 equals 1 ; TAB1 k1 = n1 - n3 ; TAB1 if k1 is less than 0 , increase k1 by 12 ; TAB1 k2 = n2 - n1 ; TAB1 if k2 is less than 0 , increase k2 by 12 ; TAB1 if k1 = 4 and k2 = 3 , a1 equals 1 ; TAB1 if k1 = 3 and k2 = 4 , a2 equals 1 ; TAB1 k1 = n2 - n3 ; TAB1 if k1 is less than 0 , increase k1 by 12 ; TAB1 k2 = n1 - n2 ; TAB1 if k2 is less than 0 , increase k2 by 12 ; TAB1 if k1 = 4 and k2 = 3 , a1 equals 1 ; TAB1 if k1 = 3 and k2 = 4 , a2 equals 1 ; TAB1 if a1 is true ; TAB2 print major and endline ; TAB1 else if a2 is true ; TAB2 print minor and endline ; TAB1 else ; TAB2 print strange and endline ;	int main ( ) { map < string , int > mymap ; mymap [ " C " ] = 1 ; mymap [ " C# " ] = 2 ; mymap [ " D " ] = 3 ; mymap [ " D# " ] = 4 ; mymap [ " E " ] = 5 ; mymap [ " F " ] = 6 ; mymap [ " F# " ] = 7 ; mymap [ " G " ] = 8 ; mymap [ " G# " ] = 9 ; mymap [ " A " ] = 10 ; mymap [ " B " ] = 11 ; mymap [ " H " ] = 12 ; string s1 , s2 , s3 ; cin >> s1 >> s2 >> s3 ; int n1 , n2 , n3 ; n1 = mymap [ s1 ] ; n2 = mymap [ s2 ] ; n3 = mymap [ s3 ] ; bool a1 = 0 , a2 = 0 ; int k1 , k2 ; k1 = n2 - n1 ; if ( k1 < 0 ) { k1 += 12 ; } k2 = n3 - n2 ; if ( k2 < 0 ) { k2 += 12 ; } if ( k1 == 4 && k2 == 3 ) { a1 = 1 ; } if ( k1 == 3 && k2 == 4 ) { a2 = 1 ; } k1 = n3 - n1 ; if ( k1 < 0 ) { k1 += 12 ; } k2 = n2 - n3 ; if ( k2 < 0 ) { k2 += 12 ; } if ( k1 == 4 && k2 == 3 ) { a1 = 1 ; } if ( k1 == 3 && k2 == 4 ) { a2 = 1 ; } k1 = n1 - n2 ; if ( k1 < 0 ) { k1 += 12 ; } k2 = n3 - n1 ; if ( k2 < 0 ) { k2 += 12 ; } if ( k1 == 4 && k2 == 3 ) { a1 = 1 ; } if ( k1 == 3 && k2 == 4 ) { a2 = 1 ; } k1 = n3 - n2 ; if ( k1 < 0 ) { k1 += 12 ; } k2 = n1 - n3 ; if ( k2 < 0 ) { k2 += 12 ; } if ( k1 == 4 && k2 == 3 ) { a1 = 1 ; } if ( k1 == 3 && k2 == 4 ) { a2 = 1 ; } k1 = n1 - n3 ; if ( k1 < 0 ) { k1 += 12 ; } k2 = n2 - n1 ; if ( k2 < 0 ) { k2 += 12 ; } if ( k1 == 4 && k2 == 3 ) { a1 = 1 ; } if ( k1 == 3 && k2 == 4 ) { a2 = 1 ; } k1 = n2 - n3 ; if ( k1 < 0 ) { k1 += 12 ; } k2 = n1 - n2 ; if ( k2 < 0 ) { k2 += 12 ; } if ( k1 == 4 && k2 == 3 ) { a1 = 1 ; } if ( k1 == 3 && k2 == 4 ) { a2 = 1 ; } if ( a1 ) { cout << " major " << endl ; } else if ( a2 ) { cout << " minor " << endl ; } else { cout << " strange " << endl ; } return 0 ; }
TAB1 n = int ; TAB1 read n ; TAB1 a = char array of size 500 ; TAB1 read a ; TAB1 count_zero = int with count_zero = 0 ; TAB1 for i = 0 to n ; TAB2 x = char with x = a [ i ] ; TAB2 if x is ' 0 ' increment count_zero ; TAB1 if a [ 0 ] is ' 0 ' ; TAB2 print 0 ; TAB1 print 1 ; TAB1 for i = 0 to count_zero print 0 ; TAB1 print newline ;	int main ( ) { int n ; cin >> n ; char a [ 500 ] ; cin >> a ; int count_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; if ( x == ' 0 ' ) count_zero ++ ; } if ( a [ 0 ] == ' 0 ' ) { cout << 0 << endl ; return 0 ; } cout << 1 ; for ( int i = 0 ; i < count_zero ; i ++ ) cout << 0 ; cout << endl ; return 0 ; }
TAB1 let a , b , c , d be double values ; TAB1 read a , b , c , d ; TAB1 if b - a is equal to c - b and c - b is equal to d - c ; TAB2 print d + ( d - c ) and newline ; TAB1 else if b / a is equal to c / b and c / b is equal to d / c ; TAB2 if d * ( d / c ) is equal to int ( d * ( d / c ) ) ; TAB3 print d * ( d / c ) and newline ; TAB2 else do the following ; TAB3 print 42 and newline ; TAB1 else do the following ; TAB2 print 42 and newline ;	int main ( ) { double a , b , c , d ; cin >> a >> b >> c >> d ; if ( b - a == c - b && c - b == d - c ) { cout << d + ( d - c ) << endl ; } else if ( b / a == c / b && c / b == d / c ) { if ( d * ( d / c ) == int ( d * ( d / c ) ) ) cout << d * ( d / c ) << endl ; else cout << " 42 " << endl ; } else cout << " 42 " << endl ; return 0 ; }
TAB1 let a , b , c , d = integers ; TAB1 read a , b , c , d ; TAB1 if gcd of a and c is not equal to 1 and b modulo gcd of a and c is not equal to d modulo gcd of a and c ; TAB2 print - 1 ; TAB1 else do the following ; TAB2 while b is not equal to d do the following ; TAB3 if b is less than d ; TAB4 set b = b + a ; TAB3 else ; TAB4 set d = d + c ; TAB2 print b ;	int main ( ) { int a , b , c , d ; cin >> a >> b >> c >> d ; if ( __gcd ( a , c ) != 1 && b % __gcd ( a , c ) != d % __gcd ( a , c ) ) cout << - 1 << endl ; else { while ( b != d ) { if ( b < d ) b += a ; else d += c ; } cout << b << endl ; } return 0 ; }
TAB0 create constant integer M = 50 + 5 ; TAB1 x , t , a , b , da , db = integers ; TAB1 read x , t , a , b , da , db ; TAB1 create boolean ok = false ; TAB1 for i = 0 to t - 1 inclusive ; TAB2 for j = 0 to t - 1 inclusive ; TAB3 create integer tsum = a - da * i + b - db * j ; TAB3 if tsum is equal to x then assign true to ok ; TAB1 for i = 0 to t - 1 inclusive ; TAB2 create integer tsum = a - da * i ; TAB2 if tsum is equal to x then set ok to true ; TAB1 for i = 0 to t - 1 inclusive ; TAB2 create integer tsum = b - db * i ; TAB2 if tsum is equal to x then set ok to true ; TAB1 if x is equal to 0 then assign true to ok ; TAB1 create integer string = YES if ok is true else string = NO ; TAB1 print ans and new line ;	const int M = 50 + 5 ; int main ( ) { int x , t , a , b , da , db ; cin >> x >> t >> a >> b >> da >> db ; bool ok = false ; for ( int i = 0 ; i <= t - 1 ; i ++ ) { for ( int j = 0 ; j <= t - 1 ; j ++ ) { int tsum = a - da * i + b - db * j ; if ( tsum == x ) { ok = true ; } } } for ( int i = 0 ; i <= t - 1 ; i ++ ) { int tsum = a - da * i ; if ( tsum == x ) { ok = true ; } } for ( int i = 0 ; i <= t - 1 ; i ++ ) { int tsum = b - db * i ; if ( tsum == x ) { ok = true ; } } if ( x == 0 ) { ok = true ; } string ans = ok ? " YES " : " NO " ; cout << ans << endl ; return 0 ; }
TAB0 declare const long long MOD = 1000000007 ; TAB0 create const long double EPS = 1e - 8 ; TAB1 declare integer n ; TAB1 read n ; TAB1 create int vector mas with n elements ; TAB1 for i from 0 to n exclusive , read mas [ i ] ; TAB1 create int vector ans with 1 element = 0 ; TAB1 declare int variable bad = 0 ; TAB1 for i from 0 to n exclusive ; TAB2 if mas [ i ] is less than 0 , increment bad by one ; TAB2 if bad > = 3 ; TAB3 push 1 into ans ; TAB3 assign 1 to bad ; TAB2 else ; TAB3 increment ans [ ans . size ( ) - 1 ] ; TAB1 print length of ans ; TAB1 for integer i = 0 to length of ans exclusive ; TAB2 if i is true , print ' ' ; TAB2 print ans [ i ] ; TAB1 print new line ;	const long long MOD = 1000000007 ; const long double EPS = 1e-8 ; int main ( ) { int n ; cin >> n ; vector < int > mas ( n ) ; for ( int i = 0 ; i < n ; i ++ ) cin >> mas [ i ] ; vector < int > ans ( 1 , 0 ) ; int bad = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mas [ i ] < 0 ) bad ++ ; if ( bad >= 3 ) { ans . push_back ( 1 ) ; bad = 1 ; } else ans [ ans . size ( ) - 1 ] ++ ; } cout << ans . size ( ) << endl ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( i ) cout << '   ' ; cout << ans [ i ] ; } cout << endl ; return 0 ; }
TAB0 define function find which takes in integers x and array of strings father ; TAB1 return x if father [ x ] is equal to x ; TAB1 set father to find of father [ x ] and father and return father [ x ] ; TAB1 declare integers n and k ; TAB1 read k and k ; TAB1 create string s ; TAB1 read s ; TAB1 create integer pos set to n ; TAB1 for i = 1 to n exclusive ; TAB2 declare and set integers j to i and k to 0 ; TAB2 iterate while s [ j ] = = s [ k ] and j < n ; TAB3 increment j ; TAB3 set k to k + 1 ; TAB2 if j and n are equal ; TAB3 assign i to pos ; TAB3 terminate loop ; TAB1 print s ; TAB1 decrement k ; TAB1 for k iterations print s . substr ( n - pos ) ; TAB1 print a newline ;	int find ( int x , int father [ ] ) { if ( father [ x ] == x ) return x ; return father [ x ] = find ( father [ x ] , father ) ; } int main ( ) { int n , k ; cin >> n >> k ; string s ; cin >> s ; int pos = n ; for ( int i = 1 ; i < n ; i ++ ) { int j = i , k = 0 ; while ( s [ j ] == s [ k ] && j < n ) { j ++ ; k ++ ; } if ( j == n ) { pos = i ; break ; } } cout << s ; k -- ; for ( int i = 0 ; i < k ; i ++ ) { cout << s . substr ( n - pos ) ; } cout << endl ; }
TAB0 in int function quick that takes int a and int b ; TAB1 s = 1 = int ; TAB1 while b is positive ; TAB2 if b is odd then set s to s * a mod 10 ; TAB2 set a to a mod 10 ; TAB2 set b to bitwise right shift 1 mod 10 ; TAB1 return s ; TAB1 n = int ; TAB1 read n ; TAB1 print the result of quick with args 8 and n ;	int quick ( int a , int b ) { int s = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) { s = s * a % 10 ; } a = a * a % 10 ; b = b >> 1 % 10 ; } return s ; } int main ( ) { int n ; cin >> n ; cout << quick ( 8 , n ) << endl ; return 0 ; }
TAB1 s , u are strings ; TAB1 read s , u ; TAB1 m is an integer set to length of u ; TAB1 for i = 0 to m exclusive , assign the character . + s + the character . to s ; TAB1 mini and cur are integers with mini set to m , cur set to 0 ; TAB1 for i = 0 to ( length of s ) - ( length of u ) + 1 exclusive ; TAB2 assign 0 to cur ; TAB2 for j = 0 to length of u exclusive ; TAB3 if s [ i + j ] is unequal to u [ j ] , increment cur ; TAB2 set mini to call min with mini , cur ; TAB1 print mini ;	int main ( ) { string s , u ; cin >> s >> u ; int m = u . length ( ) ; for ( int i = 0 ; i < m ; ++ i ) { s = ' . ' + s + ' . ' ; } int mini = m , cur = 0 ; for ( int i = 0 ; i < ( s . length ( ) - u . length ( ) ) + 1 ; ++ i ) { cur = 0 ; for ( int j = 0 ; j < u . length ( ) ; ++ j ) { if ( s [ i + j ] != u [ j ] ) { ++ cur ; } } mini = min ( mini , cur ) ; } cout << mini << endl ; return 0 ; }
TAB0 maxl is a constant integer set to 2e5 + 10 ; TAB0 la , lb are integers ; TAB0 s and t are both character arrays both with size maxl ; TAB1 read la , lb , s , t ; TAB1 tar is an integer set to - 1 ; TAB1 for i = 0 to la exclusive ; TAB2 if s [ i ] equals the character * , assign i to tar ; TAB1 if tar equals - 1 ; TAB2 if la isn ' t lb ; TAB3 display NO ; TAB2 for i = 0 to la exclusive ; TAB3 if s [ i ] isn ' t t [ i ] ; TAB4 display NO ; TAB2 display YES ; TAB1 if la - 1 is greater than lb ; TAB2 display NO ; TAB1 for i = 0 to tar exclusive ; TAB2 if s [ i ] isn ' t t [ i ] ; TAB3 display NO ; TAB1 for i = 0 as long as la - i - 1 is greater than tar with increment i ; TAB2 if s [ la - i - 1 ] isn ' t t [ lb - i - 1 ] ; TAB3 display NO ; TAB1 display YES ;	const int maxl = 2e5 + 10 ; int la , lb ; char s [ maxl ] , t [ maxl ] ; int main ( ) { cin >> la >> lb >> s >> t ; int tar = - 1 ; for ( int i = 0 ; i < la ; ++ i ) if ( s [ i ] == ' * ' ) tar = i ; if ( tar == - 1 ) { if ( la != lb ) { puts ( " NO " ) ; return 0 ; } for ( int i = 0 ; i < la ; ++ i ) if ( s [ i ] != t [ i ] ) { puts ( " NO " ) ; return 0 ; } puts ( " YES " ) ; return 0 ; } if ( la - 1 > lb ) { puts ( " NO " ) ; return 0 ; } for ( int i = 0 ; i < tar ; ++ i ) if ( s [ i ] != t [ i ] ) { puts ( " NO " ) ; return 0 ; } for ( int i = 0 ; la - i - 1 > tar ; ++ i ) if ( s [ la - i - 1 ] != t [ lb - i - 1 ] ) { puts ( " NO " ) ; return 0 ; } puts ( " YES " ) ; return 0 ; }
TAB0 define ints y , n , ans and maxi and arrays org and req with 26 elements each ; TAB0 function ansr with int arguments l and r that returns integer ; TAB1 if l > = r , return l ; TAB1 declare new integer mid with value l + ( r - l ) / 2 ; TAB1 create new integer called o = 0 ; TAB1 for i from 0 to 26 exclusive ; TAB2 if org [ i ] ! = 0 ; TAB3 change o to o + org [ i ] / mid ; TAB3 if org [ i ] % mid is not 0 , change o to o + 1 ; TAB1 if o is greater than n ; TAB2 return the result of ansr ( mid + 1 , r ) ; TAB1 else ; TAB2 return the result of ansr ( l , mid ) ; TAB1 s is a new array of characters with size 1003 ; TAB1 read s ; TAB1 read standard input to n ; TAB1 start for loop from i = 0 to ' \ 0 ' exclusive , , adding 1 to org [ s [ i ] - 97 ] on each loop ; TAB1 for integer i = 0 to 26 exclusive incrementing i ; TAB2 if org [ i ] ! = 0 ; TAB3 increment y ; TAB3 set req [ i ] to 1 ; TAB3 if maxi is less than org [ i ] , change the value of maxi to org [ i ] ; TAB1 if y is greater than n ; TAB2 print " - 1 \ n " ; TAB1 else ; TAB2 change ans to ansr of 1 and maxi ; TAB2 create new ints o and suma = 0 ; TAB2 start for loop from i = 0 to 26 exclusive ; TAB3 if org [ i ] ! = 0 ; TAB4 set o to 0 ; TAB4 increase o by org [ i ] / ans ; TAB4 if org [ i ] % ans ! = 0 , change o to o + 1 ; TAB4 set the value of req [ i ] to o ; TAB4 change suma to suma + o ; TAB2 print ans ; TAB2 for i = 0 to 26 exclusive ; TAB3 while req [ i ] is not 0 , decrement it and print i + 97 converted to char ; TAB2 if suma is less than n ; TAB3 in a for loop , change i from 1 to n - suma inclusive , print ' a ' on each iteration ; TAB2 print new line to the standard output ;	int org [ 26 ] , req [ 26 ] , y , n , ans , maxi ; int ansr ( int l , int r ) { if ( l >= r ) return l ; int mid = l + ( r - l ) / 2 ; int o = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( org [ i ] != 0 ) { o += org [ i ] / mid ; if ( org [ i ] % mid != 0 ) o += 1 ; } if ( o > n ) return ansr ( mid + 1 , r ) ; else return ansr ( l , mid ) ; } int main ( ) { char s [ 1003 ] ; cin >> s ; cin >> n ; for ( int i = 0 ; s [ i ] != ' \0 ' ; i ++ ) org [ s [ i ] - 97 ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( org [ i ] != 0 ) { ++ y ; req [ i ] = 1 ; if ( maxi < org [ i ] ) maxi = org [ i ] ; } if ( y > n ) cout << " -1\n " ; else { ans = ansr ( 1 , maxi ) ; int o = 0 , suma = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( org [ i ] != 0 ) { o = 0 ; o += org [ i ] / ans ; if ( org [ i ] % ans != 0 ) o += 1 ; req [ i ] = o ; suma += o ; } cout << ans << endl ; for ( int i = 0 ; i < 26 ; i ++ ) while ( req [ i ] -- ) cout << ( char ) ( i + 97 ) ; if ( suma < n ) for ( int i = 1 ; i <= n - suma ; i ++ ) cout << ' a ' ; cout << endl ; } return 0 ; }
TAB0 declare new constant integer MAX_N with value 1000 + 10 ; TAB0 declare 3d array of integers a with size MAX_N by 2 by 2 , and b with size 4 by 2 by 2 ; TAB0 check is a new array of booleans with MAX_N elements ; TAB0 boolean function hast with int arguments i and s ; TAB1 change the value of b [ 0 ] [ 0 ] [ 0 ] to a [ i ] [ 0 ] [ 0 ] ; TAB1 assign a [ i ] [ 0 ] [ 1 ] to b [ 0 ] [ 0 ] [ 1 ] ; TAB1 change b [ 0 ] [ 1 ] [ 0 ] to a [ i ] [ 1 ] [ 0 ] ; TAB1 set the value of b [ 0 ] [ 1 ] [ 1 ] to a [ i ] [ 1 ] [ 1 ] ; TAB1 set the value of b [ 1 ] [ 0 ] [ 0 ] to a [ i ] [ 1 ] [ 0 ] ; TAB1 assign the new value = a [ i ] [ 0 ] [ 0 ] to b [ 1 ] [ 0 ] [ 1 ] ; TAB1 assign the new value = a [ i ] [ 1 ] [ 1 ] to b [ 1 ] [ 1 ] [ 0 ] ; TAB1 change the value of b [ 1 ] [ 1 ] [ 1 ] to a [ i ] [ 0 ] [ 1 ] ; TAB1 change b [ 2 ] [ 0 ] [ 0 ] to a [ i ] [ 1 ] [ 1 ] ; TAB1 set b [ 2 ] [ 0 ] [ 1 ] to a [ i ] [ 1 ] [ 0 ] ; TAB1 change the value of b [ 2 ] [ 1 ] [ 0 ] to a [ i ] [ 0 ] [ 1 ] ; TAB1 change the value of b [ 2 ] [ 1 ] [ 1 ] to a [ i ] [ 0 ] [ 0 ] ; TAB1 change b [ 3 ] [ 0 ] [ 0 ] to a [ i ] [ 0 ] [ 1 ] ; TAB1 change the value of b [ 3 ] [ 0 ] [ 1 ] to a [ i ] [ 1 ] [ 1 ] ; TAB1 assign the new value = a [ i ] [ 0 ] [ 0 ] to b [ 3 ] [ 1 ] [ 0 ] ; TAB1 set b [ 3 ] [ 1 ] [ 1 ] to a [ i ] [ 1 ] [ 0 ] ; TAB1 start for loop from i = 0 to 4 exclusive ; TAB2 declare integer variable x with value 0 ; TAB2 start for loop from j = 0 to 2 exclusive incrementing j ; TAB3 start for loop from t = 0 to 2 exclusive ; TAB4 increment x if b [ i ] [ j ] [ t ] = a [ s ] [ j ] [ t ] ; TAB2 if x is equal to 4 , return true ; TAB1 return false ; TAB1 define integers n , aa , bb and ans where ans = 0 ; TAB1 create new string called s ; TAB1 read variable n from the input ; TAB1 for i from 0 to n exclusive ; TAB2 read standard input to aa and bb ; TAB2 if i is less than n - 1 , read s ; TAB2 set a [ i ] [ 0 ] [ 0 ] to aa / 10 ; TAB2 assign aa modulo 10 to a [ i ] [ 0 ] [ 1 ] ; TAB2 set the value of a [ i ] [ 1 ] [ 0 ] to bb / 10 ; TAB2 set the value of a [ i ] [ 1 ] [ 1 ] to bb modulo 10 ; TAB1 start for loop from i = 0 to n exclusive incrementing i ; TAB2 if check [ i ] is true , skip the rest of the loop ; TAB2 in a for loop , change j from i + 1 to n exclusive ; TAB3 if hast ( i , j ) returned true , change the value of check [ j ] to true ; TAB1 for i from 0 to n exclusive ; TAB2 if check [ i ] is false , increment ans ; TAB1 print ans ;	const int MAX_N = 1000 + 10 ; int a [ MAX_N ] [ 2 ] [ 2 ] , b [ 4 ] [ 2 ] [ 2 ] ; bool check [ MAX_N ] ; bool hast ( int i , int s ) { b [ 0 ] [ 0 ] [ 0 ] = a [ i ] [ 0 ] [ 0 ] ; b [ 0 ] [ 0 ] [ 1 ] = a [ i ] [ 0 ] [ 1 ] ; b [ 0 ] [ 1 ] [ 0 ] = a [ i ] [ 1 ] [ 0 ] ; b [ 0 ] [ 1 ] [ 1 ] = a [ i ] [ 1 ] [ 1 ] ; b [ 1 ] [ 0 ] [ 0 ] = a [ i ] [ 1 ] [ 0 ] ; b [ 1 ] [ 0 ] [ 1 ] = a [ i ] [ 0 ] [ 0 ] ; b [ 1 ] [ 1 ] [ 0 ] = a [ i ] [ 1 ] [ 1 ] ; b [ 1 ] [ 1 ] [ 1 ] = a [ i ] [ 0 ] [ 1 ] ; b [ 2 ] [ 0 ] [ 0 ] = a [ i ] [ 1 ] [ 1 ] ; b [ 2 ] [ 0 ] [ 1 ] = a [ i ] [ 1 ] [ 0 ] ; b [ 2 ] [ 1 ] [ 0 ] = a [ i ] [ 0 ] [ 1 ] ; b [ 2 ] [ 1 ] [ 1 ] = a [ i ] [ 0 ] [ 0 ] ; b [ 3 ] [ 0 ] [ 0 ] = a [ i ] [ 0 ] [ 1 ] ; b [ 3 ] [ 0 ] [ 1 ] = a [ i ] [ 1 ] [ 1 ] ; b [ 3 ] [ 1 ] [ 0 ] = a [ i ] [ 0 ] [ 0 ] ; b [ 3 ] [ 1 ] [ 1 ] = a [ i ] [ 1 ] [ 0 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int x = 0 ; for ( int j = 0 ; j < 2 ; j ++ ) for ( int t = 0 ; t < 2 ; t ++ ) if ( b [ i ] [ j ] [ t ] == a [ s ] [ j ] [ t ] ) x ++ ; if ( x == 4 ) return true ; } return false ; } int main ( ) { int n , aa , bb , ans = 0 ; string s ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> aa >> bb ; if ( i < n - 1 ) cin >> s ; a [ i ] [ 0 ] [ 0 ] = aa / 10 ; a [ i ] [ 0 ] [ 1 ] = aa % 10 ; a [ i ] [ 1 ] [ 0 ] = bb / 10 ; a [ i ] [ 1 ] [ 1 ] = bb % 10 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( check [ i ] == true ) continue ; for ( int j = i + 1 ; j < n ; j ++ ) if ( hast ( i , j ) == true ) check [ j ] = true ; } for ( int i = 0 ; i < n ; i ++ ) if ( check [ i ] == false ) ans ++ ; cout << ans << endl ; return 0 ; }
TAB0 create constant integer N with N = 150005 ; TAB0 create integer vector array g with size N ; TAB0 create integers n , m ; TAB0 create integer vector p ; TAB0 declare bfs with integer s as argument , returning pair of long long , long long ; TAB1 set p [ s ] to s ; TAB1 create integer queue q ; TAB1 add s to end of q ; TAB1 create long long ver with ver = 0 ; TAB1 create long long cnted with cnted = 0 ; TAB1 while q is not empty ; TAB2 create integer v with v = front of q ; TAB2 remove next element of q ; TAB2 increment ver ; TAB2 for i = 0 to size of g [ v ] exclusive ; TAB3 create integer to with to = g [ v ] [ i ] ; TAB3 increment cnted ; TAB3 if p [ to ] is - 1 ; TAB4 set p [ to ] to v ; TAB4 add element to to end of q ; TAB1 return new pair created with ( ver , cnted / 2 ) ; TAB1 read n read m ; TAB1 set p to vector integer initialized with ( n , - 1 ) ; TAB1 for i = 0 to m exclusive ; TAB2 create integers x , y ; TAB2 read x read y ; TAB2 decrement x ; TAB2 decrement y ; TAB2 add element y to end of g [ x ] ; TAB2 add element x to end of g [ y ] ; TAB1 for i = 0 to n exclusive ; TAB2 if p [ i ] is - 1 ; TAB3 create pair of long long , long long t with t = result of run bfs with i as argument ; TAB3 if ( first element of t * ( first element of t - 1 ) ) / 2 is not second element of t ; TAB4 print " NO " print newline ; TAB1 print " YES " print newline ;	const int N = 150005 ; vector < int > g [ N ] ; int n , m ; vector < int > p ; pair < long long , long long > bfs ( int s ) { p [ s ] = s ; queue < int > q ; q . push ( s ) ; long long ver = 0 ; long long cnted = 0 ; while ( ! q . empty ( ) ) { int v = q . front ( ) ; q . pop ( ) ; ver ++ ; for ( int i = 0 ; i < g [ v ] . size ( ) ; i ++ ) { int to = g [ v ] [ i ] ; cnted ++ ; if ( p [ to ] == - 1 ) { p [ to ] = v ; q . push ( to ) ; } } } return make_pair ( ver , cnted / 2 ) ; } int main ( ) { cin >> n >> m ; p = vector < int > ( n , - 1 ) ; for ( int i = 0 ; i < m ; i ++ ) { int x , y ; cin >> x >> y ; x -- ; y -- ; g [ x ] . push_back ( y ) ; g [ y ] . push_back ( x ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] == - 1 ) { pair < long long , long long > t = bfs ( i ) ; if ( ( t . first * ( t . first - 1 ) ) / 2 != t . second ) { cout << " NO " << endl ; return 0 ; } } } cout << " YES " << endl ; }
